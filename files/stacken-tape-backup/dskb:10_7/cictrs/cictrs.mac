TITLE	CICTRS - CI Counter Manipulation Utility
SUBTTL	Joseph A. Dziedzic /JAD	17-Jul-85


	SEARCH	GLXMAC		;SEARCH GALAXY PARAMETER FILE
	SALL			;SUPPRESS MACRO EXPANSION
	PROLOG	(CICTRS)	;COMPLETE SETUP

	SEARCH	ORNMAC		;GET PARSER DEFINITIONS
	.TEXT	"/SEGMENT:LOW REL:OPRPAR" ;GET THE PARSER
	EXTERN	PARSER, P$HELP	;GLOBALS IN OPRPAR
	PARSET			;SET UP PARSER DEFINITIONS


;Version information

	CTRVER==1		;MAJOR VERSION NUMBER
	CTRMIN==0		;MINOR VERSION NUMBER
	CTREDT==1		;EDIT LEVEL
	CTRWHO==0		;WHO LAST EDITTED

	%%CTRS==VRSN.(CTR)	;DEFINE VERSION NUMBER


	LOC	137		;STORE VERSION NUMBER IN .JBVER
.JBVER::!EXP	%%CTRS
	RELOC	0		;BACK TO RELOCATABLE

ENTVEC:	JRST	CICTRS		;NORMAL ENTRY
	JRST	CICTRS		;REMOTE ENTRY
	EXP	%%CTRS		;VERSION NUMBER
SUBTTL	Table of Contents
SUBTTL	Revision History


COMMENT	\

Edit	Description

1	JAD, 17-Jul-85.  Create first version.

\; End of Revision History
SUBTTL	Constants and Assembly Parameters


;Indices in read counters argument block

.DGFNC==0			;FUNCTION
.DGSFN==1			;SUB-FUNCTION
TOPS10 <			;IN MONSYM
.DGPVL==2			;JOB WHICH OWNS COUNTERS
.DGPND==3			;MICROCODE VERSION
.DGP0A==4			;PATH A ACKS
.DGP0N==5			;PATH A NAKS
.DGP0R==6			;PATH A NRSP
.DGP1A==7			;PATH B ACKS
.DGP1N==10			;PATH B NAKS
.DGP1R==11			;PATH B NRSP
.DGPDD==12			;DATAGRAMS DISCARDED
.DGPXC==13			;PACKETS TRANSMITTED
.DGPRC==14			;PACKETS RECEIVED
.DGPTG==15			;DESIGNATED PORT (BITS 24-31)
.DGCRC==16			;PACKETS RECEIVED WITH CRC ERRORS
.DGEW1==17			;MOVER PAR ERRS,,CBUS PAR ERRS
.DGEW2==20			;REG PLIPE ERRS,,DATA PLIPE ERRS
.DGEW3==21			;CHAN ERRS,,EBUS PAR ERRS
.DGEW4==22			;SPURIOUS CHAN ERRS,,CBUS AVAIL TIMEOUTS
.DGEW5==23			;SPURIOUS RCV ATTN,,SPURIOUS XMT ATTN
.DGEW6==24			;XMT BUFFER PAR ERRS,,XMT TIMEOUTS
>; END TOPS10
CTRLEN==25			;LENGTH OF BLOCK


;Miscellaneous

ND PDLLEN,200			;DEFAULT LENGTH OF PDL
ND CMD.SZ,1000			;SIZE OF COMMAND DATA BLOCK
ND MAXNDS,20			;MAXIMUM NUMBER OF NODES ON CI BUS
SUBTTL	Parser Keywords



;Keywords defining CI port number

TOPS10 <
	.KYCI0==1000		;CI-0
	.KYCI1==1001		;CI-1
	.KYCI2==1002		;CI-2
	.KYCI3==1003		;CI-3
	.KYCI4==1004		;CI-4
	.KYCI5==1005		;CI-5
> ;END TOPS10


;Keywords used when parsing SET command

	.KYALL==2000		;"ALL"
	.KYAAK==2001		;A-ACK
	.KYANK==2002		;A-NACK
	.KYANR==2003		;A-NRSP
	.KYBAK==2004		;B-ACK
	.KYBNK==2005		;B-NAK
	.KYBNR==2006		;B-NRSP
	.KYDGR==2007		;DATAGRAMS-DISCARDED
	.KYXMT==2010		;TRANSMITTED-PACKETS
	.KYRCV==2011		;RECEIVED-PACKETS
	.KYCLR==2012		;/CLEAR
SUBTTL	Macros


;Macro to generate an error message.  TXT is any valid $TEXT string.
;Branches to ERROR which should reset and start a new command scan.

DEFINE	$ERR(TXT),<
	LSTOF.			;;TURN OFF LISTING
	JSP	TF,ERROR	;;CALL THE ERROR ROUTINE
	CAI	[ITEXT (<TXT>)]	;;ADDRESS OF ITEXT
	LSTON.			;;TURN LISTING BACK ON
>; END DEFINE $ERR
SUBTTL	Data Segment


;Initialization block

IB:	$BUILD	(IB.SZ)		;BUILD INITIALIZATION BLOCK
	  $SET	(IB.PRG,,%%.MOD)	;PROGRAM NAME
	  $SET	(IB.FLG,IT.OCT,1)	;OPEN COMMAND TERMINAL
	  $SET	(IB.FLG,IB.NPF,1)	;NO PAGE FAULT HANDLER
	$EOB			;END OF INITIALIZATION BLOCK
;Impure storage

	$DATA	PDLIST,PDLLEN	;PUSHDOWN LIST

	$DATA	ZCORE,0		;START OF AREA ZEROED AT INITIALIZATION

	$DATA	PARBLK,PAR.SZ	;PARSER CONTROL BLOCK

	$DATA	CMDBLK,CMD.SZ	;COMMAND DATA BLOCK

TOPS10 <$DATA	PRTPDB,<1+6>>	;DYNAMIC PORT NAME PDB

	$DATA	CTRBLK,CTRLEN	;SPACE TO READ PORT COUNTERS

TOPS10 <$DATA	CTXDAT,12>	;CTX. UUO BUFFER

TOPS20 <
	$DATA	FRKRUN		;-1 IF FORK RUNNING
	$DATA	FRKJFN		;JFN OF FORK
	$DATA	FRKHND		;FORK HANDLE
	$DATA	SAVTWD,2	;SAVE TERMINAL WORDS
	$DATA	SAVMOD		;SAVE MODE
>; END TOPS20

	$DATA	EZCORE,0	;END+1 OF AREA ZEROED AT INITIALIZATION
SUBTTL	Initialization


CICTRS:	JFCL			;NO CCL ENTRY
	RESET			;RESET ALL I/O
	MOVE	P,[IOWD PDLLEN,PDLIST] ;SET UP PUSHDOWN LIST

	MOVEI	S1,IB.SZ	;SIZE OF INITIALIZATION BLOCK
	MOVEI	S2,IB		;ADDRESS OF INITIALIZATION BLOCK
	$CALL	I%INIT		;INITIAILIZE GALAXY LIBRARY

	MOVEI	S1,<EZCORE-ZCORE-1> ;LENGTH OF IMPURE STORAGE
	MOVEI	S2,ZCORE	;START OF IMPURE STORAGE
	$CALL	.ZCHNK		;ZERO IMPURE STORAGE

	SETZB	S1,S2		;NO TIMEOUT
	$CALL	P$INIT		;INITIALIZE PARSER ROUTINES

	JRST	GETCMD		;ENTER COMMAND PARSING LOOP
SUBTTL	Command Parsing Loop


GETCMD:	MOVE	P,[IOWD PDLLEN,PDLIST] ;RESET STACK POINTER EACH LOOP

	MOVEI	S1,INIFDB	;SET UP PARSER CONTROL BLOCK
	MOVEM	S1,PARBLK+PAR.TB
	MOVEI	S1,[ASCIZ /CICTRS>/] ;SET UP ADDRESS OF PROMPT
	MOVEM	S1,PARBLK+PAR.PM
	MOVEI	S1,CMDBLK	;SET UP ADDRESS OF BLOCK TO STORE COMMAND DATA
	MOVEM	S1,PARBLK+PAR.CM
	SETZM	PARBLK+PAR.SR	;DON'T RESCAN LAST LINE

	MOVEI	S1,CMD.SZ	;LENGTH OF COMMAND DATA AREA
	MOVEI	S2,CMDBLK	;ADDRESS OF COMMAND DATA AREA
	$CALL	.ZCHNK		;ZERO COMMAND DATA AREA

	MOVEI	S1,COM.SZ-1	;SET UP INITIAL SIZE OF COMMAND BLOCK
	STORE	S1,CMDBLK+.MSTYP,MS.CNT

	MOVEI	S1,PAR.SZ	;LENGTH OF PARSER BLOCK
	MOVEI	S2,PARBLK	;ADDRESS OF PARSER BLOCK
	$CALL	PARSER		;PARSE THE COMMAND
	JUMPT	GETCM1		;JUMP IF PARSE SUCCESSFUL

CMDERR:	MOVE	S1,PRT.FL(S2)	;GET FLAGS
	MOVE	S2,PRT.EM(S2)	;GET ADDRESS OF ERROR TEXT
	TXNE	S1,P.CEOF	;END OF FILE ON RESCAN?
	 MOVEI	S2,[ASCIZ /Invalid command terminator/]
	$TEXT	,<?^T/(S2)/>	;TYPE ERROR MESSAGE
	JRST	GETCMD		;AND TRY AGAIN

GETCM1:	MOVEI	S1,CMDBLK+COM.SZ ;POINT TO FIRST ARGUMENT
	$CALL	P$SETU		;SET UP FOR SECOND PASS
	$CALL	P$KEYW		;GET THE KEYWORD VALUE
	JUMPT	GETCM2		;JUMP IF PARSE SUCCESSFUL
	$TEXT	,<?Internal command table error>
	JRST	GETCMD		;TRY AGAIN

GETCM2:	$CALL	(S1)		;CALL THE COMMAND PROCESSOR
	JRST	GETCMD		;AND PROMPT FOR NEXT COMMAND


ERROR:	MOVE	TF,@TF		;GET ADDRESS OF ERROR ITEXT
	$TEXT	,<?^I/@TF/>	;PRINT ERROR MESSAGE PRECEDED BY Q-MARK
	JRST	GETCMD		;START OVER
SUBTTL	Command Parse Tables


INIFDB:	$INIT	(KEYFDB)

KEYFDB:	$KEYDSP	(CMDTAB)

CMDTAB:	$STAB
TOPS10 < DSPTAB	(,EXICMD,\".CHCNZ,CM%INV) >
	 DSPTAB	(EXIFDB,EXICMD,<EXIT>)
	 DSPTAB	(HLPFDB,HLPCMD,<HELP>)
	 DSPTAB	(PSHFDB,PSHCMD,<PUSH>)
	 DSPTAB	(SETFDB,SETCMD,<SET>)
	 DSPTAB	(SHOFDB,SHOCMD,<SHOW>)
	$ETAB

EOLFDB:	$CRLF
SUBTTL	EXIT Command Tables


EXIFDB:	$NOISE	(EOLFDB,<from CICTRS>)
SUBTTL	HELP Command Tables


	ND	CR.ADR,4	;ADDRESS OF CURRENT ARGUMENT

HLPFDB:	$NOISE	(HLP001,<with>)

HLP001:	$CTEXT(,<command>,<$ACTION(HLPACT),$DEFAULT(HELP)>)

HLPACT:	MOVE	S2,CR.ADR(S2)	;GET THE DATA
	HRROI	S2,ARG.DA(S2)	;POINT TO THE STRING
	MOVEI	S1,HLPFD	;POINT TO HELP FILE FD
	$CALL	P$HELP		;HELP THEM IF WE CAN
	$CALL	P$NPRO		;MARK NO PROCESSING
	$RETT			;RETURN

;File descriptor for help file for CICTRS

TOPS10 <
HLPFD:	$BUILD	(FDMSIZ)	;BUILD FILE DESCRIPTOR BLOCK
	  $SET	(.FDLEN,FD.LEN,FDMSIZ)	;SIZE OF FD
	  $SET	(.FDSTR,,'HLP   ')	;DEVICE
	  $SET	(.FDNAM,,'CICTRS')	;FILE NAME
	  $SET	(.FDEXT,,'HLP   ')	;EXTENSION
	$EOB			;END OF HELP FILE DESCRIPTOR BLOCK
>; END TOPS10
TOPS20 <
HLPFD:	XWD	HSIZ,0		;SIZE,,TYPE
	ASCIZ	/HLP:CICTRS.HLP/
HSIZ==.-HLPFD			;SIZE
>; END TOPS20
SUBTTL	PUSH command tables


PSHFDB:	TOPS10	<$NOISE	(PUS100,<to monitor level>)>
	TOPS20	<$NOISE	(PUS100,<to EXEC level>)>

PUS100:	$CRLF	(<$ACTION(PUSHRT)>)
SUBTTL	SET Command Tables


SETFDB:
TOPS10 <
	$NOISE	(SET010,<CI port counters of>,$PREFILL(PRTINI))

SET010:	$KEY	(SET020,PRTPDB)

SET020:	$NOISE	(SET030,<to monitor CI node>)
>; END TOPS10
TOPS20 <
	$NOISE	(SET030,<CI port counters to monitor CI node>)
>; END TOPS20

SET030:	$NUMBER	(SET100,^D10,<CI node number>,<$ALTER(SET040),$ACTION(CHKNOD)>)

SET040:	$KEYDSP	(SET050)

SET050:	$STAB
	DSPTAB	(SET100,.KYALL,<ALL>)
	$ETAB

SET100:	$NOISE	(SET110,<counter>)

SET110:	$KEY	(SET130,SET120,$ALTER(SET200))

SET120:	$STAB
	KEYTAB	(.KYAAK,<A-ACKS>)
	KEYTAB	(.KYANK,<A-NAKS>)
	KEYTAB	(.KYANR,<A-NRSP>)
	KEYTAB	(.KYBAK,<B-ACKS>)
	KEYTAB	(.KYBNK,<B-NAKS>)
	KEYTAB	(.KYBNR,<B-NRSP>)
	KEYTAB	(.KYDGR,<DATAGRAMS-DISCARDED>)
	KEYTAB	(.KYXMT,<TRANSMITTED-PACKETS>)
	KEYTAB	(.KYRCV,<RECEIVED-PACKETS>)
	$ETAB

SET130:	$COMMA	(SET140,<$ALTER(SET300),$HELP(comma to specify another counter)>)

SET140:	$KEY	(SET130,SET120,$ALTER(SET300))

SET200:	$KEYDSP	(SET210,$ALTER(SET300))

SET210:	$STAB
	DSPTAB	(SET300,.KYALL,<ALL>)
	$ETAB

SET300:	$SWITCH	(EOLFDB,SET310,$ALTER(EOLFDB))

SET310:	$STAB
	KEYTAB	(.KYCLR,<CLEAR>)
	$ETAB
;ACTION ROUTINE CALLED ON SET COMMAND TO CHECK LEGALITY OF
;CI NODE NUMBER ARGUMENT.

CHKNOD:	SKIPL	S1,CR.RES(S2)	;CHECK THAT NUMBER
	CAIL	S1,MAXNDS	;MUST BE .GE. 0 AND .LT. MAXNDS
	SKIPA			;IT'S BAD
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ /Invalid CI node number/]
	$RETF

FIXIT:	HRRZ	T4,CR.FLG(S2)	;GET ADR OF CMDBLK
	MOVE	T1,.CMPTR(T4)	;GET COMMAND POINTER
	MOVE	T2,.CMABP(T4)	;GET BP TO ATOM BUFFER
FIXI.1:	ILDB	T3,T2
	JUMPE	T3,FIXI.2	;DONE.. ALL FIXED UP
	MOVNI	T3,1		;DECREMENT THE BP
	ADJBP	T3,T1		;...
	MOVE	T1,T3		;...
	AOS	.CMCNT(T4)
	JRST	FIXI.1		;TRY NEXT CHARACTER

FIXI.2:	MOVEM	T1,.CMPTR(T4)	;STORE ADJUSTED BP
	POPJ	P,
SUBTTL	SHOW Command Tables


SHOFDB:
TOPS10 <
	$NOISE	(SHO010,<CI port counters of>,$PREFILL(PRTINI))

SHO010:	$KEY	(EOLFDB,PRTPDB)
>; END TOPS10
TOPS20 <
	$NOISE	(EOLFDB,<CI port counters>)
>; END TOPS20
SUBTTL	Dynamic Port Name Initialization


TOPS10 <
PRTINI:	$SAVE	<P1,P2>		;SAVE SOME AC'S
	MOVSI	P1,-6		;MAXIMUM NUMBER OF CPU'S WHICH MIGHT EXIST
	SETZ	P2,		;START WITH FIRST KEYWORD SLOT
PRTI.1:	HRRZ	S1,P1		;GET CPU NUMBER
	LSH	S1,1		;TIMES TWO
	ADDX	S1,%CCCIP	;OFFSET TO CI PORT CONTROL BLOCK GETTAB
	GETTAB	S1,		;DO IT
	  SETZ	S1,		;ASSUME NONE
	JUMPE	S1,PRTI.2	;JUMP IF NO CI PORT ON THIS CPU
	MOVE	S1,PRTKEY(P1)	;GET KEYWORD ENTRY FOR THIS PORT
	MOVEM	S1,PRTPDB+1(P2)	;STORE IN TABLE
	ADDI	P2,1		;OFFSET TO NEXT SLOT
PRTI.2:	AOBJN	P1,PRTI.1	;LOOP FOR REMAINDER
	HRLS	P2		;MOVE COUNT TO LH ALSO
	MOVEM	P2,PRTPDB	;SAVE COUNT IN HEAD OF TABLE
	$RETT			;RETURN


;Table of keyword entries for possible CI ports

PRTKEY:	KEYTAB	(.KYCI0,<CI-0>)	;CI-0
	KEYTAB	(.KYCI1,<CI-1>)	;CI-1
	KEYTAB	(.KYCI2,<CI-2>)	;CI-2
	KEYTAB	(.KYCI3,<CI-3>)	;CI-3
	KEYTAB	(.KYCI4,<CI-4>)	;CI-4
	KEYTAB	(.KYCI5,<CI-5>)	;CI-5
>; END TOPS10
SUBTTL	SET Command Processing


SETCMD:
TOPS10 <
	$CALL	P$KEYW		;GET THE KEYWORD (CI PORT NUMBER)
	$RETIF			;IF ERROR
	MOVE	P1,S1		;SAVE IT HERE
>; END TOPS10
	$CALL	P$NUM		;GET THE NODE NUMBER
	JUMPF	SETC.1		;POSSIBLY "ALL"
	MOVE	P2,S1		;SAVE NODE NUMBER
	JRST	SETC.2		;REJOIN COMMON CODE

SETC.1:	$CALL	P$KEYW		;SEE IF "ALL"
	$RETIF			;GUESS NOT
	CAXE	S1,.KYALL	;WAS IT "ALL"?
	$RETF			;NO, ERROR
	SETO	P2,		;FLAG FOR ALL NODES
SETC.2:	SETZ	P3,		;ASSUME THEY WILL SPECIFY SOME COUNTERS
	$CALL	P$CFM		;SEE IF EOL
	JUMPT	[MOVSI	P3,^B101010101010101010 ;LOAD BITS FOR ALL COUNTERS
		 JRST	SETCTR]	;GO SET THE COUNTERS
	$CALL	P$KEYW		;SHOULD BE SOME SORT OF KEYWORD
	$RETIF			;IF ERROR
	CAXE	S1,.KYALL	;WAS IT ALL-COUNTERS?
	JRST	SETC.3		;NO
	MOVSI	P3,^B101010101010101010 ;LOAD BITS FOR ALL COUNTERS
	JRST	SETC.4		;SEE IF SWITCH COMING

SETC.3:	CAIL	S1,.KYAAK	;IS IT A KNOWN KEYWORD?
	CAILE	S1,.KYRCV	;...
	$RETF			;NO, ERROR
	TDO	P3,CTRBIT-.KYAAK(S1) ;SET THE BIT
	$CALL	P$COMMA		;SEE IF COMMA
	JUMPF	SETC.4		;SEE IF SWITCH COMING
	$CALL	P$KEYW		;GET NEXT KEYWORD
	$RETIF			;IF ERROR
	JRST	SETC.3		;TRY FOR ANOTHER COUNTER NAME

SETC.4:	$CALL	P$SWIT		;SEE IF A SWITCH
	JUMPF	SETCTR		;NO
	CAXE	S1,.KYCLR	;SHOULD BE THIS ONE
	$RETF			;NO, ERROR
	MOVE	S1,P3		;GET THE BITS
	LSH	S1,-1		;POSITION THEM
	IOR	P3,S1		;SET THE CLEAR BITS AS APPROPRIATE
SETCTR:
TOPS10 <MOVSI	T1,-.KYCI0(P1)>	;GET CPU NUMBER
TOPS20 <SETZ	T1,>		;NO CPU NUMBER
	HRRI	T1,.DIACC	;FUNCTION TO MANIPULATE PORT COUNTERS
	MOVE	T2,[7,,.DICGT]	;KLIPA CHANNEL,,SUB-FUNCTION TO GET COUNTERS
	MOVE	S1,[-2,,T1]	;POINT AT ARGUMENTS
	$CALL	DODIAG		;DO THE UUO/JSYS
	  JUMPF	GETERR		;IF ERROR
	HRRI	T2,.DICPT	;SUB-FUNCTION TO POINT COUNTERS
	MOVE	T3,P3		;GET MASK FOR COUNTERS
	MOVE	T4,P2		;GET NODE NUMBER
	MOVE	S1,[-4,,T1]	;POINT AT ARGUMENTS
	$CALL	DODIAG		;DO THE UUO/JSYS
	  JUMPF	PNTERR		;IF ERROR
	HRRI	T2,.DICRL	;SUB-FUNCTION TO RELEASE COUNTERS
	MOVE	S1,[-2,,T1]	;POINT AT ARGUMENTS
	$CALL	DODIAG		;DO THE UUO/JSYS
	  JUMPF	RLSERR		;IF ERROR
	$RETT			;ALL DONE
;Table of bits for port counters indexed by counter name keyword

CTRBIT:	1B0			;A-ACKS
	1B2			;A-NAKS
	1B4			;A-NRSP
	1B6			;B-ACKS
	1B8			;B-NAKS
	1B10			;B-NRSP
	1B12			;DATAGRAMS-DISCARDED
	1B14			;TRANSMITTED-PACKETS
	1B16			;RECEIVED-PACKETS
SUBTTL	SHOW Command Processing


SHOCMD:
TOPS10 <
	$CALL	P$KEYW		;GET THE KEYWORD (CI PORT NUMBER)
	$RETIF			;IF ERROR
	MOVSI	T1,-.KYCI0(S1)	;GET CPU NUMBER
>; END TOPS10
TOPS20 <SETZ	T1,>		;NO CPU NUMBER
	HRRI	T1,.DIACC	;FUNCTION TO MANIPULATE PORT COUNTERS
	MOVEM	T1,CTRBLK+.DGFNC ;SAVE FUNCTION WORD
	MOVE	T1,[7,,.DICRD]	;KLIPA CHANNEL,,SUB-FUNCTION TO READ COUNTERS
	MOVEM	T1,CTRBLK+.DGSFN ;SAVE SUB-FUNCTION WORD
	MOVE	S1,[-CTRLEN,,CTRBLK] ;POINT AT THE ARGUMENTS
	$CALL	DODIAG		;DO THE UUO/JSYS
	  JUMPF	REDERR		;IF ERROR

	$TEXT	,<^M^JCounters read at ^H/[-1]/>
	LDB	S1,[POINT 8,CTRBLK+.DGPTG,31] ;GET SELECTED NODE
	CAIE	S1,377		;WAS IT ALL NODES?
	SKIPA	S2,[[ITEXT(^D/S1/)]] ;NO, GET APPROPRIATE ITEXT
	MOVEI	S2,[ITEXT (ALL)] ;YES, GET APPROPRIATE ITEXT
	$TEXT	,<Selected node: ^I/0(S2)/>
	$TEXT	,<CI-20 microcode version: ^O/CTRBLK+.DGPND/>
	$TEXT	,<Path A:   ACK count: ^D/CTRBLK+.DGP0A/  NAK count: ^D/CTRBLK+.DGP0N/  No response count: ^D/CTRBLK+.DGP0R/>
	$TEXT	,<Path B:   ACK count: ^D/CTRBLK+.DGP1A/  NAK count: ^D/CTRBLK+.DGP1N/  No response count: ^D/CTRBLK+.DGP1R/>
	$TEXT	,<Datagrams discarded: ^D/CTRBLK+.DGPDD/>
	$TEXT	,<Packets transmitted: ^D/CTRBLK+.DGPXC/>
	$TEXT	,<Packets received: ^D/CTRBLK+.DGPRC/>
	$TEXT	,<Packets received with CRC errors: ^D/CTRBLK+.DGCRC/>
	$TEXT	,<Mover parity errors: ^D/CTRBLK+.DGEW1,LHMASK/>
	$TEXT	,<CBUS parity errors: ^D/CTRBLK+.DGEW1,RHMASK/>
	$TEXT	,<Register PLIPE errors: ^D/CTRBLK+.DGEW2,LHMASK/>
	$TEXT	,<Data PLIPE errors: ^D/CTRBLK+.DGEW2,RHMASK/>
	$TEXT	,<Channel errors: ^D/CTRBLK+.DGEW3,LHMASK/>
	$TEXT	,<EBUS parity errors: ^D/CTRBLK+.DGEW3,RHMASK/>
	$TEXT	,<Spurious channel errors: ^D/CTRBLK+.DGEW4,LHMASK/>
	$TEXT	,<CBUS available timeouts: ^D/CTRBLK+.DGEW4,RHMASK/>
	$TEXT	,<Spurious receive attentions: ^D/CTRBLK+.DGEW5,LHMASK/>
	$TEXT	,<Spurious transmit attentions: ^D/CTRBLK+.DGEW5,RHMASK/>
	$TEXT	,<Transmit buffer parity errors: ^D/CTRBLK+.DGEW6,LHMASK/>
	$TEXT	,<Transmit timeouts: ^D/CTRBLK+.DGEW6,RHMASK/^M^J>
	$RETT			;ALL DONE
SUBTTL	PUSHRT	Process the PUSH command


TOPS10	<
PUSHRT::$CALL	P$NPRO##		;NO PROCESSING REQUIRED
	MOVEI	S1,CTXARG		;POINT TO ARGUMENT BLOCK
	CTX.	S1,			;PUSH
	  SKIPA				;FAILED
	$RETT				;AND RETURN
	MOVEI	S2,CTXER1		;DEFAULT TO GENERIC MESSAGE
	CAIN	S1,CTXARG		;IMPLEMENTED?
	MOVEI	S2,CTXER0		;NO
	TXNE	S1,CT.ETX		;ERROR TEXT RETURNED IN BUFFER?
	MOVEI	S2,CTXER2		;YES
	TXNE	S1,CT.RUN		;RUN UUO ERROR?
	MOVEI	S2,CTXER3		;YES
	$TEXT	(,<?Cannot save context; ^I/(S2)/>)
	$RETT				;RETURN

CTXARG:	$BUILD	(.CTMAX)		;BLOCK LENGTH
	  $SET	(.CTFNC,CT.LEN,.CTMAX)	  ;SET LENGTH
	  $SET	(.CTDBL,,12)		  ;SET DATA BLOCK LENGTH
	  $SET	(.CTDBA,,CTXDAT)	  ;SET DATA BLOCK ADDRESS
	$EOB				;END OF BLOCK

CTXER0:	ITEXT	(<CTX. UUO not implemented>)
CTXER1:	ITEXT	(<CTX. UUO error ^O/S1,CT.ERR/>)
CTXER2:	ITEXT	(<^T/CTXDAT/>)
CTXER3:	ITEXT	(<RUN UUO error ^O/S1,CT.ERR/>)

> ;END TOPS-10 CONDITIONAL
TOPS20	<
PUSHRT::$CALL	P$NPRO##		;NO PROCESSING REQUIRED
	SKIPE	S1,FRKHND		;ALREADY HAVE A FORK WITH EXEC
	JRST	PUSH.1			;GO TO PUSH RETURN
	MOVX	S1,GJ%SHT!GJ%OLD	;SHORT FORM, OLD FILE
	HRROI	S2,[ASCIZ/SYSTEM:EXEC.EXE/]
	GTJFN
	   JRST	NOEXEC			;NO EXEC
	MOVEM	S1,FRKJFN		;SAVE FORK JFN
	MOVX	S1,CR%CAP		;GIVE FORK CAPABILITIES
	CFORK				;CREATE THE FORK
	  JRST NOFORK
	MOVEM	S1,FRKHND		;SAVE FORK HANDLE
	HRLZS	S1			;PLACE IN LEFT HALF
	HRR	S1,FRKJFN		;JFN IN THE FIGHT HALF
	GET				;NOW GET THE EXEC INTO THE LOWER FORK
	MOVEI	S1,.FHSLF		;DONT ALLOW LOWER FORK TO LOG OUT
	RPCAP				;GET CAPABILITIES OF INFERIOR
	TXZ	S2,SC%LOG		;DO NOT ALLOW LOGOUT
	SETZ	T1,			;NO PRIVILEGES ENABLED
	MOVE	S1,FRKHND		;GET THE FORK HANDLE
	EPCAP				;SET ITS CAPABILITIES
	  ERJMP NOCAP			;TRAP THE ERROR
	MOVEI	S1,.FHJOB		;GET THE JOB HANDLE
	TXO	S1,RT%DIM		;GET DEFERRED ALSO
	RTIW				;READ TERMINAL INTERRUPT CHARACTERS
	DMOVEM	S2,SAVTWD		;SAVE TERMINAL WORDS
	MOVEI	S1,.PRIIN		;PRIMARY INPUT JFN
	RFMOD				;GET THE MODE
	MOVEM	S2,SAVMOD		;SAVE THE MODE
	MOVE	S1,FRKHND		;GET THE FORK HANDLE
PUSH.1:	SETZ	S2,			;USE PRIMARY START ADDRESS
	SFRKV				;START THE EXEC
	SETOM	FRKRUN			;SETOM FORK RUN
	$RETT				;RETURN

NOEXEC:	MOVEI	S2,[ASCIZ/Unable to find SYSTEM:EXEC.EXE for PUSH command/]
	$RETF				;RETURN FALSE
NOFORK:	MOVEI	S2,[ASCIZ/Unable to create fork for PUSH command/]
	$RETF				;RETURN FALSE
NOCAP:	MOVE	S1,FRKHND		;GET THE FORK HANDLE
	KFORK				;KILL THE PROCESS
	ERJMP	.+1			;IGNORE THE ERROR
	SETZM	FRKHND			;CLEAR THE FORK HANDLE
	MOVEI	S2,[ASCIZ/Unable to enable forks capabilities for PUSH command/]
	$RETF				;RETURN FALSE
> ;End TOPS20
SUBTTL	Miscellaneous Simple Commands


EXICMD:	PJRST	I%EXIT		;CALL IT QUITS


HLPCMD:	$RETT			;NOTHING TO DO, PARSER ALREADY DID IT


PSHCMD:	$RETT			;NOTHING TO DO, WE ALREADY DID IT
SUBTTL	Diagnostic UUO/JSYS


;Routine to execute a DIAG. UUO/JSYS, returning FALSE if an error
;occurred.  Call with S1 containing a pointer to the argument block.

DODIAG:
TOPS10 <
	DIAG.	S1,		;DO THE UUO
	  $RETF			;ERROR
	$RETT			;SUCCESS
>; END TOPS10
TOPS20 <
	DIAG%			;DO THE JSYS
	  ERJMP	.RETF		;ERROR
	$RETT			;SUCCESS
>; END TOPS20


;Here on errors

GETERR:	MOVEI	S2,[ASCIZ /gett/] ;GET TEXT
	JRST	DIAERR		;JOIN COMMON CODE

PNTERR:	MOVEI	S2,[ASCIZ /point/] ;GET TEXT
	JRST	DIAERR		;JOIN COMMON CODE

RLSERR:	MOVEI	S2,[ASCIZ /releas/] ;GET TEXT
	JRST	DIAERR		;JOIN COMMON CODE

REDERR:	MOVEI	S2,[ASCIZ /read/] ;GET TEXT
	JRST	DIAERR		;JOIN COMMON CODE
DIAERR:
TOPS10 <
	MOVE	T1,S1			;COPY ERROR CODE
	CAIL	T1,DIAETL		;ERROR NUMBER IN RANGE?
	MOVEI	T1,DIAETL		;NO, SOMETHING REALLY WRONG
	$ERR	(<DIAG. UUO error (^O/S1/) ^T/@DIAETX(T1)/ ^T/0(S2)/ing CI port counters>)
>; END TOPS10
TOPS20 <
	MOVX	S1,.FHSLF		;FOR SELF,
	GETER%				;LOOK UP MOST RECENT ERROR
	  ERJMP	.+1			;IGNORE ANY ERRORS
	$ERR	(<DIAG% JSYS error ^E/S1,RHMASK/ ^T/0(S2)/ing CI port counters>)
>; END TOPS20

TOPS10 <
DIAETX:	[ASCIZ	/no such error code/]
	[ASCIZ	/not privileged/]
	[ASCIZ	/illegal number of arguments/]
	[ASCIZ	/illegal controller/]
	[ASCIZ	/illegal unit/]
	[ASCIZ	/some units already assigned/]
	[ASCIZ	/unit not in diagnostic mode/]
	[ASCIZ	/unit assigned to another job/]
	[ASCIZ	/no free core/]
	[ASCIZ	/no assigned units/]
	[ASCIZ	\I/O word crosses a page boundary\]
	[ASCIZ	/illegal function/]
	[ASCIZ	/job can't be virtual/]
	[ASCIZ	/no such CPU/]
	[ASCIZ	/CPU not running/]
	[ASCIZ	/bad argument list/]
	[ASCIZ	/no CI port on CPU/]
	[ASCIZ	/read CI port counters timed out/]
	[ASCIZ	/no NI port on CPU/]
	[ASCIZ	/microcode reload failed/]
	[ASCIZ	/microcode not available/]
	[ASCIZ	/CI port not running/]
DIAETL==.-DIAETX
	[ASCIZ	/unknown error code/]
>; END TOPS10
SUBTTL	The End


TOPS10 <END	CICTRS>		;END OF CICTRS
TOPS20 <END	<3,,ENTVEC>>	;ENTRY VECTOR DEFINITION
