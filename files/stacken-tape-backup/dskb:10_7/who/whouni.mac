	TITLE	UNISCN - UNIT mode scan defaulting for WHO

	SEARCH	WHOMAC

	$SETUP	(UNISCN)

Comment |

This module provides the UNIT mode specific scan defaulting code. Its
only entry point is UNISCN.

|
;               TABLE OF CONTENTS FOR UNISCN
;
;
;                        SECTION                                   PAGE
;    1. UNISCN - Apply STRUCTURE mode specific scan input defaults   3
;    2. Storage...................................................   4
	SUBTTL	UNISCN - Apply UNIT mode specific scan input defaults

;This routine applies the following defaults to the command line
;

UNISCN::SKIPE	.FXEXT(I)		;INSURE NO EXTENSION
	$FATAL	(EIC,<Extension illegal in this context>)

; Check for UNI:
	MOVX	T1,FX.NDV		;AND THE NULL DEVICE BIT
	TDNE	T1,.FXMOD(I)		;DEVICE SPECIFIED?
	JRST	UNISC1			;NO
	SKIPE	.FXNAM(I)		;IS THE FILENAME WORD NON-ZERO?
	$FATAL (MUG,<Multiple unit names given>)
	MOVE	T1,.FXDEV(I)		;GET DEVICE NAME
	PUSHJ	P,UNIMSK		;GENERATE A MASK
	JRST	UNISC4			;ENTER COMMON CODE

; Check for UNI
UNISC1:	SKIPN	T1,.FXNAM(I)		;GET UNIt NAME FROM FILE NAME WORD
	JRST	UNISC3			;THERE ISN'T ONE
	MOVE	T2,.FXNMM(I)		;GET MASK
	CAMN	T2,[EXP -1]		;NEED TO FIX IT UP?
	PUSHJ	P,UNIMSK		;YES--GENERATE NEW MASK
	JRST	UNISC4			;ONWARD

; Check for /UNIT
UNISC3:	SKIPN	T1,.FZSTN##(I)		;GET NAME FROM SWITCH ARGUMENT
	JRST	UNISC4			;NONE GIVEN
	MOVE	T2,.FZSTM##(I)		;GET MASK
	MOVEM	T2,.FXNMM(I)		;STORE
	CAMN	T2,[EXP -1]		;WILDCARDS SPECIFIED?
	PUSHJ	P,UNIMSK		;GENERATE A MASK

; Here to check for conflicts
UNISC4:	CHKSWT	(UNN,UNIT)		;CHECK FOR CONFLICTS
	MOVE	T1,.FXNMM(I)		;GET NAME MASK
	MOVEM	T1,.FZUNM##(I)		;STORE AS UNIT MASK
	POPJ	P,			;AND RETURN
; Here to generate a mask based on the unit name
UNIMSK:	MOVEM	T1,.FXNAM(I)		;UPDATE UNIT NAME
	TRNN	T1,777777		;UNIT NUMBER SPECIFIED?
	JRST	UNIMS1			;NO
	SETOM	.FXNMM(I)		;NO WILDCARDING
	POPJ	P,			;RETURN
UNIMS1:	SETZ	T2,			;CLEAR NEW MASK
	EXCH	T1,T2			;GET STR NAME
	MOVEI	T3,6			;LOOP FOR 6 CHARACTERS
UNIMS2:	LSHC	T1,6			;SHIFT IN A CHARACTER
	TRON	T1,77			;MASK CHARACTER
	TRZ	T1,77			;ELSE MAKE IT LOOK WILD
	SOJG	T3,UNIMS2		;LOOP
	MOVEM	T1,.FXNMM(I)		;STORE IT
	MOVE	T1,.FXNAM(I)		;RELOAD THE NAME
	POPJ	P,			;RETURN
	SUBTTL	Storage

	$LOW

	PRGEND
	TITLE	UNIGET - Get UNIT information

	SEARCH	WHOMAC
	$SETUP	(UNIGET)

;               TABLE OF CONTENTS FOR UNIGET
;
;
;                        SECTION                                   PAGE
;    1. Main UNIT routines
;         1.1   UNINXT - Get the next unit...................   3
;         1.2   UNISET - Setup for a new unit................   4
;         1.3   UNIINC - Handle incremental statistics............   5
;         1.4   UNISRT - Handle unit sorting.................   6
;    2. UNIT tables
;         2.1   Define all unit subfields....................   7
;    3. DATA STORAGE..............................................  12
	SUBTTL	Main UNIT routines -- UNINXT - Get the next unit

UNINXT::JUMPL	O,UNINX1		;JUMP IF THE FIRST TIME
	SKIPL	S.SORT##		;SEE IF /SORT
	 JRST	SRTNXT			;YES--GET NEXT UNIT
	ADDI	O,1			;NO--BUMP TO NEXT
	CAILE	O,LN$UNI		;SEE IF PAST END
	 POPJ	P,			;YES--RETURN
	JRST	UNINX2			;NO--SETUP FOR THIS UNIT

UNINX1:	MOVEI	T1,LN$UNI		;MAX UNIT INDEX
	MOVEM	T1,MAXUNI		;SAVE
	MOVEI	T1,^D10			;SET A HASH TABLE LENGTH
	MOVEI	T2,^D2			;AND SIZE OF ENTRY
	PUSHJ	P,.HASHI##		;INIT IT
	MOVEI	O,0			;START WITH UNIT 0
	SKIPL	T1,S.SORT##		;GET /SORT
	 JRST	UNISRT			;GO PROCESS IF GIVEN

UNINX2:	PUSHJ	P,UNISET		;SETUP FOR THIS UNIT
	 JRST	UNINXT			;NOT ASSIGNED
	JRST	.POPJ1##		;AND RETURN
	SUBTTL	Main UNIT routines -- STRSET - Setup for a new unit

UNISET::SKIPE	JP,UNICOR		;SEE IF CORE ALLOCATED YET
	 JRST	UNIS.C			;YES
	MOVEI	T1,.UBLEN		;NO--GET SIZE
	PUSHJ	P,M$ALLOC##		;GET CORE
	MOVEM	T1,UNICOR		;SAVE STARTING ADDRESS
	MOVEI	JP,(T1)			;AND INTO JP
UNIS.C:	HRLI	T1,(JP)			;GET STARTING ADDRESS
	HRRI	T1,1(JP)		;ENDING ADDRESS
	SETOM	(JP)			;SET FIRST WORD TO -1
	BLT	T1,.UBLEN-1(JP)		;AND SET THEM ALL TO -1
	MOVEI	T1,(O)			;GET UNIT INDEX
	PJRST	UNII2N##		;CONVERT INDEX TO UNIT NAME AND RETURN
	SUBTTL	Main UNIT routines -- UNIINC - Handle incremental statistics

UNIINC::
UNIINJ:	POPJ	P,			;NONE FOR NOW
	SUBTTL	Main UNIT routines -- UNISRT - Handle unit sorting

UNISRT:	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVEI	P1,(T1)			;SAVE SORT INDEX
	MOVE	T1,MAXUNI		;GET MAX UNITS
	IMULI	T1,2			;2 WORD TABLE
	MOVN	T2,T1			;NEGATE INTO T2
	HRLZM	T2,SRTTAB		;SAVE -N,,0
	PUSHJ	P,I$ALLOC##		;GET THE CORE
	HRRM	T1,SRTTAB		;SAVE START
SRTJ.1:	PUSHJ	P,UNISET		;SETUP FOR THIS UNIT
	 JRST	SRTJ.2			;NOT ASSIGNED
	PUSHJ	P,@SUMLOD##(P1)		;GET SORT KEY
	MOVEI	T2,-1(O)		;GET UNIT
	IMULI	T2,2			;DOUBLE
	ADD	T2,SRTTAB		;PLUS START OF TABLE
	MOVEM	T1,(T2)			;SAVE SORT KEY FIELD
	MOVEM	O,1(T2)			;SAVE UNIT INDEX
SRTJ.2:	ADDI	O,1			;BUMP TO NEXT UNIT
	CAMG	O,MAXUNI		;ALL DONE?
	 JRST	SRTJ.1			;NO--ADVANCE TO NEXT
	MOVE	T1,SRTTAB		;GET AOBJN WORD
	MOVE	T2,[400000,,2]		;UNSIGNED AND STRAIGHT SORT
	SKIPLE	S.SORT##+1		;SEE IF DESCENDING
	 TLO	T2,200000		;YES-SET FLAG
	PUSHJ	P,.SORT2##		;SORT THE LIST
	MOVE	T1,SRTTAB		;GET AOBJN
	MOVEM	T1,SRTPTR		;SAVE
	SETZM	SRTCNT			;NO UNITS YET
	JRST	UNINXT			;AND BACK TO THE TOP


SRTNXT:	SKIPL	T1,SRTPTR		;GET POINTER
	 POPJ	P,			;ALL DONE
	SKIPN	O,1(T1)			;GET UNIT INDEX
	 JRST	UNIS.1			;NONE
	PUSHJ	P,UNISET		;SETUP FOR THIS UNIT
	 JRST	UNIS.1			;NOT ASSIGNED NOW?
	AOS	T1,SRTCNT		;COUNT THE UNITS
	CAMLE	T1,S.SORT##+2		;IN RANGE?
	 POPJ	P,			;NO--STOP NOW
	MOVE	T1,[2,,2]		;ADVANCE POINTER
	ADDM	T1,SRTPTR		;TO NEXT PAIR
	JRST	.POPJ1##		;AND USE THAT J

UNIS.1:	MOVE	T1,[2,,2]		;ADVANCE POINTER
	ADDM	T1,SRTPTR		;TO NEXT PAIR
	JRST	SRTNXT			;AND GET NEXT
	SUBTTL	UNIT tables -- Define all unit subfields

; This macro fetches a sub-field about the unit. If the field has been
; gotten before, it simply returns the known field. If the field has
; not been gotten before, it it derived/computed, stored for later
; use, and returned.
;
; In all cases, the field will be returned in T1, and set in table
; .UBxxx (flag UB%xxx indicates if the field has been gotten)

DEFINE	UB$(X,N<1>),<
   XLIST
	UB%'X==.UBLEN			;;FLAG WORD
	.UB'X==.UBLEN+1			;;DATA WORD
	.UBLEN==.UBLEN+2
IFG N-1,.UBLEN==.UBLEN+N
	UB$'X::	AOSN	UB%'X(JP)	;;DO WE HAVE THE INFO?
		 JRST	UB1'X		;;NO--GO GET IT
		MOVE	T1,.UB'X(JP)	;;YES--JUST GET IT NOW
		POPJ	P,		;;AND RETURN
	UB1'X:				;;(HERE TO GET INFO)
   DEFINE END$,<
	XLIST
	MOVEM	T1,.UB'X(JP)		;STORE
	POPJ	P,			;AND RETURN
	LIST
   >
   LIST
>;END DEFINE

	.UBLEN==0
UB$(ALT)	;ALTERNATE PORT
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCALT(T1)		;GET ALTERNATE PORT
	END$

UB$(BRC)	;BUFFERED READS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCBRC(T1)		;GET BUFFERED READS
	END$

UB$(BWC)	;BUFFERED WRITES
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCBWC(T1)		;GET BUFFERED WRITES
	END$

UB$(CBK)	;CACHED BLOCKS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCCBK(T1)		;GET CACHED BLOCKS
	END$

UB$(CER)	;CHECKSUM/CONSISTANCY ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCCER(T1)		;GET CHECKSUM/CONSISTANCY ERRORS
	END$

UB$(CRC)	;CACHED READ CALLS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCCRC(T1)		;GET CACHED READ CALLS
	END$

UB$(CRH)	;CACHED READ HITS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCCRH(T1)		;GET CACHED READ HITS
	END$

UB$(CWC)	;CACHED WRITE CALLS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCCWC(T1)		;GET CACHED WRITE CALLS
	END$

UB$(CWH)	;CACHED WRITE HITS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCCWH(T1)		;GET CACHED WRITE HITS
	END$

UB$(DET)	;DETACHED ALTERNATE PORT
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCDET(T1)		;GET DETACHED ALTERNATE PORT
	END$

UB$(DRC)	;DUMP READS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCDRC(T1)		;GET DUMP READS
	END$

UB$(DWC)	;DUMP WRITES
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCDWC(T1)		;GET DUMP WRITES
	END$

UB$(ECT)	;RETRIES ON LAST ERROR
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCECT(T1)		;GET RETRIES
	END$

UB$(ERR)	;2CONI
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCERR(T1)		;GET CONI WORD AFTER RETRY
	END$

UB$(FKS)	;FREE K OF SWAP SPACE REMAINING
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCFKS(T1)		;GET FREE K OF SWAP SPACE
	END$

UB$(FRB)	;FREE BLOCKS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCUNT(T1)		;GET BLOCKS FREE
	END$

UB$(FRS)	;FREE SWAPPING SPACE
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCUNT(T1)		;GET FREE SWAPPING SPACE
	END$

UB$(HBN)	;LBN
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCHBN(T1)		;GET LOGICAL BLOCK NUMBER OF ERROR
	END$

UB$(HDI)	;2DATAI
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCHDI(T1)		;GET DATAI WORD AFTER RETRY
	END$

UB$(HDT)	;HARD DATA ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCHDT(T1)		;GET HARD DATA ERRORS
	END$

UB$(HDV)	;HARD DEVICE/SEARCH ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCHDV(T1)		;GET HARD DEVICE/SEARCH ERRORS
	END$

UB$(LOG)	;LOGICAL UNIT NAME
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCULN(T1)		;GET LOGICAL UNIT NAME
	END$

UB$(MRC)	;MONITOR READS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCMRC(T1)		;GET MONITOR READS
	END$

UB$(MWC)	;MONITOR WRITES
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCMWC(T1)		;GET MONITOR WRITES
	END$

UB$(MSC)	;MONITOR SEEKS (MONITOR I/O + SWAPPING)
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVEI	T1,0
;	MOVE	T1,.DCMSC(T1)		;GET NUMBER OF SEEKS
	END$

UB$(NHG)	;NON-RECOVERABLE TRANSFER HUNG ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCNHG(T1)		;GET NON-RECOV XFER HUNG ERRORS
	END$

UB$(NUS)	;NEXT UNIT WITHIN FILE STRUCTURE
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCNUS(T1)		;GET NEXT UNIT
	END$

UB$(PHG)	;POSITION HUNG ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCPHG(T1)		;GET POSITION HUNG ERRORS
	END$

UB$(PRC)	;PAGING READS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCPRC(T1)		;GET PAGING READS
	END$

UB$(PWC)	;PAGING WRITES
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCPWC(T1)		;GET PAGING WRITES
	END$

UB$(RER)	;RIB ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCRER(T1)		;GET RIB ERRORS
	END$

UB$(SER)	;SAT ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSER(T1)		;GET SAT ERRORS
	END$

UB$(SDI)	;1DATAI
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSDI(T1)		;GET DATAI WORD BEFORE RETRY
	END$

UB$(SDT)	;SOFT DATA ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSDT(T1)		;GET SOFT DATA ERRORS
	END$

UB$(SDV)	;SOFT DEVICE/SEARCH ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSDV(T1)		;GET SOFT DEVICE/SEARCH ERRORS
	END$

UB$(SHG)	;SOFTWARE HUNG ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSHG(T1)		;GET SOFTWARE HUNG ERRORS
	END$

UB$(SOF)	;1CONI
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSOF(T1)		;GET CONI WORD BEFORE RETRY
	END$

UB$(SRC)	;SWAPPING READS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSRC(T1)		;GET SWAPPING READS
	END$

UB$(SWC)	;SWAPPING WRITES
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSWC(T1)		;GET SWAPPING WRITES
	END$

UB$(STR)	;STRUCTURE NAME
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCSNM(T1)		;GET STRUCTURE NAME
	END$

UB$(THG)	;TRANSFER HUNG ERRORS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCTHG(T1)		;GET TRANSFERFER HUNG ERRORS
	END$

UB$(TSC)	;TOTAL SEEKS
	PUSHJ	P,UB$MSC		;GET MONITOR SEEKS
	PUSH	P,T1			;SAVE COUNT
	PUSHJ	P,UB$USC		;GET USER SEEKS
	ADDM	T1,(P)			;ACCUMULATE
	POP	P,T1			;RESTORE TOTAL COUNT
	END$

UB$(UID)	;UNIT-ID
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVE	T1,.DCUID(T1)		;GET LOGICAL UNIT NAME
	END$

UB$(UNN)	;UNIT NAME
	MOVEI	T1,(O)			;GET UNIT INDEX
	PUSHJ	P,UNII2N##		;CONVERT TO UNIT NAME
	  MOVEI	T1,0			;NO SUCH UNIT
	END$

UB$(USC)	;USER SEEKS (BUFFERED AND DUMP)
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVEI	T1,0
;	MOVE	T1,.DCUSC(T1)		;GET NUMBER OF SEEKS
	END$

UB$(XRC)	;EXTENDED RIB READS
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVEI	T1,0
;	HRRZ	T1,.DCXRA(T1)		;GET EXTENDED RIB READS
	END$

UB$(XWC)	;EXTENDED RIB WRITES
	PUSHJ	P,UB$DCH		;GET DISK CHARACTERISTICS
	MOVEI	T1,0
;	HLRZ	T1,.DCXRA(T1)		;GET EXTENDED RIB WRITES
	END$

UB$(DCH,.DCMAX+2)	;DISK CHARACTERISTICS BLOCK
	PUSHJ	P,UB$UNN		;GET UNIT NAME
	MOVEM	T1,.UBDCH+2+.DCNAM(JP)	;SAVE IN ARG BLOCK
	MOVSI	T1,.DCMAX		;ARG BLOCK LENGTH
	HRRI	T1,.UBDCH+2(JP)		;ARG BLOCK ADDRESS
	PUSHJ	P,UDSKCHR##		;GET DISK CHARACTERISTICS
	  TDZA	T1,T1			;FAILED FOR SOME REASON
	MOVEM	T1,.UBDCH+1(JP)		;SAVE STUFF RETURNED IN THE AC
	MOVEI	T1,.UBDCH+2(JP)		;POINT TO DSKCHR BLOCK
	END$
	SUBTTL	DATA STORAGE

	$LOW

UNICOR::BLOCK	1
MAXUNI:	BLOCK	1
SRTTAB:	BLOCK	1
SRTPTR:	BLOCK	1
SRTCNT:	BLOCK	1

	END
