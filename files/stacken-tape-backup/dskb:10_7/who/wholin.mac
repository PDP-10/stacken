	TITLE	LINSCN - LINE mode scan defaulting for WHO

	SEARCH	WHOMAC

	$SETUP	(LINSCN)

Comment |

This module provides the LINE mode specific scan defaulting code. Its
only entry point is LINSCN.

|
;               TABLE OF CONTENTS FOR LINSCN
;
;
;                        SECTION                                   PAGE
;    1. LINSCN - Apply job line mode specific scan input defaults.   3
;    2. STORAGE...................................................   4
	SUBTTL	LINSCN - Apply job line mode specific scan input defaults

LINSCN::MOVE	T1,.FXDEV(I)		;GET DEVICE
	MOVX	T2,FX.NDV		;GET NULL DEVICE BIT
	TDNN	T2,.FXMOD(I)		;SEE IF DEVICE GIVEN
	 JRST	[CHKSWT	(TTY)
		  JRST	.+1]
	SKIPE	T1,.FXEXT(I)		;SEE IF EXTENSION GIVEN
	  JRST	[CAIN	T1,-1		;YES--INSURE JUST EXTENSION
		  SKIPE	.FXNAM(I)	;AND NO NAME
		   JRST	E$$EIC		;BECAUSE THATS BAD
		 PUSHJ	P,CHKDOT##	;SEE IF DOT OK (NOT CRASH FILE)
		 MOVE	T1,MYTTY##	;GET USERS TTY
		 CHKSWT	(TTY)
		 JRST	.+1]		;AND CONTINUE
	SKIPN	T1,.FXNAM(I)		;SEE IF NAME
	  JRST	LINS.2			;NO
	SKIPE	.FXEXT(I)		;YES--INSURE NO EXTENSION
	 $FATAL (EIC,<Extension illegal in this context>)	;NO--DIE
	CAMN	T1,[SIXBIT/*/]		;ALL WILD?
	 JRST	LINS.2			;YES--TREAT AS NO NAME
	CAMN	T1,[SIXBIT/SYSTEM/]	;SYSTEM LINE?
	 HRLZ	T1,SYSLIN##		;YES--SETUP
	TXNE	T1,77B5			;FIRST CHAR BLANK?
	  JRST	LINS.3			;NO
	MOVSS	T1			;YES--GET OCTAL NUMBER
	PUSHJ	P,TTYNNN##		;MAKE NNN
LINS.4:	HRLI	T1,'TTY'		;INCLUDE TTY
	CHKSWT	(TTY)
	JRST	LINS.2			;AND PROCEED

LINS.3:	DVNAM.	T1,			;GET LOGICAL NAME
	  MOVE	T1,.FXNAM(I)		;NONE
	CHKSWT	(TTY)
	CAME	T1,[SIXBIT/CTY/]	;SEE IF CTY
	 TRNE	T1,-1			;OR RH BLANK
	  JRST	LINS.2			;NO
	HLRZS	T1			;YES--GET LEADING SIXBIT
	HRLI	T1,'TTY'		;INCLUDE TTY
	MOVEM	T1,.FZTTY(I)		;STORE
;
;Fix up /TTY spec, and make mask
;
LINS.2:	PUSHJ	P,FIXTTY##		;FIX UP TTY SPEC
	PUSHJ	P,FIXNOD##		;FIX UP NODE SPEC
;
;Range check job number
;
	SKIPL	T1,.FZJOB##(I)		;GET JOB NUMBER
	 PUSHJ	P,CHKJOB##		;YES--RANGE CHECK
;
;Default /DIALUP if /CARRIER
;
	MOVEI	T1,.TODSD		;GET /DIALUP
	SKIPL	.FZDSC##(I)		;/[NO]CARRIER GIVEN?
	  MOVEM	T1,.FZAPC##(I)		;YES--FORCE /DIALUP
IFN FTPOWER,<
;
;Default /NODIALUP if /POWER
;
	MOVEI	T1,.TOHWD		;GET /HARDWIRED
	SKIPL	T2,.FZPOW##(I)		;/[NO]POWER GIVEN?
	 JRST	[MOVEM	T1,.FZAPC##(I)	;YES--FORCE /NODIALUP
		 MOVEM	T2,.FZDSC##(I)	;AND STORE /POWER AS /CARRIER
		JRST	.+1]		;CONTINUE
>
;
;Convert /LOCAL to /NOREMOTE and visa versa
;
	SKIPL	T1,.FZLCL##(I)		;SEE IF /LOCAL
	  JRST	[TRC T1,1		;FLIP THE BIT
		 CHKSWT	(RMT,LOCAL)	;AND STORE /REMOTE
		 JRST .+1]		;CONTINUE
;
;Convert /SPEED:N to /XMTSPEED:N and /RCVSPEED:N
;
	SKIPLE	T1,.FZSPD##(I)		;GET SPEED
	 JRST	[CHKSWT	(TSP,XMTSPEED)	;CHECK AND STORE
		 CHKSWT	(RSP,RCVSPEED)	;..
		 JRST	.+1]
;
;Default /INCLUDE:PTY if /LOGINQ
;
IFN FTLGNQ,<
	MOVX	T1,INCPTY##		;GET INCLUDE BITS
	TLNE	F,(FL.LGNQ)		;HAVE LOGIN QUEUE SUPPORT?
	SKIPLE	.FZLQP##(I)		;SEE IF /LOGINQ
	 IORM	T1,S.INCLUDE##		;YES--DEFAULT /INCLUDE:PTY
> ;END IFN FTLGNQ
;
;Here to change /TYPE:NONE into BLANKS
;
	MOVE	T1,.FZTYP##(I)		;GET TYPE
	CAMN	T1,[SIXBIT/NONE/]	;NONE?
	  SETZM	.FZTYP##(I)		;YES--CHANGE TO BLANKS

;HERE TO TURN LOCATE STRING (ASCII INTO WILDCARDED ASCIZ)

	SETCM	T1,.FZLOC##(I)		;SEE IF STRING SPECIFIED
	JUMPE	T1,LINS.8		;NO
	MOVEI	T1,.FZLOC##(I)		;POINT TO STRING
	MOVEI	T2,.FZLMC##(I)		;AND MASK STORAGE
	MOVEI	T3,^D19			;CHARACTER COUNT
	PUSHJ	P,MSKUC##		;AND MAKE A MASK
;
;All done with this spec
;
LINS.8:	POPJ	P,			;AND RETURN
	SUBTTL	STORAGE

	$LOW

	PRGEND
	TITLE	LINGET - Get line information

	SEARCH	WHOMAC
	$SETUP	(LINGET)
;               TABLE OF CONTENTS FOR LINGET
;
;
;                        SECTION                                   PAGE
;    1. Main line routines
;         1.1   LINNXT - Get the next line........................   3
;         1.2   LINSET - Setup for a new line.....................   4
;         1.3   LININC - Handle incremental statistics............   5
;         1.4   LINSRT - Handle line sorting......................   6
;    2. LINE tables
;         2.1   Define simple TRMOP's required....................   7
;         2.2   Define all line subfields.........................   8
;         2.3   Routines to fetch all subfields...................   9
;    3. Storage...................................................  12
	SUBTTL	Main line routines -- LINNXT - Get the next line

LINNXT::JUMPL	O,LINN.1		;JUMP IF THE FIRST TIME
	SKIPL	S.SORT##		;SEE IF /SORT
	 JRST	SRTNXT			;YES--GET NEXT LINE
	ADDI	O,1			;ADVANCE TO NEXT LINE
	CAMG	O,MAXLIN		;SEE IF PAST THE END
	 JRST	LINN.2			;NO--SETUP FOR THIS ONE
	POPJ	P,			;AND RETURN
LINN.1:	MOVE	T1,LINMAX##		;GET HIGHEST LINE
	MOVE	T2,S.INCLUDE##		;GET /INCLUDE:
	HLRZ	T3,.FZTTY##(I)		;GET /TTY/PTY
	CAIE	T3,'PTY'		;/PTY GIVEN?
	 TRNE	T2,INCPTY##		;OR /INCLUDE:PTY
	  ADD	T1,PTYN##		;YES--INCLUDE THEM
	MOVEM	T1,MAXLIN		;AND SAVE MAX
	CAIN	T3,'PTY'		;/PTY GIVEN?
	 SKIPA	O,LINMAX##		;YES--START WITH FIRST PTY
	  SETO	O,			;NO--START WITH FIRST LINE
	ADDI	O,1			;ADVANCE TO NEXT LINE
	MOVEI	T1,^D10			;INITIAL TABLE SIZE
	MOVEI	T2,^D2			;SIZE OF EACH ENTRY
	PUSHJ	P,.HASHI##		;ADD IT
	SKIPL	T1,S.SORT##		;GET SORT INDEX
	 JRST	LINSRT			;GO HANDLE /SORT
LINN.2:	PUSHJ	P,LINSET		;SETUP FOR THIS LINE
	 JRST	LINNXT			;NOT CONNECTED
	JRST	.POPJ1##		;ALL SET
	SUBTTL	Main line routines -- LINSET - Setup for a new line


LINSET::SKIPE	JP,LINCOR		;SEE IF CORE ALLOCATED YET
	 JRST	LINS.C			;YES
	MOVEI	T1,.LBLEN		;NO--GET SIZE
	PUSHJ	P,M$ALLOC##		;GET CORE
	MOVEM	T1,LINCOR		;SAVE STARTING ADDRESS
	MOVEI	JP,(T1)			;AND INTO JP
LINS.C:	HRLI	T1,(JP)			;GET STARTING ADDRESS
	HRRI	T1,1(JP)		;ENDING ADDRESS
	SETOM	(JP)			;SET FIRST WORD TO -1
	BLT	T1,.LBLEN-1(JP)		;AND SET THEM ALL TO -1
	MOVEI	T1,(O)			;GET LINE NUMBER
	PUSHJ	P,TTYUSE##		;SEE IF IN USE
	  POPJ	P,			;IT ISN'T
	SKPYES	S.INCREMENTAL##		;SEE IF /INCREMENTAL
	 JRST	.POPJ1##		;NO--RETURN NOW
	MOVSI	T1,-INCLEN		;GET LENGTH
	MOVEI	T2,(O)			;GET LIN INDEX
	IMULI	T2,INCLEN		;POINT TO BLOCK
	ADD	T2,INCINC		;ADD START OF TABLE
LINS.1:	MOVEI	T3,@INCOFF(T1)		;GET OFFSET THIS FIELD
	MOVE	T4,(T2)			;GET COMPUTED INCREMENTAL VALUE
	SETZM	-1(T3)			;INDICATE WE GOT IT
	MOVEM	T4,(T3)			;STORE IT
	ADDI	T2,1			;ADVANCE TO NEXT
	AOBJN	T1,LINS.1		;LOOP FOR ALL
	JRST	.POPJ1##		;AND RETURN
	SUBTTL	Main line routines -- LININC - Handle incremental statistics

LININC::PUSH	P,S.INCREMENTAL##	;SAVE /INCREMENTAL
	PUSH	P,S.SORT		;SAVE /SORT
	SETZM	S.INCREMENTAL##		;FAKE LINSET
	SETOM	S.SORT			;..
	MOVNI	O,1			;FLAG LINSET TO GET FIRST LINE
	SKIPE	INCINC			;SEE IF TABLE YET
	 JRST	LINI.L			;YES!
	MOVEI	T1,1000*INCLEN		;GET CORE NEEDED
	PUSHJ	P,C$ALLOC##		;ALLOCATE CORE
	MOVEM	T1,INCINC		;SAVE ADDRESS
	MOVEI	T1,1000*INCLEN		;GET CORE NEEDED AGAIN
	PUSHJ	P,C$ALLOC##		;ALLOCATE IT
	MOVEM	T1,INCOLD		;SAVE
LINI.L:	PUSHJ	P,LINNXT		;GET THE NEXT LINE
	 JRST	LINI.E			;ALL DONE
	PUSHJ	P,LININJ		;HANDLE INCREMENTAL STATISTICS
	JRST	LINI.L			;LOOP FOR ALL
LINI.E:	POP	P,S.SORT		;RESTORE /SORT
	POP	P,S.INCREMENTAL##	;AND /INCREMENTAL
	POPJ	P,			;RETURN

LININJ:	PUSHJ	P,.SAVE3##		;SAVE P1-P3
	MOVEI	T1,(O)			;GET LINE NUMBER
	IMULI	T1,INCLEN		;TIME LENGHTH OF TABLE
	MOVSI	P1,-INCLEN		;GET AOBJN POINTER
	MOVE	P2,INCOLD		;GET ADDRESS OF TABLE
	ADDI	P2,(T1)			;..
	MOVE	P3,INCINC		;AND ADDRESS OF INCREMENTAL TABLE
	ADDI	P3,(T1)			;..
	SKIPN	(P2)			;SEE IF SEE BEFORE
	  JRST	LNI.N			;SETUP FOR NEW LIN
LNI.L:	PUSHJ	P,@INCGET(P1)		;GET CURRENT VALUE
	MOVE	T2,T1			;SAVE
	EXCH	T1,(P2)			;STORE OLD,,GET PREVIOUS OLD
	SUB	T2,T1			;COMPUTE CURRENT-OLD
	MOVEM	T2,(P3)			;STORE INCREMENTAL
	ADDI	P2,1			;ADVANCE TO NEXT BLOCK
	ADDI	P3,1			;ADVANCE TO NEXT
	AOBJN	P1,LNI.L		;LOOP FOR ALL OFFSETS
	POPJ	P,			;AND RETURN

LNI.N:	PUSHJ	P,@INCGET(P1)		;GET CURRENT VALUE
	MOVEM	T1,(P2)			;STORE AS OLD
	SETZM	(P3)			;CLEAR INCREMENTAL
	ADDI	P2,1			;ADVANCE TO NEXT BLOCK
	ADDI	P3,1			;..
	AOBJN	P1,LNI.N		;LOOP FOR ALL OFFSETS
	POPJ	P,			;AND RETURN


DEFINE	INCS,<
	X	OCT
	X	ICT
	X	BCC
	X	CMD
>

DEFINE X(Z),<EXP LB$'Z>

INCGET:	INCS
INCLEN==.-INCGET

DEFINE X(Z),<.LB'Z(JP)>

INCOFF:	INCS
	SUBTTL	Main line routines -- LINSRT - Handle line sorting

LINSRT:	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVEI	P1,(T1)			;SAVE SORT INDEX
	MOVE	T1,MAXLIN		;GET MAX LINES
	ADDI	T1,1			;STARTS WITH ZERO
	IMULI	T1,2			;2 WORD TABLE
	MOVN	T2,T1			;NEGATE INTO T2
	HRLZM	T2,SRTTAB		;SAVE -N,,0
	PUSHJ	P,I$ALLOC##		;GET THE CORE
	HRRM	T1,SRTTAB		;SAVE START
SRTJ.1:	PUSHJ	P,LINSET		;SETUP FOR THIS LINE
	 JRST	SRTJ.2			;NOT ASSIGNED
	PUSHJ	P,@SUMLOD##(P1)		;GET SORT KEY
	MOVEI	T2,(O)			;GET LINE
	IMULI	T2,2			;DOUBLE
	ADD	T2,SRTTAB		;PLUS START OF TABLE
	MOVEM	T1,(T2)			;SAVE SORT KEY FIELD
	MOVEM	O,1(T2)			;SAVE LINE NUMBER
	AOS	1(T2)			;ADD ONE TO KEEP ZERO DIFFERENT
SRTJ.2:	ADDI	O,1			;BUMP TO NEXT LINE
	CAMG	O,MAXLIN		;ALL DONE?
	 JRST	SRTJ.1			;NO--ADVANCE TO NEXT
	MOVE	T1,SRTTAB		;GET AOBJN WORD
	MOVE	T2,[400000,,2]		;UNSIGNED AND STRAIGHT SORT
	SKIPLE	S.SORT##+1		;SEE IF DESCENDING
	 TLO	T2,200000		;YES-SET FLAG
	PUSHJ	P,.SORT2##		;SORT THE LIST
	MOVE	T1,SRTTAB		;GET AOBJN
	MOVEM	T1,SRTPTR		;SAVE
	SETZM	SRTCNT			;NO LINES YET
	JRST	LINNXT			;AND BACK TO THE TOP


SRTNXT:	SKIPL	T1,SRTPTR		;GET POINTER
	 POPJ	P,			;ALL DONE
	SKIPN	O,1(T1)			;GET LINE NUMBER
	 JRST	SRTN.1			;NONE
	SUBI	O,1			;ACCOUNT FOR ADDI ABOVE
	PUSHJ	P,LINSET		;SETUP FOR THIS LINE
	 JRST	SRTN.1			;NOT IN USE NOW?
	AOS	T1,SRTCNT		;COUNT THE LINES
	CAMLE	T1,S.SORT##+2		;IN RANGE?
	 POPJ	P,			;NO--STOP NOW
	MOVE	T1,[2,,2]		;ADVANCE POINTER
	ADDM	T1,SRTPTR		;TO NEXT PAIR
	JRST	.POPJ1##		;AND USE THAT J

SRTN.1:	MOVE	T1,[2,,2]		;ADVANCE POINTER
	ADDM	T1,SRTPTR		;TO NEXT PAIR
	JRST	SRTNXT			;AND GET NEXT
	SUBTTL	LINE tables -- Define simple TRMOP's required

DEFINE LTRM(LST),<
    XLIST
    IRP LST,<
	LT%'LST==.LBLEN		;;Define flag word
	.LT'LST==.LBLEN+1		;;And data word
	.LBLEN==.LBLEN+2
	LT$'LST::AOSN	T1,LT%'LST(JP)	;;We already have this TRMOP?
		  JRST	LT1'LST	;;No--Get it now
		 MOVE	T1,.LT'LST(JP)	;;Yes--Return its value
		 POPJ	P,		;;And return
	LT1'LST:MOVEI	T1,.TO'LST	;;Get the desired TRMOP table
		 MOVEI	T2,.UXTRM(O)	;;Get the UDX
		 PUSHJ	P,UTRMOP##	;;Fetch for the current line
		  MOVEI	T1,0		;;Failed
		 MOVEM	T1,.LT'LST(JP)	;;Store for later
		 POPJ	P,		;;And return
    >;END IRP
    LIST
>;END DEFINE

	.LBLEN==0


LTRM	<DSS,TRM,TSP,RSP,SLV,ICT,OCT,BCT,GMS,RMT>
LTRM	<LCT,TAB,FRM,DEM,LCP,NFC,WID,SND,DIS,FLC,TAP,XON,PAG,PSZ>
LTRM	<BLK,ALT,DBK,TDY,RTC,HLFX,OIP,HPS,STP,PCT,APL,274,ACR,OSU>
	SUBTTL	LINE tables -- Define all line subfields

;This macro fetches a sub-field about the Lob. If the field has been
;gotten before, it simply returns the known field. If the field has
;not been gotten before, it it derived/computed, stored for later
;use, and returned.
;
;In all cases, the field will be returned in T1, and set in table
;.LBxxx (flag LB%xxx indicates if the field has been gotten)

DEFINE	LB$(X,N<1>),<
	XLIST
	LB%'X==.LBLEN			;;FLAG WORD
	.LB'X==.LBLEN+1			;;DATA WORD
	.LBLEN==.LBLEN+2
IFG N-1,.LBLEN==.LBLEN+N
	LB$'X::	AOSN	LB%'X(JP)	;;DO WE HAVE THE INFO?
		 JRST	LB1'X		;;NO--GO GET IT
		MOVE	T1,.LB'X(JP)	;;YES--JUST GET IT NOW
		POPJ	P,		;;AND RETURN
	LB1'X:				;;(HERE TO GET INFO)
   DEFINE END$,<
	XLIST
	MOVEM	T1,.LB'X(JP)		;STORE
	POPJ	P,			;AND RETURN
	LIST
   >
    LIST
>;END DEFINE

;This macro is a trivial case of LB$(xxx). The information is simply
;from a GETTAB table, and a dispatch to fetch that GETTAB table entry
;is made, if needed. 
;
;Again, in all cases, the field will be returned in T1, and set in table
;.LBxxx (flag LB%xxx indicates if the field has been gotten)

DEFINE	LB$$(X),<
	LB$'X==:LT$'X
	.LB'X==.LT'X
	LB%'X==LT%'X
>

;This macro fetches a sub-field about the Lob. If the field has been
;gotten before, it simply returns the known field. If the field has
;not been gotten before, it it derived/computed, stored for later
;use, and returned.
;
;In all cases, the field will be returned in T1, and set in table
;.LXxxx (flag LX%xxx indicates if the field has been gotten)

DEFINE	LX$(X),<
	XLIST
	LX%'X==.LBLEN			;;FLAG WORD
	.LX'X==.LBLEN+1			;;DATA WORD
	.LBLEN==.LBLEN+2
	LX$'X::	AOSN	LX%'X(JP)	;;DO WE HAVE THE INFO?
		 JRST	LX1'X		;;NO--GO GET IT
		MOVE	T1,.LX'X(JP)	;;YES--JUST GET IT NOW
		POPJ	P,		;;AND RETURN
	LX1'X:				;;(HERE TO GET INFO)
   DEFINE END$,<
	MOVEM	T1,.LX'X(JP)		;STORE
	POPJ	P,			;AND RETURN
   >
    LIST
>;END DEFINE
	SUBTTL	LINE tables -- Routines to fetch all subfields

LB$(TYP)	;TERMINAL TYPE
	PUSHJ	P,LT$TRM
	END$

LB$$(TSP)	;TRANSMIT SPEED INDEX

LB$$(RSP)	;RECEIVE SPEED INDEX

LB$$(SLV)	;SLAVE BIT

LB$$(ICT)	;INPUT CHARACTER COUNT

LB$$(OCT)	;OUTPUT CHARACTER COUNT

LB$$(RMT)	;REMOTE BIT
LB$(MCL)	;MIC CONTROLLED LINE
	PUSHJ	P,LT$GMS		;GET MIC STATUS
	CAIE	T1,0			;CONTROLLED BY MIC?
	 MOVEI	T1,1			;YES--SET 1
	END$

LB$(DSC)	;DATA SET CARRIER
	PUSHJ	P,LT$DSS		;GET DATA SET STATUS
	LOAD	T1,T1,LS.CAR		;GET THE CARRIER BIT
	END$

LB$(TBD)	;TRANSMIT BAUD
	PUSHJ	P,LB$TSP		;GET TRANSMIT SPEED INDEX
	MOVE	T1,SPETAB(T1)		;CONVERT INTO BAUD
	END$

LB$(RBD)	;RECEIVE BAUD
	PUSHJ	P,LB$RSP		;GET RECEIVE SPEED INDEX
	MOVE	T1,SPETAB(T1)		;CONVERT INTO BAUD
	END$

LB$(BCC)	;BREAK CHARACTER COUNT
	PUSHJ	P,LT$BCT		;GET COUNTERS
	LOAD	T1,T1,LS.BRK		;GET BREAK COUNT
	END$

LB$(CMD)	;COMMANDS TYPED
	PUSHJ	P,LT$BCT		;GET COUNTERS
	LOAD	T1,T1,LS.CMD		;GET COMMAND COUNT
	END$

LB$(NLN)	;NETWORK LINE NUMBER
	PUSHJ	P,LX$NNL		;GET NODE AND LINE
	LOAD	T1,T1,GX.LIN		;GET LINE NUMBER
	END$

LB$(NNU)	;NETWORK NODE NUMBER
	PUSHJ	P,LX$NNL		;GET NODE AND LINE
	LOAD	T1,T1,GX.NOD		;GET NODE NUMBER
	END$

LB$(NNM)	;NETWORK NODE NAME
	PUSHJ	P,LB$NNU		;GET NODE NUMBER
	CAIE	T1,0			;SEE IF KNOWN
	 PUSHJ	P,ANODE##		;YES--CONVERT
	  MOVEI	T1,0			;FAILED?
	END$

LB$(TLN)	;TERMINAL LINE NUMBER
	MOVEI	T1,(O)			;GET LINE
	END$

LB$(JOB)	;ASSOCIATED JOB
	MOVEI	T1,.UXTRM(O)		;GET UDX
	PUSHJ	P,UDEVTYP##		;GET JOB IN USE
	 MOVEI	T1,0			;FAILED
	LOAD	T1,T1,TY.JOB		;EXTRACT
	END$

LB$(TTY)	;TERMINAL NAME
	MOVEI	T1,(O)			;GET TERMINAL LINE NUMBER
	CAMN	T1,CTYLIN##		;SEE IF CTY
	 JRST	TTY.C			;YES
	CAML	T1,SYSPTY##		;SEE IF PTY
	 JRST	TTY.P			;YES
	PUSHJ	P,TTYNNN##		;NO--MAKE NNN
	HRLI	T1,'TTY'		;INCLUDE PREFIX
	JRST	TTY.E			;AND FINISH

TTY.P:	SUB	T1,SYSPTY##		;MINUS OFFSET FOR PTYS
	PUSHJ	P,TTYNNN##		;MAKE NNN
	HRLI	T1,'PTY'		;INCLUDE PREFIX
	JRST	TTY.E

TTY.C:	MOVSI	T1,'CTY'		;GET CTY PREFIX

TTY.E:	END$

LB$(TCJ)	;TERMINAL CONTROLLING A JOB
	PUSHJ	P,LX$DVC		;GET DEVICE CHARS
	LOAD	T1,T1,DV.TTA		;GET THE BIT
	END$

LB$(TAC)	;TERMINAL ASSIGNED BY COMMAND
	PUSHJ	P,LX$DVC		;GET DEVICE CHARS
	LOAD	T1,T1,DV.ASC		;GET THE BIT
	END$

LB$(TAP)	;TERMINAL ASSIGNED BY PROGRAM
	PUSHJ	P,LX$DVC		;GET DEVICE CHARS
	LOAD	T1,T1,DV.ASP		;GET THE BIT
	END$

LB$(APC)	;ASYNC PORT CHARACTERISTICS
	MOVEI	T2,.UXTRM(O)		;GET LINE
	MOVEI	T1,.TOAPC		;FUNCTION CODE
	PUSHJ	P,UTRMOP##		;READ APC
	  MOVEI	T1,.TOUNK		;UNKNOWN
	END$

LB$(LOC,4)	;LOCATION STRING
	PUSHJ	P,LB$NLN		;GET NETWORK LINE NUMBER
	PUSH	P,T1			;SAVE
	PUSHJ	P,LB$NNM		;GET NETNORK NODE NAME
	POP	P,T2			;RESTORE LINE NUMBER
	PUSHJ	P,LOCFND##		;FIND ITS STRING
	DMOVEM	T1,.LBLOC+1(JP)		;SAVE
	DMOVEM	T3,.LBLOC+3(JP)		;..
	MOVEI	T1,.LBLOC+1(JP)		;GET ADDRESS OF STRING
	END$

IFN FTLGNQ,<
LB$(LQP)	;LOGIN QUEUE POSITION
	PUSHJ	P,CHKLGQ##		;SEE IF IN LOGIN QUEUE
	END$
> ;END IFN FTLGNQ
LX$(NNL)	;GET NETWORK NODE AND LINE
	MOVEI	T1,.UXTRM(O)		;GET UDX
	PUSHJ	P,UGTNTN##		;DO GTNTN.
	 MOVEI	T1,0			;FAILED
	END$

LX$(DVC)	;DEVICE CHARACTERISTICS
	MOVEI	T1,.UXTRM(O)		;GET UDX
	PUSHJ	P,UDEVCHR##		;DO DEVCHR
	END$

LX$(GLC)	;GET LINE CHARACTERISTICS
	MOVEI	T1,(O)			;GET LINE
	PUSHJ	P,UGETLCH##		;DO GETLCH
	END$
	SUBTTL	Storage

SPETAB::DEC	0,50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,0,0

	$LOW

MAXLIN::BLOCK	1
LINCOR::BLOCK	1
SRTTAB:	BLOCK	1
SRTPTR:	BLOCK	1
SRTCNT:	BLOCK	1
INCOLD:	BLOCK	1
INCINC:	BLOCK	1

	PRGEND
	TITLE	LINLOC - Location string information for WHO

	SEARCH	WHOMAC

	$SETUP	(LINLOC)


Comment |

This module contains the entry point LOCFND to return a string 
corresponding to the node/line descriptor.

|
;               TABLE OF CONTENTS FOR LINLOC
;
;
;                        SECTION                                   PAGE
;    1. LOCINI - Initialize LINES.INI file........................   3
;    2. LOCFND - Find corresponding node/line string..............   4
;    3. Storage...................................................   5
	SUBTTL	LOCINI - Initialize LINES.INI file

;Call:
;	PUSHJ	P,LOCINI
;LOCTAB will contain either -1 if STD:LINES.INI cant be accessed, or
;the address of the in core copy of the file.

LOCINI:	PUSHJ	P,.SAVT2##		;SAVE T1,T2
	MOVEI	T1,.IODMP		;DUMP MODE
	MOVSI	T2,'STD'		;SYS:
	MOVEI	T3,0			;NO BUFFERS
	OPEN	INI,T1			;OPEN CHANNEL
	 JRST	LOCI.E			;ERROR
	MOVE	T1,[SIXBIT/LINES/]	;GET NAME
	MOVSI	T2,'INI'		;EXTENSION
	SETZB	T3,T4			;CLEAR OTHER STUFF
	LOOKUP	INI,T1			;TRY FAST LOOKUP
	 JRST	LOCI.E			;ERROR
	HLRE	T1,T4			;GET FILE SIZE
	PUSH	P,T1			;SAVE
	MOVNS	T1			;MAKE POSITIVE
	PUSHJ	P,M$ALLOC##		;GET CORE
	HRRZM	T1,LOCTAB		;SAVE START
	POP	P,T2			;GET SIZE BACK
	HRL	T1,T2			;POSITION
	SUBI	T1,1			;MAKE IOWD
	MOVEI	T2,0			;CLEAR
	INPUT	INI,T1			;READ FILE
	RELEAS	INI,			;FREE CHANNEL
	POPJ	P,			;AND RETURN

LOCI.E:	SETOM	LOCTAB			;FLAG ERROR
	POPJ	P,			;AND RETURN
	SUBTTL	LOCFND - Find corresponding node/line string

;Call:
;	MOVE	T1,[SIXBIT /node name/]
;	MOVEI	T2,line number
;	PUSHJ	P,LOCFND
;Returns with T1-T4 ASCIZ string

LOCFND::SKIPN	LOCTAB			;SEE IF TABLE KNOWN
	 PUSHJ	P,LOCINI		;NO--TRY TO READ STD:LINES.INI
	SKIPG	T4,LOCTAB		;SEE IF TABLE PRESENT NOW
	 JRST	LOCF.X			;NOT THERE - RETURN EMPTY HANDED

LOCF.1:	SKIPN	T3,(T4)			;GET A NODE NAME
	  JRST	LOCF.X			;END OF TABLE
	CAMN	T1,T3			;IS IT A MATCH ?
	JRST	LOCF.2			;YES
	ADDI	T4,2			;ACCOUNT FOR TWO WORD ENTRIES
	JRST	LOCF.1			;KEEP LOOKING

LOCF.X:	SETZB	T1,T2			;RETURN NOTHING
	SETZB	T3,T4			;...
	POPJ	P,			;AND RETURN

LOCF.2:	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVE	P1,1(T4)		;GET STARTING ADDRESS OF ENTRY FOR NODE
	ADD	P1,LOCTAB		;PLUS START OF TABLE

LOCF.3:	SKIPGE	T3,(P1)			;GET A LINE NUMBER
	  JRST	LOCF.X			;END OF TABLE
	CAMN	T2,T3			;IS IT A MATCH ?
	JRST	LOCF.4			;GOT IT
	ADDI	P1,5			;ACCOUNT FOR 5 WORD ENTRIES
	JRST	LOCF.3			;NO - KEEP LOOKING

LOCF.4:	DMOVE	T1,1(P1)		;RETURN FIRST HALF
	DMOVE	T3,3(P1)		;AND SECOND HALF
	POPJ	P,			;AND RETURN
	SUBTTL	Storage

	$LOW

LOCTAB::BLOCK	1

	END
