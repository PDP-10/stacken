	TITLE	WHOACT - Action routines for WHO

	SEARCH	WHOMAC

	$SETUP	(WHOACT)

Comment |

This module contains all the "action" routines for WHO. Action
routines are things that actually do things to jobs, like force
a command to them, output a string on there terminal, etc. The
entry point is DOACTION which will call all the other action
processors.

|
;               TABLE OF CONTENTS FOR WHOACT
;
;
;                        SECTION                                   PAGE
;    1. DOACTION - Call all the action routines...................   3
;    2. Action routines
;         2.1   DOSEND - Send a string to a user..................   4
;         2.2   DOFORCE - Force a command on a user...............   5
;         2.3   DOINPUT - Input a string to a user................   6
;         2.4   DOOUTPUT - Output a string to a user..............   7
;         2.5   DOSETUUO - Do SETUUOs for a job...................   8
;         2.6   DONETWORK - Handle network functions..............   9
;         2.7   INETWORK - Handle initial network functions.......  10
;    3. Routines
;         3.1   ACTPRV - See if privileged........................  11
;         3.2   GACJOB - Get a target job number..................  12
;         3.3   GACLIN - Get a target line number.................  12
;         3.4   GACDES - Get a target line or job number..........  12
;         3.5   GACTTY - Get a target terminal name...............  12
;    4. Storage...................................................  13
	SUBTTL	DOACTION - Call all the action routines

DOACTION::
	PUSHJ	P,DOSEND		;/SEND::"STRING"
	PUSHJ	P,DOFORCE		;/FORCE:COMMAND
	PUSHJ	P,DOINPUT		;/INPUT:"STRING"
	PUSHJ	P,DOOUTPUT		;/OUTPUT:"STRING"
	PUSHJ	P,DOSETUUO		;/SETUUO:ARGS
	PUSHJ	P,DONETWORK		;/NETWORK:ARGS
	PUSHJ	P,DOHANGUP		;/HANGUP
	POPJ	P,			;AND RETURN
	SUBTTL	Action routines -- DOSEND - Send a string to a user

DOSEND:	TRNN	F,FR.TRMOP		;TRMOP. UUO FAILED?
	 SKIPN	S.SEND##		;/SEND: GIVEN?
	  POPJ	P,			;NO--JUST RETURN
	PUSHJ	P,ACTSND		;CHECK PRIVS
	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVEI	T1,SNDCHR		;GET CHAR PUTTER
	PUSHJ	P,.TYOCH##		;TELL SCAN
	PUSH	P,T1			;SAVE OLD ONE
	MOVE	P1,[POINT 7,SNDBUF]	;POINT TO TEXT BUFFER
	MOVEI	T1,[BYTE (7) .CHCRT,.CHLFD,.CHBEL,";",";",0]
	PUSHJ	P,.TSTRG##		;SEND CRLF BELL ;;
	MOVE	T2,.MYPPN##		;GET USERS PPN
	TRNE	T2,777775		;OPR OR REMOTE OPR?
	 JRST	DOSE.1			;NO
	MOVSI	T1,'OPR'		;GET THE NAME
	PUSHJ	P,.TSIXN##		;ADD THAT
	HLRZ	T1,.MYPPN##		;GET USERS PPN
	SUBI	T1,100			;GET LOCAL NODE NUMBER
	CAILE	T1,0			;SKIP IF NOT LOCAL OPR
	 PUSHJ	P,.TOCTW##		;TYPE STATION FOR LOCAL OPR
	PUSHJ	P,.TLPRN##		;TYPE "("
	MOVE	T1,MYTTY##		;GET TERMINAL NAME
	PUSHJ	P,.TSIXN##		;INCLUDE THAT
	PUSHJ	P,.TRPRN##		;CLOSE ")"
	JRST	DOSE.2			;AND SKIP NORMAL STUFF
DOSE.1:	MOVE	T1,MYTTY##		;GET USERS TERMINAL
	PUSHJ	P,.TSIXN##		;TYPE
DOSE.2:	MOVEI	T1,[ASCIZ/: - /]	;GET SEPARATPR
	PUSHJ	P,.TSTRG##		;TYPE
	MOVEI	T1,S.SEND##		;POINT TO SEND STRING
	PUSHJ	P,TSTRG			;TYPE STRING
	PUSHJ	P,.TCRLF##		;START NEW LINE
	MOVEI	T1,0			;FINISH OFF
	PUSHJ	P,SNDCHR		;SEND
	POP	P,.TOUTZ##		;RESTORE SCAN TYPER
	MOVEI	T1,.TOOUS		;GET FUNCTION
	MOVEI	T2,SNDBUF		;POINT TO BUFFER
	PUSHJ	P,ACTRMOP		;DO TRMOP
	 TROA	F,FR.TRMOP		;FLAG FAILED
	  POPJ	P,			;RETURN
	$WARN	(TSF,<TRMOP. SEND failed>,,.POPJ##)

SNDCHR:	IDPB	T1,P1			;STORE CHAR
	POPJ	P,			;AND RETURN

ACTRMOP:MOVEM	T1,TRMBLK+0		;STORE FUNCTION
	MOVEM	T2,TRMBLK+2		;STORE ARGUMENT
	PUSHJ	P,GACLIN		;GET TARGET LINE
	 JRST	.POPJ1##		;NONE
	MOVEM	T1,TRMBLK+1		;STORE TARGET
	MOVE	T1,[3,,TRMBLK]		;POINT TO BLOCK
	TRMOP.	T1,			;DO TRMOP.
	 POPJ	P,			;FAILED
	JRST	.POPJ1##		;SUCCESS

TSTRG:	HRLI	T1,(POINT 7,)		;FORM BYTE POINTER
	PUSH	P,T1			;SAVE IT
TSTR.1:	ILDB	T1,(P)			;GET A CHAR
	JUMPE	T1,TSTR.3		;DONE?
	CAIE	T1,"^"			;CONTROL FLAG?
	 JRST	TSTR.2			;NO
	ILDB	T1,(P)			;GET NEXT CHAR
	CAIL	T1,"a"			;SEE IF LOWER CASE
	 CAILE	T1,"z"			;..
	  CAIA				;NO
	   SUBI	T1,"a"-"A"		;YES--CONVERT
	JUMPE	T1,TSTR.3		;TURKEY!
	SUBI	T1,100			;CONVERT
TSTR.2:	PUSHJ	P,.TCHAR##		;TYPE IT
	JRST	TSTR.1			;AND LOOP
TSTR.3:	POP	P,(P)			;TRIM STACK
	POPJ	P,			;RETURN
	SUBTTL	Action routines -- DOFORCE - Force a command on a user

DOFORCE:MOVE	T1,S.FORCE##		;GET VALUE
	TRNN	F,FR.FRCUUO		;FRCUUO. UUO FAILED?
	 CAMN	T1,[-1]			;SEE IF GIVEN
	  POPJ	P,			;NO--JUST RETURN
	PUSHJ	P,ACTPRV		;CHECK PRIVS
	PUSHJ	P,GACDES		;GET A DESTINATION (JOB OR LINE)
	 POPJ	P,			;JOB MODE AND DETACHED
	MOVEM	T1,FRCBLK+1		;STORE JOB/LINE
	MOVE	T1,S.FORCE##		;GET COMMAND
	MOVEM	T1,FRCBLK+0		;STORE
	MOVE	T1,[2,,FRCBLK]		;POINT TO ARGS
	FRCUUO	T1,			;FORCE IT
	 TROA	F,FR.FRCUUO		;FLAG FAILED
	  POPJ	P,			;GOOD RETURN
	$WARN	(FUF,<FRCUUO. failed>,,.POPJ##)
	SUBTTL	Action routines -- DOINPUT - Input a string to a user

DOINPUT:TRNN	F,FR.TRMOP		;TRMOP. UUO FAILED?
	 SKIPN	S.INPUT##		;/INPUT: GIVEN?
	  POPJ	P,			;NO--JUST RETURN
	PUSHJ	P,ACTPRV		;CHECK PRIVS
	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVEI	T1,SNDCHR		;GET CHAR PUTTER
	PUSHJ	P,.TYOCH##		;TELL SCAN
	PUSH	P,T1			;SAVE OLD ONE
	MOVE	P1,[POINT 7,SNDBUF]	;POINT TO TEXT BUFFER
	MOVEI	T1,S.INPUT##		;POINT TO INPUT STRING
	PUSHJ	P,TSTRG			;TYPE STRING
	PUSHJ	P,.TCRLF##		;START NEW LINE
	MOVEI	T1,0			;FINISH OFF
	PUSHJ	P,SNDCHR		;SEND
	POP	P,.TOUTZ##		;RESTORE SCAN TYPER
	MOVEI	T1,.TOTYP		;GET FUNCTION
	MOVEI	T2,SNDBUF		;POINT TO BUFFER
	PUSHJ	P,ACTRMOP		;DO TRMOP
	 TROA	F,FR.TRMOP		;FLAG FAILED
	  POPJ	P,			;RETURN
	JRST	E$$TSF			;TYPE ERROR AND RETURN
	SUBTTL	Action routines -- DOOUTPUT - Output a string to a user

DOOUTPUT:TRNN	F,FR.TRMOP		;TRMOP. UUO FAILED?
	  SKIPN	S.OUTPUT##		;/OUTPUT: GIVEN?
	   POPJ	P,			;NO--JUST RETURN
	PUSHJ	P,ACTPRV		;CHECK PRIVS
	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVEI	T1,SNDCHR		;GET CHAR PUTTER
	PUSHJ	P,.TYOCH##		;TELL SCAN
	PUSH	P,T1			;SAVE OLD ONE
	MOVE	P1,[POINT 7,SNDBUF]	;POINT TO TEXT BUFFER
	MOVEI	T1,S.OUTPUT##		;POINT TO OUTPUT STRING
	PUSHJ	P,TSTRG			;TYPE STRING
	PUSHJ	P,.TCRLF##		;START NEW LINE
	MOVEI	T1,0			;FINISH OFF
	PUSHJ	P,SNDCHR		;SEND
	POP	P,.TOUTZ##		;RESTORE SCAN TYPER
	MOVEI	T1,.TOOUS		;GET FUNCTION
	MOVEI	T2,SNDBUF		;POINT TO BUFFER
	PUSHJ	P,ACTRMOP		;DO TRMOP
DOOU.1:	 TROA	F,FR.TRMOP		;FLAG FAILED
	  POPJ	P,			;RETURN
	JRST	E$$TSF			;TYPE ERROR AND RETURN
	SUBTTL	Action routines -- DOSETUUO - Do SETUUOs for a job

DOSETUUO:TRNN	F,FR.SETUUO		;SETUUO FAILED?
	  SKIPG	SETCNT##		;ANYTHING TO DO?
	   POPJ	P,			;NO--JUST RETURN
	PUSHJ	P,ACTPRV		;CHECK PRIVS
	PUSHJ	P,GACJOB		;GET THE JOB NUMBER
	 POPJ	P,			;NONE
	MOVEI	T2,0			;CLEAR COUNTER
	MOVE	T4,SETCNT##		;GET COUNT OF ARGS
SETU.1:	SOJL	T4,.POPJ##		;RETURN WHEN DONE
	MOVEM	T1,SETBLK##+1(T2)	;STORE USER JOB
	HRRI	T3,SETBLK##+1(T2)	;POINT TO ARGS
	ADD	T2,SETBLK##(T2)		;ADVANCE TO NEXT SET
	HRLI	T3,2			;INDICATE LENGTH
	JBSET.	T3,			;DO THE UUO
	 TROA	F,FR.SETUUO		;FLAG FLAGED
	  JRST	SETU.1			;LOOP FOR ALL
	$WARN	(SUF,<SETUUO failed>,,.POPJ##)
	SUBTTL	Action routines -- DONETWORK - Handle network functions

DONETWORK:SKIPG	T1,S.NETWORK##		;ANYTHING TO DO?
	   POPJ P,			;NO--JUST RETURN
	PUSHJ	P,ACTPRV		;CHECK PRIVS
	MOVE	T1,S.NETWORK##		;GET FUNCTION
	CAIE	T1,NETDISCONNECT##	;DISCONNECT?
	 POPJ	P,			;NO--RETURN
	PUSHJ	P,GACTTY		;GET A TTY NUMBER
	 POPJ	P,			;NONE
	MOVEI	T2,2			;TWO ARGS
	EXCH	T1,T2			;POSITION COUNT,,ARG
	MOVE	T3,[.NDTDS,,T1]		;FUNCTION,,ARGBLK
	NODE.	T3,			;DISCONNECT HIM
	 $WARN	(CDN,<Cant disconnect line >,E.CDN)
	POPJ	P,			;AND RETURN
	SUBTTL	Action routines -- DOHANGUP - Hangup a dialup line

DOHANGUP:SKIPG	T1,.FZHNG##(I)		;ANYTHING TO DO?
	POPJ	P,			;NO--JUST RETURN
	PUSHJ	P,ACTPRV		;CHECK PRIVS
	PUSHJ	P,LB$TLN##		;GET LINE NUMBER
	JUMPL	T1,.POPJ##		;RETURN IF DETACHED
	MOVEI	T2,.TODSF		;DISCONNECT DATASET FUNCTION
	MOVEI	T3,.UXTRM(T1)		;UDX
	MOVE	T1,[2,,T2]		;SET UP UUO
	TRMOP.	T1,			;DO IT
	  $WARN	(CHL,<Can't hangup line >,E.CHL)
	POPJ	P,			;RETURN

E.CHL:	PUSHJ	P,LB$TLN##		;GET LINE NUMBER
	PJRST	.TOCTW##		;TYPE IT AND RETURN
	SUBTTL	Action routines -- INETWORK - Handle initial network functions

INETWORK::MOVE	T1,S.NETWORK##		;GET /NETWORK:ARGS
	CAIE	T1,NETCONNECT##		;CONNECT?
	 POPJ	P,			;NO--RETURN
	PUSHJ	P,ACTPRV		;CHECK PRIVS
	PUSHJ	P,.SAVE2##		;SAVE P1&P2
	PUSHJ	P,S$FIRST##		;POSITION TO FIRST SPEC
	
INET.1:	MOVE	T2,.FZNNM##(I)		;GET NODE NAME
	CAMN	T2,[-1]			;SEE IF GIVEN
	 $FATAL	(NNS,<No node specified for /NETWORK:CONNECT>)
	MOVE	T1,.FZNNM##+1(I)		;GET MASK
	CAME	T1,[-1]			;CHECK FOR WILDCARDS
	 $FATAL	(WNI,<Wildcarded node illegal with /NETWORK:CONNECT>)
	MOVE	T1,.FZNNM##(I)		;GET NODE NAME
	PUSHJ	P,ANODE##		;CONVERT TO NUMBER
	 $WARN	(NNA,<Node not available; cannot connect terminals>,,INET.N)
	MOVEI	P2,(T1)			;SAVE IT FOR LATER
	SKIPGE	P1,.FZNLN##(I)		;SEE IF LINE SPECIFIED
	 JRST	INET.2			;NO--GET THEM ALL
	HRLI	P1,-1			;YES--MAKE SINGLE AOBJN POINTER
	JRST	INET.L			;AND CONNECT HIM
INET.2:	MOVEI	T1,4			;INDICATE LENGTH
	MOVEI	T3,0			;MUST BE ZERO
	MOVX	T4,.TYTTY		;FIND HOW MANY TERMINALS
	MOVE	P1,[.NDRCI,,T1]		;SETUP ARG BLK POINTER
	NODE.	P1,			;ASK MONITOR
	 JRST	E$$NNA			;ERROR
	HLRZ	T1,T4			;GET COUNT OF TERMINALS
	JUMPE	T1,INET.N		;JUMP IF NO TERMINALS
	MOVN	P1,T1			;GET -N
	HRLZS	P1			;MAKE -N,,0
INET.L:	MOVEI	T1,2			;LENGHT
	MOVEI	T2,(P1)			;GET LINE NUMBER
	HRLI	T2,(P2)			;INCLUDE NODE NUMBER
	MOVE	T3,[.NDTCN,,T1]		;GET CONNECT FUNCTION
	NODE.	T3,			;DO IT
	 $WARN	(CCL,<Cannot connect line >,E.CCL)
	AOBJN	P1,INET.L		;LOOP FOR ALL
INET.N:	PUSHJ	P,S$NEXT##		;GET NEXT SCAN BLOCK
	 POPJ	P,			;ALL DONE
	JRST	INET.1			;AND LOOP

E.CCL:	PUSH	P,T3			;SAVE ERROR CODE
	MOVE	T1,.FZNNM##(I)		;GET NODE
	PUSHJ	P,.TSIXN##		;TYPE
	MOVEI	T1,"_"			;DELIMITER
	PUSHJ	P,.TCHAR##		;TYPE
	MOVEI	T1,(P1)			;GET LINE NUMBER
	PUSHJ	P,.TOCTW##		;TYPE
E.CCL1:	MOVEI	T1,[ASCIZ/; /]		;TEXT
	PUSHJ	P,.TSTRG##		;TYPE IT
	POP	P,T1			;RESTORE ERROR CODE
	PUSHJ	P,.TENOD##		;MAP THE ERROR
	 JFCL				;
	PJRST	.TSTRG##		;TYPE STRING AND RETURN

E.CDN:	PUSH	P,T3			;SAVE ERROR CODE
	MOVE	T1,T2			;COPY TTY
	PUSHJ	P,.TSIXN##		;TYPE
	JRST	E.CCL1			;AND FINISH OFF
	SUBTTL	Routines -- ACTPRV - See if privileged

ACTSND:	TDZA	T1,T1			;FLAG SEND PRIV
ACTPRV:	 MOVEI	T1,1			;FLAG NORMAL PRIV
	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVE	P1,T1			;SAVE FLAG
	TLNE	F,(FL.CRASH)		;SEE IF CRASH FILE MODE
	 $FATAL	(ASI,<Action switches illegal when reading crash files>)
	CAIE	M,M%JOB##		;SEE IF JOB MODE
	 JRST	ACTP.2			;NO
	MOVNI	T1,1			;GET -1
	CAMN	T1,.FZJOB##(I)		;SEE IF JOB
	 CAME	T1,.FZNAM##(I)		;OR NAME
	  CAIA				;OK
	   $FATAL (EJR,<Explicit job, name or * required for action functions>)
	MOVEI	T1,.GTPPN		;GET PPN AGAIN
	PUSHJ	P,JTAB##		;..
	PUSH	P,T1			;SAVE CURRENT PPN
	PUSHJ	P,JB$PPN##		;GET ORIGINAL PPN
	POP	P,T2			;RESTORE CURRENT
	CAME	T1,T2			;SAME AS BEFORE?
	 JRST	ACTP.1			;NO--ERROR
	MOVEI	T1,.GTSTS		;GET JOB STATUS AGAIN
	PUSHJ	P,JTAB##		;..
	TXC	T1,JS.LOG!JS.JNA	;ASSIGNED AND LOGGED IN?
	TXCE	T1,JS.LOG!JS.JNA	;CHECK AGAIN
	 JRST	ACTP.1			;NO--ERROR
	PUSHJ	P,JB$PPG##		;GET PROGRAMMER NUMBER
	HRRZ	T2,.MYPPN##		;AND MINE
	CAIN	T1,(T2)			;MATCH ME?
	 POPJ	P,			;YES--LET ME TRY
	JUMPN	P1,ACTP.1		;NO--DO NORMAL CHECKS IF NOT SEND
	PUSHJ	P,JB$PPJ##		;GET USER PROJECT
	HLRZ	T2,.MYPPN##		;AND MINE
	CAIN	T1,(T2)			;MATCH ME?
	 POPJ	P,			;YES--LET ME TRY
	JRST	ACTP.1			;NO--DO NORMAL CHECKS

ACTP.2:	MOVNI	T1,1			;GET -1
	CAMN	T1,.FZTTY##(I)		;SEE IF TERMINAL
	 CAME	T1,.FZNNM##(I)		;OR NODE
	  CAIA				;OK
	 $FATAL (ELR,<Explicit node, line, device, or * required for action functions>)
	PUSHJ	P,LB$JOB##		;GET JOB USING TERMINAL
	CAMN	T1,MYJOB##		;ME?
	 POPJ	P,			;YES--LET ME TRY
					;NO--DO NORMAL CHECKS
ACTP.1:	TLNE	F,(FL.JACCT)		;SEE IF JACCTED
	 TLNE	F,(FL.GOD!FL.POKE)	;YES--SEE IF [1,2] OR POKE
	  POPJ	P,			;NO PRIVS--TRY ANYWAY
	   $FATAL (FRP,<Function requires privileges>)
	SUBTTL	Routines -- GACJOB - Get a target job number

GACJOB:	CAIN	M,M%JOB##		;JOB MODE?
	 PUSHJ	P,JB$JOB##		;YES--GET JOB
	CAIN	M,M%LINE##		;LINE MODE?
	 PUSHJ	P,LB$JOB##		;YES--GET JOB
	JUMPE	T1,.POPJ##		;ERROR IF NONE
	JRST	.POPJ1##		;ELSE SKIP RETURN

	SUBTTL	Routines -- GACLIN - Get a target line number

GACLIN:	CAIN	M,M%JOB##		;JOB MODE?
	 PUSHJ	P,JB$TLN##		;YES--GET LINE
	CAIN	M,M%LINE##		;LINE MODE?
	 PUSHJ	P,LB$TLN##		;YES--GET LINE
	JUMPL	T1,.POPJ##		;ERROR IF DETACHED
	ADDI	T1,.UXTRM		;MAKE UDX
	JRST	.POPJ1##		;AND SKIP RETURN

	SUBTTL	Routines -- GACDES - Get a target line or job number

GACDES:	CAIE	M,M%JOB##		;SEE IF JOB MODE
	 JRST	GACD.1			;NO
	PUSHJ	P,JB$TLN##		;GET TERMINAL
	JUMPL	T1,.POPJ##		;ERROR IF DETACHED
	PUSHJ	P,JB$JOB##		;GET JOB NUMBER
	PJRST	.POPJ1##		;AND SKIP RETURN

GACD.1:	PUSHJ	P,LB$JOB##		;GET JOB NUMBER
	JUMPN	T1,.POPJ1##		;USE THAT IF PRESENT
	PUSHJ	P,LB$TLN##		;ELSE GET LINE NUMBER
	ADDI	T1,.UXTRM		;MAKE UDX
	JRST	.POPJ1##		;AND SKIP RETURN

	SUBTTL	Routines -- GACTTY - Get a target terminal name

GACTTY:	CAIE	M,M%JOB##		;JOB MODE?
	 JRST	GACT.1			;NO
	PUSHJ	P,JB$TLN##		;GET LINE
	JUMPL	T1,.POPJ##		;ERROR IF DETACHED
	PUSHJ	P,JB$TTY##		;GET TTY NAME
	JRST	.POPJ1##		;AND SKIP RETURN

GACT.1:	PUSHJ	P,LB$TTY##		;GET TTY NAME
	JRST	.POPJ1##		;AND SKIP RETURN
	SUBTTL	Storage

	$LOW

SNDBUF:	BLOCK	LN$SND+3
TRMBLK:	BLOCK	3
FRCBLK:	BLOCK	2

	END
