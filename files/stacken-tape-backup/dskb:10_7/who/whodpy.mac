	TITLE	WHODPY - DPY interface for WHO

	SEARCH	WHOMAC

	$SETUP	(WHODPY)

Comment |

This module contains all the interfaces to OToole's DPYPAK that
WHO uses. It handles all display related functions.

|
;               TABLE OF CONTENTS FOR WHODPY
;
;
;                        SECTION                                   PAGE
;    1. DPINI - Initialize display................................   3
;    2. DPSLP
;         2.1   DPY sleep routine.................................   4
;         2.2   Command processor routines........................   5
;    3. Subroutines
;         3.1   IXCT - Execute routine for each 'I'...............   7
;    4. DPXIT - DPY user exit.....................................   8
;    5. DPLIN - Initialize per display output.....................   9
;    6. DPROL - Roll the screen n lines...........................  10
;    7. DPCLR - CLean up at the end of a display cycle............  11
;    8. DPCHR - Output a character to DPYPAK......................  12
;    9. Storage...................................................  13
	SUBTTL	DPINI - Initialize display

DPINI::	SKPYES	S.DPY##		;SEE IF /DPY
	 POPJ	P,		;NO--JUST RETURN
	PUSHJ	P,DP.SAC
	MOVE	T1,[ASCII/VT52 /];AS GOOD AS ANY TO TRY
	MOVEM	T1,DP.TRM
	MOVEI	16,[-2,,0
		       [7]
		       DP.TRM]+1
	PUSHJ	P,DPYINI##
	CAMN	0,[-1]
	 $FATAL	(TNS,<Terminal type not supported for /DPY>)
	PUSHJ	P,DPYZAP##
	PUSHJ	P,DP.RAC
	MOVE	T1,[POINT 7,DP.BUF]
	MOVEM	T1,DP.PTR
	SETZM	DP.LIN
	SETZM	DP.OLN
	SETZM	DP.LLN
	SETZM	DP.SLN
	SETZM	DP.NUM
	TRO	F,FR.DPY	;FLAG DPY IS INITED
	PJRST	OPNDPY##	;AND OPEN TERMINAL W/O ECHO
	SUBTTL	DPSLP -- DPY sleep routine

DPSLP::	PUSHJ	P,.SAVE2##	;SAVE P2
	MOVE	P1,T1		;SAVE SLEEP TIME
DPSL.1:	CAIG	P1,^D60		;MORE THAN 60 SECONDS?
	 SKIPA	T1,P1		;NO--SLEEP FOR WHAT WE GOT
	  MOVEI	T1,^D60		;YES--SLEEP FOR MAX
	IMULI	T1,^D1000	;FIXUP FOR HIBER (MS)
	TXO	T1,HB.RTC	;WAKE ON CHARACTER INPUT
	HIBER	T1,		;GO SLEEP
	 $FATAL	(HUF,<HIBER UUO failure>)
DPSL.4:	INCHRS	T1		;GET A CHAR
	 JRST	DPSL.2		;NOTHING
	CAIL	T1,"0"		;NUMBER?
	 CAILE	T1,"9"		;..
	  JRST	DPSL.A		;NO
	MOVE	T2,DP.NUM	;GET NUMBER
	IMULI	T2,^D10		;SHIFT OVER
	ADDI	T2,-"0"(T1)	;ADD IN DIGIT
	MOVEM	T2,DP.NUM	;STORE IT
	JRST	DPSL.4		;AND TRY FOR NEXT CHAR
DPSL.A:	CAIL	T1,"a"		;SEE IF LOWER CASE
	 CAILE	T1,"z"		;..
	  CAIA			;NO
	   SUBI	T1,"a"-"A"	;YES--CONVERT
	MOVSI	T2,-CMDLEN	;LENGTH OF RUNTIME COMMANDS
DPSL.3:	LDB	T3,[POINT 7,CMDTAB(T2),6];GET A CHAR
	CAIE	T1,(T3)		;MATCH?
	 AOBJN	T2,DPSL.3	;NO--LOOP FOR ALL
	MOVE	T1,CMDTAB(T2)	;GET BITS
	MOVEI	T3,0		;GET A ZERO
	EXCH	T3,DP.NUM	;CLEAR COUNTER,,MOVE INTO T3
	PUSHJ	P,(T1)		;CALL ROUTINE
	JRST	DPSL.4		;AND TRY FOR ANOTHER CMD
DPSL.2:	SUBI	P1,^D60		;MINUS WHAT WE DID
	JUMPG	P1,DPSL.1	;LOOP IF MORE
	POPJ	P,		;AND RETURN

DEFINE XX(CHAR,DISP),<EXP <CHAR>B6!DISP>

CMDTAB:	XX	"R",C.REFRESH
	XX	"I",C.INCREMENTAL
	XX	"A",C.SIZE
	XX	"C",C.CHANNEL
	XX	"D",C.DDBS
	XX	"P",C.PERFORMACE
	XX	"O",C.ORIGIN
	XX	"M",C.MAP
	XX	"H",C.HELP
	XX	"E",C.EXIT
	XX	"S",C.SLEEP
	XX	"B",C.BATCH
	XX	.CHCNZ,C.EXIT
	XX	.CHCNC,C.EXIT
	XX	"+",C.ADD
	XX	"-",C.SUB
	XX	" ",.POPJ##
CMDLEN==.-CMDTAB
	XX	"?",C.ERROR	;**MUST BE LAST OUTSIDE CMDLEN**
	SUBTTL	DPSLP -- Command processor routines

C.EXIT:	PUSHJ	P,DPXIT
	EXIT	1,
	PJRST	DPCON

C.INCR:	MOVEI	T1,1		;GET A BIT
	XORM	T1,S.INCREMENTAL## ;TOGGLE IT
	POPJ	P,		;AND RETURN

C.PERF:	MOVEI	T1,[MOVEI T1,1
		    XORM  T1,.FZPRF##(I)
		    POPJ  P,]
	PJRST	IXCT

C.MAP:	MOVEI	T1,[MOVEI T1,1
		    XORM  T1,.FZMAP##(I)
		    POPJ  P,]
	PJRST	IXCT


C.SLEEP:JUMPE	T3,C.SLOW	;ZERO IS SPECIAL CASE
	MOVEM	T3,S.REPEAT##	;STORE REPEAT TIME
	POPJ	P,		;AND RETURN

C.SLOW:	MOVEI	T1,[MOVE   T1,.FZFMT##(I)
		    CAIN   T1,%SLOW##	;SLOW?
		     SKIPA T1,[%NORMAL##];YES--MAKE NORMAL
	  	      MOVEI T1,%SLOW##	;NO--MAKE SLOW
		    MOVEM  T1,.FZFMT##(I);SAVE
		    PJRST  SETFM##]
	PJRST	IXCT

C.ADD:	CAIN	T3,0		;SEE IF DEFAULT
	 SKIPA	T1,MAXL##	;YES--FIX UP
	  MOVEI	T1,(T3)		;NO--COPY INTO T1
	PUSHJ	P,DPROL		;ROLL THE SCREEN
	ADDM	T1,DP.SLN	;ADD SCROLLING LINES
	POPJ	P,		;AND RETURN

C.SUB:	CAIN	T3,0		;SEE IF DEFAULT
	 MOVE	T3,MAXL##	;YES--FIX UP
	CAMLE	T3,DP.SLN	;SEE IF SCROLLING MORE THAN WE GOT
	 SKIPA	T1,DP.SLN	;YES--GET SCROLL WHAT WE HAVE
	  MOVEI	T1,(T3)		;NO--SCROLL IT ALL
	MOVNS	T1		;INDICATE UP
	PUSHJ	P,DPROL		;ROLL THE SCREEN
	MOVE	T1,DP.SLN	;GET CURRENT SCROLL
	SUB	T1,T3		;MINUS WHAT WE DID
	CAIGE	T1,0		;SEE IF .LT. 0
	 MOVEI	T1,0		;YES--MAKE 0
	MOVEM	T1,DP.SLN	;SAVE NEW SCROLL WINDOW
	POPJ	P,		;AND RETURN

C.BATCH:MOVX	T3,IFMBATCH##	;GET THE BIT FOR BATCH
	JRST	CTOG

C.CHAN:	JUMPE	T3,CHAN.1
	MOVEM	T3,S.COLUMN##
	PUSHJ	P,DP.SAC
	PUSHJ	P,DPYZAP##
	PUSHJ	P,DP.SAC
	POPJ	P,

CHAN.1:	SKIPA	T3,[IFMCHANNEL##]	;GET THE BIT FOR CHANNEL
C.SIZE:	 MOVX	T3,IFMSIZE##	;GET THE BIT FOR SIZE
	JRST	CTOG

C.DDBS:	SKIPA	T3,[IFMDDBS##]	;GET BIT FOR DDBS
C.ORIGI: MOVX	T3,IFMORIGIN##	;GET THE BIT FOR ORIGIN
CTOG:	MOVEI	T1,[IORM  T3,.FZINM##(I)
		    XORM  T3,.FZINF##(I)
		    POPJ  P,]
	PJRST	IXCT

C.REFRESH:
	PUSHJ	P,DP.SAC	
	PUSHJ	P,DPYREF##
	PJRST	DP.RAC

C.ERROR:OUTCHR	[.CHBEL]
	POPJ	P,

C.HELP:	MOVE	T1,MAXS##	;DPYPAK SAYS THIS IS BIG ENOUGH
	PUSHJ	P,M$GMEM##	;ALLOCATE THE CORE
	 POPJ	P,		;ERROR--NO HELP!
	MOVEM	T2,DP.COR	;STORE
	PUSHJ	P,DP.SAC	;SAVE THE ACS
	MOVEI	16,[-1,,0
		    @DP.COR]+1
	PUSHJ	P,DPYSAV##	;SAVE THE CURRENT SCREEN
	PUSHJ	P,DPYZAP##	;CLEAR IT OUT
	OUTSTR	HELTXT		;OUTPUT THE HELP
	MOVEI	T1,^D60*^D1000	;LET HIM READ
	TXO	T1,HB.RTC	;OR TYPE AHEAD IF IMPATIENT
	HIBER	T1,		;ZZZ
	 JRST	E$$HUF		;FAILED?
	INCHRS	T1		;EAT HIS CHAR IF HE TYPED ONE
	 JFCL			;GUESS HE WAITED 60 SECONDS
	PUSHJ	P,DPYZAP##	;START CLEAN AGAIN
	MOVEI	16,[-1,,0
		    @DP.COR]+1
	PUSHJ	P,DPYRST##	;MAKE THE SCREEN COME BACK
	PUSHJ	P,DP.RAC	;RESTORE ACS
	MOVE	T1,MAXS##	;SIZE OF BLOCK
	MOVE	T2,DP.COR	;ADDRESS
	PUSHJ	P,M$RMEM##	;DEALLOCATE IT
	 HALT
	POPJ	P,		;AND RETURN

DEFINE	TEXT(STR),<
	XLIST
	ASCIZ	|STR|
	LIST
>

HELTXT:	TEXT	<
Type one of the following characters

space	Update screen now
nn+	Scroll display up n lines (default=1 display page)
nn-	Scroll display down n lines (default=1 display page)
A	Toggle access table display (implies DDB display also)
C	Toggle channel display
nnC	Set screen display to n columns
D	Toggle DDB display
E	Exit now
H	Help text
I	Toggle incremental vs total statistics
M	Toggle mapping to alternate mode
O	Toggle program origin display
P	Toggle performance display
R	Refresh the screen now
S	Toggle normal/slow format display mode
nnS	Set sleep time to n seconds

Wait 60 seconds or type any character to proceed
>
	SUBTTL	Subroutines -- IXCT - Execute routine for each 'I'

IXCT:	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVEI	P1,(T1)			;COPY ROUTINE ADDRESS
	PUSHJ	P,S$FIRST##		;POSITION TO FIRST SCAN SPEC
IXCT.L:	PUSHJ	P,(P1)			;CALL ROUTINE
	PUSHJ	P,S$NEXT##		;POSITION TO NEXT SCAN SPEC
	 POPJ	P,			;ALL DONE
	JRST	IXCT.L			;AND LOOP
	SUBTTL	DPXIT - DPY user exit

DPXIT::	SKIPG	S.DPY##		;SEE IF /DPY
	 POPJ	P,		;NO--JUST RETURN
	OUTCHR	[.CHCRT]	;<CR> TO RESET SCNSERS CHAR POSITION
	MOVE	T1,MAXL##	;GET MAX LINE
	TLNE	F,(FL.WATCH)	;ANY WATCH BITS?
	 SUBI	T1,2		;YES--TWO LESS LINES
	MOVEM	T1,DP.ARG	;STORE
	PUSHJ	P,DP.SAC	;SAVE THE AC'S
	MOVEI	16,[-4,,0
			[^D1]
		 	DP.ARG
			[^D80]
			MAXL##]+1
	PUSHJ	P,DPYCSC##		;CLEAR SECTION
	MOVE	T1,MAXL##	;GET MAX LINE
	SUBI	T1,1		;A LITTLE LESS (EXIT 1, DOES CRLF)
	MOVE	F,DP.AC		;RESTORE F
	TLNE	F,(FL.WATCH)	;WATCH ON?
	 SUBI	T1,1		;YES--COMPENSATE FOR ANOTHER LINE
	MOVEM	T1,DP.ARG
	MOVEI	16,[-3,,0
			[-1]
		 	[^D1]
			DP.ARG]+1
	PUSHJ	P,DPYCHR##
	PUSHJ	P,DPYXIT##	;RESET TERMINAL PARAMETERS
	TRZ	F,FR.DPY	;DPY IS OVER
	PJRST	DP.RAC		;RESTORE AC'S AND RETURN

DPCON::	SKIPG	S.DPY##
	 POPJ	P,
	TRO	F,FR.DPY	;DPY IS BACK!
	PUSHJ	P,DP.SAC
	PUSHJ	P,DPYTTY##
	PUSHJ	P,DPYREF##
	PJRST	DP.RAC
	SUBTTL	DPLIN - Initialize per display output

DPLIN::	SKPYES	S.DPY##			;SEE IF /DPY
	 POPJ	P,			;NO--JUST RETURN
	SETZM	DP.LIN			;START WITH LINE 0
	SETZM	DP.OLN			;AND NO LINES OUTPUT
	MOVEI	T1,DPCHR		;POINT TO SCANS CHARACTER LISTER
	MOVEM	T1,.TOUTZ##		;STORE
	POPJ	P,			;RETURN
	SUBTTL	DPROL - Roll the screen n lines

DPROL:	JUMPE	T1,.POPJ##
	PUSHJ	P,DP.SAC
	MOVEM	T1,DP.ROL
	MOVEI	16,[-1,,0
		        DP.ROL]+1
	PUSHJ	P,DPYROL##
	PUSHJ	P,DP.RAC
	POPJ	P,
	SUBTTL	DPCLR - CLean up at the end of a display cycle

DPCLR::	SKPYES	S.DPY##			;SEE IF /DPY
	 POPJ	P,			;NO--RETURN
	MOVE	T1,DP.OLN		;GET LINES OUTPUT THIS PASS
	PUSH	P,T1			;SAVE IT
	CAMGE	T1,DP.LLN		;MORE THAN LAST?
	  PUSHJ	P,LINCLR		;NO--CLEAR THE REST
	POP	P,DP.LLN		;AND SAVE FOR NEXT PASS
	POPJ	P,			;AND RETURN

LINCLR:	PUSHJ	P,DP.SAC		;SAVE THE ACS
LINC.1:	AOS	T1,DP.OLN		;COUNT LINES
	CAMLE	T1,DP.LLN		;ALL LINES CLEAR?
	  PJRST	DP.RAC			;YES--RESTORES ACS AND CONTINUE
	PUSHJ	P,FNDLIN		;CONVERT TO DPYPAK LINE/COLUMN
	 PJRST	DP.RAC			;OUT OF RANGE
	MOVEM	T1,DP.AG1		;SAVE LINE
	MOVEM	T2,DP.AG2		;STARTING COLUMN
	MOVEM	T3,DP.AG3		;ENDING COLUMN
	MOVEI	16,[-4,,0
			DP.AG2
			DP.AG1
			DP.AG3
			DP.AG1]+1
	PUSHJ	P,DPYCSC##		;CLEAR SECTION
	JRST	LINC.1			;AND LOOP
	SUBTTL	DPCHR - Output a character to DPYPAK

DPCHR::	CAIN	T1,.CHCRT		;<CR>?
	  POPJ	P,			;YES
	CAIN	T1,.CHLFD		;<LF>?
	  JRST	DP.CH1			;YES
	IDPB	T1,DP.PTR		;STORE CHAR
	POPJ	P,			;AND RETURN

DP.CH1:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	AOS	T1,DP.LIN		;GET CURRENT LINE
	PUSHJ	P,FNDLIN		;GET DPYPAK LINE
	 JRST	DP.CH2			;LINE OUT OF RANGE
	MOVEM	T1,DP.AG1		;SAVE LINE
	MOVEM	T2,DP.AG2		;STARTING COLUMN
	MOVEM	T3,DP.AG3		;ENDING COLUMN
	MOVE	T4,DP.LIN		;GET CURRENT LINE
	MOVEM	T4,DP.OLN		;SAVE AS LAST OUTPUT
REPEAT 0,<
	MOVE	T1,DP.LIN		;GET LINE
	IDIVI	T1,7
	MOVE	T1,[0
		    CA.BLD
		    CA.UDS!CA.NAB
		    CA.BNK
		    CA.RVD!CA.NAB
		    CA.BLD!CA.UDS
		    CA.BNK!CA.RVD
		    CA.BNK!CA.RVD!CA.UDS](T2)
>
	MOVEI	T1,0
	MOVEM	T1,DP.ATR
	PUSHJ	P,DP.SAC
	MOVEI	16,[-6,,0
			DP.BUF
			DP.AG2
			DP.AG1
			DP.AG3
			DP.AG1
			DP.ATR]+1
	PUSHJ	P,DPYRSC##
	PUSHJ	P,DP.RAC
DP.CH2:	MOVE	T1,[POINT 7,DP.BUF]
	MOVEM	T1,DP.PTR
	SETZM	DP.BUF
	MOVE	T1,[DP.BUF,,DP.BUF+1]
	BLT	T1,DP.BUF+^D30
	POPJ	P,

DP.SAC:	MOVEM	0,DP.AC
	MOVE	0,[1,,DP.AC+1]
	BLT	0,DP.AC+16
	POPJ	P,

DP.RAC:	MOVE	0,[DP.AC+1,,1]
	BLT	0,16
	MOVE	0,DP.AC
	POPJ	P,

FNDLIN:	SUBI	T1,1			;DPYPAK STARTS WITH LINE 1
	SUB	T1,DP.SLN		;MINUS SCROLL LINE
	IDIV	T1,MAXL##		;MODULE SCREEN SIZE
	EXCH	T1,T2			;FLIP
	CAIL	T1,0			;LINE WITHIN RANGE?
	 CAML	T1,MAXL##		;..
	  POPJ	P,			;NO--NON SKIP
	MOVE	T3,MAXC##		;TERMINAL WIDTH
	IDIV	T3,S.COLUMN##		;NUMBER OF COLUMNS DESIRED
	IMULI	T2,(T3)			;COMPUTE LEFTMOST COLUMN
	ADDI	T2,1			;..
	ADDI	T3,(T2)			;FORM RIGHTMOST COLUMN
	SUBI	T3,2			;ALLOW A LITTLE LESS
	AOJA	T1,.POPJ1##		;BUMP LINE NUMBER AND RETURN
	SUBTTL	Storage

	$LOW

DP.PTR:	BLOCK	1
DP.LIN:	BLOCK	1
DP.LLN:	BLOCK	1
DP.SLN:	BLOCK	1
DP.OLN:	BLOCK	1
DP.NUM:	BLOCK	1
DP.ROL:	BLOCK	1
DP.BUF:	BLOCK	^D30+1
DP.AC:	BLOCK	20
DP.TRM:	BLOCK	1
DP.ARG:	BLOCK	1
DP.AG1:	BLOCK	1
DP.AG2:	BLOCK	1
DP.AG3:	BLOCK	1
DP.ATR:	BLOCK	1
DP.COR:	BLOCK	1

	END
