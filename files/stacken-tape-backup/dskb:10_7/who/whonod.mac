	TITLE	NODSCN - NODE mode scan defaulting for WHO

	SEARCH	WHOMAC

	$SETUP	(NODSCN)

Comment |

This module provides the NODE mode specific scan defaulting code. Its
only entry point is NODSCN.

|
;               TABLE OF CONTENTS FOR NODSCN
;
;
;                        SECTION                                   PAGE
;    1. NODSCN - Apply NODE mode specific scan input defaults.....   3
;    2. Storage...................................................   4
	SUBTTL	NODSCN - Apply NODE mode specific scan input defaults

;This routine applies the following defaults to the command line
;

NODSCN::
;
;Here to fix up name and extension (can be job, TTY, or name)
;
	SKIPE	T1,.FXEXT(I)		;SEE IF EXTENSION GIVEN
	  JRST	[CAIN	T1,-1		;YES--INSURE JUST EXTENSION
		  SKIPE	.FXNAM(I)	;AND NO NAME
		   JRST	E$$EIC		;BECAUSE THATS BAD
		 PUSHJ	P,CHKDOT##	;SEE IF DOT VALID (NOT CRASH FILE)
		 MOVE	T1,MYNOD##	;GET USERS NOD
		 CHKSWT	(NNM,NODE)
		 JRST	.+1]		;AND CONTINUE
	SKIPN	T1,.FXNAM(I)		;SEE IF NAME
	  JRST	NODS.2			;NO
	SKIPE	.FXEXT(I)		;YES--INSURE NO EXTENSION
	 $FATAL (EIC,<Extension illegal in this context>)	;NO--DIE
	TXNE	T1,77B5			;FIRST CHAR BLANK?
	  JRST	NODS.3			;NO
	MOVSS	T1			;POSITION NODE NUMBER
	CHKSWT	(NNM,NODE)
	JRST	NODS.2			;AND DEFAULT

NODS.3:	MOVE	T1,.FXNAM(I)		;GET NAME
	CHKSWT	(NNM,NODE)
	MOVE	T1,.FXNMM(I)		;GET NAME MASK
	MOVEM	T1,.FZNOM##(I)		;STORE AS NODE MASK
NODS.2:	PUSHJ	P,FIXNOD##		;FIX UP NODE SPEC
;
;All done with this scan spec
;
	POPJ	P,			;AND RETURN
	SUBTTL	Storage

	$LOW

	PRGEND
	TITLE	NODGET - Get node information

	SEARCH	WHOMAC
	$SETUP	(NODGET)

IFN	FTIPC,<SEARCH	TSGSYM>
;               TABLE OF CONTENTS FOR NODGET
;
;
;                        SECTION                                   PAGE
;    1. Main NOD routines
;         1.1   NODNXT - Get the next node........................   3
;         1.2   NODSET - Setup for a new node.....................   4
;         1.3   NODINC - Handle incremental statistics............   5
;         1.4   NODSRT - Handle node sorting......................   6
;    2. NOD tables
;         2.1   Define all node subfields.........................   7
;    3. DATA STORAGE..............................................  12
	SUBTTL	Main NOD routines -- NODNXT - Get the next node

NODNXT::JUMPL	O,NODN.1		;JUMP IF THE FIRST TIME
	SKIPL	S.SORT##		;SEE IF /SORT
	 JRST	SRTNXT			;YES--GET NEXT NOD
	ADDI	O,1			;NO--BUMP TO NEXT
	CAMLE	O,MAXNOD		;SEE IF PAST END
	 POPJ	P,			;YES--RETURN
	JRST	NODN.2			;NO--SETUP FOR THIS NOD

NODN.1:	MOVEI	T1,177			;MAX NODE NUMBER
	MOVEM	T1,MAXNOD		;SAVE
	MOVEI	T1,^D10			;SET A HASH TABLE LENGTH
	MOVEI	T2,^D2			;AND SIZE OF ENTRY
	PUSHJ	P,.HASHI##		;INIT IT
	MOVEI	O,1			;START WITH NOD 1
	SKIPL	T1,S.SORT##		;GET /SORT
	 JRST	NODSRT			;GO PROCESS IF GIVEN

NODN.2:	PUSHJ	P,NODSET		;SETUP FOR THIS NOD
	 JRST	NODNXT			;NOT ASSIGNED
	JRST	.POPJ1##		;AND RETURN
	SUBTTL	Main NOD routines -- NODSET - Setup for a new node

NODSET::SKIPE	JP,NODCOR		;SEE IF CORE ALLOCATED YET
	 JRST	NODS.C			;YES
	MOVEI	T1,.NBLEN		;NO--GET SIZE
	PUSHJ	P,M$ALLOC##		;GET CORE
	MOVEM	T1,NODCOR		;SAVE STARTING ADDRESS
	MOVEI	JP,(T1)			;AND INTO JP
NODS.C:	HRLI	T1,(JP)			;GET STARTING ADDRESS
	HRRI	T1,1(JP)		;ENDING ADDRESS
	SETOM	(JP)			;SET FIRST WORD TO -1
	BLT	T1,.NBLEN-1(JP)		;AND SET THEM ALL TO -1
	MOVEI	T1,(O)			;GET NODE
	PJRST	ANODE##			;SEE IF ONLINE
	SUBTTL	Main NOD routines -- NODINC - Handle incremental statistics

NODINC::
NODINJ:	POPJ	P,			;NONE FOR NOW
	SUBTTL	Main NOD routines -- NODSRT - Handle node sorting

NODSRT:	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVEI	P1,(T1)			;SAVE SORT INDEX
	MOVE	T1,MAXNOD		;GET MAX NODS
	IMULI	T1,2			;2 WORD TABLE
	MOVN	T2,T1			;NEGATE INTO T2
	HRLZM	T2,SRTTAB		;SAVE -N,,0
	PUSHJ	P,I$ALLOC##		;GET THE CORE
	HRRM	T1,SRTTAB		;SAVE START
SRTJ.1:	PUSHJ	P,NODSET		;SETUP FOR THIS NOD
	 JRST	SRTJ.2			;NOT ASSIGNED
	PUSHJ	P,@SUMLOD##(P1)		;GET SORT KEY
	MOVEI	T2,-1(O)		;GET NOD
	IMULI	T2,2			;DOUBLE
	ADD	T2,SRTTAB		;PLUS START OF TABLE
	MOVEM	T1,(T2)			;SAVE SORT KEY FIELD
	MOVEM	O,1(T2)			;SAVE NOD NUMBER
SRTJ.2:	ADDI	O,1			;BUMP TO NEXT NOD
	CAMG	O,MAXNOD		;ALL DONE?
	 JRST	SRTJ.1			;NO--ADVANCE TO NEXT
	MOVE	T1,SRTTAB		;GET AOBJN WORD
	MOVE	T2,[400000,,2]		;UNSIGNED AND STRAIGHT SORT
	SKIPLE	S.SORT##+1		;SEE IF DESCENDING
	 TLO	T2,200000		;YES-SET FLAG
	PUSHJ	P,.SORT2##		;SORT THE LIST
	MOVE	T1,SRTTAB		;GET AOBJN
	MOVEM	T1,SRTPTR		;SAVE
	SETZM	SRTCNT			;NO NODS YET
	JRST	NODNXT			;AND BACK TO THE TOP


SRTNXT:	SKIPL	T1,SRTPTR		;GET POINTER
	 POPJ	P,			;ALL DONE
	SKIPN	O,1(T1)			;GET NOD NUMBER
	 JRST	SRTN.1			;NONE
	PUSHJ	P,NODSET		;SETUP FOR THIS NOD
	 JRST	SRTN.1			;NOT ASSIGNED NOW?
	AOS	T1,SRTCNT		;COUNT THE NODS
	CAMLE	T1,S.SORT##+2		;IN RANGE?
	 POPJ	P,			;NO--STOP NOW
	MOVE	T1,[2,,2]		;ADVANCE POINTER
	ADDM	T1,SRTPTR		;TO NEXT PAIR
	JRST	.POPJ1##		;AND USE THAT J

SRTN.1:	MOVE	T1,[2,,2]		;ADVANCE POINTER
	ADDM	T1,SRTPTR		;TO NEXT PAIR
	JRST	SRTNXT			;AND GET NEXT
	SUBTTL	NOD tables -- Define all node subfields

;This macro fetches a sub-field about the node. If the field has been
;gotten before, it simply returns the known field. If the field has
;not been gotten before, it it derived/computed, stored for later
;use, and returned.
;
;In all cases, the field will be returned in T1, and set in table
;.NBxxx (flag NB%xxx indicates if the field has been gotten)

DEFINE	NB$(X,N<1>),<
   XLIST
	NB%'X==.NBLEN			;;FLAG WORD
	.NB'X==.NBLEN+1			;;DATA WORD
	.NBLEN==.NBLEN+2
IFG N-1,.NBLEN==.NBLEN+N
	NB$'X::	AOSN	NB%'X(JP)	;;DO WE HAVE THE INFO?
		 JRST	NB1'X		;;NO--GO GET IT
		MOVE	T1,.NB'X(JP)	;;YES--JUST GET IT NOW
		POPJ	P,		;;AND RETURN
	NB1'X:				;;(HERE TO GET INFO)
   DEFINE END$,<
	XLIST
	MOVEM	T1,.NB'X(JP)		;STORE
	POPJ	P,			;AND RETURN
	LIST
   >
   LIST
>;END DEFINE

	.NBLEN==0
DEFINE XX(NAM),<
	OBJ'NAM==ZZ
	ZZ==ZZ+1
>;END DEFINE XX

ZZ==0

	OBJECTS
DEFINE XX(NAM),<
	NB$(NAM)
		PUSHJ	P,NB$OBJ
		HRRZ	T1,.NBOBJ+1+OBJ'NAM(JP)
		END$
>;END DEFINE XX

OBJECTS
NB$(NNU)	;NETWORK NODE NUMBER
	MOVE	T1,O
	END$

NB$(NNM)	;NETWORK NODE NAME
	MOVE	T1,[1,,.NBNNM]
	MOVEI	T2,ND.SNM
	PUSHJ	P,NODNDB
	MOVE	T1,.NBNNM(JP)
	END$


NB$(CTL)	;STATION CONTROL JOB
	MOVE	T1,[1,,.NBCTL]		;ONE WORD
	MOVEI	T2,ND.CTJ		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBCTL(JP)		;RETURN VALUE
	END$

NB$(LAP)	;LAST ACK PROCESSED
	MOVE	T1,[1,,.NBLAP]		;ONE WORD
	MOVEI	T2,ND.LAP		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBLAP(JP)		;RETURN VALUE
	END$

NB$(LAR)	;LAST ACK RECEIVED
	MOVE	T1,[1,,.NBLAR]		;ONE WORD
	MOVEI	T2,ND.LAR		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBLAR(JP)		;RETURN VALUE
	END$

NB$(LAS)	;LAST ACK SENT
	MOVE	T1,[1,,.NBLAS]		;ONE WORD
	MOVEI	T2,ND.LAS		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBLAS(JP)		;RETURN VALUE
	END$

NB$(LMA)	;LAST MESSAGE ASSIGNED
	MOVE	T1,[1,,.NBLMA]		;ONE WORD
	MOVEI	T2,ND.LMA		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBLMA(JP)		;RETURN VALUE
	END$

NB$(LMP)	;LAST MESSAGE PROCESSED
	MOVE	T1,[1,,.NBLMP]		;ONE WORD
	MOVEI	T2,ND.LMP		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBLMP(JP)		;RETURN VALUE
	END$

NB$(LMR)	;LAST MESSAGE RECEIVED
	MOVE	T1,[1,,.NBLMR]		;ONE WORD
	MOVEI	T2,ND.LMR		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBLMR(JP)		;RETURN VALUE
	END$

NB$(LMS)	;LAST MESSAGE SENT
	MOVE	T1,[1,,.NBLMS]		;ONE WORD
	MOVEI	T2,ND.LMS		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBLMS(JP)		;RETURN VALUE
	END$

NB$(MOM)	;MAXIMUM OUTSTANDING MESSAGE COUNTER
	MOVE	T1,[1,,.NBMOM]		;ONE WORD
	MOVEI	T2,ND.MOM		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBMOM(JP)		;RETURN VALUE
	END$

NB$(OPR)	;OPR TTY NUMBER
	MOVE	T1,[1,,.NBOPR]		;ONE WORD
	MOVEI	T2,ND.OPR		;GET FIELD NUMBER
	PUSHJ	P,NODNDB		;GET IT FROM NETSER
	MOVE	T1,.NBOPR(JP)		;RETURN VALUE
	END$

NB$(CNF,7)	;CONFIGURATION NAME
	MOVE	T1,[7,,.NBCNF+1]
	MOVEI	T2,ND.SID
	PUSHJ	P,NODNDB
	MOVEI	T1,.NBCNF+1(JP)
	END$

NB$(DAT,3)	;DATE
	MOVE	T1,[3,,.NBDAT+1]
	MOVEI	T2,ND.DAT
	PUSHJ	P,NODNDB
	MOVEI	T1,.NBDAT+1(JP)
	END$

NB$(OBJ,LN$OBJ)	;OBJECT TYPES
	MOVE	T1,[LN$OBJ,,.NBOBJ+1]	;SET UP LENGTH,,ARG BLOCK
	MOVEI	T2,ND.CNF		;FUNCTION TO RETURN DEVICE INFO
	PUSHJ	P,NODNDB		;GET IT FROM THE NDB
	MOVSI	T1,.NBOBJ+1(JP)		;CLEAR
	HRRI	T1,.NBOBJ+2(JP)		; OUT NCL
	SETZM	.NBOBJ+1(JP)		;  DEVICE
	BLT	T1,.NBOBJ+LN$OBJ(JP)	;   STORAGE
	MOVEI	T1,0			;INIT ARG BLOCK INDEX
OBJ.1:	SKIPN	T2,NODBLK##+3(T1)	;GET WORD FROM BLOCK
	 JRST	OBJ.E			;END OF ARGUMENTS RETURNED
	HLRZ	T3,T2			;GET NCL TYPE FOR THIS DEVICE
	ADDI	T3,.NBOBJ+1(JP)		;INDEX INTO DEVICE STORAGE
	MOVEM	T2,(T3)			;SAVE NCL-TYPE,,DEVICE COUNT
	AOJA	T1,OBJ.1		;POINT TO NEXT WORD IN ARG BLOCK
OBJ.E:	MOVEI	T1,.NBOBJ+1(JP)		;POINT TO START OF NCL DEVICE BLOCK
	END$

NB$(TYP)	;NODE TYPE
	PUSHJ	P,NB$MCR
	JUMPE	T1,TYP.1
	MOVSI	T1,'MCR'
	JRST	TYP.E
TYP.1:	PUSHJ	P,NB$CNF
	LDB	T2,[POINT 14,(T1),13]
	CAIE	T2,"DN"
	 JRST	[MOVE	T1,[SIXBIT/OTHER/]
		 JRST	TYP.E]
	MOVEI	T4,(T1)
	HRLI	T4,(POINT 7,)
	MOVEI	T1,0
	MOVE	T2,[POINT 6,T1]
TYP.2:	ILDB	T3,T4
	JUMPE	T3,TYP.E
	CAIN	T3," "
	 JRST	TYP.E
	SUBI	T3," "-' '
	TLNE	T2,770000
	 IDPB	T3,T2
	JRST	TYP.2
TYP.E:	END$


NB$(TOP,20)	;TOPOLOGY/COST
	MOVE	T1,[20,,.NBTOP+1]
	MOVEI	T2,ND.TOP
	PUSHJ	P,NODNDB
	MOVSI	T1,NODBLK##+3
	HRRI	T1,.NBTOP+1(JP)
	BLT	T1,.NBTOP+20(JP)
	MOVEI	T1,.NBTOP+1(JP)
	END$
;T1/ LEN,,ADDR
;T2/ FNC

NODNDB:	PUSHJ	P,.SAVE1##
	MOVE	P1,T1
	MOVEM	T2,NODBLK##+2		;STORE FUNCTION
	MOVEM	O,NODBLK##+1		;STORE NODE
	MOVEI	T2,24			;LENGTH
	MOVEM	T2,NODBLK##+0		;STORE HEADER
	MOVE	T1,[.NDNDB,,NODBLK##]
	PUSHJ	P,UNODE##		;SIMULATE THE UUO
	 $FATAL	(UNE,<Unexpected NODE. UUO failure>)
	MOVE	T1,P1
	ADD	T1,JP			;PLUS START
	HLRZ	T2,T1			;GET LENGTH
	ADDI	T2,(T1)			;FORM END
	HRLI	T1,NODBLK##+3		;GET END
	BLT	T1,-1(T2)		;COPY
	POPJ	P,			;AND RETURN
NODDCN:	MOVX	T1,DN.FLS		;ASSUME LISTING ALL NODES
	SKPNO	S.KNOWN##		;ALL THE ONES WE KNOW ABOUT?
	MOVX	T1,DN.FLK		;YES
	SKPNO	S.REACHABLE##		;ONLY WANT THOSE REALLY ON-LINE?
	MOVX	T1,DN.FLR		;YES
	TXO	T1,DN.FLS		;STEP THROUGH THE LIST
	POPJ	P,			;RETURN
	SUBTTL	DATA STORAGE

	$LOW

NODCOR::BLOCK	1
MAXNOD:	BLOCK	1
SRTTAB:	BLOCK	1
SRTPTR:	BLOCK	1
SRTCNT:	BLOCK	1

	END
