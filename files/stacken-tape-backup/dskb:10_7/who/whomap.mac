TITLE	WHOMAP -- Interface to MAP, the DECsystem-10 page mapper

	SEARCH	WHOMAC

	$SETUP	(WHOMAP)
	SUBTTL	MAP interface -- Initialize the page mapper

MAPDEF::MOVE	T1,[MP.JRM##+.MPMON##]	;MONITOR MAPPING
	PUSHJ	P,MAPINI		;INIT MAPPER
	PUSHJ	P,SPYINI##		;AND INITIALIZE SPY ROUTINES
	TLZ	F,(FL.CRASH)		;NOT CRASH FILE READING
	MOVE	T1,[%CNDAE]		;SPECIAL GETTAB TO CHECK VERSION
	PUSHJ	P,.MAPG##		;DO IT
	  MOVEI	T1,0			;PREHISTORIC MONITOR
	MOVEM	T1,MAPMVR		;SAVE
	POPJ	P,			;AND RETURN

MAPMON::SKIPE	ONCFLG##		;ONCE-ONLY INITIALIZATION?
	TLNE	F,(FL.LOGIN)		;NO--ARE WE LOGGED IN?
	SKIPA	T1,[MP.JRM##+.MPMON##]	;OK TO USE MONITOR MAPPING
	$FATAL	(LPM,<Login please to use switch MONITOR>)
	PUSHJ	P,MAPINI		;INIT MAPPER
	TLZ	F,(FL.CRASH)		;NOT CRASH FILE READING
	JRST	MAPCOM			;ENTER COMMON CODE

MAPCRS::SKIPE	ONCFLG##		;ONCE-ONLY INITIALIZATION?
	TLNE	F,(FL.LOGIN)		;NO--ARE WE LOGGED IN?
	SKIPA	T1,[MP.EXE##+.MPFIL##]	;OK TO USE CRASH FILE MAPPING
	$FATAL	(LPC,<Login please to use switch CRASH>)
	PUSHJ	P,MAPINI		;INIT MAPPER
	TLO	F,(FL.CRASH)		;FLAG CRASH FILE READING

MAPCOM:	SKIPN	ONCFLG##		;ONCE-ONLY INITIALIZATION?
	POPJ	P,			;YES--DONE
	PUSHJ	P,SPYINI##		;AND INITIALIZE SPY ROUTINES
	$INFO	(SMN,<Status of >,E.SMN);TYPE MONITOR STATUS
	TLNE	F,(FL.CRASH)		;IS THIS A CRASH?
	$INFO	(RCF,<Report from crash file >,E.RCF);TYPE CRASH FILE NAME
	PJRST	.TCRLF##		;CRLF AND RETURN 

MAPINI:	SKIPE	MAPRTM			;WANT TO INCLUDE MAPPER RUNTIME?
	IOR	T1,[MP.RTM##]		;YES
	MOVEM	T1,MAPARG##+.MPFNC##	;SAVE THEM
	SKIPN	ONCFLG##		;ONCE-ONLY INITIALIZATION?
	JRST	MAPI.1			;YES
	SKIPG	T1,S.CACHE##		;GET PAGES TO CACHE
	 MOVEI	T1,^D50			;ASSUME 50
	PUSHJ	P,MAPPGS		;NO--RESERVE PAGES FOR THE MAPPER
	JRST	MAPI.2			;ONWARD

MAPI.1:	SETZB	T1,T2			;USE MAPPER DEFAULTS

MAPI.2:	MOVEM	T1,MAPARG##+.MPNPC##	;SAVE NUMBER OF PAGES
	MOVEM	T2,MAPARG##+.MPSPN##	;SAVE STARTING PAGE NUMBER
	SETZM	MAPARG##+.MPDSN##	;DEFAULT SECTION NUMBER IS ZERO
	MOVEI	T1,CRSFIL##		;GET ADDRESS OF FILESPEC BLOCK
	MOVEM	T1,MAPARG##+.MPARG##	;SAVE IT
	MOVEI	T1,MAPARG##		;POINT TO BLOCK
	PUSHJ	P,.MAPI##		;FIREUP THE PAGE MAPPER
	  JRST	MAPI.3			;MAPPING ERROR--LOSE
	MOVEM	T1,MAPPTR		;SAVE ADDRESS OF DATA BLOCK
	SKIPN	.MPSPY##(T1)		;ARE WE SPYING?
	 TLZA	F,(FL.SPY)		;NO--MAKE SURE THE BIT IS OFF
	  TLO	F,(FL.SPY)		;FLAG SPYING (SPY PAGES)
	POPJ	P,			;AND RETURN

MAPI.3:	SKIPN	ONCFLG##		;ONCE-ONLY INITIALIZATION?
	JRST	MAPSTP			;YES--STOPCODE
	JRST	MAPFAT			;ELSE CALL IT A FATAL ERROR
E.SMN:	PUSHJ	P,XB$DVN##		;GET DEC VERSION NUMBER
	LOAD	T1,T1,VR.VER		;GET MAJOR VERSION NUMBER
	PUSHJ	P,.TOCTW##		;TYPE IT
	MOVEI	T1,[ASCIZ | monitor |]	;ASSUME THE RUNNING MONITOR
	TLNE	F,(FL.CRASH)		;CRASH FILE READING?
	MOVEI	T1,[ASCIZ | crash |]	;YES
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	PUSHJ	P,XB$NAM##		;GET MONITOR NAME
	PUSHJ	P,.TSTRG##		;TYPE IT
	$TYPE	< on >
	PUSHJ	P,XB$UDT##		;GET DATE/TIME
	PJRST	.TDTTM##		;TYPE UDT AND RETURN

E.RCF:	MOVE	T1,MAPPTR		;GET MAPPER DATA BLOCK ADDRESS
	MOVEI	T1,.MPAFS##(T1)		;POINT TO THE RETURNED ASCIZ FILESPEC
	PUSHJ	P,.TSTRG##		;TYPE IT
	PUSHJ	P,XB$SCN##		;GET STOPCODE NAME
	JUMPE	T1,.POPJ##		;SKIP IF NO STOPCODE
	PUSH	P,T1			;SAVE STOPCODE NAME
	$TYPE	<, stopcode >
	POP	P,T1			;GET STOPCODE NAME BACK
	PJRST	.TSIXN##		;TYPE IT AND RETURN
SUBTTL	MAP interface -- Allocate pages


; Here to acquire pages for use by the page mapper
; Call:	MOVE	T1, number of pages
;	PUSHJ	P,MAPPGS
;	<RETURN>			;T1 = #PAGES, T2 = STARTING PAGE
;
MAPPGS:	AOS	T2,MAPFLG		;BEEN HERE ALREADY?
	CAIN	T2,1			;FIRST TIME THROUGH?
	JRST	MAPP.1			;YES
	MOVE	T2,MAPPTR		;GET POINTER TO DATA BLOCK
	MOVE	T1,.MPPGS##(T2)		;PAGES AVAILABLE FOR MAPPING
	MOVE	T2,.MPCPN##(T2)		;STARTING PAGE NUMBER
	POPJ	P,			;RETURN

MAPP.1:	PUSHJ	P,.SAVE4##		;SAVE SOME ACS
	MOVE	P1,T1			;GET NUMBER OF PAGES TO ALLOCATE
	MOVE	P3,P1			;MAKE A COPY

MAPP.2:	PUSHJ	P,M$NXPG##		;RESERVE A PAGE
	  $STOP	(FAP,<Failed to reserve a page for SPYing>)
	JUMPN	P2,MAPP.3		;FIRST TIME THROUGH?
	MOVE	P4,T1			;YES--SAVE STARTING PAGE NUMBER
	MOVEI	P2,-1(T1)		;FAKE OUT PREVIOUS PAGE NUMBER

MAPP.3:	CAIE	P2,-1(T1)		;CONSECUTIVE PAGES?
	JRST	MAPP.4			;NO--ALL CAN'T CACHE ANYMORE
	MOVE	P2,T1			;SAVE NEW PREVIOUS PAGE NUMBER
	SOJG	P1,MAPP.2		;LOOP

MAPP.4:	MOVE	T1,P3			;GET REQUESTED NUMBER OF PAGES
	SUB	T1,P1			;GET NUMBER OF PAGES RESERVED
	MOVE	T2,P4			;GET STARTING PAGE NUMBER
	POPJ	P,			;AND RETURN
SUBTTL	MAP interface -- Error handling


; This routine will build an argument block for
; the verbosity controlled error processor.
;
;
MAPFAT::PUSH	P,[CAIA	4,]		;FATAL ERROR
	JRST	MAPERR			;ENTER COMMON CODE
MAPSTP::PUSH	P,[CAIA	5,]		;STOPCODE
MAPERR:	PUSH	P,T1			;SAVE T1
	PUSH	P,T2			;SAVE T2
	MOVE	T1,MAPPTR		;GET POINTER TO DATA BLOCK
	MOVE	T2,[PUSHJ P,.ERROR##]	;INST TO CALL THE ERROR HANDLER
	MOVEM	T2,MPEBLK+0		;SAVE IT
	MOVE	T2,-2(P)		;GET NO-OP AND SEVERITY CODE
	IOR	T2,.MPPFX##(T1)		;INCLUDE THE PREFIX
	MOVEM	T2,MPEBLK+1		;SAVE IT
	MOVE	T2,[-3,,MPEBLK+3]	;POINTER TO ERROR ARGS
	MOVEM	T2,MPEBLK+2		;SAVE IT
	MOVSI	T2,MAPER1		;CONTINUATION ADDRESS
	HRRI	T2,.MPMET##(T1)		;TEXT ADDRESS
	MOVEM	T2,MPEBLK+3		;SAVE IT
	POP	P,T2			;RESTORE T2
	POP	P,T1			;RESTORE T1
	POP	P,(P)			;TRIM STACK
	JRST	MPEBLK			;GENERATE AN ERROR AND RETURN

; Handle extended error text if there is some
;
MAPER1:	MOVE	T4,MAPPTR		;GET MAPPING DATA BLOCK ADDRESS
	SKIPN	.MPXET##(T4)		;HAVE EXTENDED ERROR TEXT?
	POPJ	P,			;NO
	PUSHJ	P,.TCRLF##		;TYPE A CRLF
	MOVEI	T1,.MPXET##(T4)		;GET EXTENDED ERROR TEXT
	PUSHJ	P,.TSTRG##		;TYPE IT
	POPJ	P,			;RETURN
	SUBTTL	Performance display


MAPPRF::SKPYES	S.MPERFORMANCE##	;WANT MAPPER PERFORMANCE DATA?
	POPJ	P,			;NO
	PUSHJ	P,.SAVE1##		;SAVE P1
	PUSHJ	P,.TCRLF##		;START WITH A CRLF
	MOVEI	T1,[ASCIZ |Incremental|]
	SKPYES	S.INCREMENTAL##		;INCREMENTAL MODE?
	MOVEI	T1,[ASCIZ |Accumulated|]
	PUSHJ	P,.TSTRG##		;TYPE INTRO
	$TYPE	< statistics for MAP %>
	MOVE	P1,MAPPTR		;GET MAP'S PERFORMANCE DATA BLOCK ADDR
	MOVE	T1,.MPVER##(P1)		;GET THE VERSION NUMBER
	PUSHJ	P,.TVERW##		;TYPE IT
	MOVEI	T1,[ASCIZ |; mapper runtime is |]
	SKIPE	.MPRTM##(P1)		;IS IT AVAILABLE?
	PUSHJ	P,.TSTRG##		;YES
	SKIPE	T1,.MPRTM##(P1)		;GET TOTAL RUNTIME IF AVAILABLE
	PUSHJ	P,HPTOUT		;TYPE HIGH PRECISION TIME
	PUSHJ	P,.TCRLF##		;END LINE

MPERF1:	$TYPE	<   Cache data: >
	MOVE	T1,.MPCPC##(P1)		;GET CACHE SIZE
	PUSHJ	P,.TDECW##		;TYPE IT
	$TYPE	< pages, >
	MOVE	T1,.MPHSF##(P1)		;GET NUMBER OF HASH TABLE SEARCHES
	PUSHJ	P,.TDECW##		;TYPE IT
	$TYPE	< searches, >
	MOVE	T1,.MPHSC##(P1)		;GET COLLISION COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	$TYPE	< collisions, >
	MOVE	T1,.MPEXM##(P1)		;GET COUNT OF EXAMINES
	SUB	T1,.MPPGC##(P1)		;MINUS THE PAGES WE HAD TO CREATE
	IMULI	T1,^D100		;MULTIPLY BY 100 SO WE CAN
	IDIV	T1,.MPEXM##(P1)		; COMPUTE HIT RATIO
	PUSHJ	P,.TDECW##		;TYPE RATIO
	$TYPE	<% hit ratio>
	PUSHJ	P,.TCRLF##		;END LINE

MPERF2:	$TYPE	<   Paging data: >
	MOVE	T1,.MPPGC##(P1)		;GET PAGE CREATE COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	$TYPE	< page creates, >
	MOVE	T1,.MPPGD##(P1)		;GET PAGE DESTROY COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	$TYPE	< destroys>
	PUSHJ	P,.TCRLF##		;END LINE

MPERF3:	$TYPE	<   Simulated/Actual UUOs: >
	$TYPE	< GETTAB: >
	MOVE	T1,.MPGTB##(P1)		;GET GETTAB SIMULATION COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	MOVEI	T1,"/"
	PUSHJ	P,.TCHAR##
	MOVE	T1,.MPGTU##(P1)		;GET GETTAB UUO COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	$TYPE	<   JOBPEK: >
	MOVE	T1,.MPJPK##(P1)		;GET JOBPEK SIMULATION COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	MOVEI	T1,"/"
	PUSHJ	P,.TCHAR##
	MOVE	T1,.MPJPU##(P1)		;GET JOBPEK UUO COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	$TYPE	<   PEEK: >
	MOVE	T1,.MPEXM##(P1)		;GET PEEK SIMULATION COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	PUSHJ	P,.TCRLF##		;END LINE

MPERF5:	SKPNO	S.INCREMENTAL##		;INCREMENTAL MODE?
	PUSHJ	P,.MAPC##		;YES--ZAP MAPPER COUNTERS
	  JFCL				;IGNORE ERRORS
	POPJ	P,			;RETURN
SUBTTL	Special typeout routines -- High precision time output


; Call:	MOVE	T1, time in 10-microsecond units
;	PUSHJ	P,HPTOUT
;
HPTOUT:	IDIVI	T1,^D100		;CONVERT TO MILLISECONDS
	IDIVI	T1,^D1000		;GET MILLISECONDS
	PUSH	P,T2			;SAVE IT
	IDIVI	T1,^D60			;GET SECONDS
	PUSH	P,T2			;SAVE IT
	IDIVI	T1,^D60			;GET HOURS
	PUSH	P,T2			;SAVE MINUTES
	JUMPN	T1,HPTO.1		;HAVE HOURS?
	JUMPN	T2,HPTO.2		;HAVE MINUTES?
	JRST	HPTO.3			;THEN TYPE SECONDS AND FRACTION

HPTO.1:	SETZ	T2,			;NO PADDING
	PUSHJ	P,.TDEC2##		;TYPE HOURS
	PUSHJ	P,.TCOLN##		;TYPE A COLON
	SKIPA	T2,["0"]		;PAD MINUTES WITH A ZERO

HPTO.2:	SETZ	T2,			;NO PADDING
	MOVE	T1,(P)			;GET MINUTES
	PUSHJ	P,.TDEC2##		;TYPE MINUTES
	PUSHJ	P,.TCOLN##		;TYPE A COLON
	SETZ	T4,			;WE DON'T WANT FRACTIONS TYPED
	SKIPA	T2,["0"]		;PAD SECONDS WITH A ZERO

HPTO.3:	SETZ	T2,			;NO PADDING
	MOVE	T1,-1(P)		;GET SECONDS
	PUSHJ	P,.TDEC2##		;TYPE SECONDS
	POP	P,(P)			;PRUNE
	POP	P,(P)			; STACK
	PUSHJ	P,.TDOT##		;TYPE A PERIOD
	POP	P,T1			;GET MILLISECONDS
	IDIVI	T1,^D10			;STRIP OFF LOW ORDER DIGIT
	CAIL	T2,5			;NEED TO ROUND UP?
	ADDI	T1,1			;YES
	MOVEI	T2,"0"			;PAD WITH A ZERO
	PJRST	.TDEC2##		;TYPE FRACTION AND RETURN
	SUBTTL	Data storage

MAPRTM::EXP	0			;MAPPER RUNTIM FLAG SET BY WHOONC

	$LOW

MAPFLG:	BLOCK	1			;INITIALIZED FLAG
MPEBLK:	BLOCK	6			;MAPPING ERROR BLOCK
MAPPTR::BLOCK	1			;POINTER TO DATA IN THE MAPPER
MAPMVR::BLOCK	1			;MONITOR VERSION


	END
