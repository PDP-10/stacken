	TITLE	WHOSCN - SCAN interface for WHO

	SEARCH	WHOMAC

	$SETUP	(WHOSCN)
	IFN FTTUFTS,<SEARCH TCSSYM>

Comment |

This module contains most of the routines needed to interface with
SCAN, such as switch tables, switch processing routines, and file
specification allocation routines.

|
;               TABLE OF CONTENTS FOR WHOSCN
;
;
;                        SECTION                                   PAGE
;    1. SCAN switches
;         1.1   Definition of switches............................   3
;         1.2   Keyword values....................................   4
;         1.3   Expansion of switches.............................   5
;    2. SCAN switch expansions
;         2.1   'ABR mode.........................................   5
;    3. SCAN switches
;         3.1   Global switch storage and defaults................   6
;         3.2   File specific switch storage and defaults..........   7
;    4. SCAN Blocks...............................................   8
;    5. Switch scanning routines
;         5.1   $MONITOR - Reset /CRASH...........................   9
;         5.2   $CRASH - Read a crash filespec....................  10
;         5.3   $NAMEW - Read a wildcarded SIXBIT word............  12
;         5.4   $PPN - Read a wildcarded PPN......................  12
;         5.5   $CORE - Read a core specification.................  12
;         5.6   $NODE - Read a wildcarded node name...............  13
;         5.7   $PHONE - Read a phone number string...............  14
;         5.8   $SORT - Read a sort specification.................  15
;         5.9   $SUMMARY - Read a summary keyword.................  15
;         5.10  $REP - Read a repeat time and count...............  16
;         5.11  $TTY, $PTY, $DET - Read terminal specifications...  17
;         5.12  $DISK - Read disk priority........................  18
;         5.13  $FORCE - Read a forced command....................  19
;         5.14  $MODE - Read /MODE specifier......................  20
;         5.15  .DECPW - Read positive decimal number.............  21
;    6. Defaulting
;         6.1   Scan specifications...............................  23
;         6.2   Switch defaults...................................  24
;         6.3   Format switch.....................................  25
;         6.4   Output specification defaults.....................  26
;    7. SCAN support
;         7.1   CLRANS - Clear answers and reset things...........  27
;         7.2   AOUT - Allocate an output spec....................  28
;         7.3   AIN - Allocate an input spec......................  29
;    8. Tables
;         8.1   Format defaults...................................  30
;         8.2   Monitor command interface.........................  31
;         8.3   SUMMARY and SORT keywords.........................  31
;         8.4   STATE keywords....................................  32
;    9. Other routines
;         9.1   SETSPC - Set start and end of concatinated set....  33
;         9.2   FIXTTY - Convert TTY/PTY/CTY to standard format...  34
;         9.3   FIXNNN - Form octal terminal number...............  34
;         9.4   TTYNNN - Form SIXBIT terminal number..............  34
;         9.5   CHKJOB - Range check job number...................  34
;         9.6   FIXNOD - Fix up node specification................  35
;         9.7   MSKUC/MSKLC - Convert ASCII strings to masks......  36
;   10. Storage...................................................  37
	SUBTTL	SCAN switches -- Definition of switches

	DEFINE	SWTCHS,<
IFN FTTUFTS,<
SWT(JOB)	SS	ACADEMIC,S.CLASS,CL$ACAD,
>
SWT(JOB)	SP	ACCOUNT,<POINT ^D65-10,S.ACCOUNT>,.ASCQW##,,FS.VRQ
SWT(JOB)	SN	ACTIVE,S.ACTIVE,
IFN FTTUFTS,<
SWT(JOB)	SS	ADMINISTRATION,S.CLASS,CL$ADM,
>
SWT(ALL)	SN	APPEND,S.APPEND,FS.NFS
SWT(<JOB,LIN>)	SS	AUTODIALER,S.APC,.TOADL
SWT(LIN)	SN	ASSIGN,S.ASSIGN
IFN FTIPC,<
SWT(JOB)	SP	BADGE,S.BADGE,.SWDEC##,,FS.VRQ
>;END IFN FTIPC
SWT(JOB)	SN	BATCH,S.BATCH,
SWT(JOB)	SN	BBATCH,S.BBATCH,
SWT(ALL)	SS	BLANK,S.DFORMAT,FORBLANK
SWT(JOB)	SL	CAPABILITY,<-1,,SLCAP>,PR,,FS.VRQ!FS.OBV
SWT(LIN)	SN	CARRIER,S.CARRIER
SWT(ALL)	SP	CACHE,,$CACHE,,FS.VRQ!FS.NFS!FS.NCM
IFN FTIPC,<
SWT(JOB)	SP	CATEGORY,S.CATEGORY,.SWOCT##,CAT,FS.VRQ
>;END IFN FTIPC
SWT(NOD)	SN	CDP,S.CDP,
SWT(NOD)	SN	CDR,S.CDR,
SWT(JOB)	SP	CHARGE,<POINT ^D65-2,S.CHARGE>,$NAMEW,,FS.VRQ!FS.HEL
IFN FTIPC,<
SWT(JOB)	SP	CID,<POINT ^D65-2,S.CID>,$NAMEW,,FS.VRQ!FS.HEL
>;END IFN FTIPC
SWT(JOB)	SP	CLASS,S.CLASS,.SWDEC##,CLS,FS.VRQ
SWT(ALL)	SP	COLUMN,S.COLUMN,.SWDEC##,COL
SWT(JOB)	SP	CORE,<POINT ^D65-2,S.CORE>,$CORE,,FS.VRQ!FS.HEL
SWT(ALL)	SP	CRASH,S.CRASH,$CRASH,CRS,FS.NFS!FS.NCM
SWT(<JOB,LIN>)	SS	CTERM,S.APC,.TOCTM
SWT(JOB)	SP	CTLJOB,S.CTLJOB,.SWDEC##,CTL,
SWT(JOB)	SP	CTLPRG,<POINT ^D65-2,S.CTLPRG>,$NAMEW,,FS.VRQ!FS.HEL
SWT(<JOB,LIN>)	SS	CTY,S.TTY,'CTY'
SWT(JOB)	SP	DDB,S.DDB,.SWFIL##,DDB,FS.VRQ
SWT(JOB)	SL	*DDBS,S.DDBS,%,PD.DDB,
SWT(NOD)	SN	DDP,S.DDP
SWT(JOB)	SN	DDT,S.DDT,
SWT(ALL)	SS	DEFAULT,S.DFORMAT,FORDEFAULT,FS.NFS
SWT(JOB)	SP	DETACH,S.TTY,$DET,DET,FS.LRG!FS.HEL
SWT(JOB)	SP	DEVICE,S.DEVICE,.SWSIX##,,FS.VRQ
SWT(<JOB,LIN>)	SS	DIALUP,S.APC,.TODSD
SWT(ALL)	SP	DPY,<POINT ^D65-2,S.DPY>,$REP,REP,FS.NFS!FS.HEL
SWT(JOB)	SP	DSKPRI,S.DSKP,$DISK,DPR,FS.HEL
SWT(NOD)	SN	DTA,S.DTA
SWT(ALL)	SS	*FAST,S.FORMAT,%FAST,
SWT(JOB)	SP	FILE,S.DDB,.SWFIL##,DDB,FS.VRQ
SWT(JOB)	SL	FILES,S.DDBS,%,PD.DDB,
SWT(ALL)	SP	FINAL,S.FINAL,FINSWT##,,FS.NFS!FS.VRQ
SWT(ALL)	SS	FIX,S.DFORMAT,FORFIX,FS.NFS
SWT(ALL)	SS	FLOAT,S.DFORMAT,FORFLOAT,FS.NFS
SWT(ALL)	SP	FORMAT,S.FORMAT,FORSWT##,,FS.VRQ
SWT(ALL)	SP	FOOTING,S.FOOT,FOOSWT##,,FS.VRQ
SWT(<JOB,LIN>)	SP	FORCE,S.FORCE,$FORCE,,FS.NFS!FS.VRQ!FS.HEL
SWT(<JOB,LIN>)	SS	GANDALF,S.APC,.TOGAN
SWT(JOB)	SL	GLXOPR,S.GLXOPR,GOP,PD.GOP,
SWT(LIN)	SN	HANGUP,S.HANGUP
SWT(<JOB,LIN>)	SS	HARDWIRED,S.APC,.TOHWD
SWT(ALL)	SP	HEADING,S.HEAD,HEASWT##,,FS.VRQ
SWT(NOD)	SN	HOST,S.MCR,		;;Same as /MCR
SWT(JOB)	SP	HPQ,S.HPQ,.SWDEC##,HPQ,
SWT(ALL)	SN	I,S.INCREMENTAL,FS.NFS
SWT(ALL)	SL	*INCLUDE,S.INCLUDE,INC,,FS.NFS!FS.OBV
SWT(ALL)	SN	INCREMENTAL,S.INCREMENTAL,FS.NFS
SWT(ALL)	SL	INFORMATION,<-1,,SLIFM>,IFM,,FS.VRQ!FS.OBV
SWT(LIN)	SN	INITED,S.INTED		;;S.INIT IS FOR /INITIAL
SWT(ALL)	SP	INITIAL,S.INIT,INISWT##,,FS.NFS!FS.VRQ
SWT(<JOB,LIN>)	SP	INPUT,<POINT ^D65-LN$SND,S.INPUT>,.ASCQW##,,FS.NFS!FS.VRQ
SWT(<JOB,LIN>)	SP	JOB,S.JOB,.SWDEC##,JOB,
SWT(JOB)	SL	JSTATUS,S.JSTATUS,ST,,FS.VRQ!FS.OBV
SWT(NOD)	SN	KNOWN,S.KNOWN
SWT(<JOB,LIN>)	SS	LAT,S.APC,.TOLAT
SWT(<JOB,LIN>)	SN	LOCAL,S.LCAL
SWT(JOB)	SP	LOCATE,S.LOCATE,.SWOCT##,LOC,
SWT(LIN)	SP	LOCATE,<POINT ^D65-4,S.LOCATE>,.ASCQW##,,FS.VRQ
IFN FTLGNQ,<
SWT(LIN)	SN	LOGINQ,S.LOGINQ,
> ;END IFN FTLGNQ
SWT(JOB)	SP	LPPN,<POINT ^D65-2,S.LPPN>,$PPN,,FS.VRQ!FS.HEL
SWT(NOD)	SN	LPT,S.LPT
SWT(ALL)	SN	MAP,S.MAP,
SWT(NOD)	SN	MCR,S.MCR
SWT(LIN)	SN	MIC,S.MIC,
SWT(<JOB,LIN>)	SS	MICOM,S.APC,.TOMCM
SWT(ALL)	SP	MODE,,$MODE,,FS.VRQ!FS.NFS!FS.NCM
SWT(ALL)	SP	MONITOR,S.MONITOR,$MONITOR,,FS.NFS!FS.NCM
SWT(JOB)	SP	MOUNT,S.MOUNT,.SWSIX##,,FS.VRQ
SWT(ALL)	SN	MPERFORMANCE,S.MPERFORMANCE,FS.NFS
SWT(NOD)	SN	MTA,S.MTA
SWT(JOB)	SP	NAME,<POINT ^D65-2,S.NAME>,.SIXQW##,,FS.VRQ
SWT(LIN)	SL	NETWORK,S.NETWORK,NET,,FS.NFS!FS.VRQ
SWT(<JOB,LIN>)	SS	NOAUTODIALER,S.APC,<-.TOADL&777777>
SWT(<JOB,LIN>)	SS	NOCTY,S.TTY,'CTY'+1000000,FS.LRG
SWT(<JOB>)	SS	NODDBS,S.DDBS,0,
SWT(<JOB>)	SP	NODE,<POINT ^D65-3,S.NODE>,$NODE,,FS.VRQ!FS.HEL
SWT(<LIN>)	SP	*NODE,<POINT ^D65-3,S.NODE>,$NODE,,FS.VRQ!FS.HEL
SWT(<NOD>)	SP	NODE,<POINT ^D65-2,S.NODE>,$NAMEW,,FS.VRQ!FS.HEL
SWT(<JOB,LIN>)	SS	NODETACH,S.TTY,'DET'+1000000,FS.LRG
SWT(<JOB,LIN>)	SS	NODIALUP,S.APC,<-.TODSD&777777>
SS(<JOB>)	SS	NOFILES,S.DDBS,0
SWT(<JOB,LIN>)	SS	NOGANDALF,S.APC,<-.TOGAN&777777>
SWT(<JOB,LIN>)	SS	NOHARDWIRED,S.APC,<-.TOHWD&777777>
SWT(<JOB,LIN>)	SS	NOMICOM,S.APC,<-.TOMCM&777777>
SWT(<JOB,LIN>)	SS	NONRTSER,S.APC,<-.TONRT&777777>
SWT(JOB)	SS	*NOOPERATOR,S.OPER,OPRNO
SWT(<JOB,LIN>)	SS	NOPTY,S.TTY,'PTY'+1000000,FS.LRG
SWT(ALL)	SS	NORMAL,S.FORMAT,%NORMAL,
SWT(<JOB,LIN>)	SS	NOTSN,S.APC,<-.TOTSN&777777>
SWT(<JOB,LIN>)	SS	NOTTY,S.TTY,'TTY'+1000000,FS.LRG
SWT(<JOB,LIN>)	SS	NRTSER,S.APC,.TONRT
SWT(JOB)	SL	OPERATOR,S.OPER,OPR,OPRYES
SWT(<JOB,LIN>)	SP	OUTPUT,<POINT ^D65-LN$SND,S.OUTPUT>,.ASCQW##,,FS.NFS!FS.VRQ
SWT(JOB)	SN	ORIGIN,S.ORIGIN,
SWT(<JOB,LIN,UNI>) SN	PERFORMANCE,S.PERF,FS.NFS
SWT(JOB)	SN	PFH,S.PFH
SWT(LIN)	SP	PHONE,<POINT ^D65-4,S.LOCATE>,$PHONE,,FS.VRQ!FS.HEL
SWT(JOB)	SN	PIVOTED,S.PIVOT,FS.NFS
SWT(NOD)	SN	PLT,S.PLT,
IFN FTPOWER,<
SWT(LIN)	SN	POWER,S.POWER
>
SWT(JOB)	SP	PPN,<POINT ^D65-2,S.PPN>,$PPN,,FS.VRQ!FS.HEL
SWT(ALL)	SN	PRINT,S.PRINT,FS.NFS
SWT(JOB)	SL	PRIVILEGE,<-1,,SLPRV>,PR,,FS.VRQ!FS.OBV
SWT(JOB)	SP	PRGRUN,<POINT ^D65-2,S.PRGRUN>,$NAMEW,,FS.VRQ!FS.HEL
SWT(JOB)	SP	*PROGRAM,<POINT ^D65-2,S.PROG>,$NAMEW,,FS.VRQ!FS.HEL
SWT(NOD)	SN	PTP,S.PTP,
SWT(NOD)	SN	PTR,S.PTR,
SWT(<JOB,LIN>)	SP	PTY,S.TTY,$PTY,PTY,FS.LRG
SWT(JOB)	SP	RBEFORE,S.RBEFORE,.DATIP##,,FS.VRQ
SWT(LIN)	SL	RCVSPEED,S.RCVSPEED,SPD,,FS.VRQ
SWT(NOD)	SN	RDA,S.RDA,
SWT(NOD)	SN	REACHABLE,S.REACHABLE
SWT(<JOB,LIN>)	SN	REMOTE,S.REMOTE,
SWT(ALL)	SP	REPEAT,<POINT ^D65-2,S.REPEAT>,$REP,REP,FS.NFS!FS.HEL
SWT(JOB)	SP	RSINCE,S.RSINCE,.DATIP##,,FS.VRQ
SWT(JOB)	SP	SEGMENT,<POINT ^D65-2,S.SEGM>,$NAMEW,,FS.VRQ!FS.HEL
SWT(JOB)	SN	SELF,S.SELF,
SWT(<JOB,LIN>)	SP	SEND,<POINT ^D65-LN$SND,S.SEND>,.ASCQW##,,FS.NFS!FS.VRQ
IFN FTSERV,<
SWT(ALL)	SP	SERVER,<POINT ^D65-.SVMAX,S.SERV>,$SERVER,,FS.NFS!FS.VRQ!FS.HEL
> ;END IFN FTSERV
IFN FTMDC,<
SWT(JOB)	SN	SETP,S.SETP,
>;END IFN FTMDC
SWT(<JOB,LIN>)	SP	SETUUO,,$SETUUO,,FS.NFS!FS.VRQ!FS.HEL
SWT(LIN)	SN	SLAVE,S.SLAVE,
IFN FTIPC,<
SWT(JOB)	SP	SLOT,S.SLOT,.SWOCT##,SLT,FS.VRQ
>;END IFN FTIPC
SWT(ALL)	SS	*SLOW,S.FORMAT,%SLOW,
SWT(ALL)	SP	SORT,<POINT ^D65-3,S.SORT>,$SORT,,FS.NFS!FS.VRQ!FS.HEL
SWT(LIN)	SL	SPEED,S.SPEED,SPD,,FS.VRQ
SWT(ALL)	SN	STAMP,S.STAMP,FS.NFS
SWT(JOB)	SL	STATE,S.STATE,STAT,,FS.VRQ!FS.OBV
SWT(JOB)	SP	STREAM,S.STREAM,.SWDEC##,,FS.VRQ
SWT(ALL)	SP	SUMMARY,S.SUMMARY,$SUMMARY,SUM,FS.NFS!FS.HEL
SWT(STR)	SP	STRUCTURE,<POINT ^D65-2,S.STRU>,$NAMEW,,FS.VRQ!FS.HEL
SWT(JOB)	SL	SWAP,S.SWAP,SWAP,,FS.NFS!FS.VRQ
IFN FTTUFTS,<
SWT(JOB)	SS	SYSTEM,S.CLASS,CL$SYS,
>
SWT(ALL)	SN	TITLES,S.TITLES,FS.NFS
SWT(ALL)	SN	TOTALS,S.TOTALS,FS.NFS
SWT(NOD)	SN	TSK,S.TSK,
SWT(<JOB,LIN>)	SS	TSN,S.APC,.TOTSN
SWT(<JOB,LIN>)	SP	TTY,S.TTY,$TTY,TTY,FS.LRG!FS.HEL
SWT(NOD)	SN	TTY,S.TTY,
SWT(<LIN,NOD>)	SP	TYPE,<POINT ^D65-2,S.TYPE>,$NAMEW,,FS.VRQ!FS.HEL
SWT(UNI)	SP	UNIT,<POINT ^D65-2,S.UNIT>,$NAMEW,,FS.VRQ!FS.HEL
SWT(LIN)	SN	USER,S.USER
SWT(JOB)	SP	VCORE,<POINT ^D65-2,S.VCORE>,$CORE,,FS.VRQ!FS.HEL
SWT(ALL)	SS	*VFAST,S.FORMAT,%VFAST,
SWT(JOB)	SN	VM,S.VM
SWT(JOB)	SN	WHEELED,S.WHEEL,FS.NFS
SWT(JOB)	SP	WSCODE,<POINT ^D65-2,S.WSCODE>,.SIXQW##,,FS.VRQ
SWT(JOB)	SL	WTO,S.WTO,WTO,PD.WTO,
SWT(LIN)	SL	XMTSPEED,S.XMTSPEED,SPD,,FS.VRQ
>
	SUBTTL	SCAN switches -- Keyword values

	KEYS	(DDB,<FAST,NORMAL,SLOW,VFAST>)
	GKEYS	(FOR,<FIX,FLOAT,BLANK,DEFAULT>)
	KEYS	(GOP,<NONE,SYSTEM,HOST,REMOTE>)
	GOKEYS	(IFM,<ACCOUNT,TMPCOR,CHANNEL,PATH,ORIGIN,DDBS,SPOOL,IPCF,JSL,LOGICAL,TTY,SIZE,BATCH,PRIVILEGES,MTA,DEFAULTS,CAPABILITIES,TIME,CORE,WSCODE,STATE,WATCH,NAME>)
	GOKEYS	(INC,<FUNNY,PTY>)
	GKEYS	(NET,<DISCONNECT,CONNECT>)
	KEYS	(OPR,<NO,YES,LOCAL,REMOTE>)
	KEYS	(SRV,<IPCF,ANF10,DECNET>)
IFN FTIPC,<
    IFE FTMDC,<
	GOKEYS	(PR,<IPCF,DISK,METER,POKE,CPU,HPQ,UNSPOOL,ENQ,RTTRP,LOCK,TRPSET,SPYALL,SPYMON,NETEXAM,CHGPPN>)
    >
>
IFN FTMDC,<
	GOKEYS	(PR,<IPCF,DISK,METER,POKE,CPU,HPQ,UNSPOOL,ENQ,RTTRP,LOCK,TRPSET,SPYALL,SPYMON,NETEXAM,CHGPPN,SETP,PRGRUN>)
>
IFN FTTUFTS,<
	GOKEYS	(PR,<IPCF,DISK,METER,POKE,CPU,HPQ,UNSPOOL,ENQ,RTTRP,LOCK,TRPSET,SPYALL,SPYMON,NAME,PPASS,SPASS,MAIL,SFD,COMBO,MAGTAPE>)
>
IFE FTIPC!FTTUFTS!FTMDC,<
	GOKEYS	(PR,<IPCF,DISK,METER,POKE,CPU,HPQ,UNSPOOL,ENQ,RTTRP,LOCK,TRPSET,SPYALL,SPYMON>)
>
	KEYS	(SPD,<50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,EXTA,EXTB>)
	GKEYS	(ST,<RUN,CMDWAIT,MONERR,LOCK,SWAP,JACCT,DCORE,OPRWAIT,XONLY,DSKFUL>)
	OKEYS	(STA,<ACTIVE,SWAP,LOCK,STOP,RUN,EVENTWAIT,IOWAIT,SLEEP>)
	GKEYS	(SWAP,<FORCE,FIT,IN,OUT>)
	KEYS	(WTO,<ALL,WTO,NONE>)
	PD.GOP==:777
	PD.WTO==:777
	PD.DDB==:777

	DM	COL,^D132,0,2
	DM	CRS,.FXLEN,.FXLEN,.FXLEN
	DM	DDB,.FXDIM+1,.FXDIM+1,.FXDIM+1
	DM	JOB,777,1,1
	DM	REP,^D3600,0,^D10
	DM	SUM,77777,0,77777
	DM	DPY,^D3600,0,^D10
	DM	TTY,.INFIN,0,'TTY'
	DM	DET,.INFIN,0,'DET'
	DM	PTY,.INFIN,0,'PTY'
	DM	HPQ,17,0,777777
	DM	DPR,3,0,777777
	DM	LOC,177,0,777
	INTERN	PD.HPQ,PD.DPR,PD.LOC,PD.SUM
	DM	CLS,^D32,0,0
IFN FTIPC,<
	DM	CAT,777,0,0
	DM	SLT,777,0,0
>;END IFN FTIPC
	DM	CTL,^D512,0,0
	DM	SRV,0,SRVANF10,0
	SUBTTL	SCAN switches -- Expansion of switches

;The following set of macros will define a separate switch table of the
;form Sxxx. where xxx is the three letter mode abbreviation defined for
;each mode in the MODES macro in WHOMAC.MAC. The SWTCHS macro is the
;master list of all the switches, in a format suitable for SCANs
;DOSCAN macro. However, only the switches specified for each mode will
;be assembled in each independent switch table. This is done by 
;defining the SWTS macro to be either <null> to include this switch in
;this expansion of the table, or <;> to not include this switch.
;If an argument in the SWTS macro matchs the current mode we are
;building switch tables for, that switch is included.

DEFINE XX(MOD,ABR,MAP,TXT,ERR),<
	DEFINE SWT(ARG),<
		..FLAG==0
		IRP	ARG,<
			IFIDN <ARG><ABR>,<..FLAG==1>
			IFIDN <ARG><ALL>,<..FLAG==1>
		>;END IRP
		IFE ..FLAG,<;>>;END DEFINE SWT
	PAGE
	SUBTTL	SCAN switch expansions -- 'ABR mode
	DOSCAN	(S'ABR'.)
>;END DEFINE XX

	MODES
	SUBTTL	SCAN switches -- Global switch storage and defaults

	DEFINE	GSWTCH,<
;;
;;	Switch name	Number 	Default	Initial
;;			of 	value	value
;;			words
;;
GS	APPEND		,	,NO	,
GS	CRASH		,MX.CRS	,	,0
GS	COLUMN		,	,1	,
GS	DFORMAT		,	,FORDEFAULT,
GS	DPY		,2	,	,
GS	FINAL		,	,	,0
GS	FORCE		,	,	,
GS	INCLUDE		,	,	,0
GS	INCREMENTAL	,	,NO	,
GS	INITIAL		,	,	,0
GS	INPUT		,LN$SND	,	,0
GS	KNOWN		,	,NO	,
GS	MONITOR		,	,	,
GS	MPERFORMANCE	,	,NO	,
GS	NETWORK		,	,	,
GS	OUTPUT		,LN$SND	,	,0
GS	PRINT		,	,YES	,
GS	REACHABLE	,	,YES	,
GS	REPEAT		,2	,	,
GS	SEND		,LN$SND	,	,0
IFN FTSERV,<
GS	SERVER		,.SVMAX	,	,
> ;END IFN FTSERV
GS	SORT		,3	,	,
GS	STAMP		,	,NO	,
GS	SUMMARY		,	,	,
GS	TITLES		,	,YES	,
GS	TOTALS		,	,NO	,
>

	DOGSWT
	SUBTTL	SCAN switches -- File specific switch storage and defaults

	DEFINE	FSWTCH,<
IFN FTLGNQ,<
FS	LOGINQ	,LQP		,	,
> ;END IFN FTLGNQ
FS	STREAM	,BSN		,	,
FS	DDT	,DDT		,	,
FS	PFH	,PFH		,	,
FS	PERFORMANCE,PRF		,NO	,
FS	MAP	,MAP		,NO	,
FS	FORMAT	,FMT		,%NORMAL,
FS	$$$$$$	,PFM		,	,
FS	INFORM	,<INM,INF>	,	,0
FS	GLXOPR	,GOP		,	,
FS	WTO	,WTO		,	,
FS	SLAVE	,SLV		,	,
FS	MIC	,MCL		,	,
FS	VM	,VM		,	,
FS	LCAL	,LCL		,	,
FS	CORE	,<CRL,CRH>	,	,
FS	VCORE	,<VCL,VCH>	,	,
FS	ASSIGN	,TAC		,	,
FS	INTED	,TAP		,	,
FS	HANGUP	,HNG		,	,
FS	CARRIER	,DSC		,	,
IFN FTPOWER,<
FS	POWER	,POW		,	,
>
FS	TYPE	,<TYP,TYM>	,	,
FS	XMTSPEED,TSP		,	,
FS	RCVSPEED,RSP		,	,
FS	RSINCE	,RSN		,	,
FS	RBEFORE	,RBF		,	,
FS	PRGRUN	,<PTR,PTM>	,	,
FS	SPEED	,SPD		,	,
FS	NODE	,<NNM,NOM,NLN>	,	,
FS	TTY	,<TTY,TTM>	,	,
FS	%%%%%%	,<TTA>		,	,
FS	PROGRAM	,<PRG,PRM>	,	,
FS	SEGMENT	,<HSN,SEM>	,	,
FS	PPN	,<PPN,PPM>	,	,
FS	LPPN	,<LPN,LPM>	,	,
FS	JOB	,JOB		,	,
FS	HPQ	,HPQ		,	,
FS	ACTIVE	,ACT		,	,
FS	CLASS	,CLS		,	,
FS	DSKPRI	,DPR		,	,
FS	DEVICE	,DEV		,	,
FS	MOUNT	,MOU		,	,
FS	WSCODE	,<WSC,QQQ>	,	,
FS	STATE	,STA		,	,0
FS	CTLPRG	,<CPN,CPM>	,	,
FS	CTLJOB	,CJN		,	,
FS	BATCH	,BJB		,	,
FS	BBATCH	,BBB		,	,
FS	SELF	,SLF		,	,
FS	NAME	,<NAM,NA1,NMM,NM1>,	,
FS	USER	,TCJ		,	,
FS	DDB	,<DDB,DD1,DD2,DD3,DD4,DD5,DD6,DD7>,	,0
FS	OPERATOR,OPR		,	,
FS	LOCATE	,<LOC,LO1,LO2,LO3,LMC,LM1,LM2,LM3>,	,
FS	ACCOUNT	,<ACC,AC1,AC2,AC3,AC4,AC5,AC6,AC7,ATM,AM1,AM2,AM3,AM4,AM5,AM6,AM7>,	,
FS	APC	,APC		,	,
FS	ORIGIN	,ORI		,NO	,
FS	DDBS	,DBS		,	,
FS	REMOTE	,RMT		,	,
FS	PRIVILEGE,<PRV,PVM>	,	,0
FS	CAPABILITY,<CAP,CAM>	,	,0
FS	JSTATUS	,JST		,	,0
FS	SWAP	,SWP		,	,
FS	HEADING	,HEA		,	,0
FS	FOOTING	,FOO		,	,0
FS	CHARGE	,<CNO,CHM>	,	,
FS	PIVOT	,PVT		,	,
FS	WHEEL	,WHL		,	,
IFN FTIPC,<
FS	CATEGORY,CAT		,	,
FS	SLOT	,SLT		,	,
FS	CID	,<CID,CIM>	,	,
FS	BADGE	,BDG		,	,
>
IFN FTMDC,<
FS	SETP	,STP		,	,
>;END IFN FTMDC
FS	CDP	,CDP		,	,
FS	CDR	,CDR		,	,
FS	DDP	,DDP		,	,
FS	DTA	,DTA		,	,
FS	LPT	,LPT		,	,
FS	MCR	,MCR		,	,
FS	MTA	,MTA		,	,
FS	PLT	,PLT		,	,
FS	PTP	,PTP		,	,
FS	PTR	,PTR		,	,
FS	RDA	,RDA		,	,
FS	TSK	,TSK		,	,
FS	PASSWORD,<PSW,PSM>	,	,
FS	STRUCTURE,<STN,STM>	,	,
FS	UNIT	,<UNN,UNM>	,	,
>

	DOFSWT

.FZSNC==:.FXSNC
.FZBFR==:.FXBFR
	SUBTTL	SCAN Blocks

ISBLK::	IOWD	MON.L,MON.T		;POINT TO MONITOR COMMANDS
	XWD	OFFSET##,'WHO'		;STARTING OFFSET,,MY PREFIX
	XWD	CHRINP##,.TOCHR##	;TYPE-IN AND TYPE-OUT ROUTINES
	0				;..
	XWD	PROMPT,MONRET		;PROMPT AND EXIT ROUTINES
	FS.IFL!FS.INC!FS.STK		;NO CORE UUO,SUPPRESS STICKY DEFAULTING
					;INDIRECT ILLEGAL IF NOT LOGGEN
LN$IBLK==:.-ISBLK

	INTERN	MON.L,MON.T

DEFINE XX(MOD,ABR,MAP,TXT,ERR),<
	T'ABR:	IOWD	S'ABR'.L,S'ABR'.N
		XWD	S'ABR'.D,S'ABR'.M
		EXP	S'ABR'.P
		EXP	-1
		XWD	CLRANS,CLRFIL
		XWD	AIN,AOUT
	0;;	XWD	MEMSTK,APPSTK
		XWD	CLRSTK,FS.MIO

	LT'ABR==.-T'ABR
	O'ABR:	IOWD	S'ABR'.L,S'ABR'.N
		XWD	S'ABR'.D,S'ABR'.M
		EXP	S'ABR'.P
		EXP	-1
	IFIDN <ABR><JOB>,<
		XWD	2,[EXP SIXBIT/WHO/,SIXBIT/JOB/]
	>;END IFIDN
	IFDIF <ABR><JOB>,<
		EXP	SIXBIT/MOD/
	>;END IFDIF
	LO'ABR==.-O'ABR
>;END DEFINE XX

	MODES

DEFINE XX(MOD,ABR,MAP,TXT,ERR),<XWD LT'ABR,T'ABR>

TBLKX::	MODES

DEFINE XX(MOD,ABR,MAP,TXT,ERR),<XWD LO'ABR,O'ABR>

OBLKX::	MODES
	SUBTTL	Prompt and exit routines


PROMPT:	TLNE	F,(FL.WHOSRV)		;ARE WE A SERVER?
	POPJ	P,			;YES--NEVER PROMPT
	SKIPGE	T1			;SEE IF CONTINUATION
	MOVEI	T1,"#"			;YES--SET CODE
	OUTCHR	T1			;TYPE PROMPT
	POPJ	P,			;AND RETURN


MONRET:	TLNE	F,(FL.WHOSRV)		;ARE WE A SERVER?
	PJRST	SRVXIT##		;YES--SPECIAL HANDLING
	PUSHJ	P,.CCLRB##		;CONDITIONALLY CLEAR TYPE-AHEAD
	PUSHJ	P,.KLIND##		;CLEAR INDIRECT STUFF
	PJRST	.MNRET##		;LET SCAN FINISH UP
	SUBTTL	Switch scanning routines -- $MONITOR - Reset /CRASH


	[ASCIZ/Reset CRASH switch/]
$MONITOR:
	CAIN	C,":"			;A MODIFIER?
	 $FATAL (NMA,<No modifier allowed on switch MONITOR>)
	PUSHJ	P,MAPMON##		;SETUP FOR MONITOR MAPPING
	JRST	.SWDON##		;RETURN W/O STORE
	SUBTTL	Switch scanning routines -- $CRASH - Read a crash filespec


; This routine will read in a crash filespec and apply defaults if
; necessary. The default filespec is DSK:CRASH.EXE for compatibility
; with SYSTAT


	[ASCIZ/Monitor crash filespec/]
$CRASH:	PUSHJ	P,.SWFIL##		;GET A FILESPEC
	  JFCL				;CAN'T GET HERE (I DON'T THINK)
	MOVEI	T1,S.CRASH		;POINT TO SCAN BLOCK
	MOVE	T2,.FXMOD(T1)		;GET FLAGS
	DMOVE	T3,[EXP <'CRASH '>,-1]	;GET DEFAULT FILE NAME AND MASK
	SKIPN	.FXNAM(T1)		;HAVE ONE?
	 DMOVEM	T3,.FXNAM(T1)		;NOW WE DO
	HRLOI	T3,'EXE'		;GET DEFAULT EXTENSION AND MASK
	SKIPN	.FXEXT(T1)		;HAVE AN EXTENSION
	 MOVEM	T3,.FXEXT(T1)		;YES--SET DEFAULTS

	MOVEI	T2,CRSOPN		;OPEN BLOCK
	MOVEI	T3,CRSLOK		;LOOPUP BLOCK
	PUSHJ	P,.STOPN##		;CONVERT SCAN BLOCK
	 $FATAL	(NWC,<No wildcarding crash specification>)
	MOVE	T1,[POINT 7,CRSFIL]	;BYTE POINTER TO STORE TEXT
	MOVEM	T1,CRSPTR		;SAVE IT
	MOVEI	T1,CRSCHR		;GET OUR CHARACTER TYPER
	PUSHJ	P,.TYOCH##		;TELL SCAN
	PUSH	P,T1			;SAVE IT
	MOVEI	T1,CRSOPN		;OPEN BLOCK
	MOVEI	T2,CRSLOK		;LOOKUP BLOCK
	PUSHJ	P,.TOLEB##		;TYPE OPEN/LOOKUP BLOCK
	MOVEI	T1,0			;TERMINATE
	PUSHJ	P,CRSCHR		;..
	POP	P,T1			;GET OLD CHAR TYPER
	PUSHJ	P,.TYOCH##		;RESTORE IT
	PUSHJ	P,MAPCRS##		;SETUP FOR CRASH FILE MAPPING
	JRST	.SWDON##		;RETURN W/O STORE


CRSCHR:	IDPB	T1,CRSPTR		;STORE CHARACTER
	POPJ	P,			;AND RETURN
	SUBTTL	Switch scanning routines -- $NAMEW - Read a wildcarded SIXBIT word
	[ASCIZ/Wildcarded SIXBIT word/]
$NAMEW:	PUSHJ	P,.NAMEW##		;READ  WILD NAME
NAME.1:	PUSHJ	P,.LEFTX##		;POSITION
	JUMPE	N,E.SVR##		;CANT BE NULL
	MOVEM	N,.NMUL##		;STORE NAME
	MOVEM	T1,.NMUL##+1		;STORE MASK
	POPJ	P,			;AND RETURN


	SUBTTL	Switch scanning routines -- $PPN - Read a wildcarded PPN

	[ASCIZ/Wildcarded PPN word/]
$PPN:	PUSHJ	P,.TIAUC##		;GET A CHAR
	CAIE	C,"["			;MUST BE [
	  $FATAL (IPF,<Illegal PPN format>)
	PUSHJ	P,.SAVE2##		;SAVE P1,P2
	PUSHJ	P,.NOCTW##		;READ OCTAL NUMBER
	PUSHJ	P,.LEFTX##		;MOVE TO LEFT HALF
	TRNE	N,-1			;SEE IF TOO BIG
	  JRST	E$$IPF			;YES
	HLLZ	P1,N			;SAVE NUMBER
	HLLZ	P2,T1			;AND MASK
	CAIE	C,","			;SEE IF COMMA
	  JRST	E$$IPF			;NO
	JUMPN	P1,PPN.1		;SEE IF GIVEN
	HLLZ	P1,.MYPPN##		;NO--DEFAULT MY PROJECT
	HRLZI	P2,-1			;AND MASK
PPN.1:	PUSHJ	P,.NOCTW##		;READ OCTAL NUMBER
	PUSHJ	P,.LEFTX##		;MOVE TO LEFT HALF
	TRNE	N,-1			;SEE IF TOO BIG
	  JRST	E$$IPF			;YES
	JUMPN	N,PPN.2			;SEE IF PROGRAMMER
	HRLZ	N,.MYPPN##		;NO--DEFAULT MY PROGRAMMER
	HRLI	T1,-1			;AND MASK
PPN.2:	HLR	P1,N			;SAVE NUMBER
	HLR	P2,T1			;AND MASK
	CAIN	C,"]"			;TERMINATE OK?
	  PUSHJ	P,.TIAUC##		;YES--GET NEXT CHAR
	MOVEM	P1,.NMUL##		;SAVE NUMBER
	MOVEM	P2,.NMUL##+1		;AND MASK
	POPJ	P,

	SUBTTL	Switch scanning routines -- $CORE - Read a core specification

	[ASCIZ/Min:Max Core words/]
$CORE:	MOVX	T1,.INFIN		;GET INFINITY
	MOVEM	T1,.NMUL##+1		;SAVE AS MAX
	PUSHJ	P,.COREW##		;READ CORE VALUE
	PUSH	P,N			;SAVE IT
	CAIE	C,":"			;MORE COMING?
	  JRST	CORE.1			;NO
	PUSHJ	P,.COREW##		;READ NEXT CORE VALUE
	MOVEM	N,.NMUL##+1		;STORE
CORE.1:	POP	P,N			;RESTORE FIRST ARG
	MOVEM	N,.NMUL##		;STORE
	POPJ	P,			;AND RETURN

	SUBTTL	Switch scanning routines -- $NODE - Read a wildcarded node name

	[ASCIZ"Wildcarded node name/number_line"]
$NODE:	PUSHJ	P,$NAMEW		;READ WILDCARDED SIXBIT NODE
	SETOM	.NMUL##+2		;CLEAR /LINE
	CAIE	C,":"			;MORE COMING?
	 CAIN	C,"_"			;..
	  CAIA				;YES
	   POPJ	P,			;NO--RETURN
	PUSH	P,.NMUL##		;.OCTNW ZAPS IT
	PUSHJ	P,.OCTNW##		;READ LINE
	MOVEM	N,.NMUL##+2		;STORE
	POP	P,.NMUL##		;GET IT BACK
	POPJ	P,			;AND RETURN
	SUBTTL	Switch scanning routines -- $PHONE - Read a phone number string

	[ASCIZ/"Phone number string"/]
$PHONE:	MOVEI	T1,.TODSD
	MOVEM	T1,S.APC			;FORCE /DIAL
	PJRST	.ASCQW##			;AND READ ASCII STRING
	SUBTTL	Switch scnanning routines -- $SERVER - Read /SERVER arguments


IFN FTSERV,<

	[ASCIZ/node:[connect-type]:[timeout]/]
$SERVER:PUSHJ	P,$NAMEW		;GET NODE NUMBER OR NAME
	AOSE	.NMUL##+1		;CHECK FOR WILDCARDS
	$FATAL	(SCW,</SERVER node argument cannot be wild>)
	PUSH	P,.NMUL##		;SAVE IT
	PUSH	P,[EXP -1]		;DEFAULT CONNECT TYPE
	PUSH	P,[EXP -1]		;DEFAULT TIMEOUT
	CAIE	C,":"			;CONNECT TYPE ON THE WAY?
	JRST	SERV.2			;NO--MUST DEFAULT IT
	PUSHJ	P,.SIXSW##		;GET KEYWORD
	JUMPE	N,SERV.1		;HAVE A KEYWORD?
	MOVE	T1,[IOWD SRV.L,SRV.T]	;POINT TO TABLES
	PUSHJ	P,LKNAM##		;LOOKUP
	MOVEM	T1,-1(P)		;SAVE TABLE INDEX

SERV.1:	CAIE	C,":"			;TIMEOUT ARGUMENT?
	JRST	SERV.2			;NO
	PUSHJ	P,.DECNW##		;GET TIMEOUT IN SECONDS
	CAIG	N,.TSTMX		;CAN'T BE GREATER THAN MAXIMUM
	CAIGE	N,0			; BUT NOT NEGATIVE
	$FATAL	(STO,<Server timeout value out of range >,E.STO)
	MOVEM	N,0(P)			;SAVE ARG

SERV.2:	POP	P,.NMUL##+.SVTIM	;RESTORE TIMEOUT
	POP	P,.NMUL##+.SVTYP	;RESTORE CONNECT TYPE
	POP	P,.NMUL##+.SVNOD	;RESTORE NODE NAME/NUMBER
	SETZM	.NMUL##+.SVFLG		;INDICATE SOMETHING TYPED
	JRST	.SWDPB##		;RETURN AND STORE


E.STO:	MOVEI	T1,.TSTMN		;GET MINIMUM TIMEOUT VALUE
	PUSHJ	P,.TDECW##		;TYPE IT
	PUSHJ	P,.TDASH##		;SEPARATOR
	MOVEI	T1,.TSTMX		;GET MAXIMUM
	PJRST	.TDECW##		;TYPE IT AND RETURN

> ;END FTSERV
	SUBTTL	Switch scanning routines -- $SORT - Read a sort specification

	[ASCIZ/KEY:[A|D]:[number]/]
$SORT:	PUSHJ	P,.SIXSW##		;GET THE KEYWORD
	MOVE	T1,ISRTX(M)		;POINT TO TABLE
	PUSHJ	P,LKNAM##		;LOOKUP 
	ADD	T1,ASRTX(M)		;FIXUP OFFSET
	PUSH	P,T1			;SAVE INDEX
	SETZM	.NMUL##+1		;DEFAULT ASCEDNING
	MOVX	T1,.INFIN		;GET INFINITY
	MOVEM	T1,.NMUL##+2		;DEFAULT INFINIATE COUNTER
	CAIE	C,":"			;MORE COMING?
	 JRST	SORT.1			;NO
	PUSHJ	P,.TIAUC##		;PRIME THE PUMP
	CAIL	C,"0"			;DIGIT?
	 CAILE	C,"9"			;..
	  JRST	SORT.2			;NO--CHECK FOR KEYWORD
	PUSHJ	P,.DECNC##		;READ THE NUMBER
	MOVEM	N,.NMUL##+2		;STORE COUNT
	JRST	SORT.1			;AND EXIT

SORT.2:	PUSHJ	P,.SIXSC##		;READ KEYWORD
	MOVE	T1,[IOWD 2,[SIXBIT/ASCEND/]
			   [SIXBIT/DESEND/] ]
	PUSHJ	P,LKNAM			;LOOKUP NAME
	MOVEM	T1,.NMUL##+1		;SAVE MODE
	CAIE	C,":"			;COUNT COMING?
	 JRST	SORT.1			;NO--EXIT
	PUSHJ	P,.DECPW		;YES--READ COUNT
	MOVEM	N,.NMUL##+2		;STORE

SORT.1:	POP	P,T1			;RESTORE KEYWORD INDEX
	MOVEM	T1,.NMUL##		;SAVE
	JRST	.SWDPB##		;RETURN AND STORE


	SUBTTL	Switch scanning routines -- $SUMMARY - Read a summary keyword

	[ASCIZ/keyword/]
$SUMMARY:PUSHJ	P,.SIXSW##		;GET THE KEYWORD
	MOVE	T1,ISUMX(M)		;POINT TO TABLE
	PUSHJ	P,LKNAM##		;LOOKUP
	ADD	T1,ASUMX(M)		;FIXUP OFFSET
	MOVEI	N,(T1)			;COPY FOR SCAN
	JRST	.SWDPB##		;AND RETURN
	SUBTTL	Switch scanning routines -- $REP - Read a repeat time and count

	[ASCIZ/sleep-time:repeat-count/]
$REP:	PUSHJ	P,.DECPW			;GET A NUMBER
	PUSH	P,N				;SAVE A MOMENT
	MOVX	N,.INFIN			;A BIG REPEAT TIME
	CAIN	C,":"				;MORE COMING?
	 PUSHJ	P,.DECPW			;YES
	MOVEM	N,.NMUL##+1			;STORE REPEAT TIME
	POP	P,.NMUL##			;AND SLEEP TIME
	JRST	.SWDPB##			;AND GO STORE
	SUBTTL	Switch scanning routines -- $TTY, $PTY, $DET - Read terminal specifications

	[ASCIZ/Terminal specification/]
$DET:	MOVEI	T1,2
	JRST	TTY.1

	[ASCIZ/Terminal specification/]
$PTY:	MOVEI	T1,1
	JRST	TTY.1

	[ASCIZ/Terminal specification/]
$TTY:	MOVEI	T1,0
TTY.1:	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVEI	P1,(T1)			;SAEV INDEX
	PUSHJ	P,.TIAUC##		;GET ACHAR
	CAIL	C,"0"			;SEE IF IF DIGIT
	CAILE	C,"7"			;..
	  PJRST	.SIXSC##		;NO--READ SIXBIT AND RETURN
	PUSHJ	P,.OCTNC##		;YES--READ AS OCTAL
	MOVEI	T1,(N)			;COPY TO T1
	PUSHJ	P,TTYNNN		;MAKE NNN IN SIXBIT
	HLL	T1,[SIXBIT/TTY/
		    SIXBIT/PTY/
		    SIXBIT/DET/](P1)	;FORM FULL DIRE
	MOVE	N,T1			;RETURN IN "N"
	POPJ	P,			;AND RETURN
	SUBTTL	Switch scanning routines -- $DISK - Read disk priority

	[ASCIZ/Decimal number (max=3)/]
$DISK:	PUSHJ	P,.DECNW##		;GET A NUMBER
	MOVM	T1,N			;ABSOLUTE VALUE
	CAIL	T1,<1_<WID(JS.PRI)-1>>	;RANGE TEST
	 JRST	E.SVTL##		;NO--TOO LARGE
	ADDI	N,<1_WID(JS.PRI)>	;MAKE NON-NEGATIVE
	JRST	.SWDPB##		;AND STORE
	SUBTTL	Switch scanning routines -- $FORCE - Read a forced command

	[ASCIZ/Forced command name/]
$FORCE:	MOVEI	N,0			;CLEAR WORD
	MOVE	T1,[POINT 6,N]		;SETUP POINTER TO IT
FORC.1:	PUSHJ	P,.TIAUC##		;GET A CHAR
	PUSHJ	P,.TICAN##		;SEE IF ALPHA-NUMERIC
	 CAIN	C,"."			;OR DOT
	  CAIA				;LOOKS GOOD
	   JRST .SWDPB##		;NO--ALL DONE
	SUBI	C," "-' '		;CONVERT TO SIXBIT
	TLNE	T1,770000		;POINTER FULL?
	 IDPB	C,T1			;NO--STORE
	JRST	FORC.1			;AND LOOP
	SUBTTL	Switch scanning routines -- $MODE - Read /MODE specifier

$MODE:	PUSHJ	P,.SIXSW##		;GET THE KEYWORD
	MOVE	T1,[IOWD MON.L,MON.T]	;POINT TO TABLES
	PUSHJ	P,LKNAM##		;LOOKUP
	PUSHJ	P,SETMOD##		;SET UP AC 'M'
	JRST	.SWDON##		;AND RETURN
	SUBTTL	Switch scanning routines -- CACHE - Read blocks to cache

$CACHE:	PUSHJ	P,.DECNW##		;READ NUMBER
	MOVEM	N,S.CACHE		;SAVE IT
	JRST	.SWDON##		;RETURN W/O STORE
	SUBTTL	Switch scanning routines -- .DECPW - Read positive decimal number

.DECPW::PUSHJ	P,.DECNW##		;READ SIGNED NUMBER
	JUMPL	N,E.SVNG##		;ERROR IF NEGATIVE
	POPJ	P,			;ELSE RETURN
SLIFM:	MOVEI	T1,S.INFORM
	PJRST	SLKEY
SLCAP:	SKIPA	T1,[S.CAPABILITY]
SLPRV:	 MOVEI	T1,S.PRIVILEGE

SLKEY:	CAMN	N,[-1,,0]		;SEE IF "NONE"
	 JRST	SLNONE			;YES
	CAMN	N,[0,,-1]		;SEE IF "ALL"
	 JRST	SLALL			;YES
	SUBI	N,1			;ADJUST TO 0..X
	MOVEI	T2,1			;GET A BIT
	LSH	T2,(N)			;DIAL A BIT
	TDNE	T2,(T1)			;SEE IF SPECIFIED
	 $FATAL	(DKS,<Duplicate keyword specified>)
	IORM	T2,(T1)			;NO--SET FOR NEXT TIME
	CAIL	N,0			;SEE IF NOxxx
	 IORM	T2,1(T1)		;NO--SET
	CAIGE	N,0			;SEE IF NOxxx
	 ANDCAM	T2,1(T1)		;YES--CLEAR
	JRST	.SWDON##		;AND RETURN

SLNONE:	SETZM	(T1)			;CLEAR ALL BITS
	SETZM	1(T1)			;..
	JRST	.SWDON##		;AND RETURN

SLALL:	SETOM	(T1)			;SET ALL BITS
	SETOM	1(T1)			;..
	JRST	.SWDON##		;AND RETURN

	GLOB	E$$DSI
	$FATAL	(DSI,<Double switch illegal >,.TSIXN##)
	SUBTTL	Defaulting -- Scan specifications

WHOSCN::SETZM	I.PREV			;NO PREVIOUS SPEC YET
	PUSHJ	P,S$FIRST##		;POSITION TO FIRST SCAN SPEC

SCNLOP:	MOVEI	T1,(I)			;POINT TO SCAN SPEC
	MOVEI	T2,.FZLEN		;GET LENGTH OF SPEC
	PUSHJ	P,.OSDFS##		;APPLY SWITCH.INI DEFAULTS
	MOVEI	T1,(I)			;POINT TO SCAN SPEC
	PUSHJ	P,APOFIL		;APPLY SWITCH.INI FILE SWITCHES
	PUSHJ	P,@SCNXXX##(M)		;DO MODE SPECIFIC DEFAULTS
	SKIPN	T1,I.PREV		;GET PREVIOUS SCAN BLOCK
	 JRST	SCNNXT			;FIRST TIME THROUGH
	MOVE	T2,.FZFMT(T1)		;GET PREVIOUS SPECS /FORMAT
	SKIPGE	.FZFMT(I)		;THIS SPEC HAVE /FORMAT?
	 MOVEM	T2,.FZFMT(I)		;NO--DEFAULT FROM PREVIOUS
	MOVE	T2,.FZPRF(T1)		;GET PREVIOUS SPECS /PERFORMANCE
	SKIPGE	.FZPRF(I)		;THIS SPEC HAVE /PERFORMANCE?
	 MOVEM	T2,.FZPRF(I)		;NO--DEFAULT FROM PREVIOUS
	MOVE	T2,.FZDBS(T1)		;GET PREVIOUS SPECS /DDBS
	SKIPGE	.FZDBS(I)		;THIS SPEC HAVE /DDBS?
	 MOVEM	T2,.FZDBS(I)		;NO--DEFAULT FROM PREVIOUS
	MOVE	T2,.FZMAP(T1)		;GET PREVIOUS SPECS /MAP
	SKIPGE	.FZMAP(I)		;THIS SPEC HAVE /MAP?
	 MOVEM	T2,.FZMAP(I)		;NO--DEFAULT FROM PREVIOUS
	SKIPE	.FZINM(I)		;THIS SPEC HAVE /INFORMATION?
	 JRST	SCNNXT			;YES--LEAVE ALONE
	MOVE	T2,.FZINM(T1)		;NO--DEFAULT FROM PREVIOUS SPEC
	MOVEM	T2,.FZINM(I)		;..
	MOVE	T2,.FZINF(T1)		;..
	MOVEM	T2,.FZINF(I)		;..
SCNNXT:	MOVEM	I,I.PREV		;SAVE PREVIOUS SCAN SPEC
	MOVEI	T1,(I)			;POINT TO SCAN SPEC
	PUSHJ	P,APPFIL		;APPLY FILE DEFAULTS
	PUSHJ	P,S$NEXT##		;GET NEXT SCAN SPEC
	 POPJ	P,			;ALL DONE
	JRST	SCNLOP			;AND LOOP
	SUBTTL	Defaulting -- Switch defaults

SWTDEF::MOVEI	T1,NO			;GET /NOPRINT
	SKIPGE	S.PRINT			;SEE IF PRINT GIVEN
	 SKIPGE	S.SUMMARY		;NO--SEE IF /SUMMARY
	  CAIA			
	   MOVEM T1,S.PRINT		;YES-STORE /NOPRINT
	SKIPL	T1,S.DPY		;SEE IF /DPY
	 MOVEM	T1,S.REPEAT		;STORE AS /REPEAT
	SKIPL	T1,S.DPY+1		;..
	 MOVEM	T1,S.REPEAT+1		;..
	MOVE	T1,S.COLUMN		;GET /COLUMN
	CAIGE	T1,1			;INSURE AT LEAST 1
	 MOVEI	T1,1			;NOPE
	MOVEM	T1,S.COLUMN		;AND STORE
	SKPYES	S.STAMP			;SEE IF /STAMP
	 JRST	SWTD.1			;NO
	SKIPE	S.INITAL		;SEE IF /INITIAL
	 $FATAL	(SII,</STAMP illegal with /INITIAL>)
	MOVE	T1,[LSTAMNORMAL##,,FSTAMNORMAL##] ;GET /STAMP FORMAT
	MOVEM	T1,S.INITAL		;SAVE AS /INITIAL
SWTD.1:	PUSHJ	P,S$FIRST##		;POSITION TO FIRST SCAN SPEC
SWTD.2:	PUSHJ	P,SETFC			;SET FORMAT SWITCH FOR COMMAND
	PUSHJ	P,S$NEXT##		;GET NEXT SCAN SPEC
	 PJRST	APPGLB			;DONE--DEFAULT GLOBALS AND RETURN
	JRST	SWTD.2			;AND LOOP
	SUBTTL	Defaulting -- Format switch

SETFC::	SKIPGE	T1,.FZFMT(I)		;GET FORMAT SWITCH
	 JRST	SETFM			;NONE SPECIFIED
	TLNE	T1,-1			;SEE IF COUNT IN LH
	 JRST	SETFM1			;YES--USE USERS FORMAT
SETFM::	SKIPLE	T1,.FZFMT(I)		;GET FORMAT SWITCH
	 TLNE	T1,-1			;SEE IF USER COUNT
	  MOVEI	T1,%NORMAL		;FORCE NORMAL
	MOVE	T1,@FORTAB(M)		;LOAD DEFAULT FORMAT FOR MODE
SETFM1:	MOVEM	T1,.FZPFM(I)		;SAVE PRINT FORMAT
	POPJ	P,			;AND RETURN
	SUBTTL	Defaulting -- Output specification defaults

OUTDEF::
IFN FTSERV,<
	TLNE	F,(FL.WHOSRV)		;ARE WE A SERVER?
	PJRST	SRVDEF##		;YES--FIX UP OUTPUT FILESPEC ELSEWHERE
> ;END IFN FTSERV

	MOVEI	T1,O.SPEC		;POINT TO OUTPUT SPEC
	MOVEI	T2,.FZLEN		;INDICATE LENGTH
	PUSHJ	P,.OSDFS##		;APPLY SWITCH.INI DEFAULTS
	MOVSI	T1,'TTY'		;DEFAULT TTY:
	SKIPN	O.SPEC+.FXDEV		;SEE IF DEVICE
	  MOVEM	T1,O.SPEC+.FXDEV	;NO--STORE DEFAULT
	SKIPN	O.SPEC+.FXNAM		;SEE IF NAME
	  SETOM	O.SPEC+.FXNMM		;NO--MARK NOT WILD
	MOVE	T1,[SIXBIT/WHO/]	;GET DEFAULT NAME
	SKIPN	O.SPEC+.FXNAM		;SEE IF GIVEN
	  MOVEM	T1,O.SPEC+.FXNAM	;NO--STORE DEFAULT
	HRLOI	T1,'LST'		;GET DEFAULT EXTENSION
	SKIPN	O.SPEC+.FXEXT		;SEE IF GIVEN
	  MOVEM	T1,O.SPEC+.FXEXT	;NO--STORE DEFAULT
	MOVE	T1,.JBVER		;GET OUR VERSION
	SKIPGE	O.SPEC+.FXVER		;SEE IF /VERSION
	 MOVEM	T1,O.SPEC+.FXVER	;NO--DEFAULT OURS
	MOVE	T1,[.FZLEN,,O.SPEC]	;POINT TO OUTPUT SPEC
	MOVEI	T2,O.OPEN##		;POINT TO OPEN BLOCK
	MOVE	T3,[LN$LEN,,O.ENTER##]	;POINT TO ENTER BLOCK
	MOVEI	T4,O.PATH##		;POINT TO OUTPUT PATH. BLOCK
	PUSHJ	P,.STOPB##		;CONVERT SCAN BLOCKS
  	  $FATAL (NWO,<No wildcarding output specification>)
	MOVSI	T1,'WHO'		;GET PROGRAM NAME
	MOVEM	T1,O.ENTER##+.RBSPL	;STORE AS SPOOLED NAME
	POPJ	P,			;AND RETURN
	SUBTTL	SCAN support -- CLRANS - Clear answers and reset things

CLRANS:	TRZ	F,-1-FR.OPEN		;CLEAR MOST LOCAL FLAGS
	MOVEI	T1,.TOCHR##		;SET FOR BUFFERED OUTSTR
	TLNN	F,(FL.WHOSRV)		;IF NOT WHOSRVER
	 MOVEM	T1,.TOUTZ##		;STORE
	PUSHJ	P,S$DEALLOC##		;DEALLOCATE SCAN SPECS
	PUSHJ	P,C$DEALLOC##		;AND PER COMMAND MEMORY STUFF
	MOVE	T1,[O.SPEC,,O.SPEC+1]	;SET UP BLT
	SETZM	O.SPEC			;CLEAR FIRST WORD
	BLT	T1,O.SPEC+.FZLEN-1	;CLEAR OUTPUT SCAN BLOCK
	MOVEI	T1,SETBLK		;POINT TO SETUUO ARGS BLOCK
	MOVEM	T1,SETPTR		;STORE
	SETZM	SETCNT			;NO SET UUO ARGS YET
	PJRST	CLRGLB			;CLEAR GLOBALS AND RETURN

	SUBTTL	SCAN support -- AOUT - Allocate an output spec

AOUT:	MOVEI	T1,O.SPEC		;POINT TO OUTPUT SPEC
	MOVEI	T2,.FZLEN		;INDICATE LENGTH
	PJRST	MEMFIL			;COPY FILE SWITCHES AND RETURN
	SUBTTL	SCAN support -- AIN - Allocate an input spec

AIN::	PUSHJ	P,S$ALLOC##		;ALLOCATE A SCAN SPEC
	MOVEI	T1,(I)			;POINT TO IT
	MOVEI	T2,.FZLEN		;INDICATE LENGTH
	PJRST	MEMFIL			;COPY FILE SWITCHES AND RETURN
SUBTTL	SCAN support -- CLRSTK - Clear file and sticky switches


CLRSTK::PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T1,-FSWT.L		;GET LENGTH OF FILE SWITCHES
	JUMPE	T1,CLRS.E		;RETURN IF NONE
CLRS.1:	MOVE	T2,FSWT.I(T1)		;GET INITIAL VALUE
	MOVEM	T2,FSWT.S(T1)		;STORE IN SWITCH AREA
	MOVEM	T2,FSWT.P(T1)		;AND IN STICKY SWITCH AREA
	AOBJN	T1,CLRS.1		;AND LOOP FOR ALL
CLRS.E:	POPJ	P,			;RETURN
SUBTTL	SCAN support -- CLRFIL - Clear file switches


CLRFIL:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T1,-FSWT.L		;GET LENGTH OF FILE SWITCHES
	JUMPE	T1,CLRF.E		;RETURN IF NONE
CLRF.1:	MOVE	T2,FSWT.I(T1)		;GET DEFAULT
	MOVEM	T2,FSWT.S(T1)		;STORE IN FSWT.S## AREA
	AOBJN	T1,CLRF.1		;LOOP FOR ALL
CLRF.E:	POPJ	P,			;RETURN
SUBTTL	SCAN support -- MEMSTK - Memorize sticky file switches


MEMSTK:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T1,-FSWT.L		;GET LENGTH OF FILE SWITCHES
	JUMPE	T1,MEMS.E		;RETURN IF NONE
MEMS.1:	MOVE	T2,FSWT.S(T1)		;GET VALUE
	CAME	T2,FSWT.I(T1)		;SEE IF SET
	  MOVEM	T2,FSWT.P(T1)		;NO--STORE AS STICKY IN FSWT.P##
	AOBJN	T1,MEMS.1		;AND LOOP
MEMS.E:	POPJ	P,			;RETURN
SUBTTL	SCAN support -- MEMFIL - Memorize file switches


MEMFIL:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T3,-FSWT.L		;GET LENGTH FILE SWITCHES
	JUMPE	T3,MEMF.E		;RETURN IF NONE
MEMF.1:	MOVE	T4,FSWT.S(T3)		;GET INITIAL VALUE
	MOVEM	T4,.FXLEN(T1)		;STORE IT
	ADDI	T1,1			;ADVANCE TO NEXT SCAN SPEC
	AOBJN	T3,MEMF.1		;LOOP FOR ALL SWITCHES
MEMF.E:	POPJ	P,			;AND RETURN
SUBTTL	SCAN support -- APPSTK - Apply sticky file switches


APPSTK:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T1,-FSWT.L		;GET LENGTH OF FILE SWITCHES
	JUMPE	T1,APPS.E		;RETURN IF NONE
APPS.1:	MOVE	T2,FSWT.S(T1)		;GET VALUE FROM FSWT.S AREA
	CAMN	T2,FSWT.I(T1)		;SEE IF USER GAVE
	  MOVE	T2,FSWT.P(T1)		;NO--USE STICKY VALUE
	MOVEM	T2,FSWT.S(T1)		;YES--STORE
	AOBJN	T1,APPS.1		;LOOP FOR ALL
APPS.E:	POPJ	P,			;RETURN
SUBTTL	SCAN support -- APPFIL - Default file switches


;CALL:
;	MOVEI	T1,SCAN SPEC BLOCK
;	PUSHJ	P,APPFIL		;DEFAULT FILE SWITCHES
;USES T1-T4


APPFIL:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T2,-FSWT.L		;GET LENGTH FILE SWITCHES
	JUMPE	T2,APPF.E		;RETURN IF NONE
APPF.1:	MOVE	T3,.FXLEN(T1)		;GET SWITCH VALUE
	MOVE	T4,FSWT.D(T2)		;GET DEFAULT
	CAMN	T3,FSWT.I(T2)		;SWITCH GIVEN?
	 CAMN	T4,[-1]			;NO--NO DEFAULT PROVIDED?
	  SKIPA				;YES
	MOVEM	T4,.FXLEN(T1)		;NO--STORE DEFAULT
	ADDI	T1,1			;ADVANCE TO NEXT SWITCH
	AOBJN	T2,APPF.1		;LOOP FOR ALL
APPF.E:	POPJ	P,			;AND RETURN
SUBTTL	SCAN support -- APOFIL - Default SWITCH.INI file switches


APOFIL:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T2,-FSWT.L		;GET LENGTH FILE SWITCHES
	JUMPE	T2,APOF.E		;RETURN IF NONE
APOF.1:	MOVE	T3,.FXLEN(T1)		;GET USER SWITCH VALUE
	CAMN	T3,FSWT.I(T2)		;SEE IF SWITCH GIVEN
	 MOVE	T3,FSWT.S(T2)		;NO--GET SWITCH.INI VALUE
					;(MAY NOT BE SET--APPFIL WILL HANDLE)
	MOVEM	T3,.FXLEN(T1)		;STORE
	ADDI	T1,1			;ADVANCE TO NEXT SWITCH
	AOBJN	T2,APOF.1		;LOOP FOR ALL
APOF.E:	POPJ	P,			;AND RETURN
SUBTTL	SCAN support -- CLRGLB - Clear global switches


CLRGLB:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T1,-GSWT.L		;GET LENGTH GLOBAL SWITCHES
	JUMPE	T1,CLRG.E		;RETURN IF NONE
CLRG.1:	MOVE	T2,GSWT.I(T1)		;GET INITIAL VALUE
	MOVEM	T2,GSWT.S(T1)		;STORE
	AOBJN	T1,CLRG.1		;LOOP FOR ALL
CLRG.E:	POPJ	P,			;AND RETURN
SUBTTL	SCAN support -- APPGLB - Default global switches


APPGLB:	PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVSI	T1,-GSWT.L		;GET LENGTH GLOBAL SWITCHES
	JUMPE	T1,APPG.E		;RETURN IF NONE
APPG.1:	MOVE	T2,GSWT.S(T1)		;GET SWITCH VALUE
	MOVE	T3,GSWT.D(T1)		;GET DEFAULT
	CAMN	T2,GSWT.I(T1)		;SWITCH GIVEN?
	 CAMN	T3,[-1]			;NO--NO DEFAULT PROVIDED?
	  SKIPA				;YES
	MOVEM	T3,GSWT.S(T1)		;NO--STORE DEFAULT
	AOBJN	T1,APPG.1		;LOOP FOR ALL
APPG.E:	POPJ	P,			;AND RETURN
	SUBTTL	Tables -- Format defaults

DEFINE FORM(LIST),<
	IRP LIST,<
		..TEMP==..TEMP+1
		%'LIST==:..TEMP
		EXP	SIXBIT	/LIST/
	>
>

;Generate list of form typeout modes
DEFINE	FORMS,<FORM<VFAST,FAST,NORMAL,SLOW>>

..TEMP==0

;Generate SCAN keyword table and keyword symbol values
%.T:	FORMS
%.L==.-%.T

DEFINE XX(MOD,ABR,MAP,TXT,ERR),<
	DEFINE FORM(LIST),<
		IRP LIST,<XWD L'ABR''LIST##, F'ABR''LIST##>
	>
	ABR'DAT::EXP	0		;;Illegal
		  FORMS
>

;Generate format dispatch tables
	MODES
	XX	DDB,DDB,DDBs,<No files>	;Until DDB is a mode

DEFINE XX(MOD,ABR,MAP,TXT,ERR),<ABR'DAT(T1)>

FORTAB:	MODES
	SUBTTL	Tables -- Monitor command interface

	..TEMP==-1
DEFINE	XX(MOD,ABR,MAP,TXT,ERR),<
	EXP SIXBIT/MOD/
	M%'MOD==:<..TEMP==..TEMP+1>
>

MON.T:	MODES
	XX	WHO		;Same as JOB mode
	XX	NETWORK		;Same as NODE mode
MON.L==.-MON.T

	SUBTTL	Tables -- SUMMARY and SORT keywords

DEFINE X(KEY,TXT,LOD,PRT,WID,RND<1>),<EXP SIXBIT /KEY/>

DEFINE START(X),<
	X'SMT==.
>

DEFINE LEN(X),<
	X'SML==.-X'SMT
>

SRT.T:!
SUM.T::	SUMMARY
	SUMGENERAL==.-SUM.T+1

DEFINE	XX(MOD,ABR,MAP,TXT,ERR),<IOWD ABR'SML,ABR'SMT>

ISRTX:!
ISUMX:	MODES

DEFINE	XX(MOD,ABR,MAP,TXT,ERR),<EXP ABR'SMT-SUM.T>

ASRTX:!
ASUMX:	MODES
	SUBTTL	Tables -- STATE keywords

STAT.L==0

DEFINE X(A),<
	EXP	SIXBIT	/A/
	STAT'A==:1_STAT.L
	STAT.L==STAT.L+1
>

STAT.T:	STATES
	SUBTTL	Other routines -- SETSPC - Set start and end of concatinated set

;CALL:
;	PUSHJ	P,SETSPC
;Returns with S.FRST and S.LAST updated
;Uses T1,I

SETSPC::MOVEM	I,S.FRST		;SAVE FIRST SPEC ADDRESS
SETS.1:	MOVEM	I,S.LAST		;SAVE LAST SPEC ADDRESS
	LOAD	T1,.FXMOD(I),FX.TRM	;GET TERMINATOR
	JUMPE	T1,.POPJ##		;RETURN IF END
	PUSHJ	P,S$NEXT##		;GET NEXT SCAN SPEC
	 POPJ	P,			;ALL DONE
	JRST	SETS.1			;AND LOOP
	SUBTTL	Other routines -- FIXTTY - Convert TTY/PTY/CTY to standard format

;CALL:
;	PUSHJ	P,FIXTTY
;RETURNS NEW VALUES IN .FZTTY/.FZTTM

FIXTTY::MOVE	T3,.FZTTY(I)		;GET /TTY:
	TLNN	T3,-1			;SEE IF 0,,STUFF
	 MOVSS	T3			;YES--POSITION TO LH
	HLRZ	T4,.FZTTY(I)		;GET LH
	CAIN	T4,1			;SEE IF SPECIAL NOxxx FORM
	 POPJ	P,			;YES--LEAVE ALONE
	PUSHJ	P,TTYCHK		;CONVERT TO STANDARD FORMAT
	MOVEM	T3,.FZTTY(I)		;SAVE
	PUSHJ	P,.MKMSK##		;MAKE MASK
	TRNE	T1,-1
	  TRO	T1,-1
	MOVEM	T1,.FZTTM(I)		;AND STORE
	POPJ	P,			;RETURN

TTYCHK:	CAMN	T3,[-1]			;SEE IF SPECIFIED
	 POPJ	P,			;NO--RETURN
	PUSHJ	P,FIXNNN		;EXTRACT NNN IN OCTAL
	HLRZ	T2,T3			;GET GENERIC PART
	CAIN	T2,'CTY'		;SEE IF CTY
	 JRST	FIXTC			;YES--CHECK THAT
	CAIN	T2,'PTY'		;SEE IF PTY
	 JRST	FIXTP			;YES--CHECK THAT
	CAIN	T2,'DET'		;SEE IF DET
	 JRST	FIXTD			;YES--CHECK THAT
	CAIE	T2,'TTY'		;SEE IF TTY
	 $FATAL	(ITF,<Illegal TTY format>);NO--ERROR
	CAMN	T1,CTYLIN##		;SEE IF CTY
	 JRST	FIXTCC			;YES--RETURN CTY
	CAMGE	T1,SYSPTY##		;SEE IF IN PTY RANGE
	 POPJ	P,			;NO--RETURN OK
	SUB	T1,SYSPTY##		;YES--CONVERT TO PTY RANGE
	CAML	T1,PTYN##		;SEE IF IN RANGE
	 $FATAL	(TOR,<TTY number out of range>);NO--ERROR
	PUSHJ	P,TTYNNN		; INTO SIXBIT
	HRLI	T1,'PTY'		; AND INCLUDE GENERIC
	MOVE	T3,T1			;RETURN IN T3
	POPJ	P,			;AND EXIT

FIXTCC:	MOVSI	T3,'CTY'		;RETURN CTY
	POPJ	P,			;AND EXIT

FIXTP:	CAML	T1,PTYN##		;SEE IF IN RANGE
	 JRST	E$$TOR			;NO--ERROR
	POPJ	P,			;YES--RETURN

FIXTC:	TRNE	T3,-1			;CTY HAS NO DIGITS
	 JRST	E$$ITF			;SO THATS BAD IF SPECIFIED
	POPJ	P,			;ELSE RETURN

FIXTD:	MOVE	T2,SYSPTY##		;GET FIRST PTY
	ADD	T2,PTYN##		;PLUS NUMBER OF PTYS
	CAML	T1,T2			;SEE IF IN RANGE
	 JRST	E$$TOR			;NO--EROR
	POPJ	P,			;YES--OK


	SUBTTL	Other routines -- FIXNNN - Form octal terminal number

FIXNNN:	MOVEI	T1,0			;CLEAR RESULT
	MOVE	T2,[POINT 6,T3,17]	;SETUP POINTER TO DIGITS
FIXN.1:	ILDB	T4,T2			;GET A DIGIT
	JUMPE	T4,.POPJ##		;RETURN IF BLANK
	CAIL	T4,'0'			;SEE IF OCTAL SIXBIT
	 CAILE	T4,'7'			;..
	  $FATAL (NNT,<Non-numeric TTY specification>)
	IMULI	T1,10			;ADVANCE DIGITS
	ADDI	T1,-'0'(T4)		;ADD NEXT DIGIT IN
	TLNN	T2,770000		;SEE IF ALL DONE
	 POPJ	P,			;YES--RETURN
	JRST	FIXN.1			;NO--LOOP


	SUBTTL	Other routines -- TTYNNN - Form SIXBIT terminal number

TTYNNN::CAILE	T1,777			;GENERAL RANGE CHECK TTY NUMBER
	 JRST	E$$TOR			;NO--OUT OF RANGE
	MOVE	T3,[POINT 6,T1,17]	;SETUP POINTER
TTYNN1:	IDIVI	T1,10			;BREAK OFF DIGITS
	PUSH	P,T2			;SAVE DIGIT
	CAIE	T1,0			;ALL DONE?
	  PUSHJ	P,TTYNN1		;NO--RECURSE
	POP	P,T2
	ADDI	T2,'0'			;MAKE SIXBIT
	IDPB	T2,T3			;STORE DIGIT
	POPJ	P,			;AND RETURN

	SUBTTL	Other routines -- CHKJOB - Range check job number

CHKJOB::PUSH	P,T1			;SAVE JOB NUMBER
	PUSHJ	P,XB$JMX##		;GET JOBMAX
	CAMGE	T1,(P)			;WITHIN RANGE?
	 $FATAL	(JOR,<Job number out of range>)
	POP	P,T1			;RESTORE T1
	POPJ	P,			;AND RETURN

	SUBTTL	Other routines -- CHKDOT - See if dot (".") valid

CHKDOT::TLNE	F,(FL.CRASH)		;CRASH FILE READING?
	 $FATAL	(DSC,<Dot (".") specification illegal when reading crash files>)
	TLNE	F,(FL.WHOSRV)		;ARE WE A SERVER?
	 $FATAL (DSS,<Dot (".") specification illegal for server requests>)
	POPJ	P,			;AND RETURN
	SUBTTL	Other routines -- FIXNOD - Fix up node specification

;This routine insures that .FZNNM has a sixbit node name, and .FZNMM
;has its wildcarded mask. It handles the case of .FZNNM initialing 
;having either sixbit alpha, sixbit numeric, or octal node name/number.

FIXNOD::MOVE	T1,.FZNNM(I)		;GET NODE
	CAMN	T1,[-1]			;SWITCH GIVEN?
	 POPJ	P,			;NO--LEAVE ALONE
	TLNN	T1,-1			;SIXBIT OR OCTAL?
	 JRST	NOD.1			;OCTAL
	MOVEI	T1,0			;SIXBIT--CLEAR ANSWER
	MOVE	T2,[POINT 6,.FZNNM(I)]	;POINT TO SIXBIT NUMERIC
NOD.2:	ILDB	T3,T2			;GET A CHAR
	JUMPE	T3,NOD.1		;DONE IF BLANK
	CAIL	T3,'0'			;SEE IF OCTAL DIGIT
	 CAILE	T3,'7'			;..
	  JRST	NOD.E			;NO--POSSIBLY ERROR
	IMULI	T1,10			;SHIFT
	ADDI	T1,-'0'(T3)		;ADD DIGIT IN
	TLNE	T2,770000		;DONE?
	 JRST	NOD.2			;NO--LOOP
NOD.1:	PUSHJ	P,NODINF##		;CONVERT TO NAME
	 MOVEI	T1,-1			;INVALID
	MOVEM	T1,.FZNNM(I)		;STORE NAME
	SETOM	.FZNMM(I)		;INDICATE NOT WILD
	POPJ	P,			;AND RETURN

NOD.E:	JUMPE	T1,.POPJ##		;OK IF NO DIGITS YET
	$FATAL	(NNN,<Non-numeric NODE specification>);ERROR IF NOT
	SUBTTL	Other routines -- MSKUC/MSKLC - Convert ASCII strings to masks

MSKUC::	SKIPA	T4,[137]		;MASK FOR UC CHARACTER
MSKLC::	 MOVEI	T4,177			;MASK FOR ALL CHARACTERS
	PUSHJ	P,.SAVE1##		;SAVE P1
	HRLI	T1,(POINT 7,)		;MAKE BYTE POINTERS
	HRLI	T2,(POINT 7,)		;..
	MOVEI	P1,(T3)			;SAVE COUNT
MSK.7:	ILDB	T3,T1			;GET A CHAR
	CAIN	T3,"*"			;ALL WILD?
	 JRST	MSK.S			;YES!
	CAIN	T3,"?"			;SEE IF WILDCARD
	 TDZA	T3,T3			;YES--FLAG
	  MOVEI	T3,(T4)			;NO--CLEAR
	IDPB	T3,T2			;STORE
	SOJG	P1,MSK.7		;LOOP
	POPJ	P,			;AND RETURN

MSK.S:	MOVEI	T3,0			;CLEAR MASK
	IDPB	T3,T2			;STORE FOR THIS POSITION
	SOJG	P1,MSK.S		;AND LOOP
	POPJ	P,			;AND RETURN
	SUBTTL	SETSCN - SCAN interface for SETUUOs


Comment	|


This module is designed to scan and setup the function table
to perform all the various SETUUOs that are scanned from the
SETUUO switch. It is called only from the internal switch dispatch
inside SCAN.

|
	SUBTTL	SETUUO -- $SETUUO - switch scanning

	[ASCIZ/SETUUO keyword:value/]
$SETUUO:MOVE	T1,[IOWD SETLEN,SETTAB]	;POINT TO TABLE
	PUSHJ	P,KEYWRD		;PROCESS THE KEYWORD
	AOS	SETCNT			;COUNT NUMBER OF SETUUO CMDS
	PUSHJ	P,.SAVE1##		;SAVE P1
	MOVE	P1,SETPTR		;GET OLD POINTER
	PUSH	P,P1			;SAVE POINTER TO ARG COUNT
	ADDI	P1,1			;BUMP TO JOB NUMBER
	SETZM	(P1)			;LEAVE ZERO FOR NOW
	ADDI	P1,1			;BUMP TO FNC,,ARG
	MOVE	T1,SETFNC(N)		;GET FUNCTION
	MOVEM	T1,(P1)			;STORE FNC CODE
	PUSHJ	P,@SETDSP(N)		;DISPATCH FOR SCANNING
	ADDI	P1,1			;BUMP PAST END
	CAIL	P1,SETBLK+LN$SET	;SEE IF TOO MANY ARGS
	 $FATAL	(TMS,<Too many SETUUO arguments>)
	MOVEM	P1,SETPTR		;STORE NEW POINTER
	POP	P,T1			;RESTORE ARG
	SUBI	P1,(T1)			;COMPUTE DIFFERENCE
	MOVEM	P1,(T1)			;STORE COUNT
	MOVE	T2,2(T1)		;CHECK ARG
	TRNN	T2,-1			;SEE IF ROUTINE SET
	 HRRM	N,2(T1)			;NO--STORE RETURNED ARG
	PJRST	.SWDON##		;AND RETURN W/O STORE
	SUBTTL	SETUUO -- Switch keyword tables and dispatches

DEFINE FUNCTIONS,<
	X	WATCH,	.STWTC
	X	MESSAGE,.STWTC
	X	LIMIT,	.STTLM
	X	TIME,	.STTLM
	X	CPU,	.STCPU
	X	DSKFUL,	.STDFL
	X	VIRTUAL,.STCVM
	X	PHYSICAL,.STCVM
	X	DEFER,	.STDFR
	X	DEFAULT,.STDEF
	X	VTIME,	.STTVM
>

DEFINE X(NAM,FNC),<EXP SIXBIT/NAM/>

SETTAB:	FUNCTIONS
SETLEN==.-SETTAB

DEFINE X(NAM,FNC),<XWD FNC,0>

SETFNC:	FUNCTIONS

DEFINE X(NAM,FNC),<EXP $'NAM>

SETDSP:	FUNCTIONS
	SUBTTL	SETUUO scanning -- $DSKFUL - Scan DSKFUL arguments

$DSKFUL:MOVEI	N,0			;DEFAULT PAUSE
	CAIE	C,":"			;MORING COMMING?
	 POPJ	P,			;NO--USE DEFAULT
	MOVE	T1,[IOWD DSKLEN,DSKTAB]	;YES--POINT TO TABLE
	PJRST	KEYWRD			;AND PROCESS

DSKTAB:	SIXBIT	/PAUSE/
	SIXBIT	/ERROR/
DSKLEN==.-DSKTAB
	SUBTTL	SETUUO scanning -- $DEFAULT - Scan DEFAULT arguments

$DEFAULT:CAIE	C,":"			;MORING COMING?
	  JRST	E$$SKR			;KEYWORD REQUIRED
	MOVE	T1,[IOWD DFRLEN,DFRTAB]	;POINT TO TABLE
	PUSHJ	P,KEYWRD		;PROCESS KEYWORD
	CAIE	C,":"			;STILL MORE?
	 JRST	E$$SKR			;NO--ERROR
	MOVEI	T1,1(P1)		;GET ADDR BLOCK
	HRRM	T1,(P1)			;STORE
	ADDI	P1,1			;BUMP
	MOVE	T1,DFRFNC(N)		;GET FUNCTION
	MOVEM	T1,(P1)			;STORE
	ADDI	P1,1			;BUMP
	PUSHJ	P,@DFRDSP(N)		;DISPATCH ON REST
	MOVEM	N,(P1)			;STORE ARG
	POPJ	P,			;RETURN

DEFINE DEFAULTS,<
IFN FTTUFTS,<
	X	EDITOR,	ST.EDI
	X	DESTINA,ST.DES
>;END IFN FTTUFTS
	X	PROTECT,.STDPC
	X	BUFFERS,.STDNB
>

DEFINE X(NAM,BIT),<EXP SIXBIT/NAM/>

DFRTAB:	DEFAULTS
DFRLEN==.-DFRTAB

DEFINE X(NAM,BIT),<EXP BIT>

DFRFNC:	DEFAULTS

DEFINE X(NAM,BIT),<EXP $'NAM>

DFRDSP:	DEFAULTS

$PROTECT:PUSHJ	P,.OCTNW##		;READ THE PROTECTION
	CAIL	N,0			;RANGE CHECK
	 CAIL	N,1_WID(RB.PRV)		;..
	  $FATAL (POR,<Protection out of range>)
	POPJ	P,			;AND RETURN

$BUFFER:PUSHJ	P,.DECNW##		;READ THE NUMBER
	TDNE	N,[-1,,777000]		;RANGE CHECK
	 $FATAL	(BOR,<Buffer argument out of range>)
	POPJ	P,			;AND RETURN

IFN FTTUFTS,<
$DESTIN:PJRST	.DECNW##		;READ THE DECIMAL ARG AND RETURN

$EDITOR:MOVE	T1,[IOWD EDILEN,EDITAB]	;POINT TO TABLE
	PUSHJ	P,KEYWRD		;PROCESS THE KEYWORD
	ANDI	N,1			;JUST THE LAST BIT
	POPJ	P,			;AND RETURN

EDITAB:	SIXBIT	/DEC/
	SIXBIT	/EXPERI/
	SIXBIT	/OFF/
	SIXBIT	/ON/
EDILEN==.-EDITAB
>;END IFN FTTUFTS
	SUBTTL	SETUUO scanning -- $DEFER - Scan DEFER argument

$DEFER:	MOVEI	N,1			;DEFAULT DEFER
	CAIE	C,":"			;MORE COMING?
	 POPJ	P,			;NO--USE DEFAULT
	MOVE	T1,[IOWD DEFLEN,DEFTAB]	;YES--POINT TO TABLE
	PJRST	KEYWRD			;AND PROCESS

DEFTAB:	SIXBIT	/NO/
	SIXBIT	/YES/
DEFLEN==.-DEFTAB
	SUBTTL	SETUUO scanning -- $VIRTUAL - Scan VIRTUAL arguments

$VIRTUAL:CAIE	C,":"			;ARG COMING?
	  JRST	E$$SKR			;KEYWORD REQUIRED
	PUSHJ	P,COREW			;READ CORE WORD
	MOVSI	N,(N)			;POSITION TO LH
VP.1:	MOVEI	T1,1(P1)		;GET ADDR
	HRRM	T1,(P1)			;STORE
	MOVEM	N,1(P1)			;STORE WORD
	AOJA	P1,.POPJ##		;BUMP AND RETURN

	SUBTTL	SETUUO scanning -- $PHYSICAL - Scan PHYSICAL argument

$PHYSICAL:CAIE	C,":"			;ARG COMING?
	 JRST	E$$SKR			;NO--ERROR
	PUSHJ	P,.TIAUC##		;GET A CHAR
	CAIL	C,"0"			;DIGIT?
	 CAILE	C,"9"			;..
	  JRST	PHYS.1			;NO
	PUSHJ	P,COREC			;READ CORE WORD
	JRST	VP.1			;AND STORE

PHYS.1:	MOVE	T1,[IOWD PHYLEN,PHYTAB]	;POINT TO TABLR
	PUSHJ	P,KEYWRC		;PROCESS KEYWORD
	CAIE	C,":"			;MORE COMING?
	 JRST	E$$SKR			;NO--ERROR
	PUSH	P,N			;SAVE INDEX
	PUSHJ	P,COREW			;READ CORE WORD
	POP	P,T1			;RESTORE INDEX
	CAIN	T1,0			;SEE IF LIMIT
	 TXO	N,400000		;YES--SET BIT
	JRST	VP.1			;AND STORE

PHYTAB:	SIXBIT	/LIMIT/
	SIXBIT	/GUIDEL/
PHYLEN==.-PHYTAB

COREW:	PUSHJ	P,.TIAUC##		;PRIME THE PUMP
COREC:	PUSHJ	P,.COREC##		;READ THE CORE WORD
	CAIG	N,^D512			;JUST A NUMBER?
	 LSH	N,^D10			;YES--CONVERT TO WORD
	LSH	N,-^D9			;ALWAYS CONVERT TO PAGES
	POPJ	P,			;AND RETURN


	SUBTTL	SETUUO scanning -- $VTIMER - Scan VTIMER arg

$VTIMER:MOVEI	N,^D500			;DEFAULT 500 MILLISECONDS
	CAIN	C,":"			;ARG COMING?
	 PUSHJ	P,.DECNW##		;YES--GET IT
	POPJ	P,			;AND RETURN
	SUBTTL	SETUUO scanning -- $TIME, $LIMIT - Scan a TIME argument

$TIME:!
$LIMIT:	PUSHJ	P,.SAVE2##		;SAVE P1/P2
	MOVEI	P1,0			;START CLEAR
	MOVEI	P2,3			;PRESET MAX SUPER DIGITS
LIMI.1:	CAIE	C,":"			;MORE COMING?
	 JRST	LIMI.2			;NO--RETURN
	PUSHJ	P,.DECNW##		;YES--READ NUMBER
	CAIL	N,^D0			;RANGE CHECK
	 CAILE	N,^D60			;..
	  $FATAL (LOR,<Limit out of range>)
	IMULI	P1,^D60			;SHIFT OVER
	ADDI	P1,(N)			;ACCUMULATE DIGITS
	SOJGE	P2,LIMI.1		;LOOP FOR MAX
	$FATAL	(IFL,<Illegally formated limit switch>)
LIMI.2:	MOVE	N,P1			;COPY ARG FOR RETURN
	POPJ	P,			;AND EXIT
	SUBTTL	SETUUO scanning -- $WATCH - Scan WATCH arguments

$WATCH:	PUSHJ	P,.SAVE1##		;SAVE P1
	CAIE	C,":"			;SEE IF MORE COMING
	 JRST	E$$SKR
	MOVEI	P1,0			;CLEAR WORD
WATC.1:	MOVE	T1,[IOWD WATLEN,WATTAB]	;SCAN A KEYWORD
	PUSHJ	P,KEYWRD		;..
	IOR	P1,WATBIT(N)		;INCLUDE THE BIT FOR THAT ONE
	CAIN	C,","			;MORE COMING?
	 JRST	WATC.1			;YES--LOOP
	MOVE	N,P1			;COPY ARG FOR RETURN
	POPJ	P,			;AND RETURN

DEFINE WATCHS,<
	X	DAY,	ST.WDY
	X	RUN,	ST.WRN
	X	WAIT,	ST.WWT
	X	READS,	ST.WDR
	X	WRITES,	ST.WDW
	X	VERSION,ST.WVR
	X	MTA,	ST.WMT
	X	FILE,	ST.WFI
	X	ALL,	ST.WAL
>

DEFINE X(NAM,BIT),<EXP SIXBIT/NAM/>

WATTAB:	WATCHS
WATLEN==.-WATTAB

DEFINE X(NAM,BIT),<EXP BIT>

WATBIT:	WATCHS
	SUBTTL	SETUUO scanning -- $MESSAGE - Scan MESSAGE arguments

$MESSAGE:PUSHJ	P,.SAVE1##		;SAVE P1
	CAIE	C,":"			;SEE IF MORE COMING
	 JRST	E$$SKR
	MOVEI	P1,0			;CLEAR WORD
MESC.1:	MOVE	T1,[IOWD MESLEN,MESTAB]	;SCAN A KEYWORD
	PUSHJ	P,KEYWRD		;..
	IOR	P1,MESBIT(N)		;INCLUDE THE BIT FOR THAT ONE
	CAIN	C,","			;MORE COMING?
	 JRST	MESC.1			;YES--LOOP
	MOVE	N,P1			;COPY ARG FOR RETURN
	POPJ	P,			;AND RETURN

DEFINE MESSAGES,<
	X	CONTINUATION,	ST.WCN
	X	FIRST,		ST.WFL
	X	PREFIX,		ST.WPR
	X	ALL,		ST.WMS
>

DEFINE X(NAM,BIT),<EXP SIXBIT/NAM/>

MESTAB:	MESSAGES
MESLEN==.-MESTAB

DEFINE X(NAM,BIT),<EXP BIT>

MESBIT:	MESSAGES
	SUBTTL	SETUUO scanning -- $CPU - Scan CPU argument

$CPU:	PUSHJ	P,.SAVE1##		;SAVE P1
	CAIE	C,":"			;SEE IF MORE COMING
	 JRST	E$$SKR
	MOVEI	P1,0			;CLEAR WORD
CPUC.1:	MOVE	T1,[IOWD CPULEN,CPUTAB]	;SCAN A KEYWORD
	PUSHJ	P,KEYWRD		;..
	IOR	P1,CPUBIT(N)		;INCLUDE THE BIT FOR THAT ONE
	CAIN	C,","			;MORE COMING?
	 JRST	CPUC.1			;YES--LOOP
	MOVE	N,P1			;COPY ARG FOR RETURN
	POPJ	P,			;AND RETURN

DEFINE CPUS,<
X	CPU0,	SP.CR0
X	CPU1,	SP.CR1
X	0,	SP.CR0
X	1,	SP.CR1
>

DEFINE X(NAM,BIT),<EXP SIXBIT/NAM/>

CPUTAB:	CPUS
CPULEN==.-CPUTAB

DEFINE X(NAM,BIT),<EXP BIT>

CPUBIT:	CPUS
	SUBTTL	Support routines -- KEYWRD- Read keyword and search table

KEYWRC:	PUSH	P,T1			;SAVE USERS ARG
	PUSHJ	P,.SIXSC##		;READ SIXBIT (CHAR IN C)
	JRST	KEYW.1			;JOIN PROCESSING
KEYWRD:	PUSH	P,T1			;SAVE USERS ARG
	PUSHJ	P,.SIXSW##		;READ THE KEYWORD
KEYW.1:	JUMPE	N,E$$NKS		;ERROR IF NULL
	MOVE	T1,(P)			;GET USERS ARG
	PUSHJ	P,.NAME##		;LOOKUP IN TABLE
	 JRST	KEYW.2			;ERROR
	POP	P,T2			;GET USERS ARG BACK
	MOVEI	T1,-1(T1)		;FIX UP T1
	TLZ	T2,-1			;AND T2
	SUBI	T1,(T2)			;COMPUTE OFFSET
	MOVEI	N,(T1)			;COPY
	POPJ	P,			;AND RETURN

KEYW.2:	JUMPG	T1,E$$AKW		;CHECK UNKNOWN
	$FATAL	(UKW,<Unknown keyword >,E.KEY)
	$FATAL	(AKW,<Ambiguous keyword >,E.KEY)
	$FATAL	(NKS,<No keyword specified>)
	$FATAL	(SKR,<Switch keyword required>)
E.KEY:	MOVE	T1,N			;COPY ARG
	PJRST	.TSIXN##		;TYPE AND RETURN
	SUBTTL	Storage

	$LOW

CRSOPN:	BLOCK	3			;CRASH FILE OPEN BLOCK
CRSLOK:	BLOCK	.RBVER+1		;CRASH FILE LOOKUP BLOCK
CRSFIL::BLOCK	^D15			;ASCIZ CRASH FILE SPEC
CRSPTR:	BLOCK	1			;CRASH FILE BYTE POINTER
S.CACHE::BLOCK	1			;/CACHE: switch
S.FRST::BLOCK	1
S.LAST::BLOCK	1
I.PREV::BLOCK	1
O.SPEC::BLOCK	.FZLEN

SETBLK::BLOCK	LN$SET
SETPTR:	BLOCK	1
SETCNT::BLOCK	1

	END
