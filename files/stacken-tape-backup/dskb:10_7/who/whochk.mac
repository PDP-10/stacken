	TITLE	WHOCHK -- CHECK ROUTINE FOR WHO

	SEARCH	WHOMAC

	$SETUP	(WHOCHK)

Comment |

This module contains the driver subroutine WHOCHK, which dispatches
to the mode specific checking routines, but it handles 'AND', 'NOT',
and 'OR'. It also contains other general checking routines, currently
only CHKLOG to see if a job is logged in (used by WHOCMD).

|
;               TABLE OF CONTENTS FOR WHOCHK
;
;
;                        SECTION                                   PAGE
;    1. General checking
;         1.1   WHOCHK - See if matches users switches............   3
;         1.2   CHKTST - Check this spec for a match..............   4
;    2. Simple check tables
;         2.1   Define macros.....................................   5
;         2.2   JOB MODE..........................................   6
;         2.3   LINE MODE.........................................   7
;         2.4   NODE MODE.........................................   8
;         2.5   USER MODE.........................................   9
;    3. Checking routines
;         3.1   JOB MODE..........................................  10
;         3.2   LINE NODE.........................................  17
;         3.3   NODE MODE.........................................  18
;         3.4   Common tests......................................  19
;    4. General checking
;         4.1   CHKSTR - See if legal file structure..............  20
;         4.2   CHKNOD - See if node online.......................  21
;         4.3   CHKDEV - See if device given (single job).........  22
;         4.4   CHKLOG - See if logged out and legal..............  23
;    5. Storage...................................................  24
	SUBTTL	General checking -- WHOCHK - See if matches users switches

;CALL:
;	PUSHJ	P,WHOCHK
;	  <LOSE>
;	<WIN>

WHOCHK::MOVE	I,S.FRST##	;START WITH FIRST SPEC
	PUSHJ	P,S$POSITION##	;POSITION TO ENTRY

;HERE WHEN WINNING SO FAR

CHKTML:	PUSHJ	P,CHKTST	;TEST NEXT SPEC FOR MATCH
	  JRST	CHKTMB		;NO--BAD MATCH
CHKTMD:	LOAD	T1,.FXMOD(I),FX.TRM ;GET TERMINATOR
	JRST	@[.POPJ1##	;END--WIN BIG
		  CHKTMC	;'AND'--NEXT MUST ALSO WIN
		  .POPJ1##	;'OR'--WIN BIG
		  CHKTMN	;'NOT'--NEXT MUST NOT WIN
		  .POPJ1##	;+ (INDEPENDENT OF FT$COR)--WIN BIG
		  .POPJ1##	; (5)--ASSUME WIN BIG
		  .POPJ1##	; (6)--ASSUME WIN BIG
		  .POPJ1##](T1)	; (7)--ASSUME WIN BIG

;HERE WHEN OK SO FAR, THEN 'NOT'

CHKTMN:	PUSHJ	P,CHKTAD	;ADVANCE TO NEXT SPEC
	  JRST	.POPJ1##	;NOT THERE!--ASSUME BIG WIN
	PUSHJ	P,CHKTST	;TEST FOR MATCH
	  JRST	CHKTMD		;NO--PROCEED TO NEXT BASED ON SEPARATOR

;HERE WHEN LOST--MUST WAIT FOR NEXT 'OR' TO WIN

CHKTMB:	LOAD	T1,.FXMOD(I),FX.TRM ;GET TERMINATOR
	JRST	@[CHKTMF	;END--LOOSE BIG
		  CHKTMS	;'AND'--SKIP ON
		  CHKTMC	;'OR'--START MATCHING OVER
		  CHKTMS	;'NOT'--SKIP ON
		  CHKTMP	; + --DEPENDS ON FT$COR
		  CHKTMF	; (5)--ASSUME LOOSE BIG
		  CHKTMF	; (6)--ASSUME LOOSE BIG
		  CHKTMF](T1)	; (7)--ASSUME LOOSE BIG

;HERE WHEN SKIPPING TO NEXT 'OR' BECAUSE LOOSING

CHKTMS:	PUSHJ	P,CHKTAD	;ADVANCE TO NEXT SPEC
	  JRST	CHKTMF		;IF DONE, LOOSE BIG
	JRST	CHKTMB		;IF SOMETHING, REDISPATCH

;HERE WHEN WINNING AND 'AND' ENCOUNTERED

CHKTMC:	PUSHJ	P,CHKTAD	;ADVANCE TO NEXT
	  JRST	.POPJ1##	;IF DONE, ASSUME WIN BIG
	JRST	CHKTML		;THEN GO TEST THIS ALSO

;HERE IF TOO OLD OR TOO YOUNG--BACK DOWN SUCCESS COUNTER

CHKTMF:	POPJ	P,		;GIVE BAD NEWS TO CALLER

;DEFINE + BEHAVIOUR
ND FT$COR,-1	;LET + = 'OR'
IFN FT$COR,<CHKTMP==CHKTMC>
IFE FT$COR,<CHKTMP==CHKTMF>


;ROUTINE TO ADVANCE WITHIN CONCATINATED SET
;CALL:
;	PUSHJ	P,CHKTAD
;	  <DONE>
;	<NEXT SPEC>		;I POINTS TO NEXT SPEC

CHKTAD:	CAMN	I,S.LAST##	;AT THE END?
	 POPJ	P,		;YES--ALL DONE
	PJRST	S$NEXT##	;GET NEXT SPEC AND RETURN
	SUBTTL	General checking -- CHKTST - Check this spec for a match

;CALL:
;	MOVEI	I,SPEC ADDR
;	PUSHJ	P,CHKTST
;	  <LOSE>
;	<WIN>

CHKTST:	PUSHJ	P,.SAVE2##
	MOVE	P2,XCHK(M)		;LOAD CHECK AOBJN
CHKLOP:	MOVE	P1,@.CKSWT(P2)		;GET SWITCH VALUE
	CAMN	P1,.CKINI(P2)		;SEE IF DIFERENT THAN INITIAL
	 JRST	CHKNXT			;NO--THE SAME
	PUSHJ	P,@.CKLOD(P2)		;LOAD FIELD TO TEST
	SKIPN	.CKCHK(P2)		;SEE IF ROUTINE TO PROCESS
	 JRST	CHKL.1			;NO--TEST MASK
	PUSHJ	P,@.CKCHK(P2)		;DISPATCH TO CHECK
	 POPJ	P,			;REJECTED
	JRST	CHKNXT			;PASSED--GO ON

CHKL.1:	XOR	P1,T1			;MASK WITH VALUE
	TDNE	P1,@.CKMSK(P2)		;SEE IF MATCHES WHERE SIGNIFICANT
	 POPJ	P,			;REJECTED

CHKNXT:	CAMN	P2,XCHK(M)		;FIRST TIME?
	 AOS	NFOUND##		;YES--COUNT FOUND A THING
	ADD	P2,[.CKLEN-1,,.CKLEN-1]	;ADVANCE AOBJN
	AOBJN	P2,CHKLOP		;AND LOOP FOR ALL
	JRST	.POPJ1##		;PASSED!
	SUBTTL	Simple check tables -- Define macros

DEFINE XX(MOD,ABR,MAP,TXT,ERR),<XWD -L'ABR'CHK,T'ABR'CHK>

XCHK:	MODES


DEFINE CCHECK(MOD),<
	IRPC MOD,<
		DEFINE	V(XXX,INI<-1>,LOD),<
			IFB <LOD>,<X(.FZ'XXX##(I),[-1],INI,MOD'B$'XXX##,0)>
			IFNB <LOD>,<X(.FZ'XXX##(I),[-1],INI,MOD'B$'LOD##,0)>
	>
		DEFINE	VM(XXX,INI<-1>),<X(.FZ'XXX##(I),.FZ'XXX+1(I),INI,MOD'B$'XXX##,0)>
		DEFINE	VR(XXX,INI<-1>,LOD),<
			IFB <LOD>,<X(.FZ'XXX##(I),0,INI,MOD'B$'XXX##,MOD'C$'XXX)>
			IFNB <LOD>,<X(.FZ'XXX##(I),0,INI,MOD'B$'LOD##,MOD'C$'XXX)>
		>
	STOPI
	>
	T'MOD'CHK: CHECKS
	L'MOD'CHK==.-T'MOD'CHK
>;END DEFINE CCHECK

DEFINE X(SWT,MSK,INI,LOD,CHK),<
	SWT
	MSK
	INI
	LOD
	CHK
>;END DEFINE X
	SUBTTL	Simple check tables -- JOB MODE

DEFINE	CHECKS,<
	XLIST
	V	JOB		;;JOB NUMBER
	V	BJB		;;BATCH JOB BATCH
	V	CLS		;;CLASS
	V	CJN		;;CONTROLLING JOB NUMBER
	VM	LPN		;;LOGGED IN PPN
	VR	PVT,-1,LPN	;;PIVOTED
IFN FTIPC,<
	V	CAT		;;CATEGORY
	V	SLT		;;SLOT
	VM	CID		;;CHARGE ID
	V	BDG		;;DEC BADGE NUMBER
>
IFN FTMDC,<
	V	STP		;;SETP
>
	VR	APC		;;ASYNC PORT CHARACTERISTICS
	V	RMT		;;REMOTE TERMINAL BIT
	V	NLN		;;NETWORK LINE NUMBER
	V	BBB		;;BACKGROUND BATCH BIT
	V	BSN		;;BATCH STREAM NUMBER
	VM	PPN		;;PPN
	VM	PRG		;;PROGRAM
	VM	NNM		;;NETWORK NODE NAME
	VM	HSN		;;HIGH SEGMENT NAME
	VM	CPN		;;CONTROLLING PROGRAM NAME
	VM	CNO		;;CHARGE NUMBER
	VR	TTY		;;TERMINAL
	VR	HPQ		;;HPQ
	VR	DPR		;;DISK PRIORITY
	VR	STA, 0		;;JOB STATES (GENERIC)
	VR	WSC		;;JOB WAIT STATE CODES (2 CHAR THINGIES)
	VR	SLF,-1,PPN	;;SELF PPN
	VR	OPR,-1,PPN	;;OPERATORS
	VR	PRV, 0		;;PRIVILEGE BITS
	VR	CAP, 0,		;;CAPABILITY BITS
	VR	JST, 0,STS	;;JOB STATUS BITS
	VR	NAM		;;USER NAME
	VR	SNC,-1,JLT	;;LOGGED IN SINCE
	VR	BFR,-1,JLT	;;LOGGED IN BEFORE
	VR	RSN,-1,STM	;;RESET SINCE
	VR	RBF,-1,STM	;;RESET BEFORE
	VM	PTR		;;PROGRAM TO RUN
	VR	VM ,-1,PPL	;;JOB IS VIRTUAL
	VR	MOU,-1,PPN	;;MOUNTED STRUCTURE
	VR	CRL,-1,PPL	;;CORE SIZE (PHYSICAL)
	VR	VCL,-1,PVL	;;CORE SIZE (VIRTUAL)
	VR	LOC		;;JOBS LOCATION
	VR	ACC		;;ACCOUNT STRING
	VR	DDB, 0		;;DDB IN USE
	VR	WTO		;;WTO PRIVS
	VR	GOP		;;GALAXY OPR PRIVS
	VR	DDT		;;DDT IS LOADED
	VR	PFH		;;PFH IS LOADED
	LIST
>

EXTERN	JC$DDB
	CCHECK(JOB)
	SUBTTL	Simple check tables -- LINE MODE

	DEFINE	CHECKS,<
	XLIST
	VR	TTY		;;TERMINAL
	V	JOB		;;JOB NUMBER
	V	TSP		;;TRANSMIT SPEED
	V	RSP		;;RECEIVE SPEED
	V	NLN		;;NETWORK LINE NUMBER
	VR	APC		;;ASYNC PORT CHARACTERISTICS
	V	RMT		;;REMOTE TERMINAL BIT
	V	TAC		;;TERMINAL ASSIGNED BY COMMAND
	V	TAP		;;TERMINAL ASSIGNED BY PROGRAM
	V	TCJ		;;TERMINAL CONTROLLING A JOB
	V	DSC		;;DATA SET CARRIER
	V	SLV		;;SLAVE TERMINAL
	VM	NNM		;;NETWORK NODE NAME
	VM	TYP		;;TERMINAL TYPE
	VR	LOC		;;TERMINAL LOCATION STRING
	V	MCL		;;MIC CONTROLLED LINE
IFN FTLGNQ,<
	VR	LQP		;;LOGIN QUEUE POSITION
> ;END IFN FTLGNQ
	LIST
>

	CCHECK(LIN)
	SUBTTL	Simple check tables -- NODE MODE

DEFINE	CHECKS,<
	XLIST
	VM	NNM		;;NETWORK NODE NAME
	VM	TYP		;;NODE TYPE
	OBJECTS
	LIST
>

DEFINE XX(OBJ),<
	IF2,NC$'OBJ==CK$VAL
	VR	OBJ
>

	CCHECK(NOD)
	SUBTTL	Simple check tables -- STRUCTURE mode

DEFINE	CHECKS,<
	XLIST
	VM	STN		;;STRUCTURE NAME
	LIST
>

	CCHECK(STR)
	SUBTTL	Simple check tables -- UNIT mode

DEFINE	CHECKS,<
	XLIST
	VM	UNN		;;UNIT NAME
	LIST
>

	CCHECK(UNI)
	SUBTTL	Checking routines -- JOB MODE

JC$DPR:	CAIN	P1,PD.DPR##		;PRESENT DEFAULT?
	 JRST	DPR.1			;YES
	SUBI	P1,<1_WID(JS.PRI)>	;REMOVE OFFSET (SEE $DISK IN WHOSCN)
	CAME	T1,P1			;MATCH EXACTLY?
	 POPJ	P,			;NO--RETURN
	JRST	.POPJ1##		;YES--SKIP RETURN

DPR.1:	JUMPG	T1,.POPJ1##		;WIN IF GREATER THAN ZERO
	POPJ	P,			;ELSE REJECT


JC$HPQ:	CAIN	P1,PD.HPQ##		;PRESENT DEFAULT?
	 JRST	HPQ.1			;YES
	CAIE	T1,(P1)			;MATCH EXACTLY?
	 POPJ	P,			;NO--RETURN
	JRST	.POPJ1##		;YES--SKIP RETURN

HPQ.1:	JUMPG	T1,.POPJ1##		;WIN IF GREATER THAN ZERO
	POPJ	P,			;ELSE REJECT


JC$SLF:	CAMN	T1,.MYPPN##		;SEE IF MATCHES MY PPN
	 JUMPE	P1,.POPJ##		;YES--REJECT IF /NOSELF
	CAME	T1,.MYPPN##		;SEE IF MATCHES MY PPN
	 JUMPG	P1,.POPJ##		;NO--REJECT IF /SELF
	JRST	.POPJ1##		;YES--SKIP RETURN


JC$OPR:	SETO	T2,			;LOAD A MINUS 1
	MOVEI	T3,(T1)			;GET JOBS PROGRAMMER NUMBER
	MOVE	T4,OPRPPN##		;GET OPR PPN
	CAIE	T3,(T4)			;OPR PROGRAMMER?
	 JRST	OPR.1			;NO
	CAMN	T4,T1			;LOCAL OPR?
	 TDZA	T2,T2			;YES--FLAG WITH 0
	MOVEI	T2,1			;NO--LOAD A 1
OPR.1:	XCT	[JUMPGE T2,.POPJ##
		 JUMPL  T2,.POPJ##
		 JUMPN  T2,.POPJ##
		 JUMPLE T2,.POPJ##]-1(P1)
	JRST	.POPJ1##		;SUCESS RETURN


JC$RSN:!				;RESET TIME GREATER THAN SWITCH?
JC$SNC:	CAMG	T1,P1			;LOGIN GREATER THAN SWITCH?
	 POPJ	P,			;NO--REJECT
	JRST	.POPJ1##		;YES--ACCEPT


JC$RBF:!				;RESET TIME LESS THAN SWITCH?
JC$BFR:	CAML	T1,P1			;LOGIN LESS THAN SWITCH?
	 POPJ	P,			;NO--REJECT
	JRST	.POPJ1##		;YES--ACCEPT


JC$VM:	PUSH	P,T1			;SAVE PHYSICAL LOW SIZE
	PUSHJ	P,JB$PPH##		;PHYISCAL HIGH SIZE
	POP	P,T2			;RESTORE
	ADD	T1,T2			;SUM PHYSICAL SIZE
	PUSH	P,T1			;SAVE PHYSICAL SIZE
	PUSHJ	P,JB$PVL##		;VIRTUAL LOW SIZE
	PUSH	P,T1			;SAVE
	PUSHJ	P,JB$PVH##		;VIRTUAL HIGH SIZE
	POP	P,T2			;RESTORE
	ADD	T1,T2			;SUM VIRTUAL SIZE
	POP	P,T2			;RESTORE PHYSICAL SIZE
	CAIE	T2,1(T1)		;SAME (INCLUDE UPMP)
	 JUMPE	P1,.POPJ##		;NO--REJECT IF /NOVM
	CAIN	T2,1(T1)		;DIFFERENT (INCLUDE UPMP)
	 JUMPN	P1,.POPJ##		;NO--REJECT IF /VM
	JRST	.POPJ1##		;JUST RIGHT

JC$WSC:	TDNE	P1,[000077,,777777]	;ONLY 2 CHARS?
	 JRST	WSC.1			;NO--USE ALL
	LSH	P1,-^D24		;RIGHT JUSTIFY TWO CHARS
	LDB	T2,[POINT 12,T1,11]	;GET FIRST TWO STATE CHARS
	CAMN	T2,P1			;MATCH?
	 JRST	.POPJ1##		;YES--ACCEPT
	LDB	T2,[POINT 12,T1,29]	;GET NEXT TWO STAT CHARS
	CAMN	T2,P1			;MATCH?
	 JRST	.POPJ1##		;YES--ACCEPT
	POPJ	P,			;NO--REJECT

WSC.1:	CAME	T1,P1			;EXACT MATCH?
	 POPJ	P,			;NO--REJECT
	JRST	.POPJ1##		;YES--ACCEPT


JC$CRL:	PUSH	P,T1			;SAVE LOW SIZE
	PUSHJ	P,JB$PPH##		;GET HIGH SEG SIZE
	POP	P,T2			;RESTORE LOW
	ADDI	T1,(T2)			;GET TOTAL
	CAMG	T1,.FZCRH##(I)		;SEE IF TOO BIG
	 CAMGE	T1,.FZCRL##(I)		;OR TOO SMALL
	  POPJ	P,			;YES--REJECT
	JRST	.POPJ1##		;NO--ACCEPT


JC$VCL:	PUSH	P,T1			;SAVE LOW SIZE
	PUSHJ	P,JB$PVH##		;GET HIGH SEG SIZE
	POP	P,T2			;RESTORE LOW
	ADDI	T1,(T2)			;GET TOTAL
	CAMG	T1,.FZVCH##(I)		;SEE IF TOO BIG
	 CAMGE	T1,.FZVCL##(I)		;OR TOO SMALL
	  POPJ	P,			;YES--REJECT
	JRST	.POPJ1##		;NO--ACCEPT

JC$LOC:	CAMN	T1,P1			;MATCH USERS?
	 JRST	.POPJ1##		;YES--ACCEPT
	CAIE	P1,PD.LOC##		;PRESENT DEFAULT?
	 POPJ	P,			;NO--LOSE
	MOVE	P1,T1			;SAVE CURRENT LOCATION
	PUSHJ	P,JB$NNU##		;GET LOCATION OF TERMINAL
	CAME	P1,T1			;MATCH?
	 POPJ	P,			;NO--LOSE
	JRST	.POPJ1##		;YES--WIN

JC$WTO:	CAIN	P1,PD.WTO##		;PRESENT DEFAULT?
	 JRST	WTO.1			;YES
	CAIN	T1,-1(P1)		;MATCH? (KEYS START WITH 1)
	 AOS	(P)			;YES
	POPJ	P,			;AND RETURN
WTO.1:	CAIE	T1,.OBNOM		;NONE?
	 AOS	(P)			;NO--WIN
	POPJ	P,			;AND RETURN

JC$GOP:	CAIN	P1,PD.GOP##		;PRESENT DEFAULT?
	 JRST	GOP.1			;YES
	CAIN	T1,-1(P1)		;MATCH? (KEYS START WITH 1)
	 AOS	(P)			;YES
	POPJ	P,			;AND RETURN
GOP.1:	JUMPG	T1,.POPJ1##		;WIN IF ANY
	POPJ	P,			;ELSE LOSE

JC$PVT:	PUSH	P,T1			;SAVE LOGGED IN PPN
	PUSHJ	P,JB$PPN##		;GET CURRENT PPN
	POP	P,T2			;RESTORE LOGGED IN
	CAME	T1,T2			;MATCH?
	 JUMPG	P1,.POPJ1##		;NO--WIN IF /PIVOTED
	CAMN	T1,T2			;MATCH?
	 JUMPE	P1,.POPJ1##		;YES--WIN IF /NOPIVOTED
	POPJ	P,			;LOSE

JC$ACC:	MOVEI	T2,(I)
	HRLI	T2,-10
ACC.1:	MOVE	T3,.FZACC##(T2)
	XOR	T3,(T1)
	TDNE	T3,.FZATM##(T2)
	 POPJ	P,
	ADDI	T1,1
	AOBJN	T2,ACC.1
	JRST	.POPJ1##
JC$STA:	MOVE	T2,[-LN$STA,,STABIT]	;POINT TO TABLES
	PJRST	CHKBIT			;CHECK THE BITS

DEFINE	X(A),<EXP STAT'A##,STAT'A##>

STABIT:	STATES
LN$STA==.-STABIT
JC$CAP:	PUSHJ	P,.SAVE2##		;SAVE P1,P2
	DMOVE	P1,.FZCAP##(I)		;LOAD MASK, VALUES
	JRST	CAPPRV
UC$PRV:!
JC$PRV:	PUSHJ	P,.SAVE2##		;SAVE P1,P2
	DMOVE	P1,.FZPRV##(I)		;LOAD MASK, VALUES
CAPPRV:	MOVE	T2,[-LN$PRV,,PRVBIT]	;POINT TO BITS
	PJRST	CHKWRD			;AND CHECK BITS

DEFINE	PRIVS,<
	XLIST
	XX	IPCF	,JP.IPC
	XX	DISK	,JP.DPR
	XX	METER	,JP.MET
	XX	POKE	,JP.POK
	XX	CPU	,JP.CCC
	XX	HPQ	,JP.HPQ
	XX	UNSPOOL	,JP.NSP
	XX	ENQ	,JP.ENQ
	XX	RTTRP	,JP.RTT
	XX	LOCK	,JP.LCK
	XX	TRPSET	,JP.TRP
	XX	SPYALL	,JP.SPA
	XX	SPYMON	,JP.SPM
IFN FTIPC,<
	XX	NETEXAM	,JP.NEX
	XX	CHGPPN	,JP.CPN
>
IFN FTMDC,<
	XX	SETP	,JP.MPV
	XX	PRGRUN	,JP.SPG
>
IFN FTTUFTS,<
	XX	NAME	,JP.NAM
	XX	PPASSW	,JP.CPP
	XX	MAIL	,JP.MAI
	XX	SFD	,JP.SFD
	XX	SPASSW	,JP.CSP
	XX	COMBO	,JP.COM
	XX	MAGTAPE	,JP.MAG
>
	LIST
>

DEFINE	XX(A,B),<EXP PR'A##,B>

PRVBIT:	PRIVS
LN$PRV==.-PRVBIT
JC$JST:	MOVE	T2,[-LN$JST,,JSTBIT]	;POINT TO TABLE
	PJRST	CHKBIT			;GO CHECK THEM


DEFINE	JSTATUS,<
	XLIST
	XX RUN,JS.RUN
	XX CMDWAIT,JS.CMW
	XX MONERR,JS.ERR
	XX LOCK,JS.NSW
	XX SWAP,JS.SWP
	XX JACCT,JS.JAC
	XX DCORE,JS.JDC
	XX OPRWAIT,JS.OPR
	XX XONLY,JS.XOY
	XX DSKFUL,JS.DFP
	LIST
>

DEFINE	XX(A,B),<EXP <1_<ST'A##-1>>,B>

JSTBIT:	JSTATUS
LN$JST==.-JSTBIT

CHKBIT:	HRLZ	T3,(T2)			;GET THE SCAN BIT
	TDNN	T3,P1			;SEE IF KNOWN
	  JRST	CHKB.2			;NO
	MOVE	T4,1(T2)		;GET THE SPECIFIED BIT
	TSNE	T3,P1			;SEE IF /NOBIT
	 TDNE	T4,T1			;SEE IF BIT ON
	  SKIPA
	POPJ	P,			;LOSE
	TSNN	T3,P1			;SEE IF /BIT
	 TDNN	T4,T1			;SEE IF BIT OFF
	  SKIPA
	POPJ	P,
CHKB.2:	AOBJN	T2,.+1			;LOOP FOR ALL
	AOBJN	T2,CHKBIT		;..
	JRST	.POPJ1##		;WIN!

CHKWRD:	MOVE	T3,(T2)			;GET THE SCAN BIT
	TDNN	T3,P1			;SEE IF KNOWN
	 JRST	CHKW.2			;NO
	MOVE	T4,1(T2)		;GET THE SPECIFIED BIT
	TDNE	T3,P2			;SEE IF /NOBIT
	 TDNE	T4,T1			;SEE IF BIT ON
	  SKIPA
	POPJ	P,			;LOSE
	TDNN	T3,P2			;SEE IF /BIT
	 TDNN	T4,T1			;SEE IF BIT OFF
	  SKIPA
	POPJ	P,			;LOSE
CHKW.2:	AOBJN	T2,.+1			;LOOP FOR ALL
	AOBJN	T2,CHKWRD		;..
	JRST	.POPJ1##		;WIN!
JC$MOU:	MOVEM	T1,GOBBLK+.DFGPP	;STORE PPN
	PUSHJ	P,JB$JOB##		;GET JOB NUMBER
	MOVEM	T1,GOBBLK+.DFGJN	;STORE JOB NUMBER
	SETOM	GOBBLK+.DFGNM		;START WITH FIRST STR

CHKM.1:	MOVE	T1,[3,,GOBBLK]		;POINT TO BLOCK
	PUSHJ	P,UGOBSTR##		;READ S/L
	  POPJ	P,			;TOO BAD
	SKIPN	T1,GOBBLK+.DFGNM	;GET STR NAME
	 JRST	CHKM.1			;SKIP OVER FENCE
	AOJE	T1,.POPJ##		;END OF S/L
	CAMN	P1,GOBBLK+.DFGNM	;MATCH USERS?
	  JRST	.POPJ1##		;YES--MATCHES
	JRST	CHKM.1			;NO--LOOP
UC$NAM:!
JC$NAM:	MOVE	T2,1(T1)		;GET PART 2
	MOVE	T1,(T1)			;GET PART 1
NAM.3:	DMOVE	T3,T1			;COPY NAME
	XOR	T3,.FZNAM##(I)		;MASK OFF WITH USERS SWITCH
	XOR	T4,.FZNAM##+1(I)		;..
	TDNN	T3,.FZNMM##(I)		;CHECK
	 TDNE	T4,.FZNMM##+1(I)		;..
	  CAIA				;FAILED--CHECK AGAIN
	   JRST .POPJ1##		;GOOD RETURN
NAM.1:	LDB	T3,[POINT 6,T1,5]	;GET FIRST CHAR
	CAIL	T3,'A'			;ALPHA?
	 CAILE	T3,'Z'			;..
	  JRST	NAM.2			;NO--SKIP OUT
	LSHC	T1,6			;YES--SHIFT TO NEXT CHAR
	JUMPN	T1,NAM.1		;CHECK AGAIN IF NONZERO
	POPJ	P,			;FAILED
NAM.2:	LSHC	T1,6			;SHIFT OFF THE SPACE
	JUMPN	T1,NAM.3		;MASK AGAIN IF NONZERO
	POPJ	P,			;ELSE FAIL
	SUBTTL	Checking routines -- LINE NODE

LC$LOC:	MOVEI	T2,(I)
	HRLI	T2,-4
LOC.1:	MOVE	T3,.FZLOC##(T2)
	XOR	T3,(T1)
	TDNE	T3,.FZLMC##(T2)
	 POPJ	P,
	ADDI	T1,1
	AOBJN	T2,LOC.1
	JRST	.POPJ1##
	SUBTTL	Checking routines -- NODE MODE

	SUBTTL	Checking routines -- Common tests

LC$LQP:!			;LOGIN QUEUE
JC$DDT:!			;DDT
JC$PFH:!			;PFH

CK$VAL:	CAIN	P1,0		;SEE IF /NOVALUE
	 JUMPE	T1,.POPJ1##	;YES--RETURN IF NOT VALUE
	CAIE	P1,0		;SEE IF /VALUE
	 JUMPN	T1,.POPJ1##	;YES--RETURN IF VALUE
	POPJ	P,		;ELSE FAIL

JC$APC:!
LC$APC:!
CK$APC:	HRRES	P1		;FIX SIGN
	JUMPL	P1,APC.1	;JUMP IF /NOVALUE
	CAMN	P1,T1		;MATCH?
	 AOS	(P)		;YES--WIN
	POPJ	P,		;NO--RETURN

APC.1:	MOVNS	P1		;MAKE POSITIVE
	CAME	P1,T1		;MATCH?
	 AOS	(P)		;NO--WIN
	POPJ	P,		;YES--RETURN

JC$TTY:!
LC$TTY:	HLRZ	T2,P1		;GET LH
	CAIN	T2,1		;SPECIAL NOxxx FORM?
	 JRST	TTY.1		;YES
	XOR	T1,.FZTTY##(I)	;MASK OFF
	TDNE	T1,.FZTTM##(I)	;CHECK
	 POPJ	P,		;FAILED
	JRST	.POPJ1##	;GOOD!

TTY.1:	MOVSS	P1		;SWITCH HALVES
	XOR	T1,P1		;CHECK LH
	TLNN	T1,-1		;LH MATCH?
	 POPJ	P,		;MATCH--LOSE SINCE /NOxxx
	JRST	.POPJ1##	;NO MATCH--WIN
	SUBTTL	General checking -- CHKSTR - See if legal file structure

CHKSTR::MOVE	T1,.FZMOU##(I)		;GET STR NAME
	CAMN	T1,[-1]			;SEE IF GIVEN
	  POPJ	P,			;NO--RETURN
	PUSHJ	P,STRNFS##		;TRY TO CONVERT TO A FS NUMBER
	  $WARN (DNF,<Device not a file structure >,E.DNF,.POPJ##)
	SKIPN	S.PRINT##		;/NOPRINT
	  POPJ	P,			;YES--NO MOUNT COUNT MESSAGES
	MOVE	T1,.FZMOU##(I)		;RELOAD STR NAME
	PUSHJ	P,STRMNC##		;GET THE MOUNT COUNTS
	PJRST	PRTSTR			;PRINT STRUCTURE INFO AND RETURN

E.DNF:	MOVE	T1,.FZMOU##(I)		;GET NAME
	PJRST	.TSIXN##		;TYPE AND RETURN
; Here to print structure info
PRTSTR:	PUSHJ	P,.SAVE2##		;SAVE P1 AND P2
	DMOVE	P1,T1			;SAVE STRMNC FLAGS AND COUNTS
	MOVE	T1,.FZMOU##(I)		;GET STR NAME
	PUSHJ	P,.TDEVN##		;TYPE IT
	LOAD	T2,P1,MC.TMC		;GET TOTAL MOUNT COUNT
	MOVEI	T1,[ASCIZ/ Mount count /]
	SKIPN	T2			;NON-ZERO?
	MOVEI	T1,[ASCIZ | Mount count 0|]
	PUSHJ	P,.TSTRG##		;TYPE
	SKIPN	T1,T2			;GET COUNT
	JRST	PSTR.7			;DONE IF ZERO
	PUSHJ	P,.TDECW##		;TYPE
	MOVEI	T1,[ASCIZ | = |]	;SEPARATE
	PUSHJ	P,.TSTRG##		; FROM WHAT'S TO FOLLOW
	TRZ	F,FR.COMMA		;MIGHT NEED A PLUS LATER

; Type active S/L count
	LOAD	T1,P2,MC.ACT		;GET ACTIVE S/L COUNT
	JUMPE	T1,PSTR.1		;ZERO?
	PUSHJ	P,.TDECW##		;TYPE IT
	MOVEI	T1,[ASCIZ | active|]
	PUSHJ	P,.TSTRG##
	TRO	F,FR.COMMA		;MIGHT NEED A PLUS LATER

PSTR.1:	LOAD	T2,P2,MC.PAS		;GET PASSIVE S/L COUNT
	JUMPE	T2,PSTR.2		;ZERO?
	MOVEI	T1,[ASCIZ | + |]	;GET SEPARATOR
	TROE	F,FR.COMMA		;NEED A PLUS?
	PUSHJ	P,.TSTRG##		;YES
	MOVE	T1,T2			;GET COUNT
	PUSHJ	P,.TDECW##		;TYPE IT
	MOVEI	T1,[ASCIZ | passive|]
	PUSHJ	P,.TSTRG##

PSTR.2:	TXNN	P1,MC.SYS		;IN SYSTEM S/L?
	JRST	PSTR.3			;NO
	MOVEI	T1,[ASCIZ | + |]	;GET SEPARATOR
	TROE	F,FR.COMMA		;NEED A PLUS?
	PUSHJ	P,.TSTRG##		;YES
	MOVEI	T1,[ASCIZ |SSL|]
	PUSHJ	P,.TSTRG##

PSTR.3:	TXNN	P1,MC.ASL!MC.SDL	;ANY OTHER BITS ON?
	JRST	PSTR.7			;NOPE
	MOVEI	T1,[ASCIZ |; also|]	;MORE TO FOLLOW
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	TRZ	F,FR.COMMA		;NO COMMA NOW
	TXNN	P1,MC.ASL		;IN ACTIVE SWAPPING LIST?
	JRST	PSTR.6			;NO
	MOVEI	T1,[ASCIZ | unit(s) in ASL|]
	PUSHJ	P,.TSTRG##

PSTR.6:	TXNN	P1,MC.SDL		;IN SYSTEM DUMP LIST
	JRST	PSTR.7			;NO
	TROE	F,FR.COMMA		;NEED A COMMA?
	PUSHJ	P,.TCOMA##		;YES
	MOVEI	T1,[ASCIZ | in SDL|]
	PUSHJ	P,.TSTRG##

PSTR.7:	PJRST	.TCRLF##		;NEW LINE AND RETURN
	SUBTTL	General checking -- CHKNOD - See if node online

CHKNOD::MOVE	T1,.FZNNM##(I)		;GET NODE NAME
	CAIE	M,M%NODE##		;IF NOT NODE MODE
	 CAMN	T1,[-1]			;SEE IF GIVEN
	  POPJ	P,			;NO--RETURN
	SETCM	T2,.FZNOM##(I)		;GET MASK
	JUMPN	T2,.POPJ##		;RETURN IF WILDCARDS
	TLNN	F,(FL.NETWORKS)		;HAVE NETWORKS?
	  $WARN	(NNS,<No network support in this monitor>)
	PUSHJ	P,NODINF##		;DO WE KNOW ABOUT THIS ONE?
	  SKIPA				;NO
	JRST	CHKN.1			;ONWARD
	$WARN	(NSN,<No such node ">,E.NSN)
	POPJ	P,			;RETURN

CHKN.1:	TXNN	T3,NT.ONL		;IS IT REALLY ONLINE (DECNET)?
	$WARN	(NNO,<Node not online ">,E.NSN)
	POPJ	P,			;RETURN

E.NSN:	MOVE	T1,.FZNNM##(I)		;GET NODE NAME
	PUSHJ	P,.TSIXN##		;TYPE IT
	MOVEI	T1,""""			;CLOSING QUOTE
	PJRST	.TCHAR##		;TYPE IT AND RETURN
	SUBTTL	General checking -- CHKDEV - See if device given (single job)

CHKDEV::MOVE	T1,.FZDEV##(I)		;GET /DEVICE:XXX
	CAMN	T1,[-1]			;SEE IF GIVEN
	 POPJ	P,			;NO--RETURN
	DEVTYP	T1,			;GETS ITS INFO
	  MOVEI	T1,0			;FAILED
	CAIN	T1,0			;SEE IF ZERO
	  $WARN (NSD,<No such device >,E.NSD,DEVBAD)
	TXNE	T1,TY.SPL		;SEE IF SPOOLED
	  $WARN (DSD,<Device is a spooled device >,E.NSD,DEVBAD)
	LOAD	O,T1,TY.JOB		;GET JOB NUMBER
	MOVEM	O,.FZJOB##(I)		;STORE AS THIS JOB
	JUMPE	O,DEVFRE		;LOOKS FREE
	MOVEI	T1,[ASCIZ/Device /]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,E.NSD
	PUSHJ	P,.TSPAC##
	MOVE	T4,.FZDEV##(I)
	DVCHR.	T4,
	MOVEI	T1,[ASCIZ/assigned/]
	TXNE	T4,DV.ASC
	  PUSHJ	P,.TSTRG##
	MOVEI	T1,[ASCIZ/ and /]
	TXC	T4,DV.ASC!DV.ASP
	TXCN	T4,DV.ASC!DV.ASP
	  PUSHJ	P,.TSTRG##
	MOVEI	T1,[ASCIZ/inited/]
	TXNE	T4,DV.ASP
	  PUSHJ	P,.TSTRG##
	MOVEI	T1,[ASCIZ/ by/]
	PUSHJ	P,.TSTRG##
	PJRST	.TCRLF##

E.NSD:	MOVE	T1,.FZDEV##(I)
	PJRST	.TSIXN##

DEVFRE:	MOVE	T2,.FZDEV##(I)
	DVCHR.	T2,
	TXNE	T2,DV.ASC!DV.ASP
	 $WARN	(DID,<Device is detached >,E.NSD,DEVBAD)
	TXNE	T1,TY.RAS
	  $WARN (DRD,<Device is a restricted device >,E.NSD,DEVBAD)
	MOVEI	T1,[ASCIZ/Device is free /]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,E.NSD
	PJRST	.TCRLF##
DEVBAD:	SETZM	.FZJOB##(I)		;INSURE NO MATCH
	POPJ	P,			;AND RETURN
	SUBTTL	General checking -- CHKLOG - See if logged out and legal

CHKLOG::TLNE	F,(FL.LOGIN)		;AM I LOGGED IN?
	  POPJ	P,			;YES
IFN FTSERV,<
	TLNE	F,(FL.WHOSRV)		;ARE WE A SERVER?
	JRST	CHKLG1			;YES--THE LOG FILE BELONGS TO WHOSRV
>
	SKIPE	O.SPEC##+.FXDEV		;OUTPUT SPEC?
	 $FATAL (LPT,<Login please to use output file specification>)
CHKLG1:	SKIPLE	S.DPY##			;SEE IF /DPY
	 $FATAL	(LPD,<Login please to use switch DPY>)
	SKIPLE	S.REPEAT##		;SEE IF /REPEAT
	 $FATAL	(LPR,<Login please to use switch REPEAT>)
	SKIPLE	S.CACHE##		;SEE IF /CACHE
	 $FATAL (LPC,<Login please to use switch CACHE>)
IFN FTSERV,<
	SKIPN	SRVLGO##		;OK TO USE /SERVE LOGGED OUT?
	TLNE	F,(FL.WHOSRV)		;ARE WE A SERVER?
	SKIPA	T1,[EXP -1]		;YES--WE ALWAYS IGNORE /SERVER
	MOVE	T1,S.SERVER##+.SVFLG	;SEE IF /SERVER
	CAME	T1,[EXP -1]		;REQUESTING REMOTE SERVER SERVICE?
	 $FATAL (LPS,<Login please to use switch SERVER>)
> ;END IFN FTSERV
	POPJ	P,			;AND RETURN
	SUBTTL	Storage

	$LOW

GOBBLK:	BLOCK	3
DSKBLK:	BLOCK	.DCSMT+1
	END
