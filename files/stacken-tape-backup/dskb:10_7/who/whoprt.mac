	TITLE	WHOPRT -- PRINT ROUTINES FOR WHO

	SEARCH	WHOMAC

	$SETUP	(WHOPRT)

Comment |

This module contains some of the small mode specific routines for
summary and performance, and the general formatted output routines
that use the database build by the users /FORMAT switch, or defaulted
by one of the switches /VFAST, /FAST, /NORMAL, /SLOW.

|
;               TABLE OF CONTENTS FOR WHOPRT
;
;
;                        SECTION                                   PAGE
;    1. Printing routines
;         1.1   PRTMOD - Print a formated line....................   3
;    2. Print routines
;         2.1   INFACT - Print the account string.................   4
;         2.2   INFIPC - Print IPCF information...................   4
;         2.3   INFBAT - Print batch/galaxy information...........   4
;         2.4   INFDEF - Print defaults information...............   4
;         2.5   INFTIM - Print Login/Reset time information.......   4
;         2.6   INFCOR - Print core limits........................   4
;         2.7   INFSPL - Print spool information..................   5
;         2.8   INFCAP - Print the capabilities...................   6
;         2.9   INFPRV - Print the privileges.....................   6
;         2.10  PRTPRV - Print the privileges.....................   7
;         2.11  INFWSC - Print the wait state code................   8
;         2.12  INFTTY - Print TTY parameters.....................  10
;    3. TABLES....................................................  11
;    4. Printing routines
;         4.1   Character handling and justification..............  14
;    5. Performance routines
;         5.1   JOBPRF - Print JOB mode performance statistics....  15
;         5.2   LINPRF - Print LINE mode performance statistics...  16
;         5.3   NODPRF - Print NODE mode performance statistics...  17
;         5.4   USRPRF - Print USER mode performance statistics...  18
;         5.5   TNN - Type a fractional number....................  19
;    6. END.......................................................  20
	SUBTTL	Printing routines -- PRTMOD - Print a formated line

PRTMOD::PUSHJ	P,DOACTION##		;PROCESS ACTIONS
	TLNE	F,(FL.LOGIN!FL.WHOSRV)	;WE LOGGED IN OR A SERVER?
	JRST	PRTM.1			;YES
	MOVNI	T1,1			;-1 FOR OUR TERMINAL
	PUSHJ	P,UTRMNO##		;GET OUR LINE NUMBER
	  SETZM	S.PRINT##		;NO TYPEOUT IF DETACHED
PRTM.1:	SKIPN	S.PRINT##		;SEE IF /PRINT:NO
	  POPJ	P,			;YES--RETURN
	AOSN	TTLFLG			;NEED A TITLE?
	PUSHJ	P,PRTTTL		;YES
	MOVE	T1,.FZPFM##(I)		;POINT TO STANDARD FORMAT ARGS
	PUSHJ	P,PRTFMT		;PRINT THE FORMATED INFO
	SKIPLE	.FZPRF##(I)		;SEE IF WANTED PERFORMANCE INFO
	 PUSHJ	P,@PRFXXX##(M)		;DISPATCH FOR /PERFORMANCE
	PUSHJ	P,.SAVE2##		;SAVE P2
	SKIPE	P1,.FZINF##(I)		;GET /INFORMATION
	 SKIPL	P2,INFXXX(M)		;SEE IF /INFORMATION ROUTINES
	  POPJ	P,			;NO
PRTM.2:	TDNE	P1,(P2)			;THIS KEYWORD GIVEN?
	 PUSHJ	P,@1(P2)		;YES--DISPATCH
	AOBJN	P2,.+1			;ADVANCE
	AOBJN	P2,PRTM.2		;LOOP FOR ALL
	PJRST	.TCRLF##		;CRLF AND RETURN

DEFINE INFJOB,<
	X	NAM,NAME
	X	ACT,ACCOUNT
	X	TMP,TMPCOR
	X	PRV,PRIVILEGE
	X	CAP,CAPABILITY
	X	SPL,SPOOL
	X	WCH,WATCH
	X	IPC,IPCF
	X	BAT,BATCH
	X	DEF,DEFAULT
	X	ORG,ORIGIN
	X	PTH,PATH	
	X	JSL,JSL
	X	LNM,LOGICAL
	X	TIM,TIME
	X	COR,CORE
	X	WSC,<WSCODE,STATE>
	X	CHN,CHANNEL
	X	DDB,<DDB,SIZE,MTA>
>

DEFINE INFLIN,<
	X	TTY,TTY
>

DEFINE INFNOD,<
>

DEFINE	INFSTR,<
>

DEFINE	INFUNI,<
>

;Generate dispatch macro
DEFINE	X(DSP,KEY),<
	GLOB	INF'DSP
	KEYS==0
	IRP KEY,<
		KEYS==KEYS!IFM'KEY##
	>;END IRP KEY
	EXP	KEYS,INF'DSP
>;END DEFINE X

;Generate tables for each mode
DEFINE XX(MOD,ABR,MAP,TXT,ERR),<
	T'ABR'I: INF'ABR
	L'ABR'I==.-T'ABR'I
>;END DEFINE XX

	MODES

;Generate pointers to each table
DEFINE XX(MOD,ABR,MAP,TXT,ERR),<XWD -L'ABR'I,T'ABR'I>

INFXXX:	MODES
	SUBTTL	Printing routines -- PRTTTL - Print a title


PRTTTL:	SKPYES	S.TITLES##		;WANT TITLES?
	POPJ	P,			;NO
	MOVE	T1,TTLTAB##(M)		;GET TABLE ADDRESS FOR THIS MODE
	SKIPG	T2,.FZFMT##(I)		;GET FORMAT TYPE (FAST, SLOW, ETC.)
	MOVEI	T2,%NORMAL##		;DEFAULT TO NORMAL
	TLNE	T2,777777		;WORD COUNT PRESENT?
	POPJ	P,			;YES--THEN /FORMAT SPECIFIED
	ADDI	T1,-1(T2)		;INDEX INTO MODE SPECIFIC TABLE
	MOVE	T1,@0(T1)		;GET ADDRESS OF TITLE TEXT
	PUSHJ	P,.TSTRG##		;TYPE IT
	PJRST	.TCRLF##		;END LINE AND RETURN
	SUBTTL	Print routines -- INFACT - Print the account string

INFACT:	MOVE	T1,[LACTNORMAL##,,FACTNORMAL##]
	PJRST	PRTFMT			;NO

	SUBTTL	Print routines -- INFIPC - Print IPCF information

INFIPC:	MOVE	T1,[LIPCFNORMAL##,,FIPCFNORMAL##];GET ADDRESS OF FORMAT
	PJRST	PRTFMT


	SUBTTL	Print routines -- INFBAT - Print batch/galaxy information

INFBAT:	MOVE	T1,[LBATNORMAL##,,FBATNORMAL##];GET ADDRESS OF FORMAT
	PJRST	PRTFMT


	SUBTTL	Print routines -- INFDEF - Print defaults information

INFDEF:	MOVE	T1,[LDEFNORMAL##,,FDEFNORMAL##]
	PJRST	PRTFMT


	SUBTTL	Print routines -- INFTIM - Print Login/Reset time information

INFTIM:	MOVE	T1,[LTIMNORMAL##,,FTIMNORMAL##]
	PJRST	PRTFMT


	SUBTTL	Print routines -- INFCOR - Print core limits

INFCOR:	MOVE	T1,[LCORNORMAL##,,FCORNORMAL##]
	PJRST	PRTFMT
	SUBTTL	Print routines -- INFSPL - Print spool information

INFSPL:	PUSHJ	P,.SAVE2##		;SAVE P2
	PUSHJ	P,JB$SPL##		;GET SPOOL WORD
	MOVE	P1,T1			;SAVE
	MOVEI	T1,5			;SPACE OVER
	PUSHJ	P,.TSPAN##		;..
	TXNE	P1,JS.DFR		;DEFERED?
	 SKIPA	T1,[[ASCIZ/Defered spooling: /]];YES
	  MOVEI	T1,[ASCIZ/Spooling: /]	;NO
	PUSHJ	P,.TSTRG##		;TYPE
	TXNN	P1,JS.PAL		;ANY DEVICES?
	 JRST	PRTS.4			;NO
	MOVSI	P2,-SPLLEN		;LENGTH OF TABLE
	TRZ	F,FR.COMMA		;CLEAR FLAG
PRTS.1:	TDNN	P1,SPLBIT(P2)		;SPOOLED?
	 JRST	PRTS.2			;NO
	MOVEI	T1,[ASCIZ/, /]		;DELIMITER
	TROE	F,FR.COMMA		;FLAG/TEST COMMA NEEDED
	 PUSHJ	P,.TSTRG##		;YES
	MOVE	T1,SPLDEV(P2)		;YES--GET DEVICE
	PUSHJ	P,.TDEVN##		;TYPE
	MOVE	T1,SPLDEV(P2)		;GET DEVICE
	CAME	T1,[SIXBIT/CDR/]	;CDR?
	 JRST	PRTS.2			;NO
	HLLZ	T1,P1			;YES--GET NAME
	PUSHJ	P,.TSIXN##		;TYPE CDR NAME
PRTS.2:	AOBJN	P2,PRTS.1		;LOOP FOR ALL
	JRST	PRTS.3			;AND CHECK UNSPOOLING

PRTS.4:	$TYPE	<none>			;NOTHING SPOOLED
PRTS.3:	PUSHJ	P,JB$PRV##		;GET PRIVS
	TXNN	T1,JP.NSP		;UNSPOOLING?
	 PJRST	.TCRLF##		;NO
	$TYPEL	< (unspooling allowed)>
	POPJ	P,			;AND RETURN

DEFINE SPOOLS,<
	XLIST
	X	CDR,JS.PCR
	X	CDP,JS.PCP
	X	PTP,JS.PPT
	X	PLT,JS.PPL
	X	LPT,JS.PLP
	LIST
>;END DEFINE SPOOLS

ALLSPL==0

DEFINE X(DEV,BIT),<
	ALLSPL==ALLSPL!BIT
	EXP	BIT
>;END DEFINE X

SPLBIT:	SPOOLS
SPLLEN==.-SPLBIT
IFN JS.PAL-ALLSPL,<PRINTX ? SPOOL table missing some device definitions>

DEFINE X(DEV,BIT),<EXP SIXBIT/DEV/>

SPLDEV:	SPOOLS
	SUBTTL	Print routines -- INFGOP - Print GALAXY operator information

INFGOP:	PUSHJ	P,JB$GOP##		;GET OPERATOR CODE
	PUSH	P,T1			;SAVE CODE
	MOVEI	T1,5			;SPACE OVER
	PUSHJ	P,.TSPAN##		;..
	$TYPE	<GALAXY operator:>
	POP	P,T1			;RESTORE CODE
	PUSHJ	P,TGOP##		;TYPE GALAXY OPERATOR TEXT
	PJRST	.TCRLF##		;TYPE A CRLF AND RETURN
	SUBTTL	Print routines -- INFWCH - Print watch information

INFWCH:	PUSHJ	P,.SAVE2##		;SAVE P2
	PUSHJ	P,JB$WCH##		;GET WATCH BITS
	MOVE	P1,T1			;SAVE
	MOVEI	T1,5			;SPACE OVER
	PUSHJ	P,.TSPAN##		;..
	$TYPE	<Watch:>
	TXNN	P1,JW.WAL		;ANY WATCH BITS
	 JRST	PRTW.4			;NO
	MOVSI	P2,-WCHLEN		;LENGTH OF TABLE
PRTW.1:	TDNN	P1,WCHBIT(P2)		;WATCH?
	 JRST	PRTW.2			;NO
	PUSHJ	P,.TSPAC##		;SPACE
	MOVE	T1,WCHTXT(P2)		;GET TEXT
	PUSHJ	P,.TSTRG##		;TYPE WATCH NAME
PRTW.2:	AOBJN	P2,PRTW.1		;LOOP FOR ALL
	JRST	PRTW.3			;AND PRINT MESSAGE SETTING

PRTW.4:	$TYPE	< none>			;NOTHING WatchED
PRTW.3:	$TYPE	<  Message:>
	TXNN	P1,JW.WMS		;ANY MESSAGE BITS?
	 JRST	PRTW.7			;NO
	MOVSI	P2,-MSGLEN		;LENGTH OF TABLE
PRTW.5:	TDNN	P1,MSGBIT(P2)		;MESSAGE?
	 JRST	PRTW.6			;NO
	PUSHJ	P,.TSPAC##		;SPACE
	MOVE	T1,MSGTXT(P2)		;GET TEXT
	PUSHJ	P,.TSTRG##		;TYPE MESSAGE NAME
PRTW.6:	AOBJN	P2,PRTW.5		;LOOP FOR ALL
	PJRST	.TCRLF##		;CRLF AND RETURN

PRTW.7:	$TYPEL	< default>
	POPJ	P,

DEFINE WATCHS,<
	XLIST
	X	CONTEXTS,JW.WCX
	X	DAY,JW.WDY
	X	RUN,JW.WRN
	X	WAIT,JW.WWT
	X	READS,JW.WDR
	X	WRITES,JW.WDW
	X	VERSION,JW.WVR
	X	MTA,JW.WMT
	X	FILE,JW.WFI
	LIST
>;END DEFINE WATCHS

ALLWCH==0

DEFINE X(TXT,BIT),<
	ALLWCH==ALLWCH!BIT
	EXP	BIT
>;END DEFINE X

WCHBIT:	WATCHS
WCHLEN==.-WCHBIT
IFN JW.WAL-ALLWCH,<PRINTX ? WATCH table missing some bit definitions>

DEFINE X(TXT,BIT),<EXP [ASCIZ/TXT/]>

WCHTXT:	WATCHS

DEFINE MESSAGES,<
	X	PREFIX,JW.WPR
	X	FIRST,JW.WFL
	X	CONTINUATION,JW.WCN
>

DEFINE X(TXT,BIT),<EXP BIT>

MSGBIT:	MESSAGES
MSGLEN==.-MSGBIT

DEFINE X(TXT,BIT),<EXP [ASCIZ/TXT/]>

MSGTXT:	MESSAGES
	SUBTTL	Print routines -- INFCAP - Print the capabilities

INFCAP:	PUSHJ	P,JB$CAP##		;GET CAPABILITIES
	MOVEI	T2,[ASCIZ/     Capabilities:/]	;LOAD HEADER TEXT
	PJRST	PRTPRV			;AND PRINT THEM



	SUBTTL	Print routines -- INFPRV - Print the privileges

INFPRV:	PUSHJ	P,JB$PRV##		;GET PRIV WORD
	MOVEI	T2,[ASCIZ/     Privileges:/]	;LOAD HEADER TEXT
	PJRST	PRTPRV			;PRINT THEM
	SUBTTL	Print routines -- PRTPRV - Print the privileges

;Call:
;	T1/ privs
;	T2/ addr of header text

PRTPRV::PUSHJ	P,.SAVE1##		;SAVE P1
	MOVE	P1,T1			;SAVE PRIV
	MOVEI	T1,(T2)			;COPY TEXT
	PUSHJ	P,.TSTRG##		;TYPE IT
	PUSHJ	P,.TSPAC##
	MOVE	T1,P1
	PUSHJ	P,.TXWDW##
	PUSHJ	P,.TCRLF##		;CRLF
	MOVEI	T1,[ASCIZ/      DEC: /]	;HEADER
	MOVE	T2,P1			;BITS
	MOVE	T3,[-DECLEN,,DECTAB]	;POINTER
	PUSHJ	P,PRTBIT		;PRINT THE BITS
IFN FTIPC!FTTUFTS,<
	MOVEI	T1,[ASCIZ/      Local: /];HEADER
	MOVE	T2,P1			;BITS
	MOVE	T3,[-LOCLEN,,LOCTAB]	;POINTER
	PUSHJ	P,PRTBIT		;PRINT THE BITS
>;END IFN FTIPC!FTTUFTS
	POPJ	P,			;AND RETURN

;Subroutine PRTBIT - Print strings for bit names
;Call:
;	T1/ addr of header text
;	T2/ priv bits
;	T3/ AOBJN pointer to table of descriptions

PRTBIT:	PUSHJ	P,.TSTRG##		;TYPE HEADER
	PUSHJ	P,.SAVE2##
	DMOVE	P1,T2			;SAVE WORD, TABLE POINTER
PRTB.L:	TDNN	P1,(P2)			;THIS PRIV ON?
	 JRST	PRTB.E			;NO
	HRRZ	T1,1(P2)		;YES--GET TEXT
	PUSHJ	P,.TSTRG##		;TYPE
	HLRZ	T1,1(P2)		;SEE IF DISPATCH NEEDED
	CAIE	T1,0			;IS IT?
	 PUSHJ	P,(T1)			;YES--DISPATCH
	PUSHJ	P,.TSPAC##		;SPACE OVER
PRTB.E:	ADD	P2,[1,,1]		;ADVANCE TO NEXT SET
	AOBJN	P2,PRTB.L		;LOOP FOR ALL
	PJRST	.TCRLF##		;CRLF AND RETURN


PV$HPQ:	PUSHJ	P,.TCOLN##		;TYPE :
	LOAD	T1,P1,JP.HPQ		;GET HPQ VALUE
	PJRST	.TDECW##		;TYPE AND RETURN

PV$DPR:	PUSHJ	P,.TCOLN##		;TYPE :
	LOAD	T1,P1,JP.DPR		;GET DSKPRI VALUE
	PJRST	.TDECW##		;TYPE AND RETURN
	SUBTTL	Print routines -- INFWSC - Print the wait state code

INFWSC:	MOVEI	T1,5			;SAVE OVER
	PUSHJ	P,.TSPAN##		;...
	MOVEI	T1,[ASCIZ/State: /]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,JB$WSC##		;GET THE CODE
	PUSHJ	P,.SAVE1##		;SAVE
	MOVE	P1,T1			;SAVE CODE
	MOVEI	T1,[ASCIZ/Actively /]
	LDB	T2,[POINT 6,P1,17]	;GET ACTIVELY RUNNING
	CAIN	T2,'*'			;IS IT?
	 PUSHJ	P,.TSTRG##		;YES!
	LDB	T1,[POINT 12,P1,11]	;GET RUN CODE
	PUSHJ	P,STAIDX##		;GET INDEX INTO STATES TABLE
	 SKIPA	T1,[ [ASCIZ/Unknown!!/] ];NOT FOUND
	MOVE	T1,STATXT##(T1)		;GET TEXT
	PUSHJ	P,.TSTRG##		;TYPE
	LDB	T1,[POINT 12,P1,29]	;GET SWAPPED CODE
	JUMPE	T1,INFW.1		;RETURN IF NONE
	PUSHJ	P,STAIDX##		;GET INDEX
	 JRST	INFW.1			;NOT KNOWN!
	PUSH	P,T1			;SAVE T1
	MOVEI	T1,[ASCIZ/, /]		;ADDITIONAL TEXT
	PUSHJ	P,.TSTRG##		;TYPE
	MOVEI	T1,[ASCIZ/Being /]
	LDB	T2,[POINT 6,P1,35]	;GET Being SWAPPING
	CAIN	T2,'*'			;IS IT?
	 PUSHJ	P,.TSTRG##		;YES!
	POP	P,T1			;RESTORE T1
	MOVE	T1,STATXT##(T1)		;GET TEXT
	PUSHJ	P,.TSTRG##		;TYPE
INFW.1:	PJRST	.TCRLF##		;CRLF AND RETURN
;X(BIT,TXT,TYP) is
;	
;	BIT	value of bit
;	TXT	ASCII text to type if BIT is on
;	TYP	+ if dispatch to PV$'TXT to type extra stuff

DEFINE DECS,<
	XLIST
	X	JP.IPC,	IPCF
	X	JP.DPR,	DPR	,+
	X	JP.MET,	METER
	X	JP.POK,	POKE
	X	JP.CCC,	CPU
	X	JP.HPQ,	HPQ	,+
	X	JP.NSP,	USPL
	X	JP.ENQ,	ENQ
	X	JP.RTT,	RTTRP
	X	JP.LCK,	LOCK
	X	JP.TRP,	TRPSET
	X	JP.SPA,	SPY
	X	JP.SPM,	MSPY
	LIST
>

DEFINE X(BIT,TXT,TYP),<
	EXP	BIT
	IFNB <TYP>,<XWD PV$'TXT,[ASCIZ/TXT/]>
	IFB <TYP>,<EXP [ASCIZ/TXT/]>
>;END DEFINE X

DECTAB:	DECS
DECLEN==.-DECTAB


IFN FTIPC,<

DEFINE LOCS,<
	XLIST
	X	JP.NEX,	NETEXAM
	X	JP.CPN,	CHGPPN
    IFN FTMDC,<
	X	JP.MPV, SETP
	X	JP.SPG, PRGRUN
    >
	LIST
>

>;END IFN FTIPC


IFN FTTUFTS,<

DEFINE LOCS,<
	XLIST
	X	JP.NAM,	NAME
	X	JP.CPP,	PPASS
	X	JP.CSP,	SPASS
	X	JP.MAI,	MAIL
	X	JP.SFD,	SFD
	X	JP.COM,	COMBO
	X	JP.MAG,	MAGTPE
	LIST
>

>;END IFN FTTUFTS

IFN FTIPC!FTTUFTS,<

LOCTAB:	LOCS
LOCLEN==.-LOCTAB

>;END IFN FTIPC!FTTUFTS
	SUBTTL	Print routines -- INFNAM - Print name requirements

INFNAM:	CAIE	M,M%JOB##		;JOB MODE?
	POPJ	P,			;NO
	$TYPE	<     User name: >	;DISPLAY TEXT
	PUSHJ	P,JB$NAM##		;GET USER NAME
	PUSH	P,1(T1)			;SAVE WORD 2
	MOVE	T1,0(T1)		;GET FIRST WORD
	PUSHJ	P,.TSIXS##		;TYPE WITH SPACES
	POP	P,T1			;GET WORD 2
	PUSHJ	P,.TSIXS##		;DITTO
	PJRST	.TCRLF##		;FINISH WITH A CRLF
	SUBTTL	Print routines -- INFTTY - Print TTY parameters

INFTTY:	PUSHJ	P,.SAVE4##			;SAVE SOME AC'S
	MOVEI	T1,CHRDIR			;CHAR STICKER
	PUSHJ	P,.TYOCH##			;TELL SCAN
	PUSH	P,T1				;SAVE OLD
	MOVSI	P1,-LN$TRM			;GET LENGTH OF TABLE
	MOVEI	P2,1				;CLEAR COLUMN COUNTER
	MOVEI	T1,^D5
	PUSHJ	P,.TSPAN##
LINP.1:	MOVEI	L,0				;CLEAR COUTNER
	PUSHJ	P,@TRMLOD(P1)			;LOAD THE FIELD
	PUSHJ	P,@TRMPRT(P1)			;PRINT THE FIELD
	MOVEI	T1,^D16				;TAB STOP
	SUB	T1,L				;MINUS WHAT WE DID
	PUSHJ	P,.TSPAN##			;SPACE OVER
	CAIN	P2,^D4				;TIME FOR CRLF?
	 PUSHJ	P,[MOVEI P2,0			;YES--CLEAR COUNTER
		   PUSHJ P,.TCRLF##		;CRLF
		   MOVEI T1,^D5	
		   PJRST .TSPAN##]
	ADDI	P2,1				;ADVANCE COUNTER
	AOBJN	P1,LINP.1			;LOOP FOR ALL FIELDS
	CAIE	P2,0				;JUST DO CRLF?
	 PUSHJ	P,.TCRLF##			;NO--TYPE ONE NOW
	PUSHJ	P,.TCRLF##			;START A NEW LINE
	POP	P,.TOUTZ##			;RESTORE TYPER
	POPJ	P,				;AND RETURN
	SUBTTL	TABLES

DEFINE	TRMS,<
	X	274,<2741>	,TYES
	X	ALT,<Altmode>	,TNO
	X	APL,<APL>	,TYES
	X	ACR,<AutoCRLF>	,TACRLF
	X	BLK,<Blanks>	,TNO
	X	HPS,<Column:>	,TDECW
	X	NFC,<CRLF>	,TNO
	X	DBK,<Debreak>	,TYES
	X	DIS,<Display>	,TYES
	X	LCP,<Echo>	,TECHO
	X	FLC,<Fill:>	,TDECW
	X	FRM,<Form>	,TYES
	X	SND,<Gag>	,TNO
	X	HLF,<HDX>	,TYES
	X	LCT,<LC>	,TNO
	X	PCT,<Lines:>	,TDECW
	X	PAG,<Page>	,TPAGE
	X	RSP,<RCVspeed:>	,TSPEED
	X	RMT,<Remote>	,TYES
	X	RTC,<RTcomp>	,TYES	;;**;
	X	SLV,<Slave>	,TYES
	X	TAB,<Tabs>	,TYES
	X	TAP,<Tape>	,TYES
	X	TDY,<Tidy>	,TYES
	X	TRM,<Type:>	,TSIXN
	X	WID,<Width:>	,TDECW
	X	TSP,<XMTspeed:>	,TSPEED
>

DEFINE X(TRM,TXT,PRT),<EXP LT$'TRM##>

TRMLOD:	TRMS
LN$TRM==.-TRMLOD

DEFINE X(TRM,TXT,PRT),<EXP PRT>

TRMPRT:	TRMS

DEFINE X(TRM,TXT,PRT),<EXP [ASCIZ/TXT/]>

TRMTXT:TRMS
TYES:	JUMPE	T1,NO.1
	JRST	YES.1
TNO:	JUMPN	T1,NO.1
YES.1:	HRRZ	T1,TRMTXT(P1)
	PJRST	.TSTRG##
NO.1:	$TYPE	<No>
	HRRZ	T1,TRMTXT(P1)
	PJRST	.TSTRG##

TDECW:	PUSH	P,T1
	HRRZ	T1,TRMTXT(P1)
	PUSHJ	P,.TSTRG##
	POP	P,T1
	PJRST	.TDECW##

TSIXN:	PUSH	P,T1
	HRRZ	T1,TRMTXT(P1)
	PUSHJ	P,.TSTRG##
	POP	P,T1
	PJRST	.TSIXN##

TECHO:	JUMPN	T1,TNO
	HRRZ	T1,TRMTXT(P1)
	PUSHJ	P,.TSTRG##
	PUSHJ	P,LT$DEM##
	JUMPE	T1,.POPJ##
	$TYPE	<:DEFER>
	POPJ	P,

TSPEED:	PUSH	P,T1
	HRRZ	T1,TRMTXT(P1)
	PUSHJ	P,.TSTRG##
	POP	P,T1
	HRRZ	T1,SPETAB##(T1)
	PJRST	.TDECW##

TPAGE:	JUMPE	T1,TYES
	PUSHJ	P,LT$PSZ##
	JUMPE	T1,TNO
	HRRZ	T1,TRMTXT(P1)
	PUSHJ	P,.TSTRG##
	PUSHJ	P,.TCOLN##
	PUSHJ	P,LT$PSZ##
	PJRST	.TDECW##

TACRLF:	JUMPE	T1,TYES
	PUSH	P,T1
	HRRZ	T1,TRMTXT(P1)
	PUSHJ	P,.TSTRG##
	PUSHJ	P,.TCOLN##
	POP	P,T1
	PJRST	.TDECW##
PRTFMT::PUSHJ	P,.SAVE4##		;SAVE P1-P4
	MOVEI	P2,(T1)			;SAVE ADDRESS
	HLRZ	P3,T1			;SAVE LENGTH

DOARG:	MOVEI	L,0			;AND CLEAR COUNTER THIS FIELD
	TRZ	F,FR.ABORT		;CLEAR ABORTED FLAG
	MOVE	T1,[POINT 7,FMTBUF]	;POINT TO FORMAT BLOCK
	MOVEM	T1,FMTPTR		;STORE
	MOVEI	T1,BUFCHR		;GET CHAR STICKER
	MOVE	T2,.FMFMT(P2)		;GET FORMAT BITS
	TXNE	T2,FM.STR		;A STRING?
	 MOVEI	T1,BUFCNT		;YES--COUNT ALL CHARS
	PUSHJ	P,.TYOCH##		;TELL SCAN
	PUSH	P,T1			;SAVE THE OLD
	XCT	.FMLOD(P2)		;GET VALUE TO TYPEOUT
	LOAD	T2,.FMFMT(P2),FM.PRT	;GET ROUTINE TO PRINT
	PUSHJ	P,(T2)			;CALL IT
	MOVE	P1,S.DFORMAT##		;GET FORMAT TYPE
	MOVE	T1,.FMFMT(P2)		;GET FORMAT BITS
	TXNN	T1,FM.USR		;USER SPECIFY?
	 CAIN	P1,FORDEFAULT##		;OR DEFAULT USED?
	  LOAD	P1,.FMFMT(P2),FM.FMT	;YES--LOAD DEFAULT
	LOAD	T1,.FMFMT(P2),FM.WID	;GET WIDTH
	SUBI	T1,(L)			;MINUS WHAT WE DID
	JUMPLE	T1,DOAR.1		;NO FILL IF NO ROOM
	CAIN	P1,FORFLOAT##		;IF FLOATING
	 JRST	DOAR.1			; NO FILL
	CAIN	P1,FORBLANK##		;IF BLANK
	 JUMPE	L,DOAR.1		; AND NO CHARS YET->NO FILL
	MOVEI	T2,CHRDIR		;COUNT AND OUTPUT
	MOVEM	T2,.TOUTZ##		;TELL SCAN
	LOAD	T2,.FMFMT(P2),FM.JUS	;GET JUSTIFY
	PUSHJ	P,@[.POPJ##		;LEFT
		    JCENTER		;CENTER
		    .TSPAN##](T2)	;RIGHT
DOAR.1:	MOVEI	T1,0			;GET A NULL
	PUSHJ	P,FMTCHR		;END THE STRING
	POP	P,.TOUTZ##		;RESTORE TYPER
	MOVEI	T1,FMTBUF		;POINT TO FORMAT BUFFER
	PUSHJ	P,.TSTRG##		;TYPE STRING
	CAIE	P1,FORFLOAT##		;IF FLOATING
	 CAIN	P1,FORBLANK##		;OR IF BLANK
	  JUMPE	L,DOAR.5		; AND NO CHARS YET->NO FILL
	CAIN	P3,1			;SEE IF LAST ARG
	 JRST	DOAR.5			;YES--NO FILL
	LOAD	T1,.FMFMT(P2),FM.WID	;GET WIDTH AGAIN
	SUBI	T1,(L)			;MINUS WHAT WE DID
	CAIN	P1,FORFLOAT##		;IF FLOATING
	 LOAD	T1,.FMFMT(P2),FM.SPC	; GET SPACES TO SEPARATE
	PUSHJ	P,.TSPAN##		;SPACE OVER
DOAR.5:	ADDI	P2,.FMLEN		;ADVANCE TO NEXT SPEC
	TRNN	F,FR.ABORT		;UNLESS ABORTED
	 SOJG	P3,DOARG		;ADVANCE TO TO ARG
	PJRST	.TCRLF##		;CRLF AND RETURN
	SUBTTL	Printing routines -- Character handling and justification

JCENTER:LSH	T1,-1			;DIVIDE BY 2
	PJRST	.TSPAN##		;ABD SPACE OVER THAT MANY

BUFCNT:	AOJA	L,FMTCHR		;COUNT AND STORE CHAR
BUFCHR:	CAIN	T1," "			;A SPACE?
	  JUMPE	L,.POPJ##		;YES--RETURN IF NOT SIGNIFICANT
	ADDI	L,1			;COUNT CHARS
					;AND FALL INTO FMTCHR

FMTCHR:	IDPB	T1,FMTPTR		;STORE THE CHAR
	POPJ	P,			;AND RETURN

CHRDIR::AOJA	L,CHRLST##		;COUNT AND OUTPUT CHAR
	SUBTTL	Performance routines -- JOBPRF - Print JOB mode statistics

JOBPRF::SKPYES	.FZPRF##(I)		;WANT PERFORMANCE STUFF?
	  POPJ	P,			;NO--RETURN
	PUSHJ	P,.SAVE3##		;SAVE P1-P3
	PUSHJ	P,JB$TIM##		;GET RUNTIME
	MOVE	P1,T1			;INTO P1
	PUSHJ	P,JB$IJL##		;GET LOGGED IN TIME
	MOVE	P2,T1			;INTO P2
	MUL	P2,[^D24*^D60*^D60*^D1000];MAKE MILLSECONDS
	ASHC	P2,^D17			;POSITION
	$TYPE	<     DSK/E:>
	PUSHJ	P,JB$DBR##		;GET DISK READS
	PUSH	P,T1			;SAVE
	PUSHJ	P,JB$DBW##		;GET DISK WRITES
	POP	P,T2			;RESTORE READS
	ADD	T1,T2			;GET TOTAL
	IMULI	T1,^D1000		;CONVERT TO DISK-BLOCKS/MILLISECOND
	PUSH	P,T1			;SAVE A MOMENT
	MOVE	T2,P2			;GET ELAPSED TIME
	PUSHJ	P,TNN			;TYPE
	$TYPE	<  DSK/C:>
	POP	P,T1			;GET TOTAL READS+WRITES
	MOVE	T2,P1			;GET CPU TIME
	PUSHJ	P,TNN			;TYPE
	$TYPE	<  UUOS/E:>
	PUSHJ	P,JB$UUC##		;GET UUOS
	IMULI	T1,^D1000		;CONVERT TO UUOS/MILLISECOND
	MOVE	T2,P2			;GET ELAPSED TIME
	PUSHJ	P,TNN			;TYPE
	$TYPE	<  UUOS/C:>
	PUSHJ	P,JB$UUC##		;GET UUOS
	IMULI	T1,^D1000		;CONVERT TO UUOS/MILLISECOND
	MOVE	T2,P1			;GET CPU TIME
	PUSHJ	P,TNN			;TYPE
	$TYPE	<  CPU/E:>
	MOVE	T1,P1			;GET CPU TIME
	IMULI	T1,^D100		;HUNDREDS FOR PERCENT
	MOVE	T2,P2			;GET ELAPSED TIME
	PUSHJ	P,TNN
	$TYPEL	<%>
	POPJ	P,

	SUBTTL	Performance routines -- LINPRF - Print LINE mode statistics

LINPRF::SKPYES	.FZPRF##(I)		;SEE IF /PERF
	 POPJ	P,			;NO
	PUSHJ	P,.SAVE3##		;SAVE P1-P3
	PUSHJ	P,XB$UPT##		;GET UPTIME
	MOVE	P1,T1			;POSITION
	IDIVI	P1,^D1000		;MAKE SECONDS
	MOVE	P2,P1			;GET SECONDS
	IDIVI	P2,^D60			;MAKE MINUTES
	$TYPE	<     O/I:>		;GET TEXT
	PUSHJ	P,LB$ICT##		;GET INPUT CHAR COUNT
	PUSH	P,T1			;SAVE
	PUSHJ	P,LB$OCT##		;GET OUTPUT CHAR COUNT
	POP	P,T2			;RESTORE SCALED INPUT COUNT
	PUSHJ	P,TNN			;TYPE
	$TYPE	<  OCC/E:>		;GET TEXT
	PUSHJ	P,LB$OCT##
	MOVE	T2,P1
	PUSHJ	P,TNN
	$TYPE	<  ICC/E:>
	PUSHJ	P,LB$ICT##
	MOVE	T2,P1
	PUSHJ	P,TNN
	$TYPE	<  CMD/EM:>
	PUSHJ	P,LB$CMD##
	MOVE	T2,P2
	PUSHJ	P,TNN
	$TYPE	<  BRK/EM:>
	PUSHJ	P,LB$BCC##
	MOVE	T2,P2
	PUSHJ	P,TNN
	PJRST	.TCRLF##
	SUBTTL	Performance routines -- NODPRF - Print NODE mode statistics

NODPRF::POPJ	P,			;NONE FOR NOW
	SUBTTL	Performance routines -- STRPRF - Print STRUCTURE mode statistics

STRPRF::POPJ	P,			;NONE FOR NOW
	SUBTTL	Performance routines -- UNIPRF - Print UNIT mode statistics

UNIPRF::PUSHJ	P,.SAVE2		;SAVE SOME ACS
	$TYPE	<     Cached:>
	PUSHJ	P,UB$CBK##		;GET BLOCKS CACHED
	MOVE	P1,T1			;SAVE
	LSH	T1,7			;CONVERT TO WORDS
	PUSHJ	P,.TBLOK##		;TYPE AS NNNB
	JUMPE	P1,.TCRLF##		;DONE IF NO BLOCKS CACHED

UNIPR1:	PUSHJ	P,UB$CRH##		;GET CACHED READ HITS
	MOVE	P1,T1			;SAVE
	PUSHJ	P,UB$CRC##		;GET CACHED READ CALLS
	SKIPN	P2,T1			;SAVE
	JRST	UNIPR2			;THERE ARE NONE
	$TYPE	<   Rd H/C:>
	MOVE	T1,P1			;GET READ HITS
	PUSHJ	P,.TDECW##		;TYPE NUMBER
	MOVEI	T1,"/"			;TYPE
	PUSHJ	P,.TCHAR##		; SEPARATOR
	MOVE	T1,P2			;GET READ CALLS
	PUSHJ	P,.TDECW##		;TYPE NUMBER
	MOVEI	T1,"="			;TYPE
	PUSHJ	P,.TCHAR##		; SEPARATOR
	DMOVE	T1,P1			;GET ARGS
	IMULI	T1,^D100		;SCALE
	PUSHJ	P,TNN			;TYPE FRACTION
	MOVEI	T1,"%"			;GET TERMINATOR
	PUSHJ	P,.TCHAR##		;TYPE IT

UNIPR2:	PUSHJ	P,UB$CWH##		;GET CACHED WRITE HITS
	MOVE	P1,T1			;SAVE
	PUSHJ	P,UB$CWC##		;GET CACHED WRITE CALLS
	SKIPN	P2,T1			;SAVE
	PJRST	.TCRLF##		;THERE ARE NONE
	$TYPE	<   Wt H/C:>
	MOVE	T1,P1			;GET WRITE HITS
	PUSHJ	P,.TDECW##		;TYPE NUMBER
	MOVEI	T1,"/"			;TYPE
	PUSHJ	P,.TCHAR##		; SEPARATOR
	MOVE	T1,P2			;GET WRITE CALLS
	PUSHJ	P,.TDECW##		;TYPE NUMBER
	MOVEI	T1,"="			;TYPE
	PUSHJ	P,.TCHAR##		; SEPARATOR
	DMOVE	T1,P1			;GET ARGS
	IMULI	T1,^D100		;SCALE
	PUSHJ	P,TNN			;TYPE FRACTION
	MOVEI	T1,"%"			;GET FINAL TERMINATOR
	PUSHJ	P,.TCHAR##		;TYPE IT
	PJRST	.TCRLF##		;RETURN
	SUBTTL	Performance routines -- TNN - Type a fractional number
;CALL:
;	T1=NUMERATOR
;	T2=DENOMETER
;	PUSHJ	P,TNN
;types NNN, NN.N or N.NN based on size of number

TNN::	PUSHJ	P,.SAVE3##		;SAVE P3
	MOVE	P3,T2			;SAVE DIVISOR
	IDIV	T1,T2			;DIVIDE
	DMOVE	P1,T1			;SAVE INTEGER PART, REMAINDER
	PUSHJ	P,.TDECW##		;TYPE INTEGER PART
	CAILE	P1,^D99			;NNN form?
	 POPJ	P,			;YES--RETURN
	PUSHJ	P,.TDOT##		;NO--TYPE DECIMAL
	CAILE	P1,^D9			;N.NN form?
	 JRST	TNN.N			;NO--NN.N
	MOVE	T1,P2			;YES--GET REMAINDER BACK
	IMULI	T1,^D100		;SHIFT TO GET HUNDREDTHS DECIMAL
	IDIV	T1,P3			;DIVIDE BY ORIGINAL DIVISOR
	MOVEI	T2,"0"			;ZERO FILL
	PJRST	.TDEC2##		;TYPE NN AND RETURN

TNN.N:	MOVE	T1,P2			;GET REMAINDER BACK
	IMULI	T1,^D10			;SHIFT TO GET TENTHS DECIMAL
	IDIV	T1,P3			;DIVIDE BY ORIGINAL DIVISORT
	PJRST	.TDECW##		;TYPE N AND RETURN
	SUBTTL	END

	$LOW

TTLFLG::BLOCK	1
FMTPTR:	BLOCK	1
FMTBUF:	BLOCK	^D132/5+1

	END
