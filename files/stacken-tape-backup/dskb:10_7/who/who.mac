	TITLE	WHO - Command routine and mainline for WHO

	SEARCH	WHOMAC

	$SETUP	(WHO)

Comment |

This module contains the mainline code and command dispatch for WHO.
A few other general routines are in this module also.

|
DEFINE	ZZ(DEF),<
	XLIST
	IRP DEF,<
		DEFINE	XX(MOD,ABR,MAP,TXT,ERR),<
			GLOB	ABR''DEF
			EXP ABR''DEF
		>;END DEFINE XX
		DEF'XXX::MODES
	>;END IRP
	LIST
>;END DEFINE

	ZZ <SCN,NXT,INC,PRF,SET,MAM>

;XXXSCN is routine to apply mode specific SCAN defaults
;	called with I=scan spec to fix up
;XXXNXT is routine to get next object in O
;	called with O=last thing (-1 to start)
;	skip return with next thing in O, non-skip when done
;XXXINC	is routine to handle computation of incremental statistics
;XXXPRF	is routine to print performance information for the mode
;XXXSET	is routine to verify thing in O is valid
;	skip return if thing good, non-skip if not
;XXXMAM is the routine to handle /MAP (Map Alternate Mode)

	DEFINE	XX(MOD,ABR,MAP,TXT,ERR),<EXP [ASCIZ/TXT/]>

TXTXXX::MODES

	DEFINE	XX(MOD,ABR,MAP,TXT,ERR),<EXP [ASCIZ/ERR/]>

ERRXXX::MODES

	DEFINE	XX(MOD,ABR,MAP,TXT,ERR),<EXP M%'MAP##>

MODXXX:	MODES
;               TABLE OF CONTENTS FOR WHO
;
;
;                        SECTION                                   PAGE
;    1. Initialization............................................   3
;    2. Command processing
;         2.1   Main command loop.................................   4
;         2.2   Process a single command..........................   5
;         2.3   Process all specifications........................   6
;         2.4   Process a single specification....................   7
;         2.5   Process all 'things'..............................   8
;         2.6   Handle /INCREMENTAL...............................   9
;    3. Mapping
;         3.1   Handle /MAP switch................................  10
;         3.2   PRTMAP - Print a mapped line......................  11
;         3.3   LINE to JOB mode..................................  12
;         3.4   JOB to LINE mode..................................  13
;         3.5   NODE to LINE mode.................................  14
;         3.6   USER to ????......................................  15
;    4. Subroutines
;         4.1   DOSWP - Handle /SWAP..............................  16
;         4.2   CCSET - Enable ^C trapping........................  17
;         4.3   CCTRAP - Handle ^C trapping.......................  17
;         4.4   SETME - Setup my profile and privs................  18
;    5. Storage...................................................  19
	SUBTTL	Initialization

WHO::	TDZA	T1,T1			;FLAG NORMAL ENTRY
	  MOVEI	T1,1			;FLAG CCL ENTRY
	MOVEM	T1,OFFSET		;STORE STARTING OFFSET
	RESET				;RESET THE WORLD
	MOVEI	F,0			;CLEAR FLAGS
	SETOM	DIEWRD			;SETUP DIEWRD
	MOVE	P,[IOWD LN$PDL,PDL]	;SETUP STACK
	PUSHJ	P,PSIINI		;INITIALIZE THE PSI SYSTEM
	PUSHJ	P,CCSET			;SETUP ^C BLOCK
	PUSHJ	P,W$INIT##		;INIT WHOGLX AND GLXLIB
	MOVEI	T1,'WHO'		;SET ERROR PREFIX
	PUSHJ	P,.ERXPF##		;TELL ERROR HANDLER
	MOVEI	T1,.FMSGE##		;SET FATAL ERROR ROUTINE
	TXO	T1,ER.FAT!ER.STP	;FLAG FATAL
	PUSHJ	P,.ERXDI##		;TELL ERROR HANDLER
	MOVEI	T1,ERRCHR##		;GET ERROR TYPER
	PUSHJ	P,.ERXAD##		;TELL ERROR ROUTINE
	PUSHJ	P,.TOINI##		;INIT BUFFERED OUTSTR ROUTINE
	PUSHJ	P,MAPDEF##		;SETUP DEFAULT MAP (MONITOR)
	HRRZ	T1,MAPMVR##		;GET MONITOR VERSION
	CAIE	T1,%VER			;CURRENT?
	JRST	OLDWHO			;NO--RUN PREVIOUS VERSION
	PUSHJ	P,SYSSET##		;SETUP SYSTEM VARIABLES
	PUSHJ	P,FETCHK##		;CHECK MONITOR FEATURES
	PUSHJ	P,SETME			;SET MY PROFILE
IFN FTSERV,<PUSHJ P,CHKSRV##>		;DETACH FRCLIN SERVER AND DON'T RETURN
	MOVE	T1,[LN$IBLK##,,ISBLK##]	;POINT TO .ISCAN BLOCK
	PUSHJ	P,.ISCAN##		;INITIALIZE COMMAND SCANNER
	PUSHJ	P,SETMOD		;SET UP AC 'M'
IFN FTSERV,<PUSHJ P,SRVINI##>		;INIT COMMAND BUFFER
	SUBTTL	Command processing -- Main command loop

CMDLOP::MOVE	T1,TBLKX##(M)		;POINT TO .TSCAN BLOCK
	PUSHJ	P,.TSCAN##		;SCAN A COMMAND LINE
	SETOM	DIEWRD			;ALLOW ANOTHER FATAL ERROR
	PUSHJ	P,CLRSTK##		;CLEAR SWITCHES FOR OSCAN
	MOVE	T1,OBLKX##(M)		;POINT TO .OSCAN BLOCK
	TLNE	F,(FL.LOGIN)		;WE LOGGED IN?
	 PUSHJ	P,.OSCAN##		;YES--READ SWITCH.INI
	SKIPN	HEAD$S##		;ANY SCAN SPECS YET?
	  PUSHJ	P,[PUSHJ P,.CLRFL##	;NO--CLEAR FILE AREA
		   PUSHJ P,AIN##	;ALLOCATE A SPEC
		   PJRST .GTSPC##]	;AND FILL IT IN
	PUSHJ	P,VRSKEW##		;CHECK WHO/MONITOR VERSION SKEW
	PUSHJ	P,CHKLOG##		;SEE IF OK IF NOT LOGGED IN
	PUSHJ	P,WHOSCN##		;DO SCAN DEFAULTING
	PUSHJ	P,OUTDEF##		;DO OUTPUT DEFAULTING
	PUSHJ	P,SWTDEF##		;DO SWITCH DEFAULTING
	PUSHJ	P,CHKLST##		;CHECK OUTPUT DEVICE FOR TTY
	PUSHJ	P,DPINI##		;INIT DPY
	PUSHJ	P,DOCMD			;DO THE COMMAND
	PUSHJ	P,CLSLST##		;CLOSE LIST FILE IF NEEDED
	PUSHJ	P,DPXIT##		;FINISH UP IF /DPY
IFN FTSERV,<PUSHJ	P,SRVCMD##>	;RESET COMMAND BUFFER
	JRST	CMDLOP			;AND LOOP
	SUBTTL	Command processing -- Process a single command

DOCMD:	MOVEI	T1,CHRLST##		;POINT TO SCAN'S CHARACTER LISTER
	MOVEM	T1,.TOUTZ##		;STORE
	PUSHJ	P,DPLIN##		;START DPY ON NEW LINES

IFE FTSERV,<TRZ F,FR.TYPE!FR.OPEN>	;NOTHING TYPED YET
IFN FTSERV,<
	TRZ	F,FR.TYPE		;NOTHING TYPED YET
	PUSHJ	P,SRVUSR##		;FIREUP USER HALF OF SERVER IF NEEDED
	  JRST	DOCMD1			;WE DID IT SO SKIP REST OF COMMAND LOOP
> ;END IFN FTSERV

	PUSHJ	P,SYSSET##		;SETUP FOR SYSTEM THINGS
	SKIPE	T1,S.INITAL##		;GET INITIAL FORMAT
	 PUSHJ	P,PRTFMT##		;TYPE IF SPECIFIED
IFN FTLGNQ,<PUSHJ P,LGQINI##>		;INIT LOGINQ STUFF
	PUSHJ	P,DOSWP			;HANDLE /SWAP IF SET
	PUSHJ	P,INETWORK##		;HANDLE /NETWORK:CONNECT IF SET
	PUSHJ	P,DOINC			;HANDLE /INCREMENTAL
	PUSHJ	P,ALLSPC		;PROCESS ALL SPECS
	SKIPE	T1,S.FINAL##		;GET FINAL FORMAT
	 PUSHJ	P,PRTFMT##		;TYPE IF SPECIFIED
	PUSHJ	P,MAPPRF##		;DO MAPPER PERFORMANCE STUFF

DOCMD1:	PUSHJ	P,DPCLR##		;CLEAN UP DPY
	SKIPG	S.REPEAT##		;GET REPEAT TIME
	 POPJ	P,			;NONE
	SKIPG	S.DPY##			;IF NOT DPY
	 TRNN	F,FR.TYPE		;AND SOMETHING TYPED
	  CAIA				;NO
	   PUSHJ P,.TCRLF##		;YES--START NEW LINE
	SOSN	S.REPEAT##+1		;COUNT DOWN TIMES
	 POPJ	P,			;DONE WITH REPEATS
	TRNE	F,FR.MYTTY		;CONTROLLING TERMINAL OPENED?
	TRNN	F,FR.DPY		;AND IN DPY MODE?
	PUSHJ	P,CLSLST##		;NO--CLOSE LIST FILE IF NEEDED
	MOVE	T1,S.REPEAT##		;GET REPEAT COUNT
	PUSHJ	P,DPSLP##		;GO SLEEP
	JRST	DOCMD			;AND REPEAT
	SUBTTL	Command processing -- Process all specifications

ALLSPC:	PUSHJ	P,S$FIRST##		;POSITION TO FIRST SCAN SPEC

SPCLOP:	PUSHJ	P,DOSPEC		;PROCESS THIS SPEC IN 'I'
	MOVE	T1,S.FRST##		;GET FIRST SPEC ADDR
	SKIPE	T1,.FZFOO##(T1)		;/FOOTING?
	 PUSHJ	P,PRTFMT##		;YES--PRINT FORMAT
	PUSHJ	P,S$NEXT##		;GET NEXT SPEC ADDRESS
	 POPJ	P,			;ALL DONE
	MOVE	T1,NMATCH##		;GET NUMBER OF MATCHES
	MOVE	T2,S.FRST##		;GET FIRST SPEC ADDR
	CAILE	T1,1			;JUST ONE
	 SKIPE	.FZFOO##(T2)		;OR /FOOTING
	  JRST	SPCLOP			;YES--JUST LOOP
	PUSHJ	P,.TCRLF##		;NO--CRLF
	JRST	SPCLOP			;AND LOOP
	SUBTTL	Command processing -- Process a single specification

DOSPEC:	PUSHJ	P,SETSPC##		;SETUP CONCATINATED SPEC
	MOVE	I,S.FRST##		;POINT TO FIRST SPEC
	MOVE	T1,[ZERC0##,,ZERC0##+1]	;SET UP BLT
	SETZM	ZERC0##			;CLEAR FIRST WORD
	BLT	T1,ZERC1##		;CLEAR SUMMARY COUNTERS
	PUSHJ	P,I$DEALLOC##		;DEALLOCATE PER SPEC MEMORY
	SKIPE	T1,.FZHEA##(I)		;GET HEADING FORMAT
	 PUSHJ	P,PRTFMT##		;TYPE IF SPECIFIED
	PUSHJ	P,CHKSTR##		;HANDLE /MOUNT:XXX
	PUSHJ	P,CHKNOD##		;HANDLE /NODE:XXX
	PUSHJ	P,CHKDEV##		;HANDLE /DEVICE:XXX
	PUSHJ	P,ALLMOD		;PROCESS ALL 'O's
	SKIPE	NMATCH##		;ANY MATCH?
	   JRST	[PUSHJ P,WHOSUM##	;HANDLE /SUMMARY
		 SKIPG S.TOTALS##	;YES--/TOTALS?
		  POPJ	P,		;NO--RETURN
		 MOVEI T1,[ASCIZ/Total of /];GET TEXT
		 PUSHJ P,.TSTRG##	;TYPE
		 MOVE  T1,NMATCH##	;GET COUNT OF  MATCHES
		 MOVE T2,TXTXXX(M)	;GET TEXT
		 PUSHJ P,.TPLRS##
		 PJRST	.TCRLF##]	;CRLF AND RETURN
	MOVX	T1,FX.NOM		;GET /OK[ER]NONE BIT
	TDNN	T1,.FXMOM(I)		;SWITCH GIVEN?
	  JRST	MODS.1			;NO
	TDNE	T1,.FXMOD(I)		;YES--/OKNONE?
	 POPJ	P,			;YES--NO MESSAGE
	JRST	MODS.E			;NO--/ERNONE

MODS.1:	MOVEI	T1,[ASCIZ/No one
/]					;SIMPLE MESSAGE
	CAIN	M,M%JOB##		;JOB MODE?
	 PJRST	.TSTRG##		;YES--JUST TYPE AND RETURN
MODS.E:	SKIPE	NFOUND##		;ANY STARTED TO MATCH?
	 $FATAL	(ARC,<All >,E.ARC)
	$FATAL	(NTM,<>,E.NTM)		;NO

E.NTM:	MOVE	T1,ERRXXX(M)
	PJRST	.TSTRG##

E.ARC:	MOVE	T1,TXTXXX(M)
	PUSHJ	P,.TSTRG##
	MOVEI	T1,[ASCIZ/s rejected by constraints/]
	PJRST	.TSTRG##
	SUBTTL	Command processing -- Process all 'things'

ALLMOD:	SETO	O,			;INDICATE FIRST THING
	SETOM	TTLFLG##		;INIT TITLE FLAG

MODLOP:	PUSHJ	P,@NXTXXX(M)		;GET NEXT THING
	 POPJ	P,			;ALL DONE
	PUSHJ	P,WHOCHK##		;CHECK USER SWITCHES, ETC
	 JRST	MODLOP			;REJECTED
	PUSHJ	P,WHOSTA##		;COUNT FOR SUMMARY
	PUSHJ	P,PRTMOD##
	PUSHJ	P,DOMAP
	JRST	MODLOP			;AND LOOP
	SUBTTL	Command processing -- Handle /INCREMENTAL

DOINC:	SKIPG	S.INCREMENTAL##		;/INCREMENTAL?
	 POPJ	P,			;NO--JUST RETURN
	PUSHJ	P,@INCXXX(M)		;YES--HANDLE FOR PRIMARY MODE
	PUSHJ	P,S$FIRST##		;SETUP FOR FIRST SCAN SPEC
DOINC1:	SKIPLE	.FZMAP##(I)		;THIS SPEC HAVE /MAP
	 JRST	DOINC2			;YES--JUMP OUT
	PUSHJ	P,S$NEXT##		;GET NEXT SPEC
	 POPJ	P,			;ALL DONE
	JRST	DOINC1			;AND LOOP FOR NEXT

DOINC2:	MOVE	T1,MODXXX(M)		;GET ALTERNATE MODE FOR /MAP
	PJRST	@INCXXX(T1)		;AND HANDLE FOR ALTERNATE MODE
	SUBTTL	Mapping -- Handle /MAP switch

DOMAP:	SKIPG	.FZMAP##(I)		;SEE IF /MAP
	 POPJ	P,			;NO
	PUSH	P,O			;SAVE OLD INDEX
	PUSH	P,M
	PUSH	P,S.PRINT##
	MOVEI	T1,YES
	MOVEM	T1,S.PRINT##
	PUSHJ	P,@MAMXXX(M)		;DISPATCH ON MODE
	POP	P,S.PRINT##
	POP	P,M
	POP	P,O
	PJRST	SETFC##			;RESTORE FORMAT AND RETURN
	SUBTTL	Mapping -- PRTMAP - Print a mapped line

PRTMAP:	PUSHJ	P,SETFM##		;SET FORMAT FOR /MAP MODE
	CAIE	M,M%JOB##		;GOING TO DO JOB MODE?
	 SKIPA	T1,[2]			;NO--TWO SPACES
	  MOVEI	T1,1			;YES--JUST ONE SPACE
	PUSHJ	P,.TSPAN##
	PJRST	PRTMOD##		;PRINT THE INFO AND RETURN
	SUBTTL	Mapping -- LINE to JOB mode

LINMAM:	PUSHJ	P,LB$JOB##		;GET JOB
	SKIPG	O,T1			;SKIP IF JOB AVAILABLE 
	 POPJ	P,			;NONE
	MOVEI	M,M%JOB##		;SET JOB MODE
	PUSHJ	P,JOBSET##		;SETUP FOR JOB
	 POPJ	P,			;NOT ASSIGNED?
	PJRST	PRTMAP			;PRINT THE INFO AND RETURN
	SUBTTL	Mapping -- JOB to LINE mode

JOBMAM:	PUSHJ	P,JB$TLN##		;GET TERMINAL LINE NUMBER
	SKIPGE	O,T1			;SKIP IF NOT DETACHED AND LOAD J
	 POPJ	P,			;DETACHED--SKIP IT
	MOVEI	M,M%LINE##		;SET LINE MODE
	PUSHJ	P,LINSET##		;SETUP FOR LINE
	 POPJ	P,			;NOT CONNECTED?
	PJRST	PRTMAP			;PRINT THE INFO AND RETURN
	SUBTTL	Mapping -- NODE to LINE mode

NODMAM:	PUSHJ	P,.SAVE1##		;SAVE P1
	PUSHJ	P,NB$NNU##		;GET NODE NUMBER
	MOVE	P1,T1			;SAVE IT
	MOVEI	M,M%LINE##		;SET LINE MODE
	SETO	O,			;FIRST LINE
NODMA1:	PUSHJ	P,LINNXT##		;GET NEXT LINE
	 POPJ	P,			;ALL DONE
	PUSHJ	P,LB$NNU##		;GET NODE NUMBER
	CAMN	T1,P1			;MATCH WHAT WE WANT?
	 PUSHJ	P,PRTMAP		;YES--PRINT THE INFO
	JRST	NODMA1			;AND LOOP
	SUBTTL	Mapping -- STRUCTURE to UNIT

STRMAM:	PUSHJ	P,SB$STN##		;GET STR NAME
	PUSHJ	P,STRFUI##		;GET THE UNIT INDEX FOR FIRST UNIT
	  POPJ	P,			;???
	MOVEI	M,M%UNIT##		;SET UNIT MODE
STRMA1:	MOVE	O,T1			;COPY UNIT INDEX
	PUSHJ	P,UNISET##		;SETUP TO PROCESS THIS UNIT
	  POPJ	P,			;SHOULDN'T FAIL
	PUSHJ	P,PRTMAP		;DISPLAY STUFF FOR THIS UNIT
	MOVE	T1,O			;GET INDEX BACK AGAIN
	PUSHJ	P,UNIASI##		;GET ALTERNATE PORT INDEX
	  JRST	STRMA2			;NO DUAL PORTING
	MOVE	O,T1			;COPY UNIT INDEX
	PUSHJ	P,UNISET##		;SETUP TO PROCESS THIS UNIT
	  JRST	STRMA2			;ASSUME CAN'T GET SECOND PORT
	PUSHJ	P,PRTMAP		;DISPLAY STUFF FOR THIS UNIT
STRMA2:	MOVE	T1,O			;GET INDEX BACK AGAIN
	PUSHJ	P,UNINSI##		;GET INDEX FOR NEXT UNIT IN STR
	  POPJ	P,			;END OF CHAIN
	JRST	STRMA1			;LOOP BACK
	SUBTTL	Mapping -- UNIT to STRUCTURE

UNIMAM:	PUSHJ	P,UB$STR##		;GET STR NAME
	PUSHJ	P,STRNFS##		;CONVERT NAME TO FS NUMBER
	  POPJ	P,			;UNIT NOT PART OF A STRUCTURE
	MOVEI	M,M%STRU##		;SET STRUCTURE MODE
	MOVE	O,T1			;COPY FS NUMBER INDEX
	PUSHJ	P,STRSET##		;SETUP TO PROCESS THIS STRUCTURE
	  POPJ	P,			;SHOULDN'T FAIL
	PJRST	PRTMAP			;DISPLAY STUFF FOR THIS STRUCTURE
	SUBTTL	Subroutines -- DOSWP - Handle /SWAP

DOSWP:	PUSHJ	P,S$FIRST##		;POSITION TO FIRST SCAN SPEC
;
;Here to apply job number if /SWAP:(FORCE,FIT,IN,OUT)
;
DOSW.1:	SKIPG	T4,.FZSWP##(I)		;SEE IF /SWAP:
	  JRST	DOSW.2			;NO
	MOVE	T1,[EXP %SWFRC,%SWFIT,%SWFIN,%SWFIN]-1(T4)
	PUSHJ	P,GTAB##		;GET THE JOB NUMBER
	CAIN	T4,SWAPIN##		;SEE IF /SWAP:IN
	 CAIL	T1,0			;YES--SEE IF COMING IN
	  CAIA				;
	   MOVEI T1,0			;NO--CLEAR JOB
	CAIN	T4,SWAPOUT##		;SEE IF /SWAP:OUT
	 CAIG	T1,0			;YES--SEE IF GOING OUT
	  CAIA				;
	   MOVEI T1,0			;NO--CLEAR JOB
	MOVMM	T1,.FZJOB##(I)		;NO--STORE NEW ONE
DOSW.2:	PUSHJ	P,S$NEXT##		;GET NEXT SCAN SPEC
	 POPJ	P,			;ALL DONE
	JRST	DOSW.1			;AND LOOP
	SUBTTL	Subroutines -- PSIINI - PSI initialization


PSIINI:	MOVE	T1,[VECTOR,,VECTOR+1]	;SET UP BLT
	SETZM	VECTOR			;CLEAR FIRST WORD
	BLT	T1,VECTOR+<VECNUM*4>-1	;CLEAR OUT ALL VECTORS
	MOVEI	T1,VECTOR		;POINT TO BASE OF THE PSI VECTORS
	PIINI.	T1,			;INIT THE INTERRUPT SYSTEM
	  $STOP	(CIP,<Can't initialize the PSI system; PIINI. error >,.TOCTW##)
	POPJ	P,			;RETURN
	SUBTTL	Subroutines -- CCSET - Enable ^C trapping

CCSET:	MOVE	T1,[4,,CCTRAP]		;GET TRAP ADDRESS
	MOVEM	T1,CCBLK+.ERNPC		;STORE
	MOVX	T1,ER.ICC!ER.EIJ	;TRAP ^C AND FATAL JOB ERROR
	MOVEM	T1,CCBLK+.ERCLS
	SETZM	CCBLK+.EROPC		;CLEAR PC
	MOVEI	T1,CCBLK		;POINT TO ^C BLOCK
	MOVEM	T1,.JBINT		;TELL MONITOR
	POPJ	P,			;AND RETURN

	SUBTTL	Subroutines -- CCTRAP - Handle ^C trapping

CCTRAP:	PUSH	P,CCBLK+.EROPC		;SAVE PC
	SETZM	CCBLK+.EROPC		;AND REENABLE
	AOSE	DIEWRD			;SEE IF NESTED
	 LOGOUT				;YES--DIE FAST!
	PUSH	P,T1			;SAVE T1
	HLRZ	T1,CCBLK+.ERCCL		;GET REASON
	CAIN	T1,ER.EIJ		;ERROR IN JOB?
	 JRST	CCERROR			;YES--HANDLE ERRORS
	PUSHJ	P,DPXIT##		;EXIT DPYPAK IF /DPY
	POP	P,T1			;RESTORE T1
	TLNN	F,(FL.LOGIN)		;WE LOGGED IN?
	  PUSHJ	P,.MONRT##		;NO--LET SCAN LOGOUT
	EXIT	1,			;YES--JUST EXIT
	POPJ	P,			;AND RETURN IF CONTINUE

CCERROR:POP	P,T1			;RESTORE T1
	TLNN	F,(FL.WHOSRV)		;ARE WE A SERVER?
	$STOP	(FEJ,<Fatal error in job>)
	$STOP	(FES,<Fatal error in WHO server>)
	SUBTTL	Subroutines -- SETME - Setup my profile and privs

SETME::	PJOB	T1,			;GET MY JOB
	MOVEM	T1,MYJOB		;SAVE
	PUSHJ	P,UGETLIN##		;GET MY TERMINAL LINE
	MOVEM	T1,MYTTY		;SAVE MY TTY NAME
	GTNTN.	T1,			;GET MY TERMINAL
	 MOVEI	T1,0			;FAILED
	HLRZS	T1			;GET NODE NUMBER
	PUSHJ	P,ANODE##		;CONVERT TO NAME
	 SETO	T1,			;FAILED
	MOVEM	T1,MYNOD		;AND SAVE MY NODE NAME
	HRROI	T1,.GTPRV		;GET MY PRIVS
	PUSHJ	P,MTAB##		;GET THEM
	TXNE	T1,JP.SPA!JP.SPM	;CAN I PEEK?
	 TLO	F,(FL.PEEK)		;YES
	TXNE	T1,JP.POK		;CAN I POKE?
	 TLO	F,(FL.POKE)		;YES
	HRROI	T1,.GTPPN		;GET JBTPPN
	PUSHJ	P,MTAB##		;..
	MOVEM	T1,MYPPN		;SAVE
	CAMN	T1,OPRPPN##		;GOD?
	 TLO	F,(FL.GOD)		;YES
	HRROI	T1,.GTSTS		;GET JBTSTS
	PUSHJ	P,MTAB##		;..
	TXNE	T1,JS.JAC		;JACCT?
	 TLO	F,(FL.JACCT)		;YES--FLAG
	HRROI	T1,.GTLIM		;GET BATCH STATUS
	PUSHJ	P,MTAB##		;GET IT
	TXNE	T1,JB.LBT		;SEE IF BATCH
	 TLOA	F,(FL.BATCH)		;YES--FLAG
	  CAIA				;NO--SKIP
	   JRST	SETM.1			;YES--AND SKIP CTLJOB CHECK
	MOVNI	T1,1			;GET MY JOB
	PUSHJ	P,UCTLJOB##		;FIND CONTROLLING JOB
	 MOVEI	T1,0			;NONE
	JUMPLE	T1,SETM.1		;JUMP IF NONE
	HRLI	T1,.GTPPN		;GET PPN
	MOVSS	T1			;POSITION
	PUSHJ	P,MTAB##		;GET FROM MONITOR
	CAMN	T1,OPRPPN##		;CONTROLLED BY OPR?
	 TLO	F,(FL.GOD)		;YES--FLAG GOD
SETM.1:	PUSHJ	P,.ISLGI##		;SEE IF LOGGED IN
	 CAILE	T1,0			;NO
	 TLO	F,(FL.LOGIN)		;YES
	HRROI	T1,.GTWCH		;GET WATCH BITS
	PUSHJ	P,MTAB##		;..
	TXNE	T1,JW.WCX!JW.WWT!JW.WRN!JW.WDR!JW.WDW ;ANY SET TO EFFECT EXIT?
	 TLO	F,(FL.WATCH)		;YES--FLAG
	POPJ	P,			;AND RETURN
	SUBTTL	Subroutines -- SETMOD - Set up AC 'M'


; Set up AC 'M' and do defaulting if necessary
; Call:	MOVE	T1, command table index
;	PUSHJ	P,SETMOD
;
; On return, M will contain the mode index
;
SETMOD::CAIE	T1,M%WHO##		;IF WHO
	 CAIGE	T1,0			;OR IF NO COMMAND FOUND
	  MOVEI	T1,M%JOB##		;ASSUME JOB
	CAIN	T1,M%NETWORK##		;IF NETWORK COMMAND
	 MOVEI	T1,M%NODE##		;IS REALLY NODE MODE
	MOVEI	M,(T1)			;SAVE MODE INDEX
	POPJ	P,			;RETURN
SUBTTL	Subroutines -- OLDWHO - Run previous version of WHO


OLDWHO:	MOVE	T1,[RUNBLK,,RUNBLK+1]	;SET UP BLT
	SETZM	RUNBLK			;CLEAR FIRST WORD
	BLT	T1,RUNBLK+6-1		;CLEAR ENTIRE BLOCK
	MOVE	T1,[RUNPTH,,RUNPTH+1]	;SET UP BLT
	SETZM	RUNPTH			;CLEAR FIRST WORD
	BLT	T1,RUNPTH+.PTMAX-1	;CLEAR ENTIRE BLOCK
	MOVEI	T1,RUNPTH		;POINT TO PATH BLOCK
	MOVEM	T1,RUNBLK+.RNPPN	;SAVE IN RUN BLOCK
	MOVE	T2,[-RUNLEN,,RUNTAB]	;POINTER TO ARGUMENTS
	PJOB	T3,			;MYJOB ISN'T SET UP YET

OLDW.1:	HLRZ	T1,(T2)			;GET TABLE NUMBER
	HRL	T1,T3			;INCLUDE OUR JOB NUMBER
	PUSHJ	P,GTAB##		;READ A MONITOR WORD
	HRRZ	T4,(T2)			;POINT TO STORAGE
	MOVEM	T1,(T4)			;SAVE WORD AWAY
	AOBJN	T2,OLDW.1		;LOOP THROUGH TABLE
	HLRZ	T1,MAPMVR##		;GET SIXBIT MONITOR VERSION
	SKIPN	T1			;HAVE SOMETHING HERE?
	MOVEI	T1,'OLD'		;MAKE IT "WHOOLD"
	HRRM	T1,RUNBLK+.RNNAM	;MERGE WITH OUR FILE NAME
	MOVEI	T1,RUNBLK		;POINT TO RUN UUO BLOCK
	HRL	T1,OFFSET		;INCLUDE CCL OFFSET IF ANY
	RUN	T1,			;RUN THE PREVIOUS VERION
	  $STOP	(RLF,<Run linkage failure >,E.RUN)

E.RUN:	PUSH	P,T1			;SAVE ERROR CODE
	PUSHJ	P,.TLPRN##		;TYPE OPEN PARANTHESIS
	POP	P,T1			;GET ERROR CODE BACK
	PUSHJ	P,.TOCTW##		;PUT OUT ERROR CODE
	PUSHJ	P,.TRPRN##		;TYPE CLOSED PARANTHESIS
	MOVEI	T1,[ASCIZ | for |]	;TYPE
	PUSHJ	P,.TSTRG##		; SEPARATOR
	MOVE	T1,RUNBLK+.RNDEV	;DEVICE NAME
	PUSHJ	P,.TDEVN##
	MOVE	T1,RUNBLK+.RNNAM	;FILE NAME
	PUSHJ	 P,.TSIXN##
	PUSHJ	P,.TDOT##
	MOVSI	T1,'EXE'		;EXTENSION
	PUSHJ	P,.TSIXN##
	MOVE	T1,[1,,RUNPTH+.PTPPN]	;PATH
	PJRST	.TDIRB##

RUNTAB:	.GTRDV,,RUNBLK+.RNDEV		;DEVICE
	.GTRFN,,RUNBLK+.RNNAM		;FILE NAME
	.GTRDI,,RUNPTH+.PTPPN		;PPN
	.GTRS0,,RUNPTH+.PTSFD+0		;SFD #1
	.GTRS1,,RUNPTH+.PTSFD+1		;SFD #2
	.GTRS2,,RUNPTH+.PTSFD+2		;SFD #3
	.GTRS3,,RUNPTH+.PTSFD+3		;SFD #4
	.GTRS4,,RUNPTH+.PTSFD+4		;SFD #5
RUNLEN==.-RUNTAB			;LENGTH OF TABLE
SUBTTL	AC save co-routines -- .SAVT1 - Save AC T1


.SAVT1::PUSH	P,T1
	PUSHJ	P,@-1(P)
	 JRST	.+2
	AOS	-2(P)
	POP	P,T1
	SUB	P,[1,,1]
	POPJ	P,
SUBTTL	AC save co-routines -- .SAVT2 - Save AC T1 and T2


.SAVT2::ADD	P,[2,,2]
	DMOVEM	T1,-1(P)
	PUSHJ	P,@-2(P)
	 JRST	.+2
	AOS	-3(P)
	DMOVE	T1,-1(P)
	SUB	P,[3,,3]
	POPJ	P,
SUBTTL	AC save co-routines -- .SAVT3 - Save ACs T1, T2, and T3


.SAVT3::ADD	P,[3,,3]
	DMOVEM	T1,-2(P)
	MOVEM	T3,0(P)
	PUSHJ	P,@-3(P)
	 JRST	.+2
	AOS	-4(P)
	DMOVE	T1,-2(P)
	MOVE	T3,0(P)
	SUB	P,[4,,4]
	POPJ	P,
SUBTTL	AC save co-routines -- .SAVT4 - Save ACs T1, T2, T3, and T4


.SAVT4::ADD	P,[4,,4]
	DMOVEM	T1,-3(P)
	DMOVEM	T3,-1(P)
	PUSHJ	P,@-4(P)
	 JRST	.+2
	AOS	-5(P)
	DMOVE	T1,-3(P)
	DMOVE	T3,-1(P)
	SUB	P,[5,,5]
	POPJ	P,
	SUBTTL	Storage

	$LOW

OFFSET::BLOCK	1
MYJOB::	BLOCK	1
MYTTY::	BLOCK	1 
MYNOD::	BLOCK	1
MYPPN::	BLOCK	1
PDL::	BLOCK	LN$PDL
VECTOR::BLOCK	VECNUM*4	;PSI INTERRUPT VECTORS
CCBLK:	BLOCK	4
DIEWRD:	BLOCK	1
RUNBLK:	BLOCK	6		;RUN UUO BLOCK
RUNPTH:	BLOCK	.PTMAX		;PATH BLOCK FOR RUN UUO

	END
