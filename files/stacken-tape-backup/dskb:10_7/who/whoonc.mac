	TITLE	WHOONC - Once-only symbol setup

	SEARCH	WHOMAC
	$SETUP	(WHOONC)
	.DIRECT	FLBLST,.ITABM

	ONCPDS==30		;ONCE-ONLY PDL SIZE
	FILWDS==21		;NUMBER OF WORDS IN AN ASCIZ FILESPEC

	WHODEV==<SIXBIT/DSK/>	;DEFAULT SAVE FILE DEVICE
	WHOFIL==<SIXBIT/WHO/>	;DEFAULT SAVE FILE NAME
	WHODDT==<SIXBIT/WHODDT/>;DEFAULT SAVE FILE NAME IF DDT IS LOADED
; Parser data block definitions

	.PBPMT==0		;PROMPT STRING
	.PBHLP==1		;HELP TEXT ADDRESSES
	.PBTYI==2		;TYPEIN ROUTINE
	.PBTYO==3		;TYPEOUT ROUTINE
	.PBTYA==4		;TYPEOUT FOR ARGUMENT
	.PBDEF==5		;DEFAULT RESPONSE
	.PBARG==6		;ARGUMENT
	.PBRSP==7		;RESPONSE
	.PBCHK==10		;RESPONSE CHECK
	.PBLEN==11		;LENGTH OF BLOCK

DEFINE	$PARSE	(TYP,PFX,PMT,DEF,ARG1,ARG2,HLP),<

	JSP	T1,PARSER
	EXP	[ASCIZ |'PMT|]	;;PROMPT STRING
	EXP	[ASCIZ |'HLP|]	;;HELP TEXT

;; INPUT,,OUTPUT/ARGUMENT ROUTINES
IFIDN <TYP><DEC>,<EXP	.DECNW##,.TDECW##,NUMARG>
IFIDN <TYP><OCT>,<EXP	.OCTNW##,.TOCTW##,NUMARG>
IFIDN <TYP><SIX>,<EXP	.SIXSW##,.TSIXN##,LSTARG>
IFIDN <TYP><TXT>,<EXP	.ASCQW##,.TSTRG##,LSTARG>
IFIDN <TYP><FIL>,<EXP	.FILIN##,.TFBLK##,.POPJ##>

;; DEFAULT RESPONSES
IFIDN <TYP><DEC>,<MOVE	T1,[EXP	^D'DEF]>
IFIDN <TYP><OCT>,<MOVE	T1,[EXP	^O'DEF]>
IFIDN <TYP><SIX>,<MOVE	T1,[SIXBIT /DEF/]>
IFIDN <TYP><TXT>,<MOVEI	T1,[ASCIZ |DEF|]>
IFIDN <TYP><FIL>,<MOVEI	T1,DEF>

;; ARGUMENTS
IFIDN <TYP><DEC>,<XWD	^D'ARG1,^D'ARG2>
IFIDN <TYP><OCT>,<XWD	^O'ARG1,^O'ARG2>
IFIDN <TYP><SIX>,<IOWD	PFX'.L,PFX'.T>
IFIDN <TYP><TXT>,<IOWD	PFX'.L,PFX'.T>
IFIDN <TYP><FIL>,<EXP	ARG1>

;; RESPONSE
IFIDN <TYP><DEC>,<MOVE	T1,N>
IFIDN <TYP><OCT>,<MOVE	T1,N>
IFIDN <TYP><SIX>,<MOVE	T1,N>
IFIDN <TYP><TXT>,<MOVEI	T1,.NMUL##>
IFIDN <TYP><FIL>,<MOVEI	T1,ARG1>

;; CHECK
IFIDN <TYP><DEC>,<EXP	NUMCHK>
IFIDN <TYP><OCT>,<EXP	NUMCHK>
IFIDN <TYP><SIX>,<EXP	SIXCHK>
IFIDN <TYP><TXT>,<EXP	.POPJ1##>
IFIDN <TYP><FIL>,<EXP	FILCHK>

> ;END $PARSE
	$LOW

WHOONC::JFCL				;NO CCL
	RESET				;STOP I/O
	SETZB	0,O.ZBEG		;CLEAR AN AC AND A WORD
	MOVE	P,[O.ZBEG,,O.ZBEG+1]	;SET UP BLT
	BLT	P,O.ZEND-1		;CLEAR OUT ONCE-ONLY DATA
	MOVEI	17,1			;SETUP UP BLT
	BLT	17,17			;CLEAR THE ACS
	MOVE	P,[IOWD	ONCPDS,ONCPDL]	;SET UP STACK
	MOVEI	T1,'WHO'		;SET ERROR PREFIX
	PUSHJ	P,.ERXPF##		;TELL ERROR HANDLER
	PUSHJ	P,MAPMON##		;SET UP FOR MONITOR MAPPING
	PUSHJ	P,WEHSEG		;WRITE ENABLE THE HIGH SEGMENT
	PUSHJ	P,DEFALT		;DO DEFAULTING FOR DIALOG
	PUSHJ	P,DIALOG		;ASK SOME QUESTIONS
	PUSHJ	P,BOOTS			;CONVERT THE FILESPEC TO ASCIZ
	PUSHJ	P,MAPCRS##		;SET UP EXE FILE MAPPING
	PUSHJ	P,UUOFET##		;GET MONITOR FEATURES
	PUSHJ	P,SYMLOD		;LOAD SYMBOLS FROM AN UNRUN MONITOR
	PUSHJ	P,SYMCHK		;CHECK SYMBOLS
	PUSHJ	P,HIDATA		;SET UP SPECIAL HIGH SEG DATA
	PUSHJ	P,INISET		;SET UP INITIALIZATION TEXT
	PJRST	SAVER			;SAVE OUR CORE IMAGE
SUBTTL	Dialog defaulting


DEFALT:	SETZM	ONCFLG			;FLAG STARTING ONCE-ONLY CODE
	PUSHJ	P,BTSDEF		;BOOTSTRAP FILESPEC
	PUSHJ	P,SAVDEF		;SAVE FILE
	PUSHJ	P,DDTDEF		;DDT
	PUSHJ	P,SYMDEF		;SYMBOL TABLE
	POPJ	P,			;RETURN
; Default the monitor bootstrap filespec
BTSDEF:	MOVEI	P1,BTSGTB		;POINT TO TABLE
	PUSHJ	P,GTBS			;DO SOME GETTABS
	SETOM	BTSSCB+.FXNMM		;MASK FOR FILE NAME
	HLLOS	BTSSCB+.FXEXT		;MASK FOR EXTENSION
	SETOM	BTSSCB+.FXDIM+0		;MASK FOR SFD #1
	SETOM	BTSSCB+.FXDIM+2		;MASK FOR SFD #2
	SETOM	BTSSCB+.FXDIM+4		;MASK FOR SFD #3
	SETOM	BTSSCB+.FXDIM+6		;MASK FOR SFD #4
	SETOM	BTSSCB+.FXDIM+10	;MASK FOR SFD #5

; Default the monitor filespec
MONDEF:	MOVSI	T1,-.FXLEN		;-COUNT,,0

MOND.1:	MOVE	T2,BTSSCB(T1)		;GET A DEFAULT
	SKIPN	MONSCB(T1)		;WORD SPECIFIED?
	MOVEM	T2,MONSCB(T1)		;NO
	AOBJN	T1,MOND.1		;LOOP
	POPJ	P,			;RETURN

; Monitor bootstrap file spec
BTSGTB:	EXP	%CNMBS,BTSSCB+.FXDEV	;DEVICE
	EXP	%CNMBF,BTSSCB+.FXNAM	;FILE NAME
	EXP	%CNMBX,BTSSCB+.FXEXT	;EXTENSION
	EXP	%CNMBD,BTSSCB+.FXDIR+0	;PPN
	EXP	%CNSF1,BTSSCB+.FXDIR+2	;SFD #1
	EXP	%CNSF2,BTSSCB+.FXDIR+4	;SFD #2
	EXP	%CNSF3,BTSSCB+.FXDIR+6	;SFD #3
	EXP	%CNSF4,BTSSCB+.FXDIR+10	;SFD #4
	EXP	%CNSF5,BTSSCB+.FXDIR+12	;SFD #5
	EXP	0			;TERMINATE LIST
; Default the save filespec
SAVDEF:	MOVSI	T1,-.FXLEN		;-COUNT,,0

SAVD.1:	MOVE	T2,SAVDSB(T1)		;GET A DEFAULT
	SKIPN	SAVSCB(T1)		;WORD SPECIFIED?
	MOVEM	T2,SAVSCB(T1)		;NO
	AOBJN	T1,SAVD.1		;LOOP
	POPJ	P,			;RETURN

; Save file default scan block
SAVDSB:	EXP	WHODEV			;DEVICE
	EXP	WHOFIL			;FILE NAME
	EXP	-1			;FILE NAME MASK
	XWD	'EXE',-1		;EXTENSION AND MASK
	BLOCK	.FXLEN-<.-SAVDEF>	;REMAINDER OF BLOCK IS ZEROS
; DDT
DDTDEF:	SKIPN	.JBDDT			;IS DDT LOADED?
	POPJ	P,			;NO
	HRRZ	T1,.JBHRL		;GET HIGH SEG END
	JUMPE	T1,DDTD.1		;DON'T HAVE ONE
	MOVE	T1,[-2,,.GTUPM]		;ARGS TO READ UPMP
	PUSHJ	P,.MAPG##		; FOR OUR HIGH SEG

DDTD.1:	  MOVSI	T1,.JBHGH		;ASSUME THE NORMAL STARTING ADDRESS
	HLRZS	T1			;PUT IN RH
	MOVEM	T1,HGHORG		;SAVE HIGH SEG ORIGIN
	HLRZ	T2,.JBDDT		;GET DDT ENDING ADDRESS
	CAML	T1,T2			;IF BELOW THE HIGH SEG, NOT VMDDT
	MOVEM	T2,DDTFLG		;FLAG REAL DDT PRESENT
	POPJ	P,			;RETURN
; Symbol table
SYMDEF:	SKIPE	T1,HGHORG		;GET HIGH SEG ORIGIN
	SKIPN	.JBHSM(T1)		;SAVE A SYMBOL TABLE UP THERE?
	POPJ	P,			;NO HIGH SEG OR NO SYMBOLS
	MOVEM	T1,SYMFLG		;SAVE ADDRESS
	POPJ	P,			;AND RETURN
DIALOG:	SETZM	DEFFLG			;NO DEFAULTING RIGHT NOW
	MOVEI	T1,PMTPROMPT		;GET DEFAULT HELP MODE
	MOVEM	T1,HLPLVL		;SET IT
	PUSHJ	P,.TCRLF##		;CRLF TO START THINGS OFF
	MOVEI	T1,[ASCIZ |	WHO %|]	;BEGIN
	PUSHJ	P,.TSTRG##		; INTRODUCTION
	MOVE	T1,.JBVER		;GET OUR VERSION
	PUSHJ	P,.TVERW##		;TYPE IT
	MOVEI	T1,[ASCIZ | for TOPS10 |]
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVEI	T1,%VER			;GET MONITOR WHO WAS BUILT FOR
	PUSHJ	P,.TOCTW##		;TYPE IT
	MOVEI	T1,[ASCIZ | monitors|]	;FINISH
	PUSHJ	P,.TSTRG##		; LINE
	PUSHJ	P,.TCRLF##		;CRLF
	MOVEI	T1,[ASCIZ |	   Once-only initialization code|]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	PUSHJ	P,.TCRLF##		;CRLF
	PUSHJ	P,.TCRLF##		;ONE MORE

DIAL.0:	$PARSE	(SIX,YNA,<Do you want help>,NO,,,<
In  the  following  dialog,  all  numbers  are  decimal   unless
otherwise noted.  Default responses are surrounded by [].  Lists
of legal responses are surrounded by ().  "/HELP" may  be  typed
in  response  to  any  question.   It  causes the question to be
re-typed in the next longer mode.  At any time, the  dialog  may
be   restarted  by  typing  ESCAPE.   Typing  Control-Z  to  any
question will cause immediate return to monitor level.
>)
	HRRZ	T2,T1			;GET ANSWER
	SUBI	T2,YNA.T-1		;NOW INDEX INTO TABLE
	MOVEI	T1,DIAL.0+1		;POINT TO START OF PARSER BLOCK
	MOVE	T1,.PBHLP(T1)		;GET TEXT ADDRESS
	CAIN	T2,YNAYES		;WAS ANSWER NO?
	PUSHJ	P,.TSTRG##		;TYPE HELP TEXT


	$PARSE	(SIX,PMT,</HELP>,PROMPT,,,<
Questions may be asked in three different modes.  The modes are:
	SHORT	only asks for input.
	PROMPT	lists default and legal responses.
	LONG	lists help text, default, and legal responses.
>)
	HRRZS	T1			;GET JUST KEYWORD ADDRESS
	SUBI	T1,PMT.T-1		;NOW INDEX INTO TABLE
	MOVEM	T1,HLPLVL		;SAVE PROMPT HELP LEVEL
	JRST	DIAL.1

KEYS	(PMT,<SHORT,PROMPT,LONG>)
DIAL.1:	$PARSE	(FIL,XXX,<Monitor file>,BTSSCB,MONSCB,,<
WHO must obtain monitor symbols in order for  it  to  examine  a
running  monitor  or  a  crash  file.  The extracted symbols are
often used whenever an offset, monitor address, or byte  pointer
is not available from the monitor via the GETTAB UUO.
>)

DIAL.2:	SKIPN	DDTFLG			;IS DDT LOADED?
	JRST	DIAL.3			;NO
	$PARSE	(SIX,YNA,<Preserve DDT>,NO,,,<
Normally, DDT is not included in a production  version  of  WHO.
For   ease  of  debugging,  however,  you  have  the  option  of
preserving DDT.
>)
	HRRZS	T1			;GET JUST KEYWORD ADDRESS
	SUBI	T1,YNA.T-1		;NOW INDEX INTO TABLE
	CAIN	T1,YNANO		;WAS ANSWER NO?
	SETZM	DDTFLG			;WIPE OUT DDT
	MOVE	T2,[WHOFIL]		;ASSUME NO DDT
	SKIPE	DDTFLG			;WHAT DID HE ANSWER?
	MOVE	T2,[WHODDT]		;KEEPING DDT SO CHANGE DEFAULT NAME
	MOVEM	T2,SAVDSB+.FXNAM	;SET DEFAULT FILE NAME

DIAL.3:	SKIPN	SYMFLG			;HAVE SYMBOLS?
	JRST	DIAL.4			;NO
	$PARSE	(SIX,YNA,<Preserve symbols>,NO,,,<
Normally,  symbols  are  not included in a production version of
WHO.  For ease of debugging, however, you  have  the  option  of
preserving the symbol table.
>)
	HRRZS	T1			;GET JUST KEYWORD ADDRESS
	SUBI	T1,YNA.T-1		;NO INDEX INTO TABLE
	CAIN	T1,YNANO		;WAS ANSWER NO?
	SETZM	SYMFLG			;WIPE OUT SYMBOLS
DIAL.4:	$PARSE	(FIL,XXX,<Save file>,SAVDSB,SAVSCB,,<
When the once-only initialization  proceedure  is  completed,  a
runnable  production  version  of WHO will need to be saved in a
.EXE file.  Although this file usually resides on  SYS:,  it  is
recommended that WHO be tested before it's put on SYS:.
>)
	PUSHJ	P,SAVSET		;SET UP EVENTUAL SAVE. UUO
	  JRST	DIAL.4			;SOMETHING WAS WRONG--TRY AGAIN
DIAL.5:	$PARSE	(SIX,YNA,<Default internal parameters>,YES,,,<
Normally,  the  standard internal defaults will suffice for most
installations.  You have the option of changing  these  at  this
time.   Internal  parameters  are  those which do not effect the
user directly, but instead control how WHO  will  get,  process,
and display data.
>)
	HRRZS	T1			;GET JUST KEYWORD ADDRESS
	SUBI	T1,YNA.T-1		;NOW INDEX INTO TABLE
	CAIN	T1,YNANO		;WAS ANSWER NO?
	TDZA	T1,T1			;YES
	MOVEI	T1,1			;NO
	MOVEM	T1,DEFINT		;SET INTERNAL FLAG
DIAL.6:	$PARSE	(SIX,YNA,<Default user parameters>,YES,,,<
Normally, the standard user interface defaults will suffice  for
most  installations.   You  have the option of changing these at
this time.  User parameters are  those  which  effect  the  user
interface directly, such as switch and keyword defaults.
>)
	HRRZS	T1			;GET JUST KEYWORD ADDRESS
	SUBI	T1,YNA.T-1		;NOW INDEX INTO TABLE
	CAIN	T1,YNANO		;WAS ANSWER NO?
	TDZA	T1,T1			;YES
	MOVEI	T1,1			;NO
	MOVEM	T1,DEFUSR		;SET USER FLAG
DEFI.0:	MOVE	T1,DEFINT		;GET DEFAULT FLAG
	MOVEM	T1,DEFFLG		;SET IT
	JUMPN	T1,DEFI.1		;DEFAULTING?
	PUSHJ	P,.TCRLF##		;CRLF TO START THINGS OFF
	MOVEI	T1,[ASCIZ |		Internal parameters|]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	PUSHJ	P,.TCRLF##		;CRLF
	PUSHJ	P,.TCRLF##		;ONE MORE

DEFI.1:	$PARSE	(SIX,CHG,<Charge number typeout>,SIXBIT,,,<
Charge numbers are set in the  monitor  by  the  LOGIN  UUO  for
accounting purposes.  The TOPS-10 monitor, however, makes no use
of the charge number.  Therefore, the format was never  defined.
Usually, it is a sixbit number.
>)
	HRRZS	T1			;GET JUST KEYWORD ADDRESS
	SUBI	T1,CHG.T		;NOW INDEX INTO TABLE
	MOVSI	T2,(PJRST)		;LH
	HRR	T2,CHGTAB(T1)		;GET SUBROUTINE FOR TYPEOUT
	MOVEM	T2,CHGTYO		;SAVE IT
	JRST	DEFI.2

KEYS	(CHG,<DECIMAL,OCTAL,SIXBIT>)
CHGTAB:	EXP	.TDECW##,.TOCTW##,.TSIXN##

DEFI.2:	$PARSE	(SIX,YNA,<Record mapper runtime>,NO,,,<
MAP, the page mapping subroutine package,  has  the  ability  to
keep track of it's own runtime.  The accumulated runtime is made
available to WHO for displaying the mapper performance when  the
/MPERFORMANCE  switch is used.  Answering "YES" to this question
will cause two RUNTIM UUOs to be executed on each  call  to  the
mapper.  Doing this could possibly cause excessive overhead.
>)
	HRRZS	T1			;GET JUST KEYWORD ADDRESS
	SUBI	T1,YNA.T		;NO INDEX INTO TABLE
	MOVEM	T1,MAPRTM##		;SAVE 0 (NO) OR 1 (YES)

DEFI.3:
DEFU.0:	MOVE	T1,DEFUSR		;GET DEFAULT FLAG
	MOVEM	T1,DEFFLG		;SET IT
	JUMPN	T1,DEFU.1		;DEFAULTING?
	PUSHJ	P,.TCRLF##		;CRLF TO START THINGS OFF
	MOVEI	T1,[ASCIZ |		User interface parameters|]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	PUSHJ	P,.TCRLF##		;CRLF
	PUSHJ	P,.TCRLF##		;ONE MORE

DEFU.1:
IFN FTSERV,<
	$PARSE	(SIX,YNA,</SERVER legal when logged out>,NO,,,<
The /SERVER switch allows access to remote WHO servers.  In some
network  environments, this could incure a substantial amount of
runtime and tie up remote server tasks for extended  periods  of
time.
>)
	HRRZS	T1			;GET JUST KEYWORD ADDRESS
	SUBI	T1,YNA.T		;NO INDEX INTO TABLE
	MOVEM	T1,SRVLGO##		;SAVE 0 (NO) OR 1 (YES)
> ;END IFN FTSERV

DEFU.3:	POPJ	P,			;RETURN
SUBTTL	Parser logic -- Entry point


PARSER:	MOVE	P1,T1			;COPY POINTER TO DATA BLOCK
	MOVE	T1,HLPLVL		;GET HELP LEVEL
	MOVEM	T1,HLPPRS		;SET PARSER COPY

PARS.0:	PUSHJ	P,.CLRFL##		;CLEAR STICKY DEFAULTS
	SKIPE	DEFFLG			;DEFAULTING?
	JRST	PARS.5			;YES--DON'T ASK QUESTION
	MOVE	T1,HLPPRS		;TYPE OF HELP
	CAIE	T1,PMTLONG		;WANT HELP TEXT TOO?
	JRST	PARS.Y			;NO
	MOVE	T1,.PBHLP(P1)		;POINT TO TEXT
	PUSHJ	P,.TSTRG##		;TYPE HELP

PARS.Y:	MOVE	T1,.PBPMT(P1)		;POINT TO PROMPT
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVE	T1,HLPPRS		;TYPE OF HELP
	CAIE	T1,PMTSHORT		;/HELP:SHORT?
	PUSHJ	P,@.PBTYA(P1)		;TYPE ARGUMENT
	MOVE	T1,HLPPRS		;GET HELP LEVEL
	CAIGE	T1,PMTPROMPT		;/HELP:PROMPT OR /HELP:LONG?
	JRST	PARS.X			;NO
	PUSHJ	P,.TSPAC##		;SPACE OVER
	MOVEI	T1,"["			;START OF DEFAULT RESPONSE
	PUSHJ	P,.TCHAR##		;TYPE BRACKET
	XCT	.PBDEF(P1)		;GET DEFAULT RESPONSE
	PUSHJ	P,@.PBTYO(P1)		;TYPE IT
	MOVEI	T1,"]"			;END OF DEFAULT RESPONSE
	PUSHJ	P,.TCHAR##		;TYPE BRACKET

PARS.X:	PUSHJ	P,.TCOLN##		;PROMPT WITH A COLON
	PUSHJ	P,.TSPAC##		;AND A SPACE
	SETZ	T1,			;NO ARGUMENTS
	PUSHJ	P,.PSCAN##		;SET UP THE SCANNER
	  JFCL				;IGNORE SCAN'S CONFUSION

PARS.1:	PUSHJ	P,.TIALT##		;GET A CHARACTER
	CAIE	C,.CHTAB		;TAB?
	CAIN	C," "			;SPACE?
	JRST	PARS.1			;IGNORE IT
	CAIN	C,"/"			;A SWITCH (WANTS HELP)?
	JRST	PARS.2			;YES
	CAIN	C,.CHALX		;SOME FLAVOR OF ALTMODE?
	JRST	WHOONC			;YES--RESTART DIALOG
	CAMN	C,[.CHEOF]		;EOF?
	JRST	PARS.4			;YES--GO STOP
	JUMPL	C,PARS.5		;DEFAULTING?
	PUSHJ	P,.REEAT##		;RE-EAT THE LAST CHARACTER
	PUSHJ	P,@.PBTYI(P1)		;GET A RESPONSE
	  JFCL				;INCASE SKIP RETURN
	JUMPGE	C,E.INCL##		;JUNK ON LINE?
	XCT	.PBRSP(P1)		;GET RESPONSE
	JRST	PARS.6			;RETURN

PARS.2:	PUSHJ	P,.SIXSW##		;GET A SIXBIT WORD
	MOVE	T1,[IOWD 1,['HELP  ']]	;IOWD POINTER TO "HELP"
	PUSHJ	P,.NAME##		;SEE WHAT TYPED
	  $WARN	(UST,<Unknown switch typed>,)
	AOS	T1,HLPPRS		;WANT IT?
	CAILE	T1,PMTLONG		;OUT OF RANGE?
	MOVEI	T1,PMTLONG		;YES
	MOVEM	T1,HLPPRS		;RESET VALUE
	JRST	PARS.0			;GO BACK AND TRY AGAIN

PARS.4:	PUSHJ	P,.ALDON##		;CLEAR EOF, EXIT
	JRST	WHOONC			;THE FOOL TYPED CONTINUE

PARS.5:	XCT	.PBDEF(P1)		;GET DEFAULT

PARS.6:	MOVEM	T1,ANSWER		;SAVE ANSWER
	PUSHJ	P,@.PBCHK(P1)		;CHECK THE RESPONSE
	  JRST	PARS.0			;NO GOOD--TRY AGAIN
	JRST	.PBLEN(P1)		;RETURN
SUBTTL	Parser logic -- Option typeout


; Numeric range
NUMARG:	PUSHJ	P,.TSPAC##		;SPACE
	PUSHJ	P,.TLPRN##		;START OF RANGE
	HLRE	T1,.PBARG(P1)		;GET LOW
	PUSHJ	P,@.PBTYO(P1)		;TYPE IT
	MOVEI	T1,[ASCIZ | to |]	;GET SEPARATOR
	PUSHJ	P,.TSTRG##		;TYPE IT
	HRRE	T1,.PBARG(P1)		;GET HIGH
	PUSHJ	P,@.PBTYO(P1)		;TYPE IT
	PJRST	.TRPRN##		;TYPE END OF RANGE AND RETURN

; List typeout
LSTARG:	PUSHJ	P,.TSPAC##		;SPACE
	MOVE	P2,.PBARG(P1)		;GET IOWD TO LIST OF ITEMS
	SKIPA	T1,["("]		;START OF LIST

LSTA.1:	MOVEI	T1,","			;SEPARATOR
	PUSHJ	P,.TCHAR##		;TYPE IT
	MOVE	T1,1(P2)		;GET AN ITEM
	PUSHJ	P,@.PBTYO(P1)		;TYPE ITEM IN LIST
	AOBJN	P2,LSTA.1		;LOOP THROUGH LIST
	PJRST	.TRPRN##		;TYPE END OF LIST AND RETURN
SUBTTL	Parser logic -- Argument checking


; Numeric
NUMCHK:	HLRE	T2,.PBARG(P1)		;GET LOW
	HRRE	T3,.PBARG(P1)		;GET HIGH
	CAML	T1,T2			;RANGE
	CAMLE	T1,T3			; CHECK
	SKIPA				;OUT OF RANGE
	JRST	.POPJ1##		;NUMBER CHECKS OUT OK
	$FATAL	(NOR,<Number >,E.NOR)
	POPJ	P,			;RETURN

E.NOR:	PUSHJ	P,@.PBTYO(P1)		;TYPE NUMBER
	MOVEI	T1,[ASCIZ | outside the range |]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	HLRE	T1,.PBARG(P1)		;GET LOW
	PUSHJ	P,@.PBTYO(P1)		;TYPE IT
	MOVEI	T1,[ASCIZ | to |]	;MORE
	PUSHJ	P,.TSTRG##		; TEXT
	HRRE	T1,.PBARG(P1)		;GET HIGH
	PJRST	@.PBTYO(P1)		;TYPE IT AND RETURN


; Sixbit
SIXCHK:	MOVE	T1,.PBARG(P1)		;GET IOWD TO TABLE
	MOVE	N,ANSWER		;PUT WHERE SCAN EXPECTS IT
	PUSHJ	P,.NAME##		;SEE IF A MATCH
	  SKIPA				;NO GOOD
	JRST	.POPJ1##		;RETURN
	SKIPG	T1			;UNKNOWN?
	$FATAL	(UNK,<Unknown keyword ">,E.SIX)
	SKIPL	T1			;AMBIGUOUS?
	$FATAL	(AMB,<Ambiguous keyword ">,E.SIX)
	POPJ	P,			;RETURN

E.SIX:	PUSH	P,T1			;SAVE T1
	MOVE	T1,N			;GET KEYWORD
	PUSHJ	P,.TSIXN##		;TYPE IT
	MOVEI	T1,""""			;TERMINATING QUOTE
	PUSHJ	P,.TCHAR##		;TYPE IT
	POP	P,T1			;RESTORE T1
	POPJ	P,			;AND RETURN


; Filespec
FILCHK:	SKIPN	T1,.MYPPN##		;HAVE OUR PPN YET?
	GETPPN	T1,			;NO--GET IT NOW
	  JFCL				;INCASE OF JACCT
	MOVEM	T1,.MYPPN##		;SAVE FOR LATER
	XCT	.PBRSP(P1)		;POINT TO STORAGE
	HRLZ	T2,T1			;GET START ADDRESS
	HRRI	T2,1(T1)		;MAKE A BLT POINTER
	HRRZ	T3,T1			;GET SCAN BLOCK ADDRESS
	SETZM	(T3)			;CLEAR FIRST WORD
	BLT	T2,.FXLEN-1(T3)		;CLEAR OUT SCAN BLOCK
	PUSHJ	P,.GTSPC##		;GET FILESPEC
	XCT	.PBDEF(P1)		;GET DEFAULT
	MOVE	T2,T1			;PUT IN T2
	MOVE	T1,.PBARG(P1)		;POINT TO ANSWER

	MOVE	T3,.FXDEV(T2)		;GET DEFAULT DEVICE
	MOVX	T4,FX.NDV		;GET NULL DEVICE FLAG
	TDNE	T4,.FXMOD(T1)		;HAVE ONE?
	MOVEM	T3,.FXDEV(T1)		;NO

	DMOVE	T3,.FXNAM(T2)		;GET DEFAULT FILE NAME AND MASK
	SKIPN	.FXNAM(T1)		;HAVE ONE?
	DMOVEM	T3,.FXNAM(T1)		;NO

	MOVE	T3,.FXEXT(T2)		;GET DEFAULT EXTENSION AND MASK
	SKIPN	.FXEXT(T1)		;HAVE ONE?
	MOVEM	T3,.FXEXT(T1)		;NO

	MOVX	T3,FX.DIR		;GET DIRECTORY SPECIFIED FLAG
	TDNN	T3,.FXMOM(T1)		;HAVE ONE?
	JRST	FILC.1			;NO--GO LOAD FROM DEFAULT SCAN BLOCK
	TDNE	T3,.FXMOD(T1)		;WAS IT [-]?
	SKIPE	.FXDIR(T1)		;CHECK FOR [,]
	JRST	FILC.3			;WANTS TO USE DEFAULT PATH
	MOVE	T3,.MYPPN##		;GET OUR PPN
	MOVEM	T3,.FXDIR(T1)		;SET OUR PPN
	SETOM	.FXDIM(T1)		; AND MASK TOO
	JRST	FILC.3			;DONE

FILC.1:	MOVSI	T3,-.FXLND		;SET UP -LENGTH,,0

FILC.2:	MOVE	T4,.FXDIR(T2)		;GET A PPN OR SFD
	MOVEM	T4,.FXDIR(T1)		;DEFAULT IT
	MOVE	T4,.FXDIM(T2)		;GET MASK
	MOVEM	T4,.FXDIM(T1)		;DEFAULT IT TOO
	ADDI	T1,1			;POINT TO NEXT STORAGE
	ADDI	T2,1			;POINT TO NEXT DEFAULT
	AOBJN	T3,FILC.2		;LOOP

FILC.3:	JRST	.POPJ1##		;AND RETURN
SUBTTL	Parser logic -- Common tables


; YES/NO answer table
KEYS	(YNA,<NO,YES>)
; Read the monitor's bootstrap file spec
BOOTS:	MOVE	T1,[POINT 7,CRSFIL##]	;POINT TO THE ASCIZ FILESPEC STORAGE
	MOVEM	T1,BYTPTR		;SAVE IT
	MOVEI	T1,<FILWDS*5>-1		;GET BYTE COUNT
	MOVEM	T1,BYTCNT		;SAVE IT
	MOVEI	T1,BTSTYO		;POINT TO CHARACTER STICKER
	PUSHJ	P,.TYOCH##		;TELL SCAN ABOUT THE CHANGE
	PUSH	P,T1			;SAVE OLD TYPER

	SETOM	MONSCB+.FXNMM		;MASK FOR FILE NAME
	HLLOS	MONSCB+.FXEXT		;MASK FOR EXTENSION
	SETOM	MONSCB+.FXDIM+0		;MASK FOR SFD #1
	SETOM	MONSCB+.FXDIM+2		;MASK FOR SFD #2
	SETOM	MONSCB+.FXDIM+4		;MASK FOR SFD #3
	SETOM	MONSCB+.FXDIM+6		;MASK FOR SFD #4
	SETOM	MONSCB+.FXDIM+10	;MASK FOR SFD #5

	MOVEI	T1,MONSCB		;POINT TO THE SCAN BLOCK
	PUSHJ	P,.TFBLK##		;CONVERT TO ASCII
	POP	P,T1			;GET OLD CHARACTER STICKER
	PJRST	.TYOCH##		;RESET INSIDE SCAN

BTSTYO:	SOSLE	BYTCNT			;COUNT
	IDPB	T1,BYTPTR		;SAVE CHARACTER
	POPJ	P,			;RETURN
SUBTTL	Symbol table routines -- SYMLOD - Load symbols

SYMLOD:	$INFO	(LSF,<Loading symbols from file: >,E.LSF)
	$INFO	(MON,<Monitor is ">,E.MON)
	MOVEI	T1,.JBSYM		;POINTER TO THE SYMBOL TABLE
	PUSHJ	P,.MAPE##		;FIND IT
	  PJRST	MAPSTP##		;UNRECOVERABLE MAPPING ERROR
	JUMPGE	T1,SYML.1		;IF .GT. THEN VECTOR POINTER
	HRRZ	P2,T1			;ADDRESS OF SYMBOL TABLE
	HLRE	P1,T1			;NEGATIVE SYMBOL TABLE LENGTH
	MOVM	P1,P1			;POSITIVE SYMBOL TABLE LENGTH
	JRST	SYML.4			;SETUP FOR SYMBOL TABLE SEARCH


;Here to handle extended-addressing symbol table vector

SYML.1:	SKIPN	P4,T1			;REMEMBER BASE ADDRESS OF VECTOR
	POPJ	P,			;NO SYMBOL TABLE POINTER . . .
	PUSHJ	P,.MAPE##		;GET SYM VECTOR LENGTH
	  PJRST	MAPSTP##		;SO MUCH FOR THE SYMBOL TABLE
	IDIVI	T1,3			;REDUCE TO COUNT OF SUB-TABLES
	SKIPG	P3,T1			;REMEMBER THIS COUNT ALSO
	POPJ	P,			;NO SYMBOL TABLE
	ADDI	P4,.SYSTB		;OFFSET TO FIRST VECTOR SUBTABLE

;Loop over symtab vector subtable entries looking for "main" symbol table

SYML.2:	MOVE	T1,P4			;ADDRESS OF NEXT SUBTABLE
		.CREF	.SYTYP		;TYPE-AND-LENGTH-WORD OFFSET
	PUSHJ	P,.MAPE##		;EXTRACT FLAGS + LENGTH
	  PJRST	MAPSTP##		;BAD VECTOR SUBTABLE
	LDB	T2,[POINTR T1,SY.TYP]	;EXTRACT THIS SUBTABLE "TYPE"
	CAIN	T2,.SYR5D		;RADIX-50 "MAIN" SYMBOL TABLE?
	JRST	SYML.3			;YES, THIS IS WHAT WE WANT
	ADDI	P4,.SYSTL		;NO, ADVANCE TO NEXT SUBTABLE ADDRESS
	SOJG	P3,SYML.2		;CHECK OUT NEXT SUBTABLE
	POPJ	P,			;NO SYMBOL TABLE AFTER ALL

SYML.3:	ANDX	T1,SY.LEN		;REDUCE TO LENGTH
	MOVE	P1,T1			;AND REMEMBER LENGTH
	AOS	T1,P4			;ADDRESS OF SYMBOL TABLE ADDRESS
		.CREF	.SYADR		;SYMBOL-TABLE-ADDRESS OFFSET
	PUSHJ	P,.MAPE##		;GET IT
	  PJRST	MAPSTP##		;BAD VECTOR SUBTABLE
	TLNE	T1,(1B0)		;SECTION-LOCAL POINTER?
	HLL	T1,P4			;YES, SET SECTION ADDRESS
	MOVE	P2,T1			;AND REMEMBER SYMBOL TABLE ADDRESS
SYML.4:	TRNE	P1,1			;LENGTH MUST BE MODULO-2
	JRST	MAPSTP##		;BUMMER
	LSH	P1,-1			;COUNT OF SYMBOL TABLE ENTRIES
	SOJA	P2,SYML.5		;GO SEARCH SYMBOL TABLE
;Loop over symbol table, extracting desired symbols/values

SYML.5:	MOVEI	T1,SYMLEN		;GET NUMBER OF NEEDED SYMBOLS
	CAMN	T1,FOUND		;HAVE THEM ALL?
	POPJ	P,			;YES--RETURN
	AOS	T1,P2			;GET SYMBOL
	PUSHJ	P,.MAPE##		; NAME ADDRESS
	  PJRST	MAPSTP##		;UNRECOVERABLE MAPPING ERROR
	TLZ	T1,(74B5)		;CLEAR OUT FLAGS
	MOVE	P3,T1			;HANG ONTO SYMBOL NAME
	AOS	T1,P2			;GET SYMBOL VALUE ADDRESS
	PUSHJ	P,.MAPE##		; VALUE ADDRESS
	  PJRST	MAPSTP##		;UNRECOVERABLE MAPPING ERROR

;Check this symbol to see if we want its value

	MOVSI	T4,-SYMLEN		;-NUMBER OF NEEDED SYMBOLS
SYML.6:	CAME	P3,SYMTAB(T4)		;A MATCH?
	AOBJN	T4,SYML.6		;KEEP LOOKING
	JUMPGE	T4,SYML.8		;DON'T NEED THIS SYMBOL
	SKIPE	T3,REFTAB(T4)		;GET REFERENCE COUNT
	CAIE	T3,1			;JUST ONE MATCH?
	SETCAM	T1,VALTAB(T4)		;MAKE SURE WE STORE THIS VALUE
	CAMN	T1,VALTAB(T4)		;NEW VALUE SAME AS OLD VALUE?
	JRST	SYML.8			;DON'T CALL THIS MULTIPLY DEFINED
	MOVEM	T1,VALTAB(T4)		;SAVE VALUE AWAY
	AOS	T3,REFTAB(T4)		;COUNT THE REFERNCE
	CAIN	T3,1			;MULTIPLY DEFINED SYMBOLS TWICE?
	AOS	FOUND			;NO--ADD TO THE NUMBER OF SYMBOLS FOUND

SYML.8:	SOJG	P1,SYML.5		;LOOP THROUGH SYMBOL TABLE
	POPJ	P,			;RETURN
SUBTTL	Symbol table routines -- SYMCHK - Check extracted symbols


SYMCHK:	MOVEI	P1,SYMLEN		;GET NUMBER OF NEEDED SYMBOLS
	MOVEM	P1,SYMREQ		;SAVE IT
	MOVSI	P1,-SYMLEN		;-NUMBER OF NEEDED SYMBOLS
	SETZ	P2,			;CLEAR NUMBER OF ERRORS

SYMC.1:	MOVE	T1,REFTAB(P1)		;FIND THIS SYMBOL?
	SOJE	T1,SYMC.4		;JUMP IF EXACTLY ONE MATCH
	JUMPG	T1,SYMC.3		;JUMP IF MULTIPLY DEFINED
	SKIPN	T1,FLGTAB(P1)		;GET FLAGS
	JRST	SYMC.2			;SYMBOL IS REQUIRED IF NO FLAGS
	TDNN	T1,F			;IS THIS FEATURE IN THE MONITOR?
	SOSA	SYMREQ			;ADJUST REQUIRED NUMBER

SYMC.2:	$WARN	(UDS,<Undefined>,E.SYM)	;NOT A FEATURE DEPENDENT SYMBOL
	JRST	SYMC.4			;ONWARD

SYMC.3:	$WARN	(MDS,<Multiply defined>,E.SYM)

SYMC.4:	AOBJN	P1,SYMC.1		;LOOP
	MOVE	T1,M.CPU		;GET COUNT OF CPUS
	CAIG	T1,1			;HAVE MORE THAN ONE?
	TLZA	F,(FL.SMP)		;NO--TURN OFF SMP SUPPORT
	TLO	F,(FL.SMP)		;TURN ON SMP

SYMC.X:	$INFO	(NSL,<>,E.NSL)		;TYPE SUMMARY
	POPJ	P,			;RETURN
E.LSF:	MOVE	T1,MAPPTR##		;GET POINTER TO RETURNED DATA BLOCK
	MOVEI	T1,.MPAFS##(T1)		;POINT TO THE FILESPEC
	PJRST	.TSTRG##		;TYPE IT AND RETURN

E.MON:	MOVEI	P1,MONTAB		;POINT TO TABLE
	PUSHJ	P,GTBS			;GET MONITOR NAME, BUILD DATE, VERSION
	MOVEI	T1,MONNAM		;POINT TO MONITOR'S NAME
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVEI	T1,[ASCIZ |", built on |];GET TEXT
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVEI	T1,MONDAT		;POINT TO DATE
	PJRST	.TSTRG##		;TYPE IT AND RETURN

E.NSL:	MOVE	T1,FOUND		;GET SYMBOLS FOUND
	PUSHJ	P,.TDECW##		;TYPE IT
	MOVE	T1,FOUND		;GET COUNT AGAIN
	CAMN	T1,SYMREQ		;GOT ALL WE NEED?
	JRST	E.NSL1			;YES
	MOVEI	T1,[ASCIZ | symbols loaded out of |]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	MOVE	T1,SYMREQ		;GET NUMBER NEEDED
	PUSHJ	P,.TDECW##		;TYPE IT
	JRST	E.NSL2			;ONWARD

E.NSL1:	MOVEI	T1,[ASCIZ | symbols loaded|] ;ASSUME NO PROBLEMS
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	JUMPE	P2,.POPJ##		;RETURN IF NO ERRORS

E.NSL2:	MOVEI	T1,[ASCIZ |; |]		;POINT TO TEXT
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVE	T1,P2			;GET COUNT OF ERRORS
	MOVEI	T2,[ASCIZ |error|]	;GET TEXT
	PUSHJ	P,.TPLRS##		;TYPE IT
	MOVEI	T1,[ASCIZ | detected|]	;GET FINAL TEXT
	PJRST	.TSTRG##		;TYPE IT AND RETURN

E.SYM:	AOS	P2			;COUNT THE ERROR
	MOVEI	T1,[ASCIZ | symbol |]	;GET TEXT
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVE	T1,SYMTAB(P1)		;GET SYMBOL NAME

TRDX50:	IDIVI	T1,50			;DIVIDE BY RADIX
	PUSH	P,T2			;SAVE REMAINDER
	SKIPE	T1			;DONE?
	PUSHJ	P,TRDX50		;NO--RECURSE
	POP	P,T1			;GET CHARACTER BACK
	JUMPE	T1,.TSPAC##		;SHOW EMBEBDED SPACES
	ADDI	T1,260-1
	CAILE	T1,271
	ADDI	T1,301-272
	CAILE	T1,332
	SUBI	T1,334-244
	CAIN	T1,243
	MOVEI	T1,256
	PJRST	.TCHAR##		;TYPE CHARACTER AND RETURN
; Macro to build parallel tables of monitor symbol names and values
DEFINE	SYMS,<

;	Feature	, Name	,     Flag
SYMBOL	1	,ACCADT	,
SYMBOL	1	,ACCALC	,
SYMBOL	1	,ACCCNT	,
SYMBOL	1	,ACCDEL	,
SYMBOL	1	,ACCPPB	,
SYMBOL	1	,ACCPRV	,
SYMBOL	1	,ACCSTS	,
SYMBOL	1	,ACCWRT	,
SYMBOL	1	,ACPDEL	,
SYMBOL	1	,ACMCNT	,
SYMBOL	1	,ACPCNT	,
SYMBOL	1	,ACPSMU	,
SYMBOL	1	,ASSCON	,
SYMBOL	1	,ASSPRG	,
SYMBOL	1	,CHNQUL	,
SYMBOL	1	,CHYSCN	,
SYMBOL	1	,CORXTR	,
SYMBOL	1	,DEVCHR	,
SYMBOL	1	,DEVEXT	,
SYMBOL	1	,DEVFIL	,
SYMBOL	1	,DEVHCW	,
SYMBOL	1	,DEVIOS	,
SYMBOL	1	,DEVJOB	,
SYMBOL	1	,DEVLOG	,
SYMBOL	1	,DEVMOD	,
SYMBOL	1	,DEVNAM	,
SYMBOL	1	,DEVNET	,FL.ANF10
SYMBOL	1	,DEVNPD	,FL.ANF10
SYMBOL	1	,DEVPPN	,
SYMBOL	1	,DEVREL	,
SYMBOL	1	,DEVSER	,
SYMBOL	1	,DEVSPL	,
SYMBOL	1	,DIFNAL	,
SYMBOL	1	,DSCHWC	,
SYMBOL	1	,DVCNET	,
SYMBOL	1	,ENTRB	,
SYMBOL	1	,EV.D60	,
SYMBOL	1	,EV.DCN	,
SYMBOL	1	,EV.DMR	,
SYMBOL	1	,EV.DTE	,
SYMBOL	1	,EV.FEI	,
SYMBOL	1	,EV.FEO	,
SYMBOL	1	,EV.IPC	,
SYMBOL	1	,EV.KDP	,
SYMBOL	1	,EV.LBL	,
SYMBOL	1	,EV.NET	,
SYMBOL	1	,EV.NTC	,
SYMBOL	1	,EV.REW	,
SYMBOL	1	,EV.STC	,
SYMBOL	1	,EV.TKW	,
SYMBOL	1	,FS.BMK	,
SYMBOL	1	,FS.NMK	,
SYMBOL	1	,IBLK	,
SYMBOL	1	,IBUFB	,
SYMBOL	1	,ICLOSB	,
SYMBOL	1	,INBFB	,
SYMBOL	1	,INPB	,
SYMBOL	1	,IO	,
SYMBOL	1	,IOSUPR	,
SYMBOL	1	,JBPSCN	,
SYMBOL	1	,JBPSYS	,
SYMBOL	1	,JBPUFB	,
SYMBOL	1	,JBPXSY	,
SYMBOL	1	,KDBCAM	,
SYMBOL	1	,LDBDDB	,
SYMBOL	1	,LDBECC	,
SYMBOL	1	,LDBHPS	,
SYMBOL	1	,LDBMIC	,
SYMBOL	1	,LDBNRT	,FL.DECNET
SYMBOL	1	,LDBPAG	,
SYMBOL	1	,LDBREM	,
SYMBOL	1	,LDBTIC	,
SYMBOL	1	,LDBTTW	,
SYMBOL	1	,LDPBKA	,
SYMBOL	1	,LDPECH	,
SYMBOL	1	,LDPFCS	,
SYMBOL	1	,LDPLNB	,
SYMBOL	1	,LDPLNC	,
SYMBOL	1	,LDPNRT	,FL.DECNET
SYMBOL	1	,LDPOSU	,
SYMBOL	1	,LDPSTB	,
SYMBOL	1	,LDPSTC	,
SYMBOL	1	,LDPSTP	,
SYMBOL	1	,LDPTTT	,
SYMBOL	1	,LDPWID	,
SYMBOL	1	,LD.CIP	,
SYMBOL	1	,LD.MAX	,FL.DECNET
SYMBOL	1	,LN.LIB	,
SYMBOL	1	,LNPOVR	,
SYMBOL	1	,LOOKB	,
SYMBOL	FTLGNQ	,LQ.LDB	,FL.LGNQ
SYMBOL	FTLGNQ	,LQ.PLI	,FL.LGNQ
SYMBOL	1	,LRLCON	,
SYMBOL	1	,LRLDSR	,
SYMBOL	1	,LTLANF	,
SYMBOL	1	,LTLUSE	,
SYMBOL	1	,M.CPU	,
SYMBOL	1	,NMBACC	,
SYMBOL	1	,NMBNAM	,
SYMBOL	1	,NMBPPB	,
SYMBOL	1	,NMPUPT	,
SYMBOL	1	,NN.DLY	,FL.DECNET
SYMBOL	1	,NN.LKC	,FL.DECNET
SYMBOL	1	,NN.NXT	,FL.DECNET
SYMBOL	1	,NR.CHN	,FL.DECNET
SYMBOL	1	,NPDNAM	,
SYMBOL	1	,NPDNLN	,
SYMBOL	1	,NPDNOD	,
SYMBOL	1	,NT%DLA	,FL.ANF10
SYMBOL	1	,NT%SLA	,FL.ANF10
SYMBOL	1	,OBLK	,
SYMBOL	1	,OBUFB	,
SYMBOL	1	,OCLOSB	,
SYMBOL	1	,OUTBFB	,
SYMBOL	1	,OUTPB	,
SYMBOL	1	,PPBNAM	,
SYMBOL	1	,RC.LID	,FL.DECNET
SYMBOL	1	,RNLCL	,FL.DECNET
SYMBOL	1	,RNRCH	,FL.DECNET
SYMBOL	1	,SP.CJA	,FL.SMP
SYMBOL	1	,STPPVS	,
SYMBOL	1	,STRBSC	,
SYMBOL	1	,STRJOB	,
SYMBOL	1	,STRMNT	,
SYMBOL	1	,STRNAM	,
SYMBOL	1	,STRPPN	,
SYMBOL	1	,STRPVS	,
SYMBOL	1	,STRTAL	,
SYMBOL	1	,STRUNI	,
SYMBOL	1	,TDVSTS	,
SYMBOL	1	,TDVUDB	,
SYMBOL	1	,TKSOFL	,
SYMBOL	1	,TKSSEL	,
SYMBOL	1	,TKSSTD	,
SYMBOL	1	,TOP.RT	,
SYMBOL	1	,TTYOUW	,
SYMBOL	1	,TUBCNF	,
SYMBOL	1	,TUBFIL	,
SYMBOL	1	,TUBLBL	,
SYMBOL	1	,TUBREC	,
SYMBOL	1	,TUBRID	,
SYMBOL	1	,TUBSTS	,
SYMBOL	1	,TUSBOT	,
SYMBOL	1	,TUSNS	,
SYMBOL	1	,TUSREW	,
SYMBOL	1	,TUSWTL	,
SYMBOL	1	,UDBNAM	,
SYMBOL	1	,UDBPDN	,
SYMBOL	1	,UNI2ND	,
SYMBOL	1	,UNIALT	,
SYMBOL	1	,UNIBPM	,
SYMBOL	1	,UNIBPU	,
SYMBOL	1	,UNIBRC	,
SYMBOL	1	,UNIBUC	,
SYMBOL	1	,UNIBWC	,
SYMBOL	1	,UNICBK	,
SYMBOL	1	,UNICHN	,
SYMBOL	1	,UNICHR	,
SYMBOL	1	,UNICRC	,
SYMBOL	1	,UNICRH	,
SYMBOL	1	,UNICWC	,
SYMBOL	1	,UNICWH	,
SYMBOL	1	,UNICYL	,
SYMBOL	1	,UNIDRC	,
SYMBOL	1	,UNIDWC	,
SYMBOL	1	,UNIHID	,
SYMBOL	1	,UNIKON	,
SYMBOL	1	,UNILOG	,
SYMBOL	1	,UNIMRC	,
SYMBOL	1	,UNIMWC	,
SYMBOL	1	,UNIMSC	,
SYMBOL	1	,UNIQUL	,
SYMBOL	1	,UNISTR	,
SYMBOL	1	,UNITAL	,
SYMBOL	1	,UNIUSC	,
SYMBOL	1	,UNIXRA	,
SYMBOL	1	,UNYK4S	,
SYMBOL	1	,UNYKNM	,
SYMBOL	1	,UNYSPU	,
SYMBOL	1	,UNYWPS	,
SYMBOL	1	,$NNNOD	,FL.DECNET
SYMBOL	1	,$SJCHT	,FL.DECNET
SYMBOL	1	,$SLDNA	,FL.DECNET
SYMBOL	1	,.FSEND	,
SYMBOL	1	,.FSFNC	,
SYMBOL	1	,.FSMAX	,
SYMBOL	1	,.FSMIN	,

>
DEFINE	SYMBOL	(FET,NAME,FLAG),<IFN FET,<RADIX50	0,NAME>>

SYMTAB:	SYMS
SYMLEN==.-SYMTAB


DEFINE	SYMBOL	(FET,NAME,FLAG),<IFN FET,<EXP	0+FLAG>>

FLGTAB:	SYMS
WEHSEG:	TDZA	T1,T1			;WRITE LOCK
WLHSEG:	MOVEI	T1,1			;WRITE ENABLE
	SETUWP	T1,			;...
	  $STOP	(HWP,<Cannot set/clear high segment write protect>)
	POPJ	P,			;RETURN
GTBS:	SKIPN	T1,0(P1)		;GET A GETTAB ARGUMENT
	POPJ	P,			;DONE
	PUSHJ	P,.MAPG##		;...
	  SETZ	T1,			;STRANGE MONITOR
	MOVEM	T1,@1(P1)		;SAVE A WORD
	ADDI	P1,2			;ACCOUNT FOR TWO WORD ENTRIES
	JRST	GTBS			;LOOP


; Monitor name and build date
MONTAB:	EXP	%CNFG0,MONNAM+0
	EXP	%CNFG1,MONNAM+1
	EXP	%CNFG2,MONNAM+2
	EXP	%CNFG3,MONNAM+3
	EXP	%CNFG4,MONNAM+4
	EXP	%CNDT0,MONDAT+0
	EXP	%CNDT1,MONDAT+1
	EXP	%CNVER,LODONC
	EXP	%CNDVN,DECONC
	EXP	%CNCVN,CUSONC
	EXP	0			;TERMINATE LIST
SUBTTL	Set up special high segment data


HIDATA:!

; Charge number
CHGINI:	MOVE	T1,[.GTCNO,,.GTSLF]	;GETTAB TO GET THE BASE OF THE
	PUSHJ	P,.MAPG##		; CHARGE NUMBER TABLE
	  MOVEI	T1,0			;NOT THERE
	SKIPN	T1			;HAVE CHARGE NUMBERS?
	TLZA	F,(FL.CHARGE)		;NO
	TLO	F,(FL.CHARGE)		;YES


; ANF-10 networks
ANFINI:	TLNN	F,(FL.ANF10)		;HAVE ANF10 SUPPORT?
	JRST	DCNINI			;NO


; DECnet-10 networks
DCNINI:	TLNN	F,(FL.DECNET)		;HAVE DECNET SUPPORT?
	JRST	LGQINI			;NO


; LOGIN queue
LGQINI:	TLNN	F,(FL.LGNQ)		;HAVE LOGIN QUEUE SUPPORT?
	JRST	HIDATX			;NO
IFN FTLGNQ,<
> ;END IFN FTLGNQ


HIDATX:	MOVE	T1,F			;COPY FLAGS
	AND	T1,[FL.FEATURES]	;KEEP ONLY FEATURE FLAGS
	MOVEM	T1,FEATURES		;SAVE FOR RUN TIME
	POPJ	P,			;RETURN
SUBTTL	Set up initialization text

INISET:	MOVE	T1,[INITXT##,,INITXT##+1] ;SET UP BLT
	SETZM	T1,INITXT##		;CLEAR FIRST WORD
	BLT	T1,INITXT##+LN$INI-1	;CLEAR TEXT BLOCK
	MOVEI	T1,INITYO		;POINT TO CHARACTER STICKER
	PUSHJ	P,.TYOCH##		;TELL SCAN
	PUSH	P,T1			;SAVE OLD TYPER
	MOVE	T1,[POINT 7,$$NAME##]	;BYTE POINTER TO TEXT

INIS.1:	MOVE	T2,T1			;COPY POINTER
	ILDB	T3,T1			;GET A CHARACTER
	JUMPN	T3,INIS.1		;LOOP 'TILL WE FIND START OF INITXT
	MOVEI	T1," "			;GET A SPACE

INIS.2:	DPB	T1,T2			;STORE A SPACE
	ILDB	T3,T2			;GET NEXT CHARACTER
	JUMPE	T3,INIS.2		;LOOP

INIS.3:	MOVE	T1,[POINT 7,INITXT##]	;BYTE POINTER TO STORAGE
	MOVEM	T1,INIPTR		;SAVE IT
	MOVEI	T1,<LN$INI*5>-1		;NUMBER OF CHARACTERS
	MOVEM	T1,INICNT		;SAVE IT
	MOVEI	T1,[ASCIZ |WHO version |];OUR NAME
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVE	T1,.JBVER		;OUR VERSION NUMBER
	PUSHJ	P,.TVERW##		;TYPE IT
	MOVEI	T1,[ASCIZ | configured on |]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	PUSHJ	P,.TDATN##		;TYPE TODAYS DATE
	PUSHJ	P,.TCRLF##		;NEW LINE
	MOVEI	T1,[ASCIZ |	for TOPS10 version |]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	MOVE	T1,DECONC		;GET VERSION
	PUSHJ	P,.TVERW##		;TYPE IT
	SKIPN	CUSONC			;HAVE CUSTOMER VERSION?
	JRST	INIS.4			;NO
	MOVEI	T1,"/"			;SEPARATOR
	PUSHJ	P,.TCHAR##		;TYPE IT
	MOVE	T1,CUSONC		;GET CUSTOMER VERSION
	PUSHJ	P,.TVERW##		;TYPE IT

INIS.4:	MOVEI	T1,[ASCIZ |, load |]	;GET TEXT
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVE	T1,LODONC		;GET LOAD NUMBER
	PUSHJ	P,.TOCTW##		;TYPE IT
	PUSHJ	P,.TCRLF##		;NEW LINE
	MOVEI	T1,[ASCIZ |	from file |]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	MOVE	T1,MAPPTR##		;GET POINTER TO RETURNED DATA BLOCK
	MOVEI	T1,.MPAFS##(T1)		;POINT TO THE FILESPEC
	PUSHJ	P,.TSTRG##		;TYPE FILE SPEC
	PUSHJ	P,.TCRLF##		;NEW LINE
	MOVEI	T1,[ASCIZ |	monitor is "|]
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	MOVEI	T1,MONNAM		;POINT TO NAME
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVEI	T1,[ASCIZ |", built on |];SEPARATOR
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVEI	T1,MONDAT		;POINT TO BUILD DATE
	PUSHJ	P,.TSTRG##		;TYPE IT

INIXIT:	POP	P,T1			;RESTORE OLD CHARACTER STICKER
	PJRST	.TYOCH##		;TELL SCAN AND RETURN


INITYO:	SOSLE	INICNT			;COUNT CHARACTERS
	IDPB	T1,INIPTR		;STORE BYTE
	POPJ	P,			;RETURN
SUBTTL	Save file handlind -- Set up


SAVSET:	MOVE	T1,[FOPBLK,,FOPBLK+1]	;SET UP BLT
	SETZM	FOPBLK			;CLEAR FIRST WORD
	BLT	T1,FOPBLK+.FOMAX-1	;CLEAR ENTIRE BLOCK
	MOVE	T1,[FO.PRV!FO.ASC+.FOWRT] ;USE PRIVS/ASSIGN A CHANNEL/WRITE
	MOVEM	T1,FOPBLK+.FOFNC	;SAVE FUNCTION WORD
	MOVEI	T1,LERBLK		;GET ENTER BLOCK
	MOVEM	T1,FOPBLK+.FOLEB	;SAVE ADDR
	MOVE	T1,[.PTMAX,,PTHBLK]	;POINT TO RETURNED PATH BLOCK
	MOVEM	T1,FOPBLK+.FOPAT	;SAVE ADDR
	MOVE	T1,[.FOFMX,,FILBLK]	;POINT TO RETURNED FILESPEC BLOCK
	MOVEM	T1,FOPBLK+.FOFSP	;SAVE ADDR
	MOVE	T1,[LERBLK,,LERBLK+1]	;SET UP BLT
	SETZM	LERBLK			;CLEAR FIRST WORD
	BLT	T1,LERBLK+.RBMAX-1	;CLEAR ENTIRE BLOCK
	MOVEI	T1,.RBMAX		;GET BLOCK LENGTH
	MOVEM	T1,LERBLK		;SET IT
	MOVEI	T1,PTHBLK		;POINT TO PATH BLOCK
	MOVEM	T1,LERBLK+.RBPPN	;SET ADDR

	MOVE	T1,[PTHBLK,,PTHBLK+1]	;SET UP BLT
	SETZM	PTHBLK			;CLEAR FIRST WORD
	BLT	T1,PTHBLK+.PTMAX-1	;CLEAR ENTIRE BLOCK

	MOVE	T1,[.FXLEN,,SAVSCB]	;LENGTH,,SCAN BLOCK ADDR
	MOVEI	T2,FOPBLK+.FOIOS	;OPEN BLOCK
	MOVEI	T3,LERBLK		;ENTER BLOCK
	MOVEI	T4,PTHBLK		;PATH BLOCK
	PUSHJ	P,.STOPB##		;LOAD THE UUO BLOCKS
	  JRST	SAV.E1			;PROCESS ERROR
	MOVEI	T1,.IODMP		;DUMP MODE
	IORM	T1,FOPBLK+.FOIOS	;SET IT
	MOVE	T1,[.FOMAX,,FOPBLK]	;POINT TO FILOP BLOCK
	FILOP.	T1,			;TRY TO ENTER THE FILE
	  JRST	SAV.E2			;CAN'T
	LDB	T1,[POINTR (FOPBLK+.FOFNC,FO.CHN)] ;GET RETURNED CHANNEL NUMBER
	RESDV.	T1,			;TOSS THE FILE
	  JFCL				;...
SAVS.1:	SKIPN	T1,FILBLK+.FOFDV	;GET RETURNED DEVICE
	MOVE	T1,PTHBLK+.PTSTR	;USE THE ONE FROM PATH BLOCK INSTEAD
	MOVEM	T1,SAVBLK+0		;SAVE IT
	MOVEM	T1,SAVSCB+.FXDEV	;HERE TOO
	SKIPN	T1,FILBLK+.FOFFN	;GET RETURNED FILE NAME
	MOVE	T1,LERBLK+.RBNAM	;USE THE ONE WE GAVE INSTEAD
	MOVEM	T1,SAVBLK+1		;SAVE IT
	MOVEM	T1,SAVSCB+.FXNAM	;HERE TOO
	SETOM	SAVSCB+.FXNMM		;SET MASK
	HLLZ	T1,FILBLK+.FOFEX	;GET RETURNED EXTENSION
	SKIPN	T1			;HAVE ONE?
	HLLZ	T1,LERBLK+.RBEXT	;USE THE ONE WE SPECIFIED
	MOVEM	T1,SAVBLK+2		;SAVE IT
	HLLOM	T1,SAVSCB+.FXEXT	;HERE TOO
	SKIPN	T1,FILBLK+.FOFPP	;GET RETURNED PPN
	MOVE	T1,PTHBLK+.PTPPN	;USE THE ONE FROM RETURNED PATH
	MOVEM	T1,SAVPTH+.PTPPN	;SAVE IT
	MOVEM	T1,SAVSCB+.FXDIR	;HERE TOO
	SETOM	SAVSCB+.FXDIM		;SET MASK
	MOVEI	T1,FILBLK+.FOFPP+1	;POINT TO FIRST RETURNED SFD
	SKIPN	FILBLK+.FOFDV		;REASONABLE RETURNED DATA?
	MOVEI	T1,PTHBLK+.PTSFD	;NO--USE THE PATH BLOCK
	HRLI	T1,-<.PTMAX-.PTSFD-1>	;GET -LENGTH
	MOVEI	T2,SAVPTH		;POINT TO TEMPORARY STORAGE
	MOVEI	T3,SAVSCB		;POINT TO THE SCAN BLOCK

SAVS.2:	MOVE	T4,(T1)			;GET AN SFD
	MOVEM	T4,.PTSFD(T2)		;PUT AN SFD
	MOVEM	T4,.FXDIR+2(T3)		;SAVE IN SCAN BLOCK
	SETOM	.FXDIM+2(T3)		;SET MASK
	ADDI	T2,1			;POINT TO NEXT PATH BLOCK STORAGE
	ADDI	T3,2			;POINT TO NEXT SCAN BLOCK STORAGE
	AOBJN	T1,SAVS.2		;LOOP
	JRST	.POPJ1##		;RETURN
SAV.E1:	$WARN	(WCS,<Wildcards illegal in save file specification>)
	POPJ	P,			;RETURN

SAV.E2:	HRL	T1,LERBLK+.RBEXT	;GET ERROR CODE
	TLNN	T1,777777		;SAVE AN ERROR CODE WHERE IT SHOULD BE?
	HRRM	T1,LERBLK+.RBEXT	;NO--USE WHAT FILOP RETURNED
	$WARN	(SEF,<Save file enter failure >,SAV.E3)
	POPJ	P,			;RETURN

SAV.E3:	HRRZ	T1,LERBLK+.RBEXT	;GET ERROR CODE
	PUSHJ	P,.TOCTW##		;TYPE IT
	MOVEI	T1,[ASCIZ | for |]	;GET SEPARATOT
	PUSHJ	P,.TSTRG##		;TYPE IT
	MOVEI	T1,FOPBLK+.FOIOS	;POINT TO ENBEDDED OPEN BLOCK
	MOVEI	T2,LERBLK		;POINT TO ENTER BLOCK
	PJRST	.TOLEB##		;TYPE FILESPEC AND RETURN
SAVER:	$INFO	(SAV,<Saving WHO core image on >,E.SAV);TELL WHERE .EXE FILE IS
	SETZ	T1,			;CAN'T USE A PATH BLOCK
					; THIS BLETCHEROUS KROCK IS TO KEEP
					; A "ZERO'ED" LOW SEG, YET STILL LET
					; THE SAVE. BE USED TO SAVE WHO (AND
					; NOT BREAK .CTL FILES). UNFORTUNATELY,
					; A PATH BLOCK CAN'T BE IN THE HISEG
					; (ADDR CHECK), THE ACS (GET TROUNCED
					; BY SAVGET), OR JOBDAT (ILL ADDR IN
					; UUO)).
	MOVEM	T1,SAVBLK+4		;SAVE PATH BLOCK ADDRESS
	SETZM	SAVPTH+.PTFCN		;CLEAR OUT FUNCTION WORD
	SETZM	SAVPTH+.PTSWT		;CLEAR OUT FLAGS
	SETZM	SAVPTH+.PTMAX-1		;FORCIBLY TERMINATE PATH BLOCK

SAVE.1:	MOVEI	T1,SAVBLK		;POINT TO THE ARGUMENT BLOCK
	SKIPN	DDTFLG			;KEEPING DDT?
	TLO	T1,(SS%SSH)		;NO--MAKE IT SHARABLE
	MOVEM	T1,SAVARG		;SAVE THE SAVE. UUO AC

SAVE.2:	SKIPN	T1,DDTFLG		;GET END OF DDT
	MOVEI	T1,WHOONC		;OR NORMAL END OF OUR LOW SEG
	MOVEM	T1,CORARG		;SAVE FOR CORE UUO
	SKIPN	T2,DDTFLG		;GET END OF DDT
	MOVEI	T2,.JBDA		;ELSE WILL CLEAR ENTIRE LOW SEG
	HRLI	T2,1(T2)		;T2 = ADDR+1,,ADDR
	MOVSM	T2,BLTARG		;SAVE BLT AC

SAVE.3:	HRRM	T1,.JBFF		;RESET .JBFF
	HRLM	T1,.JBSA		;AND THE SAVED COPY TOO
	SKIPE	DDTFLG			;KEEPING DDT?
	SKIPA	T1,CORARG		;YES--GET LAST ADDR IN LOW SEGMENT
	MOVEI	T1,.JBDA-1		;ELSE MAKE SURE WE HAVE A NULL LOW SEG
	HRLM	T1,.JBCOR		;FIX UP FOR SAVGET
	MOVEI	T1,WHO##		;POINT TO NEW START ADDRESS
	HRRM	T1,.JBSA		;SET IT
	SKIPE	T2,HGHORG		;GET HIGH SEG ORIGIN
	HRRM	T1,.JBHSA(T2)		;SAVE IN HIGH SEG TOO

SAVE.4:	SKIPE	DDTFLG			;KEEPING DDT?
	JRST	SAVE.5			;YES
	SETZ	T1,			;CLEAR AC
	SETDDT	T1,			;CLEAR .JBDDT ADDR IN PROTECTED JOBDAT

SAVE.5:	SKIPE	SYMFLG			;KEEPING SYMBOLS?
	JRST	SAVE.6			;YES
	SETZM	.JBSYM			;CLEAR LOW SEG TABLE POINTER
	SETZM	.JBUSY			;CLEAR UNDEFINED SYMBOL TABLE POINTER
	SKIPN	T1,HGHORG		;GET HIGH SEG ORIGIN
	JRST	SAVE.6			;NO HIGH SEG
	HRRZ	T2,.JBHRL		;GET HIGHEST ADDRESS IN HIGH SEGMENT
	HLRE	T3,.JBHSM(T1)		;GET -LENGTH OF SYMBOL TABLE
	ADD	T2,T3			;COMPUTE NEW HIGH SEG END ADDRESS
	HRRM	T2,.JBHRL		;SAVE IT
	HRLM	T2,CORARG		;SAVE FOR CORE UUO TOO

SAVE.6:	SETOM	ONCFLG			;FLAG END OF ONCE-ONLY CODE
	PUSHJ	P,WLHSEG		;WRITE LOCK THE HIGH SEGMENT
	MOVE	T1,SAVBLK+1		;GET SAVE FILE NAME
	SETNAM	T1,			;MAKE THAT OUR PROGRAM NAME
	MOVE	T1,[SAVBLT,,.JBBLT]	;BLT POINTER TO
	BLT	T1,.JBBLT+2		;SET UP FOR SAVE. UUO
	HLRZ	T1,BLTARG		;GET FIRST ADDRESS TO ZERO
	SETZM	(T1)			;CLEAR IT NOW
	MOVSI	17,SAVLOW		;SET UP BLT
	BLT	17,17			;COPY EXIT CODE
	JRST	SAVGO			;GO SAVE OUR CORE IMAGE

SAVBLT:	SAVE.	2,			;.JBBLT+0 - SAVE OUR CORE IMAGE
	  OUTSTR SAVERR			;.JBBLT+1 - COMPLAIN
	EXIT				;.JBBLT+2 - EXIT TO MONITOR

SAVLOW:!PHASE	0
SAVGO:!	MOVE	0,CORARG		; 0 - GET CORE UUO AC
	MOVE	1,BLTARG		; 1 - GET BLT AC
	MOVE	2,SAVARG		; 2 - GET SAVE. UUO AC
	CORE	0,			; 3 - SHRINK CORE
	  JFCL				; 4 - IGNORE FAILURE
	HRR	.+1,.JBREL		; 5 - WHERE TO STOP
	BLT	1,0			; 6 - CLEAR CORE
	JRST	.JBBLT			; 7 - SAVE AND EXIT
	EXP	0			;10 - FREE AC
	EXP	0			;11 - FREE AC
	EXP	0			;12 - FREE AC
	EXP	0			;13 - FREE AC
	EXP	0			;14 - FREE AC
	EXP	0			;15 - FREE AC
	EXP	0			;16 - FREE AC
	EXP	0			;17 - FREE AC
SAVEND:!DEPHASE

E.SAV:	MOVEI	T1,SAVSCB		;POINT TO SCAN BLOCK
	PJRST	.TFBLK##		;TYPE IT AND RETURN
O.ZBEG:!			;START OF BLOCK TO ZERO

ONCPDL:	BLOCK	ONCPDS		;ONCE-ONLY PUSH DOWN LIST
BYTPTR:	BLOCK	1		;RANDOM BYTE POINTER
BYTCNT:	BLOCK	1		;RANDOM BYTE COUNT
FOUND:	BLOCK	1		;COUNT OF NUMBER OF SYMBOLS FOUND
SYMREQ:	BLOCK	1		;NUMBER OF SYMBOLS REQUIRED
REFTAB:	BLOCK	SYMLEN		;REFERENCE TABLE
MONNAM:	BLOCK	5		;MONITOR NAME
MONDAT:	BLOCK	2		;MONITOR BUILD DATE
HLPLVL:	BLOCK	1		;HELP TEXT LEVEL
HLPPRS:	BLOCK	1		;HELP TEXT LEVEL FOR /HELP DURING PARSE
ANSWER:	BLOCK	1		;RESPONSE
BTSSCB:	BLOCK	.FXLEN		;SCAN BLOCK FOR BOOTSTRAP FILESPEC
MONSCB:	BLOCK	.FXLEN		;SCAN BLOCK FOR MONITOR FILE
SAVSCB:	BLOCK	.FXLEN		;SCAN BLOCK FOR SAVE FILE
HGHORG:	BLOCK	1		;HIGH SEGMENT ORIGIN
DDTFLG:	BLOCK	1		;DDT PRESENT (NOT VMDDT)
SYMFLG:	BLOCK	1		;SYMBOL TABLE PRESENT
FOPBLK:	BLOCK	.FOMAX		;SCRATCH FILOP BLOCK
LERBLK:	BLOCK	.RBMAX		;SCRATCH LOOKUP/ENTER BLOCK
PTHBLK:	BLOCK	.PTMAX		;SCRATCH PATH BLOCK
FILBLK:	BLOCK	.FOFMX		;SCRATCH RETURNED FILESPEC BLOCK
SAVPTH:	BLOCK	.PTMAX		;SAVE FILE PATH BLOCK
DEFINT:	BLOCK	1		;FLAG NON-ZERO TO DEFAULT INTERNAL PARAMETERS
DEFUSR:	BLOCK	1		;FLAG NON-ZERO TO DEFAULT USER PARAMETERS
DEFFLG:	BLOCK	1		;FLAG NON-ZERO TO DEFAULT PARAMETERS
INICNT:	BLOCK	1		;BYTE COUNT FOR INITIALIZATION TEXT
INIPTR:	BLOCK	1		;BYTE POINTER TO INITIALIZATION TEXT
CORARG:	BLOCK	1		;CORE UUO ARGUMENT
BLTARG:	BLOCK	1		;BLT AC
SAVARG:	BLOCK	1		;SAVE. UUO ARGUMENT

O.ZEND:!			;END OF BLOCK TO ZERO

	$HIGH

SAVERR:	ASCIZ	|
? SAVE. UUO failed.
|

DEFINE	SYMBOL	(FET,NAME,FLAG),<IFN FET,<NAME::BLOCK	1>>

VALTAB::!SYMS
ONCFLG:: BLOCK	1		;ONCE-ONLY INITIALIZATION FLAG
FEATUR:: BLOCK	1		;FEATURE FLAGS
DECONC:: BLOCK	1		;DEC VERSION
CUSONC:: BLOCK	1		;CUSTOMER VERSION
LODONC:: BLOCK	1		;LOAD NUMBER
CHGTYO:: BLOCK	1		;CHARGE NUMBER TYPEOUT ROUTINE
SAVBLK:	 BLOCK	6		;SAVE. UUO BLOCK

	$LOW

	LIT


	END	WHOONC
