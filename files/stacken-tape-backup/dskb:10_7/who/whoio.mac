	TITLE	WHOIO - I/O routines for WHO

	SEARCH	WHOMAC

	$SETUP	(WHOIO)

Comment	|

This module contains the low level I/O routines required for WHO.
Included are routines to open a file, close a file, and a character
output/dispatch routine.

|
;               TABLE OF CONTENTS FOR WHOIO
;
;
;                        SECTION                                   PAGE
;    1. File routines
;         1.1   OPNDPY - Open terminal for DPY mode...............   3
;         1.2   OPNLST - Open the output (list) file..............   3
;         1.3   CHKFIL - See if file spec message wanted..........   4
;         1.4   CLSLST - Close the output (list) file.............   5
;         1.5   CHKLST - Check the list device for my TTY:........   6
;    2. Character routines
;         2.1   CHRLST - Output one character to the list file....   7
;         2.2   ERRCHR - Output a error character.................   7
;    3. Storage...................................................   8
	SUBTTL	File routines -- OPNDPY - Open terminal for DPY mode

;This routine opens the physical terminal with the echo turned off

OPNDPY::MOVX	T1,UU.PHS!IO.SUP	;NO ECHO, PHYSICAL ONLY
	IORM	T1,O.FILOP+.FOIOS	;..
	MOVSI	T1,'TTY'		;INSURE TTY:
	MOVEM	T1,O.FILOP+.FODEV	;FOR DPY MODE
					;FALL INTO OPNLST

	SUBTTL	File routines -- OPNLST - Open the output (list) file

;This routine opens the output file as specified by the FILOP. block

OPNLST::PUSHJ	P,.SAVT4##		;SAVE T1-T4
	MOVE	T1,[LST,,.FOWRT]	;ASSUME WRITE
	SKIPG	S.APPEND##		;SEE IF /APPEND
	 TRNE	F,FR.APPEND		;SEE IF BEEN HERE BEFORE
	  HRRI	T1,.FOAPP		;YES--USE APPEND
	SKIPE	PRVFLG			;WANT TO USE PRIVS?
	TXO	T1,FO.PRV		;YES--SERVER REQUESTED THEM
	MOVEM	T1,O.FILOP+.FOFNC	;STORE
	MOVX	T1,.IOASC		;ASCII
	IORM	T1,O.FILOP+.FOIOS	;SET
	MOVSI	T1,O.BUF		;POINT TO OUTPUT BUFFERS
	MOVEM	T1,O.FILOP+.FOBRH	;STORE
	MOVSI	T1,-1			;USE DEFAULT BUFFERS
	MOVEM	T1,O.FILOP+.FONBF	;STORE
	MOVEI	T1,O.ENTER		;POINT TO ENTER BLOCK
	MOVEM	T1,O.FILOP+.FOLEB	;STORE
	MOVE	T1,[.PTMAX,,O.PATH]	;POINT TO PATH. BLOCK
	MOVEM	T1,O.FILOP+.FOPAT	;STORE
	MOVEI	T1,LN$LEN-1		;GET ENTER LENGTH
	IORM	T1,O.ENTER+.RBCNT	;SET
	MOVEI	T1,O.FILOP+.FOIOS	;POINT TO "OPEN" BLOCK
	DEVSIZ	T1,			;FIND DEVICE SIZE
	 MOVE	T1,[2,,203]		;ASSUME 2 DISK BUFFERS
	HLRZ	T2,T1			;GET NUMBER OF BUFFERS
	IMULI	T1,(T2)			;COMPUTE SIZE
	PUSHJ	P,C$ALLOC##		;ALLOCATE CORE
	PUSH	P,.JBFF			;SAVE .JBFF
	MOVEM	T1,.JBFF		;FAKE FILOP.
	MOVE	T1,[.FOPAT+1,,O.FILOP]	;POINT TO BLOCK
	FILOP.	T1,			;DO IT
	  JRST	OPNE.1			;ERROR
	POP	P,.JBFF			;RESTORE .JBFF
	PUSHJ	P,CHKFIL		;SEE IF WANTS FILE SPEC
	TRO	F,FR.OPEN!FR.APPEND	;FLAG TO USE APPEND NEXT TIME
	POPJ	P,			;AND RETURN

OPNE.1:	HRRM	T1,O.ENTER+.RBEXT	;STORE ERROR CODE
	MOVEI	T1,O.FILOP		;POINT TO FILOP. BLOCK
	$FATAL	(OEE,<>,.TERRF##)	;TYPE ERROR AND DIE
	SUBTTL	File routines  -- CHKFIL - See if file spec message wanted

CHKFIL:	TRNE	F,FR.APPEND		;APPENDING TO FILE?
	 POPJ	P,			;YES--NEVER A MESSAGE
	MOVEI	T1,LST			;GET CHANNEL
	DVCHR.	T1,			;FIND ITS CHARACTERISTICS
	TXNE	T1,DV.TTA		;CONTROLLING JOB?
	 POPJ	P,			;YES--NO MESSAGE
	TXNN	T1,DV.TTY		;CHECK FOR NUL (BOTH TTY AND DSK)
	TXNN	T1,DV.DSK		;DSK?
	 JRST	CHKF.1			;NO
	MOVEI	T1,O.PATH		;POINT TO RETURNED PATH
	MOVEM	T1,O.ENTER+.RBPPN	;STORE PATH POINTER
	MOVE	T1,O.PATH+.PTSTR	;YES--LOAD REAL STR NAME
	JRST	CHKF.2			;AND STORE
CHKF.1:	MOVEI	T1,LST			;GET CHANNEL AGAIN
	DEVNAM	T1,			;GET PHYSICAL DEVICE
	 MOVE	T1,O.OPEN+.OPDEV	;FAILED?
CHKF.2:	MOVEM	T1,O.OPEN+.OPDEV	;STORE IMPROVED DEVICE NAME
	MOVEI	T1,O.FILOP		;POINT TO FILOP. BLOCK
	TLNN	F,(FL.WHOSRV)		;ARE WE A SERVER?
	$INFO	(WLF,<WHO listing on file >,.TFLPB##)
	POPJ	P,			;AND RETURN
	SUBTTL	File routines -- UPDLST - Update the output (list) file

;This routine updates the file opened by OPNLST

UPDLST::TRNN	F,FR.OPEN		;SEE IF OUTPUT FILE OPEN
	 POPJ	P,			;NO--JUST RETURN
	MOVEI	T1,.FOURB		;GET UPDATE FUNCTION
	HRRM	T1,O.FILOP+.FOFNC	;STORE
	MOVE	T2,[1,,O.FILOP]		;POINT TO FILOP. BLOCK
	MOVEI	T1,O.FILOP		;POSITION IN CASE ERROR
	FILOP.	T2,			;UPDATE THE FILE
	  JFCL				;IGNORE FAILURES
	POPJ	P,			;AND RETURN
	SUBTTL	File routines -- CLSLST - Close the output (list) file

;This routine closes the file opened by OPNLST or OPNDPY

CLSLST::TRZN	F,FR.OPEN		;SEE IF OUTPUT FILE OPEN
	 POPJ	P,			;NO--JUST RETURN
	MOVEI	T1,.FOCLS		;GET CLOSE FUNCTION
	HRRM	T1,O.FILOP+.FOFNC	;STORE
	MOVE	T2,[1,,O.FILOP]		;POINT TO FILOP. BLOCK
	MOVEI	T1,O.FILOP		;POSITION IN CASE ERROR
	FILOP.	T2,			;CLOSE THE FILE
	  $FATAL (OCE,<>,.TCERR##)	;TYPE CLOSE ERROR AND DIE
	RELEAS	LST,			;WHAT CANT FILOP. DO IT?
	POPJ	P,			;AND RETURN
	SUBTTL	File routines -- CHKLST - Check the list device for my TTY:

CHKLST::MOVEI	T2,O.SPEC##		;POINT TO OUTPUT SPEC
	MOVE	T2,.FXMOD(T2)		;GET /PHYSICAL FROM SCAN
	TXNN	T2,FX.PHY		;SEE IF GIVEN
	TDZA	T2,T2			;NO
	MOVX	T2,UU.PHY		;YES--GET PHYSICAL UUO BIT
	MOVE	T1,O.SPEC##+.FXDEV	;GET THE DEVICE
	DVCHR.	T1,(T2)			; ..
	TXNE	T1,DV.TTA		;CONTROLLING [MY] JOB?
	TRO	F,FR.MYTTY		;YES--FLAG
	POPJ	P,			;AND RETURN
	SUBTTL	Character routines -- CHRINP - Input a character


CHRINP::TLNE	F,(FL.WHOSRV)		;ARE WE THE SERVER?
	JRST	CHRI.1			;YES--DO THINGS DIFFERENTLY
	INCHWL	C			;GET A CHARACTER FROM THE TTY
	JRST	CHRI.2			;ONWARD

CHRI.1:	PUSHJ	P,SRVTAK##		;GET A CHARACTER
	JUMPE	C,CHRI.3		;TURN NULS INTO EOF

CHRI.2:	CAIN	C,.CHBEL		;SEE IF ONE
	 MOVEI	C,.CHLFD		; OF THE
	CAIE	C,.CHFFD		;  LINE-MODE
	 CAIN	C,.CHVTB		;   WAKE-UP
	  MOVEI	C,.CHLFD		;    CHARACTERS
	TLNN	F,(FL.WHOSRV)		;ARE WE A SERVER?
	PJRST	SRVPUT##		;NO--STORE FOR SERVER AND RETURN
	CAIE	C,.CHESC		;LINE
	CAIN	C,.CHLFD		; TERMINATOR?

CHRI.3:	MOVX	C,.CHEOF		;MAKE EOL INTO EOF
	POPJ	P,			;RETURN
	SUBTTL	Character routines -- CHRLST/ERRCHR - Output one character


;This routine outputs a character to the appropriate places


ERRCHR::TLOA	T1,400000		;FLAG ERROR OUTPUT IN PROGRESS
CHRLST::TRO	F,FR.TYPE		;FLAG A CHARACTER OUTPUT
	TDNE	F,[FL.WHOSRV+FR.TASK]	;DOING TASK I/O?
	PJRST	SRVTYO##		;YES--OUTPUT AND RETURN

CHRL.1:	SKIPE	DETFLG			;ARE WE DETACHED?
	JRST	CHRFIL			;YES--DON'T TRY TTY OUTPUT
	SKIPLE	S.DPY##			;SEE IF /DPY
	 PJRST	DPCHR##			;YES--GO OUTPUT
	TLZN	T1,400000		;ERROR OUTPUT IN PROGRESS?
	TRNE	F,FR.MYTTY		;SEE IF FOR MY TERMINAL
	 JRST	.TOCHR##		;YES--USE BUFFERED OUTSTR INSTEAD

CHRFIL::TRNN	F,FR.OPEN		;OUTPUT FILE OPENED YET?
	  PUSHJ	P,OPNLST		;NO--OPEN LIST FILE
CHRL.2:	SOSGE	O.BUF+.BFCNT		;ROOM IN BUFFER?
	  JRST	CHRL.3			;NO--DUMP IT
	IDPB	T1,O.BUF+.BFPTR		;YES--STORE CHAR
	POPJ	P,			;AND RETURN

CHRL.3:	OUT	LST,			;DUMP THE BUFFER
	  JRST	CHRL.2			;RETURN IF NO ERROR
	MOVEI	T1,O.FILOP		;ELSE POINT TO FILOP. BLOCK
	GETSTS	LST,T2			;GET ERROR STATUS
	$FATAL	(OWE,<>,.TOERR##)	;TYPE OUTPUT ERROR AND DIE
	SUBTTL	Character routines --  Generalized in-core string routines


; Set up a byte count and byte pointer to an in-core string
; Call:	MOVE	T1, [byte-count,,string-address]
;	PUSHJ	P,CHRSET
;
CHRSET::HLRZM	T1,CHRCTR		;SAVE BYTE COUNT
	HRLI	T1,(POINT 7,)		;MAKE A BYTE POINTER
	MOVEM	T1,CHRPTR		;SAVE IT
	POPJ	P,			;RETURN


; Get a character from an in-core string
; Call:	PUSHJ	P,CHRGET
;
; On return, T1 contains the character, or NUL if the
; byte count runs out.
;
CHRGET::SOSG	CHRCTR			;COUNT DOWN
	TDZA	T1,T1			;RETURN A NUL
	ILDB	T1,CHRPTR		;GET A CHARACTER
	POPJ	P,			;RETURN


; Put a character into an in-core string
; Call:	MOVE	T1, character
;	PUSHJ	P,CHRPUT/CHRNUL
;
; The charcter will be pitched if the byte count runs out
; unless CHRNUL is called which will force a NUL into the
; buffer.
;
CHRNUL::TDZA	T1,T1			;GET A NUL AND BYPASS COUNT
CHRPUT::SOSLE	CHRCTR			;COUNT DOWN
	IDPB	T1,CHRPTR		;STORE CHARACTER
	POPJ	P,			;RETURN
	SUBTTL	Storage

	$LOW

DETFLG:: BLOCK	1			;DETACHED FLAG
PRVFLG:: BLOCK	1			;NON-ZERO TO USE FILOP PRIVS
CHRCTR:	 BLOCK	1			;BYTE COUNT
CHRPTR:	 BLOCK	1			;BYTE POINTER

O.FILOP::BLOCK	.FOPAT+1
O.OPEN==:O.FILOP+.FODEV-.OPDEV
O.ENTER::BLOCK	LN$LEN
O.PATH:: BLOCK	.PTMAX
O.BUF:	 BLOCK	3

	END
