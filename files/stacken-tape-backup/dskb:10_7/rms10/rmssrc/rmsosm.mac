TITLE	RMSOSM - OS DEPENDENT MACRO CODE FOR RMS
SUBTTL	S. COHEN/RL
SEARCH	RMSINT,RMSMAC
$PROLOG

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1979,1981 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

;++
; FACILITY: RMS
;
; ABSTRACT:
;	RMSOSM contains operating system dependent code for RMS.
;	These include monitor error handlers, memory initialization
;	routines, and a filename parser for TOPS-10.
;
; AUTHOR: Seth Cohen, CREATION DATE: ???
;
; MODIFIED BY:
;
;	Ron Lusk, 3-Dec-81: VERSION 01
; 01	- RMSSTACK incorrectly signed as local, made global (Edit 53)
; 02	-
;--

$PURE

; FORMAT STATEMENTS FOR RMS
;
$FMT	(RM$CAX,<$ ,-CA%JSM,.
Type CONTINUE after expunging deleted files.>)
$FMT	(RM$CLI,<?RMSOSE CALLI ,-CA%OCT,-CA%NOCR>)
$FMT	(RM$FOP,<?RMSOSE FILOP. option ,-CA%OCT,-CA%NOCR>)
$FMT	(RM$IER,<
?RMSIER An internal error was found in routine ",-CA%ASZ," at ,-CA%OCT,
	Error is:	,-CA%ASZ>)
$FMT	(RM$IJC,<?RMSIJC invalid RMS JSYS code ,-CA%OCT, in call at ,-CA%OCT>)
$FMT	(RM$IOM,<?RMSOSE stream I/O monitor call failed with status code ,-CA%OCT>)
$FMT	(RM$JSY,<?RMSOSE JSYS ,-CA%OCT, failed at ,-CA%OCT,-CA%JSE>)
$FMT	(RM$OCT,<	,-CA%OCT>)
$FMT	(RM$RPF,<?RMSOSE reference to page ,-CA%NUM, failed,-CA%JSE>)
$FMT	(RM$RSF,<-CA%ASZ,:	,-CA%OCT>)
$FMT	(RM$UUO,< failed at ,-CA%OCT,-CA%CRLF,Status code = ,-CA%OCT>)

SUBTTL	RMS INITIALIZATION ROUTINE

$SCOPE	(TOP-LEVEL)

RMSINI::
;
; THIS ROUTINE SETS UP THE START OF FREE CORE AND NO OF FREE
; PAGES FOR USE BY ITS OWN MEMORY MANAGER.
; WHEN LIBOL'S MEMORY MANAGER IS USED, THIS INFO IS NOT REFERENCED LATER.
;
; ON THE -10, THIS ROUTINE ALSO MARKS PAGES 700-714 AS BUSY
; IN THE PAGTAB. THIS IS BECAUSE THESE PAGES ARE UTILIZED BY
; VMDDT AND ARE NOT AVAILABLE FOR ALLOCATION
; NOTE: THE DEFAULT PAGE HANDLER IS AT 777000 SO IT IS NO PROBLEM
;		RMSEND+FREEPAGES LESS THAN 770
;
; CALL IS: JSP T4,RMSINI
;
; THIS ROUTINE JUGGLES THINGS BECAUSE, UNTIL UNMAP DONE,
; IT HAS "NO PLACE" TO PUT ARGBLK ADDR OR PRESERVE UJSYS & RETPC

	T$GLOB==RMS$$G##_-9		;GET 1ST PAGE OF GLOBS
	T$FREE==<RMSEND##+777>_-9	;GET PAGE PAST END OF GLOBALS

IFN TOP$20,<
	MOVEI	T2,600			;DO THIS ONLY FOR NORMAL RMS
	CAIGE	T2,T$GLOB		;GLOBALS UP HI?
	JRST	INICMN			;NO, SKIP ZAP
;**;[53]    Change at line 59		RLUSK	3-Dec-81
	MOVEM	T1,RMSTACK##		;[53] SAVE USER ARGBLK ADDR
	$COPY	RMSTAC+1,UJSYS##,T1	; MONITOR SETS THESE, SO SAVE OVER 0-ING
	$COPY	RMSTAC+2,RETPC##,T1	; DONE
	SETOM	T1			;INDIC UNMAPPING
	MOVE	T2,[XWD .FHSLF,T$GLOB+1]	;INSURE GLOBS AREA CLEAN
	LOADX	T3,PM%CNT!<T$FREE-T$GLOB-1>	;# OF PAGES IN GLOB AREA AFT STK
	PMAP					;DO UNMAPPING (NO ERJMP, LET OS RPT IT)
	$COPY	UJSYS,RMSTAC+1,T1	;RESTORE THEM
	$COPY	RETPC,RMSTAC+2,T1
	MOVE	T1,RMSTAC
>
INICMN:
	MOVEI	T2,T$FREE			; START OF FREE CORE
	MOVEM	T2,FRECOR##
	MOVEI	T2,FREEPAG##		; NO OF FREE PAGES
	MOVEM	T2,NUMFREE##
IFN TOP$10, <
	MOVE	T2,[-15,,700-T$FREE]	; # OF PAGES IN VMDDT,,OFFS INTO PAGTAB
	MOVSI	T3,400000		; FLAG
BUSY:	IORM	T3,PAGTAB##(T2)		; SET FLAG IN PAGTAB
	AOBJN	T2,BUSY
>
	SETOM	INTFLG##		; INDICATE INITIALIZED
	JRST	0(T4)			; RET TO INST AFTER THE JSP

SUBTTL	OS ERROR ROUTINES

$REG	(CAP,6)					;AC'S NOT SAVED CAUSE GO DIRECT TO USRRET
$REG	(FOP,7)					;FILOP OPTION

STK%KLU==-2					;PRESUME CODE GEN THAT PUTS PUSHJ
						;TO HERE +1 FROM OS CALL

MONERR::
;
; MONERR - GENERATES MESSAGE WHEN A MONITOR CALL FAILS
; ARGUMENTS:
;	PRESUMES CALL IS OF FORM:
;		JSYS or CALLI AC1,UUO-TYPE
;		PUSHJ P,MONERR

	SKIPN	T4,USTOSF##			;[%50] RMS CODE SPEC BY CALLER?
	MOVEI	T4,ER$BUG			;[%50] NO, DEFAULT RMS CODE ON OS ERR
	MOVEM	T4,USRSTS##			;[%50] PERMANIZE IT

	HRRZ	CAP,0(P)			;SETUP PTR TO ARG LIST
	MOVEI	CAP,STK%KLU(CAP)		;PT AT OS CALL RATHER AFT PUSHJ
	IFN TOP$10,<
	  HRL	T1,0(CAP)			;GET CALLI INDEX OF UUO
	  MOVEM	T1,USRSTV##			;SAVE UUO ID WITH STATUS RET BY UUO
	  $CALLB PRICHK##,<USRSTV##>		;DO OUTPUT?
	  JUMPE	T1,MERREXIT			;NO
	  HRRZ	T2,0(CAP)			;ISOLATE CALLI INDEX
	  $CALLB TX$TOUT,<[RM$CLI],T2>		;PUT OUT CALLI INDEX
MERRMRG:
	  HRRZ	T1,USRSTV##			;STAT CODE OF FAILED OPERATION
	  $CALLB TX$TOUT,<[RM$UUO],CAP,T1>	;PC & STAT CODE
	>					;END IFN TOP$10
	IFN TOP$20,<
	  MOVEI	T1,.FHSLF			;GET PROCESS HANDLE
	  GETER%				;BY MON ERR CODE
	  ERJMP	.+1				;IGNORE IT
	  HRL	T2,0(CAP)			;GET INDEX OF JSYS
	  MOVEM	T2,USRSTV##			;PERMANIZE IT
	  $CALLB PRICHK##,<USRSTV##>		;DO OUTPUT?
	  JUMPE	T1,MERREXIT			;NO
	  HRRZ	T2,0(CAP)			;ISOLATE JSYS INDEX
	  $CALLB TX$TOUT,<[RM$JSY],T2,CAP>	;JSYS INDEX & PC
	>					;END IFN TOP$20
MERREXIT:
	; ---					;[%50] SET USRSTS AT TOP OF ERR CODE
	PUSHJ	P,USRERR##			;GIVE UP AFTER PUTTING THE MSG OUT

IFN TOP$10,<

FOPERR::
;
; FOPERR - GENERATES MESSAGE WHEN A FILOP. FAILS
; ARGUMENTS:
;	PRESUMES CALL IS:
;		MOVE AC2,AC1		(SAVE ARG PTR)
;		FILOP. AC1,		(RETS STAT CODE IN AC1)
;		PUSHJ P,FOPERR

	SKIPN	T4,USTOSF##			;[%50] RMS CODE SPEC BY CALLER?
	MOVEI	T4,ER$BUG			;[%50] NO, DEFAULT RMS CODE ON OS ERR
	MOVEM	T4,USRSTS##			;[%50] PERMANIZE IT

	HRRZ	CAP,0(P)			;SETUP PTR TO ARG LIST
	MOVEI	CAP,STK%KLU(CAP)		;PT AT OS CALL RATHER AFT PUSHJ
	HRRZ	FOP,0(T2)			;GET FILOP OPTION FROM ARGBLK
	HRL	T1,FOP				;MAKE IT PART OF USRSTV
	TLO	T1,1000				;DISTING IT FROM SMALL CALLI IDX
	MOVEM	T1,USRSTV##			;SAVE UUO ID WITH STATUS RET BY UUO
	$CALLB PRICHK##,<USRSTV##>		;DO OUTPUT?
	JUMPE	T1,MERREXIT			;NO
	$CALLB TX$TOUT,<[RM$FOP],FOP>		;FILOP OPTION
	JRST	MERRMRG				;THE REST IS COMMON
>						;END FOPERR CONDITIONAL

IFN TOP$20,<
$BLISS	(OKCREATE,<PAGADD,PAGNUM>)
;
; OKCREATE - CHK QUOTA EXCEEDED & PAGE CREATE DURING READ-ONLY ACCESS
; ARGUMENTS:
;	PAGADD = ADDRESS IN MEM OF PAGE IN QUESTION
;	PAGNUM = FILE PAGE NUMBER
	MOVE	T1,@PAGADD(P)		;REF 1ST WORD OF PAGE
	ERJMP	.+2			;CHK IF ILL MEM READ
	POPJ	P,			;NO, JUST RET
	MOVEI	T1,.FHSLF			;[%52] GET PROCESS HANDLE
	GETER%					;[%52] BY MON ERR CODE
	ERJMP	.+1				;[%52] IGNORE IT
	HRRZ	T1,T2				;[%52] REMOVE PROC HANDLE
	CAIE	T1,PMAPX6			;[%52] QUOTA EXC CASE 1?
	CAIN	T1,IOX11			;[%52] QUOTA EXC CASE 2?
	$NOSKIP					;[%52] YES TO EITHER
		$CALLB TX$TOUT,<[RM$CAX],T1>	;[%52] TYPE MSG
		HALTF%				;[%52] WAIT TILL PROB CORRECTED
		POPJ P,				;[%52] RESUME
	$ENDIF					;[%52]
OKCOOPS:				;FATAL ERR IF TO HERE
	$COPY	USRSTV##,PAGNUM(P)	;TELL USER THE PAGE THAT WAS IMPROP REF
	$COPY	USRSTS##,I ER$UDF	;PRESUME FILE SCREWED UP
	CAIN	T1,ILLX01		;IS IT
	PUSHJ	P,USRERR##		;YES, GIVE UP
	$COPY	USRSTS##,I ER$BUG	;NO, GIVE OS UNEX ERR
	MOVEM	T1,USRSTV##		;RET OS ERR CODE TOO
	$CALLB	PRICHK##,<USRSTV##>	;PUTTING OUT MSG?
	JUMPE	T1,OKCRERR		;NO
	MOVE	T1,PAGNUM(P)		;MAKE P# PASSABLE
	$CALLB	TX$TOUT,<[RM$RPF],T1>	;YES, PUT P# & OS ERR MSG OUT
OKCRERR:PUSHJ	P,USRERR##		;EXIT
>

SUBTTL	 TTY OUTPUT HACK

IFN TOP$10,<

$BLISS	(TTYHACK,<ADDBUF,CNTCHAR>)
;
; TTYHACK - OUTPUT ASCII TEXT TO TTY
; ARGUMENTS:
;	ADDBUF = ADDR OF BUFFER OF CHARS
;	CNTCHAR = # OF CHARS TO WRITE
	MOVE	T1,ADDBUF(P)			;GET BUFF PTR
	MOVE	T2,CNTCHAR(P)			;GET AMT TO WRITE
	$ENDARG
	MOVEM	T1,T3				;PREP TO BUILD BP
	HRLI	T3,440700			;WORD-ALIGNED BP
	ADJBP	T2,T3				;FIND LAST CHAR
	ILDB	T4,T2				;SAVE CHAR PAST END
	SETZM	T3				;WRITE A NUL BYTE
	DPB	T3,T2				;DONE
	OUTSTR	0(T1)				;DO THE OUTPUT
	DPB	T4,T2				;RESTORE ACTU CHAR PAST END
	RETURN
$ENDPROC

SUBTTL	TOPS-10 FILE SPEC PARSER

$SCOPE	(PARSE-10)
$LREG	(FOPBLK,6)			;PTR TO FILOP. BLK
$LREG	(PARTBP,7)			;BP TO 6BIT COMPON OF FILE SPEC
$LREG	(PATIDX,10)			;PTR INTO PATH BLK
$LREG	(FILBLK,11)			;PTR TO LOOKUP/ENTER BLK

$BLISS	(PAR10FS,<FS, P.FOPB, P.FILB, P.PATH>)
;
; PAR10FS - PARSES A TOPS-10 FILE SPEC, PLACING PARTS IN APPROP SPOTS
; ARGUMENTS:
;	FS = BYTE PTR TO ASCIZ FILE SPEC
;	P.FOPB = PTR TO FILOP. ARG BLK
;	P.FILB = PTR TO LOOKUP/ENTER BLK
;	P.PATH = PTR TO PATH BLK (AT RBPPN IN FILBLK IF NEEDED)
; RETURNS:
;	T1 = -1 OR ER$FSI
	$REG	(CH,T2)				;CURR CHAR OF FILE SPEC
	$REG	(LPA,T3)				;# OF CHARS ROOM LEFT IN CURR FS PART
	$REG	(PA,T4)				;TEXT OF CURRENT PART OF SPEC

	MOVE	FOPBLK,P.FOPB(P)		;MATER FILOP BLK PTR
	MOVE	FILBLK,P.FILB(P)		;MATER FILBLK PTR
	MOVE	PATIDX,P.PATH(P)		;MATER PATH PTR
	$ENDARG
	MOVEM	FILBLK,.FOLEB(FOPBLK)		;PT FOPBLK AT THEM
	MOVEM	PATIDX,.FOPAT(FOPBLK)		;PT TO RETURNED PATH
	MOVEM	PATIDX,.RBPPN(FILBLK)		;ALW SPEC DIR WITH PATH
	SETZM	.FODEV(FOPBLK)			;INIT THE FILE SPEC BLKS
	SETZM	.RBNAM(FILBLK)
	SETZM	.RBEXT(FILBLK)
	SETZM	.PTFCN(PATIDX)			;DEFAULT TO CURR DIR
	SETZM	.PTSWT(PATIDX)			;
	SETZM	.PTPPN(PATIDX)			;
	SETZM	.PTSFD(PATIDX)			;DONE
	PUSHJ	P,EATPART			;EAT STRINGS UNTIL NUL BYTE SEEN
	SKIPE	PA				;NOTHING Q-ED, CHK IF VALID SPEC
	PUSHJ	P,ATEFOX			;ATE EITHER FILE OR EXT
	SKIPE	.RBNAM(FILBLK)			;IS THERE A FILE NAME?
	$SKIP					;NO, MUST BE ONLY DEVICE
		SKIPN	.FODEV(FOPBLK)		;DEV THERE?
		JRST	ERROR			;NO
		SKIPN	.RBEXT(FILBLK)		;EXTENSION?
		SKIPE	.PTPPN(PATIDX)		;PPN?
		JRST	ERROR			;EITHER PRESENT, TOO BAD
	$ENDIF
	MOVSI	PA,'DSK'			;DEFAULT DEV FIELD
	SKIPN	.FODEV(FOPBLK)			;USER SET DEV?
	MOVEM	PA,.FODEV(FOPBLK)		;NO, USE DEFAULT
	SKIPN	.PTPPN(PATIDX)			;[%41] NO DIR SPEC?
	SETZM	.RBPPN(FILBLK)			;[%41] RIGHT, CANT USE PATH BLK
;	MOVEI	PA,'RMS'			;DEFAULT EXTENSION
;	SKIPN	.RBEXT(FILBLK)			;SET?
;	HRLM	PA,.RBEXT(FILBLK)		;NO, USE DEFAULT
	SETOM	T1				;RET SUCCESS (NO ERROR CODE)
	RETURN
ERROR:
	MOVEI	T1,ER$FSI			;FILE SPEC INVALID
	RETURN

EATPART:
	MOVEI	LPA,6				;MAX LENG OF SIXBIT PART
	SETZM	PA				;CLEAR SIXBIT BUILD AREA
	MOVE	PARTBP,[POINT 6,PA]		;PLACE TO BUILD PART IN
EAT.LP:
	LC	CH,FS(CF)			;GET NEXT CHAR OF FILE SPEC
	CAIN	CH,0				;CHK IF END OF SPEC
	POPJ	P,				;YES
	CAIN	CH,":"				;DEVICE SPEC?
	JRST	ATEDEV				;YES, PUT IT AWAY
	CAIN	CH,"."				;FILE NAME?
	JRST	ATE.FN				;YES, PUT IT AWAY
	CAIN	CH,"["				;BEGIN OF DIR?
	JRST	EATPPN				;YES
	PUSHJ	P,EATCHAR			;EAT 6BIT CHAR REPR IN ASCII
	JRST	EAT.LP				;GET NEXT CHAR
ATEDEV:
	SKIPE	.FODEV(FOPBLK)			;ALREADY SET?
	JRST	ERROR				;YES
	MOVEM	PA,.FODEV(FOPBLK)		;STORE DEV NAME
	JRST	EATPART				;EAT ANOTHER PART
ATE.FN:
	SKIPE	.RBNAM(FILBLK)			;ALREADY SET
	JRST	ERROR				;YES
	MOVEM	PA,.RBNAM(FILBLK)		;STORE FILE NAME
	JRST	EATPART

EATPPN:
	SKIPE	PA				;ANY CHARS Q-ED?
	PUSHJ	P,ATEFOX			;YES, ATE FILE OR EXT
	SKIPE	.PTPPN(PATIDX)			;SEEN PPN ALREADY?
	JRST	ERROR				;YES
	PUSHJ	P,EATOCT			;EAT PROJ NUMBER
	CAIE	CH,","				;END IN VALID DELIM?
	JRST	ERROR				;NO
	HRLM	PA,.PTPPN(PATIDX)		;STORE PROJ#
	PUSHJ	P,EATOCT			;GET PROG#
	HRRM	PA,.PTPPN(PATIDX)		;STORE PROG#
	HRLI	PATIDX,-10			;MAKE INTO AOBJ PTR
SFD.LP:
	SETZM	.PTSFD(PATIDX)			;IN CASE LAST SEEN IS LAST
	CAIN	CH,"]"				;JUST A PPN?
	JRST	SFD.LE				;YES, GO BACK TO MAIN LOOP
	PUSHJ	P,EATSFD			;EAT SFD, RET WITH DELIM IN CH
	MOVEM	PA,.PTSFD(PATIDX)		;STORE SFD
	AOBJN	PATIDX,SFD.LP			;MORE SLOTS AVAIL?
	JRST 	ERROR				;NO
SFD.LE:
	MOVE	PATIDX,.FOPAT(FOPBLK)		;GET INITIAL ADDR BACK
	JRST	EATPART

SUBTTL	SUBROUTINES

ATEFOX:						;TAKES BUILT UP STRING, STORES AS FILE OR EXT
	SKIPE	.RBNAM(FILBLK)			;FILE WITH DEFAULT EXT?
	$SKIP					;YES
	  MOVEM	PA,.RBNAM(FILBLK)		;PUT NAME AWAY
	  POPJ	P,
	$ENDIF
	SKIPE	.RBEXT(FILBLK)			;EXTENSION SET?
	JRST	ERROR				;YES
	HLLM	PA,.RBEXT(FILBLK)		;PUT IT AWAY
	POPJ	P,

EATCHAR:					;EAT 6BIT CHAR REPR AS ASCII, CHK CONV ERROR
	SOSL	LPA				;IGNORE CHARS AFTER 6TH
	CAIN	CH," "				;IGNORE IMBEDDED SPACES
	POPJ	P,				;YES, GET ANOTHER CHAR
	CAIE	CH,15				;IGNORE IMBEDDED CR
	CAIN	CH,12				;IGNORE IMBEDDED LF
	POPJ	P,				;YES TO EITHER
	CAIE	CH,140				;OUT OF CONVERT RANGE?
	CAILE	CH,"z"				;OUT CAUSE BEYOND LC Z?
	JRST	ERROR				;YES TO EITHER
	CAIGE	CH,40				;OUT CAUSE TOO LOW?
	JRST	ERROR				;YES
	CAIL	CH,"a"				;lower case alph?
	SUBI	CH,40				;YES, MAP to uc ascii
	SUBI	CH,40				;DO ASCII TO SIXBIT CONVERSION
	DC	CH,PARTBP			;PUT IT AWAY
	POPJ	P,

EATOCT:						;EAT UP TO 6 CHAR OCT NUMBER
	SETZM	PA				;INIT VALUE
EATOLP:
	LC	CH,FS(CF)			;GET PPN CHAR
	CAIE	CH,"]"				;END PROG#?
	CAIN	CH,","				;END PROJ# OR PROG#?
	POPJ	P,				;YES TO EITHER Q
	CAIL	CH,"0"				;LT 0?
	CAILE	CH,"7"				;LE 7?
	JRST	ERROR				;LT 0 OR GT 7
	SUBI	CH,"0"				;MAP TO DIGIT
	LSH	PA,3				;MAKE ROOM FOR OCTAL DIGIT
	TLNE	PA,-1				;MORE THAN 6?
	JRST	ERROR				;YES
	IOR	PA,CH				;NO, MERGE IT IN
	JRST	EATOLP				;GET ANOTHER

EATSFD:						;PARSE A SFD
	MOVEI	LPA,6				;MAX LENG OF SIXBIT PART
	SETZM	PA				;CLEAR SIXBIT BUILD AREA
	MOVE	PARTBP,[POINT 6,PA]		;PLACE TO BUILD PART IN
EATSLP:
	LC	CH,FS(CF)			;GET CHAR
	JUMPE	CH,ERROR			;CANT END SPEC WITHOUT ]
	CAIE	CH,","				;PROJ OR PROG DELIM?
	CAIN	CH,"]"				;PROG DELIM?
	POPJ	P,				;YES TO EITHER Q
	PUSHJ	P,EATCHAR			;EAT A CHAR FROM SFD
	JRST	EATSLP				;EAT ANOTHER CHAR
$ENDPROC
$ENDSCOPE(PARSE-10)
>						;END IFN TOP$10
$ENDSCOPE(TOP-LEVEL)

END

