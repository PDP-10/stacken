UNIVERSAL	RMSINT
		SALL		;THERE IS A LOT OF MACRO EXPANSION

;****************************************************************
;*								*
;*			START OF RMSSYM.MPR			*
;*								*
;*		RMS SYMBOL AND MACRO DEFINITIONS		*
;*								*
;****************************************************************


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

;COPYRIGHT (C) 1979, 1980 BY DIGITAL EQUIPMENT CORPORATION


;AUTHOR: S. BLOUNT
;EDIT DATE: 22-JUN-77


;	*************************************************
;	*						*
;	*		NEW REVISION HISTORY		*
;	*						*
;	*************************************************
;
;	PRODUCT	MODULE	 SPR
;	 EDIT	 EDIT	 QAR		DESCRIPTION
;	======	======	=====		===========
;
;
;		***** END OF REVISION HISTORY *****

;****************************************************************
;*		MACROS TO SUPPORT RMS FIELD DEFS IN RMSSYM.MTB	*
;****************************************************************


;MACRO TO CHECK INITIAL VALUES FOR SYMBOLS DURING ASSEMBLY.
;	IF ANY SYMBOLS WITHIN RMS-20 MUST HAVE A CERTAIN
;	VALUE OR RANGE OF VALUES, INSERT A MACRO INVOCATION
;	HERE TO CHECK FOR THIS.
;
DEFINE $$ASSUME(SYMBOL,LOVALUE,HIVALUE),<
	IFNB <LOVALUE>,<IFL SYMBOL-LOVALUE,<PRINTX ?'SYMBOL' HAS A VALUE WHICH IS TOO LOW>>
	IFNB <HIVALUE>,<IFG SYMBOL-HIVALUE,<PRINTX ?'SYMBOL' HAS A VALUE WHICH IS TOO HIGH>>
>;END OF DEFINE

; THE MACROS S$$SC, S$$DC, AND S$$BC ARE USED TO DEFINE RMS CONSTANTS:
;
;	S$$DC  (NAMEA, NAMEB, VALUE)	SETS NAMEA'$'NAMEB = A DECIMAL VALUE
;
;	S$$BC (NAMEA, NAMEB, VALUE)	SETS NAMEA'$'NAMEB = A BINARY CONSTANT
;					(VALUE GIVES THE BIT TO BE TURNED ON)
;
;	S$$SC  (NAMEA, NAMEB, SCA, SCB)	SETS NAMEA'$'NAMEB==SCA'$'SCB
;

DEFINE S$$SC  (NAMEA, NAMEB, SCA, SCB)  < NAMEA'$'NAMEB==SCA'$'SCB >

DEFINE S$$DC  (NAMEA, NAMEB, DC)  	< NAMEA'$'NAMEB==^D'DC >

DEFINE S$$BC  (NAMEA, NAMEB, BITNUM)  	< NAMEA'$'NAMEB==1B'BITNUM >



; MACRO $$FIELD DEFINES FIELDS WITHIN RMS-20 USER CONTROL BLOCKS.
; THE ARGUMENTS ARE:
;
;	P	- A SINGLE CHARACTER WHICH DENOTES THE BLOCK (R,F, OR X)
;	N	- FIELD NAME
;	DA,
;	 DB	- DA'$'DB	IS THE DEFAULT VALUE
;	OFF	- XX$'OFF	IS THE OFFSET INTO THE BLOCK
;	SIZE	- XX$'SIZE	IS THE SIZE OF FIELD IN BITS
;	POS	- XX$'POS	IS THE POSITION (NO. BITS REMAINING AT RIGHT OF FIELD)
; (UNU)	SNFLG	- XX$'ASNFLG	IS THE ASSIGNMENT FLAG
;				1=INITIALIZATION MACRO IS DEFINED
;				0=CANNOT BE SET AT ASSEMBLY TIME
; (UNU)	COUNT	- XX$'COUNT	IS THE COUNT OF FIELDS IF ARRAY FIELD
;
DEFINE $$FIELD (P,N,DA,DB,OFF,SIZE,POS,ASNFLG,COUNT)  <
  IF1,<
	$$'P'N==DA'$'DB
	F$$'N==<XX$'POS>B5 ! <XX$'SIZE>B11 ! XX$'OFF	;;BYTE PTR TO FIELD
  >	;END OF IF1
>	;END OF $$FIELD

; MACRO RMSEND GENERATES AN END STATEMENT
;
DEFINE $$END  < END >

; $$SYNM - SYNONYMS, THINGS BASED ON SYMBOLS DEFINED IN MTB
;
DEFINE $$SYNM<
	FB$ALL==FB$GET+FB$PUT+FB$DEL+FB$UPD+FB$TRN

	;;CONSISTENCY CHECKS
	$$ASSUME(FB$SEQ,0)		;FILE ORG MUST BE GTR ZERO
	$$ASSUME(RB$SEQ,0,0)		;RECORD ACCESS MUST START AT ZERO
	$$ASSUME(XB$KEY,0,0)		;KEY XAB MUST BE FIRST
	$$ASSUME(XB$STG,0,0)		;STRING DATA-TYPE SHOULD BE ZERO
>					;END $$SYNM

;****************************************************************
;*	MACROS TO SUPPORT DEFINITION OF VERBS IN MTB FILE	*
;****************************************************************

DEFINE $INIT<			;;SPECIAL "VERB", GENS IN-LINE CODE
	PUSHJ 17,$$RMS##	;;USER PART OF RMS INITIALIZATION
	.REQUIRE SYS:RMSINI	;;THE FILE THAT DOES IT
>
SYN $INIT,$RMS

DEFINE $$VINI<			;;SITUATION DEPENDENT INITS
	XX$MAX==0		;;INITIALIZE CURRENT MACRO OFFSET
>

DEFINE $$VERB (NAME),<		;;CREATE THE USER MACRO
    C$'NAME==XX$MAX		;;KEEP VERB OFFSET AROUND
    DEFINE $$'NAME(NAME)<	;;IMBED OS DEPENDENCIES HERE
      IFN TOP$10,<PUSHJ 17,RMS$10##+C$'NAME>	;;ABSOLUTE LOC SINCE GETSEG
      IFN TOP$20,<104B8+1000+C$'NAME>	;;THE JSYS INSTRUCTION FOR 'NAME'
    >
    DEFINE $'NAME(.BLK1,.ERRAD,.NLARG),<
	IFB <.BLK1>,<IF1,<PRINTX %ARGBLK ADDRESS OMIITED ON 'NAME' MACRO>>
	MOVEI	1, .BLK1
	IFNB <.NLARG>,<IF1,<PRINTX %MORE THAN 2 ARGS DETECTED IN 'NAME' MACRO>>
	$$'NAME			;;DO THE RMS-20 JSYS
	IFNB <.ERRAD>,<JUMP 17,.ERRAD>
	IFB <.ERRAD>,<JUMP 16,.+1>	;;USER SPEC NO ERROR ROUTINE
    >
  XX$MAX==XX$MAX+1		;;BUMP COUNTER OF VERBS
>				;;END OF $$VERB MACRO

DEFINE $$VEND<			;;DEFINE FIRST AND LAST RMS JSYS CODES
  IF2,<
	OPDEF	RM$MIN [104B8+1000]	;MINIMUM JSYS  VALUE
	OPDEF	RM$MAX [104B8+1000+XX$MAX]
  >				;;END OF IF2
>

;****************************************************************
;*			RMS-20 ERROR AND SUCCESS CODES		*
;****************************************************************


;ERROR CODE DEFINITIONS FOR RMS-20

;THERE ARE THREE TYPES OF ERROR CODES DEFINED IN THIS SECTION:
;
;	1. USER SUCCESS CODES (ALWAYS POSITIVE NON-ZERO)
;	
;	2. USER ERROR CODES
;
;	3. RMS-20 INTERNAL FILE CONSISTENCY ERROR CODES
;
; THE FILE CONSISTENCY ERROR CODES ARE NOT AVAILABLE TO THE USER
; AS ASSEMBLY-TIME SYMBOLS, THEY CAN ONLY BE USED AS ARGUMENTS TO
; THE COMMON RMS-20 ERROR HANDLER.

;DEFINE BASE VALUES FOR SUCCESS AND ERROR CODES
;
.SUBAS==1000		;SUCCESS CODES START AT 1000
.ERBAS==300000		;ERROR CODES START AT 300000
ER$MIN=.ERBAS
.EXBAS==300500		;FILE CONSISTENCY ERROR BASE

;DEFINE TEMPORARY COUNTERS FOR EACH ERROR CODE TYPE
;
.SUCTR==0		;INITIALIZE COUNTER
.ERCTR==0		;...
.EXCTR==0		;FILE CONSIS CTR

;MACRO TO DEFINE A SUCCESS CODE
;
DEFINE $$SUC(.CODE,.MSG),<
	$$CODE(.SUBAS,.SUCTR,.CODE,.MSG)
>

;MACRO TO DEFINE AN ERROR CODE
;
DEFINE $$UERR(.CODE,.MSG),<
	$$CODE(.ERBAS,.ERCTR,.CODE,.MSG)
>

;MACRO TO DEFINE A USER FILE CONSISTENCY ERROR CODE
;
DEFINE $$FERR(.CODE,.MSG),<
	$$CODE(.EXBAS,.EXCTR,.CODE,.MSG)
>

;MACRO TO SETUP MAX OF A CODE TYPE
;
DEFINE $$MAXC(TYP)<TYP'$MAX==.'TYP'BASE + .'TYP'CTR - 1>

;MACRO TO DEFINE ARBITRARY CODE VALUE
;
DEFINE $$CODE(..BASE,..CTR,..CODE,..MSG),<
	..CODE=..BASE+..CTR		;;DEFINE SYMBOL FOR CODE
	..CTR==..CTR+1			;;BUMP COUNTER
>


;****************************************************************
;*	DEFINE RMS-11 FIELDS WHICH ARE NOT SUPPORTED BY RMS-20	*
;****************************************************************

;MACRO TO DEFINE RMS-11 FIELDS WHICH ARE NOT SUPPORTED BY RMS-20

DEFINE ..BADF(PREFIX,NAME),<
	DEFINE PREFIX'$'NAME(ARG)<
		IF1,<PRINTX	%"'PREFIX'$'NAME'" RMS-11 ONLY, IGNORED BY RMS-20>
	>;;END OF DEFINE
>;;END OF ..BADF

;MACRO FOR BAD FAB FIELDS

DEFINE ..BFAB(FLDNAM),<
	IRP FLDNAM,< ..BADF(F,FLDNAM) >
>


;MACRO FOR BAD RAB FIELDS

DEFINE ..BRAB(FLDNAM),<
	IRP FLDNAM,< ..BADF(R,FLDNAM) >
>


;MACRO FOR BAD XAB FIELDS

DEFINE ..BXAB(FLDNAM),<
	IRP FLDNAM,< ..BADF(X,FLDNAM) >
>

;RMS-11 FIELDS NOT SUPPORTED BY RMS-20:

IF1,<
	..BFAB	<FNS,DNA,DNS,RTV,ALQ,ANB,FSZ,LCH>
	..BRAB  <RHB>
	..BXAB  <MTH,HAL,PRG,PRJ,SYS,OWN,GRP,WLD,VOL,SBN,XBY>
>;END OF IF1


SUBTTL	RMS USER MACROS

;****************************************************************
;	CONTROL BLOCK INITIALIZATION
;
;	DEFINE	xAB$B	(xABADDR)
;
;	THIS MACRO BEGINS THE DEFINITION OF A xAB.  A CALL TO xAB$B CAN BE FOLLOWED BY AN ARBITRARY NUMBER
;	OF FIELD INITIALIZATION MACROS (x$### WHERE ### IS THE FIELD NAME).
;	THE xAB$B AND x$### MACRO CALLS MUST BE FOLLOWED BY A xAB$E MACRO CALL.
;
;	ARGUMENT:
;		xABADDR		ADDRESS OF THE xAB (OPTIONAL)
;	USAGE:
;		IF xABADDR PRESENT, PERFORM RUNTIME INIT.
;		xAB$B(ADDR)			WITH EXECUTABLE CODE
;		  1 OR MORE x$xxx(value)	value DOESNT HAVE TO BE L-TIME
;		xAB$E
;
;		IF xABADDR ABSENT, PERFORM COMPILE-TIME INIT.
;		xAB$B				WITH DECLARATIONS
;		  0 OR MORE x$xxx(value)	VALUE MUST L-TIME CONSTANT
;		xAB-name: xAB$E			name: can also precede xAB$b
;
;	OPERATION:
;		$B SETS CURR VALUE OF EACH CTL BLK FLD TO DEFAULT VALUE.
;		EACH x$ MACRO OVERRIDES A DEFAULT VALUE WITH THE SPEC VALUE.
;		$E ACTUALLY STORES THE VALUES IN THE CTL BLK:
;		1)	IF NO FABADDR, VIA space allocation
;		2)	IF FABADDR, VIA HRREI / $STORE
;			THUS TO STORE THE CONTENTS OF A FIELD,
;			SPECIFY X$FOO(@FIELD)


; ***	SUPPORT FOR BLOCK INITIALIZATION MACROS

; $$CURR - INDIC DEFAULT VALUE APPLIES BY PURGING CANON SYMBOL
;
DEFINE	$$CURR(PRE$,FLD$)<PURGE C$$'FLD$>

; $$MAPADD - CREATE SYMBOL = BASE OF CTL BLK WHEN DOING DYNAMIC INIT
;
DEFINE	$$MAPADD(ADDR$,SYM$)<DEFINE SYM$<ADDR$>>

; $$NEWVAL - SET CANON SYMBOL TO VAL SPEC
;
DEFINE	$$NEWVAL(FLD$,VAL$)<
	DEFINE C$$'FLD$<VAL$>		;;ASSIGN THE NEW VAL
>

; $$NEWARRVAL	(FIELDID,SIZORPOS)
;
;	THIS MACRO REPLACES THE DEFAULT VALUE OF A SPECIFIC POSITION OR SIZE FLD
;	OF A KEY DESCRIPTION XAB BY A USER SPECIFIED VALUE
;
;	ARGUMENTS:
;		 FID$		FIELD NAME (SIZ OR POS)
;		 VAL$		SIZE OR POSITION SPECIFIED BY USER
;
DEFINE	$$NEWARRVAL	(FID$,VAL$)<
	IFNB <VAL$>,<C$$'FID$==VAL$>
>

; $$SET - SET RMS CTL FIELD TO USER-SPECIFIED OR DEFAULT VALUE
;	$$SET ACTU DEF BY $B MACROS DEPENDING ON STAT/DYN INIT
;	THE $$CT MACROS MUST BE ON 1 LINE SO EXPANSION IS LEGAL CODE
;
; STATIC INIT:
;	MACRO REFERENCE ALLOCATES AND ASSIGNS VALUE TO ALLOCATED SPACE
; DYNAMIC INIT:
;	FOR EFFICIENCY, RMS ASSUMES THAT A BLOCK IS 0.
;	SO $$SET ONLY SETS NON-0 DEFAULTS & FIELDS EXPLIC SET BY AN X$YYY MACRO
;	$$SET CANNOT BE FED A NEGATIVE VALUE (1B0=1).
;	HOWEVER $$SET(777777) DOES HAVE THE EFFECT DESIRED FOR $$SET(-1).
;
	DEFINE	STO$$C(FLD$)<			;;CHK IF $STORE NECES
	    IFDEF C$$'FLD$,<			;;USER SET THIS FIELD
		<HRREI 1,> ! C$$'FLD$		;;LOAD VAL OF SYMBOL
		$STORE	(1,FLD$,$$ADDR)		;;GEN MOVEM, HRxM, or DPB
	    >
	>
	DEFINE	SF$$RT(FLD$)<
	    IFNDEF C$$'FLD$,<IFN $$F'FLD$,<C$$'FLD$==$$F'FLD$>>
	    STO$$C(FLD$)			;;COPY IT
	>					;;END $$SET
	DEFINE	SF$$CT(FLD$)<IFDEF C$$'FLD$,<C$$'FLD$> IFNDEF C$$'FLD$,<$$F'FLD$>>

	DEFINE	SR$$RT(FLD$)<
	    IFNDEF C$$'FLD$,<IFN $$R'FLD$,<C$$'FLD$==$$R'FLD$>>
	    STO$$C(FLD$)			;;COPY IT
	>					;;END $$SET
	DEFINE	SR$$CT(FLD$)<IFDEF C$$'FLD$,<C$$'FLD$> IFNDEF C$$'FLD$,<$$R'FLD$>>

	DEFINE	SX$$RT(FLD$)<
	    IFNDEF C$$'FLD$,<IFN $$X'FLD$,<C$$'FLD$==$$X'FLD$>>
	    STO$$C(FLD$)			;;COPY IT
	>					;;END $$SET
	DEFINE	SX$$CT(FLD$)<IFDEF C$$'FLD$,<C$$'FLD$> IFNDEF C$$'FLD$,<$$X'FLD$>>

;****************************************************************
;*	4.2  FILE ACCESS BLOCK (FAB) DECLARATION MACROS		*
;****************************************************************


	DEFINE	FAB$B (FABADDR)<
	IFNB <FABADDR>,<			;RUN-TIME INIT
		$$MAPADD (FABADDR,$$ADDR);	; WILL REFERENCE FAB VIA $$ADDR
		SYN SF$$RT,$$SET
	>					;;END IFNB
	IFB <FABADDR>,<SYN SF$$CT,$$SET>	;;C-T INIT
		$$CURR (F,BID)
		$$CURR (F,BLN)
		$$CURR (F,STS)
		$$CURR (F,STV)
		$$CURR (F,IFI)
		$$CURR (F,JFN)
		$$CURR (F,FAC)
		$$CURR (F,SHR)
		$$CURR (F,FOP)
		$$CURR (F,ORG)
		$$CURR (F,FNA)
		$$CURR (F,RAT)
		$$CURR (F,MRS)
		$$CURR (F,MRN)
		$$CURR (F,BSZ)
		$$CURR (F,RFM)
		$$CURR (F,XAB)
		$$CURR (F,JNL)
		$$CURR (F,BLS)
		$$CURR (F,BKS)
		$$CURR (F,DEV)
		$$CURR (F,SDC)
		$$CURR (F,CTX)
	>					;END FAB$B


;	DEFINE	F$###	(VALUE)
;
;	THESE MACROS INITIALIZE FAB FIELD ### WHERE ### REPRESENTS THE FIELD NAME.
;	CALLS TO THESE MACROS MUST BE PRECEDED BY A FAB$B MACRO CALL AND FOLLOWED BY A FAB$E CALL.
;
;	ARGUMENT:
;		VALUE		VALUE TO SET THE FIELD TO
;
	DEFINE	F$JFN (VALUE) <$$NEWVAL (JFN,VALUE)>
	DEFINE	F$FAC (VALUE) <$$NEWVAL (FAC,VALUE)>
	DEFINE	F$SHR (VALUE) <$$NEWVAL (SHR,VALUE)>
	DEFINE	F$FOP (VALUE) <$$NEWVAL (FOP,VALUE)>
	DEFINE	F$ORG (VALUE) <$$NEWVAL (ORG,VALUE)>
	DEFINE	F$FNA (VALUE) <$$NEWVAL (FNA,VALUE)>
	DEFINE	F$RAT (VALUE) <$$NEWVAL (RAT,VALUE)>
	DEFINE	F$MRS (VALUE) <$$NEWVAL (MRS,VALUE)>
	DEFINE	F$MRN (VALUE) <$$NEWVAL (MRN,VALUE)>
	DEFINE	F$BSZ (VALUE) <$$NEWVAL (BSZ,VALUE)>
	DEFINE	F$RFM (VALUE) <$$NEWVAL (RFM,VALUE)>
	DEFINE	F$XAB (VALUE) <$$NEWVAL (XAB,VALUE)>
	DEFINE	F$JNL (VALUE) <$$NEWVAL (JNL,VALUE)>
	DEFINE	F$BLS (VALUE) <$$NEWVAL (BLS,VALUE)>
	DEFINE	F$BKS (VALUE) <$$NEWVAL (BKS,VALUE)>
	DEFINE	F$CTX (VALUE) <$$NEWVAL (CTX,VALUE)>




;	DEFINE	FAB$E
;
;	THIS MACRO ENDS THE DEFINITION OF A FAB.  A CALL TO FAB$E MUST BE PRECEDED BY A FAB$B MACRO CALL.
;
	DEFINE	FAB$E<
	IFNDEF $$ADDR,<				;;STATIC ALLOC
		<$$SET(BID)>_^D18 ! <$$SET(BLN)>
		<$$SET(STS)>_^D18 ! <$$SET(STV)>
		<$$SET(CTX)>
		<$$SET(IFI)>_^D18 ! <$$SET(JFN)>
		<$$SET(FAC)>_^D18 ! <$$SET(SHR)>
		<$$SET(FOP)>_^D18 ! <$$SET(ORG)>_^D14 ! <$$SET(BSZ)>_^D8 ! <$$SET(BLS)>
		<$$SET(FNA)>
		<$$SET(RAT)>_^D18 ! <$$SET(MRS)>
		<$$SET(MRN)>
		<$$SET(BKS)>_^D5 ! <$$SET(RFM)>
		<$$SET(JNL)>_^D18 ! <$$SET(XAB)>
		<$$SET(DEV)>_^D18 ! <$$SET(SDC)>
		EXP 0,0,0,0
	>					;END IFNB
	IFDEF $$ADDR,<
		$$SET(BID)
		$$SET(BLN)
		$$SET(STS)
		$$SET(STV)
		$$SET(IFI)
		$$SET(JFN)
		$$SET(FAC)
		$$SET(SHR)
		$$SET(FOP)
		$$SET(ORG)
		$$SET(FNA)
		$$SET(RAT)
		$$SET(MRS)
		$$SET(MRN)
		$$SET(BSZ)
		$$SET(RFM)
		$$SET(XAB)
		$$SET(JNL)
		$$SET(BLS)
		$$SET(BKS)
		$$SET(DEV)
		$$SET(SDC)
		$$SET(CTX)
		PURGE $$ADDR			;;SO NEXT C/R DECIS RIGHT
	>					;;IFDEF
	>					;;FAB$E

;****************************************************************
;*	4.3  RECORD ACCESS BLOCK (RAB) DECLARATION MACROS	*
;****************************************************************



	DEFINE	RAB$B (RABADDR)<
	IFNB <RABADDR>,<
		$$MAPADD (RABADDR,$$ADDR);	; WILL REFERENCE THE BLOCK VIA $$ADDR
		SYN SR$$RT,$$SET
	>					;;END IFNB
	IFB <RABADDR>,<SYN SR$$CT,$$SET>	;;C-T INIT
		$$CURR (R,BID)
		$$CURR (R,BLN)
		$$CURR (R,STS)
		$$CURR (R,STV)
		$$CURR (R,ISI)
		$$CURR (R,FAB)
		$$CURR (R,RAC)
		$$CURR (R,ROP)
		$$CURR (R,UBF)
		$$CURR (R,RBF)
		$$CURR (R,RSZ)
		$$CURR (R,USZ)
		$$CURR (R,RFA)
		$$CURR (R,KRF)
		$$CURR (R,KSZ)
		$$CURR (R,KBF)
		$$CURR (R,MBF)
		$$CURR (R,LSN)
		$$CURR (R,BKT)
		$$CURR (R,PAD)
		$$CURR (R,CTX)
	 >					;END RAB$B


	DEFINE	R$FAB (VALUE) < $$NEWVAL (FAB,VALUE)>
	DEFINE	R$RAC (VALUE) < $$NEWVAL (RAC,VALUE)>
	DEFINE	R$ROP (VALUE) < $$NEWVAL (ROP,VALUE)>
	DEFINE	R$UBF (VALUE) < $$NEWVAL (UBF,VALUE)>
	DEFINE	R$RBF (VALUE) < $$NEWVAL (RBF,VALUE)>
	DEFINE	R$RSZ (VALUE) < $$NEWVAL (RSZ,VALUE)>
	DEFINE	R$USZ (VALUE) < $$NEWVAL (USZ,VALUE)>
	DEFINE	R$KRF (VALUE) < $$NEWVAL (KRF,VALUE)>
	DEFINE	R$KSZ (VALUE) < $$NEWVAL (KSZ,VALUE)>
	DEFINE	R$KBF (VALUE) < $$NEWVAL (KBF,VALUE)>
	DEFINE	R$MBF (VALUE) < $$NEWVAL (MBF,VALUE)>
	DEFINE	R$PAD (VALUE) < $$NEWVAL (PAD,VALUE)>
	DEFINE	R$LSN (VALUE) < $$NEWVAL (LSN,VALUE)>
	DEFINE	R$CTX (VALUE) < $$NEWVAL (CTX,VALUE)>




;	RAB DECLARATION MACROS  (CONTINUED)

;	DEFINE	RAB$E
;
;	THIS MACRO ENDS THE DEFINITION OF A RAB.  A CALL TO RAB$E MUST BE PRECEDED BY A RAB$B MACRO CALL.
;
	DEFINE	RAB$E<
	IFNDEF $$ADDR,<
		<$$SET(BID)>_^D18 ! <$$SET(BLN)>
		<$$SET(STS)>_^D18 ! <$$SET(STV)>
		<$$SET(CTX)>
		<$$SET(ISI)>_^D18 ! <$$SET(FAB)>
		<$$SET(RAC)>_^D27 ! <$$SET(MBF)>_^D18 ! <$$SET(ROP)>
		<$$SET(UBF)>
		<$$SET(RBF)>
		<$$SET(RSZ)>_^D18 ! <$$SET(USZ)>
		<$$SET(RFA)>
		<$$SET(KRF)>_^D27 ! <$$SET(KSZ)>_^D18 ! <$$SET(LSN)>
		<$$SET(KBF)>
		<$$SET(BKT)>
		<$$SET(PAD)>_^D27
		EXP 0,0,0
	>				;IFNDEF
	IFDEF $$ADDR,<
		$$SET(BID)
		$$SET(BLN)
		$$SET(STS)
		$$SET(STV)
		$$SET(ISI)
		$$SET(FAB)
		$$SET(RAC)
		$$SET(ROP)
		$$SET(UBF)
		$$SET(RBF)
		$$SET(RSZ)
		$$SET(USZ)
		$$SET(RFA)
		$$SET(KRF)
		$$SET(KSZ)
		$$SET(KBF)
		$$SET(MBF)
		$$SET(LSN)
		$$SET(BKT)
		$$SET(PAD)
		$$SET(CTX)
		PURGE $$ADDR			;SO NEXT C/R DECIS CORRECT
	>					;IFDEF
	>					;RAB$E


;****************************************************************
;*	4.4  EXTENDED ATTRIBUTES BLOCK (XAB) DECLARATION MACROS	*
;****************************************************************


;	DEFINE	XAB$B	(CODE,XABADDR)
;
;	ADDITIONAL ARGUMENT:
;		CODE = TYPE OF XAB:
;			KEY	(KEY DESCRIPTOR XAB)
;			DAT	(DATE XAB)
;			ALL	(AREA ALLOCATION XAB)
;			SUM	(FILE SUMMARY XAB)
;
	DEFINE	XAB$B (CODE,XABADDR)<
	IFNB <XABADDR>,<
		$$MAPADD (XABADDR,$$ADDR)	;;WILL REFERENCE XAB VIA $$ADDR
		SYN SX$$RT,$$SET
	>					;;END IFNB
	IFB <XABADDR>,<SYN SX$$CT,$$SET>	;;C-T INIT
						;;COMMON XAB HEADER
		C$$COD==XB$'CODE		;;DEFINE TEMP FOR COMPARE CHK
		C$$BLN==XA$SX'CODE		;;SET CODE-DEP LEN OF XAB...
						;;1ST CHAR ONLY (LEN XA$SX=5)

		$$CURR (X,BID)
		$$CURR (X,RS1)
		$$CURR (X,NXT)

						;;DATE XAB
		$$CURR (X,CDT)
		$$CURR (X,RDT)
		$$CURR (X,EDT)

						;;AREA ALLOCATION XAB
		$$CURR (X,RS2)
		$$CURR (X,AID)
		$$CURR (X,BKZ)

						;;KEY DEFINITION XAB
		$$CURR (X,IFL)
		$$CURR (X,DFL)
		$$CURR (X,DTP)
		$$CURR (X,FLG)
		$$CURR (X,IAN)
		$$CURR (X,DAN)
		$$CURR (X,LAN)
		$$CURR (X,REF)
		$$CURR (X,KNM)
		$$CURR (X,RX0)
		$$CURR (X,RX1)
		$$CURR (X,RX2)
		$$CURR (X,RX3)
		$$CURR (X,RX4)
		$$CURR (X,RX5)
		$$CURR (X,PS0)
		$$CURR (X,PS1)
		$$CURR (X,PS2)
		$$CURR (X,PS3)
		$$CURR (X,PS4)
		$$CURR (X,PS5)
		$$CURR (X,PS6)
		$$CURR (X,PS7)
		$$CURR (X,SZ0)
		$$CURR (X,SZ1)
		$$CURR (X,SZ2)
		$$CURR (X,SZ3)
		$$CURR (X,SZ4)
		$$CURR (X,SZ5)
		$$CURR (X,SZ6)
		$$CURR (X,SZ7)
	
						;;FILE SUMMARY XAB
		$$CURR (X,RS6)
		$$CURR (X,NOK)
		$$CURR (X,NOA)
		$$CURR (X,RS7)
		$$CURR (X,RS8)
		$$CURR (X,RS9)
	>					;;XAB$B

; ***	MACROS TO SET INDIVIDUAL XAB FIELDS TO A SPECIFIED VALUE

							; XAB HEADER
	DEFINE	X$NXT (VALUE)<$$NEWVAL (NXT,VALUE)>

							; DATE XAB
	DEFINE	X$EDT (VALUE)<$$NEWVAL (EDT,VALUE)>

							; AREA ALLOCATION XAB
	DEFINE	X$AID (VALUE)<$$NEWVAL (AID,VALUE)>
	DEFINE	X$BKZ (VALUE)<$$NEWVAL (BKZ,VALUE)>

							; KEY DEFINITION XAB
	DEFINE	X$IFL (VALUE)<$$NEWVAL (IFL,VALUE)>
	DEFINE	X$DFL (VALUE)<$$NEWVAL (DFL,VALUE)>
	DEFINE	X$DTP (VALUE)<$$NEWVAL (DTP,VALUE)>
	DEFINE	X$FLG (VALUE)<$$NEWVAL (FLG,VALUE)>
	DEFINE	X$IAN (VALUE)<$$NEWVAL (IAN,VALUE)>
	DEFINE	X$DAN (VALUE)<$$NEWVAL (DAN,VALUE)>
	DEFINE	X$LAN (VALUE)<$$NEWVAL (LAN,VALUE)>
	DEFINE	X$REF (VALUE)<$$NEWVAL (REF,VALUE)>
	DEFINE	X$KNM (VALUE)<$$NEWVAL (KNM,VALUE)>

	; THE XPOS AND XSIZ INITIALIZATION MACROS
	; DIFFER FROM THE OTHERS SINCE UP TO 8 VALUES
	; CAN BE SPECIFIED.

	DEFINE	X$POS (VAL0,VAL1,VAL2,VAL3,VAL4,VAL5,VAL6,VAL7)<

		$$NEWARRVAL (PS0,VAL0)
		$$NEWARRVAL (PS1,VAL1)
		$$NEWARRVAL (PS2,VAL2)
		$$NEWARRVAL (PS3,VAL3)
		$$NEWARRVAL (PS4,VAL4)
		$$NEWARRVAL (PS5,VAL5)
		$$NEWARRVAL (PS6,VAL6)
		$$NEWARRVAL (PS7,VAL7)
	>

	DEFINE	X$SIZ (VAL0,VAL1,VAL2,VAL3,VAL4,VAL5,VAL6,VAL7)<

		$$NEWARRVAL (SZ0,VAL0)
		$$NEWARRVAL (SZ1,VAL1)
		$$NEWARRVAL (SZ2,VAL2)
		$$NEWARRVAL (SZ3,VAL3)
		$$NEWARRVAL (SZ4,VAL4)
		$$NEWARRVAL (SZ5,VAL5)
		$$NEWARRVAL (SZ6,VAL6)
		$$NEWARRVAL (SZ7,VAL7)
	>


;	XAB DECLARATION MACROS  (CONTINUED)

;	DEFINE	XAB$E
;
;	THIS MACRO ENDS THE DEFINITION OF A XAB.  A CALL TO XAB$E MUST BE PRECEDED BY A XAB$B MACRO CALL.
;
	DEFINE	XAB$E<
	IFNDEF $$ADDR,<
		<$$SET(BID)>_^D18 ! <$$SET(BLN)>
		<$$SET(COD)>_^D18 ! <$$SET(NXT)>
		IFE <C$$COD-XB$DAT>,<
			<$$SET(CDT)>
			<$$SET(RDT)>
			<$$SET(EDT)>
		>
		IFE <C$$COD-XB$ALL>,<
			<$$SET(AID)>_^D9 ! <$$SET(BKZ)>
			EXP 0,0,0
		>
		IFE <C$$COD-XB$KEY>,<
			<$$SET(DTP)>_^D18 ! <$$SET(FLG)>
			<$$SET(IAN)>_^D27 ! <$$SET(DAN)>_^D18 ! <$$SET(LAN)>_^D9 ! <$$SET(REF)>
			<$$SET(IFL)>_^D18 ! <$$SET(DFL)>
			<$$SET(KNM)>
			EXP 0,0,0,0,0
			<$$SET(PS0)>_^D18 ! <$$SET(SZ0)>
			<$$SET(PS1)>_^D18 ! <$$SET(SZ1)>
			<$$SET(PS2)>_^D18 ! <$$SET(SZ2)>
			<$$SET(PS3)>_^D18 ! <$$SET(SZ3)>
			<$$SET(PS4)>_^D18 ! <$$SET(SZ4)>
			<$$SET(PS5)>_^D18 ! <$$SET(SZ5)>
			<$$SET(PS6)>_^D18 ! <$$SET(SZ6)>
			<$$SET(PS7)>_^D18 ! <$$SET(SZ7)>
		>
		IFE <C$$COD-XB$SUM>,<
			<$$SET(NOK)>_^D9 ! <$$SET(NOA)>
			EXP 0,0,0
		>
	>
	IFDEF $$ADDR,<
		$$MAPADD (XABADDR,$$ADDR);	; WILL REFERENCE THE BLOCK VIA $$ADDR
							; STORE COMMON HEADER FOR ALL XAB TYPES
		$$SET(BID)
		$$SET(RS1)
		$$SET(COD)
		$$SET(NXT)
							; STORE REST OF XAB DEPENDING ON IT'S TYPE
		IFE <C$$COD-XB$DAT>,<
		$$NEWVAL(BLN,XA$SXD)		;;SIZE VARIES WITH SUBTYPE
		$$SET(BLN)
		$$SET(CDT)
		$$SET(RDT)
		$$SET(EDT)
		>

		IFE <C$$COD-XB$ALL>,<
		$$NEWVAL(BLN,XA$SXA)		;;SIZE VARIES WITH SUBTYPE
		$$SET(BLN)
		$$SET(RS2)
		$$SET(AID)
		$$SET(BKZ)
		>

		IFE <C$$COD-XB$KEY>,<
		$$NEWVAL(BLN,XA$SXK)		;;SIZE VARIES WITH SUBTYPE
		$$SET(BLN)
		$$SET(IFL)
		$$SET(DFL)
		$$SET(DTP)
		$$SET(FLG)
		$$SET(IAN)
		$$SET(DAN)
		$$SET(LAN)
		$$SET(REF)
		$$SET(KNM)
		$$SET(RX0)
		$$SET(RX1)
		$$SET(RX2)
		$$SET(RX3)
		$$SET(RX4)
		$$SET(RX5)

		$$SET(PS0)
		$$SET(PS1)
		$$SET(PS2)
		$$SET(PS3)
		$$SET(PS4)
		$$SET(PS5)
		$$SET(PS6)
		$$SET(PS7)

		$$SET(SZ0)
		$$SET(SZ1)
		$$SET(SZ2)
		$$SET(SZ3)
		$$SET(SZ4)
		$$SET(SZ5)
		$$SET(SZ6)
		$$SET(SZ7)
		>

		IFE <C$$COD-XB$SUM>,<
		$$NEWVAL(BLN,XA$SXS)		;;SIZE VARIES WITH SUBTYPE
		$$SET(BLN)
		$$SET(RS6)
		$$SET(NOK)
		$$SET(NOA)
		$$SET(RS7)
		$$SET(RS8)
		$$SET(RS9)
		>
		PURGE $$ADDR			;;SO NEXT C/R DECIS RIGHT
	>					;;IFDEF
	>					;;XAB$E

;****************************************************************
;*		MISCELLANEOUS RMS-20 USER MACROS		*
;****************************************************************

; xxx$Z - ZERO THE SPECIFIED ARGUMENT BLK
;
DEFINE FAB$Z(ADDR)< $$ZERO(ADDR,FA$LNG) >
DEFINE RAB$Z(ADDR)< $$ZERO(ADDR,RA$LNG) >
DEFINE XAB$Z(ADDR,CODE)< $$ZERO(ADDR,%NAME(XA$SX,CODE)) >

DEFINE $$ZERO(ADDR,LEN)<
	SETZM	ADDR			;;CLEAR THE 1ST WORD
	MOVEI	2,ADDR			;;PREP DEST START
	MOVEI	1,1(2)			;;INSURE GET RIGHT RESULT
	HRLI	1,ADDR			;;SRC
	BLT	1,LEN-1(2)		;;ZERO IT
>

; $RETURN - CANONICAL WAY TO RETURN FROM RMS ERROR ROUTINE
;
DEFINE $RETURN,<POPJ	17,>

; $FIELD(STR$, FLD$) - DEVELOP BYTE PTR TO ARBIT FIELD
; SUCH THAT LDB, DPB, AND PUSH X,$FIELD(A,B) HAS DESIRED EFFECT
;
DEFINE $FIELD(FLD$, STR$)<[F$$'FLD$+STR$]>

; $FETCH(AC$, FLD$, STR$) - MOVES A RMS CTL FLD INTO AC
;
; ARGUMENTS:
;	AC$ = AC TO USE
;	FLD$ = 3-LETTER FIELD ID
;	STR$ = BASE OF STRUCTURE (EG. 0(PTR))
;
DEFINE $FETCH(AC$, FLD$, STR$)<
	$$ISOL(FLD$)			;;ISOLATES PARTS OF F$$'FLD$
	IFE <T$$SZ-^D18>,<		;;HALF-WORD FIELD
	    IFE T$$PS,<			;;RH
		HRRZ AC$,T$$OF+STR$
		T$$SZ==0		;;INDIC INST GEN
	    >
	    IFE <T$$PS-^D18>,<		;;LH
		HLRZ AC$,T$$OF+STR$
		T$$SZ==0		;;INDIC INST GEN
	    >
	>
	IFE <T$$SZ-^D36>,<		;;FULL-WORD FIELD
		MOVE AC$,T$$OF+STR$
		T$$SZ==0		;;INDIC INST GEN
	>
	IFN T$$SZ,<			;;OTHER CASE
		LDB AC$,[<T$$PS>B5 ! <T$$SZ>B11 ! <T$$OF+STR$>]
	>
>

; $STORE(AC$, FLD$, STR$) - MOVES AC TO RMS CTL FIELD
;
; ARGUMENTS: AS FOR $FETCH
;
DEFINE $STORE(AC$, FLD$, STR$)<
	$$ISOL(FLD$)			;;ISOLATES PARTS OF F$$'FLD$
	IFE <T$$SZ-^D18>,<		;;HALF-WORD FIELD
	    IFE T$$PS,<			;;RH
		HRRM AC$,T$$OF+STR$
		T$$SZ==0		;;INDIC INST GEN
	    >
	    IFE <T$$PS-^D18>,<		;;LH
		HRLM AC$,T$$OF+STR$
		T$$SZ==0		;;INDIC INST GEN
	    >
	>
	IFE <T$$SZ-^D36>,<		;;FULL-WORD FIELD
		MOVEM AC$,T$$OF+STR$
		T$$SZ==0		;INDIC INST GEN
	>
	IFN T$$SZ,<			;;OTHER CASE
		DPB AC$,[<T$$PS>B5 ! <T$$SZ>B11 ! <T$$OF+STR$>]
	>
>

; $$ISOL - TAKE F$$'FLD$ AND ISOL ITS CONSTITUENTS
;
DEFINE $$ISOL(FLD$)<
	T$$PS==F$$'FLD$_-^D30		;;TAKE HIGH-ORD 6 BITS
	T$$SZ==<F$$'FLD$_-^D24> & 77	;;NEXT 6 BITS
	T$$OF==F$$'FLD$ & 777777	;;RH
>

;****************************************************************
;******************   END OF RMSSYM.MPR   ***********************
;		FILE RMSSYM.MTB FOLLOWS.
;****************************************************************

SUBTTL	DEFINITION FILE PROCESSED BY MACRO AND BLISS
