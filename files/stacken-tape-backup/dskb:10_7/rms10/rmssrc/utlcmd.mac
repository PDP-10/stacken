TITLE	UTLCMD - SYNTAX TABLES FOR RMSUTL
SUBTTL A. UDDIN
SEARCH	RMSMAC,RMSINT,CMDPAR
$PROLOG(UTL)

P$COLON==0				;;INIT DEF OF IT
LSS==74b6				;;BECAUSE OF A MACRO BUG
GTR==76B6
LE==361720,,0
GE==371720,,0

; $AID - DEFINE NUMERIC FLD THAT IS USED TO IDENTIFY AN AREA ID
;
DEFINE $AID(NEXT$,KDOPT$,%NUM)<
	$NOISE	(%NUM,#)		;;INDIC CLASS RATHER THAN SCALAR
%NUM:	$NUMGE	(NEXT$,BASE10,area ID,<KDOPT$>)
>

; AK$TAB - DEFINES KYWD TABLE IN WHICH EACH ENTRY IS AN RMS ARG BLK FIELD
;
DEFINE AK$TAB(NEXT$,TYP$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<E.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	$KEY(NEXT$,TYP$'TB,<KOPT$>)	;;KEY TABLE
	TB$KEY(TYP$,<FLD$>)		;;DO THE REAL WORK
>

; AO$TAB - DEFINES DISPATCH TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE AO$TAB(T$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<E.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	$KEYDSP(T$'TB,<KOPT$>)		;;KEY TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
>

; AS$TAB - DEFINES SWITCH DISPATCH TABLE FOR RMS ARGBLK FIELDS
; DISPATCH LABEL IS LOCAL -- SO VALUE CAN BE PICKED UP
; PARSE CODE IS ADDRESS -- SO APPROP $STORE CAN BE DONE
;
DEFINE AS$TAB(T$,FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<E.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	P$COLON==1			;;APPEND COLONS
	$SWITCH	(0,T$'TB,<KDOPT$>)	;;DISPATCH TO KYWD TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
	P$COLON==0			;;TURN OFF
>

; AV$TAB - DEFINES TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE AV$TAB(NEXT$,TYP$,P$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<P$'$'X$>	;;SYMBOL IN RMSINT
	$KEY(NEXT$,TYP$'TB,<KOPT$>)	;;KEY TABLE
	TB$KEY(TYP$,<FLD$>)		;;DO THE REAL WORK
>

; $FILEF - ALLOW SYMBOLS THAT INCLUDE . < > : [ ]
;
DEFINE $FILEF (NXT$,HELP$,ARGS$) <$FNAME(NXT$,<HELP$>,<$BREAK(MSKFIL),ARGS$>)>

; $INDEX - DEFINE NUMERIC FLD THAT IS USED TO IDENTIFY AN ELEMENT OF A CLASS
;
DEFINE $INDEX(NEXT$,KDOPT$,%NUM)<
	$NOISE	(%NUM,#)		;;INDIC CLASS RATHER THAN SCALAR
%NUM:	$NUMGT	(NEXT$,BASE10,positive decimal number,<KDOPT$>)
>

; $KREF - DEFINE NUMERIC FLD THAT IS USED TO IDENTIFY A KEY OF REFERENCE
;
DEFINE $KREF(NEXT$,KDOPT$,%NUM)<
	$NOISE	(%NUM,#)		;;INDIC CLASS RATHER THAN SCALAR
%NUM:	$NUMGE	(NEXT$,BASE10,key of reference,<KDOPT$>)
>

; $MACF - ALLOW SYMBOLS THAT INCLUDE . $ - OR %
;
DEFINE $MACF (NXT$,HELP$,ARGS$) <$FNAME(NXT$,<HELP$>,<$BREAK(MSKMAC),ARGS$>)>

SUBTTL	DATA DECLARATIONS

BASE10==^D10				;FOR $NUM--- MACRO
BASE8==8

$IMPURE
$GDATA	(PDBPAG,1000)			;BLOCK FOR PARSED DATA

$DATA	(CHENT)				;ON IF CHANGING ENTRY (AS OPP ID)
$DATA	(QRFADO)			;VAR FOR RET VAL FROM RFADO
$DATA	(QVALDF)			;VAR FOR RET VAL FROM VALDF
$DATA	(VALDF)				;VAR FOR PDB OF CURR FLD'S DATTYP

CHABTO:	$NOISE	(0,TO)			;FOR AC$NOI IN CHANGE

$PURE

MSKFIL:
	FLDB0.				;WORD-N OF MASK
	FLDB1.&<^-<1B12!1B14!1B26!1B28!1B30>>
					;B12=, B14=. B26=: B28=< B30=>
	FLDB2.&<^-<1B27!1B29>>		;B27=[ B29=]
	FLDB3.
MSKMAC:
	FLDB0.				;WORD-N OF MASK
	FLDB1.&<^-<1B4!1B5!1B13!1B14>>	;B4=$ B5=% B13=- B14=.
	FLDB2.
	FLDB3.

SUBTTL	ACTION ROUTINES

; ACTION ROUTINES ARE EFFECTIVELY PART OF CMDPAR
; CMDPAR CALLS THEM WITH:
;	T1 = LENGTH OF CMD DATA BLK
;	T2 = ITS ADDR
; YOU SHOULD RETURN:
;	TF = -1 IF SUCCESSFUL
;	TF = 0 IF FAILED, WITH T2 = PTR TO ASCIZ ERR MSG

CHENACT:				;ACTION ROUTINE FOR CHANGE BKT ENT
	SETOM	CHENT			;INDIC CHANGE ENT
	JRST	CIEACT			;MERGE
CHIDACT:				;ACTION ROUTINE FOR CHANGE BKT ID
	SETZM	CHENT			;INDIC ID

CIEACT:
;
; SET PDB ON BASIC OF TYPE OF ENTRY BEING CHANGED
;
	MOVE	T1,UTLFLG		;CHK IF FILE OPEN
	TXNE	T1,UT%FOP		;IS IT?
	$SKIP				;NO
		MOVEI	T2,[ASCIZ/File not open/]
		SETZM	TF
		POPJ	P,
	$ENDIF
	MOVE	T1,CU$TYPE		;GET BKT INFO
	CASES	T1,MX%BTY
$CASE	(BTY%CLOB)
	MOVEI	T2,[ASCIZ/Current bucket has bad header/]
	SETZM	TF			;FAILURE RETURN
	POPJ	P,
$CASE	(BTY%IDX)
	MOVEI	T5,CIESET		;YES
	SKIPGE	CHENT			;ENTRY # SPEC?
	JRST	L$CASX			;YES, NO PROB
	MOVEI	T2,[ASCIZ/Current bucket not a data bucket/]
	SETZM	TF			;FAILURE RETURN
	POPJ	P,
$CASE	(BTY%PRIM)
	MOVE	T2,FAB			;ADDR OF FAB
	MOVEI	T5,CVESET		;ASSUME VAR LENGTH RECORDS
	$FETCH	T1,RFM,(T2)		;CHECK RECORD FORMAT
	CAIE	T1,FB$VAR		;VARIABLE FORMAT?
	MOVEI	T5,CFESET		;FIXED HEADER FORMAT
	JRST	L$CASX
$CASE	(BTY%SEC)
	MOVEI	T5,CSESET		;SECONDARY BKT.
$CASX
	MOVEM	T5,.NEXT		;SET NEXT PDB
	SETOM	TF			;SUCC RET
	POPJ	P,

SETDFV:
;
; ACTION ROUTINE FOR DATAfield VALUE, SET PDB FROM DATA TYPE OF FLD
;
	MOVE	T5,CR.SAV(T2)		;GET ADDRESS OF PARSE DATA
	$CALL	SY.FIND,<0(T5)>		;PASS THE CURR TOK
	JUMPT	L$IFX			;A MATCH?
	  MOVEI	T2,[ASCIZ/Name not known/] ;NO, TELL CALLER
	  SETZM	TF			;FAILURE RET
	  POPJ	P,
	$ENDIF
	MOVEI	T5,VALQUO		;ASSUME STRING
	LOAD	T2,UF.TYP(T1)		;GET ACTUAL DATA TYPE
	CAIN	T2,DFT%DEC		;IS IT DEC INTEGER?
	MOVEI	T5,VALDEC		;YES
	CAIN	T2,DFT%OCT		;IS IT OCTAL INT?
	MOVEI	T5,VALOCT		;YES
	CAIN	T2,DFT%FLO		;IS IT FLOATING PT VAL?
	MOVEI	T5,VALFLO		;YES
	MOVEM	T5,VALDF		;SETUP NEXT PDB
	SETOM	T1
	POPJ	P,

REDCAS:
;
; ACTION ROUTINE FOR REDEFINE, SET PDB FROM TYPE OF SYMBOL
;
	MOVE	T5,CR.SAV(T2)		;GET ADDRESS OF PARSE DATA
	$CALL	SY.FIND,<0(T5)>		;PASS THE DATA FOR CURR TOK
	JUMPT	L$IFX			;A MATCH?
	  MOVEI	T2,[ASCIZ/Name not known/] ;NO, TELL CALLER
	  SETZM	TF			;FAILURE RET
	  POPJ	P,
	$ENDIF
	SETZM	T3			;INDIC NO PDB SET YET
	$FETCH	T2,BID,(T1)		;GET TYPE OF FLD
	CAIN	T2,DA$TYP		;DAT FLD?
	MOVEI	T3,DEFDAS		;YES
	CAIE	T2,XA$TYP		;XAB?
	$SKIP				;YES
	  $FETCH T2,COD,(T1)		;GET TYPE OF XAB
	  CAIN	T2,XB$KEY		;KEY?
	  MOVEI	T3,DEFXBC		;YES
	  CAIN	T2,XB$ALL		;AREA?
	  MOVEI	T3,DEFBKZ		;YES
	$ENDIF
	JUMPE	T3,L$ERRU(IUE)		;UNKNOWN TYPE CODES IN BLK
	MOVEM	T3,.NEXT		;SET NEXT PDB
	SETOM	TF			;SUCC RET
	POPJ	P,

SUBTTL	TOP-LEVEL SYNTAX OF RMSUTL

UTLCMD::			 	;ARG BLK PASSED ON EACH PARSE$ CALL
	CMDINI				;1ST PDB PASSED TO COMND ON EACH CMD
	[ASCIZ/RMSUTL>/]		;PROMPT STRING
	PDBPAG				;PAGE FOR PARSED DATA
	0				;USE TTY FOR CMD INPUT & OUTPUT

CMDINI:	$INITC(CMDS)			;THE INIT-CMD PARSER DESC BLK

CMDS:	CM$TAB	(<CHANGE,CLOSE,DEFINE,DELETE,DISPLAY,EXIT,FIX,HELP,INFORMATION,OPEN,REDEFINE,SET,SPACE,TAKE,UNCLUTTER,VERIFY>,$BREAK(MSKMAC))

CFM:	$CRLF			;CRLF IS COMMON TERMINATOR OF COMMANDS

SUBTTL	SYNTAX OF CHANGE COMMAND

;General Syntax:
;---------------
;
; CHANGE (VALUE OF) object location (SETTING) to-list
;	 WHERE <to-list> IS:  <field-name> (TO) <value>

; TOP-LEVEL DISPATCH
;
VAR$AD==QVALDF			;FOR AC$SET TO CHANGE DATFLD
.CHANG:	$NOISE (CHAENT,VALUE OF,<AC$SET(CHDCOM)>)
CHAENT:	OP$TAB	(CHA,<BUCKET,<PROLOGUE,PROLOGUE-DATA>>,<$ALTERN(CHADF)>)


;CHANGE to-list (FOR RECORDS IDENTIFIED BY) records-to-use
;

;CHGDAT:$SUB	(CHDCOM,CHADF)	;BECAUSE CHG DF IS $ALTERN, QVALDF PRESET
CHDCOM:	$COMMA	(CHADF,<$ALTERN(RTUSEL)>)

CHADF:	$MACF	(CHDTO,<datafield-name>,$ACTION(SETDFV))
CHDTO:	$NOISE	(@VALDF,<TO>)

CBEDF:	KY$WRD	(CBEDFN,CBED,DATAFIELD)	;MERGE FOR CHANGE BKT ENTRY datafld-list
CBEDFN:	$NOISE	(CHADF,NAMED)		;...CAN BE CAUSE QVALDF ALREADY SET	

;CHANGE (VALUE OF) BUCKET (AT) HEADER!ENTRY n1!ID n2 (SETTING) to-list


; CHANGE BUCKET DISPATCH
;
CHABUC:	$NOISE	(BUCOPT,<AT>)
BUCOPT:	OP$TAB	(CHG,<ENTRY,HEADER,ID>)

; CHANGE BUCKET HEADER
;

CHGHEA:	$NOISE	(HTOLST,<SETTING>)
CBHCOM:	$COMMA	(HTOLST,$ALTERN(CFM))
HTOLST:	AO$TAB	(CBH,<<ANO,<AREA-NUMBER>>,<IBA,ATTRIBUTES>,<LID,<LAST-ID>>,LEVEL,<NBP,<NEXT-BUCKET>>,<NID,<NEXT-ID>>,<IBT,TYPE>,<WIU,WORDS-IN-USE>>,AC$NOI(CHABTO))
CBHANO:	$NUMGE	(CBHCOM,BASE10,<area-ID of bucket>)
CBHIBT:	AV$TAB	(CBHCOM,IBT,IB,<DATA,INDEX>)
CBHLID:	$NUMGE	(CBHCOM,BASE10,<maximum ID for this bucket>)
CBHLEV:	$NUMGE	(CBHCOM,BASE10,<# of index levels to data-level>)
CBHNBP:	$NUMGE	(CBHCOM,BASE10,<page number of next bucket>)
CBHNID:	$NUMGE	(CBHCOM,BASE10,<ID that will be assigned next entry>)
CBHWIU:	$NUMGE	(CBHCOM,BASE10,<# of words used in bucket>)

CBHIBA:	AV$TAB	(CIBAPL,IBA,IB,<NIL,RIGHTMOST,ROOT>)
CIBAPL:	$TOKEN	(CBHIBA,+,<$ALTERN(CBHCOM)>)

;CHANGE ENTRY: GET OBJECT NUMBER & SETUP OPTIONS FOR REMAINDER OF CMD LINE

CHGID:	$INDEX	(0,$ACTION(CHIDACT))
CHGENT:	$INDEX	(0,$ACTION(CHENACT))

; CHANGE ENTRY to-list FOR INDEX ENTRY
;
CIESET:	$NOISE	(CIEOPT,<SETTING>)
CIEOPT:	AO$TAB	(CIE,<<IRA,ATTRIBUTES>,<DBP,DOWN-POINTER>,<IKV,KEY-VALUE>>,AC$NOI(CHABTO))
CIEDBP:	$NUMGT	(CIECMA,BASE10,<page number of a bucket>)
CIEIKV:	$QUOTE	(CIECMA,<Quoted key>)
CIECMA:	$COMMA	(CIEOPT,<$ALTERN(CFM)>)

CIEIRA:	AV$TAB	(CIATPL,IAT,IR,<HIKEY,NIL>)
CIATPL:	$TOKEN	(CIEIRA,+,<$ALTERN(CIECMA)>)

; CHANGE ENTRY to-list FOR VARIABLE-LENGTH UDR
;
VAR$AD==QVALDF			;FOR AC$SET
CVESET:	$NOISE	(CVEOPT,SETTING,<AC$SET(CVECMA)>)
CVEOPT:	AO$TAB	(CVE,<<IRA,ATTRIBUTES>,<RID,ENTRY-ID>,RFA,<IRS,SIZE>>,<$ALTERN(CBEDF),AC$NOI(CHABTO)>)

CVERID:	$NUMGT	(CVECMA,BASE10,<ID to assign this entry>)
CVERFA:	$SUB	(CVECMA,RFADO)
CVEIRS:	$NUMGE	(CVECMA,BASE10,<bytes in the record>)
CVECMA:	$COMMA	(CVEOPT,<$ALTERN(CFM)>)

CVEIRA:	AV$TAB	(CVATPL,VAT,IR,<DELETED,KEEP,NIL,POINTER>)
CVATPL:	$TOKEN	(CVEIRA,+,<$ALTERN(CVECMA)>)

; CHANGE ENTRY to-list FOR FIXED-LENGTH UDR
;
VAR$AD==QVALDF			;FOR AC$SET
CFESET:	$NOISE	(CFEOPT,SETTING,<AC$SET(CFECMA)>)
CFEOPT:	AO$TAB	(CFE,<<RID,ENTRY-ID>,RFA>,<$ALTERN(CBEDF),AC$NOI(CHABTO)>)
CFERID:	$NUMGT	(CFECMA,BASE10,<ID to assign this entry>)
CFERFA:	$SUB	(CFECMA,RFADO)
CFECMA:	$COMMA	(CFEOPT,<$ALTERN(CFM)>)

CFEIRA:	AV$TAB	(CFATPL,FAT,IR,<DELETED,KEEP,NIL,POINTER>)
CFATPL:	$TOKEN	(CFEIRA,+,<$ALTERN(CFECMA)>)

; CHANGE ENTRY to-list FOR SIDR ENTRY
;
CSESET:	$NOISE	(CSEOPT,<SETTING>)
CSEOPT:	AO$TAB	(CSE,<<RID,ENTRY-ID>,<SKV,KEY-VALUE>,<SRS,SIZE>>,<$ALTERN(CSRFA),AC$NOI(CHABTO)>)
CSERID:	$NUMGT	(CSECMA,BASE10,ID to assign this entry)
CSESKV:	$QUOTE	(CSECMA,<Quoted key>)
CSESRS:	$NUMGT	(CSECMA,BASE10,# of words after header)
CSECMA:	$COMMA	(CSEOPT,<$ALTERN(CFM)>)

CSEIRA:	AV$TAB	(CSATPL,SAT,IR,<NIL>)
CSATPL:	$TOKEN	(CSEIRA,+,<$ALTERN(CSECMA)>)

CSRFA:	AO$TAB	(CSR,<<RFEL,RFA>>)
CSRRFE:	$INDEX	(CSRFTO)
	VAR$AD==QRFADO			;CANT ALTERN TO SUB
CSRFTO:	$NOISE	(CSRRFA,TO,AC$SET(CSECMA))
CSRRFA:	KY$WRD	(CSECMA,RNIL,<NIL>,$ALTERN(RFADO))

;CHANGE (VALUE OF) PROLOG-DATA (FOR) FILE!AREA n1!KEY n2 (SETTING) to-list
;

CHAPRO:	$NOISE	(CPROPT,<FOR>)
CPROPT:	OP$TAB	(CHN,<AREA,FILE,KEY>)
CHFCOM:	$COMMA	(CPFOPT,$ALTERN(CFM))		;FOR SUBSEQ FLDS
CHKCOM:	$COMMA	(CPKOPT,$ALTERN(CFM))

; CHANGE PROLOG AREA
;
CHNARE:	$AID	(ASETNG)
ASETNG:	$NOISE	(ATOLST,<SETTING>)
ATOLST:	AO$TAB	(ABKZ,<<BKZ,BUCKET-SIZE>>)
ABKZBK:	$NOISE	(BKTVAL,<TO>)
BKTVAL:	$NUMGE	(CFM,BASE10,pages per bucket)

; CHANGE PROLOG FILE
;
CHNFIL:	$NOISE	(CPFOPT,<SETTING>)
CPFOPT:	AO$TAB	(CPF,<<ARC,AREA-COUNT>,<ARO,AREA-OFFSET>,<BKS,<BUCKET-SIZE>>,<BSZ,<BYTE-SIZE>>,<KYC,<KEY-COUNT>>,<KYO,<KEY-OFFSET>>,<MRS,<MAXIMUM-RECORD-SIZE>>,<ORG,<ORGANIZATION>>,<PIF,<PAGES-IN-FILE>>,<RFM,RECORD-FORMAT>>,AC$NOI(CHABTO))

CPFBKS:	$NUMGE	(CHFCOM,BASE10)
CPFBSZ:	$NUMGE	(CHFCOM,BASE10)
CPFMRS:	$NUMGE	(CHFCOM,BASE10)
CPFORG:	AV$TAB	(CHFCOM,ORZ,FB,<INDEXED,RELATIVE,SEQUENTIAL>)
	FB$IND==FB$IDX				;DEFINE SYMBOL AV$TAB EXPECTS
CPFRFM:	AV$TAB	(CHFCOM,RFM,FB,<FIXED,VARIABLE>)

CPFARC:	$NUMGE	(CHFCOM,BASE10,<number of areas>)
CPFARO:	$NUMGE	(CHFCOM,BASE10,<offset of first area descriptor>)
CPFPIF:	$NUMGE	(CHFCOM,BASE10,<next available page>)
CPFKYC:	$NUMGE	(CHFCOM,BASE10,<number of keys in file>)
CPFKYO:	$NUMGE	(CHFCOM,BASE10,<offset of first key descriptor>)

; CHANGE PROLOG KEY n
;
CHNKEY:	$KREF	(CPKSET)
CPKSET:	$NOISE	(CPKOPT,<SETTING>)
CPKOPT:	AO$TAB	(CPK,<<KYA,ATTRIBUTES>,<DAN,DATA-AREA>,<DFL,DATA-FILL>,<DTP,DATA-TYPE>,<IAN,INDEX-AREA>,<IFL,INDEX-FILL>,<REF,KEY-OF-REFERENCE>,<LVS,LEVELS>,<NKP,NEXT-KEY>,<ROOT,ROOT-PAGE>>,<$ALTERN(CPKSEG),AC$NOI(CHABTO)>)
CPKSEG:	AO$TAB	(CKS,<<POS,POSITION>,<SIZ,SIZE>>)

CPKLVS:	$NUMGE	(CHKCOM,BASE10,<# of levels in index structure>)
CPKNKP:	$NUMGE	(CHKCOM,BASE10,<offset of next key descriptor>)
CPKROO:	$NUMGE	(CHKCOM,BASE10,<page of index's root>)
CPKDAN:	$NUMGE	(CHKCOM,BASE10,<area ID of key's data buckets>)
CPKDFL:	$NUMGE	(CHKCOM,BASE10,max words to load in key's data buckets)
CPKDTP:	AV$TAB	(CHKCOM,DT,XB,<SIXBIT,<STG,ASCII>,EBCDIC>)
CPKIAN:	$NUMGE	(CHKCOM,BASE10,<area ID of key's index buckets>)
CPKIFL:	$NUMGE	(CHKCOM,BASE10,max words to load in key's index buckets)
CPKREF:	$NUMGE	(CHKCOM,BASE10,<key-of-reference>)

CPKKYA:	AV$TAB	(CKATPL,KAT,XB,<<CHG,CHANGES-ALLOWED>,<DUP,DUPLICATES-ALLOWED>,NIL>)
CKATPL:	$TOKEN	(CPKKYA,+,$ALTERN(CHKCOM))

CKSPOS:	$NOISE	(POSIDX,<OF SEGMENT>)
POSIDX:	$INDEX	(POSTO)
POSTO:	$NOISE	(POSIT,TO)
POSIT:	$NUMGE	(CHKCOM,BASE10,<# of bytes before key segment>)

CKSSIZ:	$NOISE	(SIZIDX,<OF SEGMENT>)
SIZIDX:	$INDEX	(SIZTO)
SIZTO:	$NOISE	(SIZIT,TO)
SIZIT:	$NUMGE	(CHKCOM,BASE10,<bytes in key segment>)

SUBTTL	SYNTAX OF CLOSE

; CLOSE RMSFILE ! REPORT
;
.CLOSE:	$NOISE	(CLOTYP,<FILE TYPE>)
CLOTYP:	KY$TAB	(CFM,CLO,<REPORT,<RMS,RMS-FILE>>)


SUBTTL	SYNTAX OF DEFINE COMMAND

.DEFIN:	$NOISE	(DEFTYP,OBJECT)
DEFTYP:	OP$TAB	(DEF,<AREA,DATAFIELD,FILE,KEY>)		;PROC APPROP OPTION

; SYNTAX TO DEFINE A DATA RECORD AND IT'S FIELDS:
; ----------------------------------------------
;
;	DEFINE  DATAFIELD datafieldname (WITH TYPE) ASCII!FILE-BYTES!SIXBIT
;		(WITH LENGTH) n1 (STARTING AT BYTE) n2
;
;	DEFINE DATAFIELD datafieldname INTEGER (STARTING AT WORD) n3
;

DISW%D==DFT%DEC
DISW%O==DFT%OCT
DESW%D==0
DEFDAT:	$NOISE	(DEFDNM,NAMING IT)
DEFDNM:	$MACF	(DEFDAS,<field name>)
DEFDAS:	$NOISE	(DEDTYP,WITH TYPE)
DEDTYP:	OP$TAB	(DFT,<ASCII,<FILE,FILE-BYTES>,FLOATING,INTEGER,SIXBIT>)

DFTFLO:	$NOISE	(DEDFLW,STARTING AT WORD)
DEDFLW:	$NUMGE	(DEDKEY,BASE10,<number of words before field>,$ALTERN(DEDKEY))

DFTINT:	$NOISE	(DEDINW,STARTING AT WORD)
DEDINW:	$NUMGE	(DEDISW,BASE10,<number of words before field>,$ALTERN(DEDISW))
DEDISW:	SV$TAB	(DESW,<DISPLAY>,$ALTERN(DEDKEY))
	DESW%D==KD%DIS				;COMMON TABLE WITH KEY ATTR
DESWDI:	KY$TAB	(CFM,DISW,<DECIMAL,OCTAL>,$DEFAULT(DECIMAL))

DFTASC:
DFTFIL:
DFTSIX:	$NOISE	(DEDLEN,WITH LENGTH)
DEDLEN:	$NUMGT	(DEDBYT,BASE10,<number of bytes in field>)
DEDBYT:	$NOISE	(DEDBNM,STARTING AT BYTE)
DEDBNM:	$NUMGE	(DEDKEY,BASE10,<number of bytes before field>,$ALTERN(DEDKEY))

DEDKEY:	SW$TAB	(DDK,<KEY>,$ALTERN(DKEYSW))
DDKKEY==CFM
	DDK%KEY==KD%KEY				;COMMON TAB WITH KEY ATTR

; SYNTAX TO DEFINE A FILE (SEE TABLES FOR SPELLED OUT SWITCHES):
; -----------------------
;
;DEFINE FILE file-name (WITH ORGANIZATION)
;
; FOR V1:
;		INDEXED (WITH KEYS) key-name-list [/MRS /BSZ /RFM]
;
; IN FUTURE:
;		RELATIVE (WITH CELL SIZE) n [/MRN /BSZ /RFM /BLOCK]
;		SEQUENTIAL [/MRS /BSZ /RFM /BLOCK]
;		ASCII
;		LINE-SEQUENCED

DEFFIL:	$NOISE	(DEFFNM,NAMING IT)
DEFFNM:	$FILEF	(DEFORN,<file spec>)
DEFORN:	$NOISE	(DEFORG,WITH ORGANIZATION)
DEFORG:	OP$TAB	(DFO,<INDEXED>)		;,LSA,RELATIVE,SEQUENTIAL,STREAM>)

DFOIND:	$NOISE	(DFKNAM,WITH KEYS)
DFKNAM:	$MACF	(DFCOMA,<key-name>)
DFCOMA:	$COMMA	(DFKnam,<$ALTERN(DFISW)>)
DFISW:	SV$TAB	(DFI,<<BKS,BUCKET-SIZE>,<BSZ,BYTE-SIZE>,<RFM,FORMAT>,<MRS,RECORD-SIZE>>,<$ALTERN(DFI.DF)>)
DFI.DF:	$CRLF	($HELP<confirm with CRLF (defaults are BYTE-SIZE=7, FORMAT=VAR)>)
DFIBKS:	$NUMGE	(DFISW,BASE10,default pages per bucket)
DFIBSZ:	$NUMGE	(DFISW,BASE10,bits per byte)
DFIMRS:	$NUMGE	(DFISW,BASE10,bytes per record)
DFIRFM:	AV$TAB	(DFISW,DER,FB,<FIX,VAR>)

;DFRAT:	AV$TAB	(DEFFF,DRA,FB,<BLK>)
;DFRFM:	AV$TAB	(DEFFE,DFR,FB,<FIX,VAR>)
;DEFFE:	SV$TAB	(DE,<BSZ,MRN,MRS,RAT>,<$ALTERN(DFNDEF)>)
;DEBSZ:	$NUMGE	(DEFFE,BASE10,<byte size>)
;DEMRN:	$NUMGE	(DEFFE,BASE10,<maximum record number>)
;DEMRS:	$NUMGE	(DEFFE,BASE10,<maximum record size>)
;DERAT:	AV$TAB	(DEFFE,DRB,FB,<BLK>)

;SYNTAX TO DEFINE AN AREA
;------------------------
;
;	DEFINE AREA (NAMING IT) area-name (WITH BUCKET SIZE) n
;

DEFARE:	$NOISE	(DEFANM,NAMING IT)
DEFANM:	$MACF	(DEFBKZ,<area-name>)
DEFBKZ:	$NOISE	(DFBKZ,<WITH BUCKET SIZE>)
DFBKZ:	$NUMGE	(CFM,BASE10,# of pages per bucket)


;SYNTAX TO DEFINE A KEY DESCRIPTION:
;-----------------------------------
;
;	DEFINE KEY key-name (WITH SEGMENTS) segment-list [SWITCHES]
;

DEFKEY:	$NOISE	(DEFKNM,NAMING IT)
DEFKNM:	$MACF	(DEFXBC,<key-name>)
DEFXBC:	$NOISE	(DFSNAM,WITH SEGMENTS)
DFSNAM:	$MACF	(DSCOMA,<segment-name>)
DSCOMA:	$COMMA	(DFSNAM,<$ALTERN(DKEYSW)>)

DKEYSW:	SW$TAB	(KD,<<CHA,CHANGES-ALLOWED>,<DFL,DAFILL:>,<DAN,DANAME:>,<DUP,DUPLICATES-ALLOWED>,<IFL,IAFILL:>,<IAN,IANAME:>>,$ALTERN(CFM))
KDCHA==DKEYSW
KDDUP==DKEYSW
KDDAN:	$MACF	(DKEYSW,<area name>)
KDDFL:	$NUMGE	(DKEYSW,BASE10,max words to load in key's data buckets)
KDIAN:	$MACF	(DKEYSW,<area name>)
KDIFL:	$NUMGE	(DKEYSW,BASE10,max words to load in key's index buckets)

SUBTTL	SYNTAX OF DELETE COMMAND

.DELET:	$NOISE	(DELEOP,<OBJECT>)
DELEOP:	OP$TAB	(DEL,<<BUC,BUCKET-ENTRY>,RECORD>)


; DELETE (OBJECT) BUCKET-ENTRY (IDENTIFIED BY) ENTRY n1!ID n2
;

DELBUC:	$NOISE	(DELOPT,<IDENTIFIED BY>)
DELOPT:	KY$TAB	(DELVAL,DLT,<ENTRY,ID>)
DELVAL:	$INDEX	(CFM)


; DELETE (OBJECT) RECORD (IDENTIFIED BY) records-to-use
;

DELREC:	$NOISE	(RTUSEL,<IDENTIFIED BY>)

SUBTTL	SYNTAX OF DISPLAY COMMAND

; DISPLAY PROLOGUE-DATA!BUCKET!DATA!<datafield>  ........
;	DISPLAY PROLOGUE-DATA (FOR) FILE!AREA n1!KEY n2
;
;	DISPLAY BUCKET (AT) ENTRY n1-list!ID n2-list!HEADER!KEY-VALUE!LARGEST-ENTRY
;
;	DISPLAY DATA!<datafield> (FOR RECORDS IDENTIFIED BY) .....
;
.DISPL:	$NOISE	(DSPVAL,<VALUE OF>)
DSPVAL:	OP$TAB	(DSP,<BUCKET,DATA,<PROLOGUE,PROLOGUE-DATA>>,<$ALTERN(DSPDAF)>)

DSPBUC:	$NOISE	(DISBUC,<AT>)
DISBUC:	OP$TAB	(DIS,<ENTRY,HEADER,ID,<KEY,KEY-VALUE>,<LAST,LARGEST-ENTRY>>,$ALTERN(CFM))
DISENT:	$INDEX	(DIBETO,,DIBELO)
DIBETO:	$NOISE	(DIBEHI,TO)
DIBEHI:	$NUMGE	(DIBECM,BASE10,larger number,$ALTERN(DIBECM))
DIBECM:	$COMMA	(DIBELO,<$ALTERN(CFM)>)
DISID==DISENT
DISHEA==CFM
DISKEY:	$NOISE	(DISKEV,GREATER OR EQUAL TO)
DISKEV:	$QUOTE	(CFM,<Quoted key>)
DISLAS==CFM

DSPDAT:	$NOISE	(RTUSEL,<FOR RECORDS IDENTIFIED BY>)

DSPPRO:	$NOISE	(DSOPT,<FOR>)
DSOPT:	OP$TAB	(DS,<AREA,FILE,KEY>,<$ALTERN(CFM)>)

DSAREA:	$AID	(CFM)
DSFILE: AK$TAB	(DSFCON,DSF,<<ARC,AREA-COUNT>,<ARO,AREA-OFFSET>,<BKS,<BUCKET-SIZE>>,<BSZ,<BYTE-SIZE>>,<KYC,KEY-COUNT>,<KYO,KEY-OFFSET>,<MRS,<MAXIMUM-RECORD-SIZE>>,<ORG,<ORGANIZATION>>,<PIF,<PAGES-IN-FILE>>,<RFM,<RECORD-FORMAT>>>,<$ALTERN(CFM)>)
DSFCON:	$COMMA	(DSFILE,<$ALTERN(CFM)>)

DSKEY:	$KREF	(IDXFLD)
IDXFLD:	AK$TAB	(IDXCON,DIX,<<KYA,ATTRIBUTES>,<DAN,DATA-AREA>,<DFL,<DATA-FILL>>,<DTP,<DATA-TYPE>>,<IAN,<INDEX-AREA>>,<IFL,<INDEX-FILL>>,<REF,<KEY-OF-REFERENCE>>,<LVS,LEVELS>,<NKP,<NEXT-KEY>>,POSITION,<ROOT,ROOT-PAGE>,SIZE>,$ALTERN(CFM))
IDXCON:	$COMMA	(IDXFLD,<$ALTERN(CFM)>)

DSPDAF:	$MACF	(DSPDFC,<datafield-name>)
DSPDFC:	$COMMA	(DSPDAF,$ALTERN(RTUSEL))

SUBTTL	SYNTAX OF EXIT COMMAND

;EXIT	(to monitor)
;
.EXIT:	$NOISE (CFM,<TO MONITOR>)


SUBTTL	SYNTAX OF FIX COMMAND

; FIX RFA-list
;

.FIX:	$NOISE	(FIXRFA,<RECORD WITH RFA>)
FIXRFA:	$SUB	(FIXIDX,RFADO)
FIXIDX:	$NOISE	(FIXKRF,OF INDEX)
FIXKRF:	$NUMGE	(FIXCMA,BASE10,key of reference,$DEFAULT(0))
FIXCMA:	$COMMA	(FIXRFA,$ALTERN(CFM))


SUBTTL	SYNTAX OF HELP COMMAND

;HELP		(please)
;
.HELP:	$NOISE (CFM,<PLEASE>)


SUBTTL	SYNTAX OF INFO COMMAND

;INFO	ALL!AREAS!CONTEXT!DATAFIELDS!KEYS
;
.INFOR:	$NOISE	(INFTYP,ABOUT)
INFTYP:	KY$TAB	(CFM,INF,<ALL,AREAS,CONTEXT,DATAFIELDS,KEYS>)


SUBTTL		SYNTAX OF OPEN COMMAND

;OPEN (FILETYPE) RMSFILE (WITH NAME) file-name (FOR) INPUT!OUTPUT
;OPEN (FILE TYPE) REPORT (WITH NAME) file-name /APPEND
;

.OPEN:	$NOISE	(OPNTYP,<FILE TYPE>)
OPNTYP:	OP$TAB	(OPE,<REPORT,<RMS,RMS-FILE>>)
OPEREP:	$NOISE	(REPNAM,<WITH NAME>)
REPNAM:	$FILEF	(REPSWI,<file spec>)
REPSWI:	SW$TAB	(OPN,<APPEND>,$ALTERN(CFM))
OPNAPP:	$CRLF

OPERMS:	$NOISE	(RMSNAM,<WITH NAME>)
RMSNAM:	$FILEF	(RMSOPT,<file spec>)
RMSOPT:	$NOISE	(OPNIO,<FOR>)
OPNIO:	KY$TAB	(OPNMOD,OP,<INPUT,OUTPUT,PATCHING>,$DEFAULT(INPUT))
OPNMOD:	SW$TAB	(OSRM,<<MAX,MAXIMUM-RECORD-SIZE:>>,$ALTERN(CFM))
	OSRM%M=0
OSRMMAX:$NUMGE	(CFM,BASE10,bytes in largest record)

SUBTTL	SYNTAX OF REDEFINE CMD

;REDEFINE (NAME) BLK-NAME ... [CONTINUE WITH DEFINE CMD]
;

.REDEF:	$NOISE	(REDNAM,NAME)
REDNAM:	$MACF	(0,already DEFINEd name,$ACTION(REDCAS))

;REDCAS SETS NEXT PDB TO MERGE WITH APPROP DEFINE OPTION

SUBTTL		SYNTAX OF SET COMMAND

.SET:	$NOISE	(SETENT,<CURRENT>)
SETENT:	OP$TAB	(SET,<BUCKET,INDEX,RECORD>)

;SET (CURRENT) INDEX (USING KRF) n [(AND) ROOT ! PAGE n ! RFA a/b]
;
SETIND:	$NOISE	(SINKRF,USING KEY OF REFERENCE)
SINKRF:	$NUMGE	(SINLOC,BASE10)
SINLOC:	$NOISE	(SINLTY,AND)
SINLTY:	OP$TAB	(SIL,<BUCKET,RFA,ROOT>,$DEFAULT(ROOT))
SILBUC:	$NOISE	(SILBUV,AT PAGE)
SILBUV:	$NUMGT	(CFM,BASE10,file page number)
SILRFA:	$NOISE	(SILRFV,BKT/ID)
SILRFV:	$SUB	(CFM,RFADO)
SILROOT==CFM

; SET BUCKET (TO ...) DATA-LEVEL!DOWN!ENTRY n!LAST-RECORD!NEXT!ROOT n!UP
;
SETBUC:	$NOISE	(SBKT,<TO ONE IDENTIFIED BY>)
SBKT:	OP$TAB	(STB,<<DATA,DATA-LEVEL>,DOWN,<LAST,LAST-RECORD>,NEXT,ROOT,UP>)
STBDAT==CFM
STBDOW:	$NOISE	(STBDNU,USING ENTRY)
STBDNU:	$NUMGT	(CFM,BASE10, positive decimal number,$DEFAULT(1))
STBLAS==CFM
STBNEX==CFM
STBROO==CFM
STBUP==CFM

; SET RECORD (TO ...)  [KEY range ! ! LAST ! REL range]   [(AND) name opr value]
;
SETREC:	$NOISE	(RTUSEL,<TO FIRST ONE IDENTIFIED BY>)

RTUSEL:	OP$TAB	(RTU,<KEY,<LAST,LAST-ENTRY>,<REL,RELATIVE-REC-NO>>,$ALTERN(CFM))
RTULAS==CFM
RTUKEY:	$KREF	(RTUFRO,$ALTERN(RTUST1))
RTUFRO:	$NOISE	(RTUST1,FROM)
RTUST1:	$QUOTE	(RTUKTO,<quoted key>,<$ALTERN(RTUKY1)>)
RTUKY1:	KY$WRD	(RTUKTO,RTUL,<LOWEST>)
RTUKTO:	$NOISE	(RTUST2,<TO>)
RTUST2:	$QUOTE	(RTUTST,<quoted key>,<$ALTERN(RTUKY2)>)
RTUKY2:	KY$TAB	(RTUTST,RUH,<<FOUND,FOUND-KEY-VALUE>,HIGHEST>,$ALTERN(RTUCFM))

RTUREL:	$NOISE	(RTUNUM,FROM)
RTUNUM:	$NUMGE	(RTUNTO,BASE10)
RTUNTO:	$NOISE	(RTUN2,<TO>)
RTUN2:	$NUMGE	(RTUTST,BASE10,<larger number>,$ALTERN(CFM))

VAR$AD==QVALDF				;FOR RET VAR AFTER DATTYP DEP DF VAL
RTUTST:	$NOISE	(RTUCFM,<AND>)
RTUCFM:	$CRLF	($ALTERN(RTUSYM))
RTUSYM:	$MACF	(RTUOPR,<datafield to test>,$ACTION(SETDFV))
RTUOPR:	$NOISE	(RTUEQL,OPERATOR,AC$SET(CFM))
RTUEQL:	$TOKEN	(RTUVAL,=,<$ALTERN(RTUNE)>)
RTUNE:	$TOKEN	(RTUVAL,#,<$ALTERN(RTUGE)>)
RTUGE:	$OTOK	(RTUVAL,GE,<$ALTERN(RTUGTR)>)
RTUGTR:	$OTOK	(RTUVAL,GTR,<$ALTERN(RTULE)>)
RTULE:	$OTOK	(RTUVAL,LE,<$ALTERN(RTULSS)>)
RTULSS:	$OTOK	(RTUVAL,LSS)
RTUVAL:	$NOISE	(@VALDF,VALUE)

SUBTTL	PROCESS THE SPACE CMD

;	SPACE (USAGE OF FILE FROM) verify-options

.SPACE:	$NOISE	(SPAOPT,USAGE OF FILE FROM)
SPAOPT:	OP$TAB	(SPA,<<ALL,ALL-KEYS>,KEY,<SEC,SECONDARY-KEYS>>,$DEFAULT(ALL-KEYS))
SPAKEY:	$KREF	(SPFROM)
SPFROM:	$NOISE	(SPSTR1,FROM)
SPSTR1:	$QUOTE	(SPTO,<quoted key>,<$ALTERN(SPKY1)>)
SPKY1:	KY$WRD	(SPTO,SP1,<LOWEST>,$ALTERN(CFM))
SPTO:	$NOISE	(SPSTR2,<TO>)
SPSTR2:	$QUOTE	(CFM,<quoted key>,<$ALTERN(SPKY2)>)
SPKY2:	KY$WRD	(CFM,SP2,<HIGHEST>,$ALTERN(CFM))
SPAALL==CFM
SPASEC==CFM

SUBTTL	PROCESS THE UNCLUTTER COMMAND

;	UNCLUTTER (FILE) [keys-to-use] /PROGRESS:n2

.UNCLU:	$NOISE	(UNCST1,<INDEX FILE FROM>)
UNCST1:	$QUOTE	(UNCTO,<quoted key>,<$ALTERN(UNCKY1)>)
UNCKY1:	KY$WRD	(UNCTO,UCL,<LOWEST>,$ALTERN(UNCSW))
UNCTO:	$NOISE	(UNCST2,<TO>)
UNCST2:	$QUOTE	(UNCSW,<quoted key>,<$ALTERN(UNCKY2)>)
UNCKY2:	KY$WRD	(UNCSW,UCH,<HIGHEST>,$ALTERN(UNCSW))
UNCSW:	UCS%PRO==VSW%PRO			;TREAT AS COMMON TABLE
	SV$TAB	(UCS,<PROGRESS>,<$ALTERN(CFM)>)
UCSPRO:	$NUMGT	(UNCSW,BASE10,<frequency to show progress>)


SUBTTL	PROCESS THE VERIFY COMMAND

; VERIFY [KEY n [key-range] ! SECONDARY ! ALL] /NOACCESS/NOFIX/PROGRESS:n2

.VERIF:	$NOISE	(VEROPT,<INDEX FILE UPON>)
VEROPT:	OP$TAB	(VER,<<ALL,ALL-KEYS>,KEY,<SEC,SECONDARY-KEYS>>,$DEFAULT(ALL-KEYS))
VERKEY:	$KREF	(VFROM)
VFROM:	$NOISE	(VRSTR1,FROM)
VRSTR1:	$QUOTE	(VRTO,<quoted key>,<$ALTERN(VRKY1)>)
VRKY1:	KY$WRD	(VRTO,VR1,<LOWEST>,$ALTERN(VRYSW))
VRTO:	$NOISE	(VRSTR2,<TO>)
VRSTR2:	$QUOTE	(VRYSW,<quoted key>,<$ALTERN(VRKY2)>)
VRKY2:	KY$WRD	(VRYSW,VR2,<HIGHEST>,$ALTERN(VRYSW))
VRYSW:	SW$TAB	(VSW,<<ACC,NOACCESS>,<FIX,NOFIX>,<PROG,PROGRESS:>>,$ALTERN(CFM))
VSWACC==VRYSW
VSWFIX==VRYSW
VSWPRO:	$NUMGT	(VRYSW,BASE10,<frequency to show progress>)

VERALL==VRYSW
VERSEC==VRYSW

SUBTTL	COMMAND "SUBROUTINES"

; RFADO - PARSE AN RFA FIELD
;
RFADO:	$NUMGT	(RFASLA,BASE10,bucket of RFA)
RFASLA:	$TOKEN	(RFAID,/)
RFAID:	$NUMGT	(@QRFADO,BASE10,ID of RFA)

; VALDF - PICK UP DATA TYPE DEP DATFLD VALUE
;
VALQUO:	$QUOTE	(@QVALDF,<quoted string>)
VALDEC:	$NUMBER	(@QVALDF,BASE10)
VALOCT:	$NUMBER	(@QVALDF,BASE8)
VALFLO:	$FLOAT	(@QVALDF)

END
