MODULE UTLINT (		! RMSUTL and RMS interface module
		IDENT =  '01-01'
		) =



BEGIN

GLOBAL BIND	UTILV = 1^24 + 0^18 + 20;	!EDIT DATE: 23-MAR-79

%([

FUNCTION:	THIS MODULE CONTAINS ALL ROUTINES WHICH PROCESS
		THE $UTLINT MACRO IN RMS-10/20.
		THIS MACRO IS USED BY THE UTILITY RMSUTL
		TO PROVIDE AN INTERFACE TO SOME LOW-LEVEL 
		FUNCTIONS IN RMS,  WHICH RMSUTL COULD UTILIZE.

		NOTE: THIS MACRO IS FOR THE EXCLUSIVE USE
		      OF RMSUTL.

AUTHOR:		A. UDDIN

THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

!COPYRIGHT (C) 1979, 1980 BY DIGITAL EQUIPMENT CORPORATION



**********	TABLE OF CONTENTS	**************




	ROUTINE			FUNCTION
	=======			========

	$UTLINT		PROCESSOR FOR THE $UTLINT MACRO





REVISION HISTORY:

EDIT		DATE		PURPOSE
====		====		=======


*************************************************
*						*
*		NEW REVISION HISTORY		*
*						*
*************************************************

PRODUCT	MODULE	 SPR
 EDIT	 EDIT	 QAR		DESCRIPTION
======	======	=====		===========



	***** END OF REVISION HISTORY *****




])%

	%([ EXTERNAL DECLARATIONS ])%


REQUIRE 'RMSREQ';


EXTDECLARATIONS;

EXTERNAL
	RABUTL,				!WHERE $UTLINT ENVIR SAVED
	PATH;

!	EQUATED SYMBOLS
!

MACRO
	NEG_ARG = SIGN(.ARGLST [0,WRD] ) %;


! $UTLINT
! ====

! THIS ROUTINE PROCESSES THE $UTLINT MACRO.
!	IT IS CALLED DIRECTLY FROM THE RMS-20 VERB DISPATCHER.
!	THIS ROUTINE UPON COMPLETION WILL EXIT DIRECTLY BACK TO
!	THE RMS-20 EXIT PROCESSING ROUTINE.

! FORMAT OF $UTLINT MACRO:
!
!		$UTLINT 		<ARGBLK-ADDRESS> [,<ERROR-ADDRESS>]
!
! FORMAT OF ARGBLK:
!
!	-n,,function
!	  ARG_1
!	  ARG_2
!	   .
!	   .
!	  argn
!
! where:
!	n = number of arguments(Minus sign to distinguish from _AB blocks)
!	function = U$---- (SEE RMSLIB)


! INPUT:
!	BLOCK		ADDRESS OF USER ARG BLOCK
!	ERRORRETURN	ADDRESS OF USER ERROR PROCESSING ROUTINE

! OUTPUT:
!	<NO STATUS CODE RETURNED>
!
!

%([	******** FLOW OF $UTLINT ROUTINE ********	


	****************************************


])%

GLOBAL ROUTINE %NAME('$UTLINT') ( BLOCK, ERRORRETURN ):NOVALUE =
	BEGIN
	ARGUMENT (BLOCK,BASEADD);			! ARG IS USER FAB
	ARGUMENT (ERRORRETURN,BASEADD);			! ADDRESS OF USER ERROR ROUTINE

	LOCAL
		ARGLST,
		RET_VALUE,
		TEMP,
		FUNC;

	MAP	ARGLST:	POINTER;

	RMSENTRY ($UTLINT);

	


	%([	check for valid arg.list	])%

	ARGLST = .BLOCK;			!GET ADDR OF ARG. LIST
	IF NEG_ARG ISNT TRUE
	THEN
		BEGIN
		ARGLST[0,WRD] = 0;		!SET FALSE
		USRSTS = ER$IAL;		!INVALID ARGUMENT LIST
		USEXITERR;
		END;


	TEMP = ABS(.ARGLST[NO_OF_ARGS]);	!MAKE  IT POSITIVE
	FUNC = .ARGLST[RMS_FUNC];		!WHICH RMS FUNC 
	IF .FUNC GEQ U$ENVNEED
	THEN BEGIN				!INSURE ENVIR CURR
		RAB = .RABUTL;			!RESTORE RAB
		RST = .RAB[RABISI];			!SET RST
		FST = .RST[RSTFST];		!AND FST
	END;

		ARGLST[0,WRD] = 0;		!PRESUM FALSE CAUSE RMS CAN FAIL
						! WITHOUT RETURNING TO $UTLINT
	CASE .FUNC FROM 0 TO U$$MAX OF SET

[U$SETENVIR]:	BEGIN				!SETENVIR
		RET_VALUE =	TRUE;
		RABUTL = .ARGLST[ARG_1];	!SET WHERE RST/FST GOTTEN FROM
		END;

[U$CKEYKU]:	BEGIN			!COMP KEY STRING WITH KEY IN REC
		RET_VALUE =
		  $CALL (CKEYKU,
			.ARGLST[ARG_1],		!KEY STRING VIA RDP PTR
			.ARGLST[ARG_2]);	!RECORD PTR
		END;

[U$CKEYKK]:	BEGIN			!COMP KEY STRING WITH KEY STRING
		RET_VALUE =
		  $CALL (CKEYKK,
			.ARGLST[ARG_1],		!KEY STRING VIA RDP PTR
			.ARGLST[ARG_2]);	!KEY STRING PTR
		END;

[U$CHKDUP]:	RET_VALUE = $CALL (CHKDUP,	!IS UDR ALR IN SIDR?
			.ARGLST[ARG_1],		!RECDESC FOR 1ST SIDR
						!RECPTR, KEY STRING, UDR RFA, FLGRETEX INPUT
						!RECPTR, SIDRELEMENT OUTPUT IF FALSE
						!TRUE, SAYS NO DUPS
			.ARGLST[ARG_2]);	!BKT DESC OF 1ST SIDR

[U$FBYRRV]:	BEGIN				!FND DATAREC (MAY START WITH PTR TO RRV)
		RET_VALUE =
		  $CALL (FBYRRV,
			.ARGLST[ARG_1],		!RECDESC FOR TARGET (RDRFA SET)
			.ARGLST[ARG_2]);	!DESC OF BKT FOUND
		IF .RET_VALUE EQL FALSE
		THEN IF .USRSTS EQL SU$SUC THEN USRSTS=ER$RFA;
		END;

[U$FBYRFA]:	BEGIN				!FND REC USING RFA
		RET_VALUE =
		  $CALL (FBYRFA,
			.ARGLST[ARG_1],		!RECDESC FOR TARGET (RDRFA SET)
			.ARGLST[ARG_2],		!DESC OF BKT FOUND
			FALSE);			!NEVER LOCK
		IF .RET_VALUE EQL FALSE
		THEN IF .USRSTS EQL SU$SUC THEN USRSTS=ER$RFA;
		END;

[U$FNDDATA]:	RET_VALUE = $CALL (FNDDATA,
			.ARGLST[ARG_1],		!RD WITH KEY STRING DATA
			.ARGLST[ARG_2]);	!BD RETURNED

[U$FOLOPATH]:	RET_VALUE = $CALL (FOLLOWPATH,
			.ARGLST[ARG_1],		!RD WITH ADDR OF SEARCK KEY,
						!AND ITS SIZE
			.ARGLST[ARG_2]);	!BD OF DATA BKT

[U$GETBKT]:	BEGIN			!GETBKT
		RET_VALUE =	$CALL	(GETBKT,
				.ARGLST[ARG_1],	!BUCKET NO.
				.ARGLST[ARG_2],	!BUCKET SIZE
				.ARGLST[ARG_3],	!LOCK FLAG
				.ARGLST[ARG_4]	!BUCKET DESCRIPTOR
					);
		END;

[U$GMEM]:	BEGIN			!GMEM
		RET_VALUE =	$CALL	(GMEM,
				.ARGLST[ARG_1]	!SIZE OF REQUEST
					);
		IF .RET_VALUE EQL FALSE THEN USRSTS=ER$DME;
		END;

[U$PMEM]:	BEGIN			!PMEM
		$CALL	(PMEM,
			.ARGLST[ARG_2],		!NO OF WORDS
			.ARGLST[ARG_1]		!ADDR OF CHUNK
			);
		RET_VALUE = TRUE;
		END;

[U$GPAGE]:	BEGIN			!GPAGE
		RET_VALUE =	$CALL	(GPAGE,
				.ARGLST[ARG_1]	!PAGE # OF FIRST PAGE
					);
		IF .RET_VALUE EQL FALSE THEN USRSTS=ER$DME;
		END;

[U$GETIDB]:	BEGIN			!GETIDB
		RET_VALUE =	$CALL	(GETIDB,
				.ARGLST[ARG_1]	! BUCKET DESC
				);
		END;

[U$GETROOT]:	BEGIN			!GETROOT
		RET_VALUE =	$CALL	(GETROOT,
				.ARGLST[ARG_1],	!RECORD DESC
				.ARGLST[ARG_2]	!BUCKET DESC
					);
		END;

[U$GTBKTPTR]:	BEGIN			!GTBKTPTR
		RET_VALUE =	$CALL	(GTBKTPTR,
				.ARGLST[ARG_1],	!RECORD DESC
				.ARGLST[ARG_2],	!CURRENT BKT DESC
				.ARGLST[ARG_3]	!NEXT BKT DESC
					);
		END;

[U$GETKDB]:	BEGIN			!GETKDB
		IF ( RET_VALUE = $CALL	(GETKDB,
				.ARGLST[ARG_1]	!KEY OF REF.
					)) ISNT FALSE
		THEN
			KDB = .RET_VALUE;	!SETUP KDB
		END;

[U$MOVEKEY]:	BEGIN			!MOVE SEGMENTED KEY TO KEYBUF
		RET_VALUE = TRUE;
		$CALL (MOVEKEY,
			.ARGLST[ARG_1],		!RECORD PTR
			.ARGLST[ARG_2]);	!KEYBUF PTR
		END;

[U$PATH]:	RET_VALUE = PATH;

[U$PPAGE]:	BEGIN			!PPAGE
		$CALL	(PPAGE,
			.ARGLST[ARG_1],		!PAGE # OF FIRST PAGE
			.ARGLST[ARG_2],		!# OF PAGES
			.ARGLST[ARG_3]		!KILL FLAG
			);
		RET_VALUE = TRUE;
		END;

[U$PUTBKT]:	BEGIN
		$CALL	(PUTBKT,
			.ARGLST[ARG_1],		!UPDATE FLAG
			.ARGLST[ARG_2]		!BUCKET DESCRIPTOR
			);
		RET_VALUE = TRUE;
		END;

[U$PUTSIDR]:	RET_VALUE = $CALL (PUTSIDR,	!CREATE SIDR ENTRY FOR SPEC KEY
			.ARGLST[ARG_1]);	!RD HAS RRV OF UDR & KEY STRING

[INRANGE,OUTRANGE]:
		BEGIN
		USRSTS = ER$IOP ;	!Invalid Operation attempted
		USEXITERR;
		END;
	TES;

	!A SUCCESSFUL ROUTINE RETURNS SU$SUC IN THE STATUS FIELD
	!AN UNSUCCESSFULL ROUTINE RETURNS AN ER$ VALUE THERE
	!A SUCCESSFUL RETURN MAY RETURN TRUE OR FALSE (EG. CKEYKK)
	!
	!SETSUCCESS IS NOT REFERENCED BECAUSE IT SEEMS INAPPROPRIATE TO
	!TREAT A CALL TO $UTLINT AS AN RMS OPERATION IN THE USUAL SENSE.

	ARGLST[0,WRD] =  .RET_VALUE;
	IF .USRSTS NEQ SU$SUC
	THEN	USEXITERR
	ELSE	USEREXIT;
END;					!END $UTLINT
END
ELUDOM
