
MODULE FLUSH =


BEGIN

GLOBAL BIND	FLUSV = 1^24 + 0^18 + 1;	!EDIT DATE: MAY 1, 1976

%([

FUNCTION:	THIS MODULE CONTAINS ALL ROUTINES WHICH PROCESS
		THE $FLUSH MACRO IN RMS-20.
AUTHOR:	S. BLOUNT

THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

!COPYRIGHT (C) 1977, 1979 BY DIGITAL EQUIPMENT CORPORATION



**********	TABLE OF CONTENTS	**************




	ROUTINE			FUNCTION
	=======			========

	$FLUSH			PROCESSOR FOR $FLUSH MACRO




REVISION HISTORY:

****************** Start RMS-10 V1.1 *********************
********************* TOPS-10 ONLY ***********************

PRODUCT	MODULE	 SPR
 EDIT	 EDIT	 QAR		DESCRIPTION
======	======	=====		===========

 100	  1	Dev		Make declarations for CRASH, WRITEBUFFER,
				and RSETUP be EXTERNAL ROUTINE so RMS will
				compile under BLISS V4 (RMT, 10/22/85).


	***** END OF REVISION HISTORY *****




])%



	%([ FORWARD DECLARATIONS ])%


	%([ EXTERNAL DECLARATIONS ])%

	EXTERNAL ROUTINE
	    RSETUP,		! NORMAL RECORD OPERATION SETUP
	    CRASH,		! HOPEFULLY NOT
	    WRITEBUFFER;	! WRITE THE DATA BUFFER

	%([ ERROR MESSAGES REFERENCED IN THIS MODULE ])%


REQUIRE 'RMSREQ';
EXTDECLARATIONS;


! $FLUSH
! ======
!
! PROCESSOR FOR $FLUSH MACRO.
!	THIS ROUTINE FLUSHES ALL CURRENT BUFFERS FOR A FILE.
!	THIS OPERATION IS VALID FOR ALL FILE ORGANIZATIONS,
!	BUT HAS IMPORTANT USE PRIMARILY FOR SEQUENTIAL FILES WITH
!	ASCII OR LSA RECORD FORMATS, OR FOR FILES ON SEQUENTIAL
!	DEVICES. THIS OPERATION CAN BE DONE TO AN INDEXED FILE,
!	BUT UNLESS WRITE-BEHIND IS BEING USED, THERE IS NO
!	ADVANTAGE IN DOING SO.
!
!	FORMAT OF THE MACRO:
!
!		$FLUSH		<RAB-ADDRESS>, [<,ERROR>]
!
! RAB FIELDS WHICH ARE USED AS INPUT TO THIS MACRO:
!
!	ISI		INTERNAL STREAM IDENTIFIER
!
!
! RAB FIELDS WHICH ARE SET AS OUTPUT FROM THIS MACRO:
!
!	STS		STATUS OF OPERATION
!

! INPUT:
!	USER RECORD ACCESS BLOCK (RAB)
!	USER ERROR RETURN ADDRESS
!
! OUTPUT:
!	<NONE>
!

GLOBAL ROUTINE %NAME('$FLUSH') ( BLOCK, ERRORRETURN ) =
BEGIN

	ARGUMENT	(BLOCK,BASEADD);	! ADDRESS OF RAB
	ARGUMENT	(ERRORRETURN,BASEADD);	! ADDRESS OF ERROR ROUTINE

	RMSENTRY ( $FLUSH );

	%([ FETCH THE ADDRESS OF THE USER'S RAB AND HIS
	   ERROR-PROCESSING ROUTINE, IF ANY ])%

	RAB = .BLOCK;				! FETCH RAB ADDRESS
	ERRADR = .ERRORRETURN;			! AND USER ERROR ADDRESS
	%([ SET UP ALL SYSTEM-WIDE POINTERS, ETC. AND
	   ALLOW HIM TO PERFORM THIS OPERATION NO MATTER
	   WHAT HIS FAB VALUE WAS WHEN HE OPENED THE FILE ])%

	CALLRSETUP ( PCI ( TRUE ) );		! SET UP ALL STUFF

	$CALL	(FLUBUF);				!CLEAR ALL BUFFERS

	%([ EXIT TO USER ])%

	USEREXIT

END; %(OF $FLUSH )%

! FLUBUF
! ======

! INSURES THAT ALL UPDATED BUFFERS ARE WRITTEN TO DISK

! INPUT: <NONE>

! OUTPUT: <NONE>

GLOBAL ROUTINE FLUBUF:NOVALUE =
BEGIN

REGISTER
    BDPTR:	POINTER;

	TRACE	('FLUBUF');

	%([ NOTE THAT THIS ROUTINE PERFORMS ITS FUNCTION
	   PRIMARILY FOR STREAM OR LSA RECORDS, OR FOR SEQUENTIAL
	   DEVICES.  ALSO, THE FILE MUST BE CURRENTLY
	   IN OUPUT MODE FOR THIS MACRO TO HAVE ANY EFFECT ])%

	IF	( ( MTA )			! FOR MAGTAPE
		OR
		( ASCIIFILE ) )			! OR ASCII FILES
		AND
		( NOT INPUTMODE )		! WE MUST BE WRITING THE FILE
	THEN	IF ENDOFFILE			! FLUSH BUFFERS?
		THEN BEGIN			! YES
			$CALL (WRITEBUFFER);	! OUTPUT CURR BUFF
			$CALL (PAGOUT,
				.FST [FSTJFN],
				.CURRENTFILEPAGE,
				-1,		! JUST VERIFY TO DISK
				ASCIIBKTSIZE);
		END; %(WRITING ASCIIFILE)%


	%([ FOR DISK FILES, WE CAN CYCLE THRU THE RST BUFFERS
	   AND UPDATE ALL THE BUFFERS IN THIS STREAM. ])%

	IF DASD
	THEN
		BEGIN
		BDPTR = BFDOFFSET;			! SET UP PTR TO FIRST BUFF DESC

		%([ LOOP OVER ALL BUFFERS AND UPDATE THEM TO THE DISK ])%

		INCR J FROM 1 TO .RST [ RSTBFDCOUNT ]
		DO	%(THIS LOOP ONCE FOR EACH BUFFER DESCRIPTOR)%
			BEGIN

			%([ IS THE BUFFER EMPTY? ])%

			IF (.BDPTR [ BFDBKTSIZ ] ISNT ZERO) AND BFDUPD(BDPTR)
			THEN %(IT ISNT'T EMPTY & IT HAS UPDATED DATA IN IT)%
				$CALL	(PAGOUT,
						%(JFN)%		.FST [ FSTJFN ],
						%(PAGE)%	.BDPTR [ BFDFPAGE ],
						%(MEM)%		.BDPTR [BFDBPAGE] ,
						%(COUNT)%	.BDPTR [ BFDBKTSIZ ] );
			CLEARBFDUPD(BDPTR);

			%([ BUMP THE BUFFER DESCRIPTOR POINTER ])%

			INC ( BDPTR, 1 )
			END
		END;
	RETURN;
END;	%(FLUBUF)%

END
ELUDOM
