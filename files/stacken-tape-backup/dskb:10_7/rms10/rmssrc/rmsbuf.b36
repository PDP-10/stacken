

MODULE BUFFER =

BEGIN

GLOBAL BIND	BUFRV = 1^24 + 0^18 + 5;	!EDIT DATE: 5-APR-78

%([
FUNCTION:	THIS MODULE CONTAINS ALL ROUTINES WHICH PROCESS
		FILE BUFFERS WITH RMS-20.

AUTHOR:	J. KRUPANSKY /EGM

THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

!COPYRIGHT (C) 1977, 1979 BY DIGITAL EQUIPMENT CORPORATION



**********	TABLE OF CONTENTS	**************




	ROUTINE			FUNCTION
	=======			========

	GETBUF			ALLOCATE A FILE BUFFER

	PUTBUF			DE-ALLOCATE A FILE BUFFER




REVISION HISTORY:

EDIT	WHO	DATE		PURPOSE
====	===	====		=======

1	JK	26-JUL-76	MUST SPECIFY 'KILLFLAG' ON CALL TO 'PPAGE'.
2	JK	27-JUL-76	CHECKEXACTCOUNT OF ROUTINE ARGUMENTS.
3	JK	5-AUG-76	'BSIZE' IN 'PUTBUF' IS A VALUE PARAMATER.
4	SB	25-OCT-76	ADD BUG CHECK IF COUNT IS 0 IN PUTBUF

*************************************************
*						*
*		NEW REVISION HISTORY		*
*						*
*************************************************

PRODUCT	MODULE	 SPR
 EDIT	 EDIT	 QAR		DESCRIPTION
======	======	=====		===========

	***** END OF REVISION HISTORY *****

])%



	%([ FORWARD DECLARATIONS ])%


	%([ EXTERNAL DECLARATIONS ])%

	EXTERNAL ROUTINE
	    CRASH,		! HANDLE ERRORS
!	    DUMP,		! PRINT OUT A VARIABLE
	    GPAGE,		! GET A PAGE FROM FSM
	    PPAGE;		! RETURN A PAGE TO THE FSM

	%([ ERROR MESSAGES REFERENCED IN THIS MODULE ])%


	EXTERNAL
	    MSGINPUT,	! INVALID ROUTINE ARGUMENTS
	    MSGFLAGS,	! BAD FLAGS
	    MSGCANTGETHERE,	! RMS-20 HAS GONE WILD
	    MSGBNA;		! BUFFER NOT ALLOCATED



REQUIRE 'RMSREQ';
EXTDECLARATIONS;




COMMENT;
! GETBUF
! ======

!
!  THIS ROUTINE ALLOCATES A BUFFER FOR A SPECIFIED NO. OF FILE PAGES BEGINNING
! WITH THE SPECIFIED FILE PAGE. THERE ARE FOUR CASES WHICH MAY OCCUR
! (LISTED HERE IN DECREASING PRIORITY):
!
!	1) SPECIFIED FILE PAGE IS STILL MAPPED INTO OUR PROCESS,
!	2) A BUFFER IS AVAILABLE ( USE ONE WITH SMALLEST LRU COUNT,
!	   WHICH IS THE LEAST RECENTLY USED. EXCEPT THAT
!	   EMPTY BUFFERS WILL BE USED BEFORE THE FILE PAGES IN
!	   UNUSED BUFFERS ARE FLUSHED),
!	3) A BUFFER MUST BE ALLOCATED FROM FREE STORAGE
!	4) NO BUFFER IS AVAILABLE (GIVE FAILURE RETURN).
!
! INPUT:
!	FPAGE = FILE PAGE NO.
!	BSIZE = BUCKET/BUFFER SIZE IN PAGES
!	CONTIGFLAG = BUFFERS SHOULD BE ALLOCATED CONTIGUOUSLY (SEE NOTE)
!	BPAGE = BUFFER PAGE NO. (RETURNED TO CALLER)
!	INCORE = IF PAGE IS IN CORE (FALSE= CALLER MUST MAP IT) (RETURNED TO CALLER)
!	BFDADR = ADR OF BUFFER DESCRIPTOR (0= CAME FROM FSM) (RETURNED TO CALLER)
! OUTPUT:
!	FALSE = COULDN'T GET BUFFER (NO FREE STORAGE)
!	TRUE  = GOT BUFFER (BPAGE, INCORE, AND BFDADR WILL BE SET)
!
! NOTES:
!	1.	IF THE PAGE WAS NOT FOUND IN ANY OF THE CORE BUFFERS, THEN
!		INCORE WILL BE FALSE AND IT IS THEN THE CALLER'S RESPONSIBILITY TO
!		MAP THE FILE PAGE INTO THE BUFFER RETURNED BY THIS ROUTINE.
!
!	2.	IF THE "CONTIGFLAG" IS NON-ZERO (NOT TRUE, JUST MERELY
!		NON-ZERO), THEN IT MEANS THAT IF WE DON'T FIND THE
!		PAGE IN OUR BUFFERS, WE SHOULD COMPLETELY FILL UP
!		OUR BUFFER POOL BY MAPPING ALL PAGES THAT WILL FIT.
!		CURRENTLY, THIS FACILITY IS USED ONLY FOR SEQUENTIAL/
!		RELATIVE FILES WHICH USE READ-AHEAD.
!
!
! ROUTINES CALLED:
!	GPAGE


GLOBAL ROUTINE GETBUF ( FPAGE, BSIZE, CONTIGFLAG, BPAGE, INCORE, BFDADR ) =
BEGIN

	ARGUMENT (FPAGE,VALUE);		! FILE PAGE NO.
	ARGUMENT (BSIZE,VALUE);		! BUCKET/BUFFER SIZE (IN PAGES)
	ARGUMENT (CONTIGFLAG,VALUE);	! CONTIGUOUS ALLOCATION FLAG
	ARGUMENT (BPAGE,REFERENCE);	! BUFFER PAGE NO.
	ARGUMENT (INCORE,REFERENCE);	! TRUE IF FILE PAGE IS IN CORE
	ARGUMENT (BFDADR,REFERENCE);	! ADR OF BUFFER DESCRIPTOR

MAP
    BFDADR:	POINTER;

EXTERNAL
    BFOUND,			! # OF BUFFERS FOUND IN CHAIN
    BFAULT,			! # OF BUFFERS NOT FOUND IN CHAIN
    BFCORE;			! # OF BUFFERS ALLOCATED FROM FREE CORE

LOCAL
    USECOUNT,			! # OF USERS OF THIS BUFFER
    BFDPTR:	POINTER,
    LRUPTR:	POINTER,	!PTR TO LRU WORD FOR BFDPTR
    LRUMIN;

MACRO	SETLRU(A)= A[0,WRD] = .BUFACC %;	!SET BUF'S LRU VAL (NO OVFL CHK CAUSE FULL WD)


	CHECKEXACTCOUNT;			! MUST HAVE EXACT NO. ARGS

	TRACE ( 'GETBUF' );

	%([ INCREMENT COUNTER OF CALLS TO 'GETBUF'  ])%
	%([ (THIS IS USED TO FILL IN THE LRU COUNT  ])%
	%([  FOR A BUFFER).                         ])%

	BUFACC = .BUFACC + 1;				! INCR COUNT OF BUFFER ACCESSES

	%([ CHECK OUR INPUT ])%

	%IF DBUG %THEN
	IF .CONTIGFLAG AND IDXFILE THEN RMSBUG ( MSGFLAGS );
	%FI

	%([ SEARCH FOR A BUFFER TO RETURN TO CALLER ])%

	BFDADR = ZERO;					! RESET PTR TO AVAILABLE BUFFER
	LRUMIN = PLUSINFINITY;				! PRESET SMALLEST LRU

	INCR J	FROM	BFDOFFSET
		TO	BFDOFFSET + .RST [ RSTBFDCOUNT ] - 1
		BY	1
	DO
		BEGIN
		BFDPTR = .J;			! SETUP PTR TO THIS BUFFER DESCRIPTOR
		LRUPTR = .J + .RST[RSTBFDCOUNT];	!PT AT ITS LRU WORD

		%([ 1. CHECK IF THE SPECIFIED FILE PAGE IS IN THIS BUFFER ])%


		IF .BFDPTR [ BFDFPAGE ] IS .FPAGE
			AND
		   .BFDPTR [ BFDBKTSIZ ] ISNT ZERO
		THEN
			BEGIN %( RETURN FILE PAGE ALREADY IN CORE )%
			SETLRU( LRUPTR );		! SET LRU COUNT
			BFDPTR [ BFDUSECOUNT ] = .BFDPTR [ BFDUSECOUNT ] + 1; ! INCR USE COUNT
			BPAGE = .BFDPTR [ BFDBPAGE ];	! RETURN BUFFER PAGE NO.
			INCORE = TRUE;			! RETURN "FILE PAGE IS IN CORE"
			BFDADR = .BFDPTR;		! RETURN PTR TO BUFFER DESCRIPTOR
			INC ( BFOUND, 1 );		! BUMP COUNT OF FOUND BUFFS
			GOODRETURN			! AND GIVE GOOD RETURN TO CALLER
		END;

	        %([ 2. CHECK IF THIS BUFFER IS EMPTY OR AVAILABLE WITH HAS SMALLER LRU COUNT ])%

		IF .BFDPTR[BFDBKTSIZ] IS ZERO
				OR
		( .BFDPTR [BFDUSECOUNT] IS ZERO AND .LRUPTR[0,WRD] LSS .LRUMIN )
		THEN
			BEGIN %( SAVE PTR TO LRU BUFFER )%
	 		BFDADR = .BFDPTR;		!TENTA SET LRU BUFFER
			IF .BFDPTR [BFDBKTSIZ] IS ZERO THEN EXITLOOP;
							!USE 1ST EMPTY BUFF
			LRUMIN = .LRUPTR[0,WRD]		!RESET LOWEST LRU SEEN
		END   %( OF SAVE TO LRU BUFFER )%

	END;  %( OF SEARCH ITERATION )%


	%([ IF CONTIGUOUS ALLOCATION IS NEEDED, ASSUME WE FOUND THE FIRST BUFFER ])%

	IF .CONTIGFLAG ISNT FALSE THEN BFDADR = BFDOFFSET;

	%([ CHECK IF WE FOUND A BUFFER TO USE (EMPTY OR LRU) ])%

	IF ( .BFDADR ISNT ZERO )
	THEN
		BEGIN %( RETURN THIS BUFFER TO CALLER )%
		USECOUNT = 1;				! THIS BUFFER IS BUSY
		BFDPTR = .BFDADR;			! SET UP MOVING POINTER
		BPAGE = .BFDPTR [ BFDBPAGE ];		! RETURN BUFFER PAGE NO. TO CALLER
		INCORE = FALSE;				! RETURN "PAGE MUST BE MAPPED FROM FILE" TO CALLER
		INC ( BFAULT, 1 );			! BUMP # OF FAULTS

		%([ DO THIS LOOP ONCE FOR EACH BUFFER IF CONTIGUOUS ALLOCATION,
		   ONLY ONCE OTHERWISE ])%

		INCR J FROM 1 TO .RST [ RSTBFDCOUNT ]
		DO
			BEGIN
			LRUPTR = .BFDPTR + .RST[RSTBFDCOUNT];
							!PT AT CHOSEN BUF'S LRU
			IF BFDUPD(BFDPTR)		!DO OLD CONTENTS NEED PUTTING OUT?
			THEN $CALL(PAGOUT,
				.FST[FSTJFN],
				.BFDPTR[BFDFPAGE],
				.BFDPTR[BFDBPAGE],
				.BFDPTR[BFDBKTSIZ]);

			CLEARBFDUPD(BFDPTR);			!RESET FLAG
			SETLRU ( LRUPTR );			! SET LRU COUNT FOR BUFFER
			BFDPTR [ BFDUSECOUNT ] = .USECOUNT;	! SET INITIAL USE COUNT FOR BUFFER
			BFDPTR [ BFDFPAGE ] = .FPAGE;		! SET FILE PAGE NO. THAT IS IN BUFFER
			BFDPTR [BFDBKTSIZ] = .BSIZE;		!FOR DEMAND FLUSH IN LATER GETBUF
			%IF DBUG %THEN
			BEGINDEBUG ( DBIO );
			PRINTVALUE ('	PAGE FAULT FOR PAGE:  ',FPAGE );
			ENDDEBUG;
			%FI

			%([ WE CAN EXIT IN THE NORMAL CASE ])%

			IF .CONTIGFLAG IS FALSE THEN GOODRETURN;
			INC ( BFDPTR, 1 );		! BUMP POINTER
			INC ( LRUPTR, 1 );		! BUMP POINTER
			FPAGE = .FPAGE + .BSIZE;	! AND PAGE NUMBER
			USECOUNT = ZERO			! OTHER BUFFERS ARE FREE
			END;	%(OF INCR J)%

		%([ WE HAVE SET UP ALL BUFFER DESCRIPTORS FOR CONTIGUOUS ALOC. ])%

		GOODRETURN
		END;   %( OF RETURN THIS BUFFER TO CALLER )%


	%([ DIDN'T FIND BUFFER. ASK FREE STORAGE MANAGER FOR BUFFER ])%

	IF ( BPAGE = CALLGPAGE ( %( PAGE COUNT )%   VCI ( BSIZE ) ) ) ISNT FALSE
	THEN
		BEGIN %( GOT BUFFER FROM FSM )%
		INCORE = FALSE;			! RETURN "PAGE MUST BE MAPPED" TO CALLER
		INC ( BFCORE, 1 );		! BUMP COUNT OF FREE CORE BUFFS
		GOODRETURN			! AND GIVE "GOOD" RETURN TO CALLER
		END
	ELSE RETURNSTATUS ( ER$DME )		! ELSE GIVE "CAN'T GET BUFFER" RETURN TO CALLER

END; %( OF GETBUF)%

COMMENT;


! PUTBUF
! ======
!
!  THIS ROUTINE DEALLOCATES A BUFFER. IF THE BUFFER WAS ALLOCATTED FROM
! FREE STORAGE, THEN THE FREE STORAGE MANAGER IS CALLED TO RELEASE THE
! PAGES COMPRISING THE BUFFER.  OTHERWISE, THE BUFFER IS "RETURNED" TO
! THE BUFFER POOL (NOTE THAT IF THERE IS MORE THAN ONE USER OF THE
! BUFFER THEN THE BUFFER BECOMES FREE ONLY AFTER THE LAST USER CALLS THIS
! ROUTINE).

! INPUT:
!	BSIZE = BUCKET/BUFFER SIZE IN PAGES
!	BPAGE = BUFFER PAGE NO.
!	INCORE = IF PAGE IS IN CORE ( FALSE= IT WAS PMAPPED TO FILE)
!		 "FALSE" ALSO MEANS THAT THE BUFFER IS NOW EMPTY
!	BFDADR = ADR OF BUFFER DESCRIPTOR 

! OUTPUT:
!	TRUE (ALWAYS)

! ROUTINES CALLED:
!	PPAGE

! NOTES:
!
!	1.	IF THE ADDRESS OF THE BUFFER-DESCRIPTOR (BFDADR)
!		IN THE BUCKET DESCRIPTOR IS NULL, THIS INDICATES
!		THAT THE BUFFER WAS NOT ALLOCATED FROM THE BUFFER
!		POOL IN THE RST. INSTEAD, IT WAS ALLOCATED FROM
!		THE FSM BECAUSE ALL OTHER BUFFERS WERE ALREADY IN USE
!		(THIS SITUATION SHOULD NOT HAPPEN CURRENTLY SINCE
!		A MINIMUM OF 3 BUFFERS ARE ALLOCATED WHEN A RECORD
!		STREAM IS INITIATED).

GLOBAL ROUTINE PUTBUF ( BSIZE, BPAGE, INCORE, BFDADR ) =
BEGIN
	ARGUMENT (BSIZE,VALUE);		! BUCKET/BUFFER SIZE IN PAGES
	ARGUMENT (BPAGE,VALUE);		! BUFFER PAGE NO. ( IF PPAGE MUST BE CALLED )
	ARGUMENT (INCORE,VALUE);	! INCORE FLAG (FALSE MEANS BUFFER IS NOW EMPTY)
	ARGUMENT (BFDADR,VALUE);	! ADR OF BUFFER DESCRIPTOR

MAP
    BFDADR:	POINTER;
REGISTER
    TEMPAC;


	CHECKEXACTCOUNT;		! MUST HAVE EXACT NO. ARGS

	TRACE ( 'PUTBUF' );

	%([ IF BUFFER CAME FROM FREE STORAGE, RETURN IT TO THE FSM ])%

	IF ( .BFDADR IS ZERO )
	THEN	%(RETURN BUFFER TO FSM)%

		BEGIN
		CALLPPAGE (	%(PAGE NUM)%	VCI ( BPAGE ),
				%(COUNT)%		VCI ( BSIZE ),
				%(KILLFLAG)%	PCI ( TRUE ) );
		GOODRETURN
		END;	%(OF IF BUFFER CAME FROM THE FSM)%


	%([ DECREMENT USE COUNT FOR BUFFER ])%

	TEMPAC = .BFDADR [ BFDUSECOUNT ];
	IF .TEMPAC IS ZERO THEN RMSBUG ( MSGBNA );
	BFDADR [ BFDUSECOUNT ] = .TEMPAC - 1;		! DECR USE COUNT

	%([ IF BUFFER IS NOW EMPTY, MAKE BFD INDICATE THAT CONDITION ])%
	%([ ( IF THERE ARE NO MORE USERS OF BUFFER)                   ])%

	IF ( .INCORE IS FALSE )
		AND
!** [13] ROUTINE:PUTBUF AT LINE 5707, EGM, 3-APR-78
%([13])%	   ( .BFDADR [ BFDUSECOUNT ] IS ZERO )
	THEN	BFDADR [BFDBKTSIZ] = 0;			!INDIC NO DATA IN BUF

	GOODRETURN %( FROM PUTBUF )%			! GIVE "GOOD" RETURN TO CALLER

END;   %( OF PUTBUF )%

END
ELUDOM
