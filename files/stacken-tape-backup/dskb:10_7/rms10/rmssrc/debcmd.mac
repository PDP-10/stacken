TITLE	DEBCMD - SYNTAX TABLES FOR RMSDEB
SUBTTL S. COHEN
SEARCH RMSMAC,RMSINT
$PROLOG(DEB)
SEARCH	CMDPAR

P$COLON==0				;;INIT DEF OF IT
					;;USED TO APP COLON TO TOK NAME

; AK$TAB - DEFINES KYWD TABLE IN WHICH EACH ENTRY IS AN RMS ARG BLK FIELD
;
DEFINE AK$TAB(NEXT$,TYP$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<RF.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	$KEY(NEXT$,TYP$'TB,<KOPT$>)	;;KEY TABLE
	TB$KEY(TYP$,<FLD$>)		;;DO THE REAL WORK
>

; AO$TAB - DEFINES DISPATCH TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE AO$TAB(T$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<RF.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	$KEYDSP(T$'TB,<KOPT$>)		;;KEY TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
>

; AS$TAB - DEFINES SWITCH DISPATCH TABLE FOR RMS ARGBLK FIELDS
; DISPATCH LABEL IS LOCAL -- SO VALUE CAN BE PICKED UP
; PARSE CODE IS ADDRESS -- SO APPROP $STORE CAN BE DONE
;
DEFINE AS$TAB(T$,FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<RF.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	P$COLON==1			;;APPEND COLONS
	$SWITCH	(0,T$'TB,<KDOPT$>)	;;DISPATCH TO KYWD TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
	P$COLON==0			;;TURN OFF
>

; $FILEF - ALLOW SYMBOLS THAT INCLUDE . < > : [ ]
;
DEFINE $FILEF (NXT$,HELP$,ARGS$) <$FNAME(NXT$,<HELP$>,<$BREAK(MSKFIL),ARGS$>)>

; $MACF - ALLOW SYMBOLS THAT INCLUDE . $ OR %
;
DEFINE $MACF (NXT$,HELP$,ARGS$) <$FNAME(NXT$,<HELP$>,<$BREAK(MSKMAC),ARGS$>)>

; SO$TAB - DEFINES DISPATCH TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE SO$TAB(T$,P$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<P$'$'X$>	;;SYMBOL IN RMSINT
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	$KEYDSP(T$'TB,KOPT$)		;;KEY TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
>

SUBTTL	SPECIAL STUFF FOR CMDPAR INTERFACE

BASE10==^D10				;FOR $NUMGE MACRO

$IMPURE

CHABTO:	$NOISE	(0,TO)			;FOR NOISE AFTER ARGBLK TABLE
DEFNAM:	$NOISE	(0,NAMING IT)		;FOR NOISE AFT DEF TYPE
XABCOM:	0				;SPACE FOR PDB AFTER CMA IN XAB
PDBPAG:	BLOCK	200			;SPACE FOR PARSED DATA

$PURE


MSKFIL:
	FLDB0.				;WORD-N OF MASK
	FLDB1.&<^-<1B14!1B26!1B28!1B30>>;B14=. B26=: B28=< B30=>
	FLDB2.&<^-<1B27!1B29>>		;B27=[ B29=]
	FLDB3.
MSKMAC:
	FLDB0.				;WORD-N OF MASK
	FLDB1.&<^-<1B4!1B5!1B14>>!1B13	;B4=$ B5=% B14=. AND EXCL B13=-
	FLDB2.
	FLDB3.

CHANXT:
	SZ%BID==XA$TYP+XB$SUM+1		;NUMBER OF ARGBLK TYPES
	$INIT	(BID)
	 $SET	(DA$TYP,CHADAT)
	 $SET	(FA$TYP,CHAFAB)
	 $SET	(RA$TYP,CHARAB)
	 $SET	(XA$TYP+XB$AREA,CHAXA)
	 $SET	(XA$TYP+XB$KEY,CHAXK)
	 $SET	(XA$TYP+XB$DAT,CHAXD)
	 $SET	(XA$TYP+XB$SUM,CHAXS)
	$ENDINIT
DISNXT:
	$INIT	(BID)
	 $SET	(DA$TYP,DIDCMA)		;COMPLETE CMD COULD BE D D1 [,D2,...]
	 $SET	(FA$TYP,DISFAB)
	 $SET	(RA$TYP,DISRAB)
	 $SET	(XA$TYP+XB$AREA,DISXA)
	 $SET	(XA$TYP+XB$KEY,DISXK)
	 $SET	(XA$TYP+XB$DAT,DISXD)
	 $SET	(XA$TYP+XB$SUM,DISXS)
	$ENDINIT

SUBTTL	ACTION ROUTINES

CXCNXT:					;SETS PLACE TO GO AFTER COMMA IN XAB
	$COPY	.NEXT,XABCOM		;DO IT
	POPJ	P,

CHACAS:					;ACTION ROUTINE FOR CHANGE
	$CALL	FLDTYP			;SETUP BID TO DRIVE SETTING OF .NEXT
	JUMPF	[POPJ P,]		;TRANSIT RET FAILURE
	$COPY	.NEXT,CHANXT(T2),T1	;SET GLOBAL "NEXT PDB" FLD
	MOVEM	T1,XABCOM		;SAVE WHERE TO GO AFTER COMMA
	POPJ	P,			;TRANSIT RET TRUE
DISCAS:					;ACTION ROUTINE FOR DISPLAY
	$CALL	FLDTYP			;SETUP BID TO DRIVE SETTING OF .NEXT
	JUMPF	[POPJ P,]		;TRANSIT RET FAILURE
	$COPY	.NEXT,DISNXT(T2),T1	;SET GLOBAL "NEXT PDB" FLD
	MOVEM	T1,XABCOM		;SAVE WHERE TO GO AFTER COMMA
	POPJ	P,			;TRANSIT RET TRUE

FLDTYP:
;
; FLDTYP - ACTION ROUTINE TO DETERMINE NEXT PDB OF A FIELD
; ARGUMENTS:
;	T1 = LENGTH OF CMDRET BLK
;	T2 = ADDR OF CMDRET BLK
	MOVE	T5,CR.SAV(T2)		;GET ADDRESS OF PARSE DATA
	$CALL	SY.FIND,<TK.VAL(T5)>	;PASS THE FLD VALUE
	JUMPT	L$IFX			;A MATCH?
	  MOVEI	T2,[ASCIZ/Name not known/] ;NO, TELL CALLER
	  SETZM	TF			;FAILURE RET
	  POPJ	P,
	$ENDIF
	$FETCH	T2,BID,(T1)		;GET TYPE OF FLD
	CAIE	T2,XA$TYP		;XAB?
	$SKIP				;YES
	  $FETCH T3,COD,(T1)		;GET TYPE OF XAB
	  ADD	T2,T3			;SEP PDB FOR EACH TYPE OF XAB
	$ENDIF
	SETOM	TF			;SUCC RET
	POPJ	P,

SUBTTL	TOP-LEVEL SYNTAX OF RMSDEB

; THE MAIN PARSER DESCRIPTOR BLOCK, THIS IS WHAT IS PASSED DIRECTLY TO COMND
;
DB.CMD::
	CMDINI				;PT TO CMD TABLE
	[ASCIZ/RMSDEB>/]		;PROMPT
	PDBPAG				;PAGE FOR PARSED DATA
	0				;USE TTY

CMDINI:	$INITC(CMDS)			;THE INIT BLK

CMDS:	CM$TAB	(<$CLOSE,$CONNECT,$CREATE,$DELETE,$DISCONNECT,$DISPLAY,$ERASE,$FIND,$FLUSH,$GET,$MESSAGE,$NOMESSAGE,$OPEN,$PUT,$TRUNCATE,$UPDATE,ASSIGN,CHANGE,DDT,DEFINE,DISPLAY,EXIT,HELP,INFORMATION,TAKE,UNDEFINE>,$BREAK(MSKMAC))

CFM:	$CRLF				;CRLF IS COMMON TERMINATOR OF COMMANDS

; THESE COMMANDS ARE QUITE SIMPLE: CMD [FAB-NAME ! RAB-NAME]
;
DEFINE $LABEL(V$)<IRP V$,<.'V$:>>	;;VERBS HAVE SIMPLE SYNTAX, SO GROUP THEM

$LABEL	<$CONNECT,$DELETE,$DISCONNECT,$FIND,$FLUSH,$GET,$PUT,$TRUNCATE,$UPDATE>
	$NOISE	(RABNAM,<USING RAB>)
RABNAM:	$MACF	(CFM,<RAB name>)

$LABEL	<$CLOSE,$CREATE,$DISPLAY,$ERASE,$OPEN>
	$NOISE	(FABNAM,<USING FAB>)
FABNAM:	$MACF	(CFM,<FAB name>)

$LABEL	<$MESSAGE,$NOMESSAGE,DDT,EXIT,HELP>
	$NOISE	(CFM,PLEASE)

SUBTTL	SYNTAX FOR ASSIGN CMD

; ASSIGN name = addres

.ASSIG:	$NOISE	(ASSNAM,NAME)
ASSNAM:	$MACF	(ASSEQL,<block name>)
ASSEQL:	$NOISE	(ASSOLD,<TO ADDRESS>)
ASSOLD:	$NUMGE	(CFM,8,<octal number>)

SUBTTL	SYNTAX FOR CHANGE CMD

; CHANGE ARGBLK-NAME FIELD-KYWD (TO) FLD-DEP-VALUE, ...
; CHANGE [RAB-NAME] FLD-NAME (TO) FLD-DEP-VALUE, ...
;		KEY-BUFFER (TO) STRING OR NUMBER   (IDX OR REL)

.CHANG:	$NOISE	(CHATYP,VALUE IDENTIFIED BY)
CHATYP:	OP$TAB	(CHA,<<KEY,KEY-BUFFER>>,$ALTERN(CHAFNM))
CHAFNM:	$MACF	(0,<argblk or datafield name>,$ACTION(CHACAS))

CHAKEY:	$NOISE	(CHKDEC,TO)
CHKDEC:	$NUMBER	(CFM,BASE10,relative record number,<$ALTERN(CHKTEX)>)
CHKTEX:	$QUOTE	(CFM,<quoted key value>)

CHAFAB:	$NOISE	(CHAFF,AND)
CHAFF:	AO$TAB	(CHF,<BKS,BSZ,FAC,FOP,MRN,MRS,ORG,RAT,RFM,SHR,XAB>,AC$NOI(CHABTO))
CHFBKS:	$NUMGE	(CHFCOM,BASE10,<number of pages per bucket>)
CHFBSZ:	$NUMGE	(CHFCOM,BASE10,<bits in byte>)
CHFMRN:	$NUMGE	(CHFCOM,BASE10,<maximum record number>)
CHFMRS:	$NUMGE	(CHFCOM,BASE10,<maximum bytes in record>)
CHFORG:	SV$TAB	(CHFCOM,CRG,FB,<IDX,REL,SEQ>)
CHFXAB:	$MACF	(CHFCOM,<XAB name>)
;
; SYMBOLIC BITS
;
CHFSHR:
CHFFAC:	SV$TAB	(CACPLU,CAC,FB,<ALL,DEL,GET,NIL,PUT,TRN,UPD>)
CACPLU:	$TOKEN	(CHFFAC,+,<$ALTERN(CHFCOM)>)
CHFFOP:	SV$TAB	(COPPLU,COP,FB,<CIF,DFW,DRJ,NIL,SUP,WAT>)
COPPLU:	$TOKEN	(CHFFOP,+,<$ALTERN(CHFCOM)>)
CHFRAT:	SV$TAB	(CHFCOM,CRT,FB,<BLK>)
CHFRFM:	SV$TAB	(CRFPLU,CRF,FB,<FIX,LSA,STM,VAR>)
CRFPLU:	$TOKEN	(CHFRFM,+,<$ALTERN(CHFCOM)>)
CHFCOM:	$COMMA	(CHAFF,<$ALTERN(CFM)>)

CHARAB:	$NOISE	(CHRFLD,AND)
CHRFLD:	AO$TAB	(CHR,<FAB,KRF,LSN,MBF,PAD,RAC,ROP,RSZ,USZ>,<$ALTERN(CHRKEY),AC$NOI(CHABTO)>)
CHRKEY:	$KEYDSP	(CHATB,<$ALTERN(CHDFLD)>)

CHRFAB:	$MACF	(CHRCOM,name of FAB)
CHRRAC:	SV$TAB	(CRCPLU,CRAC,RB,<KEY,SEQ,RFA>)
CRCPLU:	$TOKEN	(CHRRAC,+,<$ALTERN(CHRCOM)>)
CHRROP:	SV$TAB	(CRPPLU,CROP,RB,<EOF,FDL,KGE,KGT,LOA,LOC,NIL,NRP,PAD,RAH,WBH>)
CRPPLU:	$TOKEN	(CHRROP,+,<$ALTERN(CHRCOM)>)
CHRKRF:	$NUMGE	(CHRCOM,BASE10,<key number>)
CHRLSN:	$NUMGE	(CHRCOM,BASE10,<line-sequence-number>)
CHRMBF:	$NUMGE	(CHRCOM,BASE10,<number of buffers to allocate>)
CHRPAD:	$NUMGE	(CHRCOM,8,<octal code of pad byte>)
CHRRSZ:	$NUMGE	(CHRCOM,BASE10,<bytes in record>)
CHRUSZ:	$NUMGE	(CHRCOM,BASE10,<words in record buffer>)
CHRCOM:	$COMMA	(CHARF,<$ALTERN(CFM)>)
CHARF:	$KEYDSP	(CHRTB,AC$NOI(CHABTO))

CHAXA:	$NOISE	(CHAXAF,AND)
CHAXD:	$NOISE	(CHAXDF,AND)
CHAXK:	$NOISE	(CHAXKF,AND)
CHAXS:	$NOISE	(CHAXSF,AND)
CXANXT:
CXDNXT:
CXKNXT:
CXSNXT:
	$MACF	(CHXCOM,name of next XAB)

CHAXAF:	AO$TAB	(CXA,<AID,BKZ,NXT>,AC$NOI(CHABTO))
CXAAID:	$NUMGE	(CHXCOM,BASE10,<area ID>)
CXABKZ:	$NUMGE	(CHXCOM,BASE10,<words in bucket>)

CHAXDF:
CHAXSF:
	AO$TAB	(CXD,<NXT>,AC$NOI(CHABTO))

CHAXKF:	AO$TAB	(CXK,<DAN,DFL,DTP,FLG,IAN,IFL,KNM,NXT,PS0,PS1,PS2,PS3,REF,SZ0,SZ1,SZ2,SZ3>,AC$NOI(CHABTO))
CXKDTP:	SV$TAB	(CHXCOM,CXKD,XB,<EBC,SIX,STG>)
CXKFLG:	SV$TAB	(CXKFPL,CXKF,XB,<CHG,DUP,NIL>)
CXKFPL:	$TOKEN	(CXKFLG,+,<$ALTERN(CHXCOM)>)
CXKKNM:	$FILEF	(CHXCOM,<name of key>)
CXKDAN:	$NUMGE	(CHXCOM,BASE10,<area ID of data bucket>)
CXKDFL:	$NUMGE	(CHXCOM,BASE10,<data fill word count>)
CXKIAN:	$NUMGE	(CHXCOM,BASE10,<area ID of index bucket>)
CXKIFL:	$NUMGE	(CHXCOM,BASE10,<index fill word count>)
CXKPOS:
CXKPS0:
CXKPS1:
CXKPS2:
CXKPS3:	$NUMGE	(CHXCOM,BASE10,<starting byte number of key segment>)
CXKREF:	$NUMGE	(CHXCOM,BASE10,<key number>)
CXKSIZ:
CXKSZ0:
CXKSZ1:
CXKSZ2:
CXKSZ3:	$NUMGE	(CHXCOM,BASE10,<number of bytes in key segment>)
CHXCOM:	$COMMA	(0,<$ACTION(CXCNXT),$ALTERN(CFM)>)

CHADAT:	$NOISE	(CHDDEC,TO)
CHDDEC:	$NUMBER	(CHDCOM,BASE10,,<$ALTERN(CHDTEX)>)
CHDTEX:	$QUOTE	(CHDCOM,<quoted text>)
CHDCOM:	$COMMA	(CHDFLD,<$ALTERN(CFM)>)
CHDFLD:	$MACF	(CHADAT,name of datafield)

SUBTTL	SYNTAX FOR DEFINE CMD

; DEFINE FAB new-name (FOR) file-name [/FIELD-KYWD:VALUE ...]
; DEFINE RAB new-name (FOR) FAB-name [/FIELD-KYWD:VALUE ...]
; DEFINE XAB new-name (FOR) ALLOCATION!DATE!KEY!SUMMARY [/FIELD-KYWD:VALUE ...]
; DEFINE DATAFIELD new-name [/POS /SIZE /TYPE]

.DEFIN:	$NOISE	(DEFTYP,<TYPE OF NAME>)
DEFTYP:	OP$TAB	(DEF,<DATAFIELD,FAB,RAB,XAB>,<AC$NOI(DEFNAM)>)

; DEFINE FAB
;
DEFFAB:	$MACF	(DEFFI,<FAB name>)
DEFFI:	$NOISE	(DEFFN,FOR)
DEFFN:	$FILEF	(DEFFF,<file name>)
DEFFF:	AS$TAB	(DFF,<BKS,BSZ,FAC,FOP,MRN,MRS,ORG,RAT,RFM,SHR,XAB>,<$ALTER(DEFFDF)>)
DEFFDF:	$CRLF	($HELP<confirm with CRLF (defaults are BSZ=7 FAC=GET MRS=250 ORG=SEQ RFM=VAR SHR=NIL)>)
DFFBKS:	$NUMGE	(DEFFF,BASE10,<number of pages per bucket>)
DFFBSZ:	$NUMGE	(DEFFF,BASE10,<bits in byte>)
DFFMRN:	$NUMGE	(DEFFF,BASE10,<maximum record number>)
DFFMRS:	$NUMGE	(DEFFF,BASE10,<maximum bytes in record>)
DFFORG:	SV$TAB	(DEFFF,DRG,FB,<IDX,REL,SEQ>)
DFFXAB:	$MACF	(DEFFF,<XAB name>)
;
; SYMBOLIC BITS
;
DFFSHR:
DFFFAC:	SV$TAB	(DACPLU,DAC,FB,<ALL,DEL,GET,NIL,PUT,TRN,UPD>)
DACPLU:	$TOKEN	(DFFFAC,+,<$ALTERN(DEFFF)>)
DFFFOP:	SV$TAB	(DOPPLU,DOP,FB,<CIF,DFW,DRJ,NIL,SUP,WAT>)
DOPPLU:	$TOKEN	(DFFFOP,+,<$ALTERN(DEFFF)>)
DFFRAT:	SV$TAB	(DEFFF,DRT,FB,<BLK>)
DFFRFM:	SV$TAB	(DRFPLU,DRF,FB,<FIX,LSA,STM,VAR>)
DRFPLU:	$TOKEN	(DFFRFM,+,<$ALTERN(DEFFF)>)

; DEFINE RAB
;
DEFRAB:	$MACF	(DEFRFB,<RAB name>)
DEFRFB:	$NOISE	(DEFRFN,FOR)
DEFRFN:	$FNAME	(DEFRF,<name of FAB to connect to>)
DEFRF:	AS$TAB	(DFR,<KRF,LSN,MBF,PAD,RAC,ROP,RSZ,USZ>,<$ALTERN(DEFRDF)>)
DEFRDF:	$CRLF	($HELP<confirm with CRLF (defaults are KSZ=30 RAC=SEQ ROP=WBH USZ=50)>)

DFRRAC:	SV$TAB	(DRCPLU,DRAC,RB,<KEY,SEQ,RFA>)
DRCPLU:	$TOKEN	(DFRRAC,+,<$ALTERN(DEFRF)>)
DFRROP:	SV$TAB	(DRPPLU,DROP,RB,<EOF,FDL,KGE,KGT,LOA,LOC,NIL,NRP,PAD,RAH,WBH>)
DRPPLU:	$TOKEN	(DFRROP,+,<$ALTERN(DEFRF)>)
DFRKRF:	$NUMGE	(DEFRF,BASE10,<key number>)
DFRLSN:	$NUMGE	(DEFRF,BASE10,<line-sequence-number>)
DFRMBF:	$NUMGE	(DEFRF,BASE10,<number of buffers to allocate>)
DFRPAD:	$NUMGE	(DEFRF,8,<octal code of pad byte>)
DFRRSZ:	$NUMGE	(DEFRF,BASE10,<bytes in record>)
DFRUSZ:	$NUMGE	(DEFRF,BASE10,<words in record buffer>)

; DEFINE XAB
;
DEFXAB:	$MACF	(DEFXBC,<XAB name>)
DEFXBC:	$NOISE	(DEFXCO,FOR)
DEFXCO:	SO$TAB	(DXC,XB,<AREA,DATE,KEY,SUMMARY>)
DXCDAT:
DXCSUM:
	AS$TAB	(DXS,<NXT>,$ALTERN(CFM))
DXSNXT:	$MACF	(CFM,name of next XAB)

DXCARE:	AS$TAB	(DXA,<AID,BKZ,NXT>,<$ALTERN(DXCADF)>)
DXCADF:	$CRLF	($HELP<confirm with CRLF (defaults are AID=1 BKZ=1)>)
DXAAID:	$NUMGE	(DXCARE,BASE10,<area ID>)
DXABKZ:	$NUMGE	(DXCARE,BASE10,<number of pages in bucket>)
DXANXT:	$MACF	(DXCARE,name of next XAB)

DXCKEY:	AS$TAB	(DXK,<DAN,DFL,DTP,FLG,IAN,IFL,KNM,NXT,POS,REF,SIZ>,<$ALTERN(DXCKDF)>)
DXCKDF:	$CRLF	($HELP<confirm with CRLF (defaults are DTP=STG SIZ=1)>)

DXKDTP:	SV$TAB	(DXCKEY,DXKD,XB,<EBC,SIX,STG>)
DXKFLG:	SV$TAB	(DXKFPL,DXKF,XB,<CHG,DUP,NIL>)
DXKFPL:	$TOKEN	(DXKFLG,+,<$ALTERN(DXCKEY)>)
DXKDAN:	$NUMGE	(DXCKEY,BASE10,<area ID of data bucket>)
DXKDFL:	$NUMGE	(DXCKEY,BASE10,<max # of words to load into data bucket>)
DXKIAN:	$NUMGE	(DXCKEY,BASE10,<area ID of index bucket>)
DXKIFL:	$NUMGE	(DXCKEY,BASE10,<max # of words to load into index bucket>)
DXKKNM:	$FILEF	(DXCKEY,<name of key for $DISPLAY>)
DXKNXT:	$MACF	(DXCKEY,name of next XAB)
DXKPOS:	$NUMGE	(DXKPOC,BASE10,<starting byte number of key segment>)
DXKPOC:	$TOKEN	(DXKPOS,:,<$ALTERN(DXCKEY)>)
DXKREF:	$NUMGE	(DXCKEY,BASE10,<key number>)
DXKSIZ:	$NUMGE	(DXKSIC,BASE10,<number of bytes in key segment>)
DXKSIC:	$TOKEN	(DXKSIZ,:,<$ALTERN(DXCKEY)>)

; DEFINE FIELD
;
DISW%D==DFT%DEC
DISW%O==DFT%OCT
DESW%D==0
DEFDAT:	$MACF	(DEFDAS,<field name>)
DEFDAS:	$NOISE	(DEDTYP,WITH TYPE)
DEDTYP:	OP$TAB	(DFT,<ASCII,<FILE,BYTES>,INTEGER,SIXBIT>)

DFTINT:	$NOISE	(DEDWRD,STARTING AT WORD)
DEDWRD:	$NUMGE	(DEDISW,BASE10,<number of words before field>,$ALTERN(DEDISW))
DEDISW:	SW$TAB	(DESW,<DISPLAY>,$ALTERN(CFM))
DESWDI:	KY$TAB	(CFM,DISW,<DECIMAL,OCTAL>,$ALTERN(CFM))

DFTASC:
DFTFIL:
DFTSIX:	$NOISE	(DEDLEN,WITH LENGTH)
DEDLEN:	$NUMGT	(DEDBYT,BASE10,<number of bytes in field>)
DEDBYT:	$NOISE	(DEDBNM,STARTING AT BYTE)
DEDBNM:	$NUMGE	(CFM,BASE10,<number of bytes before field>,$ALTERN(CFM))

SUBTTL	SYNTAX OF DISPLAY COMMAND

; DISPLAY argblk-name [FIELD-KYWD-list]
; DISPLAY [RAB-name] DATA!KEY-BUFFER!field-name-list

.DISPL:	$NOISE	(DISTYP,VALUE IDENTIFIED BY)
DISTYP:	KY$TAB	(CFM,DISD,<DATA,<KEY,KEY-BUFFER>>,<$ALTERN(DISFLD)>)
DISFLD:	$MACF	(0,<argblk or datafield name>,$ACTION(DISCAS))

DISFAB:	$NOISE	(DISFF,AND)
DISFF:	AK$TAB	(DISFFC,DISF,<BKS,BSZ,DEV,FAC,FNA,FOP,IFI,JFN,MRN,MRS,ORG,RAT,RFM,SHR,STS,STV,XAB>,<$ALTERN(CFM)>)
DISFFC:	$COMMA	(DISFF,<$ALTERN(CFM)>)

DISRAB:	$NOISE	(DIRFLD,AND)
DIRFLD:	AK$TAB	(DISRFC,DISR,<BKT,FAB,ISI,KBF,KRF,KSZ,LSN,MBF,PAD,RAC,RBF,RFA,ROP,RSZ,STS,STV,UBF,USZ>,<$ALTERN(DISRD)>)
DISRFC:	$COMMA	(DISRF,<$ALTERN(CFM)>)
DISRF:	$KEY	(DISRFC,DISRTB)
DISRD:	$KEY	(CFM,DISDTB,<$ALTERN(DIRCFM)>)
DIRCFM:	$CRLF	($ALTERN(DIDFLD))

DISXA:	$NOISE	(DISXAF,AND)
DISXD:	$NOISE	(DISXDF,AND)
DISXK:	$NOISE	(DISXKF,AND)
DISXS:	$NOISE	(DISXSF,AND)

DISXAF:	AK$TAB	(DISXFC,DIXA,<AID,BKZ,NXT>,$ALTERN(CFM))
DISXDF:	AK$TAB	(DISXFC,DIXD,<CDT,EDT,NXT,RDT>,$ALTERN(CFM))
DISXKF:	AK$TAB	(DISXFC,DIXK,<DAN,DFL,DTP,FLG,IAN,IFL,KNM,NXT,POS,REF,SIZ>,<$ALTERN(CFM)>)
DISXSF:	AK$TAB	(DISXFC,DIXS,<NOA,NOK,NXT>,$ALTERN(CFM))
DISXFC:	$COMMA	(0,<$ACTION(CXCNXT),$ALTERN(CFM)>)

DIDFLD:	$MACF	(DIDCMA,<name of datafield>)
DIDCMA:	$COMMA	(DIDFLD,<$ALTERN(CFM)>)

SUBTTL	SYNTAX FOR INFORMATION CMD

; INFO ALL!FABS!DATAFIELDS!RABS!XABS

.INFOR:	$NOISE	(INFTYP,ABOUT)
INFTYP:	KY$TAB	(CFM,INF,<ALL,CONTEXT,DATAFIELDS,FABS,RABS,XABS>) ;,<$ALTERN(INFNAM)>)
;INFNAM:	$MACF	(INFCMA,<name of FAB, RAB, XAB, or datafield>)
;INFCMA:	$COMMA	(INFNAM,<$ALTERN(CFM)>)

SUBTTL	SYNTAX FOR UNDEFINE CMD

; UNDEFINE name-list

.UNDEF:	$NOISE	(UNDNAM,NAME)
UNDNAM:	$MACF	(UNDCMA,<name of FAB, RAB, XAB, or datafield>)
UNDCMA:	$COMMA	(UNDNAM,<$ALTERN(CFM)>)

END
