

TITLE	RMSDSP -- ENTRY VECTOR AND DISPATCH TABLE FOR RMS
SEARCH	RMSINT,RMSMAC
$PROLOG

REPEAT 0,<

THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.

;COPYRIGHT (C) 1977, 1978 BY DIGITAL EQUIPMENT CORPORATION


NAME:		RMSDSP
AUTHOR:		S. BLOUNT
EDIT DATE:	5-MAY-77
FUNCTION:	RMS-20 JSYS DISPATCHER



REVISION HISTORY:

EDIT	DATE		WHO	PURPOSE
====	====		===	=======

1	5-MAY-77	SB	CHANGE ENTRY DISPATCH VECTOR TO SYMBOLIC FORM
2	12-DEC-79	AU	1. CHANGE REGISTER USAGE SO THAT AC 1 COULD BE
				   USED THE ARGUMENT POINTER.
				2. ADD CODE TO USE RMS'S OWN STACK.
				3. MODIFY CODE TO SUIT NEW USER INTERFACE

*************************************************
*						*
*		NEW REVISION HISTORY		*
*						*
*************************************************

PRODUCT	MODULE	 SPR
 EDIT	 EDIT	 QAR		DESCRIPTION
======	======	=====		===========
60	3	(MBROWN,SWE)	(DAW, 2-Feb-82) Preserve registers 3 and 4;
				return status in register 2 for every verb.

****************** Start RMS-10 V1.1 *********************
********************* TOPS-10 ONLY ***********************

PRODUCT	MODULE	 SPR
 EDIT	 EDIT	 QAR		DESCRIPTION
======	======	=====		===========

 101	  4	Dev		(RMT, 12/2/85) Update copyrights.

 104	  5	Dev		(RMT, 12/2/85) Use AC0 instead of AC17
				as BLT pointer so that PSI doesn't trash
				the stack pointer.

 105	  6	Dev		(RMT, 12/2/85) Don't overwrite program's
				version number in JOBDAT

	***** END OF REVISION HISTORY *****

>;;END OF REPEAT 0

;LOC 137						;FOR VERSION # ON 10
;$VERS

$PURE

SUBTTL	ENTRY POINTS TO RMS

	RELOC	400000

	ENTRY	RMS.EV

; ***	 PUSHJ ENTRY LOGIC
;
RMS$10::	REPEAT XX$MAX,<JSP T2,CALDSP>	;[60] CREATE OFFSET TO IDENTIFY CALLED ROUTINE

SMNCPY::ASCIZ\

COPYRIGHT (C) BY DIGITAL EQUIPMENT CORPORATION 1979, 1986
ALL RIGHTS RESERVED.

\ ;

CALDSP:	SUBI	T2,RMS$10+1	;[60] GET OFFSET INTO TABLE OF ADDRESSES
	MOVEM	T2,UJSYS	;[60] STORE IT AWAY
	POP	P,RETPC		;STORE RETURN ADDRESS AWAY
	JRST	SETUP		;AND CONTINUE AS IF THIS WERE A JSYS

				; WITH THE /R OPTION, WHATEVER THAT MEANS

; ***	JSYS ENTRY LOGIC

RMS.EV==:VECLNG,,VECTOR		;FOR SETTING RMS20 ENTRY VECTOR WITH LINK... /ST:RMS.EV

VECTOR:	JRST	RMS$20		;ADDRESS OF NORMAL DISPATCHER
	JRST	RMS20I		;ADDRESS OF RMS INITIALIZATION ROUTINE
	$VERS			;RMS VERSION #
	UJSYS##			;PLACE TO STORE JSYS CODE FROM MONITOR
	RETPC##			;PLACE TO STORE RETURN PC
VECLNG==.-VECTOR		;LENGTH OF ENTRY VECTOR




RMS$20::
	SKIPA			;BYPASS TURN-OFF OF INITED FLAG
RMS20I:	SETZM	INTFLG##	;SIGNAL THAT THIS IS 1ST CALL
	MOVE	T2,UJSYS##	;[60] GET JSYS CODE
	CAMLE	T2,[RM$MAX]	;[60] JSYS TOO HIGH?
	JRST	E.JSYS		;YES
	SUB	T2,[RM$MIN]	;[60] COMPUTE JSYS OFFSET
	MOVEM	T2,UJSYS##	;[60] STORE OFFSET INTO TABLE
	JRST	SETUP		;MERGE WITH PUSHJ ENTRY

SUBTTL	RMS COMMON ENTRY/EXIT CODE

;THIS ROUTINE IS THE FIRST ONE TO GET CONTROL AFTER A RMS MACRO
; HAS BEEN EXECUTED.  IT PERFORMS THE FOLLOWING FUNCTIONS:
;
;	1.  SAVE USER AC'S
;	2.  DISPATCH TO PROPER RMS ROUTINE
;
;COME HERE ON EITHER A DIRECT CALL (PUSHJ) OR AN RMS-20 JSYS.
;
SETUP:
	SKIPN	INTFLG##	;1ST CALL?
	JSP	T4,RMSINI##	;YES, INIT RMS
	MOVEM	17,USERAC##+17	;SAVE LAST AC
	MOVE	0,[1,,USERAC##+1];SET UP TO SAVE USER AC'S
	BLT	0,USERAC##+16	;SAVE THEM
	MOVE	0,USERAC##+0	;RELOAD AC 0
	JRST	RMSENT		;HOP OVER 1-TIME CODE PUT OUT BY $MAIN

$SCOPE	(TOP-LEVEL)
$MAIN	(RMSENT,TRAPERR,<IOWD PDLNG##,RMSTACK##>)
	MOVEI	T2,SU$SUC	;ASSUME A SUCCESSFUL CONCLUSION
	MOVEM	T2,USRSTS##	;STORE IT IN USER STATUS FIELD
	SETZM	USTOSF##	;START WITH NO STATUS SUGGESTION
	SETZM	OAFLAGS		;INDIC NO OPEN ACTIVITY EXTANT
	SETZM	USRSTV##	;CLEAR STATUS-VALUE
	SETZM	ERRADR##	;CLEAR ERROR ADDRESS
	PUSH	17,T1		;PUSH CONTROL BLOCK addr
	PUSH	17,[0]		;PUSH DUMMY ARG. ALL VERB MODULES EXPECT 2 ARGUMENTS ON STACK
	MOVE	T3,UJSYS##	;GET OFFSET INTO TABLE
	PUSHJ	17,@DSPTAB(T3)	;DISPATCH TO USER ROUTINE
				;DOESNT RETURN

SUBTTL	EXIT CODE

UA%BLK==1			;?AB ADDRESS ORIG PASSED IN AC1

TRAPERR:			;ABORTIVE ERROR OCCURRED
	MOVEI	T1,ER$BUG	;RET BUG VAL
	MOVEM	T1,USRSTV##	; IN 2NDARY STATUS FIELD
	MOVE	T2,USRSTS##	;IS THERE ANOTHER CODE ALREADY?
	CAIN	T2,SU$SUC	;JUMP IF YES
	MOVEM	T1,USRSTS##	;NO, SET AS PRIMARY CODE TOO
	JRST	USRFOK		;SKIP OABORT CHK
E.JSYS:
	$CALLB	TX$TOUT##,<RM$IJC##,UJSYS##,RETPC##>
				;INVALID JSYS CODE x AT LOC y
	MOVEI	T2,ER$BUG	;HALT USER WITH BAD JSYS CODE
	MOVEM	T2,USRSTS##	;JUST GIVE A STATUS CODE
	SETZM	USRSTV##	;NO SUBSID CODE
	JRST	USRJAB		;ON RETURN

USRERR::			;COME HERE ON BAD RETURN FROM RMS
	JFCL			;NO-OP, HERE ONLY TO PROVIDE PLACE TO SET BRK-PT
USRRET::			;COME HERE ON GOOD RETURN FROM ALL RMS MACRO'S
	SKIPN	OAFLAGS##	;OPEN LEFT HANGING?
	$SKIP			;YES
	  $CALLB OABORT,<[0]>	;TELL OABORT USRSTS ALREADY SET, SO RET IN LINE
	$ENDIF
USRFOK:				;FILE ENVIR GUARAN OK BY HERE
	MOVE	0,[USERAC##+1,,1]; SET UP BLT
	BLT	0,17		;RESTORE USER AC'S (BUT AM ALLOWED TO CLOB 2-4)
	MOVE 	0,USERAC##+0	;RESTORE AC 0 
USRJAB:				;BAD JSYS CODE
	MOVE	T2,USRSTV##	;[4] GET STATUS VALUE
	$STORE	T2,STV,(UA%BLK)	;[4] STORE IT IN CONTROL BLOCK
	HRRZ	T2,USRSTS##	;GET THE USER'S ERROR CODE
	$STORE	T2,STS,(UA%BLK)	;STORE IT IN CONTROL BLOCK
	CAIGE	T2,.ERBAS	;IS IT AN ERROR CODE(.GEQ. 300000?)
	JRST	@RETPC##	;NO, EXIT THRU RETURN PC
	DMOVEM	T3,USERAC+T3	;[60] Make sure ACs don't get smashed.
	MOVE	T4,RETPC	;GET ADDRESS TO RETURN TO
	MOVE	T3,(T4)		;GET INSTRUCTION THERE
	HLLZ	T4,T3		;[60] CHECK ONLY OP-CODE
	CAMN	T4,[JUMP 16,]	;[60] IS IT AN ERJMP?
	JRST	DOJMP		;YES, "GOTO" ERROR ADDRESS
	CAME	T4,[JUMP 17,]	;[60] IS IT ERCAL?
	 JRST	RETILN		;[60] No, illegal call (Didn't use RMS macro).
				;[60] So just return in-line.
	MOVE	T4,RETPC	;[60] Get return PC
	ADDI	T4,1		;SIMULATE PUSHJ AT LOCATION OF ERCAL
	PUSH	P,T4		;...BY PUSHING @RETPC+1 ON STACK
DOJMP:	HRRZM	T3,USERAC	;[60] Address to return to
	DMOVE	T3,USERAC+T3	;[60] Restore ACS 3 and 4
	JRST	@USERAC		;[60] Transfer to user routine.
RETILN:	DMOVE	T3,USERAC+T3	;[60] Restore ACs
	JRST	@RETPC		;[60] Return.
$ENDMAIN
$ENDSCOPE(TOP-LEVEL)


SUBTTL	RMS DISPATCH TABLE

DEFINE	RMSVRB(NAME)<$'NAME##>	;;FOR PUSHJ INDIRECT TO ACTUAL PROCESSING IN RMS

DSPTAB:
	RMSVRB (OPEN)
	RMSVRB (CLOSE)
	RMSVRB (GET)
	RMSVRB (PUT)
	RMSVRB (UPDATE)
	RMSVRB (DELETE)
	RMSVRB (FIND)
	RMSVRB (TRUNCATE)
	RMSVRB (CONNECT)
	RMSVRB (DISCONNECT)
	RMSVRB (CREATE)
	RMSVRB (DEBUG)
	RMSVRB (RELEASE)
	RMSVRB (FLUSH)
	RMSVRB (MESSAGE)
	RMSVRB (NOMESSAGE)
	RMSVRB (DISPLAY)
	RMSVRB (ERASE)
	RMSVRB (FREE)
	RMSVRB	(UTLINT)

END
