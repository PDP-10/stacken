.TITLE	DC76 - DMCC	15 JUL 76

;***COPYRIGHT 1973,1974,1975,1976,1977 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

;DC76 VERSION NUMBER
	VDC76=026

.MACRO	DEFAULT	X,Y
.IF NDF X
X=Y
.ENDC
.ENDM	DEFAULT

DEFAULT	FT.CTY,<-1>	;IF NONZERO CTY IS A TTY ON 10
			; IF ZERO CTY WILL BE USED FOR DIAGNOSTIC'S ONLY
DEFAULT	FT2741,<-1>	;DEFAULT IS INCLUDE 2741 CODE
DEFAULT	DEFBCD,<^D988>	;DEFAULT 2741 CODE IS BCD APL
DEFAULT	STDALT,033	;OCTAL VALUE FOR ALTMODE

DEFAULT	FTCHECK,1	;INCLUDE SYSCHK CODE IN NONZERO
DEFAULT	FTDEBUG,1	;IF NONZERO INCLUDE DEBUGGING FEATURES
DEFAULT	DH.MAX,<^D8>	;MAXIMUM NUMBER OF DH11'S TO HANDLE
			; NOTE - SETTING THIS TOO SMALL MAY CAUSE THE PROGRAM TO CRASH
LINMAX=DH.MAX*20
DEFAULT FLOATV,300	;STARTING ADR FOR FLOATING INTERRUPT VECTORS
			; IF DEFINED DH.VEC IS THE 1ST DH11 VECTOR
DEFAULT	FTSCHK,1	;IF NONZERO INCLUDE ONCE ONLY SYSTEM DIAGNOSTIC

.ENABL	TIM,ABS,AMA,LC

STKLEN=40	;LENGTH OF STACK


	R0=%0		;USED FOR ADR OF DH11 BLOCK
	R1=%1
	R2=%2
	R3=%3
	L=%4		;NORMALY CONTAINS LINE NUMER*2
	R5=%5
	P=%6
	PC=%7

PS=177776	;PROCESSOR STATUS REGISTER
SW=177570	;CONSOLE SWITCHES

.SBTTL	MACRO DEFINITIONS


.MACRO	XP	X,Y
	X=Y
.ENDM	XP

.IF NE 0
.MACRO	XOR X,Y
	MOV	X,-(P)		;SAVE 1ST ARG
	BIC	Y,(P)		;LEAVE <X & Y'> ON STACK
	BIC	X,Y		;LEAVE <Y & X'> IN Y
	BIS	(P)+,Y		;LEAVE <Y & X'> OR <X & Y'> IN Y
.ENDM XOR
.ENDC

.MACRO	LEVEL	A	;SET PROCESSOR LEVEL
.IF NE <A-7>
	BIC	#000340,PS	;CLEAR PS LEVEL
.ENDC
.IF NE A
	BIS	#40*A,PS	;SET PROCESSOR PRIORITY LEVEL
.ENDC
.ENDM LEVEL

.MACRO COUNT A	;32BIT COUNT
	INC	A+2
	ADC	A
.ENDM	COUNT

.MACRO	JMPDWN	A		;BRANCH IF 10 NOT UP
	BIT	#40,DL.STS	;TEST FOR PORT ENABLED
	BEQ	A
.ENDM	JMPDWN

.MACRO	JUMPUP	A		;BRANCH IS PORT ENABLED
	BIT	#40,DL.STS	;TEST FOR PORT ENABLED
	BNE	A
.ENDM	JUMPUP

.MACRO	RING			;INTERRUPT THE 10
	BIS	#020000,DL.STS	;SET INTERRUPT THE 10 BIT
.ENDM	RING

.MACRO	T10ADV	A
	ADD	#2,A		;ADVANCE POINTER
	CMP	A,#T10QUE+Q.SIZ+Q.SIZ
	BNE	.+10
	MOV	#T10QUE,A
.ENDM	T10ADV
.SBTTL	HARDWARE BITS

;DH11 HARDWARE BITS
DHBASE=160020	;HARDWARE ADR OF FIRST DH11
DH.CHN=7		;DH11 INTERRUPT LEVEL
			; 1ST WORD IS SYSTEM CONTROL REGISTER
	DH.RIE=000100	;RECEIVE INTERRUPT ENABLE
	DH..RI=000200	;RECEIVE INTERRUPT
	DH..MC=004000	;MASTER CLEAR
	DH.TIE=020000	;TRANSMIT INTERRUPT ENABLE
	DH..TI=100000	;TRANSMIT INTERRUPT
			; 2ND WORD IS NEXT RECEIVED CHAR REGISTER
			; 3RD WORD IS LINE PARAMETER REGISTER
			; 4TH WORD IS CURRENT ADDRESS REGISTER
			; 5TH WORD IS BUFFER ACTIVE REGISTER
			; 6TH WORD IS BREAK CONTROL REGISTER
			; 7TH WORD IS SILO STATUS REGISTER

;ON CHARS OUT OF SILO
DHROVR=040000		;DATA OVERRUN
DHRFER=020000		;FRAMMING ERROR


;DM11B HARDWARE
DMBASE=170500	;HDW ADR OF FIRST DM11
	B.DM11=170500	;FIRST DM11 ADR
	DM.SCN=004000	;CLEAR SCANNER
	DM.INI=002000	;CLER MULTIPLEXER
	DM.STP=000400	;STEP TO NEXT LINE
	DM.DNE=200
	DM.IEN=000100	;INTERRUPT ENABLE
	DM.ENB=000040	;SCAN ENABLE
	DM.BSY=000020	;CLEAR SCAN STILL PERCOLATING


;KW11 - LINE FREQUENCY CLOCK
	CLKTRP=100	;CLOCK VECTOR
	CLKWRD=177546	;ADDRESS OF CLOCK WORD
	CLKENBL=100	;INTERRUPT ENABLE
	CLKFLG=200	;FLAG(CLEARED BY READING
;TTY BITS

CTITRP=60
CTISTS=177560
CTICHR=177562

CTOTRP=64
CTOSTS=177564
CTOCHR=177566
;DL10 - UNIBUS TO DECSYSTEM-10 MEMORY BUS INTERFACE
DL1ADR=100000	;BASE ADDRESS FOR 10 MEMORY
	;1ST WORD IS STATUS
	; BIT 15 - 11 INT(INTERRUPTS IF 11-INT-ENB SET)
	; BIT 14 - CLEAR 11 INT
	; BIT 13 - 10 INT
	; BIT 12 - CLEAR 10 INT
	; BIT 11 - NXM(INTERRUPTS IF ERR ENB SET)
	; BIT 10 - CLEAR NXM
	; BIT 09 - PAR ERR(INTERRUPTS IF ERR ENB SET)
	; BIT 08 - CLEAR PAR ERR
	; BIT 07 - WCOV(INTERRUPTS IF ERR ENB SET)
	; BIT 06 - CLEAR WCOV
	; BIT 05 - PORT ENABLE
	; BIT 04 - (GUESS !)
	; BIT 03 - ERR ENABLE
	; BIT 02 - 11 INT ENB
	; BITS 00 & 01 - PIA
DL1TRP=170	;VECTOR ADR FOR DL10
DL1CHN=7	;CHANNEL FIVE
.SBTTL	DL10 WINDOW PARAMETERS

.MACRO	BLK X,Y
.LIST
	  X=DL1ADR
.NLIST
DL1ADR=DL1ADR+Y+Y
.ENDM BLK


BLK	DL.STS,1	;HDW STATUS WORD
BLK	DL.ESA,1	;11 STARTING ADR
BLK	DL.WNU,1	;WORD NOT USED
BLK	DL.NAM,1	;POINTER TO PROGRAM NAME
BLK	DL.EPN,1	;PORT NUMBER
BLK	DL.OK,1	;SET TO ZERO ONCE A SECOND BY DC76
BLK	DL.HLT,1	;SAVE PC HERE IF 11 CRASHES
BLK	DL.DWN,1	;A FLAG WHICH INDICATES UPNESS OF 11
			; -1 DOWN - NO MESSAGES
			; 0 DOWN COMPLAIN ONCE A MIN
			; 1 UP
BLK	DL.UPT,1	; POINTER TO NUMBER IN 10 WHICH INCREMENTS ONCE/JIFFY
BLK	DL.TTP,1	;POINTER TO LAST ITEM PLACED IN THE TO-10 QUEUE
BLK	DL.TTG,1	;POINTER TO LAST ITEM TAKEN FROM THE TO-10 QUEUE
BLK	DL.TEP,1	;POINTER TO LAST ITEM PLACED IN THE TO-11 QUEUE
BLK	DL.TEG,1	;POINTER TO LAST ITEM TAKEN FROM THE TO-11 QUEUE
BLK	DL.EBS,1	;SIZE OF T0-11 QUEUE
BLK	DL.TBS,1	;SIZE OF T0-10 QUEUE
BLK	DL.LTO,1	;ADD TO 76 LINE NUMBER TO GET LINTAB INDEX
BLK	DL.DTO,1	;DSCTAB OFFSET
BLK	DL.STA,1	;POINTER TO STATES
BLK	DL.FRN,1	;NUMBER OF FREE CHUNKS
BLK	DL.AOM,1	;ADDRESS OF FIRST WORD OF MAP
BLK	DL.TEA,1	;ADDRESS OF TO-11 QUEUE
BLK	DL.TTA,1	;ADDRESS OF TO-10 QUEUE
BLK	DL.MAX,1	;TOTAL NUMBER OF FRONT END LINES
BLK	DL.NTT,1	;NUMBER OF LINES ON THIS DC76
BLK	DL.PAR,1	;PA611 READER
BLK	DL.PTR,1	;PC-11 READER
BLK	DL.PAP,1	;PA611P PUNCH
BLK	DL.LPC,1	;LPC 11
BLK	DL.PTP,1	;PC11 PUNCHES
BLK	DL.PIO,1	;NONIMMEDIATE POINTERS
BLK	DL.TTQ,0	;TO-10 QUEUE
;	DL.TEQ		;T0-11 QUEUE FOLLOWS
;TO ELEVEN QUEUE ENTRYS ARE OF THE FORMAT
;	BYTE <FRONT END CONTROL FUNCTION>,<LINE #>,<SUBFUNCTION>,<ARG>

;FRONT END CONTROL FUNCTIONS
XP	FECXMT,2	;TRANSMIT DATA
XP	FECCOB,4	;CLEAR OUTPUT BUFFER
XP	FECMDM,6	;MODEM CONTROL
XP	FECEXM,10	;EXAMINE
XP	FECDEP,12	;DEPOSIT
XP	FECFNI,14	;FUNCTION NOT IMPLEMENTED IN THE -10
XP	FECLPC,16	;LINE PARAMETER CONTROL
XP	FECMAX,16	;MAXIMUM LEGAL AFRONT END CONTROL FUNCTION

;LINE PARAMETER CONTROL MESSAGES FOR THE DC76
XP	LPCSPD,<2*400>	;SET LINE SPEED (RECEIVE*10+TRANSMIT)
XP	LPCABR,4	;ENABLE AUTO BAUD RATE DETECT
XP	LPCELE,6	;SET TYPE ELEMENT
XP	LPCAPL,10	;SET/CLEAR APL MODE
XP	LPCRVB,12	;SET/CLEAR REVERSE BREAK
XP	LPCUKB,14	;UNLOCK KEYBOARD
XP	LPCTDY,16	;SET/CLEAR TIDY BIT
XP	LPCMAX,16	;MAXIMUM LEGAL LPC FUNCTION

;MODEM CONTROL FUNCTIONS
XP	MDMOFF,2	;TURN MODEM OFF
XP	MDMON,4		;TURN MODEM ON
XP	MDMRNG,6	;DATASET IS RINGING
XP	MDMINI,10	;COMPUTER RESTARTED

;TO 10 QUEUE ENTRYS ARE OF THE FORMAT
;	BYTE	<FRONT END CONTROL FUNCTION><LINE #><><CHAR>

;FRONT END STATUS FUNCTIONS
	XP	FESXDN,<1*400>	;TRANSMIT DONE
	XP	FESRDT,<2*400>	;RECEIVED DATA
	XP	FESWRD,<3*400>	;WORD FROM 11
	XP	FESDSC,<4*400>	;MODEM CONTROL
	XP	FESRJT,<5*400>	;REJECT 
	XP	FESLPC,<6*400>	;LINE PARAMETER CONTROL
				; ONLY SUBTYPE IS LPTSPD
;2741 HANDLING IN THE DC76
;
; WHEN A LINE SPEED IS SET TO 134/134 THE 10 KNOWS THE LINE IS A 2741
;
; WHEN A JOB GOES INTO TIWAIT THE MONITOR WILL SEND A 'UNLOCK KEYBOARD' MESSAGE
;
; THE MONITOR TELLS THE DC76
;	WHAT TYPING ELEMENT
;	TIDY/NOT TIDY
;	HAS REVERSE-BREAK/DOESN'T
;	NORMAL/APL MODE
;
; FILLS FOR 2741'S ARE DONE BY THE DC76
;
; THE IRMA CATCHER DOESN'T RUN FOR 2741 LINES
.SBTTL	INTERRUPT VECTORS

.MACRO	.TRAP X,Y,Z
.=X
	Y		;ADDR OF INTERRUPT ROUTINE
	Z*40		;PRIORITY LEVEL
.ENDM .TRAP

	.TRAP	4,INSTRP,7	;TIMEOUT
	.TRAP	10,INSTRP,7	;ILLEGAL & RESERVED INSTR
	.TRAP	14,INSTRP,7	;BPT
	.TRAP	20,INSTRP,7	;IOT
	.TRAP	24,DC76,7	;POWER FAIL
	.TRAP	30,INSTRP,7	;EMT
	.TRAP	34,INSTRP,7	;TRAP

	.TRAP	CTITRP,CTIINT,7	;TTY RECEIVE INTERRUPTS
	.TRAP	CTOTRP,CTOINT,7	;TTY XMT INTERRUPS

	.TRAP	CLKTRP,CLKINT,7	;INTERRUPT FOR KW11 CLOCK

	.TRAP	DL1TRP,DL1INT,DL1CHN	;INTERRUPT ROUTINE FOR DL10

.IF NDF FLOATV
	FLOATV=300	;STARTING ADR FOR FLOATING VECTORS
.ENDC
STKADR=540+STKLEN
.=STKADR

	.WORD	VDC76	;VERSION NUMBER
.SBTTL	INITIALIZATION


;RESTART 11 CODE HERE
DC76:	LEVEL	7		;DISABLE ALL INTERRUPTS
	MOV	#STKADR,P	;INITIALIZE STACK POINTER
INIJMP:	JMP	SYSCHK		;PERFORM INITIAL SYSTEM CHECK
	INC	RCOUNT		;COUNT THIS RESTART
	MOV	#-1,UPFLAG	;SIGN THAT 10 ISN'T HERE YET
	CLR	DSCLCK		;DATASET CONTROL CLOCK

;HERE TO ZERO HIGH CORE
	MOV	#FIRZER,R0	;FIRST LOCATION TO ZERO
5$:	CLR	(R0)+		;CLEAR NEXT LOCATION
	CMP	R0,#LSTZER	;HAVE WE ZEROED LAST LOCATION ?
	BNE	5$

	MOV	#STKADR,P	;RESET STACK POINTER

;INITIALIZE ALL THE TTY LINES
	CLR	L		;START WITH LINE 0
40$:	MOV	DH.TAB(L),R0	;GET DH11 BLOCK ADR
	MOV	@R0,R3		;GET DH11 HDW ADR
	BEQ	47$		;BRANCH IF DH11 IS NOT PRESENT
	TSTB	LN.TAB(L)	;TEST FOR 1ST LINE IN DH11 ?
	BNE	43$		;BRANCH IF NOT 1ST LINE IN GROUP
	MOV	#DH..MC,@R3	;CLEAR DH11
	CLR	16(R3)		;SET ALARUM LEVEL FOR THE SILO
	BIS	#DH.TIE!DH.RIE,@R3	;ENABLE INTERRUPTS
	MOV	BLK.DM(R0),R3	;GET DM11BB HDW ADR
	BEQ	43$		;BRANCH IF DON'T HAVE ONE
	MOV	#DM.SCN,@R3	;CLEAR DM11BB
	JSR	PC,DMWAIT	;WAIT FOR COMPLETION

43$:	MOV	@R0,R3		;GET DH11 HDW ADR
	BIC	#17,@R3		;CLEAR LINE SELECT
	BISB	LN.TAB(L),@R3	;SELECT LINE NUMBER
	BICB	#^C<AUTBIT!ALNBIT>,CARTAB(L)	;CLEAR MOST BITS
	BISB	#INIBIT,CARTAB(L)	;SET SO WE SEND STATUS SOON
	TSTB	CARTAB(L)	;TEST FOR LOOKING FOR CR
	BGE	42$		;BRANCH IF NOT LOOKING FOR CR
	MOVB	#167,SPDTAB(L)	;SCAN AUTOBAUD LINES AT 300 BAUD
42$:	JSR	PC,MAKSPD	;SET LINE TO THE RIGHT SPEED
	MOV	BLK.DM(R0),R3	;GET ADR OF DM11BB
	BEQ	46$		;BRANCH IF NONE
	MOV	#3,2(R3)	;SET LINE ENABLE
	BIT	#100,2(R3)	;TEST FOR CARRIER
	BNE	45$		;BRANCH IF CARRIER IS PRESENT
	MOV	#1,2(R3)	;CLEAR LINE ENABLE
45$:	BIS	#DM.STP,@R3	;ADVANCE TO THE NEXT LINE

46$:	ADD	#2,L		;ADVANCE TO THE NEXT LINE
	CMP	#LINMAX+LINMAX,L	;COMPARE TO NONEX LINE
	BNE	40$

47$:

;INITIALIZE THE DL10
60$:	MOV	#000014+<DL1CHN&3>,DL.STS	;ENABLE ALL INTERRUPTS

;HERE TO INITIALIZE THE TO 10 QUEUE
	MOV	#T10QUE,T10PTR
	MOV	#T10QUE,T10TKR

;HERE TO INITIALIZE THE CTY
	MOV	#000100,CTISTS	;SET INTERRUPT ENABLE

	CLRB	JIFFLG
	MOV	#CLKENB,CLKWRD	;ENABLE CLOCK INTERRUPTS

	MOV	#RELMSG-1,R0
	JSR	PC,SNDALL
;	JMP	LOOP
.SBTTL	LOW LEVEL CODE

LOOP:	LEVEL	0		;IN CASE SOMEBODY FORGOT
	JUMPUP	10$		;BRANCH IF PORT ENABLED
	TST	UPFLAG		;DID I THINK 10 WAS UP ?
	BMI	30$		;BRANCH IF WE ALREADY KNEW
	JMP	DC76		;YES SO RESTART THE WORLD
10$:	TST	UPFLAG		;IS THIS A NEW DEAL ?
	BGE	30$		;BRANCH IF HAS BEEN UP ALL ALONG

	CLR	DL.WNU		;TRIE TO WRITE ZEROES IN 10 MEMORY
	TST	DL.WNU
	BNE	23$		;DIE IF EFFORT FAILED
	MOV	#-1,DL.WNU	;WRITE ALL ONES IN 10 MEMORY
	CMP	#-1,DL.WNU	;CHECK TO SEE IT GOT THERE
	BEQ	25$
23$:	TRAP
25$:
	CMP	DL.DWN,#1	;TEN THINK WE ARE UP ?
	BEQ	26$		;YES, DON'T TRY TO REWRITE NAME
	MOVB	#44,DL.NAM	;SIXBIT "D"
	MOVB	#43,DL.NAM	;SIXBIT "C"
	MOVB	#27,DL.NAM	;SIXBIT "7"
	MOVB	#26,DL.NAM	;SIXBIT "6"
	CLRB	DL.NAM
	CLRB	DL.NAM
26$:
	MOV	DL.MAX,R0	;GET NUMBER OF LINES 10 THINKS ARE ON 76
				; *****THIS SHOULD BE DL.NTT*****
.IF NE FT.CTY
	DEC	R0		;MAKES NUMBER FOR CTY
.ENDC
	CMP	#LINMAX,R0	;TEST AGAINST WHAT WE WERE BUILT FOR
	BGE	16$		;BRANCH IF REASONABLE
	MOV	#LINMAX,R0	;THIS IS AS MUCH AS HE CAN HAVE
16$:	MOV	R0,TCONLN	;LINE NUMBER FOR THE CTY

	MOV	DL.TTA,R0	;ADR OF TO-10 QUEUE
	SUB	DL.AOM,R0	;SUBTRACT OFF BASE OF WINDOW
	ASL	R0		;MULTIPLY BY 2
	ADD	#DL.STS,R0	;ADD DISPLACEMENT OF WINDOW(11'S POINT OF VIEW)
	MOV	R0,TTA		;SAVE THIS MAGIC NUMBER
	MOV	DL.TEA,R0	;ADR OF TO-11 QUEUE
	BNE	17$		;BRANCH IF PLAUSIBLE
	TRAP			;PROBABLY ON WRONG PORT
17$:	SUB	DL.AOM,R0	;SUBTRACT ADR OF WINDOW(10'S POINT OF VIEW)
	ASL	R0		;MULTIPLY BY 2
	ADD	#DL.STS,R0	;ADD ADR OF WINDOW(11'S POINT OF VIEW)
	MOV	R0,TEA		;SAVE ADR

	MOV	#CONMSG-1,R0
	JSR	PC,SNDALL	;TELL ALL USERS
;SINCE 10 WENT AWAY, HE DOESN'T KNOW LINESPDS
;TELL HIM WHAT WE HAVE
	MOV	TCONLN,L	;START WITH CTY
	ASL	L
19$:	TST	-(L)		;NOT CTY
	BISB	#INIBIT,CARTAB(L)  ;FORCE DC76 TO SEND CARRIER STATUS TO -10 IN DSCSCN
	TST	L
	BNE	19$		;NOT DONE YET
	MOV	#10,UPFLAG	;REMEMBER 10 IS UP

30$:	TST	JIFFLG		;TEST CLOCK FLAG
	BEQ	40$		;BRANCH IF CLOCK HAS NOT GONE OFF
	  JMP	CLKSCN		;CLOCK DID GO OFF
40$:	JMPDWN	LOOP70
	CMP	DL.TEP,DL.TEG	;COMPARE TO-11 PUTTER AND GETTER
	BEQ	60$		;BRANCH IF QUEUE IS EMPTY
	JMP	DLINT4		;GO READ TO-ELEVEN QUEUE

;HERE TO SEE IF WE NEED TO SEND XMT INTERRUPTS TO 10
60$:	CMP	T10TKR,T10PTR	;CHECK FOR ENTRY'S IN QUEUE
	BEQ	LOOP70		;BRANCH IF QUEUE EMPTY
	TST	UPFLAG		;IS THE -10 ALIVE?
	BLE	LOOP70		;NO. MUST HAVE STOPPED, SO WAIT
	LEVEL	7
	T10ADV	T10TKR		;ADVANCE TO-10-QUEUE TAKER
	MOV	@T10TKR,R0
	JSR	PC,QUEUEW	;SEND WORD TO 10
	LEVEL	0

LOOP70:
.SBTTL	DATASET CHECKING

;HERE TO CHECK DATASET STATUS
; STRATEGY IS TO CHECK DATA SET STATUS ONCE EVERY 1/10 OF A SECOND
; AC USAGE IS:	R0	CONTAINS DH11 BLOCK ADR
;		R3	CONTAINS DM11BB HDW ADR
;		R5	CONTAINS CARTAB ENTRY FOR LINE
;		L CONTAINS LINENUMBER*2

DSCCHK:	TST	DSCLCK		;SHOULD WE CHECK THE DATASET STUFF ?
	BGE	DSC.07
.IF NE FTDEBUG
	TST	UPFLAG
	BMI	DSC.05		;IF 10 NOT HEALTHY DON'T TALK TO HIM
	INC	IDLCNT		;COUNT TIMES WE WERE IDLE
	MOV	#EXMTRP,4	;IN CASE SWITCHES ARE FUNNY
	MOV	@SW,R1		;USE SWITCHES AS ADDR TO EXAMINE
	MOV	#NXMTRP,4	;RESTORE BUS TRAP LOC
	MOV	R1,DL.WNU	;DISPLAY WORD IN LIGHTS
	MOV	#40,R0
10$:	DEC	R0
	BNE	10$
.ENDC

DSC.05:	JMP	LOOP

DSC.07:	MOV	#-^D10,DSCLCK	;TRY AGAIN IN A LITTLE WHILE
	CLR	L		;START WITH LINE 0
DSCSCN:	MOV	DH.TAB(L),R0	;GET DH11 BLOCK ADR
	MOV	BLK.DM(R0),R3	;GET DM11BB HDW ADR
	BEQ	DSC.05
	LEVEL	7		;SO DL10 DOESN'T INTERVENE
	MOVB	CARTAB(L),R5	;GET CARTAB BITS FOR THIS LINE
	BITB	#INIBIT,R5	;IS THIS THE FIRST TIME FOR THIS LINE ?
	BEQ	10$		;IF NOT DONE
	TST	UPFLAG		;IS 10 HEALTHY
	BLE	10$		;IF NOT DON'T TALK TO 10
	TSTB	R5		;CHECK FOR LOOKING FOR SPEED
	BMI	10$		;IF SO NOTHING TO TELL THE 10
	MOVB	SPDTAB(L),R1	;GET LAST SPEED WE SAW
	BIC	#^C377,R1	;CLEAR EXTRA BITS
	BIS	#LPCSPD,R1	;SET FLAG THAT THIS IS SPEED
	MOV	L,R0		;GET LINE NUMBER
	ASR	R0
	BIS	#FESLPC,R0
	JSR	PC,QUE2WD
10$:	TSTB	LN.TAB(L)	;TEST FOR 1ST LINE IN A GROUP
	BNE	20$
	BIS	#DM.SCN,@R3	;CLEAR SCANNER
20$:	JSR	PC,DMWAIT	;WAIT FOR COMPLETION

	MOV	@R3,R2		;GET DM11BB REGISTER
	MOV	R2,R1		;SAVE A COPY IN CASE WE DON'T LIKE IT
	BIC	#^C17,R2	;LEAVE ONLY LINE SELECT BITS
	CMPB	R2,LN.TAB(L)	;IS IT THE ONE I EXPECTED ?
	BEQ	21$		;BRANCH IF OK
	TRAP			;EITHER I DON'T UNDERSTAND THE DM11BB OR IT FUTZED

21$:	MOV	2(R3),R2	;GET STATUS FOR LINE
	BIT	#100,R2		;IS CARRIER ON ?
	BNE	60$		;BRANCH IF YES

;HERE IF CARRIER IS OFF
	BITB	#INIBIT,R5	;HAVE WE JUST RESTARTED ?
	BNE	27$		;IF SO TELL 10 LINE DEAD
	BITB	#LOSBIT,R5	;DID CARRIER GO AWAY RECENTLY ?
	BEQ	30$
	BITB	#ALNBIT,R5	;IS THIS AN AUTOBAUD LINE ?
	BEQ	27$
	MOV	@R0,R1		;GET DH11 HDW ADR
.IF NE FT2741
	CLR	BCDTAB(L)	;NO LONGER 2741
.ENDC
	BISB	#AUTBIT,R5	;SET LOOK FOR SPEED BIT
	BIC	#17,@R1
	BISB	LN.TAB(L),@R1
	MOV	#B.300,4(R1)	;SET 300BAUD AGAIN
27$:	TST	UPFLAG		;IS 10 ALIVE AND WELL ?
	BLE	DSC.93		;IF NOT DON'T TRY TO TELL 10
	BICB	#INIBIT!LOSBIT,R5	;CLEAR CARRIER JUST LOST
	MOV	#MDMOFF,R1	;CODE FOR DATASET JUST LOST
	BR	DSC.70		;TELL 10

30$:	BITB	#CARBIT,R5	;HAS CARRIER BEEN ON ?
	BEQ	40$		;BRANCH IF NOT
	BICB	#CARBIT,R5	;SET CARRIER NOT HERE IN TABLE
	BISB	#LOSBIT,R5	;SET CARRIER JUST LOST
	BR	DSC.93

;HERE TO CHECK FOR RING(CARRIER IS OFF)
40$:	BIT	#200,R2		;IS RING UP ?
	BNE	44$
	BICB	#RNGBIT,R5	;CLEAR RING FLAG IN CARRIER TABLE
	BR	DSC.93
44$:	BITB	#RNGBIT,R5	;HAS RING BEEN UP FOR A WHILE ?
	BNE	DSC.93
	TST	UPFLAG		;IS THE 10 HEALTHY ?
	BLE	DSC.93		;IF NOT DON'T TRY TO TALK TO HIM
45$:	BISB	#RNGBIT,R5	;SET RING BIT IN CARRIER TABLE
	MOV	#MDMRNG,R1
	BR	DSC.70

;HERE IF CARRIER IS ON
60$:	BITB	#INIBIT,R5	;JUST STARTING 10 OR 11?
	BNE	61$		;TELL HIM ABOUT CARRIER
	BITB	#CARBIT,R5	;HAS CARRIER BEEN ON FOR A WHILE ?
	BNE	DSC.93		;BRANCH IF YES
61$:	TST	UPFLAG		;TEST FOR 10 HEALTHY
	BLE	DSC.93		;IF NOT DON'T TRY TO TALK TO HIM
	BIT	#RNGBIT,R5	;HAVE WE TOLD 10 IT RANG?
	BEQ	45$		;IF NOT PRETEND
	BICB	#LOSBIT!INIBIT,R5	;CLEAR CARRIER LOST BIT
	BISB	#CARBIT,R5	;SET CARRIER BIT IN TABLE
	TSTB	R5		;IS LINE LOOKING FOR SPEED ?
	BMI	DSC.93		;IF SO WILL SAY CARRIER ON LATER
	MOV	#MDMON,R1	;MESSAGE FOR CARRIER ON
DSC.70:	MOV	L,R0		;COPY LINE NUMBER
	ASR	R0
	BIS	#FESDSC,R0	;FLAG THIS IS DATASET CONTROL
	JSR	PC,QUE2WD	;PUT MESSAGE INTO TO-10 QUEUE
	MOVB	R5,CARTAB(L)	;IN CASE THIS IS THE END
	MOV	DL.TTP,R0	;GET TO-10 PUTTER
	SUB	DL.TTG,R0	;LEAVES NUMBER OF ENTRIES IN QUEUE
	BMI	DSC.95		;IF NEGATIVE HAS WRAPPED AROUND
				; WHICH IS COMPLICATED SO GIVE UP
	ASL	R0
	CMP	R0,DL.TBS	;COMPARE ENTRIES IN QUEUE TO SIZE
	BMI	DSC.95		;IF QUEUE IS HALF FULL LET 10 CATCH UP
DSC.93:	BIS	#DM.STP,@R3	;STEP TO NEXT LINE
	MOVB	R5,CARTAB(L)	;RESTORE CARRIER TABLE
	LEVEL	0
	ASR	L		;DIVIDE LINE NUMBER BY 2
	INC	L
	CMP	TCONLN,L
	BGT	DSC.97		;KEEP ON SCANNING IF HAVENT RUN OUT YET
DSC.95:	JMP	LOOP
DSC.97:	ASL	L
	JMP	DSCSCN

;HERE TO WAIT FOR DM11-BB TO BE NOT BUSY
; CALLED BY JSR PC, DMWAIT
; EXPECTS DM11-BB CSR ADDRESS IN R3, DESTROYS R1
;
DMWAIT:	MOV	#1000,R1	;SET UP A TIME-OUT
10$:	BIT	#DM.BSY,@R3	; IS DM11-BB BUSY ?
	BEQ	20$		; NO, RETURN
	DEC	R1		; YES, COUNT DOWN TIMER
	BGT	10$		;TRY AGAIN
	 TRAP			;DM11-BB BUSY WON'T CLEAR
20$:	RTS	PC
;HERE TO SEND A MESSAGE TO ALL USERS
; CALL:	JSR	PC,SNDALL	;WITH MSG ADR IN R0
SNDALL:	MOV	TCONLN,L
	DEC	L
	ASL	L
	MOV	R0,-(P)		;SAVE ADR OF STRING ON STACK
10$:	MOV	(P),STRTAB(L)	;SET STRING IN TABLE
	MOV	DH.TAB(L),R0	;GET ADR OF DH11 BLOCK FOR THE LINE
	BIT	TTOBIT(L),B.BAR(R0)	;TEST FOR ACTIVE
	BNE	20$
	MOV	#377,R1		;START OUTPUT WITH A FILLER
	LEVEL	7
	JSR	PC,TYPE30	;TYPE 1ST CHAR OF STRING
	LEVEL	0
20$:	SUB	#2,L
	BGE	10$
	MOV	(P)+,R0
	JMP	TYPSTR
;TRAP HERE ON AN ILLEGAL INSTRUCTION OF FATAL ERROR IN PROGRAM

INSTRP:	JMPDWN	10$
	MOV	R1,-(P)		;FAKE EXIT ZAPS R1
	MOV	#EXMTRP,4	;RETURN EVEN IF FAIL
	MOV	2(P),DL.HLT	;PUT PC UP FOR 10 TO SEE
	MOV	#NXMTRP,4	;PUT BACK NXM LOCATION
	MOV	(P)+,R1		;RECOVER AC
10$:	RESET			;FOR LUCK
.IF NE FTSCHK
	MOV	R0,-(P)
	MOV	R1,-(P)
	JSR	R0,CRLTYP
	.ASCIZ	\trap at \
	.EVEN
	MOV	4(P),R0	;GET PC OFF STACK
	JSR	PC,OCTYPE
	MOV	(P)+,R1
	MOV	(P)+,R0
.ENDC
	HALT
;TRAP HERE ON A NXM
NXMTRP:	TST	UPFLAG		;TEST TO SEE IF 10 HAD BEEN UP
	BMI	40$		;BRANCH IF 10 HAS NOT BEEN UP
	JUMPUP	30$		;BRANCH IF THE DL10 PORT STILL ENABLED
	JMP	DC76		;10 IS BEING RELOADED SO GO AWAY
30$:
40$:	TRAP
.SBTTL	FROM-10 QUEUE ROUTINES

;HERE TO PUT A TWO WORD ENTRY INTO THE TO-10 QUEUE
; CALL:	JSR	PC,QUE2WD	WITH WORDS IN R0 AND R1
QUE2WD:	MOV	DL.TTP,R2	;GET QUEUE PUTTER
	INC	R2		;ADVANCE TO NEXT ENTRY
	CMP	R2,DL.TBS	;DID THIS OVERFLOW ?
	BNE	10$
	CLR	R2
10$:	CMP	R2,DL.TTG	;IS THE QUEUE FULL?
	BEQ	QUEOVF		;YES
	ASL	R2		;CONVERT TO BYTE ADR
	ADD	TTA,R2		;MAKE RELATIVE
	MOV	R0,@R2		;PUT 1ST WORD INTO THE QUEUE
	SUB	TTA,R2
	ASR	R2
	MOV	R1,R0		;MOV 2ND ARG TO RIGHT AC
	BR	QUEWD2		;PUT 2ND WORD INTO QUEUE

;HERE TO PUT A WORD INTO THE TO-10 QUEUE
; CALL:	JSR	PC,QUEUEW	WITH WORD IN R0

QUEUEW:	MOV	DL.TTP,R2	;GET QUEUE PUTTER
QUEWD2:	INC	R2		;ADVANCE TO NEXT ENTRY
	CMP	R2,DL.TBS	;COMPARE TO LIMIT
	BNE	10$
	CLR	R2		;POINT TO START OF QUEUE
10$:	CMP	R2,DL.TTG	;IS THE QUEUE FULL?
	BEQ	QUEOVF		;YES
	ASL	R2		;MULTIPLY BY 2
	ADD	TTA,R2		;ADD QUEUE ADR
	MOV	R0,@R2
	SUB	TTA,R2
	ASR	R2
	MOV	R2,DL.TTP	;RESTORE NEW PUTTER TO WINDOW

	RING			;INTERRUPT THE 10
	RTS	PC

;HERE IF TO-10 QUEUE IS ABOUT TO OVERFLOW
;THIS INDICATES THAT TO-10 QUEUE DEFINED IN COMMON
; IS NOT LARGE ENOUGH TO HANDLE OUR MAXIMUM LOAD
QUEOVF:	TRAP			;ONLY SAFE THING TO DO
READW:	MOV	DL.TEG,R0	;GET ADR OF GETTER
	INC	R0
	CMP	R0,DL.EBS	;COMPARE TO MAX VALUE
	BNE	5$
	CLR	R0
5$:	MOV	R0,R1		;COPY RELATIVE ADR OF NEXT ENTRY
	ASL	R1		;MULTIPLY BY 2
	ADD	TEA,R1		;ADD DISPLACEMENT
	MOV	@R1,R1		;GET NEXT ENTRY
	MOV	R0,DL.TEG	;UPDATE WINDOW COPY OF GETTER

	RTS	PC

;HERE WHEN THE TO-ELEVEN QUEUE HAS DATA
DLINT4:	JSR	PC,READW	;GET NEXT WORD FROM QUEUE
	MOV	R1,L		;GET LINE NUMBER
	BIC	#^C<377>,L	;STRIP EXTRA BITS
	MOV	R1,R3		;COPY INTO ANOTHER AC
	SWAB	R3		;SWAP HALVES OF 1ST WORD
	BIC	#^C<377>,R3	;CLEAR ANY EXTRA BITS
	CMP	#FECMAX,R3	;COMPARE TO HIGHEST LEGAL FUNCTION
	BGE	5$		;BRANCH IF CODE IS LEGAL
	TRAP

5$:	JMP	@FECTAB(R3)
FECTAB:	REJECT			;(0) ILLEGAL
	TYPE			;(2) TRANSMIT DATA
	REJECT			;(4) CLEAR OUTPUT BUFFER
	SETDSC			;(6) MODEM CONTROL
	EXAMIN			;(10) EXAMINE
	DEPOSIT			;(12) DEPOSIT
	REJECT			;(14) FUNCTION NOT IMPLEMENTED
	SETLPC			;(16) LINE PARAMETER CONTROL

;HERE TO REJECT A MESSAGE FROM THE 10
REJECT:	MOV	#FESRJT,R0	;REJECT CODE
	LEVEL	7
	JSR	PC,QUEUEW	;SEND WORD TO 10
	LEVEL	0
	JMP	LOOP
;HERE BECAUSE 10 HAS REQUESTED TO SEE 11 MEMORY
EXAMIN:	JSR	PC,READW	;GET ADR 10 IS INTERESTED IN
	MOV	#EXMTRP,4	;SET BUS TRAP VECTOR
	MOV	@R1,R1		;GET REQUESTED WORD
	MOV	#NXMTRP,4	;RESET BUS TRAP LOCATION
	MOV	#FESWRD,R0
	JSR	PC,QUE2WD	;PUT MESSAGE INTO TO-10 QUEUE
	JMP	LOOP
EXMTRP:	CLR	R1
	RTI

;HERE BECAUSE 10 HAS REQUESTED TO DEPOSIT 11 MEMORY
DEPOSI:	JSR	PC,READW	;GET ADR 10 WANTS TO ZAP
	MOV	R1,R2		;SAVE ADR
	JSR	PC,READW	;GET DATA TO DEPOSIT
	MOV	R1,@R2		;DEPOSIT
	JMP	LOOP
;HERE BECAUSE DECSYSTEM-10 WANTS US TO TYPE A CHAR
TYPE:	CMP	R0,DL.TEP	;THERE SHOULD BE ANOTHER WORD IN QUEUE
	BNE	6$
	TRAP
6$:	JSR	PC,READW	;GET THE NEXT WORD
	LEVEL	7		;WHILE WE DIDDLE DH11'S
	CMP	L,TCONLN	;WAS THIS FOR THE CTY ?
	BLO	10$		;BRANCH FOR DH11
	BNE	90$		;BRANCH IF 10 IS CONFUSED
	MOVB	R1,CTOCHR	;TYPE CHAR
	MOV	#000100,CTOSTS
	BR	90$		;BACK TO LOOP

10$:	ASL	L		;MULTIPLY BY 2
	TST	@DH.TAB(L)	;IS THERE A DH11 FOR THIS LINE ?
	BEQ	60$		;IF NOT GIVE IMMEDIATE XMT FLAG
	TSTB	CARTAB(L)	;ARE WE LOOKING FOR THIS GUY'S SPEED ?
	BMI	60$		;IF WE ARE IMMEDIATE XMT INT
	CLR	STRTAB(L)	;IN CASE WE DC76 SAID SOMETHING
	JSR	PC,TYPE30	;GIVE CHAR TO DH11
90$:	LEVEL	0
	JMP	LOOP

60$:	MOV	L,R0		;COPY LINE NUMBER
	ASR	R0
	BIS	#FESXDN,R0	;FLAG TO SAY XMTINT
	T10ADV	T10PTR
	MOV	R0,@T10PTR	;PUT ITEM INTO THE QUEUE
	BR	90$
;HERE TO TYPE A CHARACTER ON A DH11 LINE
; CALL	JSR	PC,TYPE30	;WITH L SET UP AND CHAR IN R1
;	RETURN
; ALTERNATE CALL TO PERFORM NO CHARACTER TRANSLATION:
;	JSR	PC,TYPE80	;WITH L AND CHAR IN R1
;	RETURN
TYPE30:
.IF NE FT2741
	MOV	BCDTAB(L),R3	;GET 2741 STATUS BITS
	BNE	10$		;BRANCH IF 2741
	JMP	TYPE80		;NOT 2741 SO NO SPECIAL HANDLING

10$:	BIT	#BCDPRL,R3	;TEST FOR PRINTER LOCKED
	BEQ	TYPE31		;BRANCH IF NOT LOCKED
	MOVB	R1,ASAPTB(L)	;SAVE CHAR FOR LATER
	BIT	#BCDHDB,R3	;TEST FOR REVERSE BREAK FEATURE
	BEQ	6$		;BRANCH IF DOESN'T HAVE IT
	BIT	#BCDCDB,R3	;CHECK FOR OK TO DODEBREAK
	BEQ	6$
	BIT	#BCDRCR,R3	;WAS LAST CHAR IN A CR ?
	BNE	6$		;IF SO WE'LL GET CONTROL SOON ANYWAY
	TSTB	CLKTAB(L)	;CHECK FOR REQUEST IN CLOCK QUEUE
	BNE	6$		;WHICH WE DON'T WANT TO DISTURB
	MOV	@DH.TAB(L),R3	;GET DH11 HDW ADR
	BIS	TTOBIT(L),14(R3)	;COMMENCE SENDING BREAK
	BIS	#BCDKBL!BCDXRB,BCDTAB(L)	;PRINTER LOCKED, XMT REV BREAK
	MOV	#<6*400>+^D21,CLKTAB(L)	;TIMER TO STOP BREAK
6$:	RTS	PC		;AND RETURN TO CALLER
TYPE31:	BIC	#^C177,R1	;STRIP PARITY

;MAKE SPECIAL CHECKS FOR CARRIAGE RETURN
	CMP	#15,R1		;IS THIS A CARRIAGE RETURN
	BNE	8$		;BRANCH IF NOT A CR
	BIS	#BCDOCR,R3	;SET SPECIAL FLAG
	TST	STRTAB(L)	;ALREADY FILLING ?
	BNE	12$		;IF SO DON'T FORGET IT
	MOV	#FILLER-14,STRTAB(L)	;FILL WITH RUBOUT LATER
	BR	12$		;THEN ON WITH THE GAME
8$:	BIT	#BCDOCR,R3	;DID 10 JUST SEND A CR ?
	BEQ	12$		;IF NOT DON'T CHECK FURTHER
	CMP	#177,R1		;SENDING A FILLER ?
	BEQ	12$		;DON'T CHANGE GAME FOR A FILLER
	CMP	#12,R1		;IS THIS A LINE FEED ?
	BNE	10$		;IF NOT WE ARE DONE FOR NOW
	MOV	#177,R1		;JUST MAKE THIS INTO A FILLER
	BR	12$
10$:	BIC	#BCDOCR,R3	;CLEAR THE FLAG

12$:	MOV	R3,R2		;MAKE A COPY OF THE STATUS WORD
	BIC	#^CBCDCOD,R2	;LEAVE CODE ONLY
	MOV	R2,R0		;IN CASE IS NOT TIDY
	ADD	R1,R2
	MOVB	BCDXOU(R2),R1	;TRANSLATE CHARACTER
	BGE	40$		;BRANCH IF THIS CHAR ISN'T AFFECTED BY TIDY
	BIT	#BCDTDY!BCDAPL,R3	;CHECK FOR APL MODE OR TIDY
	BNE	40$		;IN WHICH CASE NOTHING SPECIAL
	BIC	#^C177,R2	;STRIP EXTRA BITS
	MOVB	R2,ASAPTB(L)	;SAVE CHAR IN CASE WE DON'T TYPE IMMEDIATELY
	BIT	#BCDCON,R3	;HAVE WE ALREADY TYPED THE TICK ?
	BNE	30$		;IF SO DONE FOR NOW
	MOVB	ARROW+BCDXOU(R0),R1	;IN CASE WE WANTED A ^
	TSTB	TDYTAB(R2)	;DO WE WANT A ' OR A ^
	BGE	23$
	MOVB	QUOTE+BCDXOU(R0),R1	;WANTS A ' INSTEAD OF AN ARROW
23$:	BIT	#100,R1		;TEST FOR UPPER OR LOWER SHIFT CHAR
	BNE	26$		;BRANCH IF IT IS UPPER SHIFT
	BIT	#BCDUPS,R3	;AND ARE WE ALREADY IN LOWER SHIFT ?
	BEQ	27$		;BRANCH IF SO
	BR	40$
26$:	BIT	#BCDUPS,R3	;AND ARE WE ALREADY IN UPPER SHIFT ?
	BEQ	40$		;BRANCH TO SET UPPER SHIFT
27$:	BIS	#BCDCON,R3	;SET HAVE SENT ' OR ^ FLAG
	BR	47$		;JUST TYPE IT

30$:	MOVB	TDYTAB(R2),R2	;CONVERT THE CHAR
	BIC	#^C177,R2	;STRIP EXTRA BITS
	ADD	R0,R2		;ADD IN CHARACTER SET
	MOVB	BCDXOU(R2),R1	;GET WHAT TO TYPE INSTEAD
	BIT	#100,R1		;TEST FOR UPPER OR LOWER SHIFT CHAR
	BNE	33$		;BRANCH FOR UPPER SHIFT CHAR
	BIT	#BCDUPS,R3	;TEST FOR WE ARE IN LOWER SHIFT
	BNE	40$		;BRANCH TO CHANGE SHIFT
	BR	34$
33$:	BIT	#BCDUPS,R3	;TEST FOR WE ARE IN UPPER/LOWER SHIFT
	BEQ	40$		;BRANCH TO SET SHIFT RIGHT
34$:	CLRB	ASAPTB(L)	;CLEAR SO WE DON'T TYPE AGAIN
	BIC	#BCDCON,R3	;CLEAR FLAG

40$:	CMP	#BCDSPC,R1	;TEST FOR CHAR IS A SPACE
	BEQ	49$		;IF SO DON'T CHECK SHIFT
	BIT	#100,R1		;TEST FOR UPPER SHIFT CHAR
	BNE	45$		;BRANCH IF NEED SHIFT
	BIT	#BCDUPS,R3	;ARE WE ALREADY IN DOWN SHIFT ?
	BEQ	47$		;BRANCH IF SO
	BIC	#BCDUPS,R3
	MOV	#BCDLCS,R1	;DOWN SHIFT CHAR
	BR	46$
45$:	BIT	#BCDUPS,R3	;ARE WE ALREADY IN UP SHFIT ?
	BNE	47$		;BRANCH IF SO
	BIS	#BCDUPS,R3	;SET UP SHIFT
	MOV	#BCDUCS,R1
46$:	TSTB	ASAPTB(L)	;ALREADY HOLDING A CHAR ?
	BNE	47$
	MOVB	R2,ASAPTB(L)	;SAVE CHAR TO TYPE LATER
47$:	CMPB	#057,R1		;IS THIS A CONTROL I?
	BNE	49$
	MOVB	#177,ASAPTB(L)	;ALWAYS SEND ONE FILLER AFTER IT
49$:	MOV	R3,BCDTAB(L)

50$:
.ENDC

TYPE80:	MOV	DH.TAB(L),R0	;GET DH11 BLOCK ADR
	MOV	@R0,R3		;GET DH11 HDW ADR
	BEQ	TYPE95		;BRANCH IF NO SUCH DH11 ON THIS DC76
	TSTB	CARTAB(L)	;CHECK FOR AUTBIT
	BMI	TYPE95		;IF LOOKING FLUSH EVERYTHING
	MOVB	R1,CHRTAB(L)	;SAVE CHAR IN BUFFER
	BIC	#17,@R3
	BISB	LN.TAB(L),@R3	;SELECT LINE
	BIC	TTOBIT(L),14(R3)	;CLEAR BREAK
	MOV	#CHRTAB,R1
	ADD	L,R1
	MOV	R1,6(R3)
	MOV	#-1,10(R3)	;SET MSG LENGTH FOR DH11
	BIS	TTOBIT(L),12(R3)
	BIS	TTOBIT(L),B.BAR(R0)

TYPE95:	RTS	PC
.IF NE FT2741
CLK.06:	MOV	@DH.TAB(L),R3	;GET DH11 HDW ADR
	BIC	TTOBIT(L),14(R3)	;CLEAR BREAK
	MOV	#<2*400>+5,CLKTAB(L)	;TIME FOR 2741 TO SETTLE
	RTS	PC
CLK.02:	BIC	#BCDXRB!BCDRCR!BCDPRL!BCDUPS,BCDTAB(L)	;CLEAR PRINTER LOCKED, SNDING REV BREAK
	BIS	#BCDKBL,BCDTAB(L)	;SET KEYBOARD LOCKED
	MOV	#BCDEOA,R1
	BR	TYPE80
.ENDC
;HERE TO PERFORM A MODEM CONTROL FUNCTION
SETDSC:	JSR	PC,READW	;GET COMMAND WORD
	CMP	L,TCONLN	;CHECK FOR LINE NUMBER REASONABLE
	BGE	DSCEXT
	ASL	L
	SWAB	R1		;SWAP HALVES
	BIC	#^C377,R1	;ONLY 8 BITS
	CMP	#MDMINI,R1
	BPL	10$
	TRAP
10$:	JMP	@DSCDSP(R1)

DSCDSP:	LOOP		;(0) IGNORE
	32$		;(2) TURN MODEM OFF
	30$		;(4) DRIVE MODEM ON
	40$		;(6) REPORT MODEM STATUS
	LOOP		;(10) COMPUTER RESTARTED

;HERE TO DRIVE MODEM OFF
32$:	JSR	PC,36$		;SETUP DM11BB TO POINT TO LINE
	MOV	#1,2(R3)	;CLEAR THE DECK
	BR	DSCEXT

;HERE TO DRIVE MODEM ON
30$:	JSR	PC,36$		;SET UP DM11BB TO POINT TO LINE
	MOV	#3,2(R3)	;ENABLE EVERYTHING
	BR	DSCEXT
36$:	MOV	DH.TAB(L),R0	;GET DH11 BLOCK ADR
	MOV	BLK.DM(R0),R3	;GET DM11BB HDW ADR
	BEQ	39$
	BIC	#17,@R3		;CLEAR LINE SELECT
	MOVB	LN.TAB(L),R1	;GET 4BIT LINE NUMBER
	BIS	R1,@R3		;SET LINE #
	MOV	@R3,R1		;GET LINE # WHICH WAS SELECTED
	MOV	R1,R2
	BIC	#^C17,R1	;STRIP EXTRA BITS
	CMPB	R1,LN.TAB(L)
	BEQ	38$
	TRAP
38$:	RTS	PC
39$:	MOV	(P)+,R0		;POP OLD PC OFF STACK
	BR	DSCEXT

;HERE TO REPORT A LINES STATUS
40$:	MOV	L,R0		;GET LINE NUMBER TO TELL 10
	ASR	R0
	BIS	#FESDSC,R0	;FLAG THIS IS MODEM CONTROL
	MOV	#MDMOFF,R1	;CODE FOR OFF
	BITB	#CARBIT,CARTAB(L)
	BEQ	43$
	MOV	#MDMON,R1	;CODE FOR ON
43$:	JSR	PC,QUE2WD	;TELL THE 10
DSCEXT:	JMP	LOOP
;HERE TO SET A LINE PARAMETER CONTROL
SETLPC:	JSR	PC,READW	;GET NEXT WORD FROM QUEUE
	MOV	R1,R2		;COPY ARGUMENT
	SWAB	R2		;SWAP HALVES
	BIC	#<^C376>,R2
	CMP	#LPCMAX,R2	;TEST TO BE SURE IS IN RANGE
	BGE	10$
	TRAP
10$:	LEVEL	7
	CMP	L,TCONLN	;COMPARE LINE NUMBER TO CTY
	BGE	SETEXT		;BRANCH FOR CTY OR NONEX
	ASL	L		;MULTIPLY LINE NUMBER BY 2
	MOV	DH.TAB(L),R0	;GET DH11 BLOCK ADR
	MOV	@R0,R3		;GET DH11 HDW ADR
	BEQ	SETEXT		;BRANCH IF NO SUCH DH11
	BIC	#17,@R3		;CLEAR DH11 LINE SELECT
	BISB	LN.TAB(L),@R3	;SELECT LINE
	JMP	@LPCTAB(R2)
LPCTAB:	REJECT		;(0) ILLEGAL
	SETSPD		;(2) SET SPEED
	SETABR		;(4) SET LOOK FOR BAUD RATE
.IF NE FT2741
	SETELE		;(6) SET TYPE ELEMENT
	SETAPL		;(10) SET/CLEAR APL MODE
	SETRVB		;(12) SET/CLEAR REVERSE BREAK
	SETUKB		;(14) UNLOCK KEYBOARD
	SETTDY		;(16) SET TIDY BIT
.ENDC
.IF EQ FT2741
	SETEXT		;(6) SET TYPE ELEMENT
	SETEXT		;(10) SET/CLEAR APL MODE
	SETEXT		;(12) SET/CLEAR REVERSE BREAK
	SETEXT		;(14) UNLOCK KEYBOARD
	SETEXT		;(16) SET TIDY BIT
.ENDC

;HERE TO SET LOOK FOR BAUD RATE MODE
SETABR:	BISB	#AUTBIT,CARTAB(L)	;SET LOOK FOR CR BIT
	MOV	#B.300,4(R3)	;SET SPEED TO SCAN AT
SETEXT:	LEVEL	0
	JMP	LOOP

.IF NE FT2741
;HERE TO CHANGE 2741 TYPING ELEMENT
SETELE:	BIC	#BCDCOD,BCDTAB(L)	;CLEAR CODE IN 2741 STATUS WORD
	BEQ	SETEXT		;BRANCH IF HE WAS KIDDING
	SWAB	R1		;BUT CODE IN LH
	BIC	#^CBCDCOD,R1	;CLEAR EXTRA BITS
	BIS	R1,BCDTAB(L)
	BR	SETEXT


;HERE TO SET/CLEAR THE APL MODE BIT
SETAPL:	BIC	#BCDAPL,BCDTAB(L)	;CLEAR APL-MODE BIT
	BEQ	SETEXT		;BRANCH IF NOT 2741 LINE
	BIT	#1,R1		;TEST FOR SETTING OR CLEARING
	BEQ	SETEXT		;BRANCH IF CLEARING
	BIS	#BCDAPL,BCDTAB(L)	;SET APL-MODE BIT
	BR	SETEXT

;HERE TO SET/CLEAR THE HAS REVERSE BREAK BIT
SETRVB:	BIC	#BCDHDB,BCDTAB(L)	;CLEAR HAS-REVERSE-BREAK BIT
	BEQ	SETEXT		;BRANCH IF NOT 2741 LINE
	BIT	#1,R1		;TEST FOR SETTING OR CLEARING
	BEQ	SETEXT		;BRANCH IF CLEARING
	BIS	#BCDHDB,BCDTAB(L)	;SET HAS-REVERSE-BREAK BIT
	BR	SETEXT

;HERE TO UNLOCK THE KEYBOARD
SETUKB:	MOV	BCDTAB(L),R3	;GET 2741 STATUS
	BEQ	SETEXT		;IF NOT 2741 WE ARE DONE
	BIT	#BCDKBL,R3	;TEST FOR KEYBOARD LOCKED
	BEQ	SETEXT
;	BIS	#BCDMSK,BCDTAB(L)	;IN CASE CAN'T RELEASE KEYBOARD NOW
	BIT	#BCDRCR!BCDPRL!BCDXRB,R3	;CHECK PRINTER LOCKED OR XMT REV BREAK
	BNE	SETEXT		;IN EITHER CASE DON'T UNLOCK !
	BIS	#BCDPRL!BCDCDB,R3	;PRINTER LOCKED & WE GAVE UP VOLUNTARILY
	MOV	R3,BCDTAB(L)	;SAVE NEW STATUS
	JSR	PC,CLK.04	;SEND EOT TO 2741
	BR	SETEXT

;HERE TO SET/CLEAR THE "TTY TIDY" BIT
SETTDY:	BIC	#BCDTDY,BCDTAB(L)	;CLEAR TIDY BIT IN 2741 STATUS
	BEQ	SETEXT		;IF NOT 2741 DONE
	BIT	#1,R1		;SETTING MODE ?
	BEQ	SETEXT		;IF NOT SETTING WE ARE DONE
	BIS	#BCDTDY,BCDTAB(L)
	BR	SETEXT
	JMP	SETEXT
.ENDC

;HERE TO SET LINE SPEED
SETSPD:	MOVB	R1,SPDTAB(L)	;REMEMBER SPEED IN CASE 10 RESTARTS
	BICB	#AUTBIT,CARTAB(L)	;NO LONGER LOOKING FOR A CR
	JSR	PC,MAKSPD	;SET UP HDW
	BR	SETEXT

MAKSPD:	MOVB	SPDTAB(L),R1	;GET SPEED SPEC
.IF NE FT2741
	CMPB	#104,R1		;SETTING 2741 ?
	BNE	10$		;BRANCH IF NOT
	TST	BCDTAB(L)	;CHECK CURRENT 2741 BITS
	BNE	5$
	MOV	#BCDVRG,BCDTAB(L)	;SET VIRGIN 2741 BITS
5$:	MOV	#B.134,4(R3)	;SET BITS FOR 2741
	RTS	PC
10$:
.ENDC

	CLR	BCDTAB(L)	;CLEAR 2741 BITS
	SWAB	R1
	ASR	R1
	ASR	R1
	BIC	#^C037700,R1	;CLEAR EXTRA BITS
	BIS	#000007,R1	;STOP BITS & PARITY JAZZ
	MOV	R1,4(R3)
	RTS	PC
.SBTTL	SERVICE FOR THE DL10

;HERE ON A INTERRUPT FROM THE DL10
DL1INT:	MOV	DL.STS,DL1STS	;MAKE COPY OF DL10 STATUS FOR DUMP
	BIT	#004000,DL1STS	;CHECK FOR NXM
	BEQ	10$		;BRANCH IF NOT NXM
	JSR	R0,CRLTYP
	.ASCII	\DL10 nxm\
	.BYTE	377,0
	.EVEN
10$:	BIT	#001000,DL1STS	;CHECK FOR PARITY ERROR
	BEQ	20$		;BRANCH IF NOT PARITY
	JSR	R0,CRLTYP
	.ASCII	\DL10 parity err\
	.BYTE	377,0
	.EVEN
20$:;	BIT	#000200,DL1STS	;CHECK FOR WCOV
	TRAP			;MUST BE AN ERROR

DL1STS:	.BLKW	1		;SAVE DL10 STATUS HERE ON AN INTERRUPT
.SBTTL	CLOCK INTERRUPT ROUTINE

SECFLG:	0		;SET NONZERO ONCE A SECOND
JIFFLG:	0		;SET NONZERO WHEN CLOCK TICKS
DSCLCK:	.BLKW	1
UPTIME:	.BLKW	2	;TICKED EACH TIME CLOCK GOES OFF

CLKINT:	INCB	JIFFLG		;SET JIFFY FLAG
	BNE	10$		; BRANCH IF FLAG IS HEALTHY
	  TRAP			;NON-INTERRUPT LEVEL CODE NOT WORKING
10$:	INC	DSCLCK		;DATASET CONTROL CLOK
	COUNT	UPTIME		;32BIT COUNTER
	BIT	#77,UPTIME+2
	BNE	20$
	INC	SECFLG		;SET SECOND FLAG
20$:	RTI			;DISMISS INTERRUPT

;HERE ONCE PER CLOCK TICK
CLKSCN:	CLR	JIFFLG		;REMEMBER WE SAW FLAG
	JMPDWN	10$		;BRANCH IF PORT IS NOT ENABLED
	MOV	DL.UPT,R0	;GET JIFFY COUNTER FROM THE 10
	TST	UPFLAG		;CHECK TO SEE IF WE HAVE BEEN RUNNING
;	BGE	5$		;BRANCH IF WE HAVE BEEN ALL ALONG
;	TRAP
5$:	BEQ	7$		;BRANCH IF 10 HAS BEEN STOPPED
	CMP	R0,L.UPT	;COMPARE TO JIFFY COUNTER LAST TICK
	BEQ	6$
	MOV	#10,UPFLAG	;10 IS ALIVE AND WELL
6$:	MOV	R0,L.UPT	;REMEMBER NEW VALUE FOR JIFFY COUNTER
	DEC	UPFLAG
	BNE	10$
	MOV	#BRKMSG-1,R0	;"%%DECSYSTEM-10 NOT RUNNING"
	JSR	PC,SNDALL	;TELL THE WORLD
	MOV	T10TKR,T10PTR	;EMPTY XMT INT QUEUE
	BR	10$

7$:	CMP	R0,L.UPT
	BEQ	10$		;BRANCH IF 10 STILL NOT GOING
	MOV	#CONMSG-1,R0	;"DECSYSTEM10 BEING CONTINUED"
	JSR	PC,SNDALL
	MOV	#10,UPFLAG	;RESET TIMER ON 10
10$:	MOV	TCONLN,L	;SCAN LINES FOR FILL
	ASL	L
20$:	TSTB	CLKTAB(L)	;CHECK TO SEE IF WE ARE TIMING LINE
	BEQ	25$
	DECB	CLKTAB(L)	;COUNT DOWN CLOCK
	BNE	25$
	MOVB	CLKTAB+1(L),R0	;GET CODE
	LEVEL	7
	JSR	PC,@CLKDSP(R0)	;DISPATCH TO CORRECT ROUTINE
	LEVEL	0
25$:	SUB	#2,L		;ADVANCE TO NEXT LINE
	BGE	20$		;IF MORE LINES LOOP BACK

90$:	TST	SECFLG		;TEST SECOND FLAG
	BNE	SECSCN		;IF IT WENT OFF DO ONCE A SEC STUFF
	JMP	LOOP

CLKDSP:	CLK.00
	CLK.02
	CLK.04		;SEND DWN SHIFT BEFORE EOT TO 2741
	CLK.06		;END REVERSE BREAK
	CLK.10		;SEND EOT TO TERMINAL
CLK.00:	TRAP

;HERE ONCE A SECOND
SECSCN:	CLR	SECFLG
.IF NE FTDEBUG
	MOV	IDLCNT,IDLSEC	;SAVE IDLE COUNTER FOR LAST SECOND
	CLR	IDLCNT		;CLEAR IDLE COUNTER
.ENDC
	JUMPUP	10$		;BRANCH IF PORT IS ENABLED

	RING			;TRY TO INTERRUPT THE 10
	BR	20$
10$:	JMPDWN	20$
	CLR	DL.OK		;REASSURE 10
20$:	JMP	LOOP
;HERE WHEN 2741 LINE TYPES A BREAK
RCVBRK:	BIT	#BCDAPL,BCDTAB(L)	;CHECK FOR LINE IS APL
	BEQ	10$		;BRANCH IF NOT APL
	MOV	#3,R1
	JMP	REC.60
10$:	TSTB	CLKTAB(L)	;DO WE ALREADY HAVE A REQUEST IN THE QUEUE ?
	BNE	99$		;IF SO IGNORE FOR NOW
	MOV	#<4*400>+^D16,CLKTAB(L)	;WAKE UP AGAIN IN A LITTLE WHILE
	BIS	#BCDPRL,BCDTAB(L)	;SET PRINTER LOCKED
	BIC	#BCDCDB,BCDTAB(L)	;SET USER INSISTED
99$:	JMP	DISMISS
CLK.04:	BIT	#BCDUPS,BCDTAB(L)	;IS TERMINAL IN UPPER SHIFT ?
	BEQ	CLK.10		;IF NOT PROCEED
	BIC	#BCDUPS,BCDTAB(L)	;CLEAR UPPER SHIFT BIT
	MOV	#<10*400>+6,CLKTAB(L)	;ENTER REQUEST IN CLOCK QUEUE
	MOV	#BCDLCS,R1	;GET A DOWN SHIFT CHAR
	JMP	TYPE80		;SEND IT
CLK.10:	MOV	#BCDEOT,R1	;SEND HIM AN EOT
	JMP	TYPE80		;SEND IT WITHOUT TRANSLATION
.SBTTL	DH11 RECEIVE INTERRUPT SERVICE

.MACRO	X	A
DHI'A'IN:	MOV	R0,-(P)
	MOV	#DH'A'BLK,R0
	BR	DHIINT
.ENDM	X

	Z=0
.REPT	DH.MAX
	X	\Z
	Z=Z+1
.ENDR

DHIINT:	MOV	R1,-(P)	;KEEP CHARACTER IN R1
	MOV	R2,-(P)
	MOV	R3,-(P)
	MOV	L,-(P)
	MOV	@R0,R3		;GET HARDWARE ADR FOR DH11
	MOV	2(R3),R1	;GET NEXT CHAR FROM SILO
	BPL	99$		;BRANCH IF NOT VALID
	MOV	R1,L		;COPY WORD
	SWAB	L		;SWAP HALVES
	BIC	#^C17,L		;LEAVE ONLY LINE#-GROUP
	ADD	B.LNUM(R0),L
	ASL	L
	BIT	#DHROVR,R1	;CHECK FOR OVERRUN
	BNE	99$		;AND FLUSH SUCH CHARS
	MOVB	CARTAB(L),R2	;GET CARRIER STATUS BITS
	BMI	10$		;BRANCH IF LOOKING FOR A CARRIAGE RETURN
	BIT	#DHRFER,R1	;CHECK FOR A FRAMMING ERROR
	BEQ	RECINT		;BRANCH IF NORMAL CHARACTER

;HERE TO HANDLE A FRAMING ERROR - PROBABLY A BREAK
.IF NE FT2741
	TST	BCDTAB(L)	;CHECK TO SEE IF LINE IS 2741
	BEQ	9$		;IF NOT RESET AUTO BAUD
	TSTB	R1		;IS THIS A BREAK?
	BEQ	RCVBRK		;YES, SPECIAL 2741 HANDLING
.ENDC
9$:	BITB	#ALNBIT,R2	;IS THIS AN AUTO BAUD LINE ?
	BEQ	99$		;IF NOT JUST FLUSH
	BISB	#AUTBIT,CARTAB(L)	;SET LOOK FOR SPEED AGAIN
	BIC	#17,@R3		;CLEAR LINE SELECT
	BISB	LN.TAB(L),@R3	;SET LINE SELECT
	MOV	#B.300,4(R3)	;SET LINEPARAMETER REGISTER
	BR	99$

10$:	CMPB	#377,R1		;CHECK FOR BREAK
	BEQ	99$		;AND JUST FLUSH IF IT WAS
	MOV	#215,-(P)	;SAVE A CR IN CASE THAT WAS TYPED
	CMPB	#15,R1		;WAS CHAR A CR ?
	BEQ	16$		;BRANCH IF SO
	CMPB	#215,R1		;MAYBE WITH PARITY ?
	BEQ	16$
	CMPB	#346,R1		;MAYBE THIS IS A 150BAUD LINE ?
	BEQ	15$
	CMPB	#214,R1		;MAYBE THIS WAS A KSR 33 ?
	BEQ	13$
	CMPB	#234,R1	
	BEQ	13$
	MOV	#003,(P)	;CHECK FOR CHAR WAS A ^C
	CMPB	#3,R1
	BEQ	16$
	CMPB	#203,R1
	BEQ	16$
.IF NE 0
	CMPB	#036,R1
	BEQ	15$
.ENDC
	CMPB	#174,R1
	BEQ	13$
.IF NE FT2741
	CMPB	#306,R1
	BEQ	14$		;BRANCH IF 134.5
	CMPB	#316,R1		;CENTER OF THIS BIT IS ON THE LINE
	BEQ	14$
	CMPB	#314,R1		;OR MAYBE WE SLEWED
	BEQ	14$
.ENDC
	TST	(P)+		;FLUSH STACK
99$:	JMP	DISMIS		;DISMISS INTERRUPT
;HERE BECAUSE LINE IS 110 BAUD
13$:	MOV	#B.110,R1	;GET BITS FOR 110 BAUD
	BR	17$		;SET BAUD RATE AND CONTINUE

.IF NE FT2741
;HERE BECAUSE LINE IS 134 BAUD
14$:	MOV	#BCDVRG,BCDTAB(L)	;SET IS 2741
	MOV	#B.134,R1	;GET BITS FOR 2741
	MOV	#055,(P)	;REPACE CR ON STACK WITH A BCD CR
	BR	18$
.ENDC

;HERE BECAUSE LINE IS 150 BAUD
15$:	MOV	#B.150,R1	;GET BITS FOR 150 BAUD
	BR	17$

;HERE BECAUSE LINE IS 300 BAUD
16$:	MOV	#B.300,R1	;GET BITS FOR 300 BAUD

17$:
.IF NE FT2741
	CLR	BCDTAB(L)	;NO LONGER 2741(IF IT EVERY WAS
.ENDC
18$:	BICB	#AUTBIT,CARTAB(L)
	BIC	#17,@R3		;CLEAR LINE SELECT
	BISB	LN.TAB(L),@R3	;SELECT OUR BOY
	MOV	R1,4(R3)	;SET LINE PARAMETER REGISTER
	ASL	R1
	ASL	R1
	SWAB	R1
	BIC	#<^C377>,R1
	MOVB	R1,SPDTAB(L)	;REMEMBER SPEED FOR LATER
	TST	UPFLAG		;CHECK TO SEE IF 10 IS ALIVE AND WELL
	BLE	DHI.20		;IF NOT CAN'T TELL HIM SPEED
	BIS	#LPCSPD,R1	;CODE TO TELL 10 WHAT WE HAVE
	MOV	L,R0		;GET LINE NUMBER TO TELL 10
	ASR	R0
	BIS	#FESLPC,R0	;LINE PARAMETER CONTROL
	JSR	PC,QUE2WD	;SEND SPEED TO 10
	MOV	L,R0		;GET LINE # AGAIN
	ASR	R0
	BIS	#FESDSC,R0	;BUILDING A DATASET MESSAGE
	MOV	#MDMON,R1
	JSR	PC,QUE2WD
DHI.20:	MOV	(P)+,R1		;GET CHAR WHICH WAS TYPED
RECINT:
.IF NE FT2741
	MOV	BCDTAB(L),R3	;GET 2741 STATUS BITS
	BEQ	REC.60		;BRANCH IF NOT 2741
	BIT	#BCDRCR,R3	;TEST FOR LAST CHAR WAS A CR
	BNE	RCVEOT		;IF SO TREAT THIS CHAR AS AN EOT
	BIC	#^C77,R1	;CLEAR PARITY BIT
	CMP	#<BCDEOT&77>,R1
	BEQ	RCVEOT
	BIT	#BCDKBL,R3	;IS THE KEYBOARD LOCKED ?
	BNE	RCVEOA		;IS SO THIS MUST BE AN EOA
	CMP	#<BCDUCS&77>,R1	;IS THIS UP SHIFT ?
	BEQ	BCDRUS		;BRANCH IF WE RECEIVED AN UPSHIFT
	CMP	#<BCDLCS&77>,R1	;IS THIS A DOWN SHIFT ?
	BEQ	BCDRDS		;BRANCH IF WE RECEIVED A DOWN SHIFT
	MOV	R3,R2		;MAKE ANOTHER COPY OF BCDTAB
	BIC	#^C<BCDCOD+BCDUPS>,R2	;LEAVE ONLY FIELD FOR CODE & SHIFT
	ADD	R2,R1		;COMBINE CODSET WITH CHARACTER
	MOVB	BCDXIN(R1),R1	;TRANSLATE CHARACTER
	BEQ	DISMISS		;IF NULL THROW CHAR AWAY
	BIC	#BCDRCR,R3	;CLEAR CARRIAGE RETURN BIT
	CMP	#15,R1		;IS THIS A CARRIAGE RETURN ?
	BNE	34$
	BIS	#BCDRCR!BCDKBL,R3
34$:	BIT	#BCDAPL,R3	;TEST FOR APL MODE
	BNE	REC.50		;BRANCH IF NO TRANSLATION
	BIT	#BCDCON,R3	;IS THIS THE CHARACTER FOLLOWING AN ARROR ?
	BEQ	40$
	BIC	#BCDCON,R3	;CLEAR FOLLOWING AN ARROW BIT
	CMP	R1,#10		;WAS CHAR A BACKSPACE ?
	BEQ	BCD.99		;IF IT WAS JUST STORE STATUS
	CMP	R1,#40		;TEST TO SEE IF CHAR MUST BE TRANSLATED
	BMI	REC.50		;BRANCH IF NO TRANSLATION
	MOVB	ARRTAB-40(R1),R1	;TRANSLATE AGAIN
37$:
	BR	REC.50
40$:	CMP	R1,#ARROW	;TEST FOR THIS CHAR IS AN ARROW
	BNE	REC.50
	BIS	#BCDCON,BCDTAB(L)	;SET ARROW MODE
	BR	DISMISS		;AND DONE
REC.50:	MOV	R3,BCDTAB(L)	;RESTORE 2741 STATUS
REC.60:
.ENDC

;CHECK TO SEE IF 10 IS HEALTHY
	TST	UPFLAG		;TEST UPNESS OF DECSYSTEM-10
	BMI	SAYDWN		;IF SYSTEM DOWN TELL USER
	BEQ	SAYBRK		;IF SYSTEM IN EDDT SAY SO

	MOV	L,R0		;GET LINE NUMBER
	ASR	R0
	BIS	#FESRDT,R0	;FLAG FOR RECEIVED DATA
	BIC	#^C377,R1	;8BITS ONLY
	JSR	PC,QUE2WD	;PUT CHAR IN TO-10 QUEUE
DISMIS:	MOV	(P)+,L
	MOV	(P)+,R3
	MOV	(P)+,R2
	MOV	(P)+,R1
	MOV	(P)+,R0
	RTI

SAYDWN:	MOV	#RELMSG,STRTAB(L)	;TELL USER SYSTEM BEING RELOADED
	BR	SAY.XX
SAYBRK:	MOV	#BRKMSG,STRTAB(L)
SAY.XX:	BIT	TTOBIT(L),B.BAR(R0)	;TEST FOR LINE ACTIVE
	BNE	DISMISS		;IF ALREADY ACTIVE DONE
.IF NE FT2741
	BIT	#BCDPRL,BCDTAB(L)	;TEST TO SEE IF PRINTER IS LOCKED
	BNE	DISMISS
.ENDC
	JSR	PC,TYPE30		;TYPE MESSAGE
	BR	DISMISS
.IF NE FT2741
;HERE FROM RECINT WHEN RECEIVE AN EOA
RCVEOA:	BIT	#BCDPRL,R3	;IS THE PRINTER ALREADY LOCKED ?
	BEQ	DISMISS		;IF NOT THIS MUST BE JUNK
	CMP	#BCDEOA,R1	;IS CHARACTER AN EOA ?
	BNE	DISMISS		;IF NOT IGNORE
	BIC	#BCDKBL!BCDUPS,R3	;KEYBOARD UNLOCKED & LOWER SHIFT
	BR	BCD.99		;RESTORE STATUS THEN DISMISS

;HERE WHEN RECEIVE AN EOT FROM A 2741 LINE
RCVEOT:	BIS	#BCDKBL!BCDPRL,R3	;SET ALL LOCKED
	BIT	#BCDXRB,R3	;TEST FOR WE WERE SENDING REVERSE BREAK
	BNE	BCD.99		;IF WE ARE IGNORE THIS EOT
	BIC	#BCDCON!BCDUPS!BCDRCR,R3	;CLEAR UPPERSHIFT & PRINTER LOCKED
	MOV	#<2*400+^D10>,CLKTAB(L)	;GIVE IT A TENTH OF A SECOND TO SETTLE
	BIT	#BCDRCR,BCDTAB(L)	;TEST AGAINST CORE COPY CUZ CLEARED R3
	BNE	BCD.99		;IF FOLLOWED CR WE ARE DONE
	BIT	#BCDAPL,R3	;IS LINE IN APL-MODE ?
	BEQ	BCD.99		;IF NOT WE ARE DONE
	MOV	#BELL,R1	;MAKE A BELL
	BR	REC.50		;GIVE THAT GUY A BELL

BCDRDS:	BIC	#BCDUPS,R3
	BR	BCD.99
BCDRUS:	BIS	#BCDUPS,R3	;SET UPPER SHIFT
BCD.99:	MOV	R3,BCDTAB(L)	;RESTORE STATUS TO 2741 TABLE
	BR	DISMISS

.ENDC
.SBTTL	DH11 TRANSMIT INTERRUPT SERVICE

.MACRO	X	A
DHO'A'IN:	MOV	R0,-(P)
	MOV	#DH'A'BLK,R0	;ADR OF DH11 BLOCK
	BR	DHOINT
.ENDM	X

	Z=0
.REPT	DH.MAX
	X	\Z
	Z=Z+1
.ENDR

DHOINT:	MOV	R1,-(P)		;SAVE AC'S ON PDL
	MOV	R2,-(P)
	MOV	R3,-(P)
	MOV	L,-(P)
	MOV	@(R0),R1	;GET STATUS WORD
	BMI	10$		;BE SURE INT WAS LEGIT
	TRAP

10$:	BIC	#100000,@(R0)	;CLEAR FLAG
	MOV	#17,L		;NEED TO CHECK ALL LINES IN DH11
	ADD	B.LNUM(R0),L	;MAKE ABSOLUTE LINE NUMBER
	MOV	@R0,R3		;GET DH11 HDW ADR
	MOV	B.BAR(R0),R2	;GET SOFTWARE STATUS REGISTER
	BIC	12(R3),R2	;CLEAR BITS FOR LINES STILL ACTIVE
	BEQ	99$		;BRANCH IF NO LINES
	BMI	32$		;BRANCH IF LINE HAS INTERRUPTED
30$:	DEC	L		;ON TO THE NEXT LINE
	ASL	R2		;ON TO THE NEXT LINE
31$:	BPL	30$
32$:	MOV	R2,-(P)	;SAVE COMBINED STATUS
	ASL	L
	BIC	TTOBIT(L),B.BAR(R0)	;CLEAR SOFTWARE ACTIVE FLAG
.IF NE FT2741
	BIT	#BCDPRL,BCDTAB(L)	;IS THE PRINTER SUPPOSED TO BE LOCKED ?
	BNE	60$		;IF SO DON'T ENCOURAGE 10
.ENDC
	MOVB	ASAPTB(L),R1	;GET CHAR TO PUT OUT RIGHT AWAY
	BNE	40$		;BRANCH IF HAVE ONE
	TST	STRTAB(L)	;CHECK FOR WE ARE GIVING LINE A STRING
	BNE	50$		;BRANCH IF TRUE
37$:
;.IF NE FT2741
;	BIT	#BCDMSK,BCDTAB(L)	;DID 10 TRY TO GIVE LINE TO USER ?
;	BEQ	38$		;BRANCH IF NO
;	BIC	#BCDMSK!BCDUPS,BCDTAB(L)
;	BIS	#BCDPRL!BCDCDB,BCDTAB(L)
;	MOV	#BCDEOT,R1	;END OF TRANSMISSION CHAR
;	JSR	PC,TYPE80	;SEND IT
;	BR	60$
;38$:
;.ENDC
	MOV	L,R1		;PUT LINE # INTO RIGHT AC
	ASR	R1
	BIS	#FESXDN,R1	;SET FLAG FOR TRANSMIT DONE
	T10ADV	T10PTR		;ADVANCE TO-10-QUEUE PUTTER
	MOV	R1,@T10PTR
60$:	ASR	L
	DEC	L
	MOV	(P)+,R2		;GET STATUS AGAIN
	ASL	R2
	BNE	31$		;BRANCH IF ANY MORE LINES MAY BE READY

99$:	MOV	(P)+,L
	MOV	(P)+,R3
	MOV	(P)+,R2
	MOV	(P)+,R1
	MOV	(P)+,R0	;RESTORE AC'S
	RTI

40$:	CLRB	ASAPTB(L)	;CLEAR ENTRY
42$:	JSR	PC,TYPE30	;TYPE CHAR
	BR	60$
50$:	INC	STRTAB(L)	;ADVANCE TO THE NEXT CHAR
	MOVB	@STRTAB(L),R1	;GET THE NEXT CHAR
	BNE	42$
	CLR	STRTAB(L)	;NO MORE CHARS
	BR	37$
.SBTTL	CTY ROUTINES

;CTY RECEIVE INTERRUPT
CTIINT:	TSTB	CTISTS		;CHECK TO SEE IT IS A DATA INTERRUPT
	BMI	3$		;BRANCH IF IT WAS
	TRAP
3$:	MOV	R0,-(P)	;SAVE R0 ON STACK
	MOV	R1,-(P)	;SAVE R1 & R2 ON STACK
	MOV	R2,-(P)
	MOVB	CTICHR,R1	;GET CHAR WHICH WAS TYPED

.IF NE FT.CTY
	TST	UPFLAG		;CHECK UPNESS OF 10
	BMI	30$		;BRANCH IF 10 IS NOT UP
	BEQ	40$		;BRANCH IF 10 IS AT A BREAKPOINT
	MOV	TCONLN,R0	;GET CTY LINE NUMBER
	BIS	#FESRDT,R0	;FLAG THIS IS RECEIVED DATA
	JSR	PC,QUE2WD	;PUT CHAR INTO THE TO-10 QUEUE
	BR	CTYEXT

30$:	MOV	#RELMSG-1,R0	;RELOAD MESSAGE
	BR	45$
40$:	MOV	#BRKMSG-1,R0	;NOT RUNNING MSG
.ENDC

.IF EQ FT.CTY
	MOV	#CTYMSG-1,R0	;TELL HIM CAN'T USE CTY
.ENDC

45$:	JSR	PC,TYPSTR	;START CTY IF NOT ALREADY TYPING
	BR	CTYEXT
;CTY TRANSMIT INTERRUPT
CTOINT:	TST	CTYPTR		;TEST CTY POINTER
	  BEQ	30$		;BRANCH IF NO DATA
	INC	CTYPTR		;ADVANCE TO NEXT CHAR
	TSTB	@CTYPTR		;IS NEXT CHAR NULL ?
	BEQ	25$		;BRANCH IF NO MORE IN STRING
	MOVB	@CTYPTR,CTOCHR	;TYPE CHAR
	RTI
25$:	CLR	CTYPTR
30$:	CLR	CTOSTS		;CLEAR INTERRUPT ENABLE
	TST	UPFLAG
	BLE	CTYRTI		;IF 10 NOT RUNNING IGNORE THIS
	MOV	R0,-(P)	;SAVE R0 ON THE STACK
	MOV	R1,-(P)	;SAVE R1 & R2 ON STACK
	MOV	R2,-(P)
	MOV	TCONLN,R0	;CTY LINE NUMBER
	BIS	#FESXDN,R0	;TRANSMIT DONE FLAG
	JSR	PC,QUEUEW	;SEND WORD TO 10
CTYEXT:	MOV	(P)+,R2
	MOV	(P)+,R1
	MOV	(P)+,R0
CTYRTI:	RTI

;HERE TO TYPE A STRING ON THE CTY
; CALL	JSR	PC,TYPSTR	;WITH STRING ADR-1 IN R0
TYPSTR:	MOV	R0,CTYPTR
;	JMP	CTOGO		;START TTY IN NECESSARY

;HERE TO START TTY OUTPUT
CTOGO:	MOV	#000100,CTOSTS	;SET INTERRUPT ENABLE
	RTS	PC		;RETURN TO CALLER
.IF NE FTSCHK
;HERE TO TYPE A STRING PRECEEDED BY A CR/LF
; CALL	JSR	R0,CRLTYP
;	.ASCII	\TEXT\
;	.BYTE	0
;	.EVEN
CRLTYP:	JSR	R0,CHKTYP
	.BYTE	377,215,215,12,377,0
	.EVEN

;HERE TO TYPE A MESSAGE WHILE IN THE ONCE ONLY SYSTEM DIAGNOSTIC
; CALL	JSR	R0,CHKTYP	;CALL TYPE ROUTINE
;	.ASCII \TEXT\
;	.BYTE	0
;	.EVEN
CHKTYP:	MOVB	(R0)+,R1	;GET THE NEXT CHAR IN THE STRING
	BEQ	20$		;BRANCH IF THIS IS NULL
	JSR	PC,CHRTYP	;TYPE THE CHAR
	BR	CHKTYP
20$:	INC	R0
	BIC	#1,R0
	RTS	R0

;HERE TO TYPE AN OCTAL NUMBER
; CALL	JSR	PC,OCTYPE	;WITH ARG IN R0
OCTYPE:	MOV	R0,-(P)
	ROR	R0
	ROR	R0
	ROR	R0
	BIC	#160000,R0
	BEQ	20$
	JSR	PC,OCTYPE
20$:	MOV	(P)+,R1
	BIC	#^C7,R1
	BIS	#60,R1
;	FALL INTO CHRTYP

;HERE TO TYPE A SINGLE CHARACTER
; CALL	JSR	PC,CHRTYP	;WITH CHAR IN R1
CHRTYP:	MOVB	R1,CTOCHR	;TYPE CHAR
10$:	TSTB	CTOSTS		;TEST FOR STILL BUSY
	BPL	10$
	RTS	PC

.ENDC
.SBTTL	2741 TRANSLATION TABLES

.IF NE FT2741
;TRANSLATION TABLES
; BIT 200 MEANS SPECIAL ACTION FOR TIDY CASE
; BIT 100 IS UPSHIFT
; BITS 77 ARE CHARACTER
XP	QUOTE,47	;ASCII CODE FOR A SINGLE QUOTE
XP	BELL,7		;ASCII CODE FOR BELL
XP	ARROW,136	;ASCII CODE FOR UP ARROW
XP	BCDEOT,174	;END OF MESSAGE
XP	BCDEOA,64	;END OF ADDRESS(START OF MESSAGE)
XP	BCDUCS,034	;UP SHIFT
XP	BCDLCS,037	;DOWN SHIFT
XP	BCDCRL,155	;CARRIAGE RETURN
XP	BCDSPC,000	;SPACE


;THE FOLLOWING DEFINES SOME BCD CODES
; OTHERS COULD BE SUBSTITUTED
;
; COLUMN 1 IS ASCII EQUIVALENT
; COLUMN 2 IS APL(CORRESPONDENCE) - ELEMENT 987
; COLUMN 3 IS CORRESPONDENCE - ELEMENT 029
; COLUMN 4 IS CALL 360 BASIC - ELEMENT 087
; COLUMN 5 IS EBCD - ELEMENT 963
; COLUMN 6 IS APL(EBCD) - ELEMENT 988
; COLUMN 7 IS BCD - ELEMENT 938
; COLUMN 8 IS RESERVED FOR CUSTOMER DEFINITION

.MACRO	BCDOU
X 000,075,075,075,075,075,075,075	;NULL OR BREAK
X 001,275,275,275,275,275,275,275	; ^A
X 002,264,264,264,264,264,264,264	;EOA START OF TEXT
X 003,275,275,275,275,275,275,275	; ^C
X 004,275,275,275,275,275,275,275	;EOT
X 005,275,275,275,275,275,275,275	; ^E
X 006,275,275,275,275,275,275,275	; ^F
X 007,275,275,275,275,275,275,275	; ^G
X 010,035,035,035,035,035,035,035	; ^H BACKSPACE
X 011,057,057,057,057,057,057,057	; TAB
X 012,056,056,056,056,056,056,056	;LF - INDEX
X 013,275,275,275,275,275,275,275	; ^K
X 014,275,275,275,275,275,275,275	; ^L
X 015,055,055,055,055,055,055,055	;CR
X 016,275,275,275,275,275,275,275	; ^N
X 017,275,275,275,275,275,275,275	; ^O
X 020,275,275,275,275,275,275,275	; ^P
X 021,275,275,275,275,275,275,275	; ^Q
X 022,275,275,275,275,275,275,275	; ^R
X 023,275,275,275,275,275,275,275	; ^S
X 024,275,275,275,275,275,275,275	; ^T
X 025,275,275,275,275,275,275,275	; ^U
X 026,275,275,275,275,275,275,275	; ^V
X 027,275,275,275,275,275,275,275	; ^W
X 030,275,275,275,275,275,275,275	; ^X
X 031,275,275,275,275,275,275,275	; ^Y
X 032,275,275,275,275,275,275,275	; ^Z
X 033,275,275,275,275,275,275,321	;ALTMODE
X 034,275,275,275,275,275,275,275	; ^\
X 035,275,275,275,275,275,275,275	;^]
X 036,275,275,275,275,275,275,275	; ^^
X 037,275,275,275,275,275,275,275	;^_
X 040,000,000,000,000,000,000,000	;SPACE
X 041,141,001,142,165,111,165,153	;"!" (APL-BALL SHIFT M)
X 042,140,111,120,164,140,170,111	; DOUBLE QUOTE
X 043,130,160,145,064,130,164,011	;"#"
X 044,170,104,152,065,104,065,053	;"$"
X 045,123,110,124,150,103,110,110	;"%"
X 046,101,150,144,003,102,164,023	;"&"
X 047,132,011,140,130,121,002,130	;APOSTROPHE(APL-BALL SHIFT K)
X 050,153,164,053,144,165,150,364	;"("
X 051,111,144,011,124,164,120,344	;")"
X 052,113,170,023,104,171,104,170	;"*" (APL-BALL SHIFT P)
X 053,067,123,067,103,001,003,123	;"+"
X 054,073,073,073,066,066,066,073	;"COMMA"
X 055,167,067,167,001,101,001,067	;"-"
X 056,021,021,021,067,067,067,021	;"."
X 057,007,007,123,042,042,042,007	;"/"
X 060,044,044,044,024,024,024,044	;"0"
X 061,040,040,040,040,040,040,040	;"1"
X 062,020,020,020,020,020,020,020	;"2"
X 063,060,060,060,060,060,060,060	;"3"
X 064,004,004,004,010,010,010,004	;"4"
X 065,010,010,010,050,050,050,010	;"5"
X 066,030,030,030,030,030,030,030	;"6"
X 067,050,050,050,070,070,070,050	;"7"
X 070,070,070,070,004,004,004,070	;"8"
X 071,064,064,064,044,044,044,064	;"9"
X 072,121,153,121,110,167,130,104	;":"
X 073,173,053,173,160,166,160,160	;";"
X 074,160,330,160,120,160,103,320	; LEFT ANGLE BRACKET
X 075,110,023,001,140,150,064,140	;"="
X 076,150,301,150,170,170,140,350	; RIGHT ANGLE BRACKET
X 077,133,107,161,142,105,142,107	;"?"(APL-BALL SHIFT Q)
X 100,171,120,171,002,143,043,001	;"@"(APL-BALL IS ALPHA)
X 101,071,171,071,143,043,143,171	;"A"
X 102,066,166,066,123,023,123,166	;"B"
X 103,072,172,072,163,063,163,172	;"C"
X 104,052,152,052,113,013,113,152	;"D"
X 105,012,112,012,153,053,153,112	;"E"
X 106,063,163,063,133,033,133,163	;"F"
X 107,043,143,043,173,073,173,143	;"G"
X 110,046,146,046,107,007,107,146	;"H"
X 111,031,131,031,147,047,147,131	;"I"
X 112,003,103,003,141,041,141,103	;"J"
X 113,032,132,032,121,021,121,132	;"K"
X 114,006,106,006,161,061,161,106	;"L"
X 115,041,141,041,111,011,111,141	;"M"
X 116,022,122,022,151,051,151,122	;"N"
X 117,005,105,005,131,031,131,105	;"O"
X 120,013,113,013,171,071,171,113	;"P"
X 121,033,133,033,105,005,105,133	;"Q"
X 122,051,151,051,145,045,145,151	;"R"
X 123,045,145,045,122,022,122,145	;"S"
X 124,002,102,002,162,062,162,102	;"T"
X 125,062,162,062,112,012,112,162	;"U"
X 126,061,161,061,152,052,152,161	;"V"
X 127,065,165,065,132,032,132,165	;"W"
X 130,042,142,042,172,072,172,142	;"X"
X 131,047,147,047,106,006,106,147	;"Y"
X 132,024,124,024,146,046,146,124	;"Z"
X 133,053,130,304,344,065,144,330	;"["
X 134,107,207,364,102,142,101,207	;"\"
X 135,011,101,330,324,064,124,301	;"]"
X 136,347,340,313,167,306,302,373	;"^"(APL-BALL SHIFT Y)
X 137,001,167,163,101,002,164,167	;"_"
X 140,225,211,303,330,341,202,301	; ACCENT GRAVE
X 141,301,071,071,043,302,043,071	;LC "A"(APL-BALL IS RT ARROW)
X 142,366,066,066,023,323,023,066	;LC "B"
X 143,372,072,072,063,363,063,072	;LC "C"
X 144,352,052,052,013,313,013,052	;LC "D"
X 145,312,012,012,053,353,053,012	;LC "E"
X 146,363,063,063,033,333,033,063	;LC "F"
X 147,343,043,043,073,373,073,043	;LC "G"
X 150,346,046,046,007,307,007,046	;LC "H"
X 151,331,031,031,047,347,047,031	;LC "I"
X 152,303,003,003,041,341,041,003	;LC "J"
X 153,304,032,032,021,310,021,032	;LC "K"(APL-BALL SHIFT 4)
X 154,306,006,006,061,361,061,006	;LC "L"
X 155,320,041,041,011,320,011,041	;LC "M"(APL-BALL SHIFT 2)
X 156,322,022,022,051,351,051,022	;LC "N"
X 157,305,005,005,031,331,031,005	;LC "O"
X 160,223,013,013,071,203,071,013	;LC "P"(APL-BALL MULTIPLY SIGN
X 161,364,033,033,005,344,005,033	;LC "Q"(APL BALL SHIFT 9)
X 162,351,051,051,045,345,045,051	;LC "R"
X 163,345,045,045,022,322,022,045	;LC "S"
X 164,302,002,002,062,362,062,002	;LC "T"
X 165,362,062,062,012,312,012,062	;LC "U"
X 166,361,061,061,052,352,052,061	;LC "V"
X 167,365,065,065,032,332,032,065	;LC "W"
X 170,342,042,042,072,372,072,042	;LC "X"
X 171,344,047,047,006,324,006,047	;LC "Y"(APL-BALL IS TEEPEE)
X 172,324,024,024,046,346,046,024	;LC "Z"
X 173,275,275,275,275,275,275,275	;173 - LEFT BRACE
X 174,275,275,275,166,275,275,275	;174 - VERTICAL BAR
X 175,275,275,275,275,275,275,275	;175 = ALTMODE - RIGHT BRACE
X 176,275,275,275,275,275,275,275	;176 = ALTMODE - TILDE
X 177,075,075,075,075,075,075,035	;RUBOUT - BECOMES IDLE
.ENDM	BCDOU
;THE FOLLOWING DEFINES THE TRANSLATION OF CHARACTERS ON INPUT FROM A BCD LINE
;
; INDEX INTO TABLE WITH 6BIT CHAR(OR 6BIT CHAR+100 IF UPPER SHIFT)

.MACRO	BCDIN
X 000,040,040,040,040,040,040,040	;SPACE
X 001,137,041,075,055,053,055,100
X 002,124,164,124,100,137,047,164
X 003,112,152,112,046,160,053,152
X 004,064,064,064,070,070,070,064
X 005,117,157,117,161,121,161,157
X 006,114,154,114,171,131,171,154
X 007,057,057,000,150,110,150,057
X 010,065,065,065,064,064,064,065
X 011,135,047,051,155,115,155,043
X 012,105,145,105,165,125,165,145
X 013,120,160,120,144,104,144,160
X 014,000,000,000,000,000,000,000
X 015,000,000,000,000,000,000,000
X 016,000,000,000,000,000,000,000
X 017,000,000,000,000,000,000,000
X 020,062,062,062,062,062,062,062
X 021,056,056,056,153,113,153,056
X 022,116,156,116,163,123,163,156
X 023,160,075,052,142,102,142,046
X 024,132,172,132,060,060,060,172
X 025,000,000,000,000,000,000,000
X 026,000,000,000,000,000,000,000
X 027,000,000,000,000,000,000,000
X 030,066,066,066,066,066,066,066
X 031,111,151,111,157,117,157,151
X 032,113,153,113,167,127,167,153
X 033,121,161,121,146,106,146,161
X 034,000,000,000,000,000,000,000	;UC SHIFT
X 035,010,010,010,010,010,010,010	;BACKSPACE
X 036,000,000,000,000,000,000,000
X 037,000,000,000,000,000,000,000	;LC SHIFT
X 040,061,061,061,061,061,061,061
X 041,115,155,115,152,112,152,155
X 042,130,170,130,057,057,057,170
X 043,107,147,107,141,101,141,147
X 044,060,060,060,071,071,071,060
X 045,123,163,123,162,122,162,163
X 046,110,150,110,172,132,172,150
X 047,131,171,131,151,111,151,171
X 050,067,067,067,065,065,065,067
X 051,122,162,122,156,116,156,162
X 052,104,144,104,166,126,166,144
X 053,133,073,050,145,105,145,044
X 054,000,000,000,000,000,000,000
X 055,015,015,015,015,015,015,015	;CARRIAGE RETURN/LF
X 056,012,012,012,012,012,012,012	;LINE FEED
X 057,011,011,011,011,011,011,011	;TAB
X 060,063,063,063,063,063,063,063
X 061,126,166,126,154,114,154,000
X 062,125,165,125,164,124,164,000
X 063,106,146,106,143,103,143,000
X 064,071,071,071,043,135,075,000
X 065,127,167,127,044,133,044,000
X 066,102,142,102,054,054,054,000
X 067,053,055,053,056,056,056,000
X 070,070,070,070,067,067,067,000
X 071,101,141,101,160,120,160,000
X 072,103,143,103,170,130,170,000
X 073,054,054,054,147,107,147,000
X 074,000,000,000,000,000,000,000	;EOT
X 075,000,000,000,000,000,000,000	;IDLE
X 076,000,000,000,000,000,000,000
X 077,000,000,000,000,000,000,000	;CD
X 100,040,040,040,040,040,040,040	;SPACE
X 101,141,135,000,137,055,134,000
X 102,164,124,000,134,141,136,000
X 103,152,112,140,053,045,074,000
X 104,153,044,133,052,044,052,072
X 105,157,117,000,121,077,121,117
X 106,154,114,000,131,136,131,114
X 107,134,077,000,110,150,110,077
X 110,075,045,075,072,153,000,045
X 111,051,042,000,115,041,115,042
X 112,145,105,000,125,165,125,105
X 113,052,120,136,104,144,104,120
X 114,000,000,000,000,000,000,000
X 115,000,000,000,000,000,000,000
X 116,000,000,000,000,000,000,000
X 117,000,000,000,000,000,000,000
X 120,155,100,042,074,155,051,074
X 121,072,056,072,113,047,113,033
X 122,156,116,000,123,163,123,116
X 123,045,053,057,102,142,102,053
X 124,172,132,045,051,171,000,132
X 125,000,000,000,000,000,000,000
X 126,000,000,000,000,000,000,000
X 127,000,000,000,000,000,000,000
X 130,043,133,135,047,043,072,047
X 131,151,111,000,117,157,117,111
X 132,047,113,000,127,167,127,113
X 133,077,121,000,106,146,106,121
X 134,000,000,000,000,000,000,000
X 135,010,010,010,010,010,010,010
X 136,000,000,000,000,000,000,000
X 137,000,000,000,000,000,000,000
X 140,042,136,047,075,042,076,075
X 141,041,115,000,112,152,112,115
X 142,170,130,041,077,134,077,130
X 143,147,107,000,101,100,101,107
X 144,171,051,046,050,161,133,051
X 145,163,123,043,122,162,122,123
X 146,150,110,000,132,172,132,110
X 147,136,131,000,111,151,111,131
X 150,076,046,076,045,075,050,076
X 151,162,122,000,116,156,116,122
X 152,144,104,044,126,166,126,104
X 153,050,072,000,105,145,105,041
X 154,000,000,000,000,000,000,000
X 155,015,015,015,015,015,015,015	;CARRIAGE RETURN/LF
X 156,012,012,012,012,012,012,012	;LINE FEED
X 157,011,011,011,011,011,011,011	;TAB
X 160,074,043,074,073,074,073,073
X 161,166,126,077,114,154,114,126
X 162,165,125,000,124,164,124,125
X 163,146,106,137,103,143,103,106
X 164,161,050,134,042,051,043,050
X 165,167,127,000,041,050,041,127
X 166,142,102,000,174,073,054,102
X 167,055,137,055,136,072,056,137
X 170,044,052,044,076,076,042,052
X 171,100,101,100,120,052,120,101
X 172,143,103,143,130,170,130,103
X 173,073,054,073,107,147,107,136
X 174,000,000,000,000,000,000,000	;EOT
X 175,000,000,000,000,000,000,000	;IDLE
X 176,000,000,000,000,000,000,000
X 177,000,000,000,000,000,000,000	;CD
.ENDM	BCDIN
BCDVRG=0
.MACRO	XX	A
.IF EQ <A-DEFBCD>
BCDVRG=.-BCDXIN
.ENDC
.ENDM	XX

;CORRESPONDENCE - ELEMENT 029
.MACRO	X	A,B,C,D,E,F,G,H
	.BYTE	C
.ENDM	X
BCDXIN:	XX	<^D029>
	BCDIN
BCDXOU:	BCDOU

;CALL 360 BASIC(CORRESPONDENCE) - ELEMENT 087
.MACRO	X	A,B,C,D,E,F,G,H
	.BYTE	D
.ENDM	X
	XX	<^D087>
	BCDIN
	BCDOU

;BCD - ELEMENT 938
.MACRO	X	A,B,C,D,E,F,G,H
	.BYTE	G
.ENDM	X
	XX	<^D938>
	BCDIN
	BCDOU

;BCD - ELEMENT 963
.MACRO	X	A,B,C,D,E,F,G,H
	.BYTE	E
.ENDM	X
	XX	<^D963>
	BCDIN
	BCDOU

;APL CORRESPONDENCE - ELEMENT 987
.MACRO	X	A,B,C,D,E,F,G,H
	.BYTE	B
.ENDM	X
	XX	<^D987>
	BCDIN
	BCDOU

;APL BCD - ELEMENT 988
.MACRO	X	A,B,C,D,E,F,G,H
	.BYTE	F
.ENDM	X
	XX	<^D988>
	BCDIN
	BCDOU
;TRANSLATION TABLE FOR CHARACTERS FOLLOWING AN UP-ARROW CHARACTER

ARRTAB:	.BYTE	040,174,042,043,STDALT,045,046,140	;40-47
	.BYTE	133,135,052,053,054,176,056,134	;50-57
	.BYTE	060,061,175,173,034,035,036,037	;60-67
	.BYTE	070,071,072,073,133,075,135,077	;70-77
	.BYTE	100,001,002,003,004,005,006,007	;100-107
	.BYTE	010,011,012,013,014,015,016,017	;110-117
	.BYTE	020,021,022,023,024,025,026,027	;120-127
	.BYTE	030,031,032,074,057,076,136,137	;130-137
	.BYTE	140,001,002,003,004,005,006,007	;140-147
	.BYTE	010,011,012,013,014,015,016,017	;150-157
	.BYTE	020,021,022,023,024,025,026,027	;160-167
	.BYTE	030,031,032,173,174,175,176,177	;170-177
;TRANSLATION TABLE FOR CHARACTERS WHEN TIDY IS SET
; INDEX INTO TABLE WITH ORIGINAL ASCII VALUE
; BIT 200 MEANS PRECEDE WITH A ' RATHER THAN A ^
; BITS 177 ARE ASCII CHAR TO TYPE

TDYTAB:	.BYTE	000,101,102,103,104,105,106,107	;000-007
	.BYTE	110,111,112,113,114,115,116,117	;010-017
	.BYTE	120,121,122,123,124,125,126,127	;020-027
	.BYTE	130,131,132,044,064,065,066,067	;030-037
	.BYTE	040,041,042,043,044,045,046,140	;040-047
	.BYTE	050,051,052,053,054,055,056,057	;050-057
	.BYTE	060,061,062,063,064,065,066,067	;060-067
	.BYTE	070,071,072,073,133,075,135,077	;070-077
	.BYTE	100,101,102,103,104,105,106,107	;100-107
	.BYTE	110,111,112,113,114,115,116,117	;110-117
	.BYTE	120,121,122,123,124,125,126,127	;120-127
	.BYTE	130,131,132,050,134,051,136,137	;130-137
	.BYTE	047,301,302,303,304,305,306,307	;140-147
	.BYTE	310,311,312,313,314,315,316,317	;150-157
	.BYTE	320,321,322,323,324,325,326,327	;160-167
	.BYTE	330,331,332,063,041,062,055,177	;170-177

.ENDC
.SBTTL	DATA STORAGE

;.LIST	MEB		;LIST MACRO EXPANSIONS FROM HERE ON

RCOUNT:	0		;COUNT OF TIMES 11 HAS BEEN STARTED
L.UPT:	0		;CONTENTS OF DL.UPT ONE SEC AGO
DLECNT:	0		;COUNT OF BAD DIRECTIVES FROM 10
DH.LIM:	0		;FIRST NON-BLK
UPFLAG:	0		;IF NEGATIVE 10 IS DEAD
			; WHEN 0 10 IS STOPPED(E.G. IN EXEC DDT)
			; IF GT 0 10 IS HEALTHY(I.E. UPDATING JIFFY COUNTER
TEA:	0		;ADR OF TO-ELEVEN QUEUE (DIVIDED BY 2)
TTA:	0		;ADR OF TO-TEN QUEUE(DIVIDED BY 2)

TCONLN:	LINMAX		;CTY LINE NUMBER
CTYPTR:	0		;STRING POINTER FOR CTY STUFF

T10PTR:	0		;TO-10-QUEUE PUTTER
T10TKR:	0		;TO-10-QUEUE TAKER
Q.SIZ=<LINMAX+1>+20
T10QUE:	.BLKW	Q.SIZ		;QUEUE FOR MSG'S TO 10


.IF NE FTDEBUG
IDLCNT:	.BLKW	1	;COUNT EVERY TIME GET TO END OF LOOP WITH NOTHING TO DO
IDLSEC:	.BLKW	1	;IDLCNT AT END OF LAST SECOND
.ENDC
.SBTTL	TTY TABLES

.MACRO	LINES
Z=0	;BEGIN WITH LINE 0
.REPT	LINMAX
	X	\Z
Z=Z+1
.ENDR
.ENDM	LINES
.MACRO	SPD	A,B	;ARGS ARE RECEIVE SPEED, TRANSMIT SPEED
Q=0
QQ=0
.IF DF A
.IIF	EQ	<A-^D50>,Q=1
.IIF	EQ	<A-^D75>,Q=2
.IIF	EQ	<A-^D110>,Q=3
.IIF	EQ	<A-^D134>,Q=4
.IIF	EQ	<A-^D150>,Q=5
.IIF	EQ	<A-^D200>,Q=6
.IIF	EQ	<A-^D300>,Q=7
.IIF	EQ	<A-^D600>,Q=10
.IIF	EQ	<A-^D1200>,Q=11
.IIF	EQ	<A-^D1800>,Q=12
.IIF	EQ	<A-^D2400>,Q=13
.IIF	EQ	<A-^D4800>,Q=14
.IIF	EQ	<A-^D9600>,Q=15
QQ=Q*20
.IF NDF B
	B=A
.ENDC
.IIF	EQ	<B-^D50>,Q=1
.IIF	EQ	<B-^D75>,Q=2
.IIF	EQ	<B-^D110>,Q=3
.IIF	EQ	<B-^D134>,Q=4
.IIF	EQ	<B-^D150>,Q=5
.IIF	EQ	<B-^D200>,Q=6
.IIF	EQ	<B-^D300>,Q=7
.IIF	EQ	<B-^D600>,Q=10
.IIF	EQ	<B-^D1200>,Q=11
.IIF	EQ	<B-^D1800>,Q=12
.IIF	EQ	<B-^D2400>,Q=13
.IIF	EQ	<B-^D4800>,Q=14
.IIF	EQ	<B-^D9600>,Q=15
QQ=QQ+Q
.ENDC
.ENDM	SPD


	QQQ=<^D110>
	SPD	QQQ,QQQ
B.110=<QQ*100>+7
	QQQ=<^D134>
	SPD	QQQ,QQQ
B.134=<QQ*100>+65
	QQQ=<^D150>
	SPD	QQQ,QQQ
B.150=<QQ*100>+7
	QQQ=<^D300>
	SPD	QQQ,QQQ
B.300=<QQ*100>+7

;BLOCKS FOR EACH DH11
			;FIRST WORD IS HDW ADR OF DH11
			; IF HDW IS NOT PRESENT WILL BE ZERO
	B.BAR=2		;ACTIVE LINES(SOFTWARE BAR)
	B.LNUM=4
	BLK.DM=6	;ADR OF DM11BB IF PRESENT, ELSE 0
.MACRO	X	A
DH'A'BLK:	0
	0
	A*20		;FIRST LINE # IN GROUP
	B.DM11+<10*A>
.ENDM	X
	DHBSIZ=10
	X	0
	X	1
	X	2
	X	3
	X	4
	X	5
	X	6
	X	7

BLKSIZ=DH1BLK-DH0BLK
BLKTAB:	DH0BLK
	DH1BLK
	DH2BLK
	DH3BLK
	DH4BLK
	DH5BLK
	DH6BLK
	DH7BLK

Z=1
TTOBIT:
.REPT	LINMAX
	.WORD	Z
	Z=Z*2
.IF EQ Z
	Z=000001
.ENDC
.ENDR
	.BYTE	177,177,177,177,177,177,177,177,177,177,177,177,177,177
FILLER:	.BYTE	177,0

BRKMSG:	.BYTE	15,15,12,377
	.ASCII	\%DECsystem10 is not running\
	.BYTE	0

RELMSG:	.BYTE	377,215,215,12,377
	.ASCII	\%DECsystem10 being reloaded\
	.BYTE	0

CONMSG:	.BYTE	377,215,215,12,377
	.ASCII	\%DECsystem10 continued\
	.BYTE	215,215,12,377
	.BYTE	0

.IF EQ FT.CTY
CTYMSG:	.BYTE	377,215,215,12,377
	.ASCII	\CTY is not a DECsystem10 terminal\
	.BYTE	0
.ENDC

	.EVEN
.SBTTL	TTY TABLES

.MACRO	LINES
Z=0	;BEGIN WITH LINE 0
.REPT	LINMAX
	X	\Z
Z=Z+1
.ENDR
.ENDM	LINES
;TABLE OF CARRIER STATUS
CARTAB:
	AUTBIT=200	;SIGN BIT = LOOK FOR CR TO START MESS
	ALNBIT=100	;LINE IS ELIGIBLE FOR AUTO BAUD
	LOSBIT=040	;LOST CARRIER ON LAST TICK
	RNGBIT=020	;RING IS ASSERTED
	CARBIT=010	;CARRIER IS PRESENT
	INIBIT=004	;HAVE JUST RESTARTED SO SEND STATUS
CHRTAB=CARTAB+1	;LEFT HALF OF CARTAB IS BUFFER FOR OUTPUT CHARS
	.MACRO	X	LNE
	SPD	T'LNE'XS,T'LNE'RS
.IIF	EQ	QQ,AUTBIT!ALNBIT
.IIF	NE	QQ,0
	.ENDM	X
	LINES

;LINE SPEED - 8 BITS OF LINE SPEED AS GIVEN BY 10 TO DC76
SPDTAB:
.MACRO	X	LNE
	SPD	T'LNE'XS,T'LNE'RS
	QQ
	.ENDM	X
	LINES

CHKZER=.	;1ST LOCATION ZEROED BY SYSCHK

;TABLE OF CHARACTERS TO PUT OUT ASAP(E.G. AFTER UPSHIFT ON A 2741)
ASAPTB:	;LH OF TABLE IS LN.TAB

;TABLE OF FOUR BIT LINE NUMBERS
LN.TAB=ASAPTB+1
	.BLKW	LINMAX

.IF NE FT2741
;STATUS WORD FOR 2741 LINES
BCDTAB:	.BLKW	LINMAX
			;IF WORD IS NONZERO LINE IS A 2741
	BCDXRB=040000	;SENDING REVERSE BREAK
	BCDKBL=020000	;IF KEYBOARD IS LOCKED
	BCDPRL=010000	;IF PRINTER IS LOCKED
	BCDTDY=004000	;TTY TIDY MODE
	BCDCOD=003400	;MASK FOR CODE
;	BCDMSK=000200	;10 REQUESTED WE UNLOCK KEYBOARD
	BCDUPS=000100	;IF IN UPPERSHIFT MODE
	BCDHDB=000040	;TERMINAL HAS DEBREAK FEATURE
	BCDOCR=000020	;LAST CHARACTER OUT WAS A CR
	BCDRCR=000010	;LAST CHARACTER RECEIVED WAS A CR
	BCDCON=000004	;LAST CHARACTER IN WAS "CONTROL" FAN
	BCDCDB=000002	;LAST TIME WE REVERSED LINE IT WAS BECAUSE
			; WE NEEDED INPUT
	BCDAPL=000001	;SPECIAL "APL-MODE"
			; NO SPCIAL HANDLING FOR UPARROW
			; BREAK IS TO BE TREATED AS ^C^C
	BCDCOD=003400	;MASK FOR CODE
	;MASK FOR CODE
			; AS SHIFT HAS BEEN SENT
BCDVRG=BCDVRG!BCDPRL	;VIRGIN BITS FOR A BCD LINE
.ENDC

;TABLE OF DH11 BLOCK
DH.TAB:	.BLKW	LINMAX

FIRZER:		;FIRST LOCATION TO ZERO ON A RESTART
;TIME TABLE(USED TO TIME FILLERS, BREAK, ETC.)
; LH IS REASON CODE, RH IS TIMER
; (0) TIMING FILLER, CONSIDER TO BE XMT INT
; (2) HAVE RECEIVED EOT FROM 2741, TIMER TO SEND EOA
CLKTAB:	.BLKW	LINMAX+1

;TABLE OF POINTERS TO STRINGS TO TYPE ON A LINE
STRTAB:	.BLKW	LINMAX+1
.IF DF LSTZER
.PRINT	LSTZER	;HIGHEST ADDRESS USED
.ENDC
LSTZER:		;LAST LOCATION TO ZERO ON A RESTART
.SBTTL	SYSCHK -  ONCE ONLY SYSTEM DIAGNOSTIC

;NOTE: THIS CODE IS EXECUTED ONCE AND THEN OVERLAID WITH TABLES

.=CHKZER
SYSCHK:	RESET			;CLEAR THE WORLD
	MOV	#10$,4		;SET BUS TRAP LOCATION
	TST	CTOSTS		;CHECK CTY TRANSMIT STATUS REGISTER
	TST	CTOCHR
	TST	CTISTS
	TST	CTICHR
	BR	15$
10$:	TRAP
15$:	MOV	#NXMTRP,4	;RESET BUS TRAP VECTOR
	.IF NE FTSCHK
	JSR	R0,CRLTYP
	.ASCII	\Initializing DC76 v\
	.BYTE	0
	.EVEN
	MOV	#VDC76,R0	;GET SOFTWARE VERSION NUMBER
	JSR	PC,OCTYPE
.ENDC

;BE SURE CLOCK IS PRESENT
CLKCHK:	MOV	#20$,4		;SET BUS TRAP IN CASE CLOCK IS NOT PRESENT
	TST	CLKWRD
	BR	99$
20$:	JSR	R0,CRLTYP
	.ASCII \??D76 - can't access KW11\
	.BYTE	0
	.EVEN
	TRAP			;DIE
99$:
;DETERMINE HOW MANY FLOATING VECTOR DEVICES ARE PRESENT

	MOV	#FLOATV,R3	;FLOATING INTERRUPT VECTOR'S BEGIN HERE

;DETERMINE HOW MANY DP11'S IN SYSTEM
	JSR	R5,CHKDEV	;FIND HOW MANY AND ADJUST VECTOR
	.WORD	174770		;1ST DP11 ADR
	.BYTE	<^D32>,10	;MAX NUMBER OF DP11'S, VECTOR INCREMENT
	.BYTE	-10,10		;HDW ADR INC, 1ST VECT MULTIPLE
	.ASCII	\ DP11's\
	.BYTE	0
	.EVEN

;DETERMINE HOW MANY PA611'S IN SYSTEM
	JSR	R5,CHKDEV	;ADJUST FLOATING VECTOR FOR PA611'S
	.WORD	172600
	.BYTE	<^D16>,4
	.BYTE	10,4		;HDW ADR INC, VECT STARTING ADR MULTIPLE
	.ASCII	\ PA611R\
	.BYTE	0
	.EVEN
	JSR	R5,CHKDEV	;ADJUST FLOATING VECTOR FOR PA611P'S
	.WORD	172700		;HDW LOC FOR 1ST
	.BYTE	<^D16>,4
	.BYTE	10,4		;HDW ADR INC, 1ST VECT ADR MULTIPLE
	.ASCII	\ PA611P\
	.BYTE	0
	.EVEN
;DETERMINE HOW MANY DH11'S IN SYSTEM
DH.CHK:	CLR	L		;COUNT DH11'S
	CLR	R5		;COUNT DM11BB'S

	MOV	#DHBASE,R1	;HDW ADR OF 1ST DH11
	MOV	#DMBASE,R2	;HDW ADR OF 1ST DM11BB
	MOV	#DH0BLK,R0	;ADR OF FIRST DH11 BLOCK
	BR	22$		;IN CASE NO DH11'S IN SYSTEM

10$:	MOV	#50$,4		;TRAP IN CASE OF NXM
	TST	@R1		;CHECK TO SEE IF DH11 IS PRESENT
	MOV	R1,@R0		;BUT DH11 ADR INTO BLOCK
	TST	R2		;HAVE WE ALREADY RUN OUT OF DM11BB'S
	BEQ	30$		;BRANCH IF SO
	MOV	#30$,4		;TRAP IN CASE DM11BB IS NOT PRESENT
	MOV	#DM.INI,@R2	;INITIALIZE THE DM11BB
	MOV	R2,BLK.DM(R0)	;SAVE DM11BB ADR IN DH11 BLOCK
	ADD	#10,R2		;ADVANCE TO NEXT DM11BB ADR
	INC	R5		;COUNT DM11
	ADD	#4,R3		;ADVANCE TO NEXT INTERRUPT VECTOR
20$:	ADD	#BLKSIZ,R0	;ADVANCE TO THE NEXT BLOCK
	INC	L		;COUNT DH11
	ADD	#20,R1		;ADVANCE TO NEXT DH11 HDW ADR
22$:	CMP	#DH.MAX,L	;HAVE WE CHECKED ALL DH11'S ?
	BEQ	VECSET		;BRANCH IF SO
	BR	10$

;HERE BECAUSE DM11BB IS NOT PRESENT FOR A DH11
30$:	CLR	BLK.DM(R0)	;CLEAR DM11BB ADR IN DH11 BLOCK
	CLR	R2		;NO MORE DM11BB'S
	BR	20$

;HERE BECAUSE DH11 IS NOT PRESENT
50$:	CLR	@R0		;CLEAR DH11 HDW ADR
	CLR	BLK.DM(R0)	;THERE IS ALSO NO DM11BB FOR THIS DH11 !
	ADD	#BLKSIZ,R0	;ADVANCE TO NEXT DH11 BLOCK
	CMP	#DH0BLK+<DH.MAX*BLKSIZ>,R0	;HAVE WE DONE ALL THE BLOCKS ?
	BNE	50$		;BRANCH FOR REST OF DH11'S
;HERE WHEN HAVE CHECKED ALL DH11'S FOR EXISTENCE
VECSET:	ADD	#4,R3
	BIC	#7,R3		;MAKES VECTOR ADR FOR 1ST DH11
.IF DF DH.VEC
	MOV	#DH.VEC,R3	;1ST DH11 INTERRUPT VECTOR
.ENDC

.IF NE FTSCHK
	MOV	R3,-(P)
	JSR	R0,CRLTYP
	.ASCII	\DC76 has \
	.BYTE	0
	.EVEN
	MOV	L,R0
	JSR	PC,OCTYPE
	JSR	R0,CHKTYP
	.ASCII	\ DH11's; \
	.BYTE	0
	.EVEN
	MOV	R5,R0
	JSR	PC,OCTYPE
	JSR	R0,CHKTYP
	.ASCII	\ DM11BB's\
	.BYTE	0
	.EVEN
	MOV	(P)+,R3
.ENDC
VST.10:.IF NE FTSCHK
	MOV	R3,-(P)		;SAVE ADR OF FIRST VECTOR
	CLR	L		;START WITH 1ST DH11
10$:	MOV	#200,R0		;FILL OUT VECTOR SPACE
	MOV	#300,R1		;PROCESSOR STATUS WORD=LEVEL 6
12$:	MOV	#30$,(R0)+
	MOV	R1,(R0)+	;SET STATUS WORD IN CASE THIS INTERRUPTS
	INC	R1
	BIC	#20,R1		;CLEAR TRACE TRAP BIT
	CMP	#500,R0
	BNE	12$
	MOV	#40$,4(R3)	;SET TRANSMIT INT VECTOR FOR THIS DH11
	CLR	PS		;CLEAR PROCESSOR STATUS WORD
	MOV	BLKTAB(L),R0	;GET BLK ADR
	MOV	@R0,R0		;GET HDW ADR
	BEQ	50$		;BRANCH IF NO HDW
	MOV	#DH..MC,@R0	;DO A MASTER CLEAR OF DH11
	MOV	#DH..TI!DH.TIE,@R0	;FAKE A TRANSMIT INTERRUPT
	MOV	@R0,R1		;GET DH11 STATUS IN CASE DOESN'T INTERRUPT
	CLR	R2
17$:	INC	R2
	BNE	17$
	TRAP
30$:	MOV	PS,-(P)		;SAVE PROCESSOR STATUS WORD
	JSR	R0,CRLTYP
	.ASCII	\DH11 #\
	.BYTE	0
	.EVEN
	MOV	L,R0
	JSR	PC,OCTYPE		;TYPE DH11 NUMBER
	JSR	R0,CHKTYP
	.ASCII	\ trapped to x\
	.BYTE	0
	.EVEN
	MOV	(P)+,R0		;GET STATUS WORD WE TRAPPED WITH
	BIC	#^C17,R0
	ASL	R0
	ASL	R0
	JSR	PC,OCTYPE
	JSR	R0,CHKTYP
	.ASCII	\ instead of \
	.BYTE	0
	.EVEN
	MOV	R3,R0
	ADD	#4,R0
	JSR	PC,OCTYPE
	JSR	R0,CHKTYP
	.BYTE	207,0
	TRAP
40$:	MOV	#DH..MC,@R0	;CLEAR DH11
	MOV	(P)+,R0		;POP OLD PC OFF STACK
	MOV	(P)+,R0		;POP OLD PS OFF STACK
	ADD	#10,R3		;ADVANCE VECTOR ADR
	ADD	#2,L		;ADVANCE TO NEXT DH11 BLOCK
	CMP	L,#DH.MAX+DH.MAX
	BNE	10$		;BRANCH FOR NEXT DH11

50$:	MOV	(P)+,R3		;GET ADR OF FIRST VECTOR BACK
.ENDC
;HERE TO SET DH11 INTERRUPT VECTORS
	CLR	L		;START WITH 1ST DH11
	MOV	#DHI0IN,R1	;FIRST DH11 INPUT INTERRUPT ADR
	MOV	#DHO0IN,R2	;FIRST DH11 OUTPUT INTERRUPT ADR
80$:	MOV	BLKTAB(L),R0	;GET ADR OF DH11 BLOCK
	TST	@R0		;CHECK TO SEE HDW EXISTS
	BEQ	90$		;BRANCH IF NO HARDWARE
	MOV	R1,@R3		;SET INPUT INTERRUPT PC
	MOV	#<40*DH.CHN>,2(R3)
	MOV	R2,4(R3)	;VECTOR ON DH11 TRANSMIT INTERRUPTS
	MOV	#<40*DH.CHN>,6(R3)
	ADD	#<DHI1IN-DHI0IN>,R1	;NEXT INTERRUPT LOCATION
	ADD	#<DHO1IN-DHO0IN>,R2
	ADD	#10,R3		;ADVANCE TO NEXT INTERRUPT VECTOR
	ADD	#2,L
	CMP	#DH.MAX+DH.MAX,L
	BNE	80$

90$:	MOV	#NXMTRP,4	;SET NXM TRAP ADR
	MOV	#INIJMP+4,INIJMP+2

	JMP	CHKDNE
;HERE TO CHECK SYSTEM FOR EXISTENCE OF OPTIONS
; CALL	JSR	R5,CHKDEV
;	.WORD	1ST DEVICE ADR
;	.BYTE	MAX #,VECTOR INC
;	.WORD	DEV HDW ADR
;	.ASCII	\ NAME\
CHKDEV:	CLR	L		;INITIALIZE COUNTER FOR DEVICES
	MOV	(R5)+,R0	;GET HDW ADR FOR 1ST DEVICE
	MOV	#20$,4		;SET BUS TRAP VECTOR
10$:	TST	@R0		;CHECK TO SEE IF DEVICE IS PRESENT
	TST	L		;IS THIS THE FIRST OF ITS KIND ?
	BNE	15$		;BRANCH IF NOT FIRST
	MOVB	3(R5),R1	;GET MULTIPLE VECTOR BEGINS ON
	DEC	R1
	ADD	R1,R3
	BIC	R1,R3
15$:	INC	L		;COUNT DEVICE
	MOVB	1(R5),R1	;GET VECTOR INCREMENT
	ADD	R1,R3
	MOVB	2(R5),R1	;GET HDW INCREMENT
	ADD	R1,R0		;ADVANCE TO NEXT DEVICE ADR
	CMPB	L,@R5		;HAVE WE CHECK ALL POSSIBLE ?
	BNE	10$		;IF NOT LOOP BACK FOR REST
20$:	MOV	#NXMTRP,4	;RESET BUS TRAP LOCATION
	TST	L		;WERE THERE ANY OF THESE ?
	BEQ	30$
	JSR	R0,CRLTYP
	.WORD	0
	MOV	L,R0		;NUMBER OF DEVICES WE FOUND
	JSR	PC,OCTYPE	;TYPE OUT THE NUMBER
	MOV	R5,R0
	ADD	#4,R0
	JMP	CHKTYP
30$:	ADD	#4,R5
33$:	INC	R5
	TSTB	(R5)
	BNE	33$
	INC	R5
	BIC	#1,R5
	RTS	R5
.IIF LT <.-FIRZER>,	.=FIRZER

;HERE WHEN DONE WITH SYSCHK
; FILL OUT SOME TABLES THEN REALLY START DC76

CHKDNE:	MOV	#CHKZER,R0	;FIRST LOCATION TO CLEAR
10$:	CLR	(R0)+
	CMP	R0,#FIRZER
	BNE	10$

	CLR	L
	CLR	R0
	MOV	#DH0BLK,R1
20$:	MOVB	R0,LN.TAB(L)	;BUILD TABLE OF 4 BIT LINE NUMBERS
	MOV	R1,DH.TAB(L)	;BUILD TABLE OF DH11 BLOCK ADR'S
	INC	R0		;ADVANCE 4 BIT LINE NUMBER
	BIC	#^C17,R0	;STRIP EXTRA BITS
	BNE	22$		;BRANCH IF MORE LINES ON DH11
	ADD	#DH1BLK-DH0BLK,R1
22$:	CLR	BCDTAB(L)	;INITIALIZE 2741 CHARACTERISTICS
	CMPB	#104,SPDTAB(L)	;IS THIS LINE A 2741 ?
	BNE	24$		;BRANCH IF NOT
	MOV	#BCDVRG,BCDTAB(L)	;SET VIRGIN 2741 BITS
24$:	ADD	#2,L
	CMP	#LINMAX+LINMAX,L
	BNE	20$
	JMP	DC76

	.END	DC76
