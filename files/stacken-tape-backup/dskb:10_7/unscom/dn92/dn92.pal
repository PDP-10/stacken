/DN92 - NETWORK REMOTE STATION - 24 MAR 81
/
/THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
/ OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
/
/COPYRIGHT (C) 1978,1979,1980,1981 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
/ DATE		LOAD	EDIT #
/ ----		----	------
/
/03-MAR-81	70143	22
/9600
/24-MAR-81	70146	23
/
/
/DAVE MCCLURE	20-FEB-1973
/KALMAN RETI	25-APR-1975
/MARILYN TOOMEY 29-MAR-1977

/ THE EXISTENCE OF A FEATURE TEST SWITCH IN THIS CODE DOES NOT IMPLY
/ THE SWITCH IS TESTED OR SUPPORTED.
/	E.G. FEATURE TEST SWITCHES ARE PROVIDED FOR STATIONS WITH A HIGH
/	SPEED PAPER TAPE READER/PUNCH OR A PLOTTER BUT THESE ARE NOT
/	SUPPORTED.

	MAJOR=1;MINOR=23		/VERSION AND EDIT

	VEDIT=MAJOR^100+MINOR		/SOFTWARE VERSION NUMBER

/EDIT HISTORY

/0(13)	KR	15-MAY-80	ADD "CAN SET HOST" BIT TO TTY CONNECT CONFIRM
/1(14)	KR	9-JUN-80	MAKE TTY'S SEND CHARACTERISTICS TO HOST FOR
/				COMPATIBILITY WITH 7.01; ALSO MAKE NEILEN
/				IN THE CONFIGURATION FILE, ADD COMMENTS.
/1(15)	KR	25-JUN-80	FIX BUG THAT COULD GET TWO LINES CONNECTED
/				TO SAME LAT
/1(16)	KR	1-JUL-80	FIX RACE IN STORING ESCAPE CHARACTERS
/
/1(17)	KR	3-JUL-80	BUM WORD FROM LPTOFN TO MAKE ALL CONFIGURATIONS
/				ASSEMBLE
/1(20)	KR	8-JUL-80	FIX NOT CONNECTING TO HOST IF ONLY ONE
/				BUG (REPORTED BY DAVE NEWMAN)
/1(21)	KR	15-JUL-80	MAKE TAB SIMULATION USE EVEN PARITY BLANK
/
/1(22)	DWB	3-MAR-81	REMOVE CONDITIONAL AROUND BUGGER SO THAT
/				FTDEBUG=0 WILL WORK
/1(23)	DAD	10-MAR-81	FIX CONNECT BUG WHERE ONE TTY MAY GET OUTPUT
/				MEANT FOR ANOTHER
/
/				(TO CONFORM TO -11 USAGE)



/STARTING INSTRUCTIONS
/	NORMAL STARTING ADDRESS IS 200
/	RESTART ADDRESS IS 200

/ASSEMBLY INSTRUCTIONS
/	.R PAL10
/	*DSK:DN92.BIN=DSK:C.PAL,DSK:DN92.PAL
/	WHERE C.PAL IS A CONFIGURATION FILE
/DEFAULT SWITCHES


IFNDEF NEILEN <NEILEN=20>	/DEFAULT NETWORK SIZE  [1(14)]
	IFZERO NEILEN <NEILEN=20>/MAKE SURE NO TURKEY TRIES ZERO  [1(14)]
	ZZ=NEILEN&4000		/CHECK SIGN BIT [1(14)]
	IFNZRO ZZ <NEILEN=20>	/IF USER GAVE NEGATIVE NUMBER, SET TO DEFAULT  [1(14)]
	ZZ=100-NEILEN		/CHECK AGAINST MAXIMUM NETWORK SIZE  [1(14)]
	ZZ=ZZ&4000		/GET SIGN BIT OF DIFFERENCE  [1(14)]
	IFNZRO ZZ <NEILEN=100>	/IF IT WAS TOO BIG, CUT IT DOWN [1(14)]

IFNDEF TTYN <TTYN=20>		/DEFAULT IS SIXTEEN TTY'S
/FOLLOWING INSURES TTYN=0,4,10,14,OR 20
	ZZ=TTYN-20
IFNZRO ZZ <
	ZZ=TTYN&3
	IFNZRO ZZ <TTYN=TTYN&14+4>
	TTYN=TTYN&34>

IFNDEF CDRN <CDRN=1>		/DEFAULT IS ONE CDR
 IFNZRO CDRN <CDRN=1>		/AT MOST ONE CDR

IFNDEF LPTN <LPTN=1>		/DEFAULT IS ONE LPT
 IFNZRO LPTN <LPTN=1>		/AT MOST 1
IFDEF LA180 <
IFNDEF FTLPLC < FTLPLC=1>	/DEFAULT LOWER CASE FOR LA180
>/END OF IFDEF LA180
IFNDEF LA180 <
 IFNDEF FTLPLC <FTLPLC=0>	/1 IF LPT HANDLES LC CHARS
>/END OF IFNDEF LA180
 IFNDEF LPTWID <LPTWID=204>	/WIDTH OF LPT
				/ 132 DECIMAL IS 204 OCTAL
				/ 80 DECIMAL IS 120 OCTAL
 IFNDEF LPTFAK <LPTFAK=0>	/IF NONZERO THROW AWAY LPT OUTPUT

IFNDEF PTRN <PTRN=0>		/DEFAULT IS NO PTR - NOT SUPPORTED
 IFNZRO PTRN <PTRN=1>		/AT MOST ONE PTR
IFNDEF PTPN <PTPN=0>		/DEFAULT IS NO PTP - NOT SUPPORTED
 IFNZRO PTPN <PTPN=1>		/AT MOST ONE PTP

	PLTN=0
IFNDEF PLTN <PLTN=0>		/PLOTTER XY8/E - NOT SUPPORTED
 IFNZRO PLTN <PLTN=1>		/AT MOST ONE PLT

IFNDEF DTAN <DTAN=0>		/DEFAULT IS NO DTA
				/ NOT IMPLEMENTED

IFNDEF CNKSIZ <CNKSIZ=10>	/SIZE OF CHUNKS - DEFAULT IS 8 WORDS
  CNKSIZ=CNKSIZ&374		/MUST BE IN RANGE 4-200
  IFZERO CNKSIZ <CNKSIZ=40>
  Z=-CNKSIZ
  CNKSIZ=CNKSIZ&Z		/ MUST BE A POWER OF 2

IFNDEF FTDEBUG <FTDEBUG=1>	/1 FOR DEBUGGING FEATURES
  IFNDEF FTLBACK <FTLBACK=0>	/1 FOR LOOPBACK TEST
  IFNDEF FTTRBL <FTTRBL=0>	/1 FOR CTY MSG ON DEVICE TIMEOUT
  IFNDEF FTBIGL <FTBIGL=0>	/0 TO XLIST UNUSED CODE

IFNDEF CNKFLD <CNKFLD=1>	/0 = KEEP CHUNKS IN FIRST FIELD
	CNKFLD=CNKFLD&0007	/ 1 = KEEP CHUNKS IN SECOND FIELD
				/ 2 = KEEP CHUNKS IN THIRD FIELD

  IFNDEF NUMSYN <NUMSYN=10>	/NUMBER OF SYNCHS AT BEGINING OF MESSAGE

	IFNDEF OURNNM <OURNNM=72>/OUR NODE NUMBER
	IFNDEF MAXOLN <MAXOLN=240+4>/MAX OUTPUT MESSAGE LENGTH=CARD+OVRHEAD
	DEVN=1+TTYN+CDRN+LPTN+PTRN+PTPN+PLTN+DTAN
	CTRLN=1+LPTN+CDRN+PTPN+PTRN+PLTN/NUMBER OF CONTROLLERS(FOR DDCMP)

IFNDEF REPTIM <REPTIM=170>	/REP TIMEOUT = 2 SECS

IFNZRO DTAN <CTRLN=CTRLN+1>

IFNDEF TTYMIC <TTYMIC=120>	/MAXIMUM NUMBER OF INPUT CHARS FROM A TTY

ERSCNT=2
IFNZRO CDRN <ERSCNT=ERSCNT+CDRCNK>/WORST CASE CARD LENGTH
IFNZRO PTRN <ERSCNT=ERSCNT+1>	/WORST CASE TO STOP PTR

IFNDEF DFLXMT <DFLXMT=156>	/DEFAULT SPEED IS 110 BAUD
IFNDEF DFLRCV <DFLRCV=DFLXMT>	/DEFAULT SPEED IS SAME AS TRANSMIT

/TRACE MODE NOT WORKING ON DAS92 FOLLOWING OVERRIDES ANY
/PARAMETER SET UP IN C.PAL
	DP8ETR=0


/SOFTWARE IDENTIFICATION STRING (SID)
	DEFINE	SIDTXT	<
"D;"N;"9;"2;" ;"V;"1;"(;"2;"3;")-200;"2;"4;"-;"M;"A;"R;"-;"8;"1-200
>/END SIDTXT DEFINITION
/	SET DEFAULT CHUNK COUNTS
	IFNDEF	LPTCHK	<LPTCHK=-100>
	IFNDEF	TTYCHK	<TTYCHK=-40>
	IFNDEF	DRQCT	<DRQCT=5>	/DATA REQ COUNT FOR ALL DEVICES


/	SET RESTRICTED NODE NUMBER TO 0 FOR ALL DEVICES
	XLIST
IFNDEF	CTYRNN <CTYRNN=0>
IFNDEF	T00RNN <T00RNN=0>
IFNDEF	T01RNN <T01RNN=0>
IFNDEF	T02RNN <T02RNN=0>
IFNDEF	T03RNN <T03RNN=0>
IFNDEF	T04RNN <T04RNN=0>
IFNDEF	T05RNN <T05RNN=0>
IFNDEF	T06RNN <T06RNN=0>
IFNDEF	T07RNN <T07RNN=0>
IFNDEF	T10RNN <T10RNN=0>
IFNDEF	T11RNN <T11RNN=0>
IFNDEF	T12RNN <T12RNN=0>
IFNDEF	T13RNN <T13RNN=0>
IFNDEF	T14RNN <T14RNN=0>
IFNDEF	T15RNN <T15RNN=0>
IFNDEF	T16RNN <T16RNN=0>
IFNDEF	T17RNN <T17RNN=0>
IFNDEF	CDRRNN <CDRRNN=0>
IFNDEF	LPTRNN <LPTRNN=0>
IFNDEF	PTRRNN <PTRRNN=0>
IFNDEF	PTPRNN <PTPRNN=0>
IFNDEF	PLTRNN <PLTRNN=0>
	XLIST
/SET DATASET LINE TTYDSL FOR ALL LINES
IFDEF LOOP <		/ONLY DONE ON PASS 2
	CTYDSL=0
IFDEF T00DSL <T00DSL=4002>
IFNDEF T00DSL <T00DSL=0>
	XLIST	/REST OF TTY LINES REPETITIVE
IFDEF T01DSL <T01DSL=4002>
IFNDEF T01DSL <T01DSL=0>
IFDEF T02DSL <T02DSL=4002>
IFNDEF T02DSL <T02DSL=0>
IFDEF T03DSL <T03DSL=4002>
IFNDEF T03DSL <T03DSL=0>
IFDEF T04DSL <T04DSL=4002>
IFNDEF T04DSL <T04DSL=0>
IFDEF T05DSL <T05DSL=4002>
IFNDEF T05DSL <T05DSL=0>
IFDEF T06DSL <T06DSL=4002>
IFNDEF T06DSL <T06DSL=0>
IFDEF T07DSL <T07DSL=4002>
IFNDEF T07DSL <T07DSL=0>
IFDEF T10DSL <T10DSL=4002>
IFNDEF T10DSL <T10DSL=0>
IFDEF T11DSL <T11DSL=4002>
IFNDEF T11DSL <T11DSL=0>
IFDEF T12DSL <T12DSL=4002>
IFNDEF T12DSL <T12DSL=0>
IFDEF T13DSL <T13DSL=4002>
IFNDEF T13DSL <T13DSL=0>
IFDEF T14DSL <T14DSL=4002>
IFNDEF T14DSL <T14DSL=0>
IFDEF T15DSL <T15DSL=4002>
IFNDEF T15DSL <T15DSL=0>
IFDEF T16DSL <T15DSL=4002>
IFNDEF T16DSL <T16DSL=0>
IFDEF T17DSL <T17DSL=4002>
IFNDEF T17DSL <T17DSL=0>
	XLIST
>/END OF IFDEF LOOP

/CORE LAYOUT FOR THIS VERSION OF DC72 CODE

/PAGE 0
/	0-7	INTERRUPT TRAP
/	10-17	AUTOINDEX REGISTERS
/	20-25	INTERRUPT DISSMISS ROUTINE
/	26-177	COMMON VARIABLE STORAGE
/PAGE 1
/	200	NORMAL STARTING ADDRESS
/	201	HALT (FORMERLY DUMP STARTING ADDRESS)
/	202	VERSION NUMBER OF DC72 CODE
/
/	DUMP ROUTINE
/	INITIALIZATION
/	NON-INTERRUPT LEVEL CODE
/	DEVICE INTERRUPT ROUTINES
/ * CHANGE TO CHUNK FIELD *
/	TABLE DATA = DEVICE BLOCKS, MESSAGES, PARITY TABLE, LPT VFU ETC.
/	SYSCHK - OVERWRITTEN LATER TO FORM CHUNKS


/EIA PINS FROM DP8E AND DP01
/	1	PROTECTIVE GROUND
/	2	TRANSMITTED DATA
/	3	RECEIVED DATA
/	4	REQUEST TO SEND
/	5	CLEAR TO SEND
/	6	DATA SET READY
/	7	SIGNAL GROUND
/	8	RECEIVED LINE SIGNAL DECTECTOR
/	17	RECEIVED SIGNAL ELEMENT TIMING
/	20	DATA TERMINAL READY
/	21	SIGNAL QUALITY DETECTOR
/	22	RING INDICATOR
/	24	TRANSMIT SIGNAL ELEMENT TIMING
/CARD LOADER FOR DC71'S IS
/
/	117570	6672	SELECT CARD READER AND SKIP IF READY
/	117571	5370	JMP .-1
/	117572	6631	SKIP ON DATA READY
/	117573	5372	JMP .-1
/	117574	6634	READ DATA BINARY
/	117575	3270	DCA 7470
/	117576	2375	ISZ .-1
/	117577	5372	JMP 7572


/RIM LOADER FOR LOW SPEED PAPER TAPE IS
/	117756	6032		/CLEAR KEYBOARD FLAG & ADVANCE READER
/	117757	6031		/SKIP ON KEYBOARD FLAG
/	117760	5357		/JMP .-1
/	117761	6036		/READ KEYBOARD BUFFER, CLEAR FLAG
/	117762	7106		/CLL RTL
/	117763	7006		/RTL
/	117764	7510		/SPA
/	117765	5357		/JMP 117757 - SKIP LEADER, TRAILER
/	117766	7006		/RTL
/	117767	6031		/SKIP ON KEYBOARD FLAG
/	117770	5367		/JMP .-1
/	117771	6034		/READ KEYBOARD STATIC
/	117772	7420		/SNL
/	117773	3776		/DCA @117776
/	117774	3376		/DCA 1176
/	117775	5356		/JMP 117756


/RIM LOADER FOR HIGH SPEED PAPER TAPE IS
/	117756	6014		/READER FETCH CHARACTER
/	117757	6011		/SKIP ON READER FLAG
/	117760	5357		/JMP .-1
/	117761	6016		/READ READER BUFFER, AND FETCH NEW CHARACTER
/	117762	7106		/CLL RTL
/	117763	7006		/RTL
/	117764	7510		/SPA
/	117765	5374		/JMP 117774 - SKIP LEADER, TRAILER
/	117766	7006		/RTL
/	117767	6011		/SKIP ON READER FLAG
/	117770	5367		/JMP .-1
/	117771	6016		/READ READER STATIC
/	117772	7420		/SNL
/	117773	3776		/DCA @117776
/	117774	3376		/DCA 1176
/	117775	5357		/JMP 117757
/CODING CONVENTIONS
/
/ 1.)	THE FIRST 3 CHARS OF A SYMBOL INDICATE WHEN THE LABEL IS USED
/	  CLKXXX IS USED AT CLOCK LEVEL(I.E. EVERYTIME CLOCK TICKS)
/	  INIXXX IS USED AT INITIALIZATION TIME.
/	  INTXXX IS USED AT INTERRUPT LEVEL
/	  IXXXXX IS USED AT INTERRUPT LEVEL
/	  DEVXXX IS USED TO REFERENCE DATA IN DEVICE BLOCK
/	  LDBXXX IS USED FOR A LDB ADDRESS
/	  NLXXXX IS USED FOR A NUMERICAL LOAD INSTRUCTION
/
/ 2.)	INTERRUPTS ALWAYS SAVE THE AC AND THE LINK
/	 THE DC72NP ASSUMED ALL THE INSTRUCTIONS WERE IN FIELD 0 AND
/	 ALL THE DATA WAS IN FIELD 1.  HOWEVER, THE DAS92 CAN'T MAKE
/	 THAT ASSUMPTION AND RESTORES THE LINK, DATA, AND INSTR FIELDS
/	 BEFORE DISMISSING THE INTERRUPT
/
/ 3.)	INSTRUCTIONS WHICH ARE CHANGED ARE FLAGED WITH ######## RH SIDE
/DEFINE CHAIN FOR INTERRUPTS & ONCE/TICK CODE
/
/	EVERY DEVICE IS TO HAVE A 3 LETTER MNEMNOIC "XYZ"
/
/	LABEL TO TEST FOR INTERUPTS FOR DEVICE IS INTXXX
/	 WHEN TEST FAILS WILL BRANCH TO INTXY9
/
/	LABEL TO BRANCH TO ONCE / SECOND IS CLKXYZ
/	 WHEN FINISHED WILL BRANCH TO CLKXY9
/	FOLLOWING ARE LABEL DEFINITIONS(MUST BE IN INCREASING PRIORITY):

IFDEF LOOP <		/THIS IS ASSEMBLED ONLY FOR PASS 2

INTMT9=INTNOT
IFNDEF INTMTY < INTMTX=INTMT9>
INTMO9=INTMTX	/MODEM TTY LINES
INTPL9=INTMOD
CLKPL9=LOOP		/END OF CLOCK CHAIN

	IFNDEF INTPLT <	INTPLT=INTPL9
			CLKPLT=CLKPL9
>/END OF IFNDEF	INTPLT
INTPP9=INTPLT
CLKPP9=CLKPLT

	IFNDEF INTPTP <	INTPTP=INTPP9
			CLKPTP=CLKPP9
>/END OF IFNDEF	INTPTP
INTPR9=INTPTP
CLKPR9=CLKPTP

	IFNDEF INTPTR <	INTPTR=INTPR9
			CLKPTR=CLKPR9
>/END OF IFNDEF	INTPTR
INTCT9=INTPTR
CLKCT9=CLKPTR

INTCL9=INTCTY

INTLP9=INTCLK
CLKLP9=CLKPTR		/NO SPECIAL CLOCK CODE FOR CTY

	IFNDEF INTLPT <	INTLPT=INTLP9
			CLKLPT=CLKLP9
>/END OF IFNDEF	INTLPT
INTTY9=INTLPT
CLKTY9=CLKLPT

	IFNDEF	INTTTY <INTTTY=INTTY9>
INTCD9=INTTTY
CLKCD9=CLKTTY

	IFNDEF INTCDR <	INTCDR=INTCD9
			CLKCDR=CLKCD99
>/END OF IFNDEF	INTCDR
INTDP9=INTCDR

SCHAIN=INTDPX		/BEGIN SKIP CHAIN WITH SYNCHRONOUS INTERRUPTS

>/END OF IFDEF LOOP
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DEVICE BLOCK DESCRIPTION		***
/	***							***
/	***********************************************************
/	***********************************************************

/DEFINITIONS OF DATA IN DEVICE BLOCK
/ ORDER IS IMPORTANT SO BE CAREFUL IF U CHANGE THEM

DEFINE X Q QQ <XLIST;QQ=QQ+1;XLIST
		Q=QQ-1>/END OF DEFINE X
	DDBSIZ=-5
/DEVICE USES LOC FOR SET HOST CONNECT LOGIC
	X	DEVRCN,DDBSIZ
		DEVRCN=DDBSIZ-1
/	DEVICE DATA SET LINE
/	4000 MEANS TTY HAS BEEN DEF AS DATA SET
/	0000 MEANS NOT DATA SET LINE
/	0100 CARRIER/RING IN DDCMP STATUS WORD
/	0040 DTR FROM HOST 
/	0017 BITS USED FOR 6 SEC COUNT
	X	DEVDSL,DDBSIZ

/DEVICE RESTRICTED NODE NUMBER (NEGATIVE OF NUMBER OF
/ONLY NODE ALLOWED TO CONNECT TO DEVICE. 0 MEANS ANY NODE
/MAY CONNECT
	X	DEVRNN,DDBSIZ

/DEVICE CHUNK IN USE COUNT (USED BY OUTPUT DEVICES)
/	SET TO MINUS NUMBER OF CHUNKS ALLOWED TO BE TIED UP BY DEVICE
	X	DEVCHK,DDBSIZ

/DEVICE NUMBER (OCCUPIES WORD BEFORE DDB) - 0 EXCEPT FOR TTY'S
	X	DEVNUM,DDBSIZ


/DEVICE ID # FOR INPUT	- LH IS OBJECT TYPE, RH IS CONNECT NUMBER
	X DEVSID,DDBSIZ

/POINTER TO CURRENT OUTPUT CHAR
	X DEVOAD,DDBSIZ

/POINTER TO LAST OUTPUT CHUNK
	X DEVOLC,DDBSIZ

/DEVICE STATUS - FOR ALL DEVICES
	X DEVSTS,DDBSIZ
		/ 4000	DEVICE ACTIVE(NOT SET FOR TTY INPUT)
CONBIT=2000	/ 2000 DEVICE IS CONNECTED
		/ 1000	NEED TO SEND A CONNECT CONFIRM (IF 2000 BIT ON)
		/       OR A DISCONNECT (IF 2000 BIT OFF)
CHRBIT=200	/ 0200  NEED TO SEND CHARACTERISTICS (TTY ONLY) [1(14)]
OUTBIT=0100	/ 0100	DEVICE IS OUTPUT(I.E. NEEDS TO SEND DATA REQUESTS)
TTYBIT=0040	/ 0040	DEVICE IS A TTY
IRMBIT=0002	/ 0002	IRMA BIT
STSBIT=0001	/ 0001	MEANS SEND DEVICE STATUS

/DEVICE DATA REQUESTS
	X DEVDRQ,DDBSIZ

/DDCMP DEVICE STATUS
	X DEVDDC,DDBSIZ

/PRIMARY BUFFER ADR
	X DEVBF1,DDBSIZ

/SECONDARY BUFFER ADR
	X DEVBF2,DDBSIZ

/DEVICE INPUT CHAR ADR
	X DEVIAD,DDBSIZ
	X DEVIFC,DDBSIZ

/TIMER FOR DEVICE
	X DEVTIM,DDBSIZ

/DDB LINK
	X DEVLNK,DDBSIZ
/DEFINITIONS OF WORDS ONLY IN TTY DEVICE BLOCKS

LDBSIZ=DDBSIZ

/TTY ADDRESS
	X LDBADR,LDBSIZ
		/ HDW ADR FOR LINE

/TTY OUTPUT COLUMN - CHANGES AT INTERRUPT LEVEL
	X LDBCOL,LDBSIZ

/TTY CARRIAGE WIDTH
	X LDBWID,LDBSIZ

/TTY XOF POINTER - CHANGES AT INTERRUPT LEVEL
	X LDBXPT,LDBSIZ

/TTY FILL POINTER - CHANGES AT INTERRUPT LEVEL
	X LDBFPT,LDBSIZ

/CHAR TO TYPE NEXT - CHANGES AT INTERRUPT LEVEL
	X LDBCHR,LDBSIZ


/POINTER TO LAST INPUT CHAR - CHANGES AT INTERRUPT LEVEL
	X LDBIPT,LDBSIZ


/TTY ECHO PIPELINE MARKER
	X LDBEPL,LDBSIZ

/TTY FILL COUNTS
	X LDBFIL,LDBSIZ
	LDBSIZ=LDBSIZ+5
/DEFINE OPCODES WHICH PAL10 DOESN'T KNOW ABOUT

ESC=33			/ESCAPE CHARACTER FOR EMBEDDING STATUS CHANGES
			/IN DATA STREAM
RMF=6244		/RESTORE DATA, INSTR FIELD BEFORE INTR OCCURRED
SKON=6000		/SKIP IF INTERRUPTS ARE ON
GTF=6004		/READ MACHINE STATE INTO AC
CAF=6007		/CLEAR ALL FLAGS
MQL=7421		/MQ LOAD = AC TO MQ, AC CLEARED
MQA=7501		/MQ ORED INTO AC
SWP=7521		/SWAP AC AND MQ
CAM=7621		/CLEAR AC AND MQ

BSW=7002		/BYTE SWAP ON 8E
NEGATE=CML CMA IAC	/NEGATE AC & LINK
NL0=CLA CLL		/LOAD AC& LINK WITH ZERO
NL1=CLA CLL IAC		/LOAD AC & LINK WITH 1
NL2=CLA CLL IAC RAL
NL3=CLA CLL CML IAC RAL
NL4=CLA CLL IAC RTL
NL6=CLA CLL CML IAC RTL
NL2000=CLL CLA CML RTR
NL3777=CLL CLA CMA RAR
NL4000=CLL CLA CML RAR
NL6000=CLL CLA CML IAC RTR
NL7775=CLL CLA CMA RTL
NL7776=CLL CLA CMA RAL
NL7777=CLL CLA CMA
NLM1=CLL CLA CML CMA	/LOAD -1
NLM2=NL7776		/LOAD -2
NLM3=NL7775		/LOAD -3

DEFINE	NLOAD	X	<XLIST
Z=7402
IFZERO X	< Z=CLL CLA >
IFZERO X-1	< Z=CLL CLA IAC >
IFZERO X-2	< Z=CLL CLA IAC RAL >
IFZERO X-3	< Z=CLL CLA IAC CML RAL >
IFZERO X-4	< Z=CLL CLA IAC RTL >
IFZERO X-6	< Z=CLL CLA IAC CML RTL >
IFZERO X-2000	< Z=CLL CLA CML RTR >
IFZERO X-3777	< Z=CLL CLA CMA RAR >
IFZERO X-4000	< Z=CLL CLA CML RAR >
IFZERO X-5777	< Z=CLL CLA CMA RTR >
IFZERO X-6000	< Z=CLL CLA CML IAC RTR >
IFZERO X-7775	< Z=CLL CLA CMA RTL >
IFZERO X-7776	< Z=CLL CLA CMA RAL >
IFZERO X-7777	< Z=CLL CLA CML CMA >
IFZERO Z-7402	< ***** BUM NLOAD CALL >
	XLIST;	Z	>/END OF DEFINE	NLOAD
/MACRO DEFINITIONS

IFNZRO FTBIGL <
DEFINE LISTOG Q < >
DEFINE XISTOG Q < >
>/END OF IFNZRO FTBIGL

IFZERO FTBIGL <
DEFINE LISTOG Q <IFZERO Q < XLIST > >
DEFINE XISTOG Q <IFNZRO Q < XLIST > >
>/END OF IFZERO FTBIGL

DEFINE CREF X <XLIST;Z=X;XLIST>

DEFINE XOR Q <
		TAD	INTMP1
		AND	Q
		CMA IAC
		CLL RAL
		TAD	INTMP1
		TAD	Q
		DCA	Q
>/END OF DEFINE XOR

DEFINE BLOCK Q <XLIST
		*.+Q
		XLIST	>/END OF DEFINE BLOCK

DEFINE REPEAT Q <XLIST
IFNZRO Z <XLIST
		Q
XLIST
Z=Z-1
>/END OF IFNZRO Z
XLIST>/END OF DEFINE REPEAT

DEFINE HLT <	XLIST
		JMS I	[DMPTRP
		XLIST	>/END OF DEFINE HLT
	DEFINE	INSRT2	<
DATDEC,	0
/	NLOAD	DEVDRQ		/POINT TO DATA REQUESTS
	XXXX=DEVDRQ-4
IFNZRO XXXX <NLOAD DEVDRQ>
	NL4
	TAD	DDB
	DCA	TEMP1
	NLM1			/LOAD -1
	TAD I	TEMP1		/ADD DATA REQUEST
	DCA I	TEMP1		/STORE NEW ONE
	JMP I	DATDEC
INUSE,	TAD	TEMPA		/GET DISPATCH ADDRESS
	TAD	(DEVN^2
	DCA	TEMP2		/MMLTAB ENTRY
	NL1			/REASON  (NOT AVAIL)
	DCA I	TEMP2		/SAVE IN MMLTAB
	DCA I	TEMPA		/CLEAR DISPATCH ADDRESS TO
				/INDICATE WE MUST SEND DISCONNECT
	JMP	RCVFLU
	IFNZRO LPTN <
CLKLP7,	SZA CLA			/BE SURE THERE OUTPUT FOR LPT
	JMS	LPTOFN
	JMP	CLKLP8
>/END OF IFNZRO LPTN
IFNZRO	DP8ETR	<
ITRCRC,	0			/TRACE INPUT CHARACTERS
	DCA	TEMP1		/STORE CHARACTER
	NL4000			/BIT TO INDICATE INPUT
	TAD	TEMP1		/+CHARACTER=TRACE ENTRY
	JMS	ITRCW		/STORE IN TRACE BUFFER
	TAD	TEMP1		/GET CHARACTER
	JMS	CRCALC		/ACCUMULATE CRC
	JMP I	ITRCRC		/RETURN
ITRCR2,	0			/STORE CRC IN TRACE
	TAD	AUTO1		/ADDRESS BEFORE CRC
	DCA	TEMP5		/AT END TEMP5 WILL POINT AT CHUNK POINTER
	ISZ	TEMP5		/ADVANCE TO NEXT CRC CHARACTER
	NL4000			/MASK FOR INPUT
	TAD I	TEMP5		/GET TRACE ENTRY
	JMS	ITRCW		/STORE IN TRACE BUFFER
	ISZ	TEMP5		/ADVANCE TO NEXT CRC CHARACTER
	NL4000			/MASK FOR INPUT
	TAD I	TEMP5		/GET TRACE ENTRY
	JMS	ITRCW		/STORE IN TRACE BUFFER
	ISZ	TEMP5		/SKIP OVER CHUNK COUNT
	ISZ	TEMP5		/POINT TO CHUNKS
	JMP I	ITRCR2		/RETURN
ITRCR3,	0			/TRACE CRC OF DATA PART
	JMS	GETCHR		/GET NEXT CRC CHARACTER
	  JMP	NRMNAK		/NO ROOM
	DCA	TEMPA		/SAVE CHARACTER
	NL4000			/INPUT MASK BIT
	TAD	TEMPA		/+CHARACTER
	JMS	ITRCW		/STORE IN TRACE BUFFER
	TAD	TEMPA		/GET BACK CHARACTER
	JMP I	ITRCR3		/RETURN
ITRCW,	0			/TURN OFF INTERRUPTS AND TRACE
	IOF
	JMS	TRACEW
	ION
	JMP I	ITRCW
>/END OF IFNZRO	DP8ETR
>/END OF DEFINE INSRT2

IFNZRO	CNKFLD <
	Z=CNKFLD^10
	CDFCNK=CDF Z
	CIFCNK=CIF Z
>/END OF IFNZRO	CNKFLD
IFZERO	CNKFLD <
	DEFINE CDFCNK <>
	DEFINE CIFCNK <>
>/END OF IFZERO	CNKFLD
	CDFTRC=CDFCNK
	CDFINS=CDF 0
	CIFINS=CIF 0
/CTY IOTS
	CTYKCF=6030		/CLEAR KEYBOARD FLAG			(PDP8E)
	CTYTFL=6040		/SET TELEPRINTER FLAG			(PDP8E)
	CTYTSK=6045		/SKIP ON PRINTER OR KEYBOARD FLAG	(PDP8E)
	CTYKSF=6031		/SKIP ON KEYBOARD FLAG
	CTYKCC=6032		/CLEAR KEYBOARD FLAG
	CTYKRS=6034		/READ KEYBOARD STATIC
	CTYKRB=6036		/READ KEYBOARD DYNAMIC(KRS+KCC)
	CTYTSF=6041		/SKIP ON TELEPRINTER FLAG
	CTYTCF=6042		/CLEAR TELEPRINTER FLAG
	CTYTPC=6044		/LOAD TELEPRINTER AND PRINT
	CTYTLS=6046		/LOAD TELEPRINTER SEQUENCE(TCF + TPC)

/CLOCK IOTS - DKC8-AA TICK EVERY 10MS EVERY OTHER TICK IGNORED
	CLKECI=6135 /INTERRUPPT ENA/DISAB AC0
	CLCL=6136 /CLEAR CLOCK FLAG
	CLKSCF=6137 /SKIP IF FLAG SET
/POWER FAIL IOT'S
	SPL=6102		/SKIP IF AC LOW FLAG SET
	CAL=6103		/CLEAR INTERRUPT FROM ACLOW FLAG
	SBE=6101		/SKIP IF BATTERY EMPTY FLAG SET(NOT USED IN DAS92)
IFNZRO CDRN <
/CDR IOTS
	CDRSF=6631		/SKIP ON DATA READY
	CDRCRB=6634		/READ CARD BINARY
	CDRSD=6671		/SKIP ON CARD DONE FLAG
	CDRCSE=6672		/SELECT CARD READER AND SKIP IF READY
	CDRCRD=6674		/CLEAR CARD DONE FLAG
>/END OF IFNZRO CDRN

IFNZRO LPTN <
/LINE PRINTER IOT'S - LS8E & LE8=LP08
	LPTSTF=6660		/SET THE FLAG			(LS8E ONLY)
	LPTSKF=6661		/SKIP ON FLAG
	LPTCLF=6662		/CLEAR FLAG
	LPTSKE=6663		/SKIP ON NOT READY
/	LPT=6664		/LOAD PRINT BUFFER
	LPTSIE=6665		/SET PI ENABLE			(LE8 ONLY)
			/ IF AC11=1 SET PI ENABLE	(LS8E ONLY)
			/ IF AC11=0 CLEAR PI ENABLE	(LS8E ONLY)
	LPTSTB=6666		/LOAD DATA & CLEAR FLAG
	LPTCIE=6667		/CLEAR PI ENABLE		(LE8 ONLY)
/LA180 INTERFACE ON DAS92 USES PARALLEL INTERFACE ON KM8A OPTION
/NO ERROR STATUS IS AVAILABLE
	PBST=6570	/SKIP ON DATA ACCEPTED,CLEAR DATA IN
/ AND DATA AVAILABLE FLIP FLOP
	DBTD=6574	/LOAD AC0-11  WITH COMPL DATA AND TRANSMIT
	DBSE=6575	/ENABLE INTERRUPT
	DBCE=6576	/DISABLE INTERRUPT
>/END OF IFNZRO LPTN
	LISTOG	TTYN
IFNZRO TTYN <
/EQUATES FOR KL8A LINES
/FIRST KL8A HAS DEVICE CODE 52
MSIE=6520	/ENABLE INTR IF AC=1,DIASABLE IF =0
MSAB=6521	/BRANCH TO SERVICE RTE, LOAD AC WITH LINE #,
/		CLEAR XMT FLAG IF SET
MSRA=6522	/STATUS A REG TO AC
		/0=SILO FILL
		/1,2=SPARE
		/3=RING LEVEL 0
		/4=RING LEVEL 1
		/5=RING LEVEL 2
		/6=CARRIER LEVEL 0
		/7=CARRIER LEVEL 1
		/8=CARRIER LEVEL 2
		/9=XMT FLAG
		/10=REC FLAG
		/11=INTR ENABLE
MSSR=6523	/SKIP IF RING, CLEAR IF SET
MSXD=6524	/TRANSFER CHAR AND LINE# FROM AC TO XMT BUFFFER
MSRD=6525	/CLEAR AC TRANSFER CHAR, LINE #,ERROR STATUS
/		FROM FIFO,CLEAR REC FLAG IF FIFO EMPTY
MSCT=6526	/CLEAR XMT FLAG
MCCD=6530	/CLEAR DEVICE FLAGS SILO ETC
MSLC=6531	/AC0-4 TO CONTROL REG FOR LINE #
		/0=LOOP BACK MODE
		/1=RTS
		/2=DTR
		/3=SPEED SELECT
		/4=SECONDARY XMT
MSLB=6532	/TRANSFER BRANCH ADDRESS TO REG [AC0-8]
MSSB=6533	/SKIP RING LINE3, AND CLEAR
MSSS=6534	/SKIP CTS LINE 3, AND CLEAR
MSSC=6535	/SKIP CARRIER AND CLEAR
MSSV=6536	/SKIP SEC XMT LINE 3 AND CLEAR
MSRB=6537	/STATUS B TO AC
		/0=CTS
		/1=RTS
		/2=DTR
		/3=SPEED SELECT
		/4=SEC TRANSMIT
		/5=CARRIER FLIP FLOP
		/6=SEC REC FF
		/7=CTS FF
		/8=DATA SET STATUS
		/9=CARRIER LEVEL
		/10=SEC REC LEVEL
		/11=INTER ENABLE
/KL8A#1  SECOND KL8A
MSIE1=6540
MSAB1=6541
MSRA1=6542
MSSR1=6543
MSXD1=6544
MSRD1=6545
MSCT1=6546
MCCD1=6550
MSLC1=6551
MSLB1=6552
MSSB1=6553
MSSS1=6554
MSSC1=6555
MSSV1=6556
MSRB1=6557
/KL8A#2 THIRD KL8A DEVICE CODE 60
MSIE2=6600
MSAB2=6601
MSRA2=6602
MSSR2=6603
MSXD2=6604
MSRD2=6605
MSCT2=6606
MCCD2=6610
MSLC2=6611
MSLB2=6612
MSSB2=6613
MSSS2=6614
MSSC2=6615
MSSV2=6616
MSRB2=6617
/KL8A#3 DEVICE CODE 64
MSIE3=6640
MSAB3=6641
MSRA3=6642
MSSR3=6643
MSXD3=6644
MSRD3=6645
MSCT3=6646
MCCD3=6650
MSLC3=6651
MSLB3=6652
MSSB3=6653
MSSS3=6654
MSSC3=6655
MSSV3=6656
MSRB3=6657
/DEFINITION FOR KL8A IOT STORED IN DDB
/FORMAT:
/	IOT=6000
/	DEVICE CODE=0XX0 WHERE XX=52,54,60,64
/	TRANSMIT CODE=0004
/	LINE NUMBER=000X WHERE X=0,1,2,3
/
	T00TSF=6524
	T01TSF=6525
	T02TSF=6526
	T03TSF=6527
	T04TSF=6544
	T05TSF=6545
	T06TSF=6546
	T07TSF=6547
	T10TSF=6604
	T11TSF=6605
	T12TSF=6606
	T13TSF=6607
	T14TSF=6644
	T15TSF=6645
	T16TSF=6646
	T17TSF=6647
>/END OF IFNZRO TTYN
	LISTOG	TTYN
	Z=PTRN+PTPN+PLTN
	LISTOG	Z
PTRPE=6010		/ENABLE READER/PUNCH INTERRUPT ENABLE
PTPCE=6020		/CLEAR READER/PUNCH INTERRUPT ENABLE
IFNZRO PTRN <
/HIGH SPEED PAPER TAPE READER IOTS - PC8-E OR 
	PTRSF=6011		/SKIP ON READER FLAG
	PTRRB=6012		/OR READER BUFFER INTO AC & CLEAR FLAG
	PTRFC=6014		/READER FETCH CHARACTER - GET NEXT CHAR
>/END OF IFNZRO PTRN

IFNZRO PTPN <
/HIGH SPEED PAPER TAPE PUNCH IOTS
	PTPSF=6021		/SKIP ON PUNCH FLAG
	PTPCF=6022		/CLEAR PUNCH FLAG
	PTPPC=6024		/PUNCH CHARACTER
	PTPLS=6026		/LOAD PUNCH BUFFER SEQUENCE
>/END OF IFNZRO PTPN

IFNZRO PLTN <		/PLOTTER IOT'S - XY8/E
	PLTCEN=6500		/CLEAR INTERRUPT ENABLE
	PLTSKF=6501		/SKIP ON PLOTTER FLAG
	PLTCLF=6502		/CLEAR PLOTTER FLAG
	PLTPUP=6503		/PEN UP
	PLTLLR=6504		/LOAD DIRECTION REGISTER
	PLTPDN=6505		/PEN DOWN
	PLTLCF=6506		/LOAD DIRECTION REGISTER AND CLEAR FLG
	PLTSEN=6507		/SET INTERRUPT ENABLE
>/END OF IFNZRO PLTN
	LISTOG	Z

		/IOTS FOR DP8E SYNCHRONOUS LINE INTERFACE
	DPSGTT=6405		/TRANSMIT GO
	DPSGRR=6404		/RECEIVE GO
	DPSSCD=6400		/SKIP IF CHAR DETECTED
	DPSCSD=6406		/CLEAR SYNC DETECT
	DPSSRO=6402		/SKIP IF RECEIVE WORD COUNT OVERFLOW
	DPSSTO=6403		/SKIP IF TRANSMIT WORD COUNT OVERFLOWS
	DPSCSI=6401		/CLEAR SYNCHRONOUS INTERFACE
	DPSRTA=6407		/READ TRANSFER ADDRESS REGISTER
	DPSLCC=6412		/LOAD CONTROL
	DPSSRG=6410		/SKIP IF RING FLAG
	DPSSCA=6411		/SKIP IF CARRIER/AGC FLAG
	DPSRS2=6414		/READ STATUS 2
			/ AC00 CARRIER/AGC
			/ AC01 REQUEST TO SEND
			/ AC02 TERMINAL READY
			/ AC03 CLEAR TO SEND
			/ AC04 TEMA 0(TRANSMIT EXTENDED MEMORY ADDRESS)
			/ AC05 TEMA 1
			/ AC06 TEMA 2
			/ AC07 RECEIVE DATA(INV)
	DPSRS1=6415		/READ STATUS 1
			/ AC00 R-RQST	RECEIVE AND TRANSMIT
			/ AC01 T-RQST	BREAK REQUESTS
			/ AC02 SYNC 2	RECEIVED SYNC
			/ AC03 SYNC 1	CHARS
			/ AC04 REMA 0
			/ AC05 REMA 1
			/ AC06 REMA 2
			/ AC07 MODEM READY
	DPSLFL=6413		/LOAD FIELD
	DPSSBE=6416		/SKIP ON BUS ERROR
	DPSRCD=6417		/READ CHAR DETECTED(IF AC0=0)

/FOLLOWING ARE IOTS FOR DP8-EP(KG8-EA) REDUNDANCY CHECK OPTION
/	6110		/TEST VRC AND SKIP
	BCCRDH=6111		/READ HIGH ORDER PORTION OF BCC INTO AC
	BCCRDL=6112		/READ LOW ORDER PORTION OF BCC INTO AC
/	BCCVRC=6113		/COMPUTE VRC CHARACTER
	BCCGEN=6114		/GENERATE BCC
	BCCLCL=6115		/LOAD CONTROL REGISTER FROM AC
			/ AC05=1: CRC; AC05=0: LRC
			/ AC6-8=0: 16BIT BCC
			/ AC6-8=1: 12BIT BCC
			/ AC6-8=2:  8BIT BCC
			/ AC6-8=3:  7BIT BCC
			/ AC6-8=4:  6BIT BCC
			/ AC9=0: PARITY TO AC4; AC9=1:PARITY TO AC11
			/ AC10=1: 6114 ALSO CAUSES 6113
			/ AC11=1: 6114 ALSO CAUSES 6110
	BCCCLR=6116		/CLEAR ACCUMULATION
/	6117		/MAINTENANCE TEST CLOCK
/THE FOLLOWING EQUATES ARE USED WHEN THE CHUNK 
/FIELD IS LOCATED IN FIELD 2
	RCKFLD=6221		/SET DATA FIELD TO 2,CHUNK AND REC FIELD
	TABFLD=6211		/SET DATA FIELD TO 1; TRANSMIT AND TABLE FIELD
/PAGE 0 INSTRUCTIONS

FIELD 0

INTRAP=0		/TRAP TO FIELD 0 LOC 0 ON AN INTERRUPT

*1
	DCA	INSVAC	/SAVE AC
	CDFCNK		/INTERRUPTS SET DF = 0

IFNZRO CDRN <
	CDRSF		/SKIP ON CARD READER COLUMN READY
	  JMP	SCHAIN	/NOT CARD READ - SO GO FIND WHAT
	JMP	ICDRD0	/GO READ COLUMN
>/END OF IFNZRO CDRN

IFZERO CDRN <
	JMP	SCHAIN	/GO FIND WHAT INTERRUPTED
>/END OF IFZERO CDRN

INSVAC,	0		/SAVE INTERRUPTED AC HERE
INRCPV,	0		/PIVOT FOR DP01 INPUT

/AUTOINDEX REGISTERS
*10

BUGGER,	0

TIQPTR,	0		/POINTER TO PUT TTY CHARS INTO THE INPUT QUEUE
TIQTKR,	0		/POINTER TO TAKE TTY CHARS OUT OF INPUT QUEUE
AUTO1,	0		/MISC AUTOINDEXER FOR NON-INTERRUPT LEVEL CODE
IAUTO1,	0		/MISC AUTOINDEXER FOR INTERRUPT LEVEL CODE
IAUTO2,	0		/	DITTO

SECFLG,	0		/SET NONZERO ONCE PER SECOND
CLKFLG,	0		/SET NONZERO WHEN CLOCK GOES OFF

FIRFRE,	0		/POINTER TO FIRST FREE CHUNK
FRECNT,	0		/COUNT OF FREE CHUNKS
FIRADR,	FIRCNK		/ADDRESS OF FIRST FREE CHUNK ########

TEMP1,	0		/TEMPORARY LOCATION FOR NONINTERRUPT LEVEL CODE
TEMP2,	0
TEMP3,	0
TEMP4,	0
TEMP5,	0
TEMP6,	0
TEMP7,	0
TEMP8,	0
TEMPA,	0		/ADDITIONAL TEMPS
TEMPB,	0
TEMPC,	0
TEMPD,	0
INTMP1,	0		/TEMPORARY LOCATION FOR INTERRUPT CODE
INTMP2,	0		/	DITTO
INTMP3,	0		/	DITTO
INTMP4,	0		/	DITTO
INTMP5,	0		/	DITTO
INTMP6,	0		/	DITTO
INTMP7,	0		/	DITTO

CRC1,	0		/FIRST HALF OF CRC-16
CRC2,	0		/2ND HALF OF CRC-16

INTDDB,	0		/ADDRESS OF CURRENT DEVICE BLOCK
IDBSTS,	0		/ADDRESS OF DEVSTS FOR INTDDB
DDB,	0		/ADDRESS OF CURRENT DEVICE BLOCK
DDBSTS,	0		/ADR OF DEVSTS

INTDIS,	NL0		/CLEAR AC & LINK
	TAD	INSVAC	/RESTORE AC
	RMF		/RESTORE DATA FIELD,INSTR FIELD
	ION
	JMP I	INTRAP	/RETURN TO INTERRUPTED PROCESS

ERRFLG,	0		/WHEN AN ERROR OCCURS PUT ADR OF MSG HERE
INTCNT,	0		/WATCHDOG FOR UNRECOGNIZED INTERRUPTS

WRKREQ,	0		/-1 WHEN INTERRUPT LEVEL HAS LEFT WORK FOR NON-INTERRUPT LEVEL
GFLG,	0		/FLAG USED TO TELL XMT A GOTO ACCEPT 

IFNZRO CDRN <
CDREXT,	0		/**DECSYNC**SLOT TO PUT TRAILING PARTS OF CARDS
			/**DDCMP**ADR OF COUNT FIELD
CDRNXT,	0		/POINTER TO BEGINING OF CURRENT CARD
CDRADR,	0		/POINTER INTO STRING BEING FILLED
CDCCNT,	0		/COMPRRESED CHAR COUNT
CDCCHR,	0		/LAST CARD COLUMN
>/END OF IFNZRO CDRN

IFNZRO LPTN <
LPTCCH,	0		/CHAR WE ARE UNCOMPRESSING
LPTCCN,	0		/COUNT OF CHARS TO UNCOMPRESS
LPTCNT,	0		/COUNT OF CHARS IN CHUNK STRING
LPTCOL,	0		/CURRENT OUTPUT COLUMN
LPTOCH,	0		/CHAR TO PRINT LATER
LPTZCT,	0		/REP COUNT AFTER TIMEOUT
LPTOPV,	0		/LAST VALUE OF PIVOT
LPTCHR,	0		/LAST CHAR OUTPUT TO LPT
LPTRCT,	0		/REPETITION COUNT FOR LPT CHARS(MAKES TABS ETC)
LPTLNE,	0		/INDEX TO LPTVFU
LPTHNG,	LPTHN1		/PUT OUT A CR TO LEFT JUSTIFY THE PRINTER
	LPTHN2		/PUT OUT SPACES TO GET INTO RIGHT COLUMN
>/END OF IFNZRO LPTN

RCVTKR,	0		/RECEIVED MESSAGE TAKER
RCVPTR,	0		/RECEIVED MESSAGE PUTTER

STACKF,	0		/-2 MEANS SENDING STARTS
			/ -1 MEANS NEED TO SEND A STACK
			/ 0 MEANS DOWN(NO ICM)
			/ 1 MEANS HAVE RECEIVED ICM
NAKFLG,	0		/IF NONZERO REASON TO SEND A NAK MESSAGE
RECVOK,	0		/LAST MESSAGE # RECEIVED OK
			/ SIGN BIT MEANS SEND ACK
REPTCK,	0		/TIMER FOR REPS
			/ 0 MEANS SEND A REP
T10FLG,	0		/TRANSMITTER STATE
			/	-2	MESSAGE READY TO GO
			/	-1	ACTIVE
			/	0	IDLE
			/	+1	SYNCH
CNTPNT,	0		/POINTER TO CHUNK COUNTER
T10AKR,	0		/POINTER TO LAST ACKED TO 10 REQUEST
			/ T10AKR, T10TKR, & T10PTR ARE ALWAYS LEFT
			/ SO THEY CAN BE USED WITHOUT CHECKING 1ST
T10LAN,	0		/LAST MESSAGE # TO 10 ACKED BY 10
T10TKR,	0		/POINTER TO TAKE TO 10 REQUESTS FROM QUEUE
T10HSN,	0		/HIGHEST MSG # SENT TO 10
T10PTR,	0		/POINTER TO PUT TO 10 REQUESTS INTO QUEUE

T10NCA,	0		/ADR OF NEXT BUFFER TO SEND
T10NWC,	0		/WC FOR NEXT BUFFER TO SEND
T10CLK,	0		/ISZ'ED BY CLOCK INTERRUPTS

F10TWC,	0		/TOTAL WC(POSITIVE) FOR DATA IN NUMBERED MSGS

RSNA,	0		/STORE SNA FIELD
RNCT,	0		/STORE NCT FIELD
RNOD,	0		/NODE NUMBER OF OTHER END OF LINE
DISSNA,	0		/FOR DISCONNECT
DISSLA,	0
DISREA,	0
DMPCHR,	DMPCTY		/WORD SET BY EITHER DMP000 OR CTYEXC
/DP8E USES LOC AT 7720-7731
	*7720
F10TCH,	ZBLOCK	4	/4 SPECIAL CHARS TO WATCH FOR ON INPUT
			/ SET UP BY SYSCHK
F10WC,	0		/WORD COUNT FOR MESSAGES FROM 10
F10CA,	0		/CURRENT ADDRESS FOR MESSAGES FROM 10
	0
T10WC,	0		/WORD COUNT FOR MESSAGES TO 10
T10CA,	0		/CURRENT ADDRESS FOR MESSAGES TO 10
	0
/ALL GOOD PDP8 PROGRAMS BEGIN AT ADDRESS 200

*200
DC72,	JMP	INIALL

/HERE TO DUMP SYSTEM ONTO LPT
DUMP,	CIF	10	/DUMP PROGRAM ASSEMBLED IF FIELD 1
	JMP	DUMPI
	VEDIT			/SOFTWARE VERSION NUMBER
DMPAC,	0			/AC WHEN AUTODUMP BEGAN
DMPLNK,	0			/FOR 8I'S THIS IS LINK
				/ FOR 8E'S THIS IS LINK AND OTHER FLAGS
DMPTRP,	0			/JMS HERE FOR AN AUTODUMP
	DCA	DMPAC		/SAVE AC
	GTF		/LOAD FLAGS AND LINK TO AC
	AND	(7770		/LOW ORDER BIT DUMMY INST FIELD
	DCA	DMPLNK		/SAVE LINK
	CAF		/STOP THE WORLD
DMP2,	TAD	(DMPMSG-1		/TELL OPR WE ARE DIEING
	JMS	CTYEXC
	TAD	DMPLNK		/OUTPUT INS FIELD
	AND	[0007
	TAD	[0060
	JMS I	DMPCHR
	TAD	DMPTRP
	DCA	DMPWRD		/SAVE WORD TO DUMP
	JMS	DMPWDC
	JMS	DMPWDC
	JMS	DMPWDC
	JMS	DMPWDC
/DEFAULT ACTION WHEN STATION CRASHES IS TO JUMP TO ROM FOR RELOAD
IFNDEF DELROM <
	CIF	70
	JMP	0	/JUMP TO ROM IN FIELD 7
>/END OF IFNDEF DELROM
/CAN OVERRIDE ROM RESTARTING WHEN SYSTEM CRASHES BY DEFINING
/DELROM=1 IN C.PAL FILE
IFDEF DELROM <
	7402
	JMP	DUMP
>/END OF IFDEF DELROM
DMPWDC,	0
	TAD	DMPWRD
	RTL
	RAL
	DCA	DMPWRD
	TAD	DMPWRD
	RAL
	AND	[0007
	TAD	[0060
	JMS I	DMPCHR
	JMP I	DMPWDC

DMPWRD,	0

/HERE TO TYPE A MESSAGE ON CTY
/ ONLY USED WHEN STATION NOT RUNNING
CTYEXC,	0
	DCA	DMPWRD
	TAD	(DMPCTY
	DCA	DMPCHR
	CDFCNK
CTYEX3,	ISZ	DMPWRD
	TAD I	DMPWRD
	JMS I	DMPCHR
	TAD I	DMPWRD		/GET CHAR AGAIN
	SMA CLA			/ALL DONE ?
	  JMP	CTYEX3		/NO
	CDFINS
	JMP I	CTYEXC
DMPCTY,	0
	CTYTLS
	CTYTSF
	JMP	.-1
	NL0
	JMP I	DMPCTY
DELTB,		/DELETE NODE FROM NEI TABLE
	NL0
	TAD	(NEITAB-1
	DCA	TEMPB
DEL2,	ISZ	TEMPB
DEL2B,	TAD I	TEMPB
	SNA
	JMP	RCVFLU
	AND	(2000
	SNA CLA
	JMP	DEL1
	TAD	(5777
	AND I	TEMPB
	DCA I	TEMPB
	JMP	DEL2
/DEL ENTRY
DEL1,	TAD	TEMPB
	DCA	TEMP1
	NL1
	TAD	TEMPB
	DCA	TEMP2
DEL3,	TAD I	TEMP2	/MOVE UP 1 LOC
	SNA
	JMP	DEL2A	/CONTINUE SCAN
	DCA I	TEMP1
	ISZ	TEMP1
	ISZ	TEMP2
	JMP	DEL3
DEL2A,	DCA I	TEMP1
	JMP	DEL2B
/RECEIVE A STATION CONTROL GOTO 
/PROCESS ONLY ONE AT A TIME
RGOTO,	JMS	BTSCN	/SETUP IN CASE NEED A REJECT
	TAD	GTTAB
	SZA CLA		/SEE IF A GOTO PENDING
	JMP	RJT
	TAD I	TEMPB	/GET DNA
	DCA	GTTAB
	TAD	(15
	DCA	GTTAB+1	/SET A GOTO ACCEPT
	TAD	(GTTAB+2
	DCA	TEMPA	/SET UP ADDRESS IN TEMPA FOR RADR
	JMS	RADR
	DCA I	TEMPB	/FREE LOC IN BTTAB
	JMP	RCVFLU
/RECEIVE EXAMINE DEVICE CTRL MSG HALF HERE DUR TO CORE PROB
RCVEX,	JMS	BTSCN	/SCAN PLACE IN BOOT TABLE
	TAD	(12
	DCA I	TEMPA
	JMP	RCVE
/LOGIC TO TRY TO EST CONNECTION 
/BROKEN UP DUE TO PAGE LIMITS
CONFD1,	AND	(4777
	TAD	(3000
	DCA I	DDBSTS
	JMP	CONDN

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		INITIALIZATION				***
/	***							***
/	***********************************************************
/	***********************************************************


/HERE TO RESTART PROGRAM
INIALL,	IOF			/DISABLE INTERRUPTS

	NLM2
	DCA	STACKF		/FLAG TO SEND A START
INISUM,
/HERE TO INITIALIZE SOME OF STATION STUFF

	CDFCNK
				/ WILL BE A NOP
INICIF,	CIF	20			/ CHANGE INSTRUCTION FIELD	########
INIJMP,	JMP I	(SYSCHK		/GO PERFORM SYSCHK		########
				/ CHANGED TO CAF(OR 0) BY SYSCHK


/HERE TO INITIALIZE THE CLOCK
	NL1
	CLKECI			/RESET CLOCK

/HERE TO INITIALIZE THE COMMUNICATIONS FLAGS
	DCA	REPTCK

/HERE TO INITIALIZE FROM 10 FLAGS
	TAD	(RCVQUE
	DCA	RCVPTR
	TAD	(RCVQUE
	DCA	RCVTKR

/HERE TO INITIALIZE TO 10 FLAGS
	TAD	(T10BF1
	DCA	T10AKR
	DCA	T10LAN		/LAST ACKED POINTER
	TAD	(T10BF1
	DCA	T10TKR		/LAST SENT POINTER
	TAD	(T10BF1+T10LEN
	DCA	T10PTR		/HIGHEST SENT POINTER
	NL1
	DCA	T10HSN		/HIGHEST MSG# SENT
	NL2			/FOR BCC
	TAD I	(NCLNID		/GET NODE-ID MSG SIZE
	NEGATE			/MAKE ISZ COUNTER
	DCA	TEMP2		/SAVES COUNTER
	TAD	(NCLNID		/POINT TO NODE ID MESSAGE
	DCA	IAUTO1		/SET UP POINTER TO MESSAGE
	TAD	(T10BF1+7
	DCA	AUTO1		/POINTER TO BUFFER
INIDD3,	TAD I	IAUTO1
	DCA I	AUTO1		/PUT NEXT CHAR INTO BLOCK
	ISZ	TEMP2
	  JMP	INIDD3		/LOOP BACK FOR REST
	TAD I	(NCLNID		/GET SIZE OF NODE-ID MSG
	DCA I	(T10BF1+1	/SET COUNT IN MSG
	DCA I	(T10BF1+2	/CLEAR HIGH ORDER COUNT
	NL1
	DCA I	(T10BF1+4	/SET MESSAGE NUMBER
	TAD	(-DEVN
	DCA	TEMP1
	TAD	(RCVDSP
	DCA	AUTO1
	TAD	(CTRLTB-1
	DCA	IAUTO1
	TAD	(SNATAB-1	/POINT TO NODE TABLE
	DCA	IAUTO2		/PUT INTO AUTOINDEX REGISTER
INIDD4,	TAD	(RCVKRD		/GET UNUSED DISPATCH ENTRY
	DCA I	AUTO1		/STORE AT RCVDSP
	DCA I	IAUTO1		/ZERO DDB FIELD
	DCA I	IAUTO2		/ZERO NODE FIELD
	ISZ	TEMP1		/UP COUNTER
	  JMP	INIDD4		/CONTINUE IF NOT EXPIRED
/INITIALIZE MCR TABLE
	TAD	(NEITAB-1
	DCA	AUTO1
	DCA	GFLG		/INIT GOTO FLAG
/TABLES ARE CONTIGUOUS
	TAD	(-NEILEN-1-BTLEN-1-GTLEN
	DCA	TEMP1
	DCA I	AUTO1
	ISZ	TEMP1
	JMP	.-2
	JMP	FUG		/GO ON WITH INITIALIZATION
INIDDB,	0
	ISZ	TEMP6		/ADVANCE DEVICE NUMBER
	TAD	TEMP6		/GET NEW DEVICE NUMBER
	JMS	GETDDB		/GET DEVICE BLOCK ADR AND SET UP DDBSTS
	DCA	AUTO1
 TAD	(1-DEVLNK 	/CLEAR ONLY PORTION
	DCA	INTMP1
INIDD0,	DCA I	AUTO1		/ZERO DEVICE BLOCK
	ISZ	INTMP1
	  JMP	INIDD0
	ISZ	AUTO1		/SKIP LINK
	TAD I	DDB
	AND	(7700
	DCA I	DDB
	TAD	(DEVRCN		/ZERO DEVRCN ON INITIALIZATION
	TAD	DDB
	DCA	INTMP1
	DCA I	INTMP1
	JMP I	INIDDB
/RECEIVE CONFIGURATION MESSAGE
/
RCVCFG,	JMS	GETCHR
	JMP	RCVFLU
	SNA CLA
	JMP	RCVFND	/MCR FOUND
	IFDEF FTOLDC	<	JMS	GTCHR	/IF BIT PATTERN SENT IN CONF MSG EXT FIELD GREATER THAN 2 WORDS
	AND	(200
	SZA CLA
	JMP	.-3
>/END OF IFDEF FTOLDC
IFNDEF FTOLDC <
	JMS	GETEXN	/BYPASS NDV
>/END OF IFNDEF FTOLDC
	JMS	GETEXN	/BYPASS PID
	JMP	RCVCFG
RCVFND,	TAD	RSNA
	NEGATE
	JMS	NETSCN	/LOOK FOR NODE IN NEIGHBORS TABLE
	TAD	RSNA	/NF RETURN
	TAD I	TEMPB	/F RET
	AND	(777
	TAD	(1000	/MASK AS MCR NODE
	JMP	NETAD	/ADD AC TO TABLE
/FIELD 0 CALL FOR FRECKS CALL FROM FIELD 1
FRC,	JMS	FRECKS	/[1(23)]
	CIF	10	/[1(23)]
	JMP	FREC1	/[1(23)] RETURN TO FIELD 1
	PAGE
IFNZRO TTYN <
INTMTX,	CIF	30	/JUMP TO MODEM LOGIC FOR KL8A'S
	JMP	INTMTY	>/END OF IFNZRO TTYN
FUG,


/HERE TO INITIALIZE THE SYNCHRONOUS LINE
	DCA	INRCPV		/MIGHT BE USEFUL ON A RESTART
	DCA	NXTDDB	/INITIALIZE ROUND ROBIN FOR SCHED XSTART
	JMS	INISYN
	JMP	INIDP9

/HERE TO INITIALIZE THE SYNCHRONOUS INTERFACE WHEN STATION RESTARTS
/ AND ALSO HERE WHEN TRANSMITTER TIMES OUT
INISYN,	0
	TAD	(CTLSIZ-1	/POINT TO CHUNKS
	TAD	RCVPTR		/POINT THIS MESSAGE
	DCA	TEMP1
	TAD	INRCPV		/GET STATE OF RECEIVER
	TAD	(-INRC70	/CHECK TO SEE IF RECEIVING NUMBERED MESSAGE
	RCKFLD
	SNA CLA			/SKIP IN WE DON'T HAVE CHUNKS IN LIMBO
	  TAD I	TEMP1		/GET ADR OF FIRST CHUNK
	TABFLD
	DCA	TEMP1		/SAVE ADR OF FIRST CHUNK(OR ZERO)
	DPSCSI			/CLEAR INTERFACE
	Z=2100		/REC FIELD-2,TRANSMIT FLD=1
	TAD	(Z
	DPSLFL			/SET FIELD FOR RECEIVE AND XMT BUFFERS
	TAD	(5400-Z
	DPSLCC			/LOAD CONTROL REGISTER
	NL0
	TAD	(SYNBUF-1	/STRING OF 4 SYNCHS
	CDFINS			/WC AND CA ARE IN FIRST FIELD
	DCA I	[T10CA
	TAD	(-4
	DCA I	[T10WC
	NLM3
	DCA	T10CLK
	JMS I	[INRCID		/SET RECEIVER TO IDLE MODE
				/ AND SET DATA FIELD TO CHUNK FIELD
	NL1
	DCA	T10FLG		/TRANSMITTER IS TRYING TO SYNCH LINE
	DPSGTT			/TRANSMIT GO
	DPSGRR			/AND RECEIVE GO
	TAD	TEMP1		/GET CHUNK ADR TO FREE(IF ANY)
	SZA
	  JMS	FRECKS
	JMP I	INISYN

INIDP9,

/HERE TO INITIALIZE THE CHUNKS
	DCA	FIRFRE		/NO FREE CHUNKS YET
	DCA	FRECNT		/COUNT OF FREE CHUNKS

	TAD	FIRADR		/GET FIRST CHUNK ADDRESS
	DCA	INTMP2
INICNK,	TAD	INTMP2
	JMS	IFRCNK		/PUT CHUNK INTO FREE LIST
	TAD	INTMP2		/GET LAST CHUNK ADR
	TAD	[CNKSIZ		/ADVANCE 1 CHUNK
	DCA	INTMP2		/SAVE NEW CHUNK ADR
	TAD	INTMP2
	Z=7760
	TAD	(-Z
	SZA CLA
	  JMP	INICNK
/HERE TO INITIALIZE ALL DEVICES AT STATION
	NLM1			/START AT DDBTAB
	DCA	TEMP6		/SAVE DEVICE NUMBER

/INITIALIZE THE TTY INPUT CHAR QUEUE
	TAD	(TTIQUE-1
	DCA	TIQPTR
	TAD	(TTIQUE-1
	DCA	TIQTKR

/HERE TO INITIALIZE THE TTYS

	TAD	(-1-TTYN	/COUNT OF CTY & TTYS
	DCA	TEMP8		/INITIALIZE TTY COUNTER
INITT0,	JMS	INITTY
	ISZ	TEMP8		/HAVE WE DONE ALL THE TTY'S ?
	  JMP	INITT0		/NOT YET SO KEEP GOING
IFNZRO TTYN <

	JMS	KL8I 
>/END OF IFNZRO TTYN
INICDR,
IFNZRO CDRN <
/HERE TO INITIALIZE THE CDR
	DCA	CDRNXT		/NO CARD READY TO GO
	JMS	INIDDB		/INITIALIZE DEVICE BLOCK
>/END OF IFNZRO	CDRN

IFNZRO LPTN <
/HERE TO INITIALIZE THE LPT
/INILPT,	JMS	INIODB		/INITIALIZE DDB
INILPT,	JMS	INIDDB
	TAD	(OUTBIT
	DCA I	DDBSTS
	DCA	LPTCCN		/NO COMPRESSED CHAR COUNT YET
	DCA	LPTCNT		/NO CHARS IN CHUNK STRING
	DCA	LPTCOL		/WE ARE AT LEFT HAND MARGIN
	TAD	(LPTVFU-1	/INDEX TO VFU
	DCA	LPTLNE		/WE ARE AT TOP OF FORM
	TAD	(SKP
	CDFINS			/WE ARE CHANGING AN INSTRUCTION
	DCA	LPTPIV
	CDFCNK
	TAD	[LPTCHK
	DCA I	[LPTBLK+DEVCHK	/STORE CHUNK COUNT
>/END OF IFNZRO LPTN

INIPTR,
IFNZRO PTRN <
/HERE TO INITIALIZE THE PTR
	JMS	INIDDB
>/END OF IFNZRO	PTRN

PTPINI,
IFNZRO PTPN <
/HERE TO INITIALIZE THE PTP
	JMS	INIODB
>/END OF IFNZRO PTPN

INIPLT,
IFNZRO PLTN <
/HERE TO INITIALIZE THE PLT
	JMS	INIODB
>/END OF IFNZRO PLTN


	JMP	LOOP

/HERE TO INITIALIZE A TTY BLOCK
INITTY,	0
	JMS	INIDDB
	TAD	(4000+TTYBIT+OUTBIT+STSBIT
	DCA I	DDBSTS		/SET INITIAL TTY STATUS WORD
	ISZ	AUTO1		/SKIP LDBADR
	DCA I	AUTO1		/SET LDBCOL
	ISZ	AUTO1		/SKIP LDBWID
	TAD	(RSTMSG-1
	DCA I	AUTO1		/SET LDBXPT
	DCA I	AUTO1		/CLEAR LDBFPT
	DCA I	AUTO1		/SET LDBCHR
	DCA I	AUTO1		/	"	LDBIPT
	NLOAD	DEVCHK
	TAD	DDB
	DCA	TEMPA
	TAD	[TTYCHK
	DCA I	TEMPA		/STORE OUTPUT CHUNK LIMIT
	JMP I	INITTY

SECOND,	DCA	SECFLG
	NL6000		/LIMIT # OF SPURIOUS INTRPS
	DCA	INTCNT
	JMP	SECDP
PAGE
DPSTS1,	0
DPSTS2,	0
/CHECK MODEM FOR SYNCHR LINE ONCE PER SECOND
SECDP,	DPSRS1
	DCA	DPSTS1
	DPSRS2
	DCA	DPSTS2
/	JMP	IRMA
/IRMA CATCHER
/ COME HERE ONCE PER SECOND
/ IF A TTY IS ACTIVELY OUTPUTING SET IRMA BIT IN LDBSTS UNLESS
/ IRMA BIT IS STILL ON FROM LAST TIME, IN WHICH CASE TTY HAS LOST XMT SO FAKE ONE
	DTR=1000		/DATA TER READY BIT IN DEVDDC
/CHECK DATA SET CARRIER ONCE PER SECOND

IRMA,	 		/START WITH CTY
	DCA	TEMP5
IRMA1,	TAD	TEMP5		/GET NUMBER OF NEXT DEVICE
	JMS	GETDDB		/GET ADDRESS OF BLOCK FOR THIS DEVICE
	IOF			/IN CASE OF XMT INTERRUPTS
	DCA	INTDDB		/SAVE ADR OF DEVICE BLOCK
/CHECK CARRIER SIGNAL ON DATA SET LINES
	TAD	(DEVDSL
	TAD	INTDDB
	DCA	INTMP6	/SAVE FOR FUTURE REF
	TAD I	INTMP6	/CHECK TO SEE IF DATA SET
	SMA CLA		
	JMP	IRM1	/NOT DATA SET
	TAD	(LDBADR
	TAD	INTDDB	/GENERATE ADDRESS OF HARDWARE INST
	DCA	INTMP2
	TAD	TEMP5		/GET TTY NO
	AND	(3
	TAD	(TALN		/GET ADDRESS OF CARRIER MASK BITS FOR  TTY LINES
	DCA	INTMP5		/SAVE ADDRESS
	TAD	TEMP5		/GET TTY NO
	AND	(3
	SZA CLA			/CHECK FOR LINE 3
	JMP	IRM6		/LINES 0,1, OR 2
	TAD I	INTMP2		/HARDWARE ADDRESS
	AND	(7770
	TAD	(17
IRM6A,	DCA	INST1
	TAD I	INTMP6
	NEGATE
	DCA	INTMP7	/SAVE FOR LATER COMPARISON
	TAD I	INTMP6
	AND	(40	/SEE IF DTR ON
	SNA CLA		/NOT ACTIVE
	JMP	IRMC		/TREAT AS LOCAL LINE
INST1,	0
	AND I	INTMP5	/CARRIER MASK TABLE
IRM7,	SZA CLA		/CARRIER GONE?
	JMP	IRMB	/NO, SEE IF JUST COME ON
	ISZ I	INTMP6	/INCRE COUNTER 6 SEC
	TAD	(7
	AND I	INTMP6		/CARRIER LOST FOR 6 SEC?
	SZA CLA
	JMP	IRM1	/NO
IRMC,	TAD I	INTMP6
	AND	(7637	/TURN CARRIER DTR BIT OFF AND INIT COUNT
	DCA I	INTMP6
	NL1
	AND	INST1
	SNA CLA		/CHECK FOR LINE 3
	JMP	IRMA2
	TAD	INST1
	AND	(7771
	DCA	.+1
	0
	JMP	IRMA2
IRM1B,	TAD I	INTMP6	/GET DEVDSL
	AND	(7760	/INIT COUNT
	TAD	(2
	DCA I	INTMP6
IRM1,	TAD I	DDBSTS
	SMA			/IS DEVICE ACTIVE ?
	  JMP	IRMA7		/NO
	AND	[TTYBIT
	SNA CLA			/IS DEVICE A TTY ?
	  JMP	IRMA9		/NO SO DONE
	TAD	(DEVTIM		/RELATIVE ADR OF FILLER TIMER
	TAD	INTDDB		/MAKE ABSOLUTE
	DCA	INTMP1		/SAVE POINTER TO FILLER
	TAD I	INTMP1		/GET FILL TIMER
	SZA CLA			/SKIP IF FILLING
	  JMP	IRMA7
	NLOAD	IRMBIT		/MASK FOR IRMA BIT
	AND I	DDBSTS		/GET BIT FROM OLD STATUS
	SZA CLA			/SKIP IF WE LOST AN XMTINT
	  JMS	XMTINT		/FAKE A XMT INTERRUPT
	NLOAD	IRMBIT		/GET BIT FOR IRMA

	TAD I	DDBSTS		/PUT INTO STATUS WORD
	DCA I	DDBSTS
IRMA7,	ION
	NL0
	ISZ	TEMP5		/ADVANCE 1 DEVICE
	TAD	TEMP5
	TAD	[-DEVN
	SZA CLA
	  JMP	IRMA1
IRMA9,	JMP	LOOP		/ALL DONE
IRM6,	TAD I	INTMP2	/GENERATE HARDWARE ADDRESS FOR LINE 0-2
	AND	(7770
	TAD	(2
	JMP	IRM6A
IRMB,	TAD I	INTMP6
	AND	(100	/WAS CARRIER ON
	SZA CLA
	JMP	IRM1B
	TAD	(100	/NO TURN IT ON AND SEND TO 10
	TAD I	INTMP6
	DCA I	INTMP6
/ONLY SEND STATUS IF CHANGED
IRMA2,	TAD I	INTMP6	/NEW VALUE 
	TAD	INTMP7
/DON'T WANT TO ISSUE STATUS WHEN NOT CHANGED
/SEC COUNTER SHOULD NOT  CONFLICT AS 
/IF THAT IS CHANGED MORE THAN LIKELY DTR CAR HAS CHANGED TOO
	SNA CLA
	JMP	IRM1B	/DTR OR CARRIER NOT CHANGE
	NL7776
	AND I	DDBSTS
	IAC
	DCA I	DDBSTS
	JMP	IRM1B
	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DESCRIPTION				***
/	***							***
/	***********************************************************
/	***********************************************************
IFNZRO 0 <


SYNCHRONOUS OUTPUT:
 A SIM IS ALWAYS IN ONE OF FOUR STATES:
	T10FLG=-2	MESSAGE READY TO TRANSMIT
	T10FLG=-1	MESSAGE IS BEING TRANSMITTED
	T10FLG=0	LINE IS SENDING IDLES
	T10FLG=1	LINE IS SENDING SYNCS
 WHEN T10FLG IS -2 T10NWC(T0 10 NEXT WORD COUNT) AND T10NCA(TO 10 NEXT
 CURRENT ADDRESS) DESCRIBE THE NEXT MESSAGE.

SYNCHRONOUS INPUT:
 THE SIM IS ALWAYS IN ONE OF THREE STATES:
	A.)	IDLE
	B.)	RECEIVING A UNNUMBERED MESSAGE(ACK, NAK, ETC.).
	C.)	RECEIVING NUMBERED MESSAGE DATA.
 THE STATE IS SET BY THE PM BY SETTING INRCPV TO BE:
	A.)	INRC10
	B.)	INRC20
	C.)	INRC70
 WHEN THE SIM IS IN STATE C, AND ONLY THEN, INCOMING CHARS ARE PLACED
 IN CHUNKS RATHER THAN A FIXED BUFFER.
 THE SIM USES F10WC AND F10CA TO STORE THE DATA.
 WORD COUNT OVERFLOWS WILL CAUSE THE SIM:
	A.)	RESETS TO JUNK BUFFER
	B.)	TRANSFERS TO INTP40
	C.)	TRANSFERS TO INTP60
 WHEN THE RECEIVER IS IDLE AND ONE OF THE FOUR CHARS AT F10TCH IS
 FOUND IN AN INPUT STREAM THE SIM NOTIFIES THE PM BY BRANCHING TO:
	INTP00		WHEN FINDS CHAR AT F10TCH
	INTP10		WHEN FINDS CHAR AT F10TCH+1
	INTP20		WHEN FINDS CHAR AT F10TCH+2
	INTP30		WHEN FINDS CHAR AT F10TCH+3
 WHEN THE RECEIVER IS IN STATE B THE PM IS NOT NOTIFIED OF SPECIAL
 CHARS.
 WHEN THE RECEIVER IS IN STATE C THE SIM WILL NOTIFIY THE PM
 OF SPECIAL CHARS BY JMPING TO INTP70(CHAR IN INTMP1, ADR IN INTMP5);
 WHEN THE PM IS DONE WITH THE CALL TO INTP70 IT WILL RETURN TO INRC80.
>/END OF IFNZRO 0
/HERE AT INTERRUPT LEVEL WHEN RECEIVER HAS FOUND A SOH
INTP00,	TAD	(-7 		/HEADER IS ALWAYS 8 CHARS
	JMS	INTP41
	TAD	(INRC70		/WE ARE NOW RECEIVING NUMBERED MSG DATA
	DCA	INRCPV		/SET SIM MODE

	TAD	RCVPTR		/GET ADR OF MESSAGE HEADER
	RCKFLD
	JMS	GETLEN		/GET LENGTH OF MESSAGE
	TAD	(0002		/FUDGE FOR CRC
	DCA	F10TWC
	DCA	INTMP1		/INITIALIZE FOR INRC80
	TAD	(0010 		/DISPLACEMENT TO CHUNK COUNTER
	TAD	RCVPTR		/ADD TO START OF BUFFER
	DCA	INTMP2		/SAVE CHUNK COUNTER ADDRESS
	TAD	INTMP2		/GET CHUNK COUNTER ADDRESS
	DCA	CNTPNT		/STORE FOR INRC80
	DCA I	INTMP2		/CLEAR CHUNK COUNTER
	ISZ	INTMP2		/SKIP OVER CHUNK COUNTER TO LINK TO CHUNKS
	DCA I	INTMP2		/CLEAR LINK TO 1ST CHUNK
	TABFLD
	JMP	INRC80


INTP20,			/SHOULDN'T HAPPEN
INTP30,			/SHOULDN'T HAPPEN !
/HERE AT INTERRUPT LEVEL WHEN RECEIVER DETECTS BEGINING OF UNNUMBERED MESSAGE = ENQ
INTP10,	TAD	(-7		/UNNUMBERED MESSAGES ARE ALWAYS 8 CHAR LONG

INTP31,	JMS	INTP41		/WAIT FOR REST OF MESSAGE FROM DECSYSTEM-10
INTP33,	NLM1
	DCA	WRKREQ		/SO NON-INTERRUPT LEVEL CODE WAKE UP
	TAD	(CTLSIZ		/ADVANCE TO NEXT CTL BUFFER
	TAD	RCVPTR
	TAD	(-RCVLIM
	SNA
	  TAD	(RCVQUE-RCVLIM
	TAD	(RCVLIM
	DCA	RCVPTR
	TAD	RCVPTR
	NEGATE
	TAD	RCVTKR
	SNA CLA			/DO WE HAVE TOO MANY MSGS READY
	  HLT
	JMS I	[INRCID		/SET RECEIVER TO IDLE STATE
	JMP	INTP42

/HERE AT INTERRUPT LEVEL WITH WC OVERFLOW ON UNNUMBERED MESSAGE
INTP40,	JMP I	INTP41
INTP41,	0
	CDFINS			/NEED TO SET WC AND CA IN FIELD 0
	DCA I	[F10WC		/SAVE LENGTH
	TAD	RCVPTR		/ADR OF BUFFER FOR HEADER
	DCA I	[F10CA		/SET BUFFER ADR FOR RECEIVER
	TAD	(INRC20
	DCA	INRCPV
	CDFCNK			/RESET NORMAL DATA FIELD
INTP42,
	DPSGRR		/ENABLE RECEIVER
	JMP	INTDIS

/HERE AT INTERRUPT LEVEL WITH WC OVERFLOW ON NUMBERED MSG DATA
INTP60=INTP33		/JUST CALL CURRENT MSG DONE


INTP70=INTDIS		/NO SPECIAL CHAR HANDLING IN MIDDLE OF JUNK
/	***********************************************************
/	***********************************************************
/	***							***
/	***			DDCMP				***
/	***							***
/	***********************************************************
/	***********************************************************
/THE PROTOCOL IS DESCRIBED IN FILE DN92.RNO ON THE DISTRIBUTION TAPE 
/SOME OF THE PROTOCOL IS GIVEN BELOW

/MESSAGE PROTOCOL
	SYN=226
	IDLE=SYN		/NO SPECIAL IDLE CHARACTER
	ENQ=005		/1ST CHAR IN UNNUMBERED MESSAGES
	DLE=220		/1ST CHAR IN BOOTSTRAP MESSAGES
	SOH=201		/1ST CHAR IN NUMBERED MESSAGES

/UNNUMBERED MESSAGES
	FILL=000		/FILL CHARACTER
	A0=1		/DESTINATION STATION ADR

/ACK:	ENQ	ACK	FILL	MSG#	FILL	A0	BCC1	BCC2
	ACK=001
/	MSG# IS LAST GOOD MSG RECEIVED

/NAK:	ENQ	NAK	RNAK	MSG#	FILL	A0	BCC1	BCC2
	NAK=002		/NEGATIVE ACKNOWLEDGE
/	RNAK=1	BCC ERROR IN HEADER
/	RNAK=2	DATA BBC INCORRECT
/	RNAK=3	REP RESPONSE
/	RNAK=10	SHORT TERM HIGH LEVEL EXCEPTION
/	RNAK=11	RECEIVER OVERRUN
/	RNAK=20	MESSAGE TOO LONG
/	RNAK=21	HEADER FORMAT ERROR
/	MSG# IS LAST GOOD MSG RECEIVED

/REP:	ENQ	REP	FILL	FILL	N	A0	BCC1	BCC2
	REP=003		/REPLY TYPE
/	N IS THE LAST MESSAGE# SENT

/RESET:	ENQ	RESET	FILL	FILL	N	A0	BCC1	BCC2
	RESET=4		/DC72NP WILL NOT SEND THIS TYPE/WILL RESPOND WITH START

/RESAK:	ENQ	RESAK	FILL	R	FILL	A0	BCC1	BCC2
	RESAK=5		/DC72NP WILL NOT SEND THIS TYPE/WILL RESPOND WITH START

/START:	ENQ	STRT	FILL	FILL	FILL	A0	BCC1	BCC2
	STRT=006		/START TYPE
/	THE NEXT NUMBERED MESSAGE TO BE SENT IS 1

/STACK:	ENQ	STACK	FILL	FILL	FILL	A0	BCC1	BCC2
	STACK=007		/START ACKNOWLEDGE
/	THE NEXT MESSAGE SENT, AND NEXT MESSAGE EXPECTED
/	ARE BOTH 1.

/BOOT:	DLE	CC1	CC2	FILL	FILL	A0	BCC1	BCC2			BOOTDATA	BCC3	BCC4

/DEFINE MACRO USED TO ADJUST TRANSMIT BUFFER POINTERS
DEFINE T10ADJ Q <	XLIST
	TAD	Q
	TAD	(-T10LST	/CHECK FOR LAST BUF
	SNA
	  TAD	(T10BF1-T10LST-T10LEN	/ADJUST IF LAST
	TAD	(T10LEN+T10LST
	DCA	Q		/ADJUST & SAVE NEW VALUE
XLIST	>/END OF T10CHK

MSNMAX=377		/MAXIMUM MESSAGE NUMBER
/HERE TO PROCESS MESSAGE RECEIVED FROM THE DECSYSTEM-10
RCVCHK,	DCA	CRC1
CRCXI1,	DCA	CRC2		/INITIALIZE CRC			########
	TAD	(-6
	DCA	TEMP3		/6 CHARS IN ALL MESSAGES
	NLM1
	TAD	RCVTKR
	DCA	AUTO1		/MESSAGE POINTER
RCVCK2,	RCKFLD
	TAD I	AUTO1
	TABFLD
IFZERO	DP8ETR	<
	JMS	CRCALC		/PUT NEXT CHAR INTO CRC
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCRC		/TRACE AND ACCUM CRC
>/END OF IFNZRO	DP8ETR
	ISZ	TEMP3
	JMP	RCVCK2

IFZERO	DP8ETR	<
	NL4
	TAD	AUTO1
	DCA	TEMP5		/SAVE POINTER TO ADR OF CHUNK STRING
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCR2		/STASH CRC IN TRACE
>/END OF IFNZRO	DP8ETR
	RCKFLD
	TAD I	AUTO1
	NEGATE
	TAD	CRC2		/COMPARE HALF OF CRC
	SZA CLA
	JMP	BADCRC		/BRANCH IF BUM CRC
	RCKFLD
	TAD I	AUTO1
	NEGATE
	TAD	CRC1		/GET SECOND HALF OF CRC
	SZA CLA
	JMP	BADCRC		/BRANCH IF BUM
	TAD I	RCVTKR
	TABFLD
	TAD	(-SOH
	SNA			/TEST FOR NUMBERED MESSAGE
	  JMP	RCVMSG
	TAD	(SOH-ENQ
	SZA CLA
	HLT			/BE SURE IS ENQ
	TAD	RCVTKR
	DCA	AUTO1
	RCKFLD
	TAD I	AUTO1		/GET MESSAGE TYPE CODE
	TABFLD
	SPA SNA
	JMP	RCVGAG		/CHECK CODE LARGE ENOUGH
	TAD	(-10
	SMA
	JMP	RCVGAG		/CHECK FOR TOO LARGE
	TAD	(JMP I	RCVTAB+7
	DCA .+1
	7402			/DISPATCH ON MESSAGE CODE
RCVTAB,	RCVACK;	RCVNAK;	RCVREP;	RRESET;	RRSACK;	RCVSRT;	RCVSTK
BADTYP,	NL1	/REASON CODE
	JMP	DISCON


	PAGE
/HERE WHEN RECEIVE AN ACK MESSAGE
RCVACK,	JMS	RCVRCK		/DO RIGHT THING BY MSG#
	JMP	RCVADV


/HERE WHEN RECEIVE A NAK MESSAGE
RCVNAK,	JMS	RCVRCK		/DO RIGHT THING BY MSG#
	TAD	T10AKR
	DCA	T10TKR		/RESET BUFFER TO SEND NEXT
	JMP	RCVADV

/HERE TO CHECK MSG# IN ACK OR NAK OR NUMBERED MSG
/ ADJUSTS QUEUE ETC.
RCVRCK,	0
	NL3
	TAD	RCVTKR
	DCA	TEMP2		/POINTER TO MSG#
	RCKFLD
	TAD I	TEMP2
	TABFLD
	JMS	RCVRC8
	DCA	TEMP1		/SAVE ADJ #
	TAD	T10HSN
	JMS	RCVRC8
	NEGATE
	TAD	TEMP1
	SPA CLA
	JMP	RCVGAG		/IF NOT REASONABLE RESTART
RCVRC0,	RCKFLD
	TAD I	TEMP2
	TABFLD
	NEGATE
	TAD	T10LAN		/COMPARE LAST ACKED & THIS
	SNA CLA
	JMP I	RCVRCK		/IF SAME DONE
	TAD	T10AKR
	NEGATE
	TAD	T10TKR
	SZA CLA
	  JMP	RCVRC1
	T10ADJ	T10TKR
RCVRC1,	TAD	T10LAN
	IAC
	AND	[0377
	DCA	T10LAN		/ADJUST MSG #
	T10ADJ	T10AKR
	TAD	T10LAN
	RCKFLD
	DCA I	TEMP2
	TABFLD
	TAD	(-REPTIM	/TIME TILL NEXT REP
	DCA	REPTCK
	JMP	RCVRC0
/FOLLOWING RETURNS LAN-N OR LAN-N-MSNMAX-1
RCVRC8,	0
	NEGATE
	TAD	T10LAN		/COMPARE TO LAST ACKED
	SMA SZA
	TAD	(-MSNMAX-1
	JMP I	RCVRC8


/HERE WHEN RECEIVE A RESET MESSAGE
RRESET,

/HERE WHEN RECEIVE A RESET ACKNOWLEDGE MESSAGE
RRSACK,
/HERE WHEN RECEIVE A MESSAGE WITH TYPE OUT OF RANGE(E.G. POLL)
RCVGAG,	IOF
	NL0			/CLEAR AC & INTERRUPTS
	TAD	(BMTMSG-1
	JMS	CTYEXC		/COMPLAIN TO OPERATOR
	JMP	INIALL		/RESTART STATION

/HERE WHEN RECEIVE A START MESSAGE
RCVSRT,	IOF			/TURN INTERRUPTS OFF
	NLM1			/FLAG TO SEND A STACK
	DCA	STACKF		/SET FLAG
	DCA	RECVOK
	JMP	INISUM		/REINITIALIZE STATION

/HERE WHEN RECEIVE A STACK MESSAGE
RCVSTK,	DCA	STACKF		/FLAG WE ARE UP NOW
	DCA	RECVOK
	JMP	RCVADV
/HERE WHEN RECEIVE A NUMBERED MESSAGE
RCVMSG,	JMS	RCVRCK		/DO RIGHT THING BY RESPONSE FIELD
	NLM3
	TAD	AUTO1
	DCA	TEMP1		/POINTER TO MSG N#
	TAD	RECVOK
	IAC
	AND	[0377
	NEGATE			/MAKE -# EXPECTED
	RCKFLD
	TAD I	TEMP1
	TABFLD
	SZA CLA
	JMP	RCVFLU		/IF NOT EXPECTED DONE
CRCXI2,	DCA	CRC1		/				
	DCA	CRC2		/INITILAIZE CRC FOR MESSAGE
	RCKFLD
	TAD I	TEMP5
	TABFLD
	DCA	TEMP3		/ADR OF CHUNKS(IF ANY)
	TAD	RCVTKR		/GET ADR OF MESSAGE HEADER
	IOF
	RCKFLD
	JMS	GETLEN		/GET LENGTH OF MESSAGE
	TABFLD
	ION
	NEGATE
	DCA	TEMP4		/AND SAVE DATA COUNT
	TAD	TEMP4
	DCA	TEMP2		/KEEP 2ND COPY OF COUNT
	JMP	RCMSG0

/HERE TO GET THE LENGTH FIELD FROM A MESSAGE HEADER
GETLEN,	0
	DCA	IAUTO1
	TAD I	IAUTO1
	DCA	INTMP1		/SAVE LOWORDER BITS
	TAD I	IAUTO1
	AND	(0007		/ONLY BELIVE 11BITS OF COUNT
	BSW
	CLL RTL
	TAD	INTMP1
	JMP I	GETLEN

	PAGE
RCMSG0,	JMS	GETCHR
	JMP	NRMNAK		/GET NEXT CHAR IF ANY
IFZERO	DP8ETR	<
	JMS	CRCALC
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCRC		/TRACE AND ACCUM CRC
>/END OF IFNZRO	DP8ETR
	ISZ	TEMP2
	JMP	RCMSG0		/LOOP BACK FOR REST OF DATA
	TAD	TEMP3		/GET ADR OF LAST DATA
	DCA	TEMP6		/SAVE IT
IFZERO	DP8ETR	<
	JMS	GETCHR
	  JMP	NRMNAK
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCR3		/GET CRC CHAR AND TRACE IT
>/END OF IFNZRO	DP8ETR
	NEGATE			/GET -CRC2
	TAD	CRC2		/GET LOW PART OF CRC
	SZA CLA
	JMP	BADCRC
IFZERO	DP8ETR	<
	JMS	GETCHR
	  JMP	NRMNAK
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCR3		/GET CRC CHARACTER AND TRACE IT
>/END OF IFNZRO	DP8ETR
	NEGATE			/GET -CRC1
	TAD	CRC1		/GET HIGH ORDER PART OF CRC
	SZA CLA
	JMP	BADCRC
/PREVENT LEADING 0 ERROR IN CRC16 CALCULATION
/DNA FIELD SHOULD ALWAYS EQUAL NODE NUMBER  IN A SEQUENTIAL NADE
/EXCEPT FOR NODE ID MESSAGE
	RCKFLD		/CHANGE TO CHUNK FIELD
	NL1
	TAD I	TEMP5	/NCT ADDRESS
	DCA	TEMP3
	TAD I	TEMP3	/CHECK FOR NODE ID MESSAGE
	NEGATE
	TAD	(106	/NODE  ID?
	SNA CLA
	JMP	RCMOK	/NOT NODE ID MESSAGE
	ISZ	TEMP3	/POINT TO DNA FIELD
	TAD I	TEMP3
	Z=OURNNM&177
	TAD	(-Z
	SZA CLA
	JMP	BADCRC
RCMOK,
	NL4000			/LAST CHAR IN CHUNK FLAG
	TAD I	TEMP6
	SPA			/SKIP IF WAS ALREADY LAST CHAR IN CHUNK
	  DCA I	TEMP6		/SET FLAG ON CHAR
	NLM1
	TAD	TEMP5
	DCA	TEMP3		/STORE ADR OF CHUNK COUNT
	TAD	TEMP6		/GET ADDRESS OF LAST CHAR AGAIN
	AND	[-CNKSIZ
	DCA	TEMP6		/MAKE INTO CHUNK POINTER
	TAD I	TEMP6		/GET ADR OF CRC CHUNK IF NOT THIS ONE
	TABFLD
	SNA			/SKIP IF THERE IS ONE FOR CRC
	  JMP	RCMSG1		/OTHERWISE SKIP OVER FOLLOWING
	JMS	FRECKS		/FREE CHUNK WITH CRC(MAYBE)
	RCKFLD
	DCA I	TEMP6		/CLEAR LINK TO CRC CHUNKS
	NLM1			/DECREMENT CHUNK COUNT
	TAD I	TEMP3
	DCA I	TEMP3
	TABFLD
RCMSG1,
	TAD	RECVOK
	IAC
	AND	[0377
	TAD	(4000
	DCA	RECVOK		/AND SAVE IT W FLAG TO ACK
	RCKFLD
	TAD I	TEMP5		/GET ADR OF 1ST CHUNK
	TABFLD
	DCA	TEMP3		/SAVE ADR OF 1ST CHUNK
	JMS	GTCHR		/GET NCT
	DCA	RNCT		/STORE FOR A WHILE
	TAD	(10		/SELECT SNA/DNA PRESENT BIT
	AND	RNCT		/TURN OFF REST
	SNA			/SHOULD BE ON
	  JMP	NODNA		/SKIP OVER DNA,SNA GETTING
	JMS	GTCHR		/GET DNA
	JMS	GTCHR		/GET SNA
NODNA,
	DCA	RSNA		/SAVE IT FOR LATER
	JMS	GTCHR		/GET NCA
	JMS	GTCHR		/GET NCN
	NL0
	TAD	[7		/MASK OF TYPE BITS FOR NCT
	AND	RNCT		/TURN OFF ALL BUT LOW ORDER 3
	SNA			/SKIP IF UN-NUMBERED CONTROL
	  JMP	NMBRED		/HANDLE NUMBERED CONTROL OR DEVICE CONTROL
/ ONLY UN-NUMBERED CONTROL MESSAGE VALID IS NODE ID (6)
	TAD	(-6		/CODE FOR NODE ID
	SZA CLA			/SKIP IF OK
	HLT		/COULD DEFAULT THRU THIS PATH IF LEADING
/0 BIT IN DATA MESSAGE LOST, CRC DOES NOT CATCH THIS ERROR!!!
	JMP	NDID		/FINISH PROCESSING NODE ID
/HERE TO ECHO A LOCAL CRLF
RECI36,	TAD	(CRLMSG-1	/CRLF STRING
	DCA I	TEMPA
	JMS	RECI37	/SET DEFERRED ECHO MODE
	JMP	TSTART
/HERE TO ACCUMULATE CRC
/ ALGORITHM IS:
/	XOR	C,CRC
/	ANDI	C,377
/	LSH	CRC,-10
/	XOR	CRC,TAB(C)

/SINCE THIS CODE IS  DUPLICATED IN 2 PLACES IT IS DEFINED AS A MACRO
	DEFINE CR0<

/XOR	C,CRC
	DCA	TEMP1
	TAD	TEMP1
	AND	CRC2
	CMA IAC
	CLL RAL
	TAD	TEMP1
	TAD	CRC2

/ANDI	C,377
/	AND	[0377		/8 BITS ONLY

/LSH CRC,-10 & XOR CRC,TAB(C)
	TAD	(CRCTAB
	DCA	TEMP1
	TAD I	TEMP1
	AND	CRC1
	CMA IAC
	CLL RAL
	TAD I	TEMP1
	TAD	CRC1
	DCA	CRC2
	TAD	(400
	TAD	TEMP1
	DCA	TEMP1
	TAD I	TEMP1
	DCA	CRC1
>/END OF CR0 DEFINITION
CRCALC,	0
	CR0
	JMP I CRCALC
	PAGE
RCVKRD,	HLT			/HERE WHEN YOU GET VARIOUS FLAVORS OF GARBAGE

/HERE WHEN RECEIVE A DISCONNECT
RCVDIS,	JMS	GTCHR		/GET ADR OF DEVICE
	TAD	(CTRLTB-1
	DCA	TEMP1
	TAD I	TEMP1
IFNZRO FTDEBUG <
	SNA
	  HLT
>/END OF IFNZRO FTDEBUG
	DCA	DDB
	TAD	DDB
	TAD	(DEVSTS
	DCA	DDBSTS
IFNZRO FTDEBUG <
	NL2000
	AND I	DDBSTS
	SNA CLA
	  HLT			/NOT CONNECTED
>/END OF IFNZRO FTDEBUG
	TAD	(TTYBIT
	AND I	DDBSTS		/CHECK TO SEE IF TTY
	SNA CLA
	JMP	RCVDS1		/NOT TTY
	TAD	(DEVRCN
	TAD	DDB
	DCA	TEMP2
	JMS	GTCHR		/GET SLA
	JMS	GTCHR		/RSN FOR DISCONNECT
	NEGATE
	TAD	(10
	SNA CLA
	JMP	STHST		/REASON FOR DISC IS A SET HOST CMD
	TAD I	TEMP2
	SZA			/SEE IF TRYING TO CONNECT
	JMP	RCVDS3		/WAS SO CONNECT REFUSED
RCVDS1,	TAD I	DDBSTS
	AND	(4577		/CLEAR CONNECT AND CHARACTERISTICS BITS [1(14)]
	TAD	(1000		/BIT TO SEND AN ACCEPT
	DCA I	DDBSTS
	DCA I	TEMP1		/NO LONGER CONNECTED
	TAD	TEMP1
	TAD	(RCVDSP-CTRLTB+1
	DCA	TEMP1
	TAD	(RCVKRD
	DCA I	TEMP1
	JMP	RCVFLU		/DONE WITH MESSAGE
RCV5,	TAD	(NEITAB-1
	JMP	RCVD6
RCVDS3,	NEGATE
	JMS	NETSCN		/LOOK FOR ENTRY IN NEIGH TABLE
	HLT			/SHOULD BE FOUND
RCVD6,	ISZ	TEMPB		/GET NEXT ENTRY IN NEITAB
	TAD I	TEMPB
	SNA			/END OF TABLE
	JMP	RCV5		/WRAP AROUND
	AND	(1000		/IS IT AN MCR
	SNA CLA
	JMP	RCVD6		/NO CONTINUE SEARCH
	TAD I	TEMPB
	AND	(377
	DCA	I TEMP2		/SAVE NODE TO CONNECT TO NEXT TIME
	TAD I	DDBSTS
	AND	(4577		/CLEAR CONNECT AND CHARACTERISTICS BITS [1(14)]
	TAD	(3000		/FLAG TO ISSUE CONNECT 
RCV4,	DCA I	DDBSTS
	JMP	RCVFLU
/HERE WHEN RECEIVE A CONNECT MESSAGE
RCVCON,	JMS	GETEXN		/GET DLA
	SNA			/CHECK FOR 0
	  JMP	RCVCN6		/YES SO MAKE ONE
/DAS 92 DOES ISSUE A CONNECT
	TAD	(SLATAB-1
	DCA	TEMPA		/GET INTO 92 TABLE
	JMS	GETEXN
	DCA I	TEMPA		/SAVE DISP INTO 10'S TABLES
	TAD	TEMPA
	TAD	(-DEVN-DEVN-1	/GET POINTER TO DDB
	DCA	TEMPA
	TAD I	TEMPA
	TAD	(DEVSTS
	DCA	TEMPA
	TAD I	TEMPA
	AND	(4776
	TAD	(2001	/CONNECT AND SEND STATUS
	DCA I	TEMPA
/ZERO RCN OF DEVICE TABLE
	ISZ	TEMPA	/POINT TO DATA REQ
	DCA I	TEMPA	/ZERO DATA REQ
	ISZ	TEMPA	/POINT TO DDCMP STATUS
	DCA I	TEMPA	/ZERO IT 
	TAD	(DEVRCN-DEVDDC
	TAD	TEMPA
	DCA	TEMPA
	DCA I	TEMPA
	JMP	RCVFLU
BELTYP,	NL0
	TAD	(TTOBEL-1	/THIS IS JUST A BELL
CNTYP2,
	DCA I	TEMP8		/SET LDBXPT
	JMP	TSTART
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP8E OUTPUT PROCESSING			***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE AT INTERRUPT LEVEL TO HANDLE DP8E OUTPUT

INTDPO,	DPSSTO			/SKIP ON TRANSMIT WC OVERFLOW
	  JMP	INTDP9		/NOT DP8E SO TRY CARD READER

	TAD I	(IDLBUF		/IDLE BUFFER IS NEVER WRITTEN
	TAD	(-IDLE		/SO LETS BE SURE IT STILL IS
	SZA			/SKIP IF OK

	  HLT			/THIS IS VERY LIKELY A HARDWARE FAILURE
				/ PLEASE CHECK ECO IS INSTALLED !
				/ THE USUAL EXPLANATION FOR THIS FAILURE IS
				/ THE DP8E HAS ADDED TO THE TRANSMIT BUFFER THE
				/ LAST CHAR RECEIVED, USUALLY SYNC=226
	JMP	INTDP1
	PAGE
/HERE TO FIND A VACANT SLOT FOR A CONNECT
RCVCN6,	TAD	(-DEVN
	DCA	TEMP2
	TAD	(RCVDSP+1
	DCA	TEMPA		/BEGINNING OF DISPATCH TABLE + 1
RCVCN7,	TAD I	TEMPA		/GET DISPATCH ADDRESS
	TAD	(-RCVKRD	/IS IT UNUSED?
	SNA CLA			/SKIP IF NOT
	  JMP	RCVCN2		/YES, WE'VE FOUND ONE
	ISZ	TEMPA		/ADVANCE TO NEXT DISPATCH ENTRY
	ISZ	TEMP2		/HAVE WE CHECKED ALL SLOTS ?
	  JMP	RCVCN7
	JMP	TOOMNY		/SEND DISCONNECT

	IFNZRO	LPTN	<
/HERE ON CONNECT FOR LPT
CONLPT,	TAD	(RCVLPT		/GET WHERE TO GO ON MESSAGE
	DCA I	TEMPA		/STORE IN RCVDSP TABLE
	TAD	(LPTBLK		/POINT TO DEVICE BLOCK
	JMP	CONDEV		/CONTINUE (I.E. SET CONNECT AND NEED-TO-ACCEPT BITS)
>/END OF IFNZRO	LPTN
DVCTLM,			/DEVICE CONTROL MESSAGE
/ AC HAS DLA IN IT
	ZZ=CTRLN
	ZZ=DEVN
	TAD	(-ZZ		/NEGATIVE OF (NO. OF ENTRIES+1)
	SMA SZA
	  JMP	RCVKRD		/OUT OF RANGE
	TAD	(RCVDSP+ZZ	/POINT TO DISPATCH TABLE ENTRY
	DCA	TEMP1		/SAVE IT
	TAD I	TEMP1		/GET DISPATCH ADDRESS
	DCA	TEMP2		/SAVE IT
	TAD	TEMP1		/DISPATCH ADDRESS
	TAD	(-ZZ-1		/POINT TO DDB ADDRESS
	DCA	TEMP1		/SAVE ADDR OF DDB ADDRESS
	TAD I	TEMP1		/GET DDB ADDRESS
	DCA	DDB		/STORE
	TAD	RNCT		/GET NCT
	AND	[40		/SEE IF INTERRUPT MESSAGE
	SNA CLA			/SKIP IF YES
	  JMS	DATDEC		/DECREMENT DATA REQUESTS
	JMS	GETEXN		/GET COUNT
	NEGATE
	DCA	TEMP4		/SAVE MINUS COUNT
	JMS	GETEXN		/GET DEVICE CTL MESSAGE TYPE
	JMP I	TEMP2

/DEVICE INDEPENDENT PORTION OF CONNECT
/ CALL WITH DEVICE BLOCK IN AC
CONDEV,	DCA	DDB		/SAVE DEVICE ADR
	NLOAD	DEVSTS
	TAD	DDB
	DCA	DDBSTS
	NLOAD	DEVRNN		/GET DISP OF RESTRICTED NODE NUMBER
	TAD	DDB		/IN THIS DDB
	DCA	TEMP2		/STORE ADDRESS
	TAD I	TEMP2		/GET RNN
	SNA			/SKIP IF NOT ZERO
	  JMP	CONANY		/ZERO MEANS ANYONE CAN CONNECT
	TAD	RSNA		/GET THIS NODE
	SZA CLA			/SKIP IF MATCHES
	  JMP	INUSE		/ELSE PRETEND ALREADY CONNECTED
CONANY,

	TAD	(CONBIT+1000	/CONNECTED AND ACCEPT BITS
	AND I	DDBSTS
	SZA CLA
	  JMP	INUSE		/DEVICE NOT AVAILABLE

	Q=DEVDRQ-DEVSTS
	NLOAD	Q
	TAD	DDBSTS
	DCA	TEMP2
	DCA I	TEMP2		/CLEAR DATA REQUESTS
	ISZ	TEMP2		/ADVANCE TO DEVDDC
	DCA I	TEMP2		/CLEAR DDCMP STATUS
	TAD	(4776		/MASK TO CLEAR CONNECT & ACCEPT & EOF BITS
	AND I	DDBSTS
	TAD	(3001		/CONNECT BIT & ACCEPT BIT & SEND STATUS
	DCA I	DDBSTS

	TAD I	DDB		/GET OLD DEVICE ADR
	AND	(7700		/STRIP IT
	TAD	TEMPA		/GET DISPATCH ADDRESS
	TAD	(-RCVDSP	/MAKES CONNECT CODE
	DCA I	DDB		/SAVE ADR

	TAD	TEMPA		/GET DISPATCH ADDRESS
	TAD	(-DEVN-1
	DCA	TEMP1
	TAD	DDB
	DCA I	TEMP1
	JMP	RCVFLU
IFNZRO LPTN <
RCVLPT,				/IGNORE MESSAGE TYPE
	RCKFLD
	NL6			/POINT TO COUNT
	TAD I	TEMP5
	DCA	TEMP3
	TAD I	TEMP5		/GET ADR OF FIRST CHUNK IN MESSAGE
	DCA	AUTO1		/POINTER TO SHUFFLE TO
RCVLP1,	ISZ	TEMP3
	TAD I	TEMP3
	DCA I	AUTO1		/PUT NEXT CHAR BACK INTO CHUNK
	TAD I	TEMP3		/GET CHAR AGAIN
	SMA CLA
	  JMP	RCVLP1
	TABFLD

	IOF
	TAD I	(LPTBLK+DEVOAD	/GET CURRENT OUTPUT CHAR ADR
	SZA CLA			/IS THERE ONE ?
	  JMP	RCVLP3		/YES
	RCKFLD
	TAD I	TEMP5		/ADR OF NEW FIRST CHUNK
	TABFLD
	DCA I	(LPTBLK+DEVOAD
	JMP	RCVLP5
RCVLP3,	TAD I	(LPTBLK+DEVOLC	/GET ADR OF LAST CHUNK
	DCA	TEMP1		/SAVE IT
	RCKFLD
	TAD I	TEMP5		/GET ADR OF 1ST CHAR WE ARE ADDING
	DCA I	TEMP1		/LINK INTO OUTPUT CHUNKS
RCVLP5,	TAD	TEMP6		/GET ADR OF LAST CHAR
	TABFLD
	DCA I	(LPTBLK+DEVOLC	/SET NEW LAST CHUNK ADR
	JMP	RCVLP6		/GO UPDATE CHUNK COUNT
>/END OF IFNZRO LPT
	PAGE
IFNZRO CDRN <
/HERE WHEN RECEIVE A MESSAGE FOR THE CDR
/ REQUEST STATUS 7
/ REQUEST MODE 11
/ SET MODE 12
/ DATA REQUEST BY RECORD 13
/ NEGATIVE DATA REQUEST 15
RCVCDR,	TAD	(-3		/SEE IF STATUS
	SNA
	  JMP	RCDSTA		/HANDLE STATUS
	TAD	(-1		/SEE IF CONTINUE
	SZA			/SKIP IF YES
	  JMP	RCVFLU		/IGNORE OTHER MSGS
RCDCON,				/HERE TO PROCESS CONTINUE
	TAD	(CDRBLK
	DCA	INTDDB
	NL3777
	AND I	(CDRBLK+DEVDDC
	JMS	ISTDDC
	JMP	RCVFLU
RCVDRQ,				/HERE WHEN RECEIVE DATA REQUEST
	JMS	GETEXN		/GET DLA
	TAD	(RCVDSP		/ADD START OF DISPATCH TABLE
	DCA	TEMPA		/SAVE THIS ENTRY ADDRESS
	TAD I	TEMPA		/GET THIS ENTRY
	TAD	(-RCVCDR	/IS IT CDR?
	SZA CLA
	  JMP	RCVFLU		/NO, IGNORE
RCDDRQ,	JMS	GETEXN		/GET DATA REQUEST
	TAD I	(CDRBLK+DEVDRQ
	DCA I	(CDRBLK+DEVDRQ
	JMP	RCVFLU		/DISPOSE OF MESSAGE
>/END OF IFNZRO CDR

IFNZRO PLTN <
RCVPLT,	HLT
>/END OF IFNZRO PLT

IFNZRO PTPN <
RCVPTP,	HLT
>/END OF IFNZRO PTP

RCVTT0,	JMS	GETCHR
	  JMP	RCVFLU
	NEGATE
	IAC
	DCA	TEMP4
	JMS	GTCHR
	JMP	RCVTT6
RCVTTY,	
	DCA	TEMP1
	NLOAD	DEVSTS
	TAD	DDB
	DCA	DDBSTS
	TAD	DDB
	IAC
	DCA	TEMP7		/STORE DEVOAD ADDRESS
	TAD	TEMP4		/GET COUNT
	IAC			/SUBTRACT ONE FOR TYPE
	DCA	TEMP4
	NLOAD	DEVDDC-DEVSTS
	TAD	DDBSTS
	DCA	TEMP6		/STORE DEVDDC ADDRESS
	NLOAD	DEVOLC		/OFFSET FOR DEVOLC
	TAD	DDB		/MAKE ABSOLUTE ADR
	DCA	TEMP8		/SAVE POINTER TO DEVOLC
	NLOAD	DEVCHK
	TAD	DDB
	DCA	TEMPA		/STORE ADR OF CHUNK COUNT
	TAD	TEMP1		/GET TYPE
RCVTT6,	TAD	(-1		/TEST TYPE
	SZA			/SKIP IF DATA
	  JMP	RCVTTC		/NO, CONTROL OR STATUS
RCVTT1,	JMS	GTCHR		/GET THE NEXT CHARACTER FROM MESSAGE
/INSERT ESC ESC FOR ESC CHAR, ESC 1 FOR SET IMAGE, ESC 2 FOR CLEAR IMAG
	DCA	TEMP1		/SAVE CHAR
	TAD	(-ESC
	TAD	TEMP1		/SEE IF ESC CHAR RECEIVED
	SZA CLA			/ESC RECD
	JMP	.+3		/NOT ESC SO ONLY STORE 1 CHAR
	TAD	TEMP1
	JMS	STCHR		/STORE FIRST ESCAPE CHARACTER (TURNING OF INTERRUPTS) [1(16)]
	TAD	TEMP1
	JMS	STCHR		/STORE SECOND ESCAPE
	ION			/ALLOW INTERRUPTS AGAIN [1(16)]
	ISZ	TEMP4		/COUNT CHAR OUT OF THE MESSAGE
	  JMP	RCVTT1		/KEEP GETTING CHARACTERS
	JMS	TTYGO		/START TTY IF IT NEEDS TO BE
	JMP	RCVTT0		/LOOP BACK FOR MORE KRUD
STCHR,	0		/STORE CHAR IN DATA STREAM
	DCA	TEMP1		/SAVE IT
	IOF			/INTERRUPTS OFF WHILE WE CHANGE THINGS
	TAD I	TEMP7		/GET DEVOAD
	SZA CLA			/SKIP IF NO OUTPUT CHUNKS YET
	  JMP	RCVTT2		/ALREADY HAVE SOME CHUNKS
	JMS	ERSGET		/GET A CHUNK
	DCA I	TEMP7		/SET DEVOAD
	TAD I	TEMP7
	DCA I	TEMP8		/SET DEVOLC
	ISZ I	TEMPA		/INCREMENT CHUNK COUNT
	  NOP			/MAY SKIP
RCVTT2,	NL1
	TAD I	TEMP8		/GET DEVOLC
	AND	[CNKSIZ-1
	SZA CLA			/WAS THAT LAST SLOT IN CHUNK ?
	  JMP	RCVTT3		/NO
	TAD I	TEMP8		/GET DEVOLC
	AND	[-CNKSIZ	/MAKE INTO LINK ADR
	DCA	TEMP2		/SAVE LINK ADR
	JMS	ERSGET		/GET ANOTHER CHUNK
	RCKFLD
	DCA I	TEMP2		/SET LINK IN PREVIOUS CHUNK
	TAD I	TEMP2
	TABFLD
	DCA I	TEMP8		/SET DEVOLC
	ISZ I	TEMPA		/INCREMENT COUNT OF CHUNKS
	  NOP			/MAY SKIP
RCVTT3,	TAD I	TEMP8		/GET DEVOLC
	DCA	TEMP2
	NLOAD	3777		/MASK FOR LAST CHARACTER BIT
	RCKFLD
	AND I	TEMP2		/STRIP LAST-CHAR BIT
	DCA I	TEMP2		/AND RESTORE TO CHUNK
	ISZ	TEMP2		/ADVANCE TO NEXT SLOT
	NLOAD	4000		/MAKE LAST-CHAR BIT
	TAD	TEMP1		/ADD CHARACTER
	DCA I	TEMP2		/AND PUT INTO CHUNK
	TABFLD
	ISZ I	TEMP8		/ADVANCE DEVOLC
	JMP I	STCHR		/RETURN TO CALLER LEAVING INTERRUPTS OFF [1(16)]
	PAGE
/TYPE 2 = ECHO PIPELINE MARKER
RCVEPL,	TAD	(LDBEPL		/OFFSET FOR PIPELINE MARKER
	TAD	DDB
	DCA	TEMP1		/SAVE POINTER TO MARKER
	JMS	GTCHR		/GET THE MARKER FROM THE MESSAGE
	NEGATE			/SO WE CAN COMPARE
	TAD I	TEMP1		/ADD IN WHAT WE SAID LAST
	AND	[0177		/SEVEN BITS ONLY
	SZA CLA
	  JMP	RCVTT0		/NOT THE SAME SO NO SPECIAL ACTION
	TAD I	AUTO1		/GET DEVBF1
	SZA CLA			/ARE WE HOLDING ANY INPUT CHARS ?
	  JMP	RCVTT0		/YES SO CAN'T ENTER LOCAL ECHO MODE
	NLOAD	7776		/MASK FOR DEFERRED ECHO BIT
	IOF
	AND I	TEMP6		/GET DDCMP STATUS WORD
	DCA I	TEMP6		/RESTORE STATUS WORD
	JMP	RCTRQS		/AND SEND STATUS TO 10


/TYPE 5 = SET BITS
RCVSBT,	IOF
	NL1
	JMS	RCTBIT		/SET UP STUFF
	TAD	TEMP1		/ADD BITS
RCVSB1,	DCA I	TEMP6
	JMS	EXAD		/SET DTR,RING,CARRIER BITS IN DEVDSL
	JMP	RCTRQ		/SEND COPY OF UPDATED STATUS TO 10

/TYPE 6 = CLEAR BITS
RCVCBT,	IOF
	NL2
	JMS	RCTBIT		/SET UP STUFF
	DCA I	TEMP6		/RESTORE STATUS WORD
RCTRQ,	JMS	TTYGO		/IN CASE CLEARED OUTPUT STOPPED BY XOF BIT
/	JMP	RCTRQS		/AND SENDCOPY OF UPDATED STATUS TO 10

/TYPE 7 = REQUEST STATUS
RCTRQS,	IOF			/DISABLE INTERRUPTS FOR A WHILE
	NLOAD	7776		/MASK FOR NEED TO SEND STATUS BIT
	AND I	DDBSTS		/CLEAR BIT FROM STATUS WORD
	IAC			/ADD BIT TO WORD
	DCA I	DDBSTS
	JMP	RCVTT0		/THEN ON TO NEXT SUBMESSAGE

/TYPE 10 = CHARACTERISTICS
RCVCHR,	TAD	(LDBFIL-1	/RELATIVE ADR OF FILLER BLOCK
	TAD	DDB
	DCA	AUTO1
	TAD	(-6		/NUMBER OF FILLERS
	DCA	TEMP4
RCVCH2,	JMS	GETEXN		/GET NEXT FILLER
	SNA			/SKIP IF NOT ZERO
	  JMP	RCVCH3		/GO RIGHT TO NEGATE
	TAD	(17		/ROUND AND ADD 8
	CLL RTR			/CLOCK TICKS ONCE EVERY 10MS
	CLL RAR			/THEREFORE SHOULD DIVIDE BY 10.
				/HOWEVER HAVE CHOSEN TO DIV BY 8 DUE
				/TO MESSY DIVIDE ON PDP8
	AND	[377		/EIGHT BITS ONLY
RCVCH3,
	NEGATE
	DCA I	AUTO1		/SET NEXT FILLER
	ISZ	TEMP4
	  JMP	RCVCH2		/ON TO THE NEXT FILLER
	TAD	(LDBWID
	TAD	DDB
	DCA	TEMP4
	JMS	GETEXN		/GET RECEIV SPEED
	JMS	GETEXN		/GET TRANSMIT SPEED
	JMS	GETEXN		/GET TTY WIDTH
	DCA I	TEMP4		/SAVE TTY WIDTH
	JMS	GETEXN		/GET COLUMN WHERE BLANKS TURN TO CRLF
	JMS	GETEXN		/GET 2741 TYPING ELEMENT
	JMS	GETEXN		/GET 2741 BITS
	JMP	RCVTT0		/ON TO NEXT SUBMESSAGE
RCVNRM,	0			/HERE BECAUSE RAN OUT OF ROOM FOR A MESSAGE
NRMNAK,	ISZ	RCVNRM		/COUNT TIMES WE NAKED BECAUSE OF NO ROOM
	  NOP
	TAD	(10
	DCA	NAKFLG		/REASON FOR NAK
	JMP	RCVFLU

RCVBCR,	0			/COUNT OF BLOCKS RECEIVED WITH A BAD CRC
/HERE TO NAK A MSG(NUMBERED OR UNNUMBERED BECAUSE OF BAD CRC)
BADCRC,	NL1
	DCA	NAKFLG		/SEND A NAK TO 10
	ISZ	RCVBCR
	NOP			/COUNT BAD CRC'S RECEIVED
	RCKFLD
	TAD I	RCVTKR
	TAD	(-SOH		/CHECK FOR NUMBERED MESSAGE TYPE
	SZA CLA
	JMP	.+3
RCVFLU,	RCKFLD
	TAD I	TEMP5
	TABFLD
	JMS	FRECKS		/IF NUMBERED FREE CHUNKS
	JMP	RCVADV

/HERE WHEN SUBMESSAGE IS CONTROL
RCVTT5,	TAD	DDB		/DEVICE BLOCK ADR
	TAD	(DEVBF1-1	/MAKE AUTO-INCREMENT POINTER TO BUFFERS
	DCA	AUTO1
	JMS	GTCHR		/GET STATUS TYPE
	TAD	(-5		/HIGHEST LEGAL MESSAGE
	SMA			/SKIP IF MESSAGE TYPE IN RANGE
	HLT
	TAD	(JMP I TTYDSP+5
	DCA	.+1
	7402
TTYDSP,	RCVEPL
	RCVGOB
	RCVCHR
	RCVKRD			/AUTO DIAL NOT SUPPORTED
	XOFT			/SEND XOF ASAP
STHST,	JMS	GETEXN
	DCA I	TEMP2		/SAVE NODE TO CONNECT TO
	TAD I	DDBSTS
	AND	(4577		/CLEAR CONNECT BITS AND "NEED
				/CHARACTERISTICS" BIT [1(14)]
	TAD	(1000		/ISSUE DIS CONFIRM
	JMP	RCV4

NDID,	JMS	GETEXN		/GET NODE NUMBER
	DCA	RNOD		/STORE IT
	JMP	RCVFLU		/FLUSH IT AND CONTINUE BIG LOOP
	PAGE
NMBRED,	JMS	GETEXN		/GET DLA
	SZA			/TEST IF NUMBERED CONTROL
	  JMP	DVCTLM		/NO, DEVICE CONTROL
/ DLA OF ZERO MEANS NCS NUMBERED CONTROL MESSAGE
/ LEGAL ONES FOR 72 ARE:
/	CONNECT (1)
/	DISCONNECT (2)
/	NEIGHBORS (3) [ONLY FROM 72'S NEIGHBOR]
/	DATA REQUEST (6)
/	REQUEST CONFIG (4)
	JMS	GETEXN		/GET COUNT
	NEGATE
	DCA	TEMP4		/SAVE IN TEMP4
	JMS	GTCHR		/GET TYPE
	AND	[7		/CLEAR ALL BUT LOW ORDER
	TAD	(JMP I NBRDSP	/ADD BEGINNING OF TABLE+INSTRUCTION
	DCA	NBRJMP		/STORE DISPATCH ADDRESS
NBRJMP,	0			/DISPATCH

NBRDSP,	RCVKRD			/0 IS ILLEGAL
	RCVCON			/1 IS CONNECT
	RCVDIS			/2 IS DISCONNECT
	RCVNEI			/3 IS NEIGHBORS
	RCVRQC			/4 IS REQ CONFIG
	RCVCFG			/5 CONFIGURATION MSG
	IFNZRO	CDRN	<
	RCVDRQ			/6 IS DATA REQUEST
>/END OF IFNZRO	CDRN
	IFZERO	CDRN	<
	RCVFLU			/6 (DATA REQUEST) INVALID UNLESS CDR
>/END OF IFZERO	CDRN
	RCVBOT			/7 STA CTL
/FIELD 0 CALL FOR FRECKS CALL FROM FIELD 1
/[1(23)] MOVED TO AFTER RCVFND
/[1(23)]FRC,	JMS	FRECKS
/[1(23)]	CIF	10
/[1(23)]	JMP	FREC1	/RETURN TO FIELD 1
/FIELD 0 LINK TO FIELD 1 CALL FOR MCRSCN
MCRS3,	0
	JMS	NETSCN
	SKP
	ISZ	MCRS3
	CIF	10
	JMP I	MCRS3
RCVRQC,	TAD	RSNA	/GET SNA
	NEGATE
	JMS	NETSCN	/TRY TO FIND NODE INNEIGHBOR7S TABLE
	JMP	NEFD	/NOT FOUND ADD TO TABLE
	TAD I	TEMPB	/GET NODE NO
	AND	(7377	/TURN OFF RQCFG AND CONFIG FLAGS
	TAD	(400	/SET TO ISUUEBOTH CONF AND REQ CONF
	DCA I	TEMPB	/STORE IN TABLE
	JMP	RCVFLU
NEFD,	TAD	RSNA
	TAD	(4400	/ADD TO TABLE AND SER RQCONF AND CONF BITS ON
	JMP	NETAD
NEIFLB,	0			/SUBROUTINE TO FLUSH BUFFERS
/TEMP1	=	WHERE TO START CHAIN
/TEMP2	=	0 OR WHERE TO INCREMENT CHUNK COUNT
	IOF
	TAD I	TEMP1		/GET START OF CHAIN
	SNA			/SEE IF ANY
	  JMP	NEIFLR		/NONE, SO RETURN
NEIFL1,	DCA	TEMP3		/STORE ADDRESS
	DCA I	TEMP1		/CLEAR POINTER
	DCA I	(FREDCK		/CLEAR COUNT
	TAD	TEMP3		/GET ADDRESS
	AND	[-CNKSIZ	/MAKE SURE AT BEGINNING OF CHUNK
	JMS	FRECKS		/FREE CHUNKS
	TAD	TEMP2		/COUNTER SPECIFIED?
	SNA CLA			/COUNTER SPECIFIED?
	  JMP	NEIFLR		/NO, RETURN
	IOF
	TAD I	(FREDCK		/COUNT OF CHUNKS FREED
	NEGATE
	TAD I	TEMP2		/PREVIOUS COUNT
	DCA I	TEMP2		/STORE NEW ONE
NEIFLR,	ION			/RESTORE INTERRUPTS
	JMP I	NEIFLB		/RETURN
DOWN,				/HERE WHEN WE DETERMINE NODE HAS GONE DOWN
	NL0			/CLEAR AC
	TAD	TEMPB		/GET SNATAB ENTRY
	TAD	(CTRLTB-SNATAB	/GET CORRESPONDING CTRLTB ENTRY
	DCA	DDB		/STORE ADDRESS OF DDB
	TAD I	DDB		/GET DDB
	SNA			/MAKE SURE THERE IS ONE
	  JMP	NEIG12		/NO, MUST HAVE BEEN A DEVICE DISCONNECT
DOWN1,				/CONTINUATION OF DOWN ROUTINE
	DCA	DDB		/SAVE DDB ADDRESS
	NLOAD	DEVSTS
	TAD	DDB		/MAKE ABSOLUTE
	DCA	DDBSTS
	IOF
	TAD I	DDBSTS		/GET STATUS
	AND	(0772		/TURN OFF ACTIVE,CONNECTED,NEED CONNECT CONFIRM,TABBING, AND SEND STATUS
	DCA I	DDBSTS		/PUT IT BACK
	TAD I	DDBSTS		/CHECK TO SEE IF TTY
	AND	[TTYBIT
	SZA CLA
	JMP	DWN1A
DWN1B,	ION			/RESTORE INTERRUPTS
	NLOAD	DEVCHK		/DEVCHK DISPLACEMENT
	TAD	DDB		/MAKE ABSOLUTE
	DCA	TEMP2		/SAVE
	NLOAD	DEVOAD		/POINTER TO OUTPUT
	TAD	DDB
	DCA	TEMP1		/SAVE ITS ADDRESS
	JMS	NEIFLB		/FLUSH ANY OUTPUT
	NLOAD	DEVBF1		/POINT TO INPUT STRING
	TAD	DDB		/MAKE ABSOLUTE
	DCA	TEMP1		/STORE
	DCA	TEMP2		/DO NOT COUNT CHUNKS
	JMS	NEIFLB		/FLUSH INPUT
	NLOAD	DEVDRQ		/POINT TO DATA REQUESTS
	TAD	DDB		/MAKE ABSOLUTE
	DCA	TEMP1		/STORE ADDRESS
	DCA I	TEMP1		/CLEAR DATA REQUESTS
	JMS	CLRCNT		/[1(23)] 60 CLEAR CONNECT COUNT
				/[1(23)] SOMEWHERE ELSE BECAUSE
				/[1(23)] THERE IS NO ROOM HERE
	TAD	TEMPB		/GET SNATAB ENTRY
	JMP	DOWN2		/GO CLEAR OUT RCVDSP ENTRY
DWN1A,	TAD	(LDBXPT
	TAD	DDB
	DCA	TEMP2
	TAD	(CONBKE		/TYPE TTY CONNECTION BROKEN
	DCA I	TEMP2
	NL4000
	TAD I	DDBSTS
	DCA I	DDBSTS		/SET TO ACTIVE
	JMP	DWN1B
	PAGE

/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP8E MODEM HANDLING			***
/	***							***
/	***********************************************************
/	***********************************************************

INTMOD,	DPSSRG			/SKIP IF RING FLAG SET
	  JMP	INTMD5
	ISZ	RNGCNT
	JMP	INTDIS
RNGCNT,	0
INTMD5,	DPSSBE			/SKIP ON BUS ERROR
	  JMP	INTMD7
	ISZ	BERCNT		/COUNT BUS ERROR
	NOP
	  TAD	(DBEMSG-1	/IF WE GET 4096 BUS ERRORS THIS WILL
				/ BE SKIPPED (WHAT ME WORRY ?)

	JMP	INTMD8		/TYPE MESSAGE THEN JMP INTDIS
BERCNT,	0			/COUNT OF BUS ERROR COUNTS

INTMD7,	DPSSCA			/SKIP IF CARRIER FLAG FLIPPED
	  JMP	INTMO9		/NOT MODEM SO ON DOWN SKIP CHAIN
	DPSRS2
	SMA CLA			/SKIP ON CARRIER
	  TAD	(LCRMSG-CARMSG	/WE HAVE LOST CARRIER
	TAD	(CARMSG-1
INTMD8,	DCA	ERRFLG		/LEAVE MSG FOR OPERATOR
	JMP	INTDIS
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP8E INPUT PROCESSING			***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO SEE IF RECEIVER HAS INTERRUPTED
INTDPX,	DPSSCD			/SKIP IF SPECIAL CHAR DETECTED
	  SKP			/NO
	JMP	INRC00		/WAS A SPECIAL CHARACTER
	DPSSRO			/SKIP ON RECEIVE WC OVERFLOW
	  JMP	INTDPO		/NOT RECEIVER SO TRY TRANSMITTER
	JMP I	INRCPV		/WC OVERFLOW ON RECEIVER

/WC OVERFLOW WHILE RECEIVER IS IDLE
INRC10,	DPSSCD			/WAS IT A SPECIAL CHAR ?
	  JMP	INRC11		/NO

/HERE FOR SPECIAL CHAR INTERRUPT
INRC00,	DPSRCD			/GET INDEX OF CHAR WHICH INTERRUPTED
	TAD	[F10TCH		/ADD ADR OF TABLE OF SPECIAL CHARS
	DCA	INTMP1		/TO ADDRESS THIS SPECIAL CHAR
	TAD	INRCPV
	TAD	[-INRC10
	SZA CLA			/ARE WE IN STATE A (IDLE)?
	  JMP	INTDIS		/NO SO IGNORE INTERRUPT
	DPSSRO
	  NOP
	CDFINS
	TAD I	INTMP1		/GET SPECIAL CHAR FROM TABLE
	NEGATE
	RCKFLD
	TAD I	RCVPTR		/GET SPECIAL CHAR AS RECEIVED
	TABFLD
	SZA CLA			/ARE THEY THE SAME ?
	  JMP	INRC01		/THIS IS EITHER A HDW PROBLEM
				/ OR WE ARE TAKING TOO LONG TO SERVICE INTERRUPTS
	TAD	INTMP1		/GET F10TCH+INDEX
		ZZ=JMP I INRC02
		ZZ=ZZ-F10TCH
	TAD	(ZZ
	DCA	.+1
	7402			/MODIFIED BY PROGRAM
INRC02,	INTP00
	INTP10
	INTP20
	INTP30

INERRC,	0			/COUNT OF SP. CHAR ERRORS
INRC01,	ISZ	INERRC		/COUNT ERROR
	JMP	INTDIS		/DISMISS INTERRUPT

/WC OVERFLOW ON UNNUMBERED MSG
INRC20,	DPSSCD			/CLEAR CHAR DETECTED FLAG
	  JMP	INTP40
	JMP	INTP40

/HERE WITH WC OVERFLOW WHILE IDLE
INRC11,	CDFINS
	TAD I	[F10CA
	CDFCNK
	DCA	INTMP1
	RCKFLD
	TAD I	INTMP1		/GET LAST CHAR
	TABFLD
	TAD	[-SYN
	SZA CLA			/WAS RANDOM CHAR A SYNC ?
	  DPSCSD		/ NO - SO CLEAR SYNC DETECT
	JMS I	[INRCID		/RESET WC AND CA
	DPSGRR			/ENABLE INPUT
	JMP	INTDIS

/WC OVERFLOW ON NUMBERED MSG DATA
INRC70,	CDFINS
	TAD I	[F10CA		/GET ADR OF LAST CHAR
/	CDFCNK
	DCA	INTMP1
	NL4000
	RCKFLD
	TAD I	INTMP1
	DCA I	INTMP1
	TAD	INTMP1		/ADR OF LAST DATA IN CHUNK
	AND	[-CNKSIZ	/MAKES ADR OF LINK
	DCA	INTMP2
	TAD I	INTMP2
	TABFLD
	SZA CLA
	  HLT
	TAD	F10TWC
	SNA CLA			/MIGHT THERE BE MORE IN MESSAGE ?
	  JMP	INTP60		/NO

INRC80,	IFNZRO FTDEBUG <
	RCKFLD
	TAD I	INTMP2		/GET LINK WORD IN LAST CHUNK
	TABFLD
	SZA
	  HLT
>/END OF IFNZRO FTDEBUG
	JMS	IGTCNK		/TRY TO GET ANOTHER CHUNK
	  JMP	INTP60		/NO SO PRETEND WC EXHAUSTED
	RCKFLD
	DCA I	INTMP2		/SET LINK IN PREVIOUS CHUNK
	TAD I	INTMP2
	ISZ I	CNTPNT	/INCREMENT NUMBER OF CHUNKS
	CDFINS
	DCA I	[F10CA
	TAD	F10TWC
	TAD	[1-CNKSIZ
	SPA
	  JMP	INRC83
	DCA	F10TWC
	TAD	[1-CNKSIZ
	DCA I	[F10WC
	JMP	INRC84

INRC83,	NL0
	TAD	F10TWC
	NEGATE
	DCA I	[F10WC
	DCA	F10TWC
INRC84,	CDFCNK
	DPSGRR
	JMP	INTDIS

	PAGE

/HERE AT INTERRUPT LEVEL TO HANDLE DP8E OUTPUT
/HERE WHEN CURRENT TRANSMIT BUFFER IS EMPTY
INTDP1,	TAD	T10FLG
	SNA
	  JMP	INTN97		/IDLING
	SMA CLA
	  JMP	INTN10		/WE ARE SYNCHING LINE
	ISZ	T10FLG		/DID WE JUST COMPLETE A MESSAGE ?
	  JMP	INTN20		/NO WE ARE JUST READY TO BEGIN
	TAD	GFLG		/SEE IF GOTO ACCEPT JUST PROCESSED
	SNA CLA			/IF NOZRO GOTO
	JMP	INTN11
	TAD	GTTAB+3		/CHANGE DATA FIELD INST
	IAC			/MAKE IT INTO CHANGE INSTR FIELD
	DCA	.+1
	0
	TAD	GTTAB+2		/GET ADDRESS BITS
	DCA	.+2
	JMP I	.+1
	0
INTN11,	ISZ	T10FLG		/STATE IS NOW SYNCHING
	NLM1			/WE JUST FINISHED A MESSAGE(DAT ACK ETC)
	DCA	WRKREQ		/WAKE NONINTERRUPT LEVEL CODE
INTN10,	TAD	[SYNBUF-1	/BUFFER OF SYNCHS
	JMP	INTN98		/SET UP CA, WC AND CLOCK FOR 1 CHAR

/HERE TO BEGIN A MESSAGE
INTN20,	TAD	T10NCA		/ADR OF NEXT BUFFER TO SEND
	CDFINS
	DCA I	[T10CA
	TAD	T10NWC		/LENGTH OF NEW BUFFER
	DCA I	[T10WC
	CDFCNK
	TAD	T10NWC
	CLL CML RAR
INTN21,	CLL CML RAR		/FOR SPEED .LT. 2400 WILL BE NOP	########
	TAD	[-3
	JMP	INTN99

/HERE WHEN LINE IS IDLING
INTN97,	TAD	(IDLBUF-1
INTN98,	CDFINS
	DCA I	[T10CA
	TAD	[-NUMSYN
	DCA I	[T10WC
	CDFCNK
	SYNCLK=NUMSYN^3		/3 PER CHARACTER
	TAD	[-SYNCLK	/RESET CLOCK ON XMTR
INTN99,	DCA	T10CLK
	DPSGTT			/REENABLE XMTR
	JMP	INTDIS

/	***********************************************************
/	***********************************************************
/	***							***
/	***		NON-INTERRUPT LEVEL CODE		***
/	***							***
/	***********************************************************
/	***********************************************************

/ FIRST SCAN FOR THINGS TO DO LEFT BY INTERRUPT LEVEL CODE
/ THEN DISPLAY CONTENTS OF ADR IN SWITCHES

LOOP,	ION
	NL0			/RESET INTERRUPTS & AC

	TAD	CLKFLG
	SZA CLA
	  JMP	SCHED		/CHECK FOR ONCE PER TICK DUTIES

	TAD	SECFLG
	SZA CLA
	  JMP	SECOND		/CHECK FOR ONCE PER SECOND DUTIES

	TAD	TIQPTR
	NEGATE
	TAD	TIQTKR		/CHECK TTY RECEIVE QUEUE
	SZA CLA
	  JMP	RECINT		/IF ANY RECEIVE STUFF HANDLE IT

	TAD	RCVTKR
	NEGATE
	TAD	RCVPTR
	SZA CLA
	  JMP	RCVCHK		/THERE IS INPUT FROM DECSYSTEM-10 WAITING

	TAD	T10FLG		/CHECK SYNCHRONOUS TRANSMIT STATE
	SMA CLA
	  JMP	XSTAS		/IDLE OR SYNCH

LOOP30,	CIF	30	
	JMP	ID1
XSTAS,	CIF	10	/LINK TO INSTR ON FIELD 1
	JMP	XSTART
/HERE ONCE PER CLOCK TICK(UNLESS WE OVERRUN)
SCHED,	DCA	CLKFLG		/MARK WE SAW FLAG
	IOF
	TAD	REPTCK
	SPA CLA			/ARE WE TIMEING OUT ?
	ISZ	REPTCK		/YES HAVE WE
	  JMP	SCHED2		/NO TO ONE OF ABOVE
	JMP	SCHED2

/	***********************************************************
/	***********************************************************
/	***							***
/	***		COMMON SUBROUTINES			***
/	***							***
/	***********************************************************
/	***********************************************************


/HERE TO FREE A CHUNK
/CALL	JMS	FRECNK	(CALL WITH CNK ADR IN AC
/	RETURN
/FRECNK,	0
/	IOF
/	JMS	IFRCNK		/RELEASE CHUNK
/	ION
/	JMP I	FRECNK

/HERE TO FREE A NUMBER OF CHUNKS
/CALL	JMS	FRECKS	(WITH ADR OF FIRST CHUNK IN AC)
/	RETURN
FRECKS,	0
	ION
	SNA			/ANY CHUNKS LEFT ?
	  JMP I	FRECKS		/NO SO RETURN TO CALLER
	IOF			/FOR CALL TO IFRCNK
	DCA	INTMP1		/SAVE ADR OF THIS CHUNK
	RCKFLD
	TAD I	INTMP1		/GET ADR OF NEXT CHUNK
	DCA	INTMP2		/SAVE IT
	TAD	INTMP1
	JMS	IFRCNK		/RELEASE THIS CHUNK
	ISZ I	(FREDCK		/COUNT THIS CHUNK
	NOP			/SINCE IT MIGHT SKIP
	TAD	INTMP2		/GET ADR OF NEXT CHUNK IN STRING
	JMP	FRECKS+1	/LOOP FOR NEXT CHUNK
RCX,	NLOAD	4
	JMS	ISBDDC		/FLAG OUTPUT IS FROZEN
	JMS	RECI42		/INSERT STATUS
	JMP	LOOP
/IF IDLE REP SEND ACK
RCVREP,	RCKFLD
	DCA I	AUTO1
	DCA I	AUTO1
	TAD	RECVOK		/LAST MSG REC OK
	AND	(3777		/ZERO MASK TO SEND ACK
	NEGATE
	TAD I	AUTO1
	TABFLD
	SZA CLA
	JMP	REPNAK		/SEND NAK AS MES # NOT THE SAME
	NL4000
	TAD	RECVOK	/DONT SET ACK BIT OFF IF ON
	SPA
	DCA	RECVOK
	JMP	RCVADV	/ACK TO BE SENT

	 PAGE 

/HERE TO GET A FREE(NOT ERS) CHUNK AT INTERRUPT LEVEL
/ CALL	JMS	IGTCNK
/	ERROR RETURN
/	RETURN	WITH CHUNK ADR IN AC
IGTCNK,	0
	NL0
	TAD	(-ERSCNT
	TAD	FRECNT
	SPA CLA
	  JMP I	IGTCNK		/NOT ENOUGH CHUNKS LEFT TO PASS ANY OUT
	JMS	ERSGET		/GET A CHUNK
	ISZ	IGTCNK
	JMP I	IGTCNK
/HERE TO GET DDB ADR
/CALL	JMS	GETDDB	(WITH DEVICE # IN AC)
/	RETURN	WITH DDB, DDBSTS STEUP & BLOCK ADR IN AC
GETDDB,	0
	SPA
	  HLT
	TAD	(-DEVN
	SMA
	  HLT
	TAD	(DDBTAB+DEVN
	DCA	DDB
	TAD I	DDB
	DCA	DDB		/SAVE DEVICE BLOCK ADR
	NLOAD	DEVSTS		/RELATIVE ADR OF DEVICE STATUS WORD
	TAD	DDB
	DCA	DDBSTS		/SAVE ADR OF STATUS WORD
	TAD	DDB
	JMP I	GETDDB
/HERE TO GET THE NEXT OUTPUT CHAR FROM CHUNK
/ USES INTMP1 - INTMP4
/CALL	PUT DEVICE BLOCK ADR IN INTDDB
/	JMS	IGTOCH
/	RETURN IF NONE( AC=0 )
/	RETURN WITH CHAR IN AC

IGTOCH,	0
	NLOAD	DEVOAD
	TAD	INTDDB		/ADD DEVICE DATA 
	DCA	INTMP3
	TAD I	INTMP3		/GET OUTPUT CHAR COUNT
	SNA			/DO WE HAVE ANY OUTPUT CHARS ?
	  JMP I	IGTOCH		/NO - DISMISS
	ISZ	IGTOCH		/SKIP RETURN TO CALLER
	ISZ I	INTMP3		/ADVANCE CHAR POINTER
	IAC 			/MAKE ADR OF CURRENT CHAR
	DCA	INTMP4
	RCKFLD
	TAD I	INTMP4		/PICK UP CURRENT CHAR
	TABFLD
	SMA			/ALL DONE WITH CURRENT CHUNK ?
	  JMP I	IGTOCH		/NO - EXIT ROUTINE
	DCA	INTMP2		/SAVE CHARCTER
	TAD	INTMP4		/CURRENT CHAR POINTER
	AND	[-CNKSIZ	/MAKES POINTER TO LINK WORD
	DCA	INTMP4
	RCKFLD
	TAD I	INTMP4		/GET ADR OF NEXT CHUNK
	TABFLD

IFNZRO FTDEBUG <
	SNA
	  JMP	.+3
	JMS	ICNKCK		/CHECK CHUNK ADR IS KOSHER
	TAD	INTMP1		/GET ADR OF CHUNK AGAIN
>/END OF IFNZRO FTDEBUG

	DCA I	INTMP3		/SET NEW CHAR POINTER
	TAD	INTMP4		/ADR OF USED CHUNK
	JMS	IFRCNK		/FREE CURRENT CHUNK
	NLOAD	DEVCHK		/DISPLACEMENT OF CHUNK COUNT
	TAD	INTDDB		/PLUS DDB START
	DCA	INTMP3		/SAVE DEVCHK ADDRESS
	NLM1			/DECREMENT
	TAD I	INTMP3		/ CHUNK COUNT
	DCA I	INTMP3		/ AND STORE
	TAD	INTMP2		/GET CURRENT CHAR AGAIN
	AND	(3777		/TURN OFF LAST CHAR BIT
	JMP I	IGTOCH		/DONE
/HERE TO GET AN EXTENSIBLE NUMBER USING IGTOCH
IGTEXN,	0
	JMS	IGTOCH
	  JMP I	IGTEXN		/TRY AGAIN LATER
	AND	[0377
	DCA	INTMP5		/SAVE LOW ORDER BITS
	TAD	INTMP5
	AND	[0200
	SNA CLA
	  JMP	IGTEN9		/RETURN
	JMS	IGTOCH
	  HLT
	CLL RAL			/PUT SIGN BIT IN LINK
	CLL RTL			/CLEAR FORMER SIGN BIT
	CLL RTL
IFNZRO FTDEBUG <
	SZL			/CHECK FOR 200 BIT WHICH SAYES EXTENSIBLE
	  HLT			/CAN'T HACK NUMBERS THAT LARGE !
>/END OF IFNZRO FTDEBUG
	CLL RTL
	TAD	(-200
IGTEN9,	TAD	INTMP5
	ISZ	IGTEXN		/SKIP RETURN
	JMP I	IGTEXN
/HERE AT INTERRUPT LEVEL TO SET RECEIVER TO IDLE MODE
INRCID,	0
	NLM1
	CDFINS
	DCA I	[F10WC
	NLM1
	TAD	RCVPTR
	DCA I [F10CA
	TAD	(INRC10
	DCA	INRCPV
	CDFCNK
	JMP I	INRCID
DOWN2,	TAD	(RCVDSP+1-SNATAB /POINT TO RCVDSP ENTRY
	DCA	TEMP1	/STORE ADDRESS
	TAD	(RCVKRD	/UN-USED VALUE
	DCA I	TEMP1	/NOW THIS CONNECTION IS AVAIL
	JMP	NEIG13	/RETURN TO LOOP
SCHED2,	ISZ	T10CLK	/HAS SYN TRANSMITTER TAKEN TOO LONG
	JMP	SCHED9	/NO
	TAD	(DPTMSG	/LEAVE MESSAGE FOR OPERATOR
	DCA	ERRFLG
	JMS	INISYN
SCHED9,	ION
	JMP	CLKCDR	/TO CDR STUFF FIRST
REPNAK,	NL3			/SEND NAK IN RESPONSE TO A REP
	DCA	NAKFLG		/RESPONSE OF THREE
	JMP	RCVADV		/DONE WITH MESSAGE
	PAGE 


/HERE TO GET A FREE CHUNK AT INTERRUPT LEVEL
/ (-) CYCLES + JMS CYCLES
/CALL	JMS	ERSGET
/	ERROR RETURN
/	SUCCESS RETURN WITH CHUNK ADR IN AC

ERSGET,	0
	NL0
	TAD	FIRFRE		/GET ADR OF 1ST CHUNK
	SNA			/IS THERE A FIRST CHUNK ?
	  HLT			/MUST NEVER HAPPEN
				/ IMPLIES STARTED SOMETHING WE CAN'T FINISH

IFNZRO FTDEBUG < JMS ICNKCK >	/BE SURE ADR IS KOSHER
IFZERO FTDEBUG < DCA INTMP1 >	/SAVE ADR OF FIRST CHUNK
	RCKFLD

	TAD I	FIRFRE		/AND GET ADR OF 2ND CHUNK
	DCA	FIRFRE		/SET NEW FIRST FREE CHUNK
	DCA I	INTMP1		/CLEAR LINK IN THIS CHUNK
	TABFLD

	NLM1
	TAD	FRECNT		/UPDATE FREE COUNT
IFNZRO FTDEBUG <
	SPA
	  HLT			/IT IS ALWAYS POSITIVE
>/END OF IFNZRO	FTDEBUG
	DCA	FRECNT

	TAD	INTMP1		/GET ADR OF CHUNK WE ARE GETTING
	JMP I	ERSGET

/HERE TO FREE A CNK
/(12-16) CYCLES + JMS CYCLES
/CALL	JMS	IFRCNK	(CALL WITH CNK ADR IN AC
/	RETURN		AC WILL BE 0, LINK UNDEFINED
IFRCNK,	0

IFZERO FTDEBUG <
	DCA	INTMP1		/SAVE ADR OF CHUNK
>/END OF IFZERO FTDEBUG

IFNZRO FTDEBUG <
	JMS	ICNKCK		/CHECK CHUNK ADR IS KOSHER
>/END OF IFNZRO FTDEBUG

	TAD	FIRFRE		/ADR OF FIRST FREE CHUNK
	RCKFLD
	DCA I	INTMP1		/SET LINK IN NEW FIRST CHUNK
	TABFLD
	TAD	INTMP1
	DCA	FIRFRE
	ISZ	FRECNT		/COUNT FREE CHUNKS
	JMP I	IFRCNK
	HLT
/HERE TO CHECK A CHUNK ADR IS LEGAL
/ CALL	JMS	ICNKCK		/WITH IOF AND ADR IN AC
/	RETURN			/(AC)=0 AND ADR OF CHUNK IN INTMP1
ICNKCK,	0
	DCA	INTMP1		/SAVE CHUNK ADR
	TAD	INTMP1
	AND	[CNKSIZ-1
	SZA			/ALL CHUNKS BEGIN ON EVEN BOUNDRY
	  HLT			/THIS ONE DOESN'T ?
	CLL CLA			/CLEAR LINK
	TAD	FIRADR		/GET ADDRESS OF FIRST CHUNK
	CMA IAC			/CONVERT TO NEGATIVE
	TAD	INTMP1		/GET ADDR OF CHUNK AGAIN
	SNL CLA
	  HLT
	JMP I	ICNKCK

/HERE TO SET DDCMP STATUS WORD
/ CALL	SET UP INTDDB
/	LOAD NEW STATUS INTO AC
/	JMS	ISTDDC
ISTDDC,	0
	DCA	INTMP3		/SAVE NEW DDCMP STATUS WORD
	TAD	(DEVDDC		/OFFSET FOR DDCMP STATUS WORD
	TAD	INTDDB
	DCA	INTMP2
	TAD I	INTMP2
	NEGATE
	TAD	INTMP3		/GET NEW DDCMP STATUS WORD
	SNA CLA			/ARE THEY DIFFERENT ?
	  JMP I	ISTDDC		/NO SO RETURN
	TAD	INTMP3		/GET NEW STATUS WORD
	DCA I	INTMP2		/AND SET IT
	NLOAD	DEVSTS
	TAD	INTDDB
	DCA	INTMP1		/SAVE ADR OF STATUS WORD
	NL7776			/MASK FOR NEED-TO-SEND-STATUS BIT
	AND I	INTMP1		/CLEAR IT
	IAC			/SET IT
	DCA I	INTMP1		/SAVE IT
	JMP I	ISTDDC

/HERE TO SET A BIT IN THE DEVDDC WORD
/ CALL	JMS	ISBDDC	/WITH INTDDB SETUP AND BITS IN AC
/			/USES INTMP1 - INTMP4
ISBDDC,	0
	DCA	INTMP1		/SAVE BITS
	NLOAD	DEVSTS		/RELATIVE ADR OF STATUS WORD
	TAD	INTDDB
	DCA	INTMP3		/SAVE ADR OF STATUS WORD
	Q=DEVDDC-DEVSTS
	NLOAD	Q
	TAD	INTMP3		/MAKES ADR OF DEVDDC
	DCA	INTMP4		/SAVE ADR OF DEVDDC
	TAD I	INTMP4		/GET OLD DEVDDC
	DCA	INTMP2		/SAVE FOR FUTURE REFERENCE
	TAD	INTMP1		/GET BITS TO SET
	CMA			/MAKE INTO A MASK
	AND I	INTMP4		/CLEAR BITS IN DEVDDC
	TAD	INTMP1		/ADD BITS
	DCA I	INTMP4		/AND SAVE IN DEVDDC
	TAD	INTMP2		/ONLY SHIP STATUS IF DIFFERENT
	NEGATE
	TAD I	INTMP4		/NEW STATUS
	SNA			/SKIP IF DIFFERENT THAN OLD
	JMP I	ISBDDC		/SAME SO DONT SEND TO HOST
	NL7776			/MASK TO REQUEST STATUS
	AND I	INTMP3		/CLEAR BIT FROM DEVSTS
	IAC			/SET BIT
	DCA I	INTMP3
	JMP I	ISBDDC
/HERE TO GET THE NEXT CHAR FROM A STRING OF CHUNKS POINTED TO BY TEMP3
/CALL	JMS	GETCHR
/	  RETURN WHEN NO MORE CHARS IN STRING(I.E. TEMP3 NOW 0
/	RETURN WITH CHAR IN AC(WILL BE 11 BITS ONLY)
GETCHR,	0
	TAD	TEMP3
	SNA			/IS  STRING NULL ?
	  JMP I GETCHR		/YES SO NONSKIP RETURN
	AND	[CNKSIZ-1
	IOF
	SNA CLA			/ARE WE POINTING TO A LINK WORD ?
	  JMP	GETCH3		/YES
	RCKFLD
	TAD I	TEMP3		/GET THE LAST CHAR
	TABFLD
	SPA CLA			/WAS LAST CHAR LAST IN ITS CHUNK ?
	  JMP	GETCH7		/YES SO ADVANCE CHUNKS

IFNZRO FTDEBUG <
	NL1
	TAD	TEMP3
	AND	[CNKSIZ-1
	SNA CLA
	  HLT
>/END OF IFNZRO FTDEBUG

GETCH3,	ISZ	TEMP3		/ADVANCE TO NEXT CHAR
	NL3777			/STRIP LAST DATA BIT IF PRESENT
	RCKFLD
	AND I	TEMP3		/GET NEXT CHAR
	TABFLD
	ISZ	GETCHR		/SKIP RETURN
GETCH5,	ION
	JMP I	GETCHR
GETCH7,	TAD	TEMP3		/GET POINTER TO CURRENT CHAR
	AND	[-CNKSIZ	/MAKE POINTER TO FIRST WORD OF CHUNK
	DCA	TEMP3
	RCKFLD
	TAD I	TEMP3		/GET ADR OF NEXT CHUNK
	TABFLD
	SNA
	  JMP	GETCH5		/NO MORE CHUNKS SO DONE

IFNZRO FTDEBUG <
	JMS	ICNKCK		/CHECK LINK HAD LEGAL CHUNK ADDRESS
	TAD	INTMP1
>/END OF INZRO FTDEBUG

	DCA	TEMP3
	JMP	GETCH3		/GO GET NEXT CHAR
	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CTY SERVICE				***
/	***		GAS FOR LESS				***
/	***							***
/	***********************************************************
/	***********************************************************


/HERE AT INTERRUPT LEVEL TO TEST FOR CTY INTERRUPTS
INTCTY,	CTYKSF			/TYPING SOMETHING?
	  JMP	INTCTO		/NOT KEYBOARD - CHECK XMTR
	TAD	(CTYBLK		/ADR OF DEVICE BLOCK
	DCA I	TIQPTR		/SAVE ADR
	CTYKRB			/READ KEYBOARD & RESET FLAG
/HERE TO PUT CHAR INTO TTI QUEUE AND BE SURE QUEUE IS NOT GARBLED
INTYI9,	DCA I	TIQPTR		/SAVE CHAR
	TAD	TIQPTR
	TAD	(1-TTIQUE-TIQLEN
	SZA CLA			/HAVE WE FILLED THE QUEUE ?
	  JMP	.+3		/NO
	TAD	(TTIQUE-1
	DCA	TIQPTR

/NOW CHECK TO SEE QUEUE HASN'T OVERFLOWED
	TAD	TIQPTR
	NEGATE
	TAD	TIQTKR		/HAVE WE FILLED THE QUEUE
	SNA CLA
	  HLT
	NLM1
	DCA	WRKREQ		/FIND THIS ASAP
	JMP	INTDIS

INTCTO,	CTYTSF			/SKIP ON CTY TRANSMIT FLAG
	  JMP	INTCT9		/NOT CTY - CHECK NEXT DEVICE
	TAD	(CTYBLK
INTTYX,	DCA	INTDDB
	JMS	XMTINT		/SEE WHAT IS LEFT TO GO
	JMP	INTDIS
/ CALL:	JMS	TTYGO	WITH DDB& DDBSTS SETUP
/	RETURN			/POSSIBLY WITH GARBAGE IN AC
/HERE AT NONINTERRUPT LEVEL TO START A TTY IF IT WERE INACTIVE
TTYGO,	0
	TAD	DDB		/GET DEVICE BLOCK ADR
	IOF
	DCA	INTDDB		/SAVE IT WHERE XMTINT WANTS IT
	NL4000
	TAD I	DDBSTS		/MAKE ACTIVE STATUS
	SMA
	  JMP	.+3		/EXIT BECAUSE ALREADY ACTIVE
	DCA I	DDBSTS
	JMS	XMTINT
	NL0			/CLEAR AC
	JMP I	TTYGO

GTCHR,	0
	NL0			/CLEAR AC
	JMS	GETCHR
	  HLT
	JMP I	GTCHR

IFNZRO	DP8ETR	<
OTR,	0			/TRACE OUTPUT MESSAGE
	TAD	T10NWC		/NUMBER OF CHARACTERS
	DCA	TEMP1		/SAVE FOR LOOP CONTROL
	TAD	T10NCA		/BEGINNING OF MESSAGE
	DCA	AUTO1		/ INTO AUTOINDEX POINTER
OTRL,	TAD I	AUTO1		/GET NEXT CHARACTER
	IOF
	JMS	TRACEW		/TRACE IT
	ION
	ISZ	TEMP1		/SKIP IF FINISHED
	  JMP	OTRL		/ELSE CONTINUE
	JMP I	OTR
>/END OF IFNZRO	DP8ETR
	IFNZRO TTYN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		KL8A SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

INTYI1,	0
	CDFINS
	NL0
	TAD I	INTYI1		/GET DDB ADR
	SNA			/DO WE BELIEVE IN HIM ?
	  JMP	INTYI3		/NO SO FLUSH IT
	DCA	INTMP1
	TAD	INTMP1
	CDFCNK			/BACK TO NORMAL DATA FIELD
	DCA I	TIQPTR		/PUT INTO TTY INPUT QUEUE
	TAD	[LDBADR
	TAD	INTMP1
	DCA	INTMP1
	TAD I	INTMP1
	AND	(7770
	TAD	(0005		/MAKES A KRB
	DCA	.+1
	0
	JMP	INTYI9

INTYI3,
	CDFCNK			/BACK TO NORMAL DATA FIELD
	JMP	INTDIS

/HERE WHEN A KL8E LINE HAS AN XMT INTERRUPT
INTYO1,	0
	CDFINS			/CHANGE DATA FIELD TO PICK UP AN INSTRUCTION
	NL0
	TAD I	INTYO1
	CDFCNK			/BACK TO NORMAL DATA FIELD
	JMP	INTTYX		/POKE XMTINT
/HERE FROM CODE FOLLOWING XMTINT TO TYPE AN OUTPUT CHAR
INTYPE,	
	TAD	[LDBADR		/POINT TO ADDRESS FIELD
	TAD	INTDDB		/IN DDB
	DCA	INTMP2		/STORE ADDRESS OF IOT INSTRUCTION
	TAD I	INTMP2		/GET IOT
	AND	(7774	/MASK LINE NO OUT
	DCA	.+11
	TAD I	INTMP2
	AND	(3
	BSW
	CLL RTL
	DCA	TEX
	TAD	(377
	AND 	INTMP6
	TAD	TEX
	0
	JMP	XMTDIS
TEX,	0
>/END OF IFNZRO TTYN
IFNZRO	CDRN	<
ICDC20,	DCA	CDCCHR
	ISZ	CDCCNT	/COUNT REPETITION
ICDRD5,	ISZ I	(CDRBLK+DEVOLC
	TAD I	(CDRBLK+DEVOLC
	TAD	(-120
	SNA CLA
	JMS	ICDC30
	JMP	INTDIS
>/END OF IFNZRO CDRN
RCVTTC,	TAD	(-2		/SEE IF STATUS
	SZA CLA			/SKIP IF YES
	  JMP	RCVTT5		/MUST BE CONTROL
	JMS	GTCHR		/STC
	TAD	(JMP I	TTSDSP
	DCA	.+1
	7402
TTSDSP,	RCVKRD			/TYPE 0=UNKNOWN
	RCVSBT			/TYPE 1=SET BITS
	RCVCBT			/TYPE 2=CLEAR BITS
	RCVKRD			/TYPE 3=FATAL ACCORDING TO NCL SPEC
/SET UP SO TTY NOT CONNECTED PRINTED
CONDN,	TAD	(NCOMSG-1
	JMP	CNTYP2
	
	PAGE
IFNZRO TTYN <
ZZ=TTYN
/THE FOLLOWING CONDITIONAL SETS UP VECTORED ADDRESS FOR EACH TTY LINE ON KL8A
DEFINE KL8 Q QQ <
IFNZRO ZZ <
QQ,	JMP	Q	/TRANSMIT ON LINE 0
	JMP	Q+2	/TRANS ON LINE 1
	JMP	Q+4	/TRANS ON LINE 2
	JMP	Q+6	/TRANS ON LINE 3
	JMP	Q+10	/RECEIVE ON LINE 0
	JMP	Q+12	/REC LINE 1
	JMP	Q+14	/REC LINE 2
	JMP	Q+16	/REC LINE 3
ZZ=ZZ-4
>/END IFNZRO ZZ
>/END OF DEF KL8
	KL8 A8TM0,KL8A1
	KL8 A8TM1,KL8A2
	KL8 A8TM2,KL8A3
	KL8 A8TM3,KL8A4
ZZ=TTYN
/DEFINES I/O PROCESSING FOR KL8A
/	QQ=VECTORED ADDRESS FOR KL8A 
/	Q=DDB TABLE LINE 0
/	Q1=DDB TABLE LINE 1
/	Q2=DDB TABLE ADDRESS LINE 2
/	Q3=DDB TABLE ADDRESS LINE 3
DEFINE KL8A QQ Q Q1 Q2 Q3 <
IFNZRO ZZ <
QQ,	JMS I [INTYO1
	Q
	JMS I	[INTYO1
	Q1
	JMS I	[INTYO1
	Q2
	JMS I	[INTYO1
	Q3
	JMS I [INTYI1
	Q
	JMS I [INTYI1
	Q1
	JMS I [INTYI1
	Q2
	JMS I [INTYI1
	Q3
ZZ=ZZ-4
>/END OF IFNZRO ZZ
>/END OF DEF KL8A
	KL8A A8TM0,T00BLK,T01BLK,T02BLK,T03BLK
	KL8A A8TM1,T04BLK,T05BLK,T06BLK,T07BLK
	KL8A A8TM2,T10BLK,T11BLK,T12BLK,T13BLK
	KL8A A8TM3,T14BLK,T15BLK,T16BLK,T17BLK
ZZ=TTYN
IFNZRO ZZ <
ZZ=ZZ-4
INTTTY,	MSAB >
IFNZRO ZZ < MSAB1
ZZ=ZZ-4>
IFNZRO ZZ <
ZZ=ZZ-4
MSAB2>
IFNZRO ZZ <MSAB3>
	JMP I [INTTY9
Z=TTYN
/INITIALIZE KL8AS
KL8I,	0
	NL1	/ENABLE INTR
IFNZRO Z <MCCD
	MSIE
Z=Z-4>
IFNZRO Z <MCCD1
	MSIE1
Z=Z-4>
IFNZRO Z <MCCD2
	MSIE2
Z=Z-4>
IFNZRO Z <MCCD3
	MSIE3>
Z=TTYN
IFNZRO Z <TAD (KL8A1-1
	MSLB
Z=Z-4>
IFNZRO Z <TAD (10 /KL8A2
	MSLB1
Z=Z-4>
IFNZRO Z <TAD (10 /KL8A3
	MSLB2
Z=Z-4>
IFNZRO Z <TAD (10 /KL8A4
	MSLB3>
	NL0
	JMP I KL8I 


>/END OF IF NZRO TTYN
/THE FOLLOWING IS AN INTERFACE TO FIELD0 FROM FIELD 1
F0I42,	JMS	RECI42
	CIF	10	/RETURN TO FIELD 1
	JMP	XST41
	PAGE
/SEND XOF TO TERMINAL ASAP
XOFT,	TAD	(LDBXPT
	TAD	DDB
	DCA	TEMP1
	TAD	(XOFMS-1
	DCA I	TEMP1
	JMS	TTYGO
	JMP	RCVTT0
/HERE TO SKIP AN EXTENSIBLE FIELD
GETEXN,	0
	JMS	GTCHR
	DCA	TEMP1
	TAD	TEMP1
	AND	(0200		/MASK OFF EXT BIT
	SNA CLA	
	JMP	GETEX2
	DCA	GTSAV		/ZERO TEMP LOC FOR DTR/RING BITS
	DCA	GTSAV1
	JMS	GTCHR
	CLL RTL
	CLL RTL
	SPA
	  HLT
	CLL RTL
	SZL		/IS RING CARRIER BIT SET
	ISZ	GTSAV	/YES
	CLL RAL
	SZL
	ISZ	GTSAV1	/DTR IF STAATUS
	TAD	(-200
	TAD	TEMP1
	DCA	TEMP1
	TAD	GTSAV
	CLL RAL		/LINK SHOULD CONTAIN DTR BIT
	TAD	GTSAV1
	BSW
	CLL RAR		/SHIFT SO BIT ARE 140 AND SAVE OR
GETEX2,	DCA	GTSAV	/CLEAR FOR LATER USE BY EXAD AND RCTBIT
	TAD	TEMP1
	JMP I	GETEXN
GTSAV,	0
GTSAV1,	0
EXPT,	0
EXAD,	0
	TAD	GTSAV
	TAD I	EXPT
	DCA I	EXPT		/ADD BITS
	JMP I	EXAD	/NO SO RETURN
RCTBIT,	0
	DCA	EXAD		/SAVE 1 OR 2 
	JMS	GETEXN		/GET BITS 10 WANTS TO CHANGE
	AND	(20		/CHECK TO SEE IF STATUS IMAGE BIT INVOLVED
	SNA CLA
	JMP	IMG1		/IMAGE BIT IS NOT INVOLVED [1(16)]
IMG,	TAD	TEMP1		/GET BITS
	AND	(7757		/MASK OUT IMAGE BIT
	DCA	EXPT		/SAVE
	TAD	(ESC
	JMS	STCHR		/STORE ESCAPE AND TURN OFF INTERRUPTS [1(16)]
	TAD	EXAD		/GET 1 OR 2 AS SET IN AC ON CALL
	JMS	STCHR		/STORE IN DATA  STREAM
	ION			/TURN ON INTERRUPTS AGAIN [1(16)]
	TAD	EXPT		/GET STATUS BIT PATTERN
	DCA	TEMP1
IMG1,	TAD	(DEVDSL
	TAD	DDB
	DCA	EXPT		/SAVE LOC POINTER
	TAD	GTSAV		/LOC HAS BEEN SET BY LAST CALL TO GETEXN
	CMA
	IOF			/INTERRUPT OFF WHEN CHANGING STATUS
	AND I	EXPT
	DCA I	EXPT		/SHUT OFF BITS IN STATUS IF MASK IN GTSAV 1
	TAD	TEMP1		/GET CHANGE BITS AGAIN
	CMA			/COMPLEMENT
	AND I	TEMP6		/GET DDCMP STATUS WORD WITHOUT BITS
	JMP I	RCTBIT
RCDSTA,	JMS	GTCHR		/GET TYPE
	TAD	(-2		/CLEAR BITS?
	SZA CLA
	  JMP	RCVFLU
	TAD	(DEVDDC
	TAD	DDB
	DCA	TEMP6
	JMS	GETEXN
	CMA
	AND I	TEMP6
	DCA I	TEMP6
	JMP	RCVFLU
/CALL WITH TEMP3 POINTING TO STRING OF CHUNKS
SKPEXN,	0
	JMS	GTCHR
	AND	(200	/CHECK EXTENSIBLE BIT
	SZA		/SKIP IF DONE
	JMP	SKPEXN+1	/OTHERWISE
	JMP I	SKPEXN	/RETURN
	INSRT2
/	***********************************************************
/	***********************************************************
/	***							***
/	***			RECINT-DDCMP			***
/	***		BASE LEVEL TTY INPUT HANDLING		***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO HANDLE TTY INPUT
/ CALLED FROM LOOP - WILL RETURN TO LOOP
/ TAKES NEXT CHAR FROM TTIQUE AND PUTS IT INTO AN INPUT CHUNK
/TEMP USAGE IS
/	TEMP8	IS POINTER TO LDBXPT
/	TEMP7	ADR OF DDCMP STATUS WORD
/	TEMP6	ADR OF DEVBF1
/	TEMP5	CHAR
/	TEMP4	ADR OF CHRTAB BITS

/DEVDDC BITS
/	0001	/DEFERED ECHO MODE
/	0002	/TRANSLATE LOWER CASE TO UPPER
/	0004	/OUTPUT HAS BEEN FROZEN BY TYPEIN OF XOF
/	0010	/IMAGE MODE INPUT
/	0020	/IMAGE MODE OUTPUT
/	0040	/TTY PAGE IN EFFECT
/	0100	/TTY TAPE FEATURE(IMPLIES SUPPRESS NORMAL CR HANDLING)
/	0200	/TTY HAS HDW TAB
/	0400	/INPUT STOPPED BY SENDING XOFF TO TTY

	PAGE
RECIN0,	ION			/MATCHES IOF AT RECINT
	TAD	TEMP5		/GET CHARACTER
	AND	[0177		/SEVEN BITS ONLY
	TAD	(CHRTAB		/SCNSER CHAR TABLE ADR
	DCA	TEMP4		/SAVE ADR OF CHAR TYPE BITS

	NLOAD	DEVSTS
	TAD	DDB		/MAKE STATUS ADR
	DCA	DDBSTS		/SAVE FOR TTYGO

	Q=DEVBF1-DEVSTS
	NLOAD	Q
	TAD	DDBSTS
	DCA	TEMP6		/SAVE POINTER TO DEVBF1

	TAD	(LDBXPT
	TAD	DDB
	DCA	TEMP8		/SAVE POINTER TO XOF LEVEL STRING

	Q=DEVDDC-DEVSTS
	NLOAD	Q
	TAD	DDBSTS		/DEVICE STATUS
	DCA	TEMP7		/SAVE ADR OF DEVDDC

RECIN,
	TAD	(0010		/MASK FOR IMAGE MODE INPUT
	AND I	TEMP7		/COMPARE AGAINST DDCMP STATUS
	SZA CLA			/SKIP IF NOT IN IMAGE MODE INPUT
	  JMP	RECIN1		/IMAGE MODE INPUT
	TAD	TEMP5		/GET CHARACTER
	SNA CLA			/CHECK FOR NULL
	  JMP	LOOP		/FLUSH NULLS

	NLOAD	CHRLC		/MASK FOR CHAR IS LOWER CASE
	AND I	TEMP4		/TEST AGAIN CHRTAB
	SNA CLA
	  JMP	RECIN1		/CHAR IS NOT LOWER CASE
	NLOAD	2		/MASK FOR SHOULD TRANSLATE
	AND I	TEMP7		/COMPARE AGAINST DDCMP STATUS
	SZA CLA
	  TAD	(-240		/CONVERT TO UPPER CASE
	TAD	TEMP5		/ AND COMPLEMENT PARITY BIT
	AND	[0377		/CLEAR EXTRANEOUS BITS, INCLUDING "LAST IN CHUNK" FLAG
	DCA	TEMP5		/ AND SAVE CHAR AGAIN

RECIN1,	TAD	(DEVRCN	/POINT TO RCN IN DDB TO SEE IF TRIING TO CONNECT 
	TAD	DDB
	DCA	TEMP3
	TAD I	TEMP3
	SZA CLA		/TRY TO ISSUE CONNECT
	JMP	CONDN	/ALREADY TRIED TO ISSUE CONNECT
	NLOAD	CONBIT		/MASK FOR DEVICE CONNECTED
	AND I	DDBSTS
	SNA CLA			/IS IT CONNECTED ?
	  JMP	CONTYP		/NO SO TELL USER
	TAD	(-ERSCNT
	TAD	FRECNT
	SPA CLA
	  JMP	BELTYP		/NO FREE CHUNKS
	TAD	TEMP6		/DEVBF1
	IAC			/DEVBF2
	DCA	TEMP3
	TAD I	TEMP3
	DCA	TEMP3
	JMS	GETCHR
	NL0
	TAD	(-30		/24 DECIMAL
	SMA CLA			/HAS USER TYPED FAR AHEAD ?
	  JMP	BELTYP		/YES SO DING HIM
RECIN2,	JMS	RECI42		/PUT STATUS INTO THE MESSAGE
	NLOAD	1		/MASK FOR DEFERRED ECHO
	AND I	TEMP7		/COMPARE WITH DEVDDC
	SZA CLA			/SKIP IF NOT DEFERRED ECHO
	  JMP	RECIN5		/ALREADY IN DEFERRED ECHO MODE

	NLOAD	DEVOAD		/POINTER TO OUTPUT DATA
	TAD	DDB
	DCA	TEMP1
	TAD I	TEMP1
	SZA CLA			/IS THERE OUTPUT DATA WAITING ?
	  JMP	RECIN4		/YES SO GO INTO DEFERRED ECHO MODE
	Q=LDBFPT-LDBXPT
	NLOAD	Q
	TAD	TEMP8
	IOF			/WE WILL MODIFY INTERRUPT LOCATIONS
	DCA	TEMPA		/SAVE POINTER TO LDBFPT
	TAD	TEMPA		/GET LDBFPT
	IAC
	DCA	TEMPB		/SAVE POINTER TO LDBCHR
	TAD I	TEMPA		/GET FILLER WAITING
	TAD I	TEMPB		/ANY CHARS LEFT TO ECHO FROM BEFORE ?
	SZA CLA
	  JMP	RECIN4		/YES SO ENTER DEFERRED ECHO MODE
	TAD I	TEMP4		/GET CHRTAB BITS FOR THIS CHARACTER
	SPA CLA			/IS CHAR A BREAK CHAR ?
	  JMP	RECIN4		/YES SO ENTER DEFERRED ECHO MODE
	JMS	RECIN6		/PUT CHAR INTO THE INPUT CHUNKS
	TAD	TEMP5		/GET CHAR TO ECHO
	AND	[0177		/SEVEN BITS ONLY
	TAD	(-15		/TEST FOR CARRIAGE RETURN
	SNA CLA
	  JMP	RECI36		/CHAR IS A CR
	TAD	TEMP5		/GET CHAR TO ECHO
	DCA I	TEMPB		/AND PUT IT INTO LDBCHR
TSTART,	JMS	TTYGO		/TRY TO START THE TTY
	JMP	LOOP		/AND BACK TO THE BIG LOOP
/TRY TO ESTABLISH A CONNECT TO A HOST WITH AN MCR
CONTYP,	TAD	(NEITAB-1	/TRY TO FIND MCR IN NEITAB [1(20)]
	DCA	TEMPB
CONSC,	ISZ	TEMPB
	TAD I	TEMPB
	AND	(1000	/DOES IT HAVE AN MCR
	SZA CLA		/NO
	JMP	CONFD	/MCR FOUND
	TAD	(-NEIEND	/CHECK FOR END OF TABLE
	TAD	TEMPB
	SZA CLA
	JMP	CONSC	/CONTINUE SCAN
	JMP	CONDN

	PAGE

/HERE TO SET DEFERRED ECHO MODE
RECI37,	0
	TAD	DDB
	IOF			/IN CASE NEED TO CALL ISBDDC
	DCA	INTDDB
	NLOAD	1		/DEFERRED ECHO MODE BIT
	JMS	ISBDDC		/SET BIT IN DEVDDC
	JMS	RECI42		/PUT STATUS INTO THE MESSAGE
	JMP I	RECI37

/HERE TO SET DEFERRED ECHO MODE
RECIN4,	JMS	RECI37		/SET DEFERRED-ECHO MODE

/HERE IF TTY IS IN DEFERRED ECHO MODE
RECIN5,	JMS	RECIN6		/PUT CHAR INTO THE INPUT CHUNKS
	TAD	DDB
	IOF			/IN CASE NEED TO CALL ISBDDC
	DCA	INTDDB
	TAD	(CHRXOF		/MASK FORXOF BIT
	AND I	TEMP4		/MASK AGAINST CHRTAB BITS
	SNA CLA
	  JMP	LOOP		/NOT AN XOF
	TAD I	TEMP7		/GET DEVDDC
	AND	[0040		/MASK FOR TTY PAGE
	SNA CLA
	  JMP	LOOP		/NOT IN TTY PAGE
	JMP	RCX

/HERE TO PUT AN INPUT CHAR INTO THE CHUNKS
RECIN6,	0
	TAD	TEMP6		/GET ADR OF DEVBF1
	IAC
	DCA	TEMP2		/SAVE POINTER TO DEVBF2
	TAD I	TEMP2		/GET DEVBF2(=POINTER TO DATA COUNT)
	SZA CLA
	  JMP	RECI62
	NL1
	JMS	RECI70		/PUT COUNT INTO THE CHUNKS
	TAD I	TEMP3		/GET LDBIPT
	DCA I	TEMP2		/SET DEVBF2
	NL1			/TYPE=1 FOR DATA
	JMS	RECI70		/PUT LINE NUMBER INTO THE CHUNKS
RECI62,	TAD	TEMP5		/GET THE CHARACTER WE JUST GOT
	JMS	RECI70		/PUT IT INTO THE CHUNKS
	TAD I	TEMP2		/GET DEVBF2
	DCA	TEMP2
	RCKFLD
	ISZ I	TEMP2		/COUNT IT
	TABFLD
	JMP I	RECIN6

/HERE TO PUT STATUS INTO INPUT STRING FOR A LINE
RECI42,	0
	NLOAD	1		/MASK FOR NEED TO SEND STATUS
	AND I	DDBSTS		/CHECK AGAINST DEVSTS
	SNA CLA
	  JMP I	RECI42		/DON'T NEED TO
	TAD	TEMP6		/GET POINTER TO DEVBF1
	IAC			/MAKE INTO POINTER TO DEVBF2
	DCA	TEMP1
	DCA I	TEMP1
	NLOAD	4		/CHAR COUNT FOR STATUS IS ALWAYS 4 CHARS
	JMS	RECI70
	NL3			/STATUS IS TYPE 3
	JMS	RECI70		/PUT CODE INTO THE MESSAGE
	JMS	RECI70		/STC=0
	TAD	(DEVDSL		/GET EXTRA 2 BITS OF STATUS STORED 
	TAD	DDB
	DCA	TEMP1		/SAVE ADDRESS TO STATUSBITS
	TAD I	TEMP1
	AND	(140	/MASK ONLY DESIRED BITS
	DCA	TEMP1		/SAVE BITS
	TAD I	TEMP7		/GET DEVDDC
	AND	[0177		/SEVEN BITS ONLY
	TAD	(0200		/ADD EXTENSIBLE BIT
	JMS	RECI70		/PUT 1ST HALF OF STATUS INTO STRING
	TAD I	TEMP7		/GET DEVDDC AGAIN
	BSW
	CLL RAR
	AND	(0037		/STRIP EXTRA BITS
	TAD	TEMP1		/ADD DTR R,C BITS
	JMS	RECI70		/PUT INTO THE STRING
	NLOAD	7776		/MASK FOR NEED-TO-SEND-STATUS BIT
	IOF
	AND I	DDBSTS
	DCA I	DDBSTS
	JMP I	RECI42
/HERE TO PUT A CHARACTER INTO THE CHUNKS
/ CALL	JMS	RECI70	WITH CHAR IN AC
/	RETURN
RECI70,	0
	IOF
	DCA	INTMP4		/SAVE CHAR
	TAD	(LDBIPT
	TAD	DDB
	DCA	TEMP3		/SAVE POINTER TO LDBIPT
	TAD I	TEMP6		/GET DEVBF1
	SZA CLA
	  JMP	RECI72		/ALREADY HAVE AT LEAST ONE CHUNK
	JMS	ERSGET		/GET A CHUNK
	DCA I	TEMP6		/SET DEVBF1
	TAD I	TEMP6		/GET DEVBF1 AGAIN
	DCA I	TEMP3		/SET LDBIPT
RECI72,	TAD I	TEMP3		/GET LDBIPT
	IAC
	AND	[CNKSIZ-1
	SZA CLA
	  JMP	RECI75
	TAD I	TEMP3		/GET LDBIPT
	AND	[-CNKSIZ	/MAKE ADR OF LINK WORD
	DCA	INTMP3		/SAVE ADR OF LINK WORD
	JMS	ERSGET		/GET ANOTHER CHUNK
	RCKFLD
	DCA I	INTMP3		/SET LINK ADR IN PREVIOUS CHUNK
	TAD I	INTMP3		/GET CHUNK ADR AGAIN
	TABFLD
	DCA I	TEMP3		/SET LDBIPT
RECI75,	TAD I	TEMP3		/GET ADR OF PREVIOUS CHAR
	DCA	INTMP3
	NLOAD	3777		/MASK FOR LAST DATA BIT
	RCKFLD
	AND I	INTMP3		/STRIP PREVIOUS CHAR OF LAST BIT
	DCA I	INTMP3		/AND SAVE IT AGAIN WITHOUT BIT
	ISZ	INTMP3		/ADVANCE TO NEXT CHAR SLOT
	NLOAD	4000		/MASK FOR LAST CHAR IN CHUNK
	TAD	INTMP4		/GET CHAR
	DCA I	INTMP3
	TABFLD
	ISZ I	TEMP3		/ADVANCE LDBIPT
	ION
	JMP I	RECI70		/RETURN TO CALLER

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***			DDCMP - XMTINT			***
/	***		INTERUPT LEVEL TTY HANDLING		***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE AT INTERRUPT LEVEL TO GET NEXT CHAR TO SEND TO A TTY
/ CALL	LOAD INTDDB WITH ADR OF BLOCK
/	JMS	XMTINT	WILL FIND NEXT CHAR AND TYPE IT
/	RETURN		WILL CLRACT IF ALL DONE
/		AC MAY CONTAIN GARBAGE ON RETURN
/
/ TEMPORARY STOARAGE IS:
/	INTMP7		/POINTER TO DEVTIM
/	INTMP6		/CHAR TO TYPE
/	INTMP5		/POINTER TO DEVSTS

XMTDIS,	JMP I	XMTINT
XMTINT,	0

/CLEAR IRMA BIT
	NLOAD	DEVSTS		/RELATIVE ADR OF STATUS WORD
	TAD	INTDDB
	DCA	INTMP5		/SAVE POINTER TO DEVSTS
	TAD	(DEVTIM		/RELATIVE ADR OF DEVICE TIME
	TAD	INTDDB		/MAKE ABSOLUTE
	DCA	INTMP7		/SAVE POINTER TO DEVTIM

/CLEAR THE IRMA BIT
	Q=-IRMBIT-1
	NLOAD	Q		/MASK TO CLEAR IRMA BIT
	AND I	INTMP5
	DCA I	INTMP5

/SEE IF WE ARE SIMULATING A TAB
	TAD	(CHRBLA		/POINT TO A WORD WHICH HAS HORIZONTAL MOTION BIT ON
	DCA	INTMP1		/STORE ADDRESS OF THIS WORD
	NL4			/MASK FOR TAB SIMULATION BIT
	AND I	INTMP5		/LOOK AT STATUS
	SZA CLA
	  JMP	IXMT33		/YES, CONTINUE

/CHECK TO SEE IF WE ARE TIMING A FILLER
	TAD I	INTMP7		/GET DEVTIM
	SZA CLA			/ARE WE DOING A FILLER ?
	  JMP	IXMT92		/YES SO JUST CLEAR THE INTERRUPT

/FIRST CHECK IF THERE IS ANY XON/XOF LEVEL OUTPUT
	TAD	(LDBXPT
	TAD	INTDDB
	DCA	INTMP4
	TAD I	INTMP4		/PICK UP POINTER
	SZA
	  JMP	IXMT15		/YES THERE IS XON/XOF OUTPUT
	ISZ	INTMP4		/NOW TRY FILL CLASS POINTER
	TAD I	INTMP4
	SNA			/IS THIS POINTER READY ?
	  JMP	IXMT17		/KEEP LOOKING

/FOLLOWING IS USED BOTH FOR XON/XOF LEVEL, AND FOR FILL LEVEL OUTPUT
IXMT15,	ISZ I	INTMP4		/ADVANCE MEMORY COPY OF POINTER
	IAC			/ADVANCE AC COPY OF POINTER
	DCA	INTMP1
	TAD I	INTMP1		/GET NEXT CHAR
	SMA			/IS THIS LAST CHAR IN STRING ?
	  JMP	IXMT30		/NO SO JUST TYPE IT
IXMTA,	DCA	INTMP6		/SAVE CHAR
	DCA I	INTMP4		/CLEAR POINTER
	JMP	IXMT32		/GO TYPE THE CHAR

IXMT17,	ISZ	INTMP4		/ADVANCE TO LDBCHR
	TAD I	INTMP4		/SEE IF THERE IS A CHAR IN SLOT
	SNA			/WAS THERE A CHAR ?
	  JMP	IXMT20		/NO - TRY FOR OUTPUT
	JMP	IXMTA

/CHECK TO SEE IF THERE ARE ANY OUTPUT CHARS
IXMT20,	Q=DEVDDC-DEVSTS
	NLOAD	Q
	TAD	INTMP5		/MAKES ADR OF DEVDDC
	DCA	IXPT
	NLOAD	4		/MASK FOR OUTPUT FROZEN WITH XOF
	AND I	IXPT		/COMPARE AGAINST DEVDDC
	SNA CLA			/WAS OUTPUT FROZEN ?
IXMTC,	JMS	IGTOCH		/TRY TO GET ANOTHER CHAR FROM THE CHUNKS
	  JMP	IXMT90		/NONE LEFT OR OUTPUT FROZEN
	DCA	INTMP6		/SAVE CHAR
	TAD	(-ESC
	TAD	INTMP6		/CHECK FOR ESC CHAR
	SZA CLA
	JMP	IXMT32		/NORMAL CHAR
/ESC ESC ESCAPE
/ESC 1 SET IMAGE MODE
/ESC 2 CLEAR IMAGE MODE
	JMS	IGTOCH
	HLT			/MUST HAVE CHAR FOLLOWING
	TAD	(-1
	SNA
	JMP	SETIMG		/SET IMAGE MODE
	TAD	(-1		/CLEAR IMAGE MODE
	SZA CLA
	JMP	IXMT32		/OUTPUT ESC CHAR
CLRIMG,	TAD	(7757
	AND I	IXPT
CLRIM1,	DCA I	IXPT
	JMP	IXMTC
SETIMG,	TAD	(7757
	AND I	IXPT
	TAD	(20
	JMP	CLRIM1
IXPT,	0

/HERE TO TYPE NEXT CHAR
IXMT30,	DCA	INTMP6		/SAVE CHAR
IXMT31,
IXMT32,	TAD	INTMP6		/GET CHARACTER AGAIN
	AND	[0177		/7 BITS ONLY
	TAD	(CHRTAB		/MAKE POINTER INTO THE CHARACTER TABLE
	DCA	INTMP1		/ADDRESS OF CHARACTER TABLE ENTRY
	NLOAD	Q
	TAD	INTMP5	/MAKES ADDR DEVDDC
	DCA	INTMP4	/SAVE
	TAD I 	INTMP4	/SEE IF PIM MODE
	AND	(20
	SZA CLA		/NOT PIM MODE
	JMP	IXMTB	/IF PIM SKIP CHK FOR TAB, FILLER
	TAD	(CHRHT
	AND I	INTMP1		/GET HT BIT
	SNA CLA
	  JMP	IXMT50
/HERE TO CHECK IF TTY HAS HARDWARE TABS
	TAD I	INTMP4		/DEVDDC
	AND	(200		/HDW TAB BIT OR IMAGE OUTPUT
	SZA CLA			/SKIP IF NEITHER
	  JMP	IXMTD		/EITHER OR BOTH, SO PRINT TAB
/START OF TAB SIMULATION
	NL4
	TAD I	INTMP5
	DCA I	INTMP5
	TAD	(CHRBLA		/POINT TO CHARACTER WITH HMO BIT ON
	DCA	INTMP1		/SAVE ADDRESS
	JMP	IXMT33
IXMTD,	TAD	(LDBCOL	/ADD TO NEXT TAB COL WHEN ISSUE HARDWARE TAB
	TAD	INTDDB
	DCA	INTMP3
	TAD I	INTMP3	/GET COL POSITION
	TAD	(10
	AND	(7770
	TAD	(-1	/IXMT50 ADDS ONE TO LDBCOL
	DCA I	INTMP3
	JMP	IXMT50
	PAGE
IXMT50,
	NLOAD	CHRFLL		/MAKE MASK FOR CHAR NEEDS A FILLER
	AND I	INTMP1		/GET SPECIAL CHARACTER BITS
	SNA CLA
	  JMP	IXMT33		/DOESN'T NEED A FILLER
	TAD	INTMP6		/GET CHARACTER AGAIN(MUST BE IN RANGE 10-15)
	AND	[0007		/THREE BITS ONLY
	TAD	(LDBFIL
	TAD	INTDDB
	DCA	INTMP2
	TAD I	INTMP2		/GET TIME TO STALL ON THIS CHAR
	SNA			/IS THERE ANY FILLER FOR THIS ONE ?
	  JMP	IXMT33		/NO
	DCA I	INTMP7		/AND SET DEVTIM
IXMT33,	TAD	(LDBCOL		/RELATIVE ADR OF HORIZONTAL POSITION
	TAD	INTDDB		/MAKE ABSOLUTE
	DCA	INTMP3		/SAVE LDBCOL ADDRESS
	TAD I	INTMP1		/GET CHRTAB BITS
	AND	(CHRHMO		/MASK FOR HORIZONTAL MOTION
	SZA CLA
	  ISZ I	INTMP3		/INCREMENT HORIZONTAL POSITION
	NL4			/TAB BIT MASK
	AND I	INTMP5		/SEE IF ON
	SNA CLA			/SKIP IF YES
	  JMP	IXMT34		/JMP IF NOT
	TAD I	INTMP3		/GET POSITION
	AND	[7		/LOOK AT LOW ORDER BITS
	SZA CLA			/SKIP IF AT TAB STOP
	  JMP	IXMT61
	TAD I	INTMP5		/GET STATUS
	AND	(7773
	DCA I	INTMP5
IXMT61,	TAD	(240		/GET EVEN PARITY BLANK [1(21)]
	DCA	INTMP6		/STORE AS CHARACTER
	JMP	IXMT38		/TYPE IT
IXMT34,
	TAD I	INTMP1		/GET CHRTAB BITS
	AND	(CHRCR		/MASK FOR CARRIAGE RETURN
	SZA CLA			/IS CHAR A CR ?
	  DCA I	INTMP3		/YES SO RESET TO COLUMN 0

IXMT38,	TAD I	INTMP3	/GET CHAR COUNT
	ISZ	INTMP3	/POINT TO WIDTH
	NEGATE
	TAD I	INTMP3
	SPA CLA		/GT=0 OK
	JMP	FRCR	/FORCE CARRIGE RETURN IF EXCEED LINE WIDTH
IXMTB,	IFNZRO TTYN <
	TAD	INTDDB
	TAD	(-CTYBLK
	SZA CLA			/IS THIS CHAR FOR THE CTY
	  JMP	INTYPE		/NO SO BRANCH TO DC02F OR KL8E ROUTINE
>/END OF IFNZRO TTYN

	TAD	INTMP6		/RETREIVE CHAR
IXMT60,	CTYTLS			/ECHO IT
	JMP	XMTDIS
/HERE WHEN NOTHING FOR A TTY TO DO
IXMT90,	NL3777			/MASK TO STRIP ACTIVE BIT
	AND I	INTMP5		/CLEAR ACTIVE BIT
	DCA I	INTMP5

IXMT92,	IFNZRO TTYN <
	TAD	INTDDB
	TAD	(-CTYBLK
	SZA CLA
	  JMP	XMTDIS		/CLEAR TTY
>/END OF IFZERO TTYN

	CTYTCF			/CLEAR TELEPRINTER FLAG
	JMP	XMTDIS		/DISMISS CALL TO XMTINT
FRCR,	TAD	(LDBFPT		/SET UP FILL POINTER
	TAD	INTDDB
	DCA	INTMP3
	TAD I	INTMP4		/CHECK FOR NO CRLF
	SPA CLA
	JMP	IXMTB		/NO AUTO CRLF
	TAD	(CRLMSG	/POINT TO CRLF LITERAL
	DCA I	INTMP3		/STORE AT FILL POINTER
	ISZ	INTMP3		/POINT TO LDBCHR
	TAD	INTMP6		/CHAR TO BE TRANSMITTED AFTER CRLF
	DCA I	INTMP3		/SAVE AT LDBCHR
	NL4		/CHECK TO SEE IF SIM TAB
	AND I	INTMP5
	SNA CLA
	JMP	FRCR1		/SIMULATING TAB
	TAD I	INTMP5	/TURN OFF BIT TO SIMULATE TAB
	AND	(7773
	DCA I	INTMP5
	TAD	(11		/OUTPUT A TAB AFTER CR
	DCA I	INTMP3
FRCR1,	TAD	(15		/CARRIAGE RETURN
	JMP	IXMT30		/OUTPUT CHAR
/TYPE 4 = CHARACTER GOBBLER
RCVGOB,
RCGOB1,	TAD	DDB
	IOF			/DISABLE INTERRUPTS FOR A WHILE
	DCA	INTDDB		/SETUP FOR CALL TO IGTOCH
	JMS	IGTOCH		/GET ANY OUTPUT CHARS
	JMP	RCVTT0
	NEGATE
	TAD	(ESC
	SNA CLA
	JMP	CMP1	/ESC CHAR FOUND
RCGOB2,	ION
	CLA
	JMP	RCGOB1
/INSERT ESC 1 FOR SET IMAGE MODE
/ESC 2 MEANS CLEAR IMAGE MODE
CMP1,	JMS	IGTOCH
	HLT		/ALWAYS 2 CHAR IN ESC SEQUENCE
	TAD	(-1	/CHECK FOR 1
	SNA
	JMP	SETI	/SET IMAGE MODE
	TAD	(-1
	SZA CLA		/CLEAR IMAGE
	JMP	RCGOB2	/NEITHER JUST AN ESC CHAR
	TAD I	TEMP6	/GET STATUS
	AND	(7757	/CLEAR BIT
CLRI,	DCA I	TEMP6
	JMP	RCGOB2
SETI,	TAD I	TEMP6
	AND	(7757
	TAD	(20	/SET IMAGE MODE
	JMP	CLRI
	PAGE
	LISTOG	LPTN

IFNZRO LPTN < 
/	***********************************************************
/	***********************************************************
/	***							***
/	***		LPT SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

/DDCMP COMPRESSES LINE PRINTER DATA AS FOLLOWS
/	1CCCCCCC	CCCCCCC IS CHARACTER
/	01XXXXXX	XXXXXX IS NUMBER OF BLANKS
/	001XXXXX	XXXXX IS REPETITION FOR FOLLOWING CHAR
/DEVDDC BITS
/	0001	FATAL ERROR
/	0002	OFF LINE
/	0004	OUT OF PAPER
/	0010	PAPER JAM
/	0020	OFF LINE BECAUSE OF OPERATOR
/	0040	SLEW ERROR
/	0100	HAMMER FIRING ERROR
/	0200	LOW ON PAPER
/	0400	STACKER FULL
/	1000	OUT OF INK
/	2000	PRINT QUALITY BAD

LPTVTB,	DCA	INTMP1		/SAVE MASK FOR VFU SEARCH
	TAD	[0012		/LINE FEED
	DCA	LPTCHR
	TAD	LPTLNE		/LINE # WE ARE ON
	DCA	INTMP3		/SAVE POINTER TO VFU TAPE
LPTVT3,	ISZ	LPTLNE
	TAD I	LPTLNE		/GET CURRENT LINE STOPS
	SPA
	  JMP	LPTVT4		/END OF TAPE SO DO A FF
	AND	INTMP1		/USE MASK ON IT
	SNA CLA			/IS THIS HOLE PUNCHED ON TAPE ?
	  JMP	LPTVT3
	TAD	LPTLNE		/GET POINTER TO VFU TABLE
	CMA			/MAKE -LPTLNE-1
	TAD	INTMP3		/MAKES # OF LINES TO SKIP
	JMP	LPTX15		/ZERO LPTCOL THEN GO PRINT CHAR
LPTVT4,	TAD	LPTLNE
	NEGATE
	TAD	INTMP3		/LEAVES NUMBER OF LINES TO SKIP-1
	SZA CLA			/WERE WE ON LAST LINE ?
	  JMP	LPT014		/NO SO DO A FORM FEED
	JMP	LPTX14		/YES SO DO A LINE FEED

LPTHN2,	TAD	[0040
	ISZ	LPTZCT
	  JMP	INTLP4		/PRINT SPACE
	NL6000
	TAD	LPTOPV
	CDFINS
	DCA	LPTPIV
	CDFCNK
	JMP	INTLP0+1

LPTOFN,	0		/SEND OFFLINE MESSAGE FOR LPT
/	NL0		/CLEAR AC	[1(17)] ALL CALLERS CLEAR AC
	TAD	(LPTBLK
	DCA	INTDDB
	NL2
	JMS	ISBDDC
	JMP I	LPTOFN
INTLPT,
IFNDEF LA180 <	LPTSKF			/SKIP ON LPT FLAG
>/END OF IFNDEF LA180
IFDEF LA180 < PBST	>/END OF IFDEF LA180 SKIP IF INTR FROM LPT
	  JMP	INTLP8		/NOT LPT SO KEEP LOOKING
	JMS	INTLP0
	JMP	INTDIS

INTLP8,	TAD I	(LPTBLK+DEVSTS	/GET LPT STATUS
	SPA CLA			/SKIP IF NOT ACTIVE
LPXXSE,	LPTSKE			/SKIP ON LPT ERROR		########
				/ INSTRUCTION CHANGED BY SYSCHK FOR LS8E AND LA180
	  JMP	INTLP9		/NOT LPT ERROR OR NOT ACTIVE
IFNDEF LA180 <
	JMS 	LPTOFN		/SEND OFF LINE MESSAGE
	NL3777			/CLEAR ACTIVE
	AND I	(LPTBLK+DEVSTS
	DCA I	(LPTBLK+DEVSTS
	LPTCIE			/CLEAR INTERRUPT ENABLE
	JMP	INTDIS
>/END OF IFNDEF LA180
/HERE ONCE PER CLOCK TICK TO SEE IF LPT NEEDS SERVICE
CLKLPT,	IOF			/DISABLE INTERRUPTS WHILE CHECK LPT
	TAD I	(LPTBLK+DEVSTS	/GET ACTIVE/INACTIVE STATUS
	SMA CLA			/IS LPT ACTIVE ?
	  JMP	STRLPT		/NO TRY TO START IT
	ISZ I	(LPTBLK+DEVTIM	/YES HAVE WE TIMED OUT ?
	  JMP	CLKLP8		/HASN'T TIMED OUT
/HERE WHEN LPT TIMES OUT
	JMS	LPTOFN		/SEND OFF LINE MESSAGE 
	NL2000
	CDFINS
	TAD	LPTPIV
	SMA			/IS PIVOT ALREADY A JMP(I.E. OPCODE 5) ?
	  DCA	LPTOPV		/NO SO SAVE PIVOT
	NL0
	TAD	LPTCOL
	CMA
	DCA	LPTZCT
	TAD	(JMP I LPTHNG
	DCA	LPTPIV
	CDFCNK
IFNZRO FTTRBL <
	TAD	(LPTMSG-1
	DCA	ERRFLG		/LEAVE MSG FOR OPERATOR
>/END OF IFNZRO FTTRBL
	TAD	[0015		/CARRIAGE RETURN
IFDEF LA180 <
	CMA		/LA180 INTERFACE REQUIRES COMP DATA
	DBTD	>/END OF IFDEF LA180 TRANSMIT DATA
IFNDEF LA180 <	LPTSTB			/PRINT IT
>/END OF IFNDEF LA180
	JMP	CLKLP8

/HERE TO TRY TO START LPT WHEN NOT ACTIVE
STRLPT,
	TAD I (LPTBLK+DEVOAD  /GET OUTPUT CHAR ADR
LPXYSE,	LPTSKE			/DON'T TRY IF LPT IS IN TROUBLE		########
				/ INSTRUCTION CHANGED BY SYSCHK FOR LS8E AND LA180
	SNA CLA			/ANY OUTPUT FOR LPT ?
	  JMP	CLKLP7		/NO
	NL1			/NEED FOR LS8E
IFNDEF LA180 <
	LPTSIE			/SET INTERRUPT ENABLE
>/END OF IFNDEF LA180
IFDEF LA180 <	DBSE	>/ENABLE INTERRUPT END OF IFDEF LA180
	NLOAD	4000		/FLAG DEVICE IS ACTIVE
	TAD I	(LPTBLK+DEVSTS
	DCA I	(LPTBLK+DEVSTS
	JMS	INTLP0		/BEGIN PRINTING
CLKLP8,	ION
	NL0			/BECAUSE THERE MAY BE GARBAGE IN AC
	JMP	CLKLP9
>/END OF IFNZRO LPTN
	LISTOG	LPTN
/HERE WHEN DONE WITH A MESSAGE(NUMBERED OR UNNUMBERED)
RCVADV,
	NL0
	IOF
	TAD	(CTLSIZ
	TAD	RCVTKR		/ADVANCE TO NEXT SLOT
	TAD	(-RCVLIM
	SNA			/CHECK FOR OUT OF RANGE
	TAD	(RCVQUE-RCVLIM
	TAD	(RCVLIM		/ADJUST
	DCA	RCVTKR		/SAVE NEW SLOT ADR
	JMP	LOOP		/REENTER HUGE LOOP

IACTCK,	0
	DCA	INTDDB		/SAVE DEVICE BLOCK ADR
	NLOAD	DEVSTS
	TAD	INTDDB
	DCA	IDBSTS
	TAD I	IDBSTS		/GET DEVSTS
	SMA CLA			/SKIP IF DEVICE IS ACTIVE
	  JMP	INTDIS	/DISMISS INTERRUPT
	JMP I	IACTCK		/RETURN TO CALLER
	LISTOG	LPTN
IFNZRO LPTN < PAGE
LPTBBB,	JMS	IGTEXN		/GET THE EXTENSIBLE NUMBER = COUNT
	  JMP	LPTFIN		/NONE SO DONE
IFNZRO FTDEBUG <
	SNA
	  HLT
>/END OF IFNZRO FTDEBUG
	TAD	[-1
	DCA	LPTCNT
	JMS	IGTOCH
	  JMP	LPTFIN
LPTGGG,	NLM1			/PREPARE TO DECREMENT COUNT
	TAD	LPTCNT
	SPA			/ARE THERE CHARS LEFT ?
	  JMP	LPTBBB		/NO SO GET A COUNT
	DCA	LPTCNT		/YES RESTORE COUNT
	JMS	IGTOCH		/GET THE NEXT CHAR
	  JMP	LPTFIN
	DCA	LPTCCH		/SAVE CHAR AND FLAG BITS
	TAD	LPTCCH
	AND	[0200		/IS THIS A COMPRESSED CHAR ?
	SZA CLA			/IS THIS A NICE CHAR
	  JMP	LPTFFF
LPTXXX,	TAD	LPTCCH		/GET FLAG BITS AGAIN
	AND	(0100		/WAS THIS COMPRESSED BLANKS ?
	SZA CLA
	  JMP	LPTZZZ		/YES
	NLM1
	TAD	LPTCCH		/GET COUNT
	AND	(0037
	DCA	LPTCCN
	JMP	LPTGGG		/GO GET CHAR TO REPEAT
LPTZZZ,	TAD	LPTCCH
	AND	(0077		/LEAVE ONLY COUNT
	DCA	LPTCCN		/SAVE COUNT
	TAD	[0040		/BLANK
LPTVVV,	DCA	LPTCCH
	JMP	INTLP0+1
>/END OF IFNZRO LPTN
	LISTOG	LPTN
/RECEIVE STATION CONTROL MSG FOR DEPOSIT
RCVDP,	JMS	BTSCN		/SET UP ENTRY  IN BOOT TABLE
	TAD	(11		/SET UP ACCEPT TYPE FOR TRANSMIT
	DCA I	TEMPA		/PUT IN TABLE
	ISZ	TEMPA
	JMS	RADR		/GO GET ADDRESS FOR MSG
/GET DATA FROM MSG AND DEPOSIT AS GO THRU IT
	NLM1
	TAD	TEMPA		/GET ADDRESS FROM TABLE
	DCA	TEMPA
	TAD I	TEMPA
	DCA	DFLD		/CHANGE DATA FIELD INST
	NLM1
	TAD	TEMPA
	DCA	TEMPA
	TAD I	TEMPA
	DCA	DADR		/12 BITS OF DATA LOC
	ISZ	TEMPA
	ISZ	TEMPA		/RE-ALLIGN POINTER
RCVDP2,	JMS	GETCHR
	JMP	RCVDP1		/DONE WITH MSG
	DCA	TEMP1		/SAVE LOW ORDER 6 BITS
	JMS	GETCHR		/GET HIGH ORDER 6 BITS
	JMP	RJT		/SEND REJECT IF MSG BAD
	BSW
	TAD	TEMP1
DFLD,	0		/CHANGE DATA FIELD
	DCA I	DADR	/SAVE VALUE
	CDF	10	/POINT TO DEFAULT FIELD
	ISZ	DADR	/BUMP ADDRESS
	JMP	RCVDP2	/CONTINUE
	TAD	DFLD
	TAD	(10	/BUMP TO NEXT FIELD
	DCA	DFLD	/DONT CHECK FOR WRAP APOUND ASSUME FRIENDLY ENVIRONMENT
	JMP	RCVDP2
RCVDP1,	TAD	DADR
	DCA I	TEMPA		/STORE IN TABLE FOR XMT OF ACCEPT
	ISZ	TEMPA
	TAD	DFLD
	DCA I	TEMPA
	JMP	RCVFLU
DADR,	0
/GET ADDRESS OF DATA FROM STATION CTRL MESSAGES
RADR,	0
	JMS	GETCHR	/LOW ORDER 8 BITS
	JMP	RJT	/SOMETHING WRONG
	DCA I	TEMPA	/STORE IN TABLE
	JMS	GETCHR
	JMP	RJT
	DCA	TEMP1
	TAD	TEMP1
	BSW
	RTL
	AND	(7400
	TAD I	TEMPA
	DCA I	TEMPA
	ISZ	TEMPA
	TAD TEMP1
	RAR
	AND	(70
	TAD	(CDF
	DCA I	TEMPA
	ISZ	TEMPA
	JMP I	RADR
RJT,	ISZ	TEMPB	/TEMPB POINTS TO BEG OF ENTRY IN TABLE
	NL0
	TAD	(13		/SET UP REJECT
	DCA I	TEMPB
	JMP	RCVFLU
/BOOT TYPE STATION CONTROL MESGS 
/ONLY 3 OF THESE MSG ARE PROCESSED
/EXAMINE,DEPOSIT, AND GOTO
RCVBOT,	JMS	GTCHR	/GET SNA ALREADY STORED AT RSNA
	JMS	GTCHR	/TYPE
	TAD	(-3
	SMA SZA
	JMP	RCVFLU
	JMP	NJMPA

	PAGE
	LISTOG	LPTN
IFNZRO LPTN <

/HERE WHEN USER SENT LINE LONGER THAN PRINTER LINE
LPTWRP,	TAD	LPTCHR
	DCA	LPTOCH
	TAD	[0012		/PUT OUT A LINE FEED
	JMP	INTLP1

/HERE WHEN OUTPUT DATA FOR LPT IS EXHAUSTED
/FOLLOWING INSTRUCTION CHANGED TO NOP BY SYSCHK FOR LA180
LPTFIN,	LPTCLF			/CLEAR ANY FLAGS
	JMS	CLRACT
	JMS	ISTDDC	/UPDATE DDCMP STATUS
LPXXCE,
IFDEF LA180 <	DBCE	>/END OF IFDEF LA180 DISABLE INTERRUPT
IFNDEF LA180 <	LPTCIE			>/CLEAR INTERRUPT ENABLE		########
				/ INSTRUCTION CHANGED BY SYSCHK FOR LS8E
	JMP I	INTLP0		/RETURN TO CALLER

/HERE AT INTERRUPT LEVEL WHEN LPT INTERRUPTS
INTLP0,	0
	NL0			/IN CASE CAME FROM SPECIAL CHAR CODE
	TAD	(LPTBLK
	DCA	INTDDB
LPTPIV,	7402			/LPT PIVOT(SET TO NOP, SKP OR JMP)
	  JMP	INTLP6		/DO TAB FUNCTION
	NLM1			/GET SET TO DECREMENT
	TAD	LPTCCN		/DECREMENT COMPRESSED CHAR COUNT
	SPA			/ARE WE DECOMPRESSING ?
	  JMP	LPTGGG		/NO SO GET A CHAR FROM CHUNKS
LPTYYY,	DCA	LPTCCN		/SAVE COMPRESSED CHAR COUNT
LPTFFF,
	TAD	LPTCCH		/GET CHAR AGAIN
	AND	[0177		/SEVEN BITS ONLY
INTLP1,	DCA	LPTCHR		/SAVE CHAR
INTLPA,
	TAD	LPTCHR
	TAD	(CHRTAB
	DCA	INTMP1
	TAD I	INTMP1
	RTR
	SZL SPA			/SKIP IF NORMAL CHAR
	  JMP	INTLP5		/SPECIAL MOTION OR FLUSH

IFNZRO FTLPLC <	NL0	>
IFZERO FTLPLC <			/SPECIAL HANDLING FOR LPT'S WITHOUT LOWER CASE
	RAR			/SHIFT BIT FOR LC INTO POSITION
	SNL CLA			/IS CHAR LOWER CASE ?
	  JMP	INTLP2		/NOT LOWER CASE
	TAD	LPTCHR		/GET CHAR AGAIN
	TAD	(-40		/CONVERT TO UPPER CASE
	DCA	LPTCHR		/AND SAVE CHAR
>/END OF IFZERO FTLPC

INTLP2,
	ISZ	LPTCOL		/THIS ADVANCES PRINTER ONE COLUMN
	TAD	LPTCOL
	TAD	(-LPTWID
	SMA SZA CLA
	  JMP	LPTWRP		/NEED TO DO WRAP AROUND

INTLP3,	NL0
	TAD	LPTCHR		/GET CHAR AGAIN
INTLP4,
IFNDEF LA180 <
	LPTSTB
>/END OF IFNDEF LA180
IFDEF LA180	<	CMA
	DBTD		/TRANSMIT DATA
	CMA	>/END OF IFDEF LA180
	TAD	(-14
	SNA CLA			/WAS THIS A FORM FEED ?
	  TAD	LPTTFF		/YES
	TAD	LPTTCH		/TIME FOR NORMAL CHAR
	DCA I	(LPTBLK+DEVTIM
	JMP I	INTLP0
LPTTFF,	-100			/TIME FOR A FORM FEED		########
LPTTCH,	-32			/TIME FOR A NORMAL CHARACTER	########

/HERE WHEN CHAR MAY BE SPECIAL MOTION
INTLP5,				/CHECK IF CHAR TO BE FLUSHED
	SNL CLA			/IS CHAR GARBAGE ?
	  JMP 	LPTFLS		/FLUSH CHAR & RETURN TO CALLER
	TAD	LPTCHR		/GET CHAR AGAIN
	TAD	(LPTTBL-11
	DCA	INTMP1
	TAD I	INTMP1
	SNA			/IS THIS A TAB ?
	  JMP	LPT011		/YES
	SMA			/IS THIS A FF OR A CR ?
	  JMP	LPTVTB		/NO
	IAC
	SNA			/IS CHAR A CARRIAGE RETURN ?
	  JMP	LPT015		/YES
/HERE TO PRINT A FF ON LPT
LPT014,	NL0
	TAD	[0014
	DCA	LPTCHR
LPTX14,	TAD	(LPTVFU-1
	DCA	LPTLNE		/WE ARE AT LINE 0 AGAIN
	NLM2			/SAYS PRINT ONCE
LPTX15,	DCA	LPTRCT		/SET REPETITION COUNT
	TAD	(NOP
	DCA	LPTPIV
LPT015,	DCA	LPTCOL		/SET COLUMN 0 AGAIN
	TAD	[0015		/CARRIAGE RETURN
	JMP	INTLP4

/HERE TO SIMULATE A HORIZONTAL TAB ON LPT
LPT011,	TAD	LPTCOL		/GET CURRENT COLUMN
	AND	(0007
	TAD	(-10
	DCA	LPTRCT		/REPETITION COUNT
	TAD	(10
	TAD	LPTCOL
	AND	(7770
	DCA	LPTCOL
	TAD	[0040		/SPACE
	DCA	LPTCHR
	TAD	(NOP
	DCA	LPTPIV
	JMP	INTLP3		/GO PRINT FIRST COPY

INTLP6,	ISZ	LPTRCT		/INCREMENT COUNT
	  JMP	INTLP3		/PRINT CHAR
	TAD	(SKP
	DCA	LPTPIV
	TAD	LPTOCH
	SNA
	  JMP	INTLP0+1
	DCA	LPTCHR
	DCA	LPTOCH
	JMP	INTLPA

/HERE ON HUNG LPT
LPTHN1,	ISZ	LPTPIV
	JMP	LPT015

LPTFLS,	DCA	LPTCCN			/HERE TO FLUSH CHARACTER
IFNZRO	CDRN	<
	TAD I	(CDRBLK+DEVSTS	/SEE IF CDR ACTIVE
	SMA CLA			/SKIP IF ACTIVE
>/END OF IFNZRO	CDRN
	  JMP	INTLP0+1	/DO NEXT CHARACTER
IFNZRO	CDRN	<
	JMP	LPTFIN		/TURN OFF LPT ACTIVE; TICKS
				/WILL START IT UP AGAIN
>/END OF IFNZRO	CDRN

	PAGE
>/END OF IFNZRO LPTN
	LISTOG	LPTN
	DEFINE	INSRT1	<
TOOMNY,	JMS	GETEXN		/GET SLA
	DCA	TEMP2		/SAVE IT
	NL2			/REASON
DISCON,	DCA	TEMPA		/SAVE REASON
	TAD	DISREA		/GET CURRENT REASON
	SZA CLA			/CHECK IF WE'VE GOT DISCONNECT WAITING
/	  HLT			/TOO MANY TOO FAST
	  JMS I	[DMPTRP
	TAD	TEMP2		/PICK UP SLA
	DCA	DISSLA		/SAVE IT
	TAD	RSNA
	DCA	DISSNA
	TAD	TEMPA		/GET REASON
	DCA	DISREA		/STORE AND INDICATE THAT WE NEED TO SEND DISCONNECT
	JMP	RCVFLU		/GET RID OF MESSAGE

>/END OF DEFINE INSRT1


IFZERO	LPTN	<PAGE>
	LISTOG	CDRN
IFNZRO CDRN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CDR SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

/DATA SENT TO DECSYSTEM-10 IS ESSENTIALY IMAGE MODE
/	IF BIT 100 IS ZERO THEN DATA IS LOW ORDER 6BITS OF TWO CHARS
/	IF BIT 100 IS SET THEN DATA IS COMPRESSED:
/	BITS 060 SPECIFIY ZONE PUNCH:
/		0 IS NO ZONE PUNCH
/		1 IS 12 PUNCH
/		2 IS 11 PUNCH
/		3 IS 0 PUNCH
/	BITS 17 SPECIFY COLUMN PUNCH:
/		0 IS NO PUNCH
/		1 IS 1 PUNCH
/		2 IS 2 PUNCH
/		ETC.
/	TRAILING BLANKS ARE NOT TRANSMITTED.
/	REPRESENTATION	MEANING
/	1CCCCCCC	CCCCCCC = SEVEN BIT ENCODED CHARACTER
/	01XXXXXX	XXXXXX =COUNT OF BLANKS
/	001XXXXX	XXXXX = COUNT OF REPETITIONS, 0-31
/	0000CCCC
/	CCCCCCCC	CCCCCCCCCCCC = TWELVE BIT ENCODED CHARACTER
/
/ DEVDDC	-	DDCMP STATUS WORD
/	0001	CARD READER ERROR(MASTER ERROR)
/	0002	HOPPER EMPTY
/	0004	REGISTRATION ERROR
/	0010	INVALID PUNCH
/	0020	STACKER FULL
/	0040	JAM WHILE FEEDING
/	0100	PICK FAILURE
/	0200	END OF FILE CARD
/	0400	HDW EOF
/	1000	CDR OVERRAN THE PROCESSOR
/	2000	CDR HAS GONE OFF LINE
/	4000	CDR STOPPED(MAY BE CLEARED WITH A SET MODE)
/
/ DEVICE BLOCK
/	DEVOLC IS USED TO COUNT COLUMNS OF CARD
/	DEVOAD IS ADR OF LAST NONBLANK CHAR
/	DEVSTS USES EOFBIT

/CDRCNK IS WORST CASE NUMBER OF CHUNKS/CARD
	Z=CNKSIZ-4;	IFZERO Z <CDRCNK=66>
	Z=CNKSIZ-10;	IFZERO Z <CDRCNK=27>
	Z=CNKSIZ-20;	IFZERO Z <CDRCNK=13>
	Z=CNKSIZ-40;	IFZERO Z <CDRCNK=6>
	Z=CNKSIZ-100;	IFZERO Z <CDRCNK=3>
	Z=CNKSIZ-200;	IFZERO Z <CDRCNK=2>
/HERE FOR A DATA READY INTERRUPT FROM CARD READER
ICDRD0,	CDRCRB			/READ CARD COLUMN
	DCA	INTMP5		/SAVE IT
	TAD I	(CDRBLK+DEVSTS	/GET STATUS WORD FOR THE CDR
	SMA CLA			/IS CARD READER ACTIVE ?
	  JMP	INTDIS		/NO - PROBABLY LOCAL MODE
	TAD I	(CDRBLK+DEVOLC	/GET COUNT OF COLUMNS READ SO FAR
	TAD	(-120		/COMPARE COLUMN TO 80
	SMA CLA			/WAS IT GT 80 ?
	  JMP	ICDRD5		/ONLY READ 80 COLUMNS !!
	TAD I	(CDRBLK+DEVOLC	/GET CARD COLUMN COUNTER
	SZA CLA			/IS THIS THE FIRST COLUMN ?
	  JMP	ICDC14
	TAD	INTMP5		/GET CHARACTER AGAIN
	DCA I	(CDRBLK+DEVOAD	/SAVE COLUMN ONE
	JMP	ICDC19
ICDC14,	TAD	INTMP5		/GET THE CHARACTER AGAIN
	NEGATE
	TAD	CDCCHR		/GET LAST CHAR READ
	SZA CLA			/IS THIS A REPETITION
	  JMP	ICDC18		/NO SO PUT PREVIOUS CHAR INTO CHUNKS
	TAD	CDCCNT		/GET COUNT OF REPETITIONS
	TAD	(-37
	SMA CLA			/HAVE WE DONE AS MANY AS POSSIBLE
ICDC18,	  JMS	ICDC30		/PUT PREVIOUS CHARS INTO CHUNKS
ICDC19,	TAD	INTMP5		/GET THIS COLUMN AGAIN
	JMP	ICDC20

ICDC30,	0
	NLM1
	TAD	CDCCNT		/GET COUNT FOR COMPRESSION
	SNA			/DID WE HAVE ANY REPETITIONS ?
	  JMP	ICDC35		/NO JUST SEND THE CHAR
	TAD	(0041		/FLAG THIS IS A REPETION COUNT
	JMS	ICDRD6		/PUT COUNT INTO CHUNKS
ICDC35,	NL6000
	IAC CML RAR		/SET LINK & LOAD 7000
	AND	CDCCHR		/GET ROWS 12,11, & 0
	RTR
	RTR
	RAR			/POSITION BITS
	DCA	INTMP3		/AND SAVE FOR LATER USE
	TAD	CDCCHR		/GET THE CHAR AGAIN
	AND	(0017		/GET ROWS 6,7,8,9
	TAD	(CD2TAB
	DCA	INTMP2
	TAD	CDCCHR		/GET COLUMN AGAIN
	AND	(0760		/LEAVE ONLY ROWS 1/2/3/4/5
	RTR
	RTR
	TAD	(CD1TAB
	DCA	INTMP1
	TAD I	INTMP1
	TAD I	INTMP2
	TAD	INTMP3		/ADD ROWS 12/11/0
	SMA SNL			/CAN THE CHAR BE COMPRESSED ?
	  JMP	ICDC39		/PUT CHAR INTO CHUNKS
	NL6000			/BEGIN TO ASSEMBLE MASK
	CLL CML IAC RTR		/LEAVES 7400 IN AC
	AND	CDCCHR		/GET THE CHARACTER AGAIN
	RTL
	RTL
	RAL
	JMS	ICDRD6		/PUT HALF OF CHAR INTO THE CHUNKS
	NL3777			/MASK TO STRIP SIGN BIT
	AND	CDCCHR
ICDC39,	JMS	ICDRD6		/PUT REST OF COLUMN INTO CHUNKS
	DCA	CDCCNT		/INITIALIZE THE COUNT
	JMP I	ICDC30
/HERE TO PUT A CHAR INTO THE CHUNK BUFFER
ICDRD6,	0
	DCA	INTMP2		/SAVE CHAR
	NL1
	TAD	CDRADR
	AND	[CNKSIZ-1
	SZA CLA			/HAVE WE HIT A CHUNK BOUNDRY ?
	  JMP	ICDRD7		/NO
	NL4000
	RCKFLD
	TAD I	CDRADR
	DCA I	CDRADR		/FLAG LAST CHAR IN CHUNK
	TAD	CDRADR
	AND	[-CNKSIZ
	DCA	CDRADR		/MAKE POINTER TO LINK WORD
	JMS	ERSGET		/GET ANOTHER CHUNK FROM ERS
	RCKFLD
	DCA I	CDRADR
	TAD	INTMP1
	DCA	CDRADR		/LINK CHUNK INTO STRING

ICDRD7,	ISZ	CDRADR		/ADVANCE BUFFER POINTER
	TAD	INTMP2		/GET CHAR AGAIN
	RCKFLD
	DCA I	CDRADR		/SAVE CHAR IN BUFFER
	ISZ I	CDREXT		/COUNT CHAR INTO CHUNKS
	TABFLD
	JMP I	ICDRD6		/RETURN TO CALLER
/HERE TO CHECK FOR LOW PRIORITY CARD READER INTERRUPTS
INTCDR,	CDRSD			/SKIP ON CARD DONE FLAG
	  JMP	INTCD9		/NO TRY NEXT DEVICE
	CDRCRD			/CLEAR DONE FLAG
	TAD I	(CDRBLK+DEVSTS
	SMA CLA			/IS READER SUPPOSED TO BE ACTIVE ?
	  JMP	INTDIS		/NO SO JUST DISMISS
	TAD I	(CDRBLK+DEVOLC	/GET COUNT OF COLUMNS ON CARD
	TAD	(-120		/SHOULD BE 80 DECIMAL
	SZA CLA			/IS IT ?
	  JMP	INTCD2		/NO

	NL4000			/FLAG FOR LAST CHAR IN CHUNK
	RCKFLD
	TAD I	CDRADR		/GET LAST CHAR IN CARD
	DCA I	CDRADR		/SAVE IT WITH FLAG
	TAD	(0200
	AND I	CDREXT		/GET COUNT FOR BUFFER
	TABFLD
	JMP	INTCD4

	PAGE
INTCD4,	SNA CLA
	  JMP	INTCD1
	ISZ	CDREXT
	NL1
	SKP
INTCD1,	TAD	(0200
	RCKFLD
	TAD I	CDREXT
	DCA I	CDREXT
	TABFLD
	TAD I	(CDRBLK+DEVOAD	/GET COLUMN 1
	TAD	(-7417		/COMPARE WITH EOF
	SZA CLA
	  JMP	INTCD0		/WASN'T EOF SO CONTINUE
	TAD	(CDRBLK		/ADR OF DEVICE BLOCK
	DCA	INTDDB
	TAD	(4200		/FLAG CDR HAS STOPPED AND READ EOF
	JMS	ISBDDC		/TELL 10 WE SAW IT AND STOPPED
INTCD0,

	JMP	INTCD3

INTCD3,	JMS	INTCD5		/TRY SEND CARD TO 10
	JMS	STCARD		/TRY TO KEEP CDR MOVING
	JMP	INTDIS		/DISMISS INTERRUPT

/HERE TO TRY TO SEND CARD TO 10
INTCD5,	0


	TAD I	(CDRBLK+DEVBF2
	SZA CLA
	  JMP I	INTCD5
	TAD	CDRNXT
	DCA I	(CDRBLK+DEVBF2
	DCA	CDRNXT
	NLM1			/DECREMENT DATA REQUESTS
	TAD I	(CDRBLK+DEVDRQ
	DCA I	(CDRBLK+DEVDRQ
	JMP I	INTCD5
/HERE ONCE PER CLOCK TICK TO CHECK THE CARDREADER
/ IF ACTIVE SEE IF IT HAS TIMED OUT(PICK FAIL ?)
/ IF NOT ACTIVE TRY TO START IT
CLKCDR,	IOF			/LEAVE INTERRUPTS OFF FOR A WHILE
	TAD	(CDRBLK		/IN CASE WE CALL ISTDDC, ETC.
	DCA	INTDDB
	TAD I	(CDRBLK+DEVBF1	/GET ADR OF 1ST CARD
	SZA CLA
	  JMP	CLKCD2
	TAD I	(CDRBLK+DEVBF2
	DCA I	(CDRBLK+DEVBF1
	DCA I	(CDRBLK+DEVBF2
CLKCD2,	TAD I	(CDRBLK+DEVSTS	/GET DEVICE STATUS
	SPA CLA			/TEST FOR ACTIVE
	  JMP	CLKCD5		/IS ACTIVE
	NL1
	AND I	(CDRBLK+DEVDDC
	SZA CLA			/IS TROUBLE BIT UP ?
	  JMP	CLKCD4		/YES SO CHECK IT
	TAD I	(CDRBLK+DEVDRQ
	SNA CLA			/DO WE HAVE ANY DATA REQUESTS ?
	  JMP	CLKCD8		/NONE SO DONE
	TAD	CDRNXT
	SZA CLA
	  JMS	INTCD5		/IF HOLDING DUMP
	NL4000			/ACTIVE FLAG
	TAD I	(CDRBLK+DEVSTS
	DCA I	(CDRBLK+DEVSTS	/FLAG ACTIVE
	JMS	STCARD		/TRY TO MOVE A CARD
CLKCD8,	ION
	NL0
	JMP	CLKCD9		/DONE FOR THIS TICK

CLKCD4,	ISZ I	(CDRBLK+DEVTIM	/SEE IF WE HAVE WAITED A WHILE
	  JMP	CLKCD8		/NO LONG ENOUGH YET
	NL4000			/JUST STOP BIT
	JMS	ISTDDC		/SET NEW DEVICE STATUS
	JMP	CLKCD8

/HERE AT ONCE PER TICK IF CDR IS ACTIVE
CLKCD5,	ISZ I	(CDRBLK+DEVTIM	/INCREMENT TIMER
	  JMP	CLKCD8		/HASN'T TIMED OUT SO WE ARE DONE

/CDR HAS TIMED OUT = PICK FAILURE
	JMS	CLRACT		/CLEAR DEVICE ACTIVE
	TAD	(4101		/CDR STOPPED & PICK CHECK
	JMS	ISBDDC		/SET DDCMP STATUS
	NL6000			/THIS IS ABOUT 17 SECONDS(60HZ)
	DCA I	(CDRBLK+DEVTIM	/SET TIMER
	TAD	CDRNXT		/GET ADR OF CARD WE WERE TRYING TO READ
	JMS	FRECKS		/FREE CHUNKS
	DCA	CDRNXT		/FREE CURRENT BUFFER(& ION)
	JMP	CLKCD9		/ON TO NEXT DEVICE
>/  END OF IFNZRO CDRN
	INSRT1
CONFD,	TAD I	TEMPB
	AND	(377	/MASK OFF EXTRANEOUS BITS IN MCR
	DCA I	TEMP3	/SAVE AT RCN OF DDB
	TAD I	DDBSTS
	JMP	CONFD1
NJMPA,	TAD	(JMP I NJMP+4
	DCA	NJMP
NJMP,	0
	RCVKRD	/BOOT ILLEGAL
	RCVEX	/RECEIVE EXAMINE
	RCVDP	/RECEIVE DEPOSIT
	RGOTO	/GOTO

	PAGE
IFNZRO CDRN <
STCARD,	0
	NLOAD	STSBIT		/MASK FOR HAVE TO SEND STS
	AND I	(CDRBLK+DEVSTS	/GET CURRENT STATUS BITS
	SZA CLA			/CHECK FOR EOF OR NEED TO SEND STATUS
	  JMP	STCDR8		/STSBIT MUST BE CLEARED BEFORE READING
	TAD I	(CDRBLK+DEVDDC	/GET DDCMP STATUS
	SPA CLA			/TEST FOR CDR STOPPED BIT
	  JMP	STCDR8		/HAS STOPPED
	TAD I	(CDRBLK+DEVDRQ	/GET DATA REQUESTS
	SNA CLA
	  JMP	STCDR8		/NO DATA REQUESTS SO DON'T MOVE CARDS
	TAD I	(CDRBLK+DEVBF2
	SNA CLA			/CHECK TO SEE IF HOLDING
	JMS	IGTCNK		/GET FIRST CHUNK TO STORE CARD IN
	  JMP	STCDR8		/HOLDING OR OUT OF CORE
	DCA	CDRNXT
	TAD	CDRNXT		/GET ADR OF LINK WORD
	IAC			/MAKES ADR OF COUNT FIELD
	DCA	CDREXT		/SAVE ADR OF COUNT FIELD(LOW ORDER)
	RCKFLD
	DCA I	CDREXT		/CLEAR COUNT(LOW ORDER)
	TAD	CDREXT
	IAC			/MAKES ADR OF COUNT FIELD(HIGH ORDER)
	DCA	CDRADR		/SAVE ADR
	DCA I	CDRADR		/CLEAR HIGH ORDER COUNT
	TABFLD
	NL2			/DATA WITH EOR
	JMS	ICDRD6		/PUT CODE INTO CHUNKS
	DCA	CDCCNT		/HAVE READ NO CHARS YET
	TAD I	(CDRBLK+DEVDDC	/GET DEVICE STATUS BITS
	AND	(7177		/TURN OFF BOTH EOF BITS
	DCA I	(CDRBLK+DEVDDC	/STASH BACK
	CDRCSE
	NOP			/START CARD READER
	TAD	(-200
	DCA I	(CDRBLK+DEVTIM	/TWO SECOND TIMEOUT
	DCA I	(CDRBLK+DEVOLC	/INITIALIZE COLUMN COUNTER
	JMP I	STCARD
STCDR8,	NL3777			/MASK TO CLEAR ACTIVE
	AND I	(CDRBLK+DEVSTS
	DCA I	(CDRBLK+DEVSTS	/CLEAR ACTIVE
	JMP I	STCARD
CONCDR,	TAD	(RCVCDR		/DISPATCH ADDRESS
	DCA I	TEMPA			/INTO TABLE
	TAD	(CDRBLK			/GET DDB ADDRESS
	JMP	CONDEV			/DO REST

>/END OF IFNZRO CDRN
	LISTOG	CDRN
	LISTOG	PTRN
IFNZRO PTRN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		PTR SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

PTRCNT,	0			/COUNT OF CHARS

/HERE AT INTERRUPT LEVEL WHEN PTR INTERRUPTS
INTPTR,	PTRSF			/SKIP ON PTR FLAG
	  JMP	INTPR9		/NOT PTR CHECK NEXT DEVICE
	PTRRB			/GET FRAME FROM PTR AND CLEAR FLAG
	DCA	INTMP5		/SAVE CHAR
	TAD	(PTRBLK		/ADDRESS OF DEVICE BLOCK
	JMS	IACTCK		/CHECK DEVICE SHOULD BE ACTIVE
				/ IF NOT DON'T RETURN

	TAD	INTMP5		/GET CHAR AGAIN
	JMS	IPUTCH		/PUT CHAR INTO THE CHUNKS
	NLOAD	-1
	TAD I	(PTRBLK+DEVDRQ	/UPDATE DATA REQUEST COUNT
	DCA I	(PTRBLK+DEVDRQ	/AND SAVE NEW COUNT
	ISZ	PTRCNT		/COUNT CHAR IN CURRENT BUFFER
	TAD	PTRCNT		/GET CHAR COUNT
	TAD	(-240
	SMA CLA
	  JMP	INTPR5		/BRANCH IF HAVE ENOUGH
	JMS	PTRMOV		/MOVE TAPE AGAIN
	JMP	INTDIS

INTPR5,	JMS	INTPR7		/QUEUE DATA TO 10
	JMP	INTDIS

/HERE TO SEND PTR DATA TO 10
INTPR7,	0
	TAD	PTRCNT
	SNA CLA
	  JMP I	INTPR7		/IF NO DATA DONE
	JMS	CLRACT		/CLEAR DEVICE ACTIVE
	TAD I	(PTRBLK+DEVBF2
	DCA I	(PTRBLK+DEVBF1
	DCA I	(PTRBLK+DEVBF2
	JMP I	INTPR7
/HERE ONCE PER CLOCK TICK TO CHECK PTR

CLKPTR,	IFZERO PDP8E <
	PTRPE			/REENABLE PTR/PTP INTS
>/END OF IFZERO PDP8E
	TAD	(PTRBLK		/PREPARE
	IOF
	DCA	INTDDB		/FOR VARIOUS SUBROUTINES
	TAD I	(PTRBLK+DEVSTS	/GET CURRENT STATUS
	SMA CLA			/IS DEVICE ACTIVE ?
	  JMP	STRPTR		/NO YET - TRY TO START IT
	ISZ I	(PTRBLK+DEVTIM	/HAS DEVICE TIMED OUT ?
	  JMP	CLKPR8		/NO
	JMS	INTPR7		/QUEUE DATA TO 10
	TAD I	(PTRBLK+DEVSTS
	TAD	(4001		/SET EOF & CLRACT
	DCA I	(PTRBLK+DEVSTS
CLKPR8,	ION
	JMP	CLKPR9

/HERE TO PERHAPS START PTR MOVING
STRPTR,
	TAD I	(PTRBLK+DEVDRQ	/GET DATA REQUEST COUNT
	SNA CLA
	  JMP	CLKPR8		/NONE SO DON'T START PTR
	DCA	PTRCNT		/HAVE READ NOTHING YET
	NLOAD	4000		/FLAG DEVICE IS ACTIVE
	TAD I	(PTRBLK+DEVSTS
	DCA I	(PTRBLK+DEVSTS
	JMS	PTRMOV		/START TAPE MOVING
	JMP	CLKPR8
/SUBROUTINE TO MOVE THE TAPE
/ IF THERE AREN'T ENOUGH CHUNKS LEFT STOP READER
/ AND SEND WHAT WE HAVE SO FAR
PTRMOV,	0
	TAD	FRECNT
	TAD	(-ERSCNT
	SPA CLA			/SKIP IF HAVE CORE
	JMP	PRMOV3
	PTRFC			/START TAPE MOVING
	TAD	(-100
	DCA I	(PTRBLK+DEVTIM	/RESET TIMER
	JMP I	PTRMOV
PRMOV3,	JMS	CLRACT		/CLEAR DEVICE ACTIVE FLAG
	JMS	INTPR7		/SEND DATA TO 10
	JMP I	PTRMOV

	PAGE
>/END OF IFNZRO PTRN
	LISTOG	PTRN
	LISTOG	PTPN
IFNZRO PTPN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		PTP SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

PTPCNT,	0			/COUNTER FOR HEADER & TRAILER

/HERE AT INTERRUPT LEVEL TO CHECK FOR PTP INTERRUPTS
INTPTP,	PTPSF			/SKIP ON PTP FLAG
	  JMP	INTPP9		/NOT PTP SO CHECK NEXT DEVICE
	JMS	INTPP0
	JMP	INTDIS
INTPP0,	0
	TAD	PTPCNT
	SZA CLA			/DO WE NEED HEADER/TRAILER ?
	  JMP	INTPP5		/YES
	TAD	(PTPBLK
	DCA	INTDDB
	JMS	IGTOCH		/GET NEXT CHAR IF ANY
	  JMP	PTPFIN		/NONE
	CLL			/CLEAR LINK
	TAD	(2000
	SZL
	  JMP	INTPP7		/THIS IS REALLY AN OPEN !
INTPP1,	PTPLS			/PUNCH CHAR
	NLM3			/FOR TIMEOUT
	DCA I	(PTPBLK+DEVTIM
	JMP I	INTPP0
INTPP5,	ISZ	PTPCNT
	JMP	INTPP1		/GO PUNCH A 0
	JMP	INTPP1		/ DITTO
INTPP7,	NL0
	TAD	(-200		/THIS IS APP TWO FOLDS OF TAPE
	DCA	PTPCNT
	JMP	INTPP1		/GO PUNCH 1ST PART OF HEADER/TRAILER
/HERE WHEN DATA FOR PTP IS EXHAUSTED
PTPFIN,	PTPCF			/CLEAR ANY FLAGS
	JMS	CLRACT		/MARK DEVICE AS NOT ACTIVE
	JMP	INTDIS

CLKPTP,	IFZERO PTRN <
	IFZERO PDP8E <
	PTRPE			/REENABLE READER/PUNCH INTERRUPTS
>/END OF IFZERO PDP8E
>/END OF IFZERO PTRN
	TAD I	(PTPBLK+DEVSTS
	SMA CLA			/IS PTP ACTIVE ?
	  JMP	STRPTP		/NO SO TRY TO START IT
	ISZ I	(PTPBLK+DEVTIM	/YES - IS THIS TIMEOUT ?
	JMP	CLKPP9		/NO
IFNZRO FTTRBL <
	TAD	(PTPMSG-1
	DCA	ERRFLG		/LEAVE MSG FOR OPERATOR
>/END OF IFNZRO FTTRBL
	JMP	CLKPP9

STRPTP,	TAD I	(PTPBLK+DEVOCN
	SNA CLA
	  JMP	CLKPP9		/NOTHING TO DO SO GO TO NEXT DEVICE
	NL4000
	IOF
	TAD I	(PTPBLK+DEVSTS
	DCA I	(PTPBLK+DEVSTS
	JMS	INTPP0
	ION
	JMP	CLKPP9

/	PAGE
>/END OF IFNZRO PTPN
	LISTOG	PTPN
	LISTOG	PLTN
IFNZRO PLTN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		PLT SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************


/DATA FOR THE PLT COMES IN 10 FORMAT - I.E. 6 BIT BYTES AS FOLLOWS:
/	0040	PEN UP
/	0020	PEN DOWN
/	0010	DRUM UP
/	0004	DRUM DOWN
/	0002	PEN LEFT
/	0001	PEN RIGHT

/HERE AT INTERRUPT LEVEL TO CHECK FOR PLT INTERRUPTS
INTPLT,	PLTSKF			/SKIP ON PLOTTER FLAG
	  JMP	INTPL9		/CHECK NEXT DEVICE
INTPL0,	TAD	(PLTBLK
	DCA	INTDDB
	JMS	IGTOCH		/GET NEXT CHAR IF ANY
	  JMP	PLTFIN		/NONE
/	PLOT HERE
	JMP	INTDIS
PLTFIN,	PLTCLF			/CLEAR ANY FLAGS
	JMS	CLRACT		/MARK DEVICE AS NOT ACTIVE
	JMP	INTDIS


CLKPLT,	TAD I	(PLTBLK+DEVSTS
	SMA CLA			/IS PLT ACTIVE ?
	  JMP	CLKPL2		/NO TRY TO START IT
	ISZ I	(PLTBLK+DEVTIM	/YES - IS THIS TIMEOUT ?
	JMP	CLKPL9		/NO
	JMP	CLKPL9

CLKPL2,	JMP	CLKPL9		/CAN'T START PLT

/	PAGE
>/END OF IFNZRO PLTN
	LISTOG	PLTN
/HERE ONCE PER TICK TO CHECK TTY'S
/ SEE IF THERE IS AN ERROR MESSAGE FOR THE CTY
/ CHECK FILLERS FOR ALL LINES
CLKTTY,	TAD I	(CTYBLK+LDBFPT
	SZA CLA
	  JMP	CLKTY2		/ALREADY TYPING
	TAD	ERRFLG
	SNA
	  JMP	CLKTY2		/NO MSG SO DONE
	DCA I	(CTYBLK+LDBFPT
	DCA	ERRFLG		/SETUP MSG
	TAD	(CTYBLK
	DCA	DDB
	TAD	(CTYBLK+DEVSTS
	DCA	DDBSTS
	JMS	TTYGO		/START CTY IF NEED TO
CLKTY2,
	TAD	(FIRTTY		/GET ADR OF FIRST TTY BLOCK
CLKTY3,	IOF			/DISABLE INTERRUPTS FOR A WHILE
	DCA	INTDDB
	TAD	(DEVTIM		/RELATIVE ADR OF TIMER
	TAD	INTDDB
	DCA	TEMP2		/SAVE POINTER TO TIMER
	TAD I	TEMP2		/GET TIMER FOR FILLER
	SZA CLA
	ISZ I	TEMP2
	  JMP	CLKTY5		/HASN'T TIMED OUT
	  JMS	XMTINT
	NL0			/BECAUSE XMTINT RETURNS GARBAGE
CLKTY5,	ION
	ISZ	TEMP2		/DEVLNK IS ONE GREATER THAN DEVTIM
	TAD I	TEMP2
	SZA
	  JMP	CLKTY3
	JMP	CLKTY9
/HERE TO CLEAR THE CONNECT NUMBER IN THE DDB
CLRCNT, 0
	TAD I	DDB		/[1(23)] GET THE DDB CONTENTS
	AND	(7700		/[1(23)] CLEAR THE CONNECT NUMBER
	DCA I	DDB		/[1(23)] AND STORE BACK IN THE DDB
	JMP I	CLRCNT		/[1(23)] RETURN TO CALLER

/HERE TO  MARK A DEVICE AS NOT ACTIVE
/ CALL	JMS	CLRACT		/WITH IOF AND INTDDB SETUP
/	RETURN
CLRACT,	0
	NLOAD	DEVSTS
	TAD	INTDDB		/MAKE ADR OF DEVSTS
	DCA	INTMP1
	NL3777			/MASK TO CLEAR ACTIVE BIT
	AND I	INTMP1
	DCA I	INTMP1		/SAVE NEW STATUS WORD
	JMP I	CLRACT

RECINT,	IOF			/SO WE DON'T MISS A QUEUE OVERFLOW
	TAD I	TIQTKR		/GET LINE #
	DCA	DDB
	TAD I	TIQTKR		/GET CHAR
	AND	[377		/8 BITS ONLY(THIS ISN'T NECESSARY)
	DCA	TEMP5		/SAVE CHAR

	TAD	TIQTKR
	TAD	(1-TTIQUE-TIQLEN
	SZA CLA
	  JMP	RECIN0		/DON'T NEED TO RESET POINTERS
	TAD	(TTIQUE-1
	DCA	TIQTKR

	JMP	RECIN0
	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CLOCK SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE AT INTERRUPT LEVEL WHEN CLOCK GOES OFF

/TEST FOR CLK INTERRUPTS
INTCLK,	CLKSCF			/DID CLOCK GO OFF?
	  JMP	INTCL9		/NOT CLOCK SO CHECK NEXT DEVICE
	CLCL
	NL1			/IGNORE EVERY OTHER TICK
	AND	JIFSEC+1
	SZA CLA
	  JMP	INTCK4

	ISZ	CLKFLG		/FLAG FOR NONINTERRUPT LEVEL CODE
	SKP
	  HLT			/WENT A MINUTE WITHOUT FINDING CLOCK FLAG ??
	NLM1
	DCA	WRKREQ		/SO WE FIND CLOCK FLAG
	TAD	JIFSEC+1
	AND	(0176
	SZA CLA
	  JMP	INTCK4
	ISZ	SECFLG		/FLAG TIME FOR 64TH TICK CODE(APP. 1 / SEC)

	IFNZRO FTDEBUG <
	NLM1
	CIF	30		/LOC IN FIELD 3
	JMS	TRACEW		/PUT WORD INTO THE TRACE
>/END OF IFNZRO FTDEBUG

INTCK4,	ISZ	JIFSEC+1
	  JMP	INTDIS
	ISZ	JIFSEC
	  JMP	INTDIS
	JMP	INTDIS
JIFSEC,	ZBLOCK	2		/TICKED ONCE PER JIFFY
RCVCN2,	
	JMS	GETEXN		/GET SLA
	DCA	TEMP2		/STORE IT
	TAD	(DEVN		/LENGTH OF RCVDSP TABLE
	TAD	TEMPA		/ADD RCVDSP ENTRY POINTER
	DCA	TEMP1		/STORE ADDRESS FOR SLA
	TAD	TEMP2		/PICK UP SLA
	DCA I	TEMP1		/STASH IT
	TAD	(DEVTYP-1	/GET ADR OF DEVICE TYPE TABLE
	DCA	AUTO1
	TAD	(-CTRLN		/NUMBER OF POSSIBLE TYPES
	DCA	TEMPD		/NUMBER OF POSSIBLE TYPES
	JMS	GTCHR		/GET OBJECT TYPE (ONLY ONE BYTE)
/ LEGAL ARE 1=TTY,2=CARD READER,3=LINE PRINTER
RCVCN4,	TAD I	AUTO1
	SNA
	  JMP	RCVCN5		/THIS IS THE ONE WE NEEDED
	ISZ	AUTO1		/SKIP DISPATCH ADR
	ISZ	TEMPD		/HAVE CHECK ALL POSSIBLE ?
	  JMP	RCVCN4		/NO SO KEEP ON CHECKING
	JMP	BADTYP		/SEND DISCONNECT
RCVCN5,	TAD I	AUTO1
	DCA	TEMPB
	TAD	(-CONTTY	/SEE IF TTY
	TAD	TEMPB		/WE ARE DISPATCHING TO
	SNA CLA			/SKIP IF NOT
	  JMP	RCVCNT		/HANDLE TTY CASE
	JMS	SKPEXN		/SKIP PROCESS ID FIELD
RCVCN0,
	JMS	GETEXN		/GET OBJECT TYPE OF SENDER
	JMS	SKPEXN		/SKIP HIS PROCESS ID
	JMS	GETEXN		/MAX MESSAGE LENGTH
	DCA	TEMP1		/STORE
	TAD	(DEVN
	TAD	(DEVN
	TAD	TEMPA		/DISPATCH ADDRESS
	DCA	TEMP2		/STASH
	TAD	TEMP1		/GET MAX LENGTH
	DCA I	TEMP2		/STORE IT
	TAD	TEMP2		/GET ADDRESS
	TAD	(DEVN		/POINT TO NEXT TABLE
	DCA	TEMP2		/STORE IT
	TAD	RSNA		/GET SNA
	DCA I	TEMP2		/STORE IT
	JMP I	TEMPB		/GO TO DEVICE DEPENDENT CONNECT
RCVCNT,	JMS	GETEXN		/GET TTY NUMBER
	DCA	TTYNO
	JMP	RCVCN0		/CONTINUE

TTYNO,	-1
CONTTY,	TAD	(RCVTTY		/DISPATCH ADDRESS
	DCA I	TEMPA		/SAVE IT
	TAD	TTYNO
	TAD	(-TTYN-1
	SMA 			/SHOULD BE NEGATIVE
	JMP	BADTYP
	TAD	(TTYN+1
	TAD	(DDBTAB
	DCA	TEMPC		/PROPER ENTRY
	TAD I	TEMPC		/PROPER DDB
	JMP	CONDEV
	IFNZRO	CDRN	<
/HERE TO START CARD MOVING
INTCD2,	TAD	(RCKMSG-1
	DCA	ERRFLG		/COMPLAIN ABOUT CARD
	JMP	INTDIS		/ DEVICE WILL TIME OUT AND USER WILL GET MESSAGE FROM 10
>/END OF IFNZRO	CDRN
/BOOT MESSAGES IE STATION CONTROL MSG ARE QUEUED
/IN THIS TABLE SO STATION CAN SEND HANDSHAKE TO DNA WHEN XMTTER IDLE
BTSCN,	0
	TAD	(BTTAB-GTLEN
	DCA	TEMPA	
BTT1,	TAD	(GTLEN
	TAD	TEMPA
	DCA	TEMPA
	TAD I	TEMPA
	SZA CLA		/CHECK FOR FREE ENTRY
	JMP	BTT1
	TAD	(-BTEND
	TAD	TEMPA
	SNA CLA		/END OF TABLE
	JMP	RCVFLU	/IGNORE MESSAGE
	TAD	TEMPA
	DCA	TEMPB	/SAVE BEG OF ENTRY ADDRESS AT TEMPB
	TAD	RSNA
	DCA I	TEMPA
	ISZ	TEMPA
	JMP I	BTSCN
	PAGE
/INTERRUPT FROM UNKNOWN DEVICE
/OR POWER FAIL INTERRUPT
INTNOT,	SPL		/SKIP IF POWER FAIL
	JMP	.+3	/NOT POWER UNDEFINED INTERRUPT
	CAL		/CLEAR INTERRUPT 
	HLT
	ISZ	INTCNT	/COUNT IT
	JMP	INTDIS
	TAD	(INTMSG-1
	JMS	CTYEXC
	HLT
RCVNEI,				/HERE WHEN WE RECEIVE NEIGHBORS MESSAGE
	TAD	RNOD		/GET OUR NEIGHBOR
	NEGATE
	TAD	RSNA		/GET WHO SENT NEIGHBORS
	SZA CLA			/ONLY BELIEVE HIM
	  JMP	RCVFLU		/IGNORE OTHERS
NEIG0,
	JMS	GETCHR		/GET NNM
	  JMP	NEIG10		/NONE, SO DONE
	NEGATE			/GET NEGATIVE
	DCA	TEMPA		/SAVE
	TAD	TEMPA
	JMS	NETSCN
	JMP	NECT	/NOT FOUND
	TAD	(2000
	TAD I	TEMPB	/MARK AS FOUND
	DCA I	TEMPB
NECT,	TAD	(SNATAB		/POINT TO START OF NODE TABLE
	DCA	TEMPB		/STORE
	TAD	(-DEVN		/NUMBER OF ENTRIES
	DCA	TEMPC		/STORE
NEIG1,				/LOOP TO MARK NODES UP
	TAD I	TEMPB		/GET NODE TABLE ENTRY
	SNA			/ONLY TEST ONES THAT ARE THERE
	  JMP	NEIG3		/ADVANCE TO NEXT ENTRY IF NOT USED
	TAD	TEMPA		/ADD THE ONE WE ARE CONSIDERING
	SNA CLA			/SKIP IF NOT THE SAME
	  JMP	NEIG2		/MARK AS UP IF THE SAME
NEIG3,	ISZ	TEMPB		/ADVANCE NODE TABLE POINTER
	ISZ	TEMPC		/ADVANCE COUNTER
	  JMP	NEIG1		/CONTINUE IF COUNT NOT EXHAUSTED
	JMS	GTCHR		/GET LVL TO THROW AWAY
	NL0			/BE SURE AC IS  0 WHEN CALL GETCHR
	JMP	NEIG0		/DO NEXT
NEIG2,	NL4000			/GET BIT TO MARK NODE UP
	TAD I	TEMPB		/GET TABLE ENTRY
	DCA I	TEMPB		/STORE IT AGAIN WITH UP BIT ON
	JMP	NEIG3		/CONTINUE
NEIG10,				/HERE AFTER ALL NODES MARKED AS UP
	TAD	(SNATAB	/GET START OF NODE TABLE
	DCA	TEMPB
	TAD	(-DEVN		/GET NO OF ENTRIES
	DCA	TEMPC		/SAVE
NEIG11,	TAD I	TEMPB		/GET ENTRY
	SMA SZA			/EITHER 0 (NOT USED) OR MINUS (UP) IS OK
	  JMP	DOWN		/AC WILL BE ZERO WHEN ROUTINE JMPS TO NEIG13
NEIG13,	AND	(3777		/CLEAR UP BIT
	DCA I	TEMPB		/STORE ENTRY BACK
NEIG12,	ISZ	TEMPB		/ADVANCE TABLE POINTER
	ISZ	TEMPC		/ADVANCE COUNTER
	  JMP	NEIG11		/CONTINUE LOOP
	JMP	DELTB		/DELETE ANY NEIGHBOURS WHO DISAPPEARED
/	IF WE WANT TO SEND CONFIGURATION, DO IT HERE
/CODE TA SCAN NEIGHBORS TABLE
/FORMAT OF NEIGHBORS TABLE IS
/	4000	ENTRY HAS TO REQUEST CONF
/	2000	PRESENT IN CURRENT NEI MSG
/	1000	NODE HAS MCR HANDLER
/	 000	CONTAINS NODE NO
/	0	MARKS END OF TABLE
/
NETSCN,	0
	DCA	NET1	/SAVE VALUE SCANNING FOR
	TAD	(NEITAB-1
	DCA	TEMPB
NET2,	ISZ	TEMPB	/BUMP TO NEXT ENTRY
	TAD I	TEMPB
	SNA		/CHECK FOR END OF TABLE
	JMP I	NETSCN	/NOT FOUND RETURN TEMPB POINTS TO FREE ENTRY
	AND	(377	/MASK AWAY ALL FLAGS
	TAD	NET1	/SEE IF THIS IS VALUE SEARCHING FOR
	SZA CLA
	JMP	NET2	/NO, CONTINUE SCAN
	ISZ	NETSCN	/FOUND RETURN
	JMP I	NETSCN
NET1,	0
NETAD,			/AC CONTAINS VALUE TO ADD TO WHER E TEMPB POINTS
 	DCA I	TEMPB
	TAD	TEMPB
	NEGATE
	TAD	NTAD	/SET UP SO ABLE TO STORE LIT AT 7717
	SNA CLA
	HLT 		/TABLE TOO SMALL
	JMP	RCVFLU
NTAD,	NEIEND


/7720 THROUGH 7731 INCLUSIVE ARE USED BY DP8E
ZZ=.&4000
IFNZRO ZZ <
ZZ=7720-.
ZZ=ZZ&4000
IFNZRO ZZ <
	ERROR		/CODE OVERLAPS DP8E HARDWARE ADDRESSES
>/END OF IFNZRO ZZ

*7732		/SKIP DP8E ADDRESSES

>/END OF IFNZRO ZZ

RCVLP6,	NLOAD	DEVCHK		/DISPLACEMENT OF CHUNK COUNT
	TAD	DDB
	DCA	TEMPA		/SAVE ADR OF DDB CHUNK COUNT
	NLM1
	TAD	TEMP5
	DCA	TEMPB		/SAVE ADR OF MSG'S CHUNK COUNT
	RCKFLD
	TAD I	TEMPB		/NO OF CHUNKS IN THIS MESSAGE
	TABFLD
	TAD I	TEMPA		/PLUS PREVIOUS
	DCA I	TEMPA		/STORE BACK
	ION
	JMP	RCVADV		/FORGET MESSAGE BUT NOT CHUNKS
RCVE,	ISZ	TEMPA
	JMS	RADR
	JMS	RADR
	JMP	RCVFLU
/THE FOLLOWING INSTRUCTIONS ARE AN INTERFACE TO FIELD 0
/ROUTINES NEEDED BY TRANSMITTER LOGIC MOVED TO FIELD 1
/
/
GETC1,	0
	JMS	GETCHR
	SKP
	ISZ	GETC1	/INCR RET FOR SAME LOGIC RET AS IN GETCH
	CIF	10	/RETURN TO CALLER
	JMP I	GETC1
	FIELD 1
	DEFINE HLT	<JMS  DMP1>
/NODEID MESSAGE
/PAGE0 EQUATES ARE THE SAME AS FIELD 0
/ONLY THE TEMP AREAS ARE USED
/THE LOC WHICH CONTAIN PERMANENT FLAGS ETC
/ARE LOADED FROM FIELD 0 BY CHANGING DATA FIELDS AND
/USING INDIRECT ADDRESSING
*DDBSTS+1			/GET PAST CRUCIAL PART OF PAGE 0
FNDSPD,	0			/SUBROUTINE TO FIND SPEED FOR  [1(14)]
				/TTY (USED BY XMTCHR)  [1(14)]
	TAD	(DFAULT		/ASSUME DEFAULT  [1(14)]
	DCA	SPEED		/STORE AT POINTER  [1(14)]
	TAD	(SPDTAB		/POINT TO EXCEPTION TABLE  [1(14)]
	DCA	SPDPTR		/STORE ADDRESS  [1(14)]
FNDLOP,	TAD I	SPDPTR		/GET -DDB ADDRESS FOR THIS TERMINAL  [1(14)]
	SNA			/SKIP IF NOT END OF TABLE  [1(14)]
	  JMP I	FNDSPD		/ELSE RETURN WITH DEFAULT POINTER  [1(14)]
	TAD I	(DDB		/COMPARE WITH OUR DDB  [1(14)]
	SNA CLA			/SKIP IF NOT EQUAL  [1(14)]
	  JMP	FOUND		/ELSE GO UPDATE POINTER AND EXIT  [1(14)]
	ISZ	SPDPTR		/POINT  [1(14)]
	ISZ	SPDPTR		/ TO  [1(14)]
	ISZ	SPDPTR		/  NEXT ENTRY  [1(14)]
	JMP	FNDLOP		/AND KEEP ON LOOKING  [1(14)]
FOUND,	ISZ	SPDPTR		/ADVANCE PAST DDB ADDRESS  [1(14)]
	TAD	SPDPTR		/GET ADDRESS OF FIRST SPEED  [1(14)]
	DCA	SPEED		/STORE IT  [1(14)]
	JMP I	FNDSPD		/RETURN TO CALLER  [1(14)]

LOOPCT,				/MULTIPLEXED LOCATION, LOOP COUNT  [1(14)]
SPEED,	0			/ADDRESS OF SPEED RETURNED TO CALLER  [1(14)]
LOOPPT,				/MULTIPLEXED LOCATION, LOOP POINTER  [1(14)]
SPDPTR,	0			/POINTER FOR ADVANCE THROUGH SPEED TABLE  [1(14)]

XMTCR2,				/CONTINUATION OF XMTCHR  [1(14)]
	TAD	(LDBFIL		/POINT TO FILLERS  [1(14)]
	TAD I	(DDB
	DCA	LOOPPT		/STORE FILLER ADDRESS  [1(14)]
	TAD	(-6		/COUNT  [1(14)]
	DCA	LOOPCT
FILLOP,	TAD I	LOOPPT		/GET FILLER VALUE  [1(14)]
	ISZ	LOOPPT		/POINT TO NEXT ONE  [1(14)]
	JMS	SNDEXN		/PUT INTO MESSAGE  [1(14)]
	ISZ	LOOPCT		/INCREMENT COUNTER  [1(14)]
	  JMP	FILLOP		/GO BACK AROUND IF NOT DONE  [1(14)]
	JMS	FNDSPD		/FIND SPEED  [1(14)]
	TAD	SPEED		/GET ADDRESS OF SPEED  [1(14)]
	DCA	LOOPPT
	NLM2			/GET COUNT  [1(14)]
	DCA	LOOPCT
SPDLOP,	TAD I	LOOPPT
	ISZ	LOOPPT
	JMS	SNDEXN
	ISZ	LOOPCT
	  JMP	SPDLOP
	TAD	(LDBWID		/POINT TO WIDTH  [1(14)]
	TAD I	(DDB
	DCA	LOOPPT
	TAD I	LOOPPT		/GET WIDTH VALUE  [1(14)]
	JMS	SNDEXN
	JMS	SNDCHR		/0 AUTO-CRLF POINT  [1(14)]
	JMS	SNDCHR		/0 2741 ELEMENT  [1(14)]
	JMS	SNDCHR		/0 2741 BITS  [1(14)]
	JMP	XMTCRT		/GO RETURN  [1(14)]

*200	/ORIGIN BEYOND PAGE 0 FIELD 0
NCLNID,	BLOCK	100

/PER CONNECTION TABLES
CTRLTB,	BLOCK	DEVN

RCVDSP,	BLOCK	1
	BLOCK	DEVN

/	THESE TABLES MUST FOLLOW AND BE SAME LENGTH
/ AS RCVDSP.

SLATAB,
	BLOCK	DEVN
MMLTAB,
	BLOCK	DEVN
SNATAB,		/SOURCE NODE
	BLOCK	DEVN
/NEITAB AND BTTAB ARE TABLES SET UP FOR SET HOST AND BOOT MESSAGES
/NEILEN IS THE NUMBER OF NODES IN THE NETWORK  DEFAULT VALUE IS 16
/FORMAT FOR NEITAB IS THE FOLLOWING:
/ONE WORD PER ENTRY
/	4000 ISSUE REQ CONFIGURATION
/	 400 ISSUE CONFIG MESSAGE
/	1000 NODE HAS MCR
/	  XX NODE NUMBER
/
/
/BTTAB HAS 6 WORDS PER ENTRY
/	WORD 1=NODE NUMBER ISSUING BOOT MESSAGE
/	WORD 2=RESPONSE MESSAGE NEEDED
/	WORD 3=SOFTWARE INST TO SET DATA FIELD TO ADDR1(6201+N0)
/	WORD 4=12 BITS OF ADDRESS
/	WORD 5,6=SAME AS WORDS 3,4 FOR ADDRESS2
/NOENT=5 SETS THE BOOT QUEUE TO BE 5 MESSAGES
	NOENT=5
	GTLEN=6		/6 LOC PER ENTRY IN BOOT TABLE
	BTLEN=NOENT^GTLEN
NEITAB,
	BLOCK	NEILEN
NEIEND,	0
BTTAB,	BLOCK	BTLEN
BTEND,	0
GTTAB,	BLOCK	GTLEN


ZZ=CTRLTB
ZZ=RCVDSP
ZZ=SLATAB
ZZ=MMLTAB
ZZ=SNATAB
ZZ=NEITAB
ZZ=BTTAB
ZZ=GTTAB

/	OUTPUT MESSAGE BUFFERS

CTLSIZ=12		/DDCMP HEADER (8) + CHUNK COUNT (1) + CHUNK POINTER
SYNCHS,	BLOCK	20	/WHERE SYN BUF WILL GO
SYNBUF=.-NUMSYN
IDLBUF=SYNBUF		/NO SPECIAL BUFFER FOR IDLE MODE

CTLBUF,	BLOCK	10
	Z=4+MAXOLN+6
	T10LEN=12+MAXOLN
T10BF1,	BLOCK	Z
T10BF2,	BLOCK	Z
T10LST,	BLOCK	Z

ZZ=T10BF1
ZZ=T10BF2
ZZ=T10LST

/STORAGE FOR TTY'S

/QUEUE OF INPUT FROM TTY'S
/ FIRST WORD IS LINE #
/ SECOND IS 8BIT CHAR
IFNDEF TIQLEN <TIQLEN=100>
TTIQUE,	BLOCK	TIQLEN
/MACRO TO MAKE A DEVICE BLOCK FOR A TTY
/ 1ST ARG IS DEVICE BLOCK LABEL
/ 2ND ARG IS DEVICE ADR FOR DC02 TTY'S
/	NOLONGER USED ON DAS92
/ 3RD ARG IS DEVICE ADR FOR KL8A TTY'S
/ 4TH ARG IS NONZERO IF TTY HAS HDW TABS
/ 5TH ARG IS TTY CARRIAGE WIDTH
/ 6TH ARG IS TTY FILLER CLASS
/ 7TH ARG IS RESTRICTED NODE NUMBER
/ 8TH ARG IS DATA SET LINE FLAG
DEFINE TTBLK NAME Q QQ QQQ QQQQ QQQQQ QQQQQQ Q1 <XLIST
	ZZ=QQ
	TTYCNT=TTYCNT+1
	XLIST
	0	/DEVRCN=0
Q1
	-QQQQQQ			/DEVRNN
	TTYCHK
	TTYCNT-1
NAME,	100		/LH=OBJ TYPE,RH=CONNECT
	XLIST
	*.+DEVLNK-1
	XLIST
	FIRTTY		/ADR OF PREVIOUS DEVICE BLOCK
	XLIST
	FIRTTY=.-DEVLNK-1
	FIRDDB=FIRTTY
	XLIST
	ZZ		/DEVICE ADDRESS
	XLIST
	ZZZ=ZZZ+1
		*.+1		/SKIP LDBCOL
	IFNDEF QQQQ < QQQQ=110	>		/DEFAULT WIDTH IS 72
		XLIST
	QQQQ		/TTY WIDTH
		XLIST
		ZZ=LDBFIL-1-LDBWID
		*.+ZZ
	-10	/FILLER FOR 10
	-10	/FILLER FOR 11
	-10	/FILLER FOR 12
	-10	/FILLER FOR 13
	-10	/FILLER FOR 14
	-10	/FILLER FOR 15
	Z=Z-1
	IFNZRO Z <
XLIST	>/END OF IFNZRO Z
>/END OF TTBLK

	ZZZ=200		/DEVICE NUMBER FOR CTY
			FIRTTY=0	

	Z=TTYN+1
/DEVICE DATA BLOCK FOR CTY
	TTYCNT=0
	TTBLK	CTYBLK,0,0,CTYTAB,CTYWID,CTYFIL,CTYRNN,CTYDSL

IFNZRO Z <	TTBLK	T00BLK,4010,T00TSF,T00TAB,T00WID,T00FIL,T00RNN,T00DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T01BLK,2010,T01TSF,T01TAB,T01WID,T01FIL,T01RNN,T01DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T02BLK,1010,T02TSF,T02TAB,T02WID,T02FIL,T02RNN,T02DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T03BLK,0410,T03TSF,T03TAB,T03WID,T03FIL,T03RNN,T03DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T04BLK,0210,T04TSF,T04TAB,T04WID,T04FIL,T04RNN,T04DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T05BLK,0110,T05TSF,T05TAB,T05WID,T05FIL,T05RNN,T05DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T06BLK,0050,T06TSF,T06TAB,T06WID,T06FIL,T06RNN,T06DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T07BLK,0030,T07TSF,T07TAB,T07WID,T07FIL,T07RNN,T07DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T10BLK,4004,T10TSF,T10TAB,T10WID,T10FIL,T10RNN,T10DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T11BLK,2004,T11TSF,T11TAB,T11WID,T11FIL,T11RNN,T11DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T12BLK,1004,T12TSF,T12TAB,T12WID,T12FIL,T12RNN,T12DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T13BLK,0404,T13TSF,T13TAB,T13WID,T13FIL,T13RNN,T13DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T14BLK,0204,T14TSF,T14TAB,T14WID,T14FIL,T14RNN,T14DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T15BLK,0104,T15TSF,T15TAB,T15WID,T15FIL,T15RNN,T15DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T16BLK,0044,T16TSF,T16TAB,T16WID,T16FIL,T16RNN,T16DSL
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T17BLK,0024,T17TSF,T17TAB,T17WID,T17FIL,T17RNN,T17DSL
 >/END OF IFNZRO Z
IFZERO Z <	XLIST	>

TTYFEA,	3		/NUMBER OF CHARS IN FEATURES
	5		/NOTHING FANCY
/THE FOLLOWING FIELDS ARE FILLED IN DYNAMICALLY WHEN SENDING CONNECT FOR
/EACH TTY LINE AT TAG "FEA2"
	0		/CARRIAGE WIDTH
	0		/=1 MEANS MODEM SUPPORT
			/=100 MEANS STATION CAN SET HOST
/ MACRO TO MAKE DEVICE BLOCK FOR NON-TELETYPE DEVICES
/ 1ST ARGUMENT IS DDB LABEL NAME
/ 2ND ARGUMENT IS DEVICE TYPE CODE
/ 3RD ARGUMENT IS RESTRICTED NODE NUMBER
DEFINE DBLOCK NAME Q QQ <XLIST
	ZZ=-1			/DEFAULT
IFNZRO	LPTN	<
	IFZERO	.+5-LPTBLK <ZZ=LPTCHK>/IF LPT, USE LPT VALUE
>/END OF IFNZRO	LPTN
	DEVCNT=DEVCNT+1
	XLIST
	0		/RCN HAS TO BE ZERO ALWAYS
	0		/NEVER A DATA SET LINE
	-QQ			/DEVRNN
	ZZ			/MAX CHUNKS
	DEVCNT-1
NAME,	Q^100
	XLIST
	Z=DEVLNK-1
	*.+Z
	XLIST
	FIRDDB		/ADR OF PREVIOUS DEVICE BLOCK
	XLIST
	FIRDDB=.-DEVLNK-1
	XLIST	>/END OF DEFINE DBLOCK


IFNZRO CDRN <
/DEVICE DATA BLOCK FOR CDR
	DEVCNT=0
	DBLOCK	CDRBLK,2,CDRRNN
	3		/LENGTH OF FEATURES
	1		/DECIMAGE
	120		/COLUMNS/CARD=80
	1		/LOW SPEED
>/END OF IFNZRO CDRN

IFNZRO LPTN <
/DEVICE DATA BLOCK FOR LPT
/ SPECIAL DEVSTS BITS:
/	LOW ORDER BIT IS A COUNT OF OPENS EXERCISED
	DEVCNT=0
	DBLOCK	LPTBLK,3,LPTRNN
	Z=LPTWID&7200
IFNZRO Z <	5	>		/LENGTH OF FEATURES
IFZERO Z <	4	>		/LENGTH OF FEATURES
IFZERO FTLPLC <	10	>		/ANSI 68
IFNZRO FTLPLC <	12	>		/ANSI 68, LOWER CASE
IFZERO Z <	LPTWID	>		/CARRIAGE WIDTH
IFNZRO Z <	Z=LPTWID&177;	200+Z;	1>		/CARRIAGE WIDTH

	305		/OVERPRINT, MULTIPART PAPER, LOWSPEED
	4		/FORMS WIDTH CHANGEABLE,
>/END OF IFNZRO LPTN

IFNZRO PTRN <
/DEVICE DATA BLOCK FOR PTR
	DEVCNT=0
	DBLOCK	PTRBLK,6,PTRRNN
	1;	0		/FEATURES
>/END OF IFNZRO PTRN

IFNZRO PTPN <
/DEVICE DATA BLOCK FOR PTP
	DEVCNT=0
	DBLOCK	PTPBLK,5,PTPRNN
	1;	0		/FEATURES
>/END OF IFNZRO PTPN

IFNZRO PLTN <
/DEVICE DATA BLOCK FOR PLT
	DEVCNT=0
	DBLOCK	PLTBLK,20,PLTRNN
	1;	0		/FEATURES
>/END OF IFNZRO PLTN
NXTDDB,	FIRDDB
SERDDB,	0	/FIRST DDB SERVICED IN LOOP

DEFINE X Q <IFDEF Q <	Q	>>

/TABLE OF DDB ADDRESSES
DDBTAB,
	X	CTYBLK
	X	T00BLK
	X	T01BLK
	X	T02BLK
	X	T03BLK
	X	T04BLK
	X	T05BLK
	X	T06BLK
	X	T07BLK
	X	T10BLK
	X	T11BLK
	X	T12BLK
	X	T13BLK
	X	T14BLK
	X	T15BLK
	X	T16BLK
	X	T17BLK
  IFDEF CDRBLK <	CDRBLK>
  IFDEF LPTBLK <	LPTBLK>
  IFDEF PTRBLK <	PTRBLK>
  IFDEF PTPBLK <	PTPBLK>
  IFDEF PLTBLK <	PLTBLK>
/STRINGS PUT OUT BY SCNSER

TALN,	4		/TABLE FOR CARRIER MASK FOR KL8A LINED
	40		/LINE 0 CARRIER LEVEL IN STATUS RE
	20		/LINE 1
	10		/LINE 2
XOFMSG,	0223		/XOF = ^S
	4377		/FILLER (WITHOUT REGARD FOR RACE CREED OR CLASS)

TTOSPC,	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	4000+" 		/FINAL BLANK

CRLMSG,	0215		/CARRIAGE RETURN
	4012		/LINE FEED

DEFINE DC7MSG <	XLIST
		0104		/ASCII "D"
		0116		/ASCII "N"
		0071		/ASCII "9"
		0262		/ASCII "2"
	XLIST>/END OF DEFINE DC7MSG

DEFINE DPMSG <	XLIST
		0104		/ASCII "D"
		0120		/ASCII "P"
	0270		/ASCII "8"
		0305 		/ASCII "E"
	0040
	XLIST>/END OF DEFINE DPMSG

DEFINE	BEGMSG <	XLIST
		0215		/CARRIAGE RETURN
		0207		/BELL AND FILLER
		0012		/LINE FEED
		0207		/BELL
		0245		/ASCII "%"
		0245		/ASCII "%"
	XLIST	>/END OF DEFINE BEGMSG

/COMMON MESSAGE BEGINNER FOR FATAL MESSAGES
DEFINE	FATMSG <	XLIST
		0215		/CARRIAGE RETURN
		0215		/ EXTRA CR FOR FILLER
		0012		/LINE FEED
		0207		/BELL
		0207		/BELL
		0077		/ASCII "?"
		0077		/ASCII "?"
	XLIST	>/END OF DEFINE FATMSG
/MESSAGE SENT WHEN STATION RESTARTS
RSTMSG,	377
	0012		/EXTRA LINE FEED
	207		/EXTRA BELL
	0012		/EXTRA LINE FEED
	BEGMSG
	"R
	0145		/E
	0363		/S
	0164		/T
	0341		/A
	0162		/R
	0164		/T
	0151		/I
	0356		/N
	0347		/G
	" 		/BLANK
	DC7MSG
	" 		/BLANK
	0116		/N
	0117		/O
	0104		/D
	0105		/E
	" 		/BLANK
	0042		/"
OURID,
IFDEF DC92ID <
	DC92ID
>/END OF IFDEF DC92ID
IFNDEF	DC92ID	<
	"D;"N;"9;"2
>/END OF IFNDEF	DC92ID
	0042		/"
	240		/SPACE
	215
	012
TTOBEL,	4207		/BELL
CONBKE,NCOMSG,	BEGMSG
	"T;"T;"Y;" ;"N;"O;"T;" ;"C;"O;"N;"N;"E;"C;"T;"E;"D;215;4012



BMTMSG,	377		/SPECIAL FILLER
	FATMSG
	"B;"A;"D;" ;"M;"S;"G;" ;"T;"Y;"P;4000+"E

/UNRECOGNIZED INTERRUPT MSG
INTMSG,	377		/SPECIAL FILLER TO START
	FATMSG
	DC7MSG
	" ;"I;"N;"T;" ;"E;"R;4000+"R

/AUTODUMP MESSAGE
DMPMSG,	377			/RUBOUT TO BEGIN
	FATMSG
	DC7MSG
	" ;"C;"R;"A;"S;"H;" ;"P;"C;4000+"=
DPTMSG,	BEGMSG
	DPMSG
	" ;"T;"I;"M;"E;"O;"U;4000+"T

XOFMS,	4023	/XOF CHAR
IFNZRO CDRN <		/MESSAGE WHEN GET READ CHECK ON CARDREADER
RCKMSG,	BEGMSG
	"R;"D;"C;"H;"K;" ;"-;" ;"R;"E;"F;"E;"E;"D;" ;"C;"A;"R;"D;215;4012
>/END OFIFNZRO CDRN

IFNZRO FTTRBL <
IFNZRO LPTN <
/MESSAGE WHEN LPT TIMES OUT
LPTMSG,	BEGMSG
	"L;"P;"T;" ;"T;"R;"B;4000+"L
>/END OF IFNZRO LPTN

IFNZRO PTPN <
/MSG WHEN PTP TIMES OUT
PTPMSG,	BEGMSG
	"P;"T;"P;" ;"T;"R;"B;4000+"L
>/END OF IFNZRO PTPN
>/END OF IFNZRO FTTRBL


/MESSAGE IF DP8E GETS A BUS ERROR
DBEMSG,	BEGMSG
	DPMSG
	" ;"B;"U;"S;" ;"E;"R;4000+"R

/MESSAGE WHEN CARRIER LOST
LCRMSG,	BEGMSG
	"C;"A;"R;"R;"I;"E;"R;" ;"L;"O;"S;"T;215;4012
CARMSG,	BEGMSG
	"C;"A;"R;"R;"I;"E;"R;" ;"B;"A;"C;"K;215;4012
IFNZRO CDRN <
/CARD CODE TRANSLATION TABLES
/ TRICK IS USE ROWS TO INDEX INTO THE TABLES
/ IF THE RESULT HAS THE SIGN BIT ON CAN'T COMPRESS COLUMN
/TABLE TO TRANSLATE ROWS 1/2/3/4/5
CD1TAB,	0000;	2005;	2004;	4000;	2003;	4000;	4000;	4000
	2002;	4000;	4000;	4000;	4000;	4000;	4000;	4000
	3001;	4000;	4000;	4000;	4000;	4000;	4000;	4000
	4000;	4000;	4000;	4000;	4000;	4000;	4000;	4000

/TABLE TO TRANSLATE ROWS 6/7/8/9
CD2TAB,	0000;	2011;	1010;	4000;	2007;	4000;	2017;	4000
	2006;	4000;	2016;	4000;	4000;	4000;	4000;	4000
>/END OF IFNZRO CDRN
/TABLE FOR INTERPRETING TTY & LPT CHAR FUNCTIONS
/ BIT DEFINITIONS ARE:
	CHRBRK=0
	CHRARR=0
	CHRSUP=0
	CHRALT=0
	CHRFLL=2000
	CHRDEF=4000		/GO INTO DEFERRED ECHO
	CHRXOF=0200		/CHAR IS AN XOF
	CHRHT=0040		/CHAR IS AN HT
	CHRHMO=0020		/CHAR PERFORMS HORIZONTAL MOTION
	CHRCR=0010		/CHAR IS A CARRIAGE RETURN
	CHRLC=0004		/CHAR IS LOWER CASE
/	0002		/FOR LPT CHAR IS SPECIAL MOTION
/	0001		/FOR LPT FLUSH CHAR

CHRTAB,	0001			/ASCII 0
	CHRDEF+CHRARR+0001	/ASCII 1 = ^A
	CHRDEF+CHRARR+0001	/ASCII 2 = ^B
	CHRDEF+CHRBRK+CHRARR+0001	/ASCII 3 = ^C
	CHRDEF+CHRARR+0001	/ASCII 4 = ^D
	CHRDEF+CHRARR+0001	/ASCII 5 = ^E
	CHRDEF+CHRARR+0001	/ASCII 6 = ^F
	CHRDEF+CHRBRK+0001	/ASCII 7 = ^G = BELL
	CHRDEF+CHRFLL+0001	/ASCII 10 = ^H
	CHRFLL+CHRHT+0002+CHRHMO	/ASCII 11 = ^I = HORIZONTAL TAB
	CHRDEF+CHRBRK+CHRFLL+0002	/ASCII 12 = LINE FEED
	CHRDEF+CHRBRK+CHRFLL+0002	/ASCII 13 = VERT TAB
	CHRDEF+CHRBRK+CHRFLL+0002	/ASCII 14 = FORM FEED
	CHRFLL+CHRCR+0002	/ASCII 15 = CARRIAGE RETURN
	CHRDEF+CHRARR+0001	/ASCII 16 = ^N
	CHRDEF+CHRARR+0001	/ASCII 17 = ^O
	CHRDEF+CHRARR+0002	/ASCII 20 = ^P
	CHRDEF+CHRARR+0002	/ASCII 21 = ^Q = XON
	CHRDEF+CHRARR+0002	/ASCII 22 = ^R
	CHRDEF+CHRARR+CHRXOF+0002	/ASCII 23 = ^S = XOF
	CHRDEF+CHRARR+0002	/ASCII 24 = ^T
	CHRDEF+CHRSUP+0001	/ASCII 25 = ^U - NOT CHRARR BECAUSE SPECIAL HANDLING
	CHRDEF+CHRARR+0001	/ASCII 26 = ^V
	CHRDEF+CHRARR+0001	/ASCII 27 = ^W
	CHRDEF+CHRARR+0001	/ASCII 30 = ^X
	CHRDEF+CHRARR+0001	/ASCII 31 = ^Y
	CHRDEF+CHRBRK+CHRARR+0001	/ASCII 32 = ^Z
	CHRDEF+CHRBRK+CHRALT+0001	/ASCII 33 = ALTMODE
	CHRDEF+CHRARR+0001	/ASCII 34 = ^\
	CHRDEF+CHRARR+0001	/ASCII 35 = ^]
	CHRDEF+CHRARR+0001	/ASCII 36 = ^^
	CHRDEF+CHRARR+0001	/ASCII 37 = ^_
CHRBLA,				/CHARACTER WITH CHRHMO BIT SET FOR TAB SIMULATION
	CHRHMO			/ASCII 40 =  
	CHRHMO			/ASCII 41 = !
	CHRHMO			/ASCII 42 = "
	CHRHMO			/ASCII 43 = #
	CHRHMO			/ASCII 44 = $
	CHRHMO			/ASCII 45 = %
	CHRHMO			/ASCII 46 = &
	CHRHMO			/ASCII 47 = '
	CHRHMO			/ASCII 50 = (
	CHRHMO			/ASCII 51 = )
	CHRHMO			/ASCII 52 = *
	CHRHMO			/ASCII 53 = +
	CHRHMO			/ASCII 54 = ,
	CHRHMO			/ASCII 55 = -
	CHRHMO			/ASCII 56 = .
	CHRHMO			/ASCII 57 = /
	CHRHMO			/ASCII 60 = 0
	CHRHMO			/ASCII 61 = 1
	CHRHMO			/ASCII 62 = 2
	CHRHMO			/ASCII 63 = 3
	CHRHMO			/ASCII 64 = 4
	CHRHMO			/ASCII 65 = 5
	CHRHMO			/ASCII 66 = 6
	CHRHMO			/ASCII 67 = 7
	CHRHMO			/ASCII 70 = 8
	CHRHMO			/ASCII 71 = 9
	CHRHMO			/ASCII 72 = :
	CHRHMO			/ASCII 73 = ;
	CHRHMO			/ASCII 74 = <
	CHRHMO			/ASCII 75 = =
	CHRHMO			/ASCII 76 = >
	CHRHMO			/ASCII 77 = ?
	CHRHMO			/ASCII 100 = @
	CHRHMO			/ASCII 101 = A
	CHRHMO			/ASCII 102 = B
	CHRHMO			/ASCII 103 = C
	CHRHMO			/ASCII 104 = D
	CHRHMO			/ASCII 105 = E
	CHRHMO			/ASCII 106 = F
	CHRHMO			/ASCII 107 = G
	CHRHMO			/ASCII 110 = H
	CHRHMO			/ASCII 111 = I
	CHRHMO			/ASCII 112 = J
	CHRHMO			/ASCII 113 = K
	CHRHMO			/ASCII 114 = L
	CHRHMO			/ASCII 115 = M
	CHRHMO			/ASCII 116 = N
	CHRHMO			/ASCII 117 = O
	CHRHMO			/ASCII 120 = P
	CHRHMO			/ASCII 121 = Q
	CHRHMO			/ASCII 122 = R
	CHRHMO			/ASCII 123 = S
	CHRHMO			/ASCII 124 = T
	CHRHMO			/ASCII 125 = U
	CHRHMO			/ASCII 126 = V
	CHRHMO			/ASCII 127 = W
	CHRHMO			/ASCII 130 = X
	CHRHMO			/ASCII 131 = Y
	CHRHMO			/ASCII 132 = Z
	CHRHMO			/ASCII 133 = [
	CHRHMO			/ASCII 134 = \
	CHRHMO			/ASCII 135 = ]
	CHRHMO			/ASCII 136 = ^
	CHRHMO			/ASCII 137 = _
	CHRHMO			/ASCII 140 =
	CHRLC+CHRHMO		/ASCII 141 = LC A
	CHRLC+CHRHMO		/ASCII 142 = LC B
	CHRLC+CHRHMO		/ASCII 143 = LC C
	CHRLC+CHRHMO		/ASCII 144 = LC D
	CHRLC+CHRHMO		/ASCII 145 = LC E
	CHRLC+CHRHMO		/ASCII 146 = LC F
	CHRLC+CHRHMO		/ASCII 147 = LC G
	CHRLC+CHRHMO		/ASCII 150 = LC H
	CHRLC+CHRHMO		/ASCII 151 = LC I
	CHRLC+CHRHMO		/ASCII 152 = LC J
	CHRLC+CHRHMO		/ASCII 153 = LC K
	CHRLC+CHRHMO		/ASCII 154 = LC L
	CHRLC+CHRHMO		/ASCII 155 = LC M
	CHRLC+CHRHMO		/ASCII 156 = LC N
	CHRLC+CHRHMO		/ASCII 157 = LC O
	CHRLC+CHRHMO		/ASCII 160 = LC P
	CHRLC+CHRHMO		/ASCII 161 = LC Q
	CHRLC+CHRHMO		/ASCII 162 = LC R
	CHRLC+CHRHMO		/ASCII 163 = LC S
	CHRLC+CHRHMO		/ASCII 164 = LC T
	CHRLC+CHRHMO		/ASCII 165 = LC U
	CHRLC+CHRHMO		/ASCII 166 = LC V
	CHRLC+CHRHMO		/ASCII 167 = LC W
	CHRLC+CHRHMO		/ASCII 170 = LC X
	CHRLC+CHRHMO		/ASCII 171 = LC Y
	CHRLC+CHRHMO		/ASCII 172 = LC Z
	CHRDEF			/ASCII 173 =
	CHRDEF			/ASCII 174 =
	CHRDEF+CHRBRK+CHRALT	/ASCII 175 = ALTMODE
	CHRDEF+CHRBRK+CHRALT	/ASCII 176 = ALTMODE
	CHRDEF+CHRSUP+0001	/ASCII 177 = RUBOUT
	LISTOG	LPTN
IFNZRO LPTN <
LPTTBL,	0		/CHAR 11 = HORIZONTAL TAB
	0001		/CHAR 12 = LF = CHANNEL 8
	0002		/CHAR 13 = VT = CHANNEL 7
	-2		/CHAR 14 = FORM FEED = CHANNEL 1
	-1		/CHAR 15 = CARRIAGE RETURN
	0		/CHAR 16 = CHANGE RIBBON TO RED
	0		/CHAR 17 = CHANGE RIBBON TO BLACK
	0100		/CHAR 20 = DC0 = CHANNEL 2
	0040		/CHAR 21 = DC1 = CHANNEL 3
	0020		/CHAR 22 = DC2 = CHANNEL 4
	0010		/CHAR 23 = DC3 = CHANNEL 5
	0004		/CHAR 24 = DC4 = CHANNEL 6


/SIMULATED CARRIAGE CONTROL TAPE FOR LPT

LPTVFU,	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8

	051		/ 3-5-8
	031		/ 4-5-8
	055		/ 3-5-6-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8

	051		/ 3-5-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8
	057		/ 3-5-6-7-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8

	071		/ 3-4-5-8
	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	175		/ 2-3-4-5-6-8
	011		/ 5-8

	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8

	057		/ 3-5-6-7-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8

	071		/ 3-4-5-8
	011		/ 5-8
	055		/ 3-5-6-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8

	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	010		/ 5
	010		/ 5
	010		/ 5
	010		/ 5

	010		/ 5
	010		/ 5
	-1		/FLAG END OF TAPE
>/END OF IFNZRO LPTN
	LISTOG	LPTN
STARTC,	ENQ;6;0;0;0;1;111;225	/DDCMP START MESSAGE
STARTD,	SOH;0;0;0;0;1		/START OF DATA MESSAGE
SID,	0	/LENGTH OF STRING
	SIDTXT
SIDEND,
*SID
ZZ=SID+1-SIDEND
	ZZ
*SIDEND
 DEFINE VAL Q <	Q
	 XLIST; ZZZ=ZZZ+1; XLIST>/END OF DEFINE VAL
	ZZZZ=.
CNF,	0			/LENGTH 
	ZZZ=0
	VAL	5		/MESSAGE TYPE
	IFNZRO	LPTN	<
	VAL	3		/OBJECT CLASS
	VAL	LPTN
	VAL	0		/DESCRIPTION
>/END OF IFNZRO	LPTN
	VAL	1		/OBJECT TYPE
IFNDEF FTOLDC <	VAL	TTYN+1	>
IFDEF	FTOLDC	<
	Z=TTYN+1
	Z=Z-1
IFZERO Z < 1 >
	Z=Z-4
IFZERO Z < 37 >
	Z=Z-4
IFZERO Z < 377
	3 >
	Z=Z-4
IFZERO Z < 377
	77 >
	Z=Z-4
IFZERO Z < 377
	377
	3 >
>/END OF IFDEF FTOLDC  GENERATES BIT PATTERN FOR CONF MSG
	VAL	0		/DESCRIPTION
	IFNZRO	CDRN	<
	VAL	2		/OBJECT TYPE
	VAL	CDRN
	VAL	0		/DESCRIPTION
>/END OF IFNZRO	CDRN
	ZZZZZ=.
	*ZZZZ
	ZZZ
	*ZZZZZ

FREDCK,	0		/COUNT OF CHUNKS FREED BY FRECKS


DEFINE	X	Q QQ QQQ <XLIST
IFNZRO Q <XLIST
	Z-QQ
	QQQ
XLIST
	Z=QQ	>/END OF IFNZRO	Q
XLIST	>/END OF X
	Z=0
DEVTYP,	X	1,1,CONTTY		/CONNECT FOR TTY
	X	CDRN,2,CONCDR
	X	LPTN,3,CONLPT
/TABLE OF TTY SPEEDS FOR CHARACTERISTICS MESSAGE [1(14)]
/
DEFINE SPD BLK RCV XMT <XLIST
	Z=Z-1			/DECREMENT COUNTER
IFDEF XMT <
IFNDEF RCV <	RCV=XMT	>
>
IFDEF RCV <
IFNDEF XMT <	XMT=RCV	>
>
	XLIST
IFDEF RCV <
	-BLK			/NEGATIVE OF DDB ADDRESS
	RCV			/RECEIVE SPEED
	XMT			/TRANSMIT SPEED
>
>/END DEFINE SPD

DFAULT,				/DEFAULT SPEED ENTRY
	DFLRCV
	DFLXMT

SPDTAB,				/SPEED TABLE
	Z=TTYN+1		/TOTAL NUMBER OF TTY'S
	SPD	CTYBLK,CTYRCV,CTYXMT
IFNZRO Z <	SPD T00BLK,T00RCV,T00XMT
>
IFNZRO Z <	SPD T01BLK,T01RCV,T01XMT
>
IFNZRO Z <	SPD T02BLK,T02RCV,T02XMT
>
IFNZRO Z <	SPD T03BLK,T03RCV,T03XMT
>
IFNZRO Z <	SPD T04BLK,T04RCV,T04XMT
>
IFNZRO Z <	SPD T05BLK,T05RCV,T05XMT
>
IFNZRO Z <	SPD T06BLK,T06RCV,T06XMT
>
IFNZRO Z <	SPD T07BLK,T07RCV,T07XMT
>
IFNZRO Z <	SPD T10BLK,T10RCV,T10XMT
>
IFNZRO Z <	SPD T11BLK,T11RCV,T11XMT
>
IFNZRO Z <	SPD T12BLK,T12RCV,T12XMT
>
IFNZRO Z <	SPD T13BLK,T13RCV,T13XMT
>
IFNZRO Z <	SPD T14BLK,T14RCV,T14XMT
>
IFNZRO Z <	SPD T15BLK,T15RCV,T15XMT
>
IFNZRO Z <	SPD T16BLK,T16RCV,T16XMT
>
IFNZRO Z <	SPD T17BLK,T17RCV,T17XMT
>
	0			/TO END TABLE

/CONSIDER THE FOLLOWING METHOD OF CACULATING CRC-16
/ CALL:	PUSHJ	P,CRCALC
/ CRCALC:	XOR	C,CRC
/	ANDI	C,377
/	LSH	CRC,-10
/	XOR	CRC,TAB(C)
/RH OF TABLE FOLLOWS IMMEDIATELY, LH IS CRCTAB+400
CRCTAB,	BLOCK	1000
CRCTBE=.			/CURRENT LOCATION IS END OF CRCTAB [1(14)]
CRCTBC=5200-CRCTBE		/CALCULATE FREE WORDS [1(14)]
CRCTBC=CRCTBC&4000		/GET SIGN BIT [1(14)]

IFNZRO CRCTBC <
	CRCTBG			/GENERATE ERROR IF CRC TABLE OVERLAPS [1(14)]
>

*5200

NCSDLA,	0			/SEND DLA
	TAD	TEMPB		/INDEX INTO TABLE
	TAD	(SLATAB-1	/GET LINK ADDRESS
	DCA	TEMPA
	TAD I	TEMPA		/DLA
	JMS	SNDEXN
	JMP I	NCSDLA		/RETURN

XMTCR1,				/HERE FOR PART OF XMTCHR  [1(14)]
	TAD I	TEMPA		/GET DLA FROM NCSDLA  [1(14)]
	SNA CLA			/MAKE SURE IT IS NON-ZERO  [1(14)]
	  JMP	XSTRT1		/IF NOT, SKIP THIS TTY ENTIRELY  [1(14)]
	IOF			/DON'T CHANGE BITS ON INTERRUPT LEVEL  [1(14)]
	TAD I	DDBSTS		/GET CURRENT STATUS BITS  [1(14)]
	AND	(-CHRBIT-1	/CLEAR CHARACTERISTICS BIT  [1(14)]
	DCA I	DDBSTS		/STORE IT BACK  [1(14)]
	ION			/ALLOW INTERRUPTS AGAIN  [1(14)]
	TAD	(27		/COUNT FOR SUB-MESSAGE  [1(14)]
	JMS	SNDCHR
	NL4			/CONTROL TYPE CODE (4)  [1(14)]
	JMS	SNDCHR
	NL2			/CHARACTERISTICS SUB-TYPE (2)  [1(14)]
	JMS	SNDCHR
	JMP	XMTCR2		/GO TO NEXT PART OF ROUTINE  [1(14)]

/HERE WHEN SYNCHRONOUS TRANSMITTER IS IDLE TO TRY TO START IT
/ FIRST SEE IF WE NEED TO SEND A START OR STACK MESSAGE
/ THEN SEE IF WE NEED TO SEND A NAK MESSAGE
/ THEN SEE IF WE HAVE A NUMBERED MESSAGE TO SEND
/ THEN SEE IF WE NEED TO SEND AN ACK
/ THEN SEE IF WE SHOULD SEND A REP

XSTART,	JMS	XSTRT0		/SET UP TO SEND A CTL MESSAGE
	CDF	0		/SET DATA FIELD TO ZERO
	TAD	(SYNBUF-1	/POINT TO ONE BEFORE SYN'S
	DCA I	[T10NCA		/ADR OF MESSAGE
	TAD	(-10-NUMSYN	/NEGATIVE OF NUMBER OF SYN'S
	DCA I	[T10NWC		/NEXT WC
	TAD I	[STACKF		/GET STACK FLAG (-1 FOR STACK, -2 FOR START)
	SPA CLA
	  JMP	SNDSTK		/NEED TO SEND START OR STACK
	TAD I	[NAKFLG
	SZA CLA
	JMP	SNDNAK		/CHECK FOR NEED NAK
	TAD I	[T10TKR
	NEGATE
	TAD I	[T10PTR		/CHECK FOR RETRANSMISSIONS
	SZA CLA			/DO WE HAVE A MESSAGE TO RETRANSMIT
	  JMP	SNDMSG		/IF HAVE A MESSAGE SEND IT
	TAD I	[T10PTR
	TAD	(-T10LST	/SEE IF TIME TO WRAP AROUND
	SNA
	  TAD	(T10BF1-T10LST-T10LEN
	TAD	(T10LEN+T10LST
	NEGATE
	TAD I	[T10AKR		/COMPARE TO LAST ACKED
	SNA CLA			/HAVE SENT ALL WE CAN ?
	  JMP	XSTRT9
	TAD I	[DISREA		/SEE IF WE NEED TO SEND DISCONNECT
	SZA CLA			/ZERO MEANS NO
	  JMP	XDISCN		/SEND IT
	CDF	10		/CHANGE BACK TO DEF DATA FIELD
	JMS	RCCOF	/CHECK TO SEE IF NEED TO REQ CONF
	JMS	XMBT		/SEE IF ANY STATION CTRL MSGS NEED TO BE XMTTED
	JMS	DISCHK		/SEE IF NEED TO SEND DISCONNECT
	TAD	NXTDDB		/INITIALIZE LOOP CHECK
	SNA			/SKIP IF NOT FIRST TIME OR WRAP AROUND
	TAD	(FIRDDB		/FIRST TIME OR WRAP AROUND, POINT TO LAST DDB
	DCA	SERDDB		/START OF DDB STRING
	TAD	SERDDB		/GET ADDRESS OF DDB TO SERVICE
	DCA	DDB		/SAVE IT
	JMP	XSTA		/AND JUMP INTO THE THICK OF THINGS
XSTRT1,	TAD I	(NXTDDB		/GET DDB TO BE SERVICED NEXT
	SNA			/CHECK FOR BEG OF CHAIN
	TAD	(FIRDDB		/INITIALIZE TO FIRST OF CHAIN
	DCA	DDB		/SET UP FOR SERVICING
	TAD	DDB		/CHECK FOR END OF LOOP
	NEGATE
	TAD	SERDDB
	ION
	SNA CLA			/SKIP IF NOT END
	JMP	XSTRT9		/WE HAVE LOOKED AT ALL DDBS
XSTA,
	TAD	(DEVLNK		/POINTER TO NEXT DDB
	TAD	DDB
	DCA	TEMP1		/ADDR OF NEXT DDB TO BE SERVICED
	TAD I	TEMP1
	DCA	NXTDDB		/SAVE FOR NEXT TIME AROUND
				/IF WE SERVICE DDB, THEN NEXT TIME WE
				/COME TO XSTART WE WILL START WITH
				/THIS ONE
	NLOAD	DEVSTS
	TAD	DDB
	DCA	DDBSTS		/SAVE ADR OF STATUS WORD
	TAD	(3000		/MASK FOR CONNECT & ACCEPT BIT
	AND I	DDBSTS
	SNA			/CHECK TO SEE IF 10 KNOWS ABOUT DEVICE
	  JMP	XSTRT1		/LEAVE THIS ORPHAN ALONE
	AND	(1000		/DO WE NEED AN ACCEPT ?
	IOF
	SNA CLA			/SKIP IF WE HAVE TO SEND CONNECT CONFIRM OR DISCONNECT
	  JMP	XSTRT2		/NO, TRY SOMETHING ELSE
	NL2000
	AND I	DDBSTS
	SNA CLA
	  JMP	XSDIS0
	TAD I	DDBSTS		/GET STATUS
	AND	(6777		/TURN OFF NEED-TO-ACCEPT BIT
	DCA I	DDBSTS		/UPDATE STATUS
	JMS	XSTMSG		/SET UP TO SEND A MESSAGE
	JMP	XS1CON		/CONTINUE OVER PAGE
	PAGE
XS1CON,
/92 CAN BE ISSUING A CONNECT CONF OR CONNECT INITIATE
	TAD	DDB
	TAD	(DEVRCN
	DCA	TEMP2
	TAD I	TEMP2
	SZA CLA
	JMP	XS2		/ISSUE CONNECT INITIATE
/HERE ON CONNECT CONFIRM FROM ABOVE, AND ON CONNECT INITIATE FROM
/XS2 IF DEVRNN IS COMPATIBLE TO FINISH SENDING CONNECT
XS3,	JMS	FEAPNT
	TAD	(10
	JMS	NCSBEG
	TAD	(12		/LENGTH OF CONNECT (EXCLUSIVE OF FEATURES)
/NOTE: ASSUMES EXTENSIBLE FIELDS ALWAYS SENT AS TWO BYTES
	TAD I	TEMP2		/ADD FEATURE LENGTH
	JMS	SNDEXN		/SEND COUNT (EXTENSIBLE NUMBER)
	NL1			/CONNECT=1
	JMS	SNDCHR		/TYPE
	JMS	NCSDLA		/SEND DLA (OR 0 IF CONNECT INITIATE)
	TAD	TEMPB		/OUR LINK VALUE
	JMS	SNDCHR		/SLA
	JMS	SNDCHR		/DEST OBJ TYPE
	JMS	SNDCHR		/DEST PID
	JMS	SNDOBJ		/SEND OBJECT TYPE
	NLM1			/GET ADDRESS OF DEVICE NUMBER
	TAD	DDB		/WHICH IS ONE BEFORE START OF DDB
	DCA	TEMP1		/STORE ADDRESS
	TAD I	TEMP1		/GET DEVICE NUMBER
	JMS	SNDCHR		/PID
	TAD	TEMPB		/GET OUR INDEX
	TAD	(MMLTAB-1	/INTO MMLTAB
	DCA	TEMP3		/STORE TO GET INDIRECT
	TAD I	TEMP3		/GET MML
	JMS	SNDEXN		/SEND AS TWO BYTE FIELD
	TAD	TEMP2
	DCA	TEMP3
	TAD I	TEMP2		/GET COUNT
	NEGATE
	DCA	TEMP2
	ISZ	TEMP3
	TAD I	TEMP3		/GET NEXT CHAR
	JMS	SNDCHR
	ISZ	TEMP2
	  JMP	.-4
	TAD I	DDBSTS		/GET STATUS BITS   [1(14)]
	AND	(TTYBIT		/CHECK FOR TTY DDB   [1(14)]
	SNA CLA			/SKIP IF TTY   [1(14)]
	  JMP	FINMSG		/WE ARE DONE IF NOT   [1(14)]
	TAD	(CHRBIT		/GET "NEED TO SEND CHARACTERISTICS" BIT   [1(14)]
	TAD I	DDBSTS		/ AND OLD STATUS BITS   [1(14)]
	DCA I	DDBSTS		/STORE THEM BACK   [1(14)]
	JMP	FINMSG		/FINISH SETTING UP MESSAGE

/BEFORE CONNECT MAKE SURE DEVRNN IS COMPATIBLE
/DEVRRN MUST BE ZERO OR CODE WILL FORCE DEVRCN TO HOST
/SPECIFIED IN DEVRRN (DEVRRN CONTAINS NEG VALUE OF LEGAL HOST
/WHICH LINE MAY BE CONNECTED TO LEGALLY)
XS2,	TAD	DDB
	TAD	(DEVRNN
	DCA	TEMPA
	TAD I	TEMPA
	SZA
	JMP	RNNCK
XS2A,	TAD I	DDB
	AND	(77	/GET DISP INTO TABLE
	SNA
	JMP	FNDRM
	DCA	TEMPA
FNDRM4,	TAD I	TEMP2
	CIF	0	/GO TO FIELD 0 FOR ROUTINE
	JMS	MCRS3		/FIELD 0 CALL TO MCRSCN
	JMP	.+2
	JMP	XS4
	TAD	(SLATAB-1
	TAD	TEMPA
	DCA	TEMPB
	DCA I	TEMPB
	TAD	TEMPA
	TAD	(SNATAB-1
	DCA	TEMPB
	TAD I	TEMP2
	DCA I	TEMPB
	TAD	 TEMPA
	TAD	(RCVDSP
	DCA	TEMPB
	TAD	(RCVTTY
	DCA I	TEMPB
	TAD	(CTRLTB-1
	TAD	TEMPA
	DCA	TEMPB
	TAD	DDB
	DCA I	TEMPB
	JMP	XS3
XS4,	DCA I	TEMP2	/0 RCN
	TAD TEMPA
	TAD	(RCVDSP
	DCA	TEMPB
	TAD	(RCVKRD
	DCA I	TEMPB
	TAD	(4777
	AND I	DDBSTS
	DCA I	DDBSTS
	JMP	XSTRT1
RNNCK,	NEGATE		/FORCE RCN TO BE HOST LINE IS ABLE TO CONNECT TO
	DCA I	TEMP2		/STORE AT DEVRCN
	JMP	XS2A

XSTRT4,	JMS	XSTMSG
	TAD	(50		/GET NCT
	JMP	XSTR4A		/JUMP OVER PAGE BOUNDARY [1(14)]
	PAGE
XSTR4A,				/CONTINUED FROM PREVIOUS PAGE [1(14)]
	JMS	NCSBG
	JMS	NCSDLA
	JMS	XMTCHR		/SEND CHARACTERISTICS IF NECESSARY  [1(14)]
	TAD	DDB		/SET UP LINKS IN FIELD 0 FOR RECI42!
	CDF	0
	DCA I	[DDB
	TAD	DDBSTS
	DCA I	[DDBSTS
	TAD	(DEVDDC
	TAD	DDB
	DCA	TEMP7
	TAD	TEMP7
	DCA I	[TEMP7
	TAD	(DEVBF1		/ADR OF BUFFER
	TAD	DDB
	DCA I	[TEMP6
	CDF	10
	CIF	0
	JMP	F0I42		/FIELD 0 LINK TO RECI42
XST41,	TAD	DDB
	DCA	TEMP4		/SAVE ADR OF DDCMP ADR
	CDF	0		/RESTORE FIELD 1 LOC
	TAD I	[TEMP6
	DCA	TEMP6
	CDF	10

/HERE TO THINK ABOUT SENDING CHARACTERS TO THE 10
XSTTRD,	TAD I	TEMP6		/GET DATA ADR(IF ANY)
	SNA			/IS THERE ANY ?
	  JMP	XSTTDN
	CDF	0		/SET UP FIELD 0 TEMP3 FOR GETCH
	DCA I	[TEMP3
	JMS	GETC		/FIELD 1 LINK TO GETCH
	HLT			/ERROR CHAR SHOULD BE THERE
	TAD	TEMP5
	TAD	(-MAXOLN+20
	SMA CLA			/ROOM ENOUGH FOR THIS DATA ?
	  JMP	XSTTDN		/NOT NOW SEND WITH THE NEXT MESSAGE
	CDF	0		/RESTORE TEMP3 FIELD 0 TO FIELD 1
	TAD I	[TEMP3
	DCA	TEMP3
	RCKFLD
	TAD I	TEMP3		/GET THE CHARACTER COUNT AGAIN
	TABFLD
	JMS	SNDCHR		/PUT THE CHAR INTO THE MESSAGE
	JMS	GETC		/GET THE NEXT CHARACTER, IF ANY
	  SKP
	JMP	.-3
	TAD I	TEMP6		/GET FIRST CHUNK ADR AGAIN
	JMS	FREC		/AND RELEASE THE CHUNKS
	DCA I	TEMP6		/CLEAR DEVBF1
	ISZ	TEMP6		/ADVANCE TO DEVBF2
	DCA I	TEMP6		/CLEAR DEVBF2

/HERE TO SEND AN ECHO-PIPELINE-MARKER(MAYBE)
	NL1			/MASK FOR DEFERRED ECHO MODE
	AND I	TEMP7		/SEE IF WE ARE IN THAT WAY
	SNA CLA			/SKIP IF TRUE
	  JMP	XSTTDN
	NL3			/COUNT
	JMS	SNDCHR
	NL4			/TYPE
	JMS	SNDCHR
	JMS	SNDCHR	
	TAD	(LDBEPL		/OFFSET FOR PIPELINE MARKER
	TAD	DDB
	DCA	TEMP1		/SAVE POINTER TO MARKER
	ISZ I	TEMP1		/ADVANCE MARKER
	  TAD I	TEMP1		/GET IT IF NOT ZERO
	AND	(0177		/7 BITS ONLY PLEASE
	JMS	SNDCHR		/PUT MARKER INTO THE MESSAGE
/HERE WHEN DONE WITH A LINE
XSTTDN,	ION
	TAD	TEMP5		/GET CURRENT MESSAGE SIZE
	TAD	(-MAXOLN+20	/COMPARE TO MAX
	SMA CLA
	  JMP	FINMSG		/SEND MESSAGE AS IS
	TAD	(-7
	TAD	TEMP5		/GET MESSAGE SIZE
	SZA CLA			/TEST FOR REAL MESSAGE
	  JMP	FINMSG		/REAL SO SEND MESSAGE
	JMS	XDRQ
	JMP	XSTRT1		/NOT REAL SO DON'T SEND IT
RCCOF,	0	/CHECK TO SEE IF NEED TO REQ CONF FROM ANY NODES
	TAD	(NEITAB-1
	DCA	TEMPB
RCCOF1,	ISZ	TEMPB
	NL0
	TAD I	TEMPB
	SNA		/END OF TABLE
	JMP I	RCCOF	/RETURN
	AND	[400	/CONF REQUIRED
	SZA CLA
	JMP	XSCONF	/YES
	TAD I	TEMPB
	SMA
	JMP	RCCOF1	/CONT LOOKING
	AND	(3777	/TURN OFF BIT
	DCA I	TEMPB
	TAD I	TEMPB
	AND	[377	/TURN OFF ANY EXTRANEOUS BITS
	CDF	0
	DCA I	[DISSNA	/STORE FOR SUBR TO START MSG
	CDF	10
	JMS	XDISBG
	NL1
	JMS	SNDCHR		/COUNT IS 1
	NL4			/TYPE IS 4 REQ CONFIG
	JMS	SNDCHR
	JMP	FINMSG
	PAGE
XSD1,	NL2000			/SET CONNECT BIT
	TAD I	DDBSTS		/GET REST OF BITS
	DCA I	DDBSTS		/ AND STORE RESULT
	JMP	FINMSG
XDISCN,	CDF	10
	JMS	XDISBG		/SEND BEGINNING OF MSG
	TAD	(5		/COUNT
	JMS	SNDCHR		/COUNT
	NL2
	JMS	SNDCHR		/TYPE=DISCONNECT
	CDF	0
	TAD I	[DISSLA		/GET LINK WHO REQUESTED CONNECT
	CDF	10
	JMS	SNDEXN		/DLA
	JMS	SNDCHR		/SLA=0
	CDF	0
	TAD I	[DISREA		/PICK UP REASON
	JMS	SNDCHR		/RSN
	CDF	0
	DCA I	[DISREA		/CLEAR REASON
	CDF	10
	JMP	FINMSG		/FINISH MESSAGE
/HERE TO SEE IF WE NEED TO SEND A STATUS MESSAGE TO THE 10
XSTRT7,	NL1			/MASK FOR NEED TO SEND STATUS BIT
	AND I	DDBSTS
	SZA CLA			/SKIP IF WE DON'T NEED TO SEND STATUS
	  JMP	SNDSTS		/SEND STATUS TO THE 10

	  JMP	XSTRT1		/CHECK IT FOR POSSIBLE SERVICE
XSTRT0,	0			/MOVE FROM PREV LOC BEFORE XDISBG
	TAD	(CTLBUF		/POINT TO BEG OF CONTROL BUFFER
	DCA	AUTO1		/ASSUME UNNUMBERED
CRCXI3,	DCA	CRC1		/CLEAR CRC
	DCA	CRC2
	TAD	(ENQ		/FIRST CHAR TO CRC
	JMS	CRCA		/CALCULATE CRC
	JMP I	XSTRT0

XSTRT9,	CDF	10
	JMS	XSTRT0
	CDF	0
	TAD I	[RECVOK
	SPA CLA
	  JMP	SNDACK		/CHECK FOR NEED ACK

/HERE TO SEND A REP MESSAGE
SNDREP,	JMS	CKREPT		/CHECK REP TIMER
	NLOAD	REP
	JMS	SNDCHR		/2ND CHAR IS REP
SNDRP3,	JMS	SNDFIL
	JMS	SNDFIL		/3RD & 4TH ARE FILLS
SNDRP5,	CDF	0
	TAD I	[T10HSN
	JMS	SNDCHR		/5TH CHAR IS HIGHEST MSG # SENT
	JMP	SNDAK6		/REST IS LIKE AN ACK MSG

/HERE TO SEE IF REP TIMER HAS GONE OFF
CKREPT,	0
	TAD I	[REPTCK
	SPA CLA
	JMP	ALP30		/IF STILL COUNTING DON'T SEND
	TAD	(-REPTIM
	DCA I	[REPTCK		/RESET TIMER
	JMP I	CKREPT
ALP30,	CDF	10
	CIF	0
	JMP	LOOP30


SNDSTS,	NL7776			/MASK TO CLEAR NEED TO SEND STATUS BIT
	AND I	DDBSTS		/CLEAR BIT FROM WORD
	DCA I	DDBSTS		/SAVE UPDATED WORD
	JMS	XSTMSG		/BEGIN BUILDING MESSAGE
	TAD	(50		/NCT FOR STATUS MESSAGE
	JMS	NCSBG		/BEGINNING OF DEVICE CONTROL MSG
	JMS	NCSDLA		/DLA
	NL4			/COUNT
	JMS	SNDCHR
	NL3			/TYPE
	JMS	SNDCHR
	JMS	SNDCHR
	TAD	(DEVDSL		/GET 2 EXTRA STATUS BITS TO SEND TO 10
	TAD	DDB
	DCA	TEMP3
	TAD I	TEMP3
	AND	(140
	DCA	TEMP2		/SAVE TO ADD LATER
	TAD	(DEVDDC
	TAD	DDB
	DCA	TEMP3
	TAD I	TEMP3
	AND	(0177		/STRIP EXTRA BITS
	TAD	(0200		/ADD EXTENSIBLE BIT
	JMS	SNDCHR
	TAD I	TEMP3		/GET HIGH ORDER BITS OF STATUS WORD
	BSW
	CLL RAR
	AND	(0037		/CLEAR EXTRA BITS
	TAD	TEMP2		/GET EXTRA 2 STATUS BITS
	JMS	SNDCHR
	JMP	FINMSG		/SEND MESSAGE
/TEMP CONVENTIONS WHEN BUILDING MESSAGES
/ TEMP5 IS COUNT OF DATA PORTION
XSTMSG,	0
	ION
CRCXI4,	DCA	CRC1		/CLEAR 1ST HALF OF CRC		########
	DCA	CRC2		/CLEAR 2ND HALF OF CRC
	CDF	0
	TAD I	[T10PTR		/POINTER TO NEW MESSAGE
	CDF	10
	TAD	(7		/MAKES POINTER TO DATA
	DCA	AUTO1
	DCA	TEMP5
	JMP I	XSTMSG

	PAGE
/HERE TO SEND A STACK MESSAGE
SNDSTK,	CDF	0
	TAD I	[STACKF		/GET START-STACK FLAG
	IAC
	SPA CLA			/SKIP TO SEND A STACK
	  JMP	SNDSRT		/NEED TO SEND A START
	DCA I	[STACKF		/DONE WHEN HAVE RESPONDED
	TAD	(STACK
	JMS	SNDCHR		/2ND CHAR IS STACK
	JMS	SNDFIL		/3RD CHAR IS A FILL
	JMS	SNDCHR		/4TH CHAR IS A FILL
SNDSK5,
	JMS	SNDCHR		/5TH CHAR IS A FILL
	JMP	SNDAK6		/6TH IS DEST STA ADR


/HERE TO SEND A START MESSAGE
SNDSRT,	JMS	CKREPT		/CHECK REP TIMMER
	TAD	(STRT
	JMS	SNDCHR		/2ND WORD IS START
	JMS	SNDFIL
	JMS	SNDFIL		/3RD & 4TH ARE FILLS
	JMP	SNDSK5		/REST IS LIKE A STACK

/HERE TO SEND A NAK MESSAGE
SNDNAK,	NLOAD	NAK
	JMS	SNDCHR		/2ND CHAR IS A NAK
	CDF	0
	TAD I	[NAKFLG
	JMS	SNDCHR		/3RD IS REASON
	CDF	0
	DCA I	[NAKFLG		/CLEAR NAK FLAG
	JMP	SNDAK4		/REST IS LIKE AN ACK MSG

/HERE TO SEND AN ACK MESSAGE
SNDACK,	NL3777
	CDF	0
	AND I	[RECVOK
	DCA I	[RECVOK		/CLEAR NEED ACK FLAG
	NLOAD	ACK
	JMS	SNDCHR		/2ND CHAR IS ACK
	JMS	SNDFIL		/3RD IS FILL
SNDAK4,	CDF	0
	TAD I	[RECVOK
	JMS	SNDCHR		/4TH IS LAST GOOD MSG #
	JMS	SNDFIL		/5TH CHAR IS FILL
/HERE TO PUT DESTINATION STATION ADR AND CRC ON MESSAGE
SNDAK6,	NL1
	JMS	SNDCHR		/6TH CHAR IS ALWAYS 1
	TAD	CRC2		/GET LOW PART OF CRC
	DCA I	AUTO1		/PUT HALF OF CRC IN MSG
	TAD	CRC1		/GET HIGH PART OF CRC
	DCA I	AUTO1		/ DITTO
IFNZRO	DP8ETR	<
	JMS	OTR		/TRACE MESSAGE
>/END OF IFNZRO	DP8ETR
	NLM2
	CDF	0
	DCA I	[T10FLG
	JMP	ALP		/FLAG FOR XMITTER

/HERE TO PUT A FILL CHARACTER INTO A MESSAGE
SNDFIL,

/HERE TO PUT A CHAR INTO A MESSAGE
SNDCHR,	0
	CDF	10
	AND	(0377		/STRIP EXTRA BITS IF ANY
	DCA	TEMP1		/SAVE COPY OF CHAR
	TAD	TEMP1		/GET CHAR AGAIN
	DCA I	AUTO1		/PUT CHARACTER INTO MESSAGE

	TAD	TEMP1		/GET CHARACTER AGAIN
	JMS	CRCA		/PUT INTO CRC CALCULATION
	ISZ	TEMP5		/COUNT CHAR
	JMP I	SNDCHR
	JMP I	SNDCHR
SNDEXN,	0			/SEND EXTENSIBLE NUMBER
/ NOTE: ALWAYS SENDS TWO BYTE EXTENSIBLE NUMBER, SINCE
/ OTHERWISE TOO HARD TO CALCULATE COUNTS.
	DCA	TEMPD		/SAVE IT
	TAD	TEMPD		/GET IT AGAIN
	AND	(177		/TURN OFF ALL BUT BOTTOM SEVEN
	TAD	(200		/TURN ON EXTENSIBLE BIT
	JMS	SNDCHR		/SEND LOW BITS
	TAD	TEMPD		/GET CHARACTER
	AND	(7600		/TURN OFF BOTTOM 7 BITS
	BSW
	CLL RAR
	JMS	SNDCHR		/SEND HIGH BITS
	JMP I	SNDEXN		/RETURN
/HERE TO SEND A NUMBERED MESSAGE TO 10
SNDMSG,	NLM1
	CDF	0
	TAD I	[T10TKR
	DCA I	[T10NCA		/ADR OF BUFFER
	TAD I	[T10TKR
	DCA	AUTO1
	CDF	10
	TAD I	AUTO1		/GET LENGTH OF DATA
	TAD	(12
	NEGATE
	CDF	0
	DCA I	[T10NWC		/SET WC FOR BLOCK
CRCXI5,	DCA	CRC1		/				########
	DCA	CRC2		/INITIALIZE THE CRC
	TAD I	[T10TKR
	DCA	TEMP1
	CDF	10
	TAD	TEMP1
	DCA	AUTO1
	TAD I	TEMP1
	CDF	0
	SPA CLA
	ISZ I	[GFLG
	CDF	10
	TAD	(SOH
	DCA I	TEMP1
	TAD	(SOH
	JMS	CRCA		/FIRST CHAR IS ALWAYS SOH
	TAD I	AUTO1
	JMS	CRCA		/2ND IS HALF OF LENGTH
	TAD I	AUTO1
	JMS	CRCA		/3RD IS HALF OF LENGTH
	CDF	0
	TAD I	[RECVOK
	JMS	SNDCHR		/4TH IS LAST # RECEIVED
	TAD I	AUTO1		/5TH CHAR IS MESSAGE NUMBER
	JMS	CRCA		/PUT INTO CRC
	CDF	0
	TAD I	[T10TKR
	TAD	(-T10LST
	SNA
	TAD	(T10BF1-T10LST-T10LEN
	JMP	SD1
	PAGE
SD1,	TAD	(T10LEN+T10LST
	DCA I	[T10TKR
	CDF	10
	JMP	SNDAK6		/REST IS LIKE AN ACK
GETC,	0
	CIF	0
	JMS	GETC1
	JMP I	GETC
	ISZ	GETC
	JMP I	GETC
FREC,	0
	CIF	0
	JMP	FRC
FREC1,	JMP I	FREC
DMP1,	0	/HALT MSG FROM FIELD 1
	CDF	0
	DCA I	[DMPAC
	GTF
	AND	(7770		/GENERATE FIELD 1 FOR INST FIELD
	IAC
	DCA I	[DMPLNK
	CAF
	TAD	DMP1
	DCA I	[DMPTRP
	CIF	0
	JMP	DMP2	/GO TO PRINT MESSAGE
NCSBEG,	0		/PUT OUT BEG OF NCS CONTROL MESSAGE
	JMS	NCSBG	/BEGINNING (AC HOLDS NCT)
	JMS	SNDCHR	/ZERO DLA
	JMP I	NCSBEG	/EXIT
NCSBG,	0		/BEGINNING OF NCL MESSAGE MINUS DLA
	JMS	SNDCHR	/PUT NCT (IN AC) INTO MESSAGE
	TAD I	DDB	/GET FIRST WORD OF DDB
	AND	(0077	/CLEAR LEFT HALF
	DCA	TEMPB	/SAVE LINK NUMBER
	TAD	TEMPB	/GET IT
	TAD	(SNATAB-1	/GET DESTINATION NODE ADDR
	DCA	TEMPA		/SAVE ADDR
	TAD I	TEMPA		/GET DNA
	JMS	SNDCHR		/PUT INTO MESSAGE
	Z=OURNNM&177
	TAD	(Z
	JMS	SNDCHR		/SNA
	JMS	SNDCHR		/NCA
	JMS	SNDCHR		/NCN
	JMP I	NCSBG		/RETURN
CRCA,	0
	CR0			/MACRO USED SO CODE ONLY IN ONE PLACE
	JMP I	CRCA
FEAPNT,	0			/SUBROUTINE TO POINT TO FEATURES
	TAD I	DDBSTS		/GET DDB STATUS
	AND	(TTYBIT
	SZA CLA
	JMP	FEA2
	TAD	[DDBSIZ
	TAD	DDB
FEA1,	DCA	TEMP2
	JMP I	FEAPNT
FEA2,	TAD	(LDBWID
	TAD	DDB
	DCA	TEMP3
	TAD I	TEMP3
	DCA	TTYFEA+2
	TAD	(DEVDSL
	TAD	DDB
	DCA	TEMP3
	TAD I	TEMP3
	SPA CLA
	NL1			/MODEM LINE
	TAD	(100		/ADD "CAN SET HOST" BIT [0(13)]
	DCA	TTYFEA+3
	TAD	(TTYFEA
	JMP	FEA1
DISCHK,	0			/CHECK IF A DEVICE CONNECTED DISCONNECT MUST BE SENT
	TAD	(-DEVN		/LOOP CONTROL
	DCA	TEMPD		/ INITIALIZATION
	TAD	(RCVDSP+1	/FIRST ENTRY
	DCA	TEMPC
DISCLP,	TAD I	TEMPC		/GET ENTRY
	SNA CLA			/SKIP UNLESS DISCONNECT REQUIRED
	  JMP	DISSND		/SEND DISCONNECT
	ISZ	TEMPC		/ADVANCE POINTER
	ISZ	TEMPD		/UP COUNTER AND SKIP IF DONE
	  JMP	DISCLP		/CONTINUE
	JMP I	DISCHK		/RETURN TO CALLER
	PAGE
FINMSG,				/END UP MESSAGE
	TAD	CRC2		/GET LOW PART OF CRC
	DCA I	AUTO1
	TAD	CRC1		/GET HIGH PART OF CRC
	DCA I	AUTO1
	CDF	0
	TAD I	[T10PTR
	CDF	10
	DCA	AUTO1
	TAD	TEMP5		/GET SIZE OF MESSAGE
	DCA I	AUTO1		/PUT INTO HEADER
	TAD	TEMP5		/GET MESSAGE SIZE AGAIN
	CLL RTR
	CLL RTR
	CLL RTR
	CLL RTR
	AND	(0017		/ONLY 4 BITS ARE REAL
	DCA I	AUTO1		/PUT REST OF COUNT IN
	ISZ	AUTO1		/SKIP RESPONSE FIELD
	CDF	0
	TAD I	[T10HSN		/GET HIGHEST MESSAGE NUMBER SENT SO FAR
	IAC
	AND	(0377
	DCA I	[T10HSN
	TAD I	[T10HSN
	CDF	10
	DCA I	AUTO1		/PUT MESSAGE NUMBER INTO HEADER
	CDF	0		/ADJUST T10PTR
	TAD I	[T10PTR
	TAD	(-T10LST
	SNA
	TAD	(T10BF1-T10LST-T10LEN	/ADJ IF LAST 
	TAD	(T10LEN+T10LST
	DCA I	[T10PTR
ALP,	CDF	10
	CIF	0
	JMP	LOOP	/RETURN TO FIELD 0 PROCESSING
XSCONF,	TAD I	TEMPB		/GET NODE NO TO TRANSMIT CONF TO
	AND	(7377		/RESET FLAG
	DCA I	TEMPB		/SAVE  IN NEITAB
	TAD I	TEMPB
	AND	(377		/MASK OFF EXTRANEOUS BITS
	CDF	0
	DCA I	[DISSNA		/STORE FOR SUBR USE
	CDF	10
	JMS	XDISBG		/DO START OF MESSAGE
	TAD	(CNF		/POINT TO DATA PART OF MESSAGE
	DCA	TEMPC		/SAVE ADDRESS
	TAD I	TEMPC		/GET COUNT
	IAC			/INCLUDE ITSELF
	NEGATE			/FOR ISZ
	DCA	TEMPB		/LOOP CONTROL
XSCNF1,	TAD I	TEMPC		/GET NEXT CHARACTER
	ISZ	TEMPC		/POINT TO NEXT ONE
	JMS	SNDCHR		/PUT INTO MESSAGE
	ISZ	TEMPB		/CHECK IF DONE
	  JMP	XSCNF1		/NO, CONTINUE
	JMP	FINMSG		/END IT
SNDOBJ,	0			/SEND OBJECT TYPE
	TAD I	DDB		/FIRST WORD OF DDB
	AND	(7700		/CLEAR RIGHT HALF
	BSW
	JMS	SNDCHR		/OBJECT TYPE
	JMP I	SNDOBJ		/RETURN
DISSND,				/SEND DEVICE UNAVAILABLE DISCONNECT
	TAD	TEMPC		/RCVDSP TABLE ENTRY
	TAD	(-RCVDSP-1+SNATAB/POINT TO SNATAB ENTRY
	DCA	TEMP1
	TAD I	TEMP1		/GET DNA
	CDF	0
	DCA I	[DISSNA		/STORE FOR XDISBG
	CDF	10
	DCA I	TEMP1		/CLEAR SNATAB ENTRY
	JMS	XDISBG		/BEGINNING OF DISCONNECT
	TAD	(5		/COUNT
	JMS	SNDCHR
	NL2
	JMS	SNDCHR		/TYPE=DISCONNECT
	TAD	TEMPC		/RCVDSP ENTRY
	TAD	(-RCVDSP-1+SLATAB/SLATAB ENTRY
	DCA	TEMP1
	TAD I	TEMP1		/GET DLA
	JMS	SNDEXN
	JMS	SNDCHR		/SLA=0
	TAD	TEMPC
	TAD	(-RCVDSP-1+MMLTAB/MMLTAB HOLDS REASON
	DCA	TEMP1
	TAD I	TEMP1
	JMS	SNDCHR
	TAD	(RCVKRD		/UNUSED VALUE
	DCA I	TEMPC		/INTO RCVDSP
	JMP	FINMSG
/MUST FIND ROOM IN STATION TABLES IF DEV NEVER BEEN CONNECTED
FNDRM,	CLA
	TAD	(-DEVN
	DCA	TEMP3
	TAD	(RCVDSP+1
	DCA	TEMPA
FNDRM1,	TAD I	TEMPA
	TAD	(-RCVKRD	/LOOK FOR FREE ENTRY
	SNA CLA
	JMP	FNDRM2
	ISZ	TEMPA
	ISZ	TEMP3
	JMP	FNDRM1
	JMP	XSTRT1	/NO ROOM
	PAGE
XDRQ,	0
	NLOAD	DEVCHK		/POINT TO CHUNK COUNT
	TAD	DDB
	DCA	TEMP3
	TAD I	TEMP3		/GET CHUNK COUNT
	SMA CLA			/ONLY SEND DATA REQUEST IF MINUS
	  JMP I	XDRQ		/RETURN
	NLOAD	DEVDRQ		/ADDRESS OF DATA REQUEST COUNT WITHIN  DDB
	TAD	DDB		/DDB ADDRESS
	DCA	TEMP3		/STORE
	TAD I	TEMP3		/GET DATA REQ SENT
	NEGATE
	TAD	(DRQCT		/GET MAX ALLOWED
	SPA SNA		
	JMP I	XDRQ	/NO DATA REQUEST TO SEND
	DCA	TEMP2		/SAVE NO. OF DATA REQ TO SEND
	TAD	(DRQCT		/SET TO MAX NO.
	DCA I	TEMP3
	JMS	XSTMSG
	TAD	(50		/INTERRUPT NCT
	JMS	NCSBEG		/BEGINNING OF MESSAGE
	NL4			/COUNT ASSUMES DLA IS 2 BYTE FIELD
	JMS	SNDCHR		/COUNT
	NL6			/DATA REQUEST
	JMS	SNDCHR		/TYPE
	JMS	NCSDLA		/DLA
	TAD	TEMP2		/GET NO. OF DATA REQUESTS TO SEND
	JMS	SNDCHR		/DRQ
	JMP	FINMSG

XSDIS0,	JMS	XSTMSG
	TAD	(50
	JMS	NCSBEG
	TAD	(5
	JMS	SNDCHR		/COUNT
	NL2
	JMS	SNDCHR		/TYPE=DISCONNECT
	JMS	NCSDLA		/DLA
	TAD	TEMPB
	JMS	SNDCHR		/SLA
	JMS	SNDCHR		/REASON=0
	TAD	(DEVRCN
	TAD	DDB
	DCA	TEMPA
	TAD I	TEMPA		/SEE  IF HAVE TO ISSUE CON AFTER DIS
	SZA CLA			/SKIP IF NOT
	JMP	XSD1
	TAD	TEMPB		/INDEX
	TAD	(RCVDSP
	DCA	TEMPB
	TAD	(RCVKRD
	DCA I	TEMPB
	TAD	(6577		/ALL EXCEPT ACCEPT BIT AND "NEED CHARAC-
				/TERISTICS" BITS [1(14)]
	AND I	DDBSTS		/GET REST OF STATUS BITS
	DCA I	DDBSTS		/STORE THEM BACK
	TAD I	DDB		/[1(23)] GET DDB CONTENTS
	AND	(7700		/[1(23)] CLEAR CONNECT NUMBER
	DCA I	DDB		/[1(23)] STORE BACK IN DDB
	JMP	FINMSG
XSTRT3,	TAD	(DEVBF1
	TAD	DDB
	DCA	TEMP4
	TAD I	TEMP4
	SNA
IFNZRO CDRN<JMP XCDRCK>
IFZERO CDRN<JMP XSTRT7>		/CHECK TO SEE IF THIS IS THE CDR
	CDF	0		/WANT TO SET UP TEMP3 FOR GETCHR CALL IN FIELD 0
	DCA I	[TEMP3
	CDF	10
	JMS	XSTMSG		/SET UP TO SEND A MESSAGE
	TAD	(10		/NCT
	JMS	NCSBG		/BEGINNING MINUS DLA
	JMS	NCSDLA		/DLA
	SKP
	JMS	SNDCHR		/PUT IN MESSAGE
	JMS	GETC		/FIELD 1 CALL TO GETCH
	SKP
	JMP	.-3		/CONTINUE
	TAD I	TEMP4		/GET CHUNK STRING ADDRESS AGAIN
	JMS	FREC		/FIELD 1 CALL TO FRECKS
	DCA I	TEMP4
	JMP	FINMSG		/FINISH OFF MESSAGE
XDISBG,	0			/SUBR TO BEGIN DISCON OR CONF
	JMS	XSTMSG		/START OF DISCONNECT
	TAD	(10		/MAKE NCT
	JMS	SNDCHR		/NCT
	CDF	0
	TAD I	[DISSNA
	JMS	SNDCHR		/DNA
	Z=OURNNM&177
	TAD	(Z
	JMS	SNDCHR		/SNA
	JMS	SNDCHR		/NCA
	JMS	SNDCHR		/NCN
	JMS	SNDCHR		/DLA
	JMP I	XDISBG		/RETURN
IFNZRO CDRN<
XCDRCK,	TAD	DDB		/GET THE DDB AGAIN
	TAD	(-CDRBLK	/SEE IF CDR
	SZA CLA			/SKIP IF CDR
	  JMP	XSTRT7		/NOT CDR.  SEE IF NEED TO SEND STATUS
	TAD	(CDRBLK+DEVBF2	/GET SECOND BUFFER ADDRESS
	DCA	TEMP4
	TAD I	TEMP4
	SNA CLA			/NONZERO MEANS CARDS ARE WAITING
	  JMP	XSTRT7		/NO CARDS WAITING.  SEE IF WE NEED TO SEND STATUS
	JMP	XSTRT1		/CARDS ARE WAITING SO LET CLOCK LEVEL SET UP BUFFERS
>/END OF IFNZRO CDRN
	PAGE
/ROUTINE CHECKS TO  SEE IF ANY STATION CONTROL MESSAGES ARE PENDING
/
/
XMBT,	0
	NL0
	TAD	(BTTAB-GTLEN	/SET UP POINTERS TO CHECK TABLE
	DCA	TEMPB
XMBT2,	TAD	(GTLEN
	TAD	TEMPB
	DCA	TEMPB
	TAD I	TEMPB
	SZA
	JMP	XMBTS		/TRANSMISSION NEEDED
	TAD	(-BTEND		/CHECK FOR END OF TABLE
	TAD	TEMPB
	SZA CLA			/DONE
	JMP	XMBT2		/CONTINUE SCAN OF TABLE
	TAD	(GTTAB
	DCA	TEMPB		/CHECK FOR GOTOS
	TAD I	TEMPB
	SNA CLA
	JMP I	XMBT		/NO MSGS TO XMIT
XMBTS,	CDF	0
	DCA I	[DISSNA		/SET UP DNA FOR NCL MESSAGE
	CDF	10
	DCA I	TEMPB		/ZERO TABLE ENTRY IN BTTAB
	JMS	XDISBG		/SET UP BEG OF MSG THRU DLA OF 0
	ISZ	TEMPB
	TAD I	TEMPB		/GET TYPE OF STATION CTRL TO BE SENT
	TAD	(-13		/CHECK FOR REJECT
	SNA CLA
	JMP	XRJT		/TRANSMIT REJECT MESSAGE
	TAD I	TEMPB
	AND	(4
	SZA CLA			/4 BIT ON MEANS GOTO ACCEPT
	JMP	XGTO1
/EX DATA AND ACCEPT DEPOSIT THE SAME
/COUNT=5+DATA WORDS,COUNT SENT AS AN EXT FIELD
	NL1
	TAD	TEMPB
	DCA	TEMPA		/CALCULATE DATA COUNT
	TAD I	TEMPA
	NEGATE
	ISZ	TEMPA
	ISZ	TEMPA
	TAD I	TEMPA		/ASSUMES ADR1<ADR2, FRIEND!
	SPA
	JMP	RRJ	/TOO LARGE COUNT
	CLL RAL	/MULTIPLY BY 2
	TAD	(5
	DCA	BTCT
	Z=T10LEN-22	/8 DDCMP,8 NCL ,2 COUNT
	TAD	(-Z-1
	TAD	BTCT
	SMA CLA		/COUNT TOO LARGE
	JMP	RRJ	/ISSUE REJECT
	TAD	BTCT
	JMS	XRTE	/COUNT,STAT CTRL,DNA,TYPE
	JMS	XADR	/SHIP ADDRESS
	NLM1
	TAD	TEMPB
	DCA	TEMPB
	TAD I	TEMPB
	DCA	XAR1
	ISZ	TEMPB
	TAD I	TEMPB
	DCA	XFR1		/FIELD SPECIFIED
	ISZ	TEMPB
	TAD I	TEMPB	/ADDRESS
	DCA	XAR2
	ISZ	TEMPB
	TAD I	TEMPB
	DCA	XFR2
XFR1,	0		/CHANGE DATA FIELD
	TAD I	XAR1
	CDF	10
	DCA	XBTSV
	TAD	XBTSV
	AND	(77
	JMS	SNDCHR
	TAD	XBTSV
	BSW
	AND	(77
	JMS	SNDCHR
	ISZ	XAR1	/BUMP ADDRESS
	JMP	XCHK	/CHECK FOR END
	TAD	XFR1
	TAD	(10	/BUMP TO NEXT FIELD
	AND	(7277	/ASSUMES FIELD 7 BUMPS TO FIELD 0
	DCA	XFR1
XCHK,	TAD	XAR1
	NEGATE
	TAD	XAR2
	SZA CLA
	JMP	XFR1	/CONTINUE
	TAD	XFR1
	NEGATE
	TAD	XFR2
	SZA CLA
	JMP	XFR1
	JMP	FINMSG
XBTSV,	0
XAR2,	0
BTCT,	0
XAR1,	0
XFR2,	0
XMTCHR,	0			/SEND A CHARACTERISTICS MESSAGE  [1(14)]
	TAD	(CHRBIT		/GET "NEED TO SEND CHARACTERISTICS" BIT  [1(14)]
	AND I	DDBSTS		/CLEAR REST  [1(14)]
	SNA CLA			/SKIP IF IT WAS ON  [1(14)]
XMTCRT,	  JMP I	XMTCHR		/RETURN TO CALLER IF NOT  [1(14)]
	JMP	XMTCR1		/GO TO CONTINUATION  [1(14)]
	PAGE
/TRANSMIT A GOTO
XGTO1,	TAD	(5
	JMS	XRTE	/SET UP COUNT,STA CTRL,DNA,TTYPE
	JMS	XADR	/GET ADDRESS
	CDF	0
	TAD I	[T10PTR
	CDF	10
	DCA	TEMPA
	NL4000		/FLAG TO SIGNAL SNDMSG GOO BEING XMTED
	TAD I	TEMPA
	DCA I	TEMPA
	JMP	FINMSG
/TRANSMIT A REJECT
RRJ,	TAD	(13
	DCA I	TEMPB
XRJT,	NL3		/COUNT IS 3
	JMS	XRTE	/COUNT STAT CTL,DNA,TYPE
	JMP	FINMSG
/COMMON ROUTINE TO SET UP COUNT,STATION CTRL,DNA,TYPE
/
XRTE,	0
	JMS	SNDEXN	/AC HAS COUNT ALWAYS EXT
	TAD	(7	/STATION CTRL
	JMS	SNDCHR
	NL0		/SET TO ZERO FOR SELF
	JMS	SNDCHR
	TAD I	TEMPB	/TYPE
	AND	(13
	JMS	SNDCHR
	JMP I	XRTE
/GET ADDRESS FROM TABLE TO MESSAGE
/
XADR,	0
	ISZ	TEMPB
	TAD	(377
	AND I	TEMPB
	JMS	SNDCHR	/SEND LOW ORDER BITS
	TAD	(7400
	AND I	TEMPB
	BSW
	CLL RTR		/INSERT 4 HIGH ORDER BITS
	DCA	TEMPA	/SAVE IT
	ISZ	TEMPB
	TAD	(70	/GET FIELD DESIGNATOR
	AND I	TEMPB
	CLL RAL
	TAD	TEMPA
	JMS	SNDCHR
	JMP I	XADR
XSTRT2,	TAD I	DDBSTS
	AND	(OUTBIT+TTYBIT	/MASK FOR OUTPUT DEVICES
	SNA			/SKIP IF EITHER OUTPUT OR TTY
	  JMP	XSTRT3		/NEITHER, SEE IF MESSAGE TO BE SENT
	AND	(TTYBIT		/SEE IF TTY
	SZA CLA			/SKIP IF NOT (I.E. OUTPUT)
	  JMP	XSTRT4		/DEVICE IS A TTY SO DO TTY STUFF
	JMS	XDRQ		/SEND DATA REQUEST IF NECESSARY
	JMP	XSTRT7		/WON'T RETURN IF DATA REQUEST SENT
	EXFLD=1		/EXEC IN FIELD 1
	FIELDS=4
IFNZRO	DP8ETR <EIELDS=4>

ALPWD,	0
ALPCT,	0
DMPALP,	0
	RDF			/GET DATA FIELD
	TAD	(CDF		/CONVERT TO INSTRUCTION
	DCA	DMPAL2		/STASH
	TAD	DMPAL2		/GET IT AGAIN
	DCA	ALPFLD		/STORE IN ALP SUBROUTINE
	QQ=EXFLD^10
	CDF+QQ		/SET TO FIELD IN WHICH CODE RESIDES
	TAD	DMPWAD		/GET CURRENT ADDRESS
	SNA			/TEST FOR 0
	  JMP	DMPAL2		/ZERO, SO JUST DO CRLF
	TAD	(-1
	JMS	ALP1
DMPAL2,	0			/WILL CHANGE DATA FIELD
	JMS	DMPCRL
	JMP I	DMPALP
ALP1,	0
	AND	(7760
	DCA	ALPWD
ALPFLD,	0			/WILL CHANGE DATA FIELD
	JMS	DMPSP
	JMS	DMPSP
	TAD	(-20
	DCA	ALPCT
ALPL,	TAD I	ALPWD
	AND	(3577		/TURN OFF SIGN AND EXTENSIBLE BITS
	TAD	(-40
	SMA CLA
	  JMP	ALPL1
ALPBL,	TAD	(56
	JMP	ALPLP
ALPL1,	TAD I	ALPWD
	AND	(3577
	TAD	(-141
	SMA CLA
	  JMP	ALPBL
	TAD I	ALPWD
	AND	(3577
ALPLP,	JMS	DMP
	ISZ	ALPWD
	NOP
	ISZ	ALPCT
	  JMP	ALPL
	JMS	DMPSP
	JMP I	ALP1
	PAGE
DUMPI,				/START OF DUMP
	IOF
	CLA
DMP000,	DCA	DMPWAD		/START BY DUMPING WORD 0
	DCA	DMPFLD
	JMP	DMPPAG
DMP010,	TAD	DMPFLD
	CLL RTL
	RAL
	TAD	(CDF
	DCA	.+1
	0
DMPLOP,
	IFNZRO LPTN <
	AND	(0017		/CR AFTER EVERY 20 WORDS
>/END OF IFNZRO LPTN
	IFZERO LPTN <
	AND	(0007		/CR AFTER EVERY 10 WORDS
>/END OF IFZERO LPTN
	SZA
	  JMP	DMPLP3

IFZERO LPTN <
DMPLP1,	TAD I	DMPWAD		/GET NEXT WORD
	SZA CLA
	  JMP	DMPLP2
	ISZ	DMPWAD
	  JMP	DMPLP1
	JMP	DMPINC		/ALL DONE WITH INCE
DMPLP2,	TAD	DMPWAD
	AND	(7770
	DCA	DMPWAD
>/END OF IFZERO LPTN

	JMS I	(DMPALP
	TAD	DMPWAD
	AND	(0177		/SKIP EXTRA LINE EVERY 100 WORDS
	SNA CLA
	  JMS	DMPCRL
IFNZRO LPTN < JMS	DMPTAB > /TAB IN CASE RIBBON SKEWED
	TAD	DMPFLD
	TAD	(0060
	JMS	DMP
	TAD	DMPWAD		/ADR OF WORD BEING DUMPED
	JMS	DMPWDO
DMPLP3,	AND	(0007
	SNA CLA
	  JMS	DMPTAB
	TAD I	DMPWAD		/GET NEXT WORD TO DUMP
	JMS	DMPWDO
	JMS	DMPSP
	ISZ	DMPWAD
	TAD	DMPWAD
	SZA			/WAS THAT LAST WORD IN FIELD ?
	  JMP	DMPLOP
DMPINC,	ISZ	DMPFLD		/ADVANCE FIELD
DMPPAG,	TAD	(0015		/CARRIAGE RETURN
	JMS	DMP
	TAD	(0014		/FORM FEED
	JMS	DMP
DMPTRC,	TAD	(-FIELDS	/NEG NO OF FIELDS TO DUMP
	TAD	DMPFLD
	SMA CLA
	JMP	DONE
	JMP	DMP010
DMPWDO,	0
	DCA	DMPWR		/SAVE WORD TO DUMP
	JMS	DMPWD
	JMS	DMPWD
	JMS	DMPWD
	JMS	DMPWD
	JMP I	DMPWDO
DMPWD,	0
	TAD	DMPWR
	RTL
	RAL
	DCA	DMPWR
	TAD	DMPWR
	RAL
	AND	(0007
	TAD	(0060
	JMS	DMP
	JMP I	DMPWD
DMPTAB,	0
IFNZRO LPTN <
	JMS	DMPSP
	JMS	DMPSP
>/END OF IFNZRO LPTN
	JMS	DMPSP
	JMS	DMPSP
	JMP I	DMPTAB
DMPSP,	0			/HERE TO PRINT A SPACE
	TAD	(0040
	JMS	DMP
	JMP I	DMPSP
DMPCRL,	0
	TAD	(0015		/CARRIAGE RETURN
	JMS	DMP
	TAD	(0012		/LINE FEED
	JMS	DMP
	TAD	(0012
	JMS	DMP
	JMP I	DMPCRL

IFNZRO LPTN <
DMP,	0
IFNDEF LA180 <
	LPTSTB
	LPTSKF			/WAIT FOR LPT
>/END OF IFNDEF  LA180
IFDEF LA180 <
	CMA
	DBTD	/TRANSMIT DATA
	PBST	/SKIP WHEN DONE
>/END OF IFDEF LA180
	JMP	.-1
	NLOAD	0
	JMP I	DMP
>/END OF IFNZRO LPTN

DMPFLD,	0			/FIELD TO DUMP
DMPWAD,	0			/ADR OF CURRENT WORD BEING DUMPED
DMPWR,	0
IFZERO LPTN <
DMP,	0
	CTYTLS
	CTYTSF
	JMP	.-1
	NLOAD	0
	JMP I	DMP
>/END OF IFZERO LPTN
DONE,	CIF	0
	JMP	INIALL	/RESTART SOFTWARE
FNDRM2,	NL1			/GET ANY OLD CRUD VALUE [1(15)]
	DCA I	TEMPA		/AND STORE IT IN THE SLOT TO RESERVE IT [1(15)]
	TAD	TEMPA
	TAD	(-RCVDSP
	DCA	TEMPA
	TAD I	DDB
	AND	(7700
	TAD	TEMPA
	DCA I	DDB
	JMP	FNDRM4
	FIELD 2
DEFINE HLT <7402>
CHK1=1
CHK2=2
CHK3=3
CHK4=4
CHK5=5
CHK6=6
CHK7=7
CHAUTO=17
*20
RCVQUE,
ZZ=CTLSIZ^10
	BLOCK	ZZ
RCVLIM,
	ZZ=RCVQUE
	ZZ=RCVLIM
	Z=.+CNKSIZ-1
	ZZ=-CNKSIZ
*Z&ZZ
/	***********************************************************
/	***********************************************************
/	***							***
/	***		SYSCHK - ONCE ONLY SYSTEM DIAGNOSTIC	***
/	***							***
/	***********************************************************
/	***********************************************************

/ONCE ONLY SYSTEM ANALYZER
/ CODE IS OVERWRITTEN BY CHUNKS SO CAN ONLY BE EXECUTED ONCE

FIRCNK,	0
*100	/ORIGIN FOR PAGE 0 LIT USED BY SYSCHK
FLG,	0
CHKST1,	0

CHKST2,	0
CHOCNT,	0
T10LCA,	0
INISEC,	0
	0
	PAGE
SYSCHK,	SKP			/TRY TO SKIP
	  7402			/IT DIDN'T WORK ? ! ?
	NL0			/ZERO AC
	SZA			/SKIP IF AC IS ZERO
	  7402			/HARDWARE FAILURE
	SPA			/SKIP IF AC IS POSITIVE
	  7402			/HARDWARE FAILURE
	SMA			/SKIP IF AC IS NEGATIVE
	  SKP			/SHOULDN'T HAVE SKIPPED SO OK
	  7402			/HARDWARE FAILURE
	NL1			/PUT 1 IN AC
	SNA			/BE SURE AC IS NON ZERO
	  7402

	BSW			/IF AN 8E SWAP HALVES
	TAD	(7700
	SNA CLA
	  JMP	SCHK00		/CODE IS FOR RIGHT MACHINE
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INLTYP		/TRYING TO RUN 8I CODE ON AN 8E(OR VICE VERSA)
	DC7MSG
	" ;"W;"O;"N;47;"T;" ;"R;"U;"N;" ;"O;"N;" ;"A;" ;"P;"D;"P;"8
	4000+"I
	HLT			/RETURNS HERE AFTER TYPEING MESSAGE
	JMP	SYSCHK		/IF OPERATOR CONTINUES TEST AGAIN
SCHK00,	JMS	INLTYP
	15;15;207;12;377
	"[;"I;"N;"I;"T;"I;"A;"L;"I;"Z;"I;"N;"G
	" ;
IFNZRO FTLBACK < "L;"O;"O;"B;"A;"C;"K;" ;"T;"E;"S;"T;"  >
IFZERO FTLBACK < DC7MSG >
	" ;4366
	CDFINS			/PICK UP WORD FROM INSTRUCTION FIELD
	TAD I	(203		/GET VERSION NUMBER
	DCA	CHK1		/SAVE IT
	CDFCNK
	TAD	CHK1		/GET VERSION
	AND	(7700
	CLL RTR
	RTR
	RTR
	JMS	INIOCT
	JMS	INLTYP
	"(+4000
	TAD	CHK1
	AND	(0077
	JMS	INIOCT		/TYPE VERSION NUMBER
	JMS	INLTYP

	");" ;"N;"O;"D;"E
	240			/BLANK
	42
IFDEF DC92ID <
	DC92ID
>/END OF IFDEF DC92ID
IFNDEF	DC92ID	<
	"D;"N;"9;"2
>/END OF IFNDEF	DC92ID
	4042
	JMS	INLTYP
	"];15;15;12;4012
	JMP	SCHK01


	PAGE
SCHK01,	CAF	/CLEAR ALL FLAGS

/HERE TO CHECK SYSTEM CLOCK IS PRESENT AND ACCURATE
	NL1			/RESET THE CLOCK
	CLKECI			/RESET THE CLOCK
	JMS	SCHK02		/GO GET 1ST TICK
	CLKSCF			/AND THERE SHOULD NOT BE ANOTHER FLAG UP YET
	  SKP			/OK IT WASN'T UP AGAIN
	JMP	SCHK03		/IT DID COME UP AGAIN ??

/ASSUME LINE FREQUENCY IS 50CYCLE
	TAD (-5153-240 	/5153 = 2667. (LOOP = 7.5)
	JMS	SCHK02		/TIME TICK
	TAD	CHK1
	SMA			/BE SURE IT ALMOST TOOK UP ALL OF TIME
	  JMP	SCHK03		/NO WHERE NEAR RIGHT
	TAD	(500
	SMA CLA			/IS THIS IN RANGE FOR 50 CYCLE ?
	  JMP	SCHK04		/YES
	JMP	SCHK03

/HERE TO WAIT FOR A CLOCK TICK
/ LOOP TAKES 10.25US ON PDP8I
/ LOOP TAKES 6.2US ON A PDP8E
SCHK02,	0
	DCA	CHK1		/SAVE MAX COUNT

			/TIME TWO TICKS FOR PDP8A
	CLKSCF			/(1.2US)IS CLOCK FLAG UP ?
	  SKP			/(1.2US) NO
	JMP	.+4		/HAVE SEEN ONE CLOCK TICK
	ISZ	CHK1		/(2.6US)
	  JMP	.-4		/(1.2US)KEEP WAITING FOR CLOCK
	JMP	SCHK03		/TIMED OUT ON FIRST TICK !?!
	CLCL

WT,	CLKSCF			/(1.2 OR 4.25US)IS CLOCK FLAG UP ?
	JMP	.+3
	CLCL
	JMP I	SCHK02		/HAVE SEEN ONE CLOCK TICK
	ISZ	CHK1		/(2.6 OR 3.0US)
	  JMP	WT		/(1.2 OR 1.5US)KEEP WAITING FOR CLOCK

/HERE WHEN CLOCK IS MISBEHAVING
SCHK03,	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INLTYP
	"D;"K;"C;"8;" ;"C;"L;"O;"C;"K;
	" ;"E;"R;"R;"O;"R;215;4012
	HLT
	JMP	SCHK01		/TRY AGAIN IF HE INSISTS

HERTZF,	6			/NONZERO MEANS RUNNING ON 50 CYCLE
/MEMORY PARITY CHECK

SCHK04,

/HERE TO SEE IF MEMORY PARITY OPTION IS PRESENT
/ NOT NECESSARY ON PDP8A'S

	JMP	SCHK06

SCHK05,	0
/HERE TO SEE HOW MUCH MEMORY IS PRESENT
/ ADJUST DISMAX, DISCDF AND TRACE CODE ACCORDINGLY

SCHK06,	TAD	(177
	CDF	30		/BUGGER PAGE 0 FIELD 3 LOC
IFNZRO FTDEBUG <	DCA I	(BUG		>/INITIALIZE BUGGER FOR TRACE
IFZERO FTEDEBUG < CLL CLA >	/CLEAR AC FOR NEXT INSTR
	DCA I	(DISMAX		/INITIALIZE MAX FIELD WE HAVE
SCHK07,	TAD I	(DISMAX
	CLL RAL
	CLL RTL
	TAD	(CDF
	DCA	.+1
	CDFINS
	TAD	(7402		/BIT PATTERN TO STORE INTO FIELD
	DCA I	(0		/AND STORE IN MEMORY
	TAD	(-7402
	TAD I	(0		/WILL LEAVE 0 IF THERE BANK PRESENT
	CDF	30
	SZA CLA			/IS THIS MEMORY BANK THERE ?
	  JMP	SCHK08		/NO
	ISZ	I (DISMAX
	TAD I	(DISMAX
	TAD	(-10
	SZA CLA
	JMP	SCHK07
SCHK08,	TAD I	(DISMAX
	NEGATE
	TAD	(0010
	DCA I	(DISMIN

	JMP	SCHK10	/TEST TTY LINES

	PAGE
SCHK10,
	LISTOG	TTYN
IFNZRO TTYN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		SYSCHK FOR TTY LINES			***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO CHECK TTYS ARE REASONABLE
/ FIRST CHECK THAT CHAR OUTPUT DOES NOT RAISE FLAG IMMEDIATELY
/ AND THAT IT DOES RAISE FLAG A REASONABLE AMOUNT OF TIME

	CDFCNK

/NECESSARY TO INITIALIZE TRANSMIT/RECEIVE SERVICE ADDRESS
/IF KL8A IS USED FOR TTY LINES.
	ZZ=TTYN
	NL0
	TAD	(KL8AS
	IFNZRO ZZ <
	ZZ=ZZ-4
	MCCD	/INIT FIRST KL8A
	MSLB	/SET UP ADDRESS
	>/END OF IFNZRO ZZ
	IFNZRO ZZ <
	ZZ=ZZ-4
	MCCD1
	MSLB1	>/END OF IFNZRO ZZ
	IFNZRO ZZ <
	ZZ=ZZ-4
	MCCD2
	MSLB2	>/END OF KL8A2
	IFNZRO ZZ <
	ZZ=ZZ-4
	MCCD3
	MSLB3	>/KL8A#3
	NL0
	DCA	CHK1		/START WITH TTY0
SCHK11,	CDFCNK			/SET TO CHUNK DATAFIELD
	TAD	CHK1
	TAD	(DDBTAB+1
	DCA	CHK2
	TAD I	CHK2		/GET ADR OF DEVICE BLOCK
	TAD	[LDBADR		/POINT TO DEVICE ADDRESS WORD
	DCA	CHK2		/SAVE ADR OF WORD WITH DEVICE ADR
	TAD	(-15		/GIVE TTY .208 SEC TO XMT FLAG
	DCA	INISEC
	DCA	CHK5		/SET NONZERO TO FLAG LINE IS RUNNING OPEN

	TAD	(207		/ASCII BELL


/HERE TO TYPE A CHAR
	DCA	CHK3		/SAVE CHAR
	TAD I	CHK2		/GET TLS FOR LINE
/KL8A PROCESSING
	AND	(7774	/GENERATE INSTR FOR TRANSMISSION
	DCA	INST
	NLM2		/GENERATE A READ STATUS INSTR
	TAD	INST
	DCA	INST2
	TAD I	CHK2	/GET LINE #
	AND	(3
	BSW
	CLL RTL		/PUT INTO HIGH ORDER BITS
	TAD	CHK3	/INCLUDE CHAR
INST,	0
	NL0
INST2,	0	/READ STATUS
	AND	(4	/TRANSMIT FLAG SET ALREADY?
	SZA CLA		/NO THAT IS AS IT SHOULD BE
	JMP	SCHK29	/MUCH TOO FAST
SCHK12,	JMS	SCHK17		/SEE IF LINE HAS XMT INTERRUPTED YET
	  JMP	SCHK20		/IT HAS

SCHK13,	JMS	SCHK98		/HAVE WE WAITED TOO LONG ?
	  JMP	SCHK12		/NO KEEP WAITING
	JMS	SCHK28		/GIVE TTY ID
	JMS	INLTYP
	"N;"O;" ;"X;"M;"T;" ;"F;"L;"A;4000+"G
	JMP	SCHK22
SCHK20,	JMS	SCHK17
	JMP	.+2

	  JMP	SCHK21		/NONE
	TAD	FLG
	SNA CLA
	JMP	SCHK20
SCHK18,	TAD	CHK3	/GET CHAR IF RCV INTERRUPT
	SNA			/IS IT NULL
	  ISZ	CHK5		/YES
	TAD	(-207
	SNA CLA			/IS TTY IN LOOPBACK MODE ?
	  JMP	SCHK26		/YES SO TELL OPERATOR
SCHK21,	JMS	SCHK98		/CHECK CLOCK
	  JMP	SCHK20		/ KEEP WAITING TO TEST FOR LOOP BACK MODE
SCHK22,	NL0
	JMS	SCHK17		/CLEAR XMT FLAG IF UP
	  NOP
	TAD	CHK5		/IS LINE RUNNING OPEN ?
	SNA CLA
	  JMP	SCHK23		/NOT RUNNING OPEN
	JMS	SCHK28		/TYPE TTY LINE #
	TAD	(ERR23-1
	JMS	INITYP

SCHK23,	ISZ	CHK1		/ADVANCE TO NEXT TTY #
	TAD	CHK1		/GET NEW LINE #
	TAD	(-TTYN
	SZA CLA			/HAVE WE DONE ALL OF THE LINES ?
	  JMP	SCHK11		/GO DO NEXT TTY LINE
	JMP	SCHK30


	PAGE

/HERE TO SEE IF TTY HAS XMT INTERRUPTED
SCHK17,	0
SCHKC,	TAD I	CHK2		/GET THE TLS INSTRUCTION
	AND	(7770	/MASK TO MAKE MSAB TO JUMP TO ADDRESS
	IAC
	DCA	.+1
	0
	ISZ	SCHK17		/NORMAL(I.E. SKIP) RETURN
	JMP I	SCHK17

/HERE WHEN TTY IS APPARENTLY IN LOOP BACK MODE
SCHK26,	JMS	SCHK28		/TYPE TTYP#
	JMS	INLTYP
	"I;"S;" ;"I;"N;" ;"L;"O;"O;"P;"B;"A;"C;"K;" ;"M;"O;"D;4000+"E
	HLT
	JMP	SCHK23		/WE ARE DONE WITH THIS LINE


/HERE TO TYPE TTY IDENTIFICATION
SCHK28,	0
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INLTYP
	"T;"T;4000+"Y
	TAD	CHK1		/GET LINE NUMBER
	JMS	INIOCT		/TYPE OCTAL NUMBER
	JMS	INLTYP
	4240			/SPACE
	JMP I	SCHK28

SCHK29,
	TAD	FLG
	SZA CLA
	JMP	SCHK12	/END OF IFDEF BA892
	JMS	SCHK28		/TYPE TTY NAME
	JMS	INLTYP
	"X;"M;"T;4240
	JMS	SCHK93		/TYPE "FLAG WON'T CLEAR"
	HLT
	JMP	SCHK10		/REDO SYSCHK FOR TTY'S

SCHK24,	JMS	SCHK28		/TYPE TTY ID
	JMS	INLTYP
	"R;"C;"V;4240
	JMS	SCHK93		/TYPE "FLAG WON'T CLEAR
	HLT
	JMP	SCHK10		/TRY AGAIN IF HE INSISTS


KL8AT,	0
	AND	(3	/SAVE LINE THAT CAUSE JUMP
	NEGATE
	DCA	TM	/LINE NO FOR TRANSMIT
	DCA	FLG
SCHKS,	TAD I	CHK2
	AND	(3	/GET LINE NO
	TAD	TM
	SZA CLA		/IF SAME TRANSMIT DONE
	ISZ	SCHK17	/NO TRANS FOR LINE YET
	JMP I	SCHK17
KL8AR,	0
	AND	(3
	NEGATE
	DCA	TM
	NLM1	/NONZERO MEANS REC CHAR FLAG, 0 FOR XMT
	DCA	FLG
	TAD I	CHK2
	AND	(7770
	TAD	(5
	DCA	.+1
	0
	AND	(377
	DCA	CHK3
		JMP	SCHKS
TM,	0
	PAGE
>/END OF IFNZRO TTYN
	LISTOG	TTYN
/	***********************************************************
/	***********************************************************
/	***							***
/	***	SYSCHK FOR SYNCHRONOUS INTERFACET		***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO CHECK SYNCHRONOUS INTERFACE
/ CHK6 IS A FLAG FOR XMT TEST
/ CHK5 IS A FLAG FOR ANY CHAR RECEIVED
/ CHK4 IS A FLAG FOR NONSYNCH RECEIVED TEST

CHKDPT=200		/TIME FOR SYNCHRONOUS INTERFACE TO COME ALIVE
			/ APP 2 SECONDS

	SKP
	HLT

SCHK30,	CDFCNK			/SET RIGHT DATA FIELD
	JMS	SCHKA1		/INITIALIZE BUFFERS
	NLM1
	DCA	CHK6		/FLAG 1ST TIME THROUGH XMT TEST
	TAD	(0020
	DCA	CHKST1		/INITIAL STS1
	TAD	(5400
	DCA	CHKST2		/INITIAL STS2

	CDFINS
	TAD	(F10TCH-1	/POINTER TO TEST CHARS
	DCA	AUTO1
	DCA I	AUTO1
	DCA I	AUTO1
	DCA I	AUTO1
	TAD	(SYN
	DCA I	AUTO1
	CDFCNK

SCHK31,	NLM1
	DCA	CHK5		/FLAG FIRST TIME THROUGH BASIC REC TEST
	NLM1
	DCA	CHK4
SCHK32,
	DPSCSI			/CLEAR SYNCHRONOUS INTERFACE
	TAD	(5400		/TERMINAL READY; INTERFACE ENABLE; TRANS REQ
	DPSLCC			/SET INITIAL CONDITIONS
	NL0
	Z=2100	/RECEIVE FIELD=2,TRANSMIT FIELD=1
	TAD	(Z
	DPSLFL
	NL0

	CDFINS
	TAD	(SYNBUF-1
	DCA I	(T10CA		/SET UP BUFFER TO SEND SYNCHS
	TAD	(-4
	DCA I	(T10WC		/SET UP WC TO SEND SYNCHS
	DCA I	(T10NCA		/SEND SYNCH'S WHEN DONE
	CDFCNK
	DCA	CHOCNT		/NO CHARS SEND YET
	TAD	(-SYNBUF-3
	DCA	T10LCA
	DPSGTT		/ENABLE DP8E TRANSMITTER
	JMS	SCHK77		/ENABLE RECEIVER

	TAD	(-CHKDPT
	DCA	INISEC		/TIME FOR INTERFACE TO COME ALIVE

SCHK33,

	Z=CNKFLD^40
	DPSRS1			/GET TRANSMIT FIELD SELECT
	AND	(0340
	TAD	(-Z
	SZA			/IS IT OK ?
	  JMS	SCHK39
	DPSRS2			/GET RECEIVE FIELD SELECT
	AND	(0340
	Z=100	/RECEIVE FIELD =2
	TAD	(-Z
	SZA			/IS IT OK ?
	  JMS	SCHK39

	DPSRS1			/GET STATUS 1
	AND	(0020		/MASK FOR MODEM READY
	SNA CLA
	  JMP	SCHK35

	DPSRS2
	AND	(5400		/MASK FOR TERMINAL READY,CARRIER, &CLEAR TO SEND
	TAD	(-5400
	SZA CLA
	  JMP	SCHK35		/WAIT A WHILE

	JMS	SCHK75
	NOP
	NL0			/CHECK RECEIVER
	JMS	SCHK66		/SERVICE TRANSMITTER
	TAD	CHOCNT
	TAD	(40		/SEE HOW MANY CHARS SENT
	SPA CLA
	  JMP	SCHK40		/BRANCH IF XMTTER GOING
SCHK35,	JMS	SCHK98		/SEE IF CLOCK HAS TIMED OUT
	  JMP	SCHK33		/NOT YET

/HERE IF TIMER GOES OFF WHILE TRYING TO INITIALIZE DP01 OR DP8E
	NL0

	DPSRS1
	AND	(0020
	NEGATE			/GET MODEM READY BIT
	TAD	CHKST1
	SZA CLA
	  JMP	SCHK36		/IF STATUS CHANGED DISPLAY IT
	DPSRS2
	AND	(5400
	NEGATE			/GET STS2 BITS
	TAD	CHKST2
	SZA CLA	
	JMP	SCHK36
	TAD	CHKST1
	SNA CLA	
	JMP	SCHK31		/KEEP ONWAITING
	TAD	CHKST2
	TAD	(-5400		/CHECK OTHER STS WORD
	SZA CLA	
	JMP	SCHK31
	JMP	SCHK37

	PAGE
SCHK36,	NLM1	
	DCA	CHK6		/ENABLE SCHK37
	DPSRS1	
	AND	(0020
	DCA	CHKST1		/GET 1ST STATUS
	DPSRS2	
	AND	(5400
	DCA	CHKST2		/GET 2ND STATUS
	TAD	CHKST1
	SZA CLA	
	JMP	SCHKX1
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"M;"O;"D;"E;"M;" ;"N;"O;"T;" ;"R;"E;"A;"D;4000+"Y
SCHKX1,	NL4000	
	AND	CHKST2		/MASK FOR CARRIER
	SZA CLA	
	JMP	SCHKX2
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"N;"O;" ;"C;"A;"R;"R;"I;"E;4000+"R
SCHKX2,	TAD	(1000
	AND	CHKST2		/MASK FOR TERMINAL READY
	SZA CLA	
	JMP	SCHKX3
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"T;"E;"R;"M;" ;"N;"O;"T;" ;"R;"E;"A;"D;4000+"Y
SCHKX3,	TAD	(0400
	AND	CHKST2		/MASK FOR CLEAR TO SEND
	SZA CLA	
	JMP	SCHKX4
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"N;"O;"T;" ;"C;"L;"E;"A;"R;" ;"T;"O;" ;"S;"E;"N;4000+"D
SCHKX4,	JMP	SCHK31		/KEEP TRYING
SCHK37,	ISZ	CHK6		/HAVE WE COMPLAINED ONCE ALREADY ?
	  JMP	SCHK31		/YES SO JUST KEEP TRYING
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"X;"M;"T;" ;"N;"O;"T;" ;"R;"E;"A;"D;4000+"Y
	JMP	SCHK31

	PAGE
/HERE BECAUSE WC OR CA DOESN'T LOOK RIGHT AT END OF XMISSION
	0			/PUT AC HERE WHEN CALLED
SCHK38,	0
	CDFCNK
	DCA	SCHK38-1	/SAVE AC CONTENTS
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"W;"C;" ;"O;"R;" ;"C;"A;" ;"W;"R;"O;"N;4000+"G
	JMP	SCHK30-1	/TRY ALL OVER AGAIN IF HE CONTINUES

/HERE BECAUSE FIELD SELECT FAILED
SCHK39,	0
	DCA	CHK3
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"F;"I;"E;"L;"D;" ;"S;"E;"L;"E;"C;"T;" ;"F;"A;"I;"L;"E;4000+"D
	TAD	CHK3		/GET BAD VALUE-CNKFLD
	TAD	(CNKFLD		/LEAVES ONLY BAD VALUE
	JMS	INIOCT		/TYPE IT
	TAD	(257		/ASCII /
	JMS	INITY8
	NL0
	TAD	(CNKFLD		/GET RIGHT VALUE
	JMS	INIOCT		/AND TYPE IT
	JMP	SCHK30-1	/TRY ALL OVER AGAIN IF HE INSISTS


/HERE WHEN SPECIAL CHAR DETECT FAILS
SCHK57,	0
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"C;"H;"A;"R;" ;"D;"E;"T;"E;"C;"T;" ;"S;"K;"I;"P;" ;"F;"A;"I;"L;"E;4000+"D
	JMP	SCHK30-1	/TRY AGAIN IF HE INSISTS

SCHK55,	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"R;"E;"A;"D;" ;"C;"H;"A;"R;" ;"D;"E;"T;"E;"C;"T;"E;"D;4240
	TAD	CHK1
	JMS	INIOCT
	NL0
	JMS	INLTYP
	" ;"R;"I;"G;"H;"T;4000+"=
	NL3
	JMS	INIOCT
	JMP	SCHK30-1	/TRY AGAIN IF HE INSISTS

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***	SYSCHK FOR SYNCHRONOUS INTERFACE - RECEIVE	***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO SEE WHAT WE ARE RECEIVING
/ BE SURE STUFF IS ALSO GOING OUT(TO EXECISE LOOPBACK, CROSSTALK, ETC.)
SCHK40,	NLM1	
	DCA	CHK6		/FLAG 1ST TIME THROUGH XMT TEST
	TAD	(-CHKDPT
	DCA	INISEC		/TIME TO COME ALIVE

SCHK42,	JMS	SCHK66		/CHECK SYNCHRONOUS TRANSMITTER

	JMS	SCHK75		/GET NEXT CHAR FROM RECEIVER
	  JMP	SCHK45		/NONE FOR A WHILE
	DCA	RCVQUE		/SAVE CHAR
	NLM1
	DCA	CHK5		/FLAG FOR BASIC REC TEST
	TAD	RCVQUE
	TAD	(-SYN
	SZA CLA			/WAS CHAR A SYNC ?
	  JMP	SCHK44		/NO SO COMPLAIN

	DPSSCD			/SKIP ON SPECIAL CHAR DETECT
	  JMS	SCHK57		/SHOULD HAVE SKIPPED
	DPSSCD			/SKIP ABOVE SHOULD HAVE CLEARED FLAG
	SKP CLA
	  JMS	SCHK57		/IT DIDN'T SO COMPLAIN
	DPSRCD			/GET SPECIAL CHAR INDEX
	DCA	CHK1
	NLM3			/SHOULD BE 3
	TAD	CHK1
	SZA CLA
	  JMP	SCHK55		/IT WASN'T ?

	JMP	SCHK50		/YES SO ON TO NEXT TEST

SCHK44,	
	TAD	RCVQUE
	NEGATE
	TAD	CHK4
	SNA CLA			/HAVE WE DISPLAYED THIS ONE ALREADY ?
	  JMP	SCHK32		/YES SO DON'T SHOW AGAIN
	TAD	RCVQUE
	DCA	CHK4
	JMS	INBTYP		/TYPE CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"R;"C;"V;"';"D;4000+" 
	TAD	RCVQUE
	JMS	INIOCT
	JMP	SCHK32		/LOOP ON ERROR

/HERE TO CHECK SYNCHRONOUS TRANSMITTER
/ IF T10WC HAS EXPIRED USE T10NWC&T10NCA TO REFRESH IT
/ ELSE SEND SYNCH'S
SCHK66,	0

	DPSSTO	
	JMP I	SCHK66		/CHECK DP8E FOR WC OVERFLOW
	DPSSTO	
	SKP CLA	
	JMS	SCHK56		/BE SURE FLAG CLEARED
	CDFINS	
	TAD I	(T10CA
	TAD	T10LCA		/CHECK CA
	SZA
	  JMS	SCHK38		/BE SURE IT IS KOSHER
	TAD I	(T10WC
	SZA
	  JMS	SCHK38		/CHECK WC ALSO

	TAD I	(T10NCA
	SNA	
	JMP	SCHK67
	DCA I	(T10CA
	DCA I	(T10NCA
	TAD I	(T10NWC
	DCA I	(T10WC
	JMP	SCHK68
SCHK67,	TAD	(SYNBUF-1
	DCA I	(T10CA		/NO MSG SO SEND SYNCS
	NLM1	
	DCA I	(T10WC
SCHK68,	TAD I	(T10WC
	TAD	CHOCNT
	DCA	CHOCNT
	TAD I	(T10CA
	NEGATE	
	TAD I	(T10WC
	DCA	T10LCA
	DPSGTT
SCHK69,	CDFCNK	
	JMP I	SCHK66		/RETURN
ERR23,	"I;"S;" ;"R;"U;"N;"N;"I;"N;"G;" ;"O;"P;"E;4000+"N


	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***	CHECK TO SEE IF SYN LINK IS LOOPED BACK		***
/	***							***
/	***********************************************************
/	***********************************************************

SCHK50,	TAD	(-CHKDPT
	DCA	INISEC		/TIME TO HEAR LOOPBACK

SCHK51,	TAD	(SCHKRD
	DCA	CHK2		/POINTER TO WATCH RECEIVE

SCHK52,	CDFINS
	TAD	(SCHKRD-5
	DCA I	(T10NCA		/SET UP JUNK TO GO
	TAD	(-7
	DCA I	(T10NWC		/WC FOR JUNK
	CDFCNK

	JMS	SCHK66		/SERVICE TRANSMITTER

	JMS	SCHK75		/TRY TO GET ANOTHER CHAR FROM THE SYN RECEIVER
	  JMP	SCHK54		/NOT READY YET
	NEGATE
	TAD I	CHK2
	SZA CLA			/IS THIS ONE OF JUNK CHARS ?
	  JMP	SCHK51		/NO
	ISZ	CHK2		/ADVANCE STATE
	TAD	CHK2
	TAD	(-SCHKRD-3
	SZA CLA
	  JMP	SCHK54		/STILL NOT FATAL
IFNZRO FTLBACK <JMP	SCHK60	>	/MODEM IS IN LOOPBACK MODE

SCHK53,	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"I;"S
IFNZRO FTLBACK < " ;"N;"O;"T >
	" ;"I;"N;" ;"L;"O;"O;"P;"B;"A;"C;"K;" ;"M;"O;"D;4000+"E
	JMP	SCHK30-1	/RECHECK ALL SYNCHRONOUS STUFF

SCHK54,	JMS	SCHK98
	  JMP	SCHK52		/CHECK CLOCK
IFNZRO FTLBACK < JMP SCHK53 >	/MUST BE FOR LOOPBACK TEST

SCHK60,	CDF	20
	TAD	HERTZF
	CDF	10
	TAD	(-36
	DCA	INISEC		/HALF SECOND
	DCA	CHOCNT		/SO WE CAN COUNT CHARS
	JMS	SCHK75		/CHECK RECEIVER
	JMS	SCHK66		/SERVICE TRANSMITER
	NL0	
	JMS	SCHK98
	JMP	.-4
	TAD	CHOCNT
	TAD	(207
	SPA CLA	
	JMP	SCHK61
	CDFINS
	TAD	(NOP
	DCA	INTN21
	CDFCNK
SCHK61,
	TAD	CHOCNT
	TAD	(1200		/COMPARE TO 640.
	CDF	20	/INCASE HAVE TO STORE INTO SCHK62
	SPA CLA
	DCA	SCHK62
	CDF	10
	JMP	SCHK70

/JUNK CHARACTERS TO SEND TO 10
/ NOTE THAT ONLY BITS USED ARE BITS WE KNOW DP01/DP8E CAN SEE
	SYN	;	SYN	;	SYN	;	SYN
SCHKRD,	206;	202;	220
/JMS HERE IF CAN'T CLEAR FLAG ON DP01 OR DP8E
SCHK56,	0
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	SCHK93		/TYPE FLAG WON'T CLEAR
	JMP	SCHK30-1	/TRY AGAIN

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CHECK TO BE SURE 10 ANSWERS		***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO SEND A START(REP) MESSAGE TO 10 AND AWAIT A STACK(RACK)

SCHK70,	TAD	(-CHKDPT
	DCA	INISEC		/TIME TO GET A STACK(RACK)


/SEND START MSG
	CDFINS
	TAD	(-10-NUMSYN
	DCA I	(T10NWC
	TAD	(SYNBUF-1
	DCA I	(T10NCA
	CDFCNK

SCHK71,	TAD	(JMP I SCHK73+1
	DCA	SCHK73

SCHK72,	JMS	SCHK66		/CHECK TRANSMITTER
	JMS	SCHK75
	JMP	SCHK74		/GET NEXT CHAR FROM RECEIVER
SCHK73,	7402			/WILL BE A JMP I SCHK73+#


	CHKENQ;	CHKSTK;	CHKFLL
	SCHK62
SCHK62,	JMP	SCHK80
	JMS	INBTYP
	JMS	INDTYP
	JMS	INLTYP
	"G;"T;" ;"9;"6;"0;"0;" ;"B;"A;"U;4000+"D
	JMP	SCHK80
SCHK74,	JMS	SCHK98
	JMP	SCHK72		/CHECK CLOCK

	JMS	INBTYP		/TYPE CR/LF/%
	JMS	INLTYP
	"N;"O;" ;"R;"E;"S;"P;"O;"N;"S;"E;" ;"T;"O
	" ;"S;"T;"A;"R;4000+"T 
	JMP	SCHK30		/KEEP TRYING

CHKSTK,	TAD	(ENQ-STACK
CHKENQ,	TAD	(-ENQ
CHKFIL,	SZA CLA
	  JMP	SCHK71
	ISZ	SCHK73
	JMP	SCHK74
CHKFLL,	AND	(077		/STRIP SELECT AND QSYNC BITS
	JMP	CHKFIL
SCHK45,	JMS	SCHK98	/CHECK CLOCK
	JMP	SCHK42	/KEEP WAITING
	NLM1
	DCA	CHK4	/FLAG TO DISPLAY ANY RECEIVED CHAR
	ISZ	CHK5
	JMP	SCHK32	/DON'T COMPLAIN EVERY TIME
	JMS	INBTYP	/TYPE A CR/LF/%
	JMS	INDTYP	/TYPE DP8E OR DP01
	JMS	INLTYP
	"N;"O;"T;" ;"R;"E;"C;"E;"I;"V;"I;"N;"G
	JMP	SCHK32

	PAGE
/HERE TO ACCUMULATE A CRC IN CHK6 & CHK7
SCHK78,	0
	DCA	CHK1
	TAD	(-10
	DCA	CHK2
	TAD	CHK6
	CLL RAR
	DCA	CHK6
	SZL	
	TAD	(0400
	TAD	CHK7
	CLL RAR	
	DCA	CHK7
	SZL	
	JMS	SCHKCC
	TAD	CHK1
	CLL RAR
	DCA	CHK1
	SZL	
	JMS	SCHKCC
	ISZ	CHK2
	JMP	SCHK78+4
	JMP I	SCHK78

SCHKCC,	0
	TAD	CHK7
	CLL RAR
	CML
	RAL	
	DCA	CHK7
	TAD	CHK6
	AND	(240
	CMA IAC
	CLL RAL
	TAD	CHK6
	TAD	(240
	DCA	CHK6
	JMP I	SCHKCC
/HERE TO GET THE NEXT CHAR FROM THE SYNCHRONOUS RECEIVER
/ CALL	JMS	SCHK75
/	RETURN		/IF NOTHING HAPPENING
/	RETURN WITH RECEIVED CHAR IN AC
SCHK75,	0

	DPSSRO
	  JMP I	SCHK75		/CHECK FOR FLAG
	DPSSRO
	SKP
	JMS	SCHK56		/FLAG IS SUPPOSED TO HAVE CLEARED
	CDFINS
	TAD I	(F10WC		/CHECK TO BE SURE HDW MEANT IT
	SZA
	  JMS	SCHK38		/COMPLAIN WC ISN'T RIGHT
	TAD I	(F10CA
	TAD	(-RCVQUE
	SZA
	  JMS	SCHK38
	JMS	SCHK76		/REENABLE RECEIVER
	TAD	RCVQUE		/GET CHAR

	ISZ	SCHK75
	JMP I	SCHK75		/SKIP RETURN WITH CHAR

/HERE TO ENABLE DP8E RECEIVER
SCHK76,	0
	CDFINS	
	NLM1	
	DCA I	(F10WC		/RESET RECEIVE WC
	TAD	(RCVQUE-1
	DCA I	(F10CA
	CDFCNK			/RESET RECEIVE CA
	DPSGRR			/REENABLE RECEIVER
	JMP I	SCHK76

/HERE TO INITIALIZE THE SYNCHRONOUS RECEIVER
/ CALL	JMS	SCHK77
/	RETURN
SCHK77,	0

	DPSCSD			/CLEAR SYNC DETECT
	JMS	SCHK76		/RESET WC & CA

	JMP I	SCHK77

/	SUBROUTINE TO BUILD BEGINNING OF OUTPUT BUFFERS
SCHKA1,	0
	TAD	(SYNCHS-1
	DCA	CHAUTO
	TAD	(-20		/16
	DCA	CHK6
SCHKA2,	TAD	(SYN
	DCA I	CHAUTO
	ISZ	CHK6
	  JMP	SCHKA2
	TAD	(STARTC-1	/BEGINNING OF CONTROL
	DCA	CHAUTO
	TAD	(CTLBUF-1	/WHERE IT HAS TO GO
	DCA	CHAUTO-1
	TAD	(-10-6		/BOTH CTL AND 1ST DATA BUFFER
	JMS	CHCOPY		/COPY IT
	TAD	(STARTD-1
	DCA	CHAUTO
	TAD	(T10BF2-1
	DCA	CHAUTO-1
	TAD	(-6
	JMS	CHCOPY
	TAD	(T10LST-1
	DCA	CHAUTO-1
	TAD	(STARTD-1
	DCA	CHAUTO
	TAD	(-6
	JMS	CHCOPY
	JMP I	SCHKA1
CHCOPY,	0
	DCA	CHK6
CHCOPL,	TAD I	CHAUTO
	DCA I	CHAUTO-1
	ISZ	CHK6
	  JMP	CHCOPL
	JMP I	CHCOPY

	PAGE
SCHK80,
	JMP	SCHK90
/HERE TO SEE IF LINE PRINTER IS LS8E(CENTRONICS) OR LE8(LP02)

SCHK90,	CDFCNK			/RESET NORMAL DATA FIELD
	LISTOG	LPTN
	IFNZRO LPTN <
IFNDEF LA180 <	LPTCLF			/CLEAR LPT FLAG
	LPTSKF			/IS FLAG STILL UP ?
	  JMP	SCHK92		/NO SO OK
>/END OF IFNDEF LA1180
IFDEF LA180 <
	NL0
	PBST	/SKIP ON DATA ACCEPTED AND CLEAR
	NOP
	PBST	/ERROR IF  SKIP
	JMP	SCH180
>/END OF IFDEF LA180
SCHK91,	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INLTYP
	"L;"P;"T;4240
	JMS	SCHK93		/TYPE FLAG WON'T CLEAR
	HLT
	JMP	SCHK90		/TRY AGAIN IF HE CONTINUES
IFNDEF LA180 <

SCHK92,	LPTSTF			/SET THE FLAG IF THIS IS AN LS8E
	LPTSKF			/SKIP ON FLAG
	  JMP	SCHK96		/THIS IS AN LE8=LP08
/CENTRONICS PRINTER SO ADJUST TIMEOUTS
	LPTCLF
	LPTSKF
	  SKP			/GOOD - WE CLEARED FLAG
	JMP	SCHK91		/FATAL - CAN'T CLEAR FLAG
	CDFINS			/WE ARE CHANGING DATA IN FIRST FIELD
	TAD	(LPTSIE		/USE THIS TO CLEAR INTERRUPT ENABLE
	DCA I	(LPXXCE		/SET IN LPTFIN
>/END IFNDEF LA180
IFDEF LA180 <
SCH180,	CDFINS
	TAD	(NOP
	DCA I	(LPTFIN
>/END OF LA180
	TAD	(NOP
	DCA I	(LPXXSE
	TAD	(NOP
	DCA I	(LPXYSE
	TAD	(-200		/TWO SECONDS ON A FORM FEED
	DCA I	(LPTTFF
	TAD	(-100		/ONE SECOND ON RANDOM CHAR
	DCA I	(LPTTCH
	CDFCNK			/BACK TO NORMAL DATA FIELD

>/END OF IFNZRO LPTN
	LISTOG	LPTN

SCHK96,

	TAD	(377		/START WITH THE LAST ENTRY IN THE TABLE
	DCA	CHK3
	DCA	CHK6		/CLEAR HALF OF CRC
	DCA	CHK7		/CLEAR REST OF CRC
	TAD	CHK3		/GET CHAR TO MAKE CRC FOR
	JMS	SCHK78		/GO COMPUTE THE CRC FOR IT
	TAD	CHK3
	TAD	(CRCTAB
	DCA	CHK1
	TAD	CHK7
	DCA I	CHK1
	TAD	CHK1
	TAD	(400
	DCA	CHK1
	TAD	CHK6
	DCA I	CHK1
	NLM1
	TAD	CHK3
	SMA			/HAVE WE FILLED THE TABLE ?
	  JMP	SCHK96+1	/NOT YET SO KEEP ON
	NL0

	JMP	SCHK94

SCHK93,	0
	JMS	INLTYP
	"F;"L;"A;"G;" ;"W;"O;"N;"';"T;" ;"C;"L;"E;"A;4000+"R
	JMP I	SCHK93

	PAGE
/HERE WHEN DONE CHECKING SYSTEM
SCHK94,	CDFINS

	NL0
	TAD	(F10TCH-1	/ADDRESS OF TEST CHAR TABLE
	DCA	AUTO1

/FILL OUT THE SPECIAL CHAR TABLE

	TAD	(SOH		/START OF A NUMBERED MESSAGE
	DCA I	AUTO1
	TAD	(ENQ
	DCA I	AUTO1
	TAD	(ENQ
	DCA I	AUTO1		/PAD OUT TABLE
	TAD	(ENQ
	DCA I	AUTO1		/PAD OUT TABLE

/HERE TO BUILD NODE ID MESSAGE
	CDFCNK			/POINT TO DATA FIELD
	DCA	CHK6		/INITIALIZE THE CRC CALCULATION
	DCA	CHK7
	TAD	(NCLNID		/ADDRESS OF MESSAGE
	DCA	AUTO1		/SET UP AUTO INDEX REGISTER
	DCA I	(NCLNID		/CLEAR COUNTER
	NL6			/NCL-NODE-ID MSG TYPE IS 6
	JMS	SCHK95		/PUT INTO MSG
	JMS	SCHK95		/FIELD FOR #
	JMS	SCHK95		/FIELD FOR #
	Z=OURNNM&177		/ONLY 7 BITS
	TAD	(Z		/OUR NODE NUMBER
	JMS	SCHK95		/PUT INTO NODE ID MSG
	TAD	(OURID		/POINTER TO NAME FIELD
	DCA	CHK3		/SAVE POINTER
SCHKNI,	TAD	CHK3
	IAC
	DCA	CHK1
	TAD I	CHK1
	AND	(200
	SNA CLA
	  JMP	SCHKSI		/PUT SOFTWARE ID IN NOW
	TAD I	CHK3		/GET NEXT CHAR
	AND	(177		/STRIP EXTRA BITS
	TAD	(200		/FLAG FOR EXTENSIBLE FIELD
	JMS	SCHK95		/PUT INTO THE MESSAGE
	ISZ	CHK3		/ADVANCE CHAR POINTER
	JMP	SCHKNI		/AND BACK FOR MORE
SCHKSI,	TAD I	CHK3		/GET LAST CHAR OF NAME
	AND	(177		/STRIP EXTRA BITS
	JMS	SCHK95		/AND PUT INTO NODEID
	TAD	(SID-1		/POINT TO SOFTWARE ID
	DCA	CHAUTO		/SAVE ADDRESS OF COUNT
	TAD I	CHAUTO		/GET COUNT (NEG NO OF CHARACTERS)
	DCA	CHK3		/STORE FOR LOOP CONTROL
SCHSID,	TAD I	CHAUTO		/GET NEXT CHARACTER
	JMS	SCHK95		/PUT CHARACTER INTO MESSAGE
	ISZ	CHK3		/TEST IF LAST
	  JMP	SCHSID		/ELSE GO BACK FOR MORE
	TAD	CHK7		/GET HALF OF BCC
	DCA I	AUTO1		/PUT AFTER MSG
	TAD	CHK6		/GET REST OF BCC
	DCA I	AUTO1		/PUT AFTER MSG ALSO
	JMP	SCHK97
SCHK95,	0
	DCA	CHK1		/HOLD CHAR A SEC
	TAD	CHK1		/ GET IT AGAIN
	DCA I	AUTO1		/PUT NEXT CHAR INTO THE MESSAGE
	TAD	CHK1		/GET CHAR AGAIN
	JMS	SCHK78		/INCLUDE IN BCC
	ISZ I	(NCLNID		/COUNT CHAR
	JMP I	SCHK95
SCHK97,
	CDFINS

	NL0			/DEFENSIVE CODE
	DCA I	(INICIF		/CHANGE CIFCNK TO AND 0
	TAD	(CAF		/MAKE INTO CAF FOR PDP8A
	DCA I	(INIJMP		/CHANGE JMP I (SYSCHK TO 0
	CDFCNK			/SET NORMAL CHUNK FIELD
	CIFINS			/SET NORMAL INSTRUCTION FIELD
	JMP I	(INIJMP		/RETURN TO INITIALIZATION
/HERE TO SEE IF CLOCK HAS TIMED OUT
/ CALL	JMS	SCHK98
/	RETURN		/IF INISEC HAS NOT TIMED OUT
/	RETURN		/IF INISEC WENT TO ZERO
SCHK98,	0
	NL0
	CLKSCF			/SKIP ON CLOCK FLAG
	  JMP I	SCHK98		/HASN'T TICKED

	CLCL
	ISZ	INISEC+1	/ COUNT INISEC+1 EVERY TICK
	  NOP			/ AND INISEC ON EVERY OTHER TICK
	NL1
	AND	INISEC+1
	SNA CLA
	  JMP I	SCHK98

	ISZ	INISEC		/CLOCK HAS TICKED - DID TIMER EXPIRE ?
	  JMP I	SCHK98		/NO SO JUSTRETURN
	ISZ	SCHK98		/YES SO SKIP RETURN
	JMP I	SCHK98


	PAGE
/HERE TO TYPE A MESSAGE WHILE IN THE SYSCHK CODE
/ CALL	JMS	INITYP		/WITH MSG ADR-1 IN AC
/	RETURN			/AFTER MSG IS TYPED
INITYP,	0
	DCA	AUTO1		/SAVE MSG ADR IN AUTOINDEX REGISTER
INITY1,	CDF	20
	TAD I	AUTO1		/GET NEXT CHAR FROM MSG
	JMS	INITY8
	SMA CLA			/IS MESSAGE FINISHED ?
	  JMP	INITY1
	CDF	10
	JMP I	INITYP
INITY8,	0
	DCA	INICHR		/SAVE CHAR TO TYPE
	TAD	INICHR
	AND	(0177		/STRIP PARITY
	TAD	(-40
	SPA CLA			/IS CHAR A CR/LF(MAYBE) ?
	  DCA	INIFLG		/YES SO TURN OFF ^O IF IT WAS ON
	TAD	INIFLG		/GET CONTROL O FLAG
	SZA CLA			/IF IT IS ON DON'T TYPE CHAR
	  JMP	INITY9		/IT WAS ON
	TAD	INICHR
	CTYTLS
	CTYTSF
	JMP	.-1
	CTYTCF			/CLEAR FLAG

	CTYKSF			/SKIP ON KEYBOARD FLAG
	  JMP	INITY9
	CTYKRB			/GET CHAR
	NLM1
	DCA	INIFLG
INITY9,	NL0
	TAD	INICHR		/GET CHAR AGAIN
	JMP I	INITY8
INIFLG,	0			/SET NONZERO IF USER TYPES IN WHILE SYSCHK IS TYPING OUT
				/ WILL FLUSH TTY OUTPUT TO NEXT CR/LF
INICHR,	0			/CHAR TO TYPE
INITMP,	0			/LOCATION TO GO INDIRECT ON TO GET PARITY FOR CHAR

INIOCT,	0
	DCA	CHK3
	TAD	CHK3
	AND	(7000
	SZA CLA
	  JMP	INIOC4		/PRINT ALL FOUR DIGITS
	TAD	CHK3
	AND	(0700
	SZA CLA
	  JMP	INIOC3		/PRINT THREE DIGITS ONLY
	TAD	CHK3
	AND	(0070
	SZA CLA
	  JMP	INIOC2		/PRINT TWO DIGITS ONLY
	JMP	INIOC1		/ONLY ONE DIGIT
INIOC4,	TAD	CHK3
	RTL
	RTL
	JMS	INITYO
INIOC3,	TAD	CHK3
	RTR
	RTR
	RTR
	JMS	INITYO
INIOC2,	TAD	CHK3
	RTR
	RAR
	JMS	INITYO
INIOC1,	TAD	CHK3
	JMS	INITYO
	JMP I	INIOCT

INITYO,	0
	AND	(0007
	TAD	(0060		/CONVERT TO OCTAL
	JMS	INITY8		/TYPE CHAR
	NL0
	JMP I	INITYO

/ROUTINE TO TYPE INLINE MESSAGE
INLTYP,	0	
	NL0
	CDF	20		/MESSAGES STORED IN FIELD SYSCHK LOC
INLTY2,	TAD I	INLTYP
	JMS	INITY8
	ISZ	INLTYP		/TYPE NEXT CHAR
	SMA CLA
	JMP	INLTY2
	CDF	10		/RESTORE TO DEFAULT FIELD
	JMP I	INLTYP

/HERE TO TYPE CR/LF??
INFTYP,	0
	JMS	INLTYP
	FATMSG
	4207			/FINAL BELL
	JMP I	INFTYP

/HERE TO TYPE CR/LF/%
INBTYP,	0
	JMS	INLTYP
	215;215;215;12;207;207;"%;4000+"%
	JMP I	INBTYP

/HERE TO TYPE DP8E OR DP01
INDTYP,	0
	JMS	INLTYP
	"D;"P;"8;"E;4240 
	JMP I	INDTYP
IFNZRO TTYN <
	PAGE
KL8AS,	JMS	KL8AT
	JMS	KL8AT
	JMS	KL8AT
	JMS	KL8AT
	JMS	KL8AR
	JMS	KL8AR
	JMS	KL8AR
	JMS	KL8AR
>/END OF IFNZRO TTYN
FIELD	3
*7200
/CHECK FOR MODEM TYPE INTERRUPTS ON KL8A'S
/DEFINE MACRO TO GENERATE CHECK
IFNZRO TTYN <
DEFINE	 MODM Q Q1 Q2 Q3  Q4 Q5 Q6 Q7 Q8 <
/Q=RING ON LINE 0-2
/Q1=DDBTAB ADDRESS OF FIRST TTY ON MODULE
/Q2=HARDWARE INST TO READ STATUS REG A
/Q3=HARDWARE INST TO LOAD CONTROL REG FOR LINE 3
/Q4=RING ON LINE 3
/Q5=CARRIER LINE THREE
/Q6=SEC REC LINE 3
/Q7=CTS LINE 3
/Q8=HARDWARE INSTRUCTION FOR READING STATUS REG B
	TAD	(Q1		/GET POINTER TO DDB ADR
	DCA	INTMP3		/SAVE FOR COMMON ROUTINE
	Q	/INST TO TEST RING ON LIES 0-2
	JMP	.+3	/RING NOT ON LINES 0-2
	Q2	/READ STATUS REG
	JMP	MM	/PROCESS IT
	Q4	/RING ON LINE 3
	JMP	.+10
	Q8		/READ STAUS REG B
	AND	(1000	/DTR ON
	SZA CLA		/IF NOT ON PROCESS INTERUPT
	JMP	INTA	/OTHERWISE IGNORE INTER
	TAD	(3000		/TURN DTR RTS ON
	Q3
	JMP	MM2
	Q5	/CHECK CARRIER LINE 3 
	JMP	.+2	/NO
	JMP	INTA
	Q6		/CHECK SEC RECV
	JMP	.+2	/NO
	JMP	INTA
	Q7		/CHECK CLEAR TO SEND
	JMP	.+2
	JMP	INTA
>/END OF DEFINE MODM
INTMTY,	NL0
	MODM	MSSR,DDBTAB+1,MSRA,MSLC,MSSB,MSSC,MSSV,MSSS,MSRB
ZZ=TTYN
ZZ=ZZ-4
IFNZRO ZZ < MODM	MSSR1,DDBTAB+5,MSRA1,MSLC1,MSSB1,MSSC1,MSSV1,MSSS1,MSRB1
ZZ=ZZ-4>
IFNZRO ZZ < MODM	MSSR2,DDBTAB+11,MSRA2,MSLC2,MSSB2,MSSC2,MSSV2,MSSS2,MSRB2
ZZ=ZZ-4>
IFNZRO ZZ < MODM	MSSR3,DDBTAB+15,MSRA3,MSLC3,MSSB3,MSSC3,MSSV3,MSSS3,MSRB3
>/END OF IF NZRO ZZ
	CIF	0

	JMP	INTMT9
	PAGE
MM,	DCA	INTMP4	/SAVE STATUS REG
	DCA	INTMP2	/INIT COUNT
	TAD	INTMP4
	RTL
	RAL		/GET STATUS OF RING IN HIGH ORDER 3 BITS
	AND	(7000	/MASK OUT REST
MM1,	CLL RAL
	SZL
	JMP	.+3	/FOUND SET BIT
	ISZ	INTMP2
	JMP	MM1
	NL0		/CLEAR AC
	TAD	INTMP2
MM3,	TAD	INTMP3	/CONTAINS DDBTAB ADDR
	DCA	INTMP1
	TAD I	INTMP1	/GET DDB ADDRESS
	TAD	(DEVDSL
	DCA	INTMP2	/SAVE ADDRESS OF DEVDSL
	TAD	(7637	/SET DTR OFF RING ON
	AND I	INTMP2
	TAD	(100	/RING ON
	DCA I	INTMP2
	TAD	(DEVSTS-DEVDSL
	TAD	INTMP2
	DCA	INTMP2
	NL7776
	AND I	INTMP2
	IAC
	DCA I	INTMP2		/SHIP STATUS
INTA,	CIF	0
	JMP	INTDIS
MM2,	NL3
	JMP	MM3
>/END OF IFNZRO TTYN
IFNZRO FTDEBUG <
/HERE TO PUT A WORD INTO THE TRACE
TRACEW,	0
	CDF	30		/DAS92 TRACE FIELD IS 3
	ISZ	BUG
	DCA I	BUG
	CDFCNK			/CHANGE TO NORMAL DATA FIELD
	TAD	BUG		/CHECK FOR WRAP AROUND
	TAD	(-7177
	SZA CLA
	JMP	TRACEX
	TAD	(177		/WRAP AROUND
	DCA	BUG
TRACEX,	CIF	0
	JMP I	TRACEW		/RETURN TO CALLER FROM FIELD 0
BUG,	0
>/END OF IFZERO FTDEBUG
/IDLE - SO DISPLAY DATA ADDRESSED BY CONSOL SWITCHES
ID1,	CLA OSR			/GET CONTENTS OF SWITCHES
	DCA	TEMP1
	TAD	TEMP1
	TAD	DISMIN
	SMA
	  JMP	LOOP90
	TAD	DISMAX		/LIMIT TEST FOR DISPLAY FIELD
	SPA
	  JMP	LOOP90		/OUT OF RANGE
	CLL RTL
	CLL RAL
	TAD	(CDF
	DCA	LOOP90
LOOP90,	CDFINS			/INITIALLY DISPLAY INSTRUCTION FIELD
	NL0
	TAD I	TEMP1
	MQL			/LOAD INTO MQ
LOOP99,	CDF	0
	ISZ I	(WRKREQ		/DISPLAY 4096 TIMES OR UNTIL INTERRUPTED
	JMP	LOOP99
	CIF	0		/CHANGE INSTR FIELD TO RETURN TO FIELD 0
	CDFCNK			/BACK TO NORMAL DATA FIELD
	JMP	LOOP

/NOTE THAT DISMIN+DISMAX MUST = 0010
DISMIN,	10
DISMAX,	0			/FIRST FIELD WHICH MAY NOT BE DISPLAYED

	FIELD 0
*DC72		/STARTING ADDRESS FOR LOADER

$
