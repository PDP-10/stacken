/DC72NP - NETWORK REMOTE STATION SOFTWARE FOR DECSYSTEM-10 - 24 OCT 78
/***COPYRIGHT 1973,1974,1975,1976,1977,1978 BY DIGITAL EQUIPMENT CORP., MAYNARD MASS. ***
/DAVE MCCLURE	20-FEB-1973
/KALMAN RETI	25-APR-1975
/DAN DEUFEL	24-OCT-1978
/ THIS CODE WILL ASSEMBLE EITHER DC71 OR DC72 CODE
/ THE EXISTENCE OF A FEATURE TEST SWITCH IN THIS CODE DOES NOT IMPLY
/ THE SWITCH IS TESTED OR SUPPORTED.
/	E.G. FEATURE TEST SWITCHES ARE PROVIDED FOR STATIONS WITH A HIGH
/	SPEED PAPER TAPE READER/PUNCH OR A PLOTTER BUT THESE ARE NOT
/	SUPPORTED.
	MAJOR=0;MINOR=32

	VEDIT=MAJOR^100+MINOR /SOFTWARE VERSION NUMBER

/STARTING INSTRUCTIONS
/	NORMAL STARTING ADDRESS IS 200
/	RESTART ADDRESS IS 200

/ASSEMBLY INSTRUCTIONS
/	.R PAL10
/	*DSK:CLDR.BIN=DSK:CLDR.PAL
/	*DSK:PCH.BIN=DSK:C.PAL,DSK:DC72NP.PAL
/	WHERE C.PAL IS A CONFIGURATION FILE
/ THEN
/	.R 8CARDS	TO PRODUCE A CARD DECK
/ OR
/	.R PIP
/	*PTP:/I=DSK:PCH.BIN
/DEFAULT SWITCHES

IFNDEF PDP8 <PDP8=2>		/FOR PDP8I USE 1
				/FOR PDP8E USE 2
	PDP8I=PDP8-1
	PDP8E=PDP8-2

IFNDEF FTDP01 <
	IFZERO PDP8I <FTDP01=-1>/DEFAULT IS DP01 HDW
	IFZERO PDP8E <FTDP01=0>	/DEFAULT FOR 8E IS DP8E
>/END OF IFNDEF	FTDP01
IFNZRO FTDP01 <FTDP8E=0>
IFZERO FTDP01 <FTDP8E=-1>

IFNDEF FTDC02F <
	IFZERO PDP8I <FTDC02F=-1>/DEFAULT IS DC02F HDW
	IFZERO PDP8E <FTDC02F=0>/DEFAULT FOR 8E IS KL8E
>/END OF IFNDEF FTDC02F

IFNDEF TTYN <TTYN=20>		/DEFAULT IS SIXTEEN TTY'S

IFNDEF CDRN <CDRN=1>		/DEFAULT IS ONE CDR
 IFNZRO CDRN <CDRN=1>		/AT MOST ONE CDR

IFNDEF LPTN <LPTN=1>		/DEFAULT IS ONE LPT
 IFNZRO LPTN <LPTN=1>		/AT MOST 1
 IFNDEF FTLPLC <FTLPLC=0>	/1 IF LPT HANDLES LC CHARS
 IFNDEF LPTWID <LPTWID=204>	/WIDTH OF LPT
				/ 132 DECIMAL IS 204 OCTAL
				/ 80 DECIMAL IS 120 OCTAL
 IFNDEF LPTFAK <LPTFAK=0>	/IF NONZERO THROW AWAY LPT OUTPUT

IFNDEF PTRN <PTRN=0>		/DEFAULT IS NO PTR - NOT SUPPORTED
 IFNZRO PTRN <PTRN=1>		/AT MOST ONE PTR
IFNDEF PTPN <PTPN=0>		/DEFAULT IS NO PTP - NOT SUPPORTED
 IFNZRO PTPN <PTPN=1>		/AT MOST ONE PTP

	PLTN=0
IFNDEF PLTN <PLTN=0>		/PLOTTER XY8/E - NOT SUPPORTED
 IFNZRO PLTN <PLTN=1>		/AT MOST ONE PLT

IFNDEF DTAN <DTAN=0>		/DEFAULT IS NO DTA
				/ NOT IMPLEMENTED

IFNDEF CNKSIZ <CNKSIZ=10>	/SIZE OF CHUNKS - DEFAULT IS 8 WORDS
  CNKSIZ=CNKSIZ&374		/MUST BE IN RANGE 4-200
  IFZERO CNKSIZ <CNKSIZ=40>
  Z=-CNKSIZ
  CNKSIZ=CNKSIZ&Z		/ MUST BE A POWER OF 2

IFNDEF FTDEBUG <FTDEBUG=1>	/1 FOR DEBUGGING FEATURES
  IFNDEF FTLBACK <FTLBACK=0>	/1 FOR LOOPBACK TEST
  IFNDEF FTTRBL <FTTRBL=0>	/1 FOR CTY MSG ON DEVICE TIMEOUT
  IFNDEF FTBIGL <FTBIGL=0>	/0 TO XLIST UNUSED CODE

IFNDEF CNKFLD <CNKFLD=1>	/0 = KEEP CHUNKS IN FIRST FIELD
	CNKFLD=CNKFLD&0007	/ 1 = KEEP CHUNKS IN SECOND FIELD
				/ 2 = KEEP CHUNKS IN THIRD FIELD

  IFNDEF NUMSYN <NUMSYN=10>	/NUMBER OF SYNCHS AT BEGINING OF MESSAGE

	IFNDEF OURNNM <OURNNM=72>/OUR NODE NUMBER
	IFNDEF MAXOLN <MAXOLN=240+4>/MAX OUTPUT MESSAGE LENGTH=CARD+OVRHEAD
	DEVN=1+TTYN+CDRN+LPTN+PTRN+PTPN+PLTN+DTAN
	CTRLN=1+LPTN+CDRN+PTPN+PTRN+PLTN/NUMBER OF CONTROLLERS(FOR DDCMP)

IFNDEF REPTIM <REPTIM=170>	/REP TIMEOUT = 2 SECS

IFNZRO DTAN <CTRLN=CTRLN+1>

IFNDEF TTYMIC <TTYMIC=120>	/MAXIMUM NUMBER OF INPUT CHARS FROM A TTY

ERSCNT=2
IFNZRO CDRN <ERSCNT=ERSCNT+CDRCNK>/WORST CASE CARD LENGTH
IFNZRO PTRN <ERSCNT=ERSCNT+1>	/WORST CASE TO STOP PTR

IFNDEF	DP8ETR	<DP8ETR=0	/CODE TO TRACE DP8E MESSAGES
IFNZRO	FTDP8E	<
IFNZRO	FTDEBUG	<
/DP8ETR=1			/DEFAULT IS TRACE OFF
>/END OF IFNZRO	FTDEBUG
>/END OF IFNZRO	FTDP8E
>/END OF IFNDEF	DP8ETR

/SOFTWARE IDENTIFICATION STRING (SID)
	DEFINE	SIDTXT	<
"D;"C;"7;260+PDP8;"N;"P;" ;"V;"0;".;"3;"2-200;"2;"4;"-;"O;"C;"T;"-;"7;"8-200
>/END SIDTXT DEFINITION
/	SET DEFAULT CHUNK COUNTS
	IFNDEF	LPTCHK	<LPTCHK=-20>
	IFNDEF	TTYCHK	<TTYCHK=-4>

IFNDEF	BOOTSZ	<BOOTSZ=1420>	/SIZE OF BOOTSTRAP PROGRAM

/	SET RESTRICTED NODE NUMBER TO 0 FOR ALL DEVICES
	XLIST
IFNDEF	CTYRNN <CTYRNN=0>
IFNDEF	T00RNN <T00RNN=0>
IFNDEF	T01RNN <T01RNN=0>
IFNDEF	T02RNN <T02RNN=0>
IFNDEF	T03RNN <T03RNN=0>
IFNDEF	T04RNN <T04RNN=0>
IFNDEF	T05RNN <T05RNN=0>
IFNDEF	T06RNN <T06RNN=0>
IFNDEF	T07RNN <T07RNN=0>
IFNDEF	T10RNN <T10RNN=0>
IFNDEF	T11RNN <T11RNN=0>
IFNDEF	T12RNN <T12RNN=0>
IFNDEF	T13RNN <T13RNN=0>
IFNDEF	T14RNN <T14RNN=0>
IFNDEF	T15RNN <T15RNN=0>
IFNDEF	T16RNN <T16RNN=0>
IFNDEF	T17RNN <T17RNN=0>
IFNDEF	T20RNN <T20RNN=0>
IFNDEF	T21RNN <T21RNN=0>
IFNDEF	T22RNN <T22RNN=0>
IFNDEF	T23RNN <T23RNN=0>
IFNDEF	T24RNN <T24RNN=0>
IFNDEF	T25RNN <T25RNN=0>
IFNDEF	T26RNN <T26RNN=0>
IFNDEF	T27RNN <T27RNN=0>
IFNDEF	CDRRNN <CDRRNN=0>
IFNDEF	LPTRNN <LPTRNN=0>
IFNDEF	PTRRNN <PTRRNN=0>
IFNDEF	PTPRNN <PTPRNN=0>
IFNDEF	PLTRNN <PLTRNN=0>
	XLIST

/CORE LAYOUT FOR THIS VERSION OF DC72 CODE

/PAGE 0
/	0-7	INTERRUPT TRAP
/	10-17	AUTOINDEX REGISTERS
/	20-25	INTERRUPT DISSMISS ROUTINE
/	26-177	COMMON VARIABLE STORAGE
/PAGE 1
/	200	NORMAL STARTING ADDRESS
/	201	HALT (FORMERLY DUMP STARTING ADDRESS)
/	202	VERSION NUMBER OF DC72 CODE
/
/	DUMP ROUTINE
/	INITIALIZATION
/	NON-INTERRUPT LEVEL CODE
/	DEVICE INTERRUPT ROUTINES
/ * CHANGE TO CHUNK FIELD *
/	TABLE DATA = DEVICE BLOCKS, MESSAGES, PARITY TABLE, LPT VFU ETC.
/	SYSCHK - OVERWRITTEN LATER TO FORM CHUNKS


/EIA PINS FROM DP8E AND DP01
/	1	PROTECTIVE GROUND
/	2	TRANSMITTED DATA
/	3	RECEIVED DATA
/	4	REQUEST TO SEND
/	5	CLEAR TO SEND
/	6	DATA SET READY
/	7	SIGNAL GROUND
/	8	RECEIVED LINE SIGNAL DECTECTOR
/	17	RECEIVED SIGNAL ELEMENT TIMING
/	20	DATA TERMINAL READY
/	21	SIGNAL QUALITY DETECTOR
/	22	RING INDICATOR
/	24	TRANSMIT SIGNAL ELEMENT TIMING
/CARD LOADER FOR DC71'S IS
/
/	117570	6672	SELECT CARD READER AND SKIP IF READY
/	117571	5370	JMP .-1
/	117572	6631	SKIP ON DATA READY
/	117573	5372	JMP .-1
/	117574	6634	READ DATA BINARY
/	117575	3270	DCA 7470
/	117576	2375	ISZ .-1
/	117577	5372	JMP 7572


/RIM LOADER FOR LOW SPEED PAPER TAPE IS
/	117756	6032		/CLEAR KEYBOARD FLAG & ADVANCE READER
/	117757	6031		/SKIP ON KEYBOARD FLAG
/	117760	5357		/JMP .-1
/	117761	6036		/READ KEYBOARD BUFFER, CLEAR FLAG
/	117762	7106		/CLL RTL
/	117763	7006		/RTL
/	117764	7510		/SPA
/	117765	5357		/JMP 117757 - SKIP LEADER, TRAILER
/	117766	7006		/RTL
/	117767	6031		/SKIP ON KEYBOARD FLAG
/	117770	5367		/JMP .-1
/	117771	6034		/READ KEYBOARD STATIC
/	117772	7420		/SNL
/	117773	3776		/DCA @117776
/	117774	3376		/DCA 1176
/	117775	5356		/JMP 117756


/RIM LOADER FOR HIGH SPEED PAPER TAPE IS
/	117756	6014		/READER FETCH CHARACTER
/	117757	6011		/SKIP ON READER FLAG
/	117760	5357		/JMP .-1
/	117761	6016		/READ READER BUFFER, AND FETCH NEW CHARACTER
/	117762	7106		/CLL RTL
/	117763	7006		/RTL
/	117764	7510		/SPA
/	117765	5374		/JMP 117774 - SKIP LEADER, TRAILER
/	117766	7006		/RTL
/	117767	6011		/SKIP ON READER FLAG
/	117770	5367		/JMP .-1
/	117771	6016		/READ READER STATIC
/	117772	7420		/SNL
/	117773	3776		/DCA @117776
/	117774	3376		/DCA 1176
/	117775	5357		/JMP 117757
/CODING CONVENTIONS
/
/ 1.)	THE FIRST 3 CHARS OF A SYMBOL INDICATE WHEN THE LABEL IS USED
/	  CLKXXX IS USED AT CLOCK LEVEL(I.E. EVERYTIME CLOCK TICKS)
/	  INIXXX IS USED AT INITIALIZATION TIME.
/	  INTXXX IS USED AT INTERRUPT LEVEL
/	  IXXXXX IS USED AT INTERRUPT LEVEL
/	  DEVXXX IS USED TO REFERENCE DATA IN DEVICE BLOCK
/	  LDBXXX IS USED FOR A LDB ADDRESS
/	  NLXXXX IS USED FOR A NUMERICAL LOAD INSTRUCTION
/
/ 2.)	INTERRUPTS ALWAYS SAVE THE AC(BUT NOT THE LINK)
/	  INTERRUPTS DO NOT CHANGE OR CHECK INSTRUCTION OR DATA FIELD
/	  THE NORMAL INSTRUCTION FIELD IS 0; THE NORMAL DATA FIELD IS
/	  THE CHUNK FIELD(USUALLY 1)
/
/ 3.)	INSTRUCTIONS WHICH ARE CHANGED ARE FLAGED WITH ######## RH SIDE
/DEFINE CHAIN FOR INTERRUPTS & ONCE/TICK CODE
/
/	EVERY DEVICE IS TO HAVE A 3 LETTER MNEMNOIC "XYZ"
/
/	LABEL TO TEST FOR INTERUPTS FOR DEVICE IS INTXXX
/	 WHEN TEST FAILS WILL BRANCH TO INTXY9
/
/	LABEL TO BRANCH TO ONCE / SECOND IS CLKXYZ
/	 WHEN FINISHED WILL BRANCH TO CLKXY9
/	FOLLOWING ARE LABEL DEFINITIONS(MUST BE IN INCREASING PRIORITY):

IFDEF LOOP <		/THIS IS ASSEMBLED ONLY FOR PASS 2

INTMO9=INTMEM

INTPL9=INTMOD
CLKPL9=LOOP		/END OF CLOCK CHAIN

	IFNDEF INTPLT <	INTPLT=INTPL9
			CLKPLT=CLKPL9
>/END OF IFNDEF	INTPLT
INTPP9=INTPLT
CLKPP9=CLKPLT

	IFNDEF INTPTP <	INTPTP=INTPP9
			CLKPTP=CLKPP9
>/END OF IFNDEF	INTPTP
INTPR9=INTPTP
CLKPR9=CLKPTP

	IFNDEF INTPTR <	INTPTR=INTPR9
			CLKPTR=CLKPR9
>/END OF IFNDEF	INTPTR
INTCT9=INTPTR
CLKCT9=CLKPTR

INTCL9=INTCTY

INTLP9=INTCLK
CLKLP9=CLKPTR		/NO SPECIAL CLOCK CODE FOR CTY

	IFNDEF INTLPT <	INTLPT=INTLP9
			CLKLPT=CLKLP9
>/END OF IFNDEF	INTLPT
INTTY9=INTLPT
CLKTY9=CLKLPT

	IFNDEF	INTTTY <INTTTY=INTTY9>
INTCD9=INTTTY
CLKCD9=CLKTTY

	IFNDEF INTCDR <	INTCDR=INTCD9
			CLKCDR=CLKCD99
>/END OF IFNDEF	INTCDR
INTDP9=INTCDR

SCHAIN=INTDPX		/BEGIN SKIP CHAIN WITH SYNCHRONOUS INTERRUPTS

>/END OF IFDEF LOOP
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DEVICE BLOCK DESCRIPTION		***
/	***							***
/	***********************************************************
/	***********************************************************

/DEFINITIONS OF DATA IN DEVICE BLOCK
/ ORDER IS IMPORTANT SO BE CAREFUL IF U CHANGE THEM

DEFINE X Q QQ <XLIST;QQ=QQ+1;XLIST
		Q=QQ-1>/END OF DEFINE X
	DDBSIZ=-3

/DEVICE RESTRICTED NODE NUMBER (NEGATIVE OF NUMBER OF
/ONLY NODE ALLOWED TO CONNECT TO DEVICE. 0 MEANS ANY NODE
/MAY CONNECT
	X	DEVRNN,DDBSIZ

/DEVICE CHUNK IN USE COUNT (USED BY OUTPUT DEVICES)
/	SET TO MINUS NUMBER OF CHUNKS ALLOWED TO BE TIED UP BY DEVICE
	X	DEVCHK,DDBSIZ

/DEVICE NUMBER (OCCUPIES WORD BEFORE DDB) - 0 EXCEPT FOR TTY'S
	X	DEVNUM,DDBSIZ


/DEVICE ID # FOR INPUT	- LH IS OBJECT TYPE, RH IS CONNECT NUMBER
	X DEVSID,DDBSIZ

/POINTER TO CURRENT OUTPUT CHAR
	X DEVOAD,DDBSIZ

/POINTER TO LAST OUTPUT CHUNK
	X DEVOLC,DDBSIZ

/DEVICE STATUS - FOR ALL DEVICES
	X DEVSTS,DDBSIZ
		/ 4000	DEVICE ACTIVE(NOT SET FOR TTY INPUT)
CONBIT=2000	/ 2000 DEVICE IS CONNECTED
		/ 1000	NEED TO SEND A CONNECT CONFIRM (IF 2000 BIT ON)
		/       OR A DISCONNECT (IF 2000 BIT OFF)
OUTBIT=0100	/ 0100	DEVICE IS OUTPUT(I.E. NEEDS TO SEND DATA REQUESTS)
TTYBIT=0040	/ 0040	DEVICE IS A TTY
IRMBIT=0002	/ 0002	IRMA BIT
STSBIT=0001	/ 0001	MEANS SEND DEVICE STATUS

/DEVICE DATA REQUESTS
	X DEVDRQ,DDBSIZ

/DDCMP DEVICE STATUS
	X DEVDDC,DDBSIZ

/PRIMARY BUFFER ADR
	X DEVBF1,DDBSIZ

/SECONDARY BUFFER ADR
	X DEVBF2,DDBSIZ

/DEVICE INPUT CHAR ADR
	X DEVIAD,DDBSIZ
	X DEVIFC,DDBSIZ

/TIMER FOR DEVICE
	X DEVTIM,DDBSIZ

/DDB LINK
	X DEVLNK,DDBSIZ
/DEFINITIONS OF WORDS ONLY IN TTY DEVICE BLOCKS

LDBSIZ=DDBSIZ

/TTY ADDRESS
	X LDBADR,LDBSIZ
		/ HDW ADR FOR LINE

/TTY OUTPUT COLUMN - CHANGES AT INTERRUPT LEVEL
	X LDBCOL,LDBSIZ

/TTY CARRIAGE WIDTH
	X LDBWID,LDBSIZ

/TTY XOF POINTER - CHANGES AT INTERRUPT LEVEL
	X LDBXPT,LDBSIZ

/TTY FILL POINTER - CHANGES AT INTERRUPT LEVEL
	X LDBFPT,LDBSIZ

/CHAR TO TYPE NEXT - CHANGES AT INTERRUPT LEVEL
	X LDBCHR,LDBSIZ


/POINTER TO LAST INPUT CHAR - CHANGES AT INTERRUPT LEVEL
	X LDBIPT,LDBSIZ


/TTY ECHO PIPELINE MARKER
	X LDBEPL,LDBSIZ

/TTY FILL COUNTS
	X LDBFIL,LDBSIZ
	LDBSIZ=LDBSIZ+5
/DEFINE OPCODES WHICH PAL10 DOESN'T KNOW ABOUT

IFZERO PDP8E <
SKON=6000		/SKIP IF INTERRUPTS ARE ON
GTF=6004		/READ MACHINE STATE INTO AC
CAF=6007		/CLEAR ALL FLAGS
MQL=7421		/MQ LOAD = AC TO MQ, AC CLEARED
MQA=7501		/MQ ORED INTO AC
SWP=7521		/SWAP AC AND MQ
CAM=7621		/CLEAR AC AND MQ
>/END OF IFZERO PDP8E

BSW=7002		/BYTE SWAP ON 8E
NEGATE=CML CMA IAC	/NEGATE AC & LINK
NL0=CLA CLL		/LOAD AC& LINK WITH ZERO
NL1=CLA CLL IAC		/LOAD AC & LINK WITH 1
NL2=CLA CLL IAC RAL
NL3=CLA CLL CML IAC RAL
NL4=CLA CLL IAC RTL
NL6=CLA CLL CML IAC RTL
NL2000=CLL CLA CML RTR
NL3777=CLL CLA CMA RAR
NL4000=CLL CLA CML RAR
NL6000=CLL CLA CML IAC RTR
NL7775=CLL CLA CMA RTL
NL7776=CLL CLA CMA RAL
NL7777=CLL CLA CMA
NLM1=CLL CLA CML CMA	/LOAD -1
NLM2=NL7776		/LOAD -2
NLM3=NL7775		/LOAD -3

DEFINE	NLOAD	X	<XLIST
Z=7402
IFZERO X	< Z=CLL CLA >
IFZERO X-1	< Z=CLL CLA IAC >
IFZERO X-2	< Z=CLL CLA IAC RAL >
IFZERO X-3	< Z=CLL CLA IAC CML RAL >
IFZERO X-4	< Z=CLL CLA IAC RTL >
IFZERO X-6	< Z=CLL CLA IAC CML RTL >
IFZERO X-2000	< Z=CLL CLA CML RTR >
IFZERO X-3777	< Z=CLL CLA CMA RAR >
IFZERO X-4000	< Z=CLL CLA CML RAR >
IFZERO X-5777	< Z=CLL CLA CMA RTR >
IFZERO X-6000	< Z=CLL CLA CML IAC RTR >
IFZERO X-7775	< Z=CLL CLA CMA RTL >
IFZERO X-7776	< Z=CLL CLA CMA RAL >
IFZERO X-7777	< Z=CLL CLA CML CMA >
IFZERO Z-7402	< ***** BUM NLOAD CALL >
	XLIST;	Z	>/END OF DEFINE	NLOAD
/MACRO DEFINITIONS

IFNZRO FTBIGL <
DEFINE LISTOG Q < >
DEFINE XISTOG Q < >
>/END OF IFNZRO FTBIGL

IFZERO FTBIGL <
DEFINE LISTOG Q <IFZERO Q < XLIST > >
DEFINE XISTOG Q <IFNZRO Q < XLIST > >
>/END OF IFZERO FTBIGL

DEFINE CREF X <XLIST;Z=X;XLIST>

DEFINE XOR Q <
		TAD	INTMP1
		AND	Q
		CMA IAC
		CLL RAL
		TAD	INTMP1
		TAD	Q
		DCA	Q
>/END OF DEFINE XOR

DEFINE BLOCK Q <XLIST
		*.+Q
		XLIST	>/END OF DEFINE BLOCK

DEFINE REPEAT Q <XLIST
IFNZRO Z <XLIST
		Q
XLIST
Z=Z-1
>/END OF IFNZRO Z
XLIST>/END OF DEFINE REPEAT

DEFINE HLT <	XLIST
		JMS I	[DMPTRP
		XLIST	>/END OF DEFINE HLT

IFNZRO	CNKFLD <
	Z=CNKFLD^10
	CDFCNK=CDF Z
	CIFCNK=CIF Z
>/END OF IFNZRO	CNKFLD
IFZERO	CNKFLD <
	DEFINE CDFCNK <>
	DEFINE CIFCNK <>
>/END OF IFZERO	CNKFLD
	CDFTRC=CDFCNK
	CDFINS=CDF 0
	CIFINS=CIF 0
/CTY IOTS
IFZERO PDP8E <
	CTYKCF=6030		/CLEAR KEYBOARD FLAG			(PDP8E)
	CTYTFL=6040		/SET TELEPRINTER FLAG			(PDP8E)
	CTYTSK=6045		/SKIP ON PRINTER OR KEYBOARD FLAG	(PDP8E)
>/END OF IFZERO PDP8E
	CTYKSF=6031		/SKIP ON KEYBOARD FLAG
	CTYKCC=6032		/CLEAR KEYBOARD FLAG
	CTYKRS=6034		/READ KEYBOARD STATIC
	CTYKRB=6036		/READ KEYBOARD DYNAMIC(KRS+KCC)
	CTYTSF=6041		/SKIP ON TELEPRINTER FLAG
	CTYTCF=6042		/CLEAR TELEPRINTER FLAG
	CTYTPC=6044		/LOAD TELEPRINTER AND PRINT
	CTYTLS=6046		/LOAD TELEPRINTER SEQUENCE(TCF + TPC)

/CLOCK IOTS - KW8/I OR DK8-EA
/ KW8/I TICKS 60(50) TIMES PER SECOND
/ DK8E TICKS 120(100) TIMES PER SECOND SO EVERY OTHER TICK IS IGNORED
IFZERO PDP8I <	CLKECI=6137		/CLEAR ALL CONTROL FLIP FLOPS>
IFZERO PDP8E <	CLKECI=6131		/CLEAR ALL CONTROL FLIP FLOPS>
	CLKSCF=6133		/SKIP ON CLOCK FLAG(AND CLEAR IT)

/MEMORY PARITY IOTS
	MEMSMP=6101		/SKIP ON NO MEMORY PARITY ERROR
	MEMCMP=6104		/CLEAR MEMORY PARITY ERROR FLAG
	MEMSPO=SKP		/IN CASE NOT DEFINED BELOW
IFZERO PDP8E <
	MEMEPI=6103		/ENABLE MEMORY PARITY INTERRUPTS
	MEMSPO=6107		/SKIP IF MEMORY PARITY OPTION PRESENT
>/END OF NEW IOT'S FOR 8E

IFNZRO CDRN <
/CDR IOTS
	CDRSF=6631		/SKIP ON DATA READY
	CDRCRB=6634		/READ CARD BINARY
	CDRSD=6671		/SKIP ON CARD DONE FLAG
	CDRCSE=6672		/SELECT CARD READER AND SKIP IF READY
	CDRCRD=6674		/CLEAR CARD DONE FLAG
>/END OF IFNZRO CDRN

IFNZRO LPTN <
/LINE PRINTER IOT'S - LS8E & LE8=LP08
	LPTSTF=6660		/SET THE FLAG			(LS8E ONLY)
	LPTSKF=6661		/SKIP ON FLAG
	LPTCLF=6662		/CLEAR FLAG
	LPTSKE=6663		/SKIP ON NOT READY
/	LPT=6664		/LOAD PRINT BUFFER
	LPTSIE=6665		/SET PI ENABLE			(LE8 ONLY)
			/ IF AC11=1 SET PI ENABLE	(LS8E ONLY)
			/ IF AC11=0 CLEAR PI ENABLE	(LS8E ONLY)
	LPTSTB=6666		/LOAD DATA & CLEAR FLAG
	LPTCIE=6667		/CLEAR PI ENABLE		(LE8 ONLY)
>/END OF IFNZRO LPTN
	LISTOG	TTYN
IFNZRO TTYN <
	LISTOG	FTDC02F
IFNZRO FTDC02F <
/FOR DCMTPF & DCMTKF	AC 8 SPECIFIES GROUP 0
/			AC 9 SPECIFIES GROUP 1
/			AC 10 SPECIFIES GROUP 2
/			AC 11 SPECIFIES GROUP 3
	DCMTPF=6113		/READ GROUP'S TRANSMITTER FLAGS INTO AC 0-7
	DCMTKF=6123		/READ GROUP'S RECEIVER FLAGS INTO AC 0-7
	DCMINT=6115		/ENABLE INTERRUPTS
	DCMINS=6125		/SKIP IN INTERRUPT REQUEST ACTIVE
	DCMTON=6117		/SELECT STATION(AC0-7) & GROUP(AC8-11)
	DCMKSF=6111		/SKIP ON KEYBOARD FLAG
	DCMKCC=6112		/CLEAR KEYBOARD FLAG
	DCMKRS=6114		/OR CHAR INTO AC4-11
	DCMTSF=6121		/SKIP ON TRANSMIT FLAG
	DCMTCF=6122		/CLEAR TRANSMIT FLAG
	DCMTPC=6124		/TRANSMIT A CHAR
>/END OF DC02F IOTS

	LISTOG	0
IFZERO FTDC02F <
	T00KSF=6141
	T01KSF=6161
	T02KSF=6301
	T03KSF=6321
	T04KSF=6361
	T05KSF=6511
	T06KSF=6601
	T07KSF=6641
	T10KSF=6051
	T11KSF=6331
	T12KSF=6521
	T13KSF=6541
	T14KSF=6561
	T15KSF=6461
	T16KSF=6441
	T17KSF=6061
	T00TSF=6151
	T01TSF=6171
	T02TSF=6311
	T03TSF=6351
	T04TSF=6371
	T05TSF=6621
	T06TSF=6611
	T07TSF=6651
	T10TSF=6071
	T11TSF=6341
	T12TSF=6531
	T13TSF=6551
	T14TSF=6571
	T15TSF=6471
	T16TSF=6451
	T17TSF=6121
>/END OF KL8E IOTS
	XISTOG	FTDC02F
>/END OF IFNZRO TTYN
	LISTOG	TTYN
	Z=PTRN+PTPN+PLTN
	LISTOG	Z
IFZERO PDP8E <
PTRPE=6010		/ENABLE READER/PUNCH INTERRUPT ENABLE
PTPCE=6020		/CLEAR READER/PUNCH INTERRUPT ENABLE
>/END OF IFZERO PDP8E
IFNZRO PTRN <
/HIGH SPEED PAPER TAPE READER IOTS - PC8-E OR 
	PTRSF=6011		/SKIP ON READER FLAG
	PTRRB=6012		/OR READER BUFFER INTO AC & CLEAR FLAG
	PTRFC=6014		/READER FETCH CHARACTER - GET NEXT CHAR
>/END OF IFNZRO PTRN

IFNZRO PTPN <
/HIGH SPEED PAPER TAPE PUNCH IOTS
	PTPSF=6021		/SKIP ON PUNCH FLAG
	PTPCF=6022		/CLEAR PUNCH FLAG
	PTPPC=6024		/PUNCH CHARACTER
	PTPLS=6026		/LOAD PUNCH BUFFER SEQUENCE
>/END OF IFNZRO PTPN

IFNZRO PLTN <		/PLOTTER IOT'S - XY8/E
	PLTCEN=6500		/CLEAR INTERRUPT ENABLE
	PLTSKF=6501		/SKIP ON PLOTTER FLAG
	PLTCLF=6502		/CLEAR PLOTTER FLAG
	PLTPUP=6503		/PEN UP
	PLTLLR=6504		/LOAD DIRECTION REGISTER
	PLTPDN=6505		/PEN DOWN
	PLTLCF=6506		/LOAD DIRECTION REGISTER AND CLEAR FLG
	PLTSEN=6507		/SET INTERRUPT ENABLE
>/END OF IFNZRO PLTN
	LISTOG	Z
	LISTOG	FTDP01
IFNZRO FTDP01 <		/IOTS FOR DP01
	DPTAC=6301		/TRANSMIT A CHARACTER
	DPCTF=6302		/CLEAR TRANSMIT FLAG & SKIP IF TRANSMIT ACTIVE FLAG SET
	DPCIM=6304		/CLEAR IDLE MODE
	DPSTF=6311		/SKIP ON TRANSMIT FLAG NOT SET
	DPSIM=6314		/SET IDLE MODE
	DPSRF=6351		/SKIP ON RECEIVE FLAG NOT SET
	DPRRB=6312		/READ RECEIVE BUFFER(AND CLEAR FLAG)
	DPSEF=6321		/SKIP ON RECEIVE END FLAG
	DPCEF=6322		/CLEAR END FLAG
	DPSRE=6324		/SET RING ENABLE
	DPCRE=6344		/CLEAR RING ENABLE
	DPSRI=6331		/SKIP ON RING INDICATOR
	DPCRF=6332		/CLEAR RING FLAG
	DPSTR=6334		/SET TERMINAL READY
	DPCTR=6342		/CLEAR TERMINAL READY
	DPSSR=6341		/SKIP ON DATASET READY
	DPCRA=6352		/CLEAR RECEIVER ACTIVE
>/END OF IFNZRO FTDP01
	LISTOG	0

IFZERO FTDP01 <		/IOTS FOR DP8E SYNCHRONOUS LINE INTERFACE
	DPSGTT=6405		/TRANSMIT GO
	DPSGRR=6404		/RECEIVE GO
	DPSSCD=6400		/SKIP IF CHAR DETECTED
	DPSCSD=6406		/CLEAR SYNC DETECT
	DPSSRO=6402		/SKIP IF RECEIVE WORD COUNT OVERFLOW
	DPSSTO=6403		/SKIP IF TRANSMIT WORD COUNT OVERFLOWS
	DPSCSI=6401		/CLEAR SYNCHRONOUS INTERFACE
	DPSRTA=6407		/READ TRANSFER ADDRESS REGISTER
	DPSLCC=6412		/LOAD CONTROL
	DPSSRG=6410		/SKIP IF RING FLAG
	DPSSCA=6411		/SKIP IF CARRIER/AGC FLAG
	DPSRS2=6414		/READ STATUS 2
			/ AC00 CARRIER/AGC
			/ AC01 REQUEST TO SEND
			/ AC02 TERMINAL READY
			/ AC03 CLEAR TO SEND
			/ AC04 TEMA 0(TRANSMIT EXTENDED MEMORY ADDRESS)
			/ AC05 TEMA 1
			/ AC06 TEMA 2
			/ AC07 RECEIVE DATA(INV)
	DPSRS1=6415		/READ STATUS 1
			/ AC00 R-RQST	RECEIVE AND TRANSMIT
			/ AC01 T-RQST	BREAK REQUESTS
			/ AC02 SYNC 2	RECEIVED SYNC
			/ AC03 SYNC 1	CHARS
			/ AC04 REMA 0
			/ AC05 REMA 1
			/ AC06 REMA 2
			/ AC07 MODEM READY
	DPSLFL=6413		/LOAD FIELD
	DPSSBE=6416		/SKIP ON BUS ERROR
	DPSRCD=6417		/READ CHAR DETECTED(IF AC0=0)

/FOLLOWING ARE IOTS FOR DP8-EP(KG8-EA) REDUNDANCY CHECK OPTION
/	6110		/TEST VRC AND SKIP
	BCCRDH=6111		/READ HIGH ORDER PORTION OF BCC INTO AC
	BCCRDL=6112		/READ LOW ORDER PORTION OF BCC INTO AC
/	BCCVRC=6113		/COMPUTE VRC CHARACTER
	BCCGEN=6114		/GENERATE BCC
	BCCLCL=6115		/LOAD CONTROL REGISTER FROM AC
			/ AC05=1: CRC; AC05=0: LRC
			/ AC6-8=0: 16BIT BCC
			/ AC6-8=1: 12BIT BCC
			/ AC6-8=2:  8BIT BCC
			/ AC6-8=3:  7BIT BCC
			/ AC6-8=4:  6BIT BCC
			/ AC9=0: PARITY TO AC4; AC9=1:PARITY TO AC11
			/ AC10=1: 6114 ALSO CAUSES 6113
			/ AC11=1: 6114 ALSO CAUSES 6110
	BCCCLR=6116		/CLEAR ACCUMULATION
/	6117		/MAINTENANCE TEST CLOCK
>/END OF IFZERO FTDP01
	LISTOG	FTDP8E
/PAGE 0 INSTRUCTIONS

FIELD 0

INTRAP=0		/TRAP TO FIELD 0 LOC 0 ON AN INTERRUPT

*1
	DCA	INSVAC	/SAVE AC
	CDFCNK		/INTERRUPTS SET DF = 0

IFNZRO CDRN <
	CDRSF		/SKIP ON CARD READER COLUMN READY
	  JMP	SCHAIN	/NOT CARD READ - SO GO FIND WHAT
	JMP	ICDRD0	/GO READ COLUMN
>/END OF IFNZRO CDRN

IFZERO CDRN <
	JMP	SCHAIN	/GO FIND WHAT INTERRUPTED
>/END OF IFZERO CDRN

INSVAC,	0		/SAVE INTERRUPTED AC HERE
INRCPV,	0		/PIVOT FOR DP01 INPUT

/AUTOINDEX REGISTERS
*10

IFNZRO	FTDEBUG <
BUGGER,	0
>/END OF IFNZRO	FTDEBUG

TIQPTR,	0		/POINTER TO PUT TTY CHARS INTO THE INPUT QUEUE
TIQTKR,	0		/POINTER TO TAKE TTY CHARS OUT OF INPUT QUEUE
AUTO1,	0		/MISC AUTOINDEXER FOR NON-INTERRUPT LEVEL CODE
IAUTO1,	0		/MISC AUTOINDEXER FOR INTERRUPT LEVEL CODE
IAUTO2,	0		/	DITTO

INTDIS,	NL0		/CLEAR AC & LINK
	TAD	INSVAC	/RESTORE AC
	ION
	JMP I	INTRAP	/RETURN TO INTERRUPTED PROCESS

FIRFRE,	0		/POINTER TO FIRST FREE CHUNK
FRECNT,	0		/COUNT OF FREE CHUNKS
FIRADR,	FIRCNK		/ADDRESS OF FIRST FREE CHUNK ########

TEMP1,	0		/TEMPORARY LOCATION FOR NONINTERRUPT LEVEL CODE
TEMP2,	0
TEMP3,	0
TEMP4,	0
TEMP5,	0
TEMP6,	0
TEMP7,	0
TEMP8,	0
TEMPA,	0		/ADDITIONAL TEMPS
TEMPB,	0
TEMPC,	0
TEMPD,	0
INTMP1,	0		/TEMPORARY LOCATION FOR INTERRUPT CODE
INTMP2,	0		/	DITTO
INTMP3,	0		/	DITTO
INTMP4,	0		/	DITTO
INTMP5,	0		/	DITTO
INTMP6,	0		/	DITTO
INTMP7,	0		/	DITTO

INTDDB,	0		/ADDRESS OF CURRENT DEVICE BLOCK
IDBSTS,	0		/ADDRESS OF DEVSTS FOR INTDDB
DDB,	0		/ADDRESS OF CURRENT DEVICE BLOCK
DDBSTS,	0		/ADR OF DEVSTS

ERRFLG,	0		/WHEN AN ERROR OCCURS PUT ADR OF MSG HERE
SECFLG,	0		/SET NONZERO ONCE PER SECOND
CLKFLG,	0		/SET NONZERO WHEN CLOCK GOES OFF
INTCNT,	0		/WATCHDOG FOR UNRECOGNIZED INTERRUPTS

WRKREQ,	0		/-1 WHEN INTERRUPT LEVEL HAS LEFT WORK FOR NON-INTERRUPT LEVEL

IFNZRO CDRN <
CDREXT,	0		/**DECSYNC**SLOT TO PUT TRAILING PARTS OF CARDS
			/**DDCMP**ADR OF COUNT FIELD
CDRNXT,	0		/POINTER TO BEGINING OF CURRENT CARD
CDRADR,	0		/POINTER INTO STRING BEING FILLED
CDCCNT,	0		/COMPRRESED CHAR COUNT
CDCCHR,	0		/LAST CARD COLUMN
>/END OF IFNZRO CDRN

IFNZRO LPTN <
LPTCCH,	0		/CHAR WE ARE UNCOMPRESSING
LPTCCN,	0		/COUNT OF CHARS TO UNCOMPRESS
LPTCNT,	0		/COUNT OF CHARS IN CHUNK STRING
LPTCOL,	0		/CURRENT OUTPUT COLUMN
LPTOCH,	0		/CHAR TO PRINT LATER
LPTZCT,	0		/REP COUNT AFTER TIMEOUT
LPTOPV,	0		/LAST VALUE OF PIVOT
LPTCHR,	0		/LAST CHAR OUTPUT TO LPT
LPTRCT,	0		/REPETITION COUNT FOR LPT CHARS(MAKES TABS ETC)
LPTLNE,	0		/INDEX TO LPTVFU
LPTHNG,	LPTHN1		/PUT OUT A CR TO LEFT JUSTIFY THE PRINTER
	LPTHN2		/PUT OUT SPACES TO GET INTO RIGHT COLUMN
>/END OF IFNZRO LPTN

IFNZRO TTYN <
IFNZRO FTDC02F <
DEFINE X Q <
	XLIST
	ZZ=Z&0070
	IFNZRO ZZ <ZZ=7760>		/MASK FOR 8 LINES
	IFZERO Z <ZZ=0000>
	 Z=Z-1
	IFZERO Z <ZZ=4000>
	 Z=Z-1
	IFZERO Z <ZZ=6000>
	 Z=Z-1
	IFZERO Z <ZZ=7000>
	 Z=Z-1
	IFZERO Z <ZZ=7400>
	 Z=Z-1
	IFZERO Z <ZZ=7600>
	 Z=Z-1
	IFZERO Z <ZZ=7700>
	 Z=Z-1
	IFZERO Z <ZZ=7740>
	 Z=Z-1
	IFZERO Z <ZZ=7760>
	XLIST
	ZZ+Q
	XLIST
	ZZ=Z&4000
	IFNZRO ZZ <Z=0>		/IF NEGATIVE HAVE DONE ENOUGH
	XLIST
>/END OF DEFINITION OF X

	Z=TTYN		/INITIALIZE COUNTER

DC1MSK,	X 10
IFNZRO Z <
DC2MSK,	X 4
IFNZRO Z <
DC3MSK,	X 2
IFNZRO Z <
DC4MSK,	X 1
>>>/END OF IFNZRO Z

>/END OF IFNZRO FTDC02F
IFZERO FTDC02F <
>/END OF IFZERO DC02F
>/END OF IFNZRO TTYN
RCVTKR,	0		/RECEIVED MESSAGE TAKER
RCVPTR,	0		/RECEIVED MESSAGE PUTTER

STACKF,	0		/-2 MEANS SENDING STARTS
			/ -1 MEANS NEED TO SEND A STACK
			/ 0 MEANS DOWN(NO ICM)
			/ 1 MEANS HAVE RECEIVED ICM
NAKFLG,	0		/IF NONZERO REASON TO SEND A NAK MESSAGE
CRC1,	0		/FIRST HALF OF CRC-16
CRC2,	0		/2ND HALF OF CRC-16
RECVOK,	0		/LAST MESSAGE # RECEIVED OK
			/ SIGN BIT MEANS SEND ACK
REPTCK,	0		/TIMER FOR REPS
			/ 0 MEANS SEND A REP
T10FLG,	0		/TRANSMITTER STATE
			/	-2	MESSAGE READY TO GO
			/	-1	ACTIVE
			/	0	IDLE
			/	+1	SYNCH
CNTPNT,	0		/POINTER TO CHUNK COUNTER
T10AKR,	0		/POINTER TO LAST ACKED TO 10 REQUEST
			/ T10AKR, T10TKR, & T10PTR ARE ALWAYS LEFT
			/ SO THEY CAN BE USED WITHOUT CHECKING 1ST
T10LAN,	0		/LAST MESSAGE # TO 10 ACKED BY 10
T10TKR,	0		/POINTER TO TAKE TO 10 REQUESTS FROM QUEUE
T10HSN,	0		/HIGHEST MSG # SENT TO 10
T10PTR,	0		/POINTER TO PUT TO 10 REQUESTS INTO QUEUE

T10NCA,	0		/ADR OF NEXT BUFFER TO SEND
T10NWC,	0		/WC FOR NEXT BUFFER TO SEND
T10CLK,	0		/ISZ'ED BY CLOCK INTERRUPTS

F10TWC,	0		/TOTAL WC(POSITIVE) FOR DATA IN NUMBERED MSGS

RSNA,	0		/STORE SNA FIELD
RNCT,	0		/STORE NCT FIELD
RNOD,	0		/NODE NUMBER OF OTHER END OF LINE
DISSNA,	0		/FOR DISCONNECT
DISSLA,	0
DISREA,	0
CONSNA,	0		/INDICATE WE NEED TO SEND CONFIG
DMPCHR,	DMPCTY		/WORD SET BY EITHER DMP000 OR CTYEXC
IFZERO FTDP01 <	*7720	>
F10TCH,	ZBLOCK	4	/4 SPECIAL CHARS TO WATCH FOR ON INPUT
			/ SET UP BY SYSCHK
F10WC,	0		/WORD COUNT FOR MESSAGES FROM 10
F10CA,	0		/CURRENT ADDRESS FOR MESSAGES FROM 10
IFZERO FTDP01 <	0	>/LOCATION USED BY HDW
T10WC,	0		/WORD COUNT FOR MESSAGES TO 10
T10CA,	0		/CURRENT ADDRESS FOR MESSAGES TO 10
IFZERO FTDP01 <	0	>/LOCATION USED BY HDW
/ALL GOOD PDP8 PROGRAMS BEGIN AT ADDRESS 200

*200
DC72,	JMP	INIALL

/HERE TO DUMP SYSTEM ONTO LPT
DUMP,	7402			/FOR COMPATIBILITY
	VEDIT			/SOFTWARE VERSION NUMBER
DMPAC,	0			/AC WHEN AUTODUMP BEGAN
DMPLNK,	0			/FOR 8I'S THIS IS LINK
				/ FOR 8E'S THIS IS LINK AND OTHER FLAGS
DMPTRP,	0			/JMS HERE FOR AN AUTODUMP
	DCA	DMPAC		/SAVE AC
IFZERO PDP8I <	RAR	>	/ROTATE LINK INTO AC
IFZERO PDP8E <	GTF	>	/LOAD FLAGS(AND LINK) INTO AC
	DCA	DMPLNK		/SAVE LINK
IFZERO PDP8I <	IOF	> /PREVENT ANY ADDITIONAL INTERRUPTS
IFZERO PDP8E <	CAF	>		/STOP THE WORLD
	TAD	(DMPMSG-1		/TELL OPR WE ARE DIEING
	JMS	CTYEXC
	TAD	DMPTRP
	JMS	DMPWDO
	7402			/HALT
DMPWDO,	0
	DCA	DMPWRD		/SAVE WORD TO DUMP
	JMS	DMPWDC
	JMS	DMPWDC
	JMS	DMPWDC
	JMS	DMPWDC
	JMP I	DMPWDO
DMPWDC,	0
	TAD	DMPWRD
	RTL
	RAL
	DCA	DMPWRD
	TAD	DMPWRD
	RAL
	AND	[0007
	TAD	[0060
	JMS I	DMPCHR
	JMP I	DMPWDC
DMPTAB,	0
IFNZRO LPTN <
	JMS	DMPSPC
	JMS	DMPSPC
>/END OF IFNZRO LPTN
	JMS	DMPSPC
	JMS	DMPSPC
	JMP I	DMPTAB
DMPSPC,	0			/HERE TO PRINT A SPACE
	TAD	[0040
	JMS I	DMPCHR
	JMP I	DMPSPC
DMPCRL,	0
	TAD	[0015		/CARRIAGE RETURN
	JMS I	DMPCHR		/ WE NEED THIS FOR CENTRONICS
	TAD	[0012		/LINE FEED
	JMS I	DMPCHR
	TAD	[0012
	JMS I	DMPCHR
	JMP I	DMPCRL

DMPWRD,	0

/HERE TO TYPE A MESSAGE ON CTY
/ ONLY USED WHEN STATION NOT RUNNING
CTYEXC,	0
	DCA	DMPWRD
	TAD	(DMPCTY
	DCA	DMPCHR
	CDFCNK
CTYEX3,	ISZ	DMPWRD
	TAD I	DMPWRD
	JMS I	DMPCHR
	TAD I	DMPWRD		/GET CHAR AGAIN
	SMA CLA			/ALL DONE ?
	  JMP	CTYEX3		/NO
	CDFINS
	JMP I	CTYEXC
DMPCTY,	0
	CTYTLS
	CTYTSF
	JMP	.-1
	NL0
	JMP I	DMPCTY

DOWN1,				/CONTINUATION OF DOWN ROUTINE
	DCA	DDB		/SAVE DDB ADDRESS
	TAD	(DEVSTS		/DISPLACEMENT
	TAD	DDB		/MAKE ABSOLUTE
	DCA	DDBSTS
	IOF
	TAD I	DDBSTS		/GET STATUS
	AND	(0772		/TURN OFF ACTIVE,CONNECTED,NEED CONNECT CONFIRM,TABBING, AND SEND STATUS
	DCA I	DDBSTS		/PUT IT BACK
	ION			/RESTORE INTERRUPTS
	NLOAD	DEVCHK		/DEVCHK DISPLACEMENT
	TAD	DDB		/MAKE ABSOLUTE
	DCA	TEMP2		/SAVE
	NLOAD	DEVOAD		/POINTER TO OUTPUT
	TAD	DDB
	DCA	TEMP1		/SAVE ITS ADDRESS
	JMS	NEIFLB		/FLUSH ANY OUTPUT
	NLOAD	DEVBF1		/POINT TO INPUT STRING
	TAD	DDB		/MAKE ABSOLUTE
	DCA	TEMP1		/STORE
	DCA	TEMP2		/DO NOT COUNT CHUNKS
	JMS	NEIFLB		/FLUSH INPUT
	NLOAD	DEVDRQ		/POINT TO DATA REQUESTS
	TAD	DDB		/MAKE ABSOLUTE
	DCA	TEMP1		/STORE ADDRESS
	DCA I	TEMP1		/CLEAR DATA REQUESTS
	TAD	TEMPB		/GET SNATAB ENTRY
	JMP	DOWN2		/GO CLEAR OUT RCVDSP ENTRY
NEIFLB,	0			/SUBROUTINE TO FLUSH BUFFERS
/TEMP1	=	WHERE TO START CHAIN
/TEMP2	=	0 OR WHERE TO INCREMENT CHUNK COUNT
	IOF
	TAD I	TEMP1		/GET START OF CHAIN
	SNA			/SEE IF ANY
	  JMP	NEIFLR		/NONE, SO RETURN
NEIFL1,	DCA	TEMP3		/STORE ADDRESS
	DCA I	TEMP1		/CLEAR POINTER
	DCA	FREDCK		/CLEAR COUNT
	TAD	TEMP3		/GET ADDRESS
	AND	[-CNKSIZ	/MAKE SURE AT BEGINNING OF CHUNK
	JMS	FRECKS		/FREE CHUNKS
	TAD	TEMP2		/COUNTER SPECIFIED?
	SNA CLA			/COUNTER SPECIFIED?
	  JMP	NEIFLR		/NO, RETURN
	IOF
	TAD	FREDCK		/COUNT OF CHUNKS FREED
	NEGATE
	TAD I	TEMP2		/PREVIOUS COUNT
	DCA I	TEMP2		/STORE NEW ONE
NEIFLR,	ION			/RESTORE INTERRUPTS
	JMP I	NEIFLB		/RETURN
	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		INITIALIZATION				***
/	***							***
/	***********************************************************
/	***********************************************************

INICNT,	0			/COUNTED EACH TIME STATION IS RESTARTED

/HERE TO RESTART PROGRAM
INIALL,	IOF			/DISABLE INTERRUPTS

	NLM2
	DCA	STACKF		/FLAG TO SEND A START
INISUM,
/HERE TO INITIALIZE SOME OF STATION STUFF

	CDFCNK
	ISZ	INICNT		/IF IT SKIPS WON'T MATTER BECAUSE NEXT INS
				/ WILL BE A NOP
INICIF,	CIFCNK			/ CHANGE INSTRUCTION FIELD	########
INIJMP,	JMP I	(SYSCHK		/GO PERFORM SYSCHK		########
				/ CHANGED TO CAF(OR 0) BY SYSCHK

IFZERO PDP8E <
	MEMEPI			/ENABLE MEMORY PARITY ERROR INTERRUPTS
>/END OF IFZERO PDP8E

/HERE TO INITIALIZE THE CLOCK
	CLKECI			/RESET CLOCK

/HERE TO INITIALIZE THE COMMUNICATIONS FLAGS
	DCA	REPTCK

/HERE TO INITIALIZE FROM 10 FLAGS
	TAD	(RCVQUE
	DCA	RCVPTR
	TAD	(RCVQUE
	DCA	RCVTKR

/HERE TO INITIALIZE TO 10 FLAGS
	TAD	(T10BF1
	DCA	T10AKR
	DCA	T10LAN		/LAST ACKED POINTER
	TAD	(T10BF1
	DCA	T10TKR		/LAST SENT POINTER
	TAD	(T10BF1+T10LEN
	DCA	T10PTR		/HIGHEST SENT POINTER
	NL1
	DCA	T10HSN		/HIGHEST MSG# SENT
	NL2			/FOR BCC
	TAD I	(NCLNID		/GET NODE-ID MSG SIZE
	NEGATE			/MAKE ISZ COUNTER
	DCA	TEMP2		/SAVES COUNTER
	TAD	(NCLNID		/POINT TO NODE ID MESSAGE
	DCA	IAUTO1		/SET UP POINTER TO MESSAGE
	TAD	(T10BF1+7
	DCA	AUTO1		/POINTER TO BUFFER
INIDD3,	TAD I	IAUTO1
	DCA I	AUTO1		/PUT NEXT CHAR INTO BLOCK
	ISZ	TEMP2
	  JMP	INIDD3		/LOOP BACK FOR REST
	TAD I	(NCLNID		/GET SIZE OF NODE-ID MSG
	DCA I	(T10BF1+1	/SET COUNT IN MSG
	DCA I	(T10BF1+2	/CLEAR HIGH ORDER COUNT
	NL1
	DCA I	(T10BF1+4	/SET MESSAGE NUMBER
	TAD	(-DEVN
	DCA	TEMP1
	TAD	(RCVDSP
	DCA	AUTO1
	TAD	(CTRLTB-1
	DCA	IAUTO1
	TAD	(SNATAB-1	/POINT TO NODE TABLE
	DCA	IAUTO2		/PUT INTO AUTOINDEX REGISTER
INIDD4,	TAD	(RCVKRD		/GET UNUSED DISPATCH ENTRY
	DCA I	AUTO1		/STORE AT RCVDSP
	DCA I	IAUTO1		/ZERO DDB FIELD
	DCA I	IAUTO2		/ZERO NODE FIELD
	ISZ	TEMP1		/UP COUNTER
	  JMP	INIDD4		/CONTINUE IF NOT EXPIRED
	JMP	FUG		/GO ON WITH INITIALIZATION
RCVNEI,				/HERE WHEN WE RECEIVE NEIGHBORS MESSAGE
	TAD	RNOD		/GET OUR NEIGHBOR
	NEGATE
	TAD	RSNA		/GET WHO SENT NEIGHBORS
	SZA CLA			/ONLY BELIEVE HIM
	  JMP	RCVFLU		/IGNORE OTHERS
NEIG0,
	JMS	GETCHR	/GET NNM
	  JMP	NEIG10		/NONE, SO DONE
	NEGATE			/GET NEGATIVE
	DCA	TEMPA		/SAVE
	TAD	(SNATAB		/POINT TO START OF NODE TABLE
	DCA	TEMPB		/STORE
	TAD	(-DEVN		/NUMBER OF ENTRIES
	DCA	TEMPC		/STORE
NEIG1,				/LOOP TO MARK NODES UP
	TAD I	TEMPB		/GET NODE TABLE ENTRY
	SNA			/ONLY TEST ONES THAT ARE THERE
	  JMP	NEIG3		/ADVANCE TO NEXT ENTRY IF NOT USED
	TAD	TEMPA		/ADD THE ONE WE ARE CONSIDERING
	SNA CLA			/SKIP IF NOT THE SAME
	  JMP	NEIG2		/MARK AS UP IF THE SAME
NEIG3,	ISZ	TEMPB		/ADVANCE NODE TABLE POINTER
	ISZ	TEMPC		/ADVANCE COUNTER
	  JMP	NEIG1		/CONTINUE IF COUNT NOT EXHAUSTED
	JMS	GTCHR		/GET LVL TO THROW AWAY
	JMP	NEIG0		/DO NEXT
NEIG2,	NL4000			/GET BIT TO MARK NODE UP
	TAD I	TEMPB		/GET TABLE ENTRY
	DCA I	TEMPB		/STORE IT AGAIN WITH UP BIT ON
	JMP	NEIG3		/CONTINUE
NEIG10,				/HERE AFTER ALL NODES MARKED AS UP
	TAD	(SNATAB		/GET START OF NODE TABLE
	DCA	TEMPB		/SAVE
	TAD	(-DEVN		/GET NUMBER OF ENTRIES
	DCA	TEMPC		/SAVE
NEIG11,				/LOOP THROUGH TABLE
	TAD I	TEMPB		/GET ENTRY
	SMA SZA			/EITHER 0 (NOT USED) OR MINUS (UP) IS OK
	  JMP	DOWN		/AC WILL BE ZERO WHEN ROUTINE JMPS TO NEIG13
NEIG13,	AND	(3777		/CLEAR UP BIT
	DCA I	TEMPB		/STORE ENTRY BACK
NEIG12,	ISZ	TEMPB		/ADVANCE TABLE POINTER
	ISZ	TEMPC		/ADVANCE COUNTER
	  JMP	NEIG11		/CONTINUE LOOP
/	IF WE WANT TO SEND CONFIGURATION, DO IT HERE
	JMP	RCVFLU		/DONE WITH MESSAGE
DOWN,				/HERE WHEN WE DETERMINE NODE HAS GONE DOWN
	NL0			/CLEAR AC
	TAD	TEMPB		/GET SNATAB ENTRY
	TAD	(CTRLTB-SNATAB	/GET CORRESPONDING CTRLTB ENTRY
	DCA	DDB		/STORE ADDRESS OF DDB
	TAD I	DDB		/GET DDB
	SNA			/MAKE SURE THERE IS ONE
	  JMP	NEIG12		/NO, MUST HAVE BEEN A DEVICE DISCONNECT
	JMP	DOWN1		/CONTINUE
	PAGE
FUG,


/HERE TO INITIALIZE THE SYNCHRONOUS LINE
	DCA	INRCPV		/MIGHT BE USEFUL ON A RESTART
	JMS	INISYN
	JMP	INIDP9

/HERE TO INITIALIZE THE SYNCHRONOUS INTERFACE WHEN STATION RESTARTS
/ AND ALSO HERE WHEN TRANSMITTER TIMES OUT
INISYN,	0
	TAD	(CTLSIZ-1	/POINT TO CHUNKS
	TAD	RCVPTR		/POINT THIS MESSAGE
	DCA	TEMP1
	TAD	INRCPV		/GET STATE OF RECEIVER
	TAD	(-INRC70	/CHECK TO SEE IF RECEIVING NUMBERED MESSAGE
	SNA CLA			/SKIP IN WE DON'T HAVE CHUNKS IN LIMBO
	  TAD I	TEMP1		/GET ADR OF FIRST CHUNK
	DCA	TEMP1		/SAVE ADR OF FIRST CHUNK(OR ZERO)
IFZERO FTDP01 <
	DPSCSI			/CLEAR INTERFACE
		Z=CNKFLD^1100
	TAD	(Z
	DPSLFL			/SET FIELD FOR RECEIVE AND XMT BUFFERS
	TAD	(5400-Z
	DPSLCC			/LOAD CONTROL REGISTER
	NL0
>/END OF IFZERO FTDP01
	TAD	(SYNBUF-1	/STRING OF 4 SYNCHS
	CDFINS			/WC AND CA ARE IN FIRST FIELD
	DCA I	[T10CA
	TAD	(-4
	DCA I	[T10WC
	NLM3
	DCA	T10CLK
	JMS	INRCID		/SET RECEIVER TO IDLE MODE
				/ AND SET DATA FIELD TO CHUNK FIELD
	NL1
	DCA	T10FLG		/TRANSMITTER IS TRYING TO SYNCH LINE

IFNZRO FTDP01 <
/HERE TO INITIALIZE DP01 ROUTINES
	DPSTR			/SET TERMINAL READY
	TAD	(SYN
	DPTAC			/START DP01
	NL0
>/END OF IFNZRO FTDP01

IFZERO FTDP01 <
	DPSGTT			/TRANSMIT GO
	DPSGRR			/AND RECEIVE GO
>/END OF IFZERO FTDP01
	TAD	TEMP1		/GET CHUNK ADR TO FREE(IF ANY)
	SZA
	  JMS	FRECKS
	JMP I	INISYN

INIDP9,

/HERE TO INITIALIZE THE CHUNKS
	DCA	FIRFRE		/NO FREE CHUNKS YET
	DCA	FRECNT		/COUNT OF FREE CHUNKS

	TAD	FIRADR		/GET FIRST CHUNK ADDRESS
	DCA	INTMP2
INICNK,	TAD	INTMP2
	JMS	IFRCNK		/PUT CHUNK INTO FREE LIST
	TAD	INTMP2		/GET LAST CHUNK ADR
	TAD	[CNKSIZ		/ADVANCE 1 CHUNK
	DCA	INTMP2		/SAVE NEW CHUNK ADR
	TAD	INTMP2
IFZERO PDP8I <Z=-CNKSIZ&7570>	/DON'T OVERWRITE CARD LOADER
IFZERO PDP8E <Z=7600>		/DON'T OVERWRITE SHORT TRACE
	TAD	(-Z
	SZA CLA
	  JMP	INICNK
/HERE TO INITIALIZE ALL DEVICES AT STATION
	NLM1			/START AT DDBTAB
	DCA	TEMP6		/SAVE DEVICE NUMBER

/INITIALIZE THE TTY INPUT CHAR QUEUE
	TAD	(TTIQUE-1
	DCA	TIQPTR
	TAD	(TTIQUE-1
	DCA	TIQTKR

/HERE TO INITIALIZE THE TTYS

IFNZRO FTDC02F <
/DCMINT IS DONE ONCE A SECOND ANYWAY SO DON'T BOTHER HERE
/ ALSO DON'T DO CALL TO ALLSEL BECAUSE STARTUP MESSAGE WILL DO IT ANYWAY
>/END OF IFNZRO DC02F

	TAD	(-1-TTYN	/COUNT OF CTY & TTYS
	DCA	TEMP8		/INITIALIZE TTY COUNTER
INITT0,	JMS	INITTY
	ISZ	TEMP8		/HAVE WE DONE ALL THE TTY'S ?
	  JMP	INITT0		/NOT YET SO KEEP GOING

INICDR,
IFNZRO CDRN <
/HERE TO INITIALIZE THE CDR
	DCA	CDRNXT		/NO CARD READY TO GO
	JMS	INIDDB		/INITIALIZE DEVICE BLOCK
>/END OF IFNZRO	CDRN

IFNZRO LPTN <
/HERE TO INITIALIZE THE LPT
INILPT,	JMS	INIODB		/INITIALIZE DDB
	DCA	LPTCCN		/NO COMPRESSED CHAR COUNT YET
	DCA	LPTCNT		/NO CHARS IN CHUNK STRING
	DCA	LPTCOL		/WE ARE AT LEFT HAND MARGIN
	TAD	(LPTVFU-1	/INDEX TO VFU
	DCA	LPTLNE		/WE ARE AT TOP OF FORM
	TAD	(SKP
	CDFINS			/WE ARE CHANGING AN INSTRUCTION
	DCA	LPTPIV
	CDFCNK
	TAD	[LPTCHK
	DCA I	[LPTBLK+DEVCHK	/STORE CHUNK COUNT
>/END OF IFNZRO LPTN

INIPTR,
IFNZRO PTRN <
/HERE TO INITIALIZE THE PTR
	JMS	INIDDB
>/END OF IFNZRO	PTRN

PTPINI,
IFNZRO PTPN <
/HERE TO INITIALIZE THE PTP
	JMS	INIODB
>/END OF IFNZRO PTPN

INIPLT,
IFNZRO PLTN <
/HERE TO INITIALIZE THE PLT
	JMS	INIODB
>/END OF IFNZRO PLTN


	JMP	LOOP

/HERE TO INITIALIZE A TTY BLOCK
INITTY,	0
	JMS	INIODB
	TAD	INTMP1
	DCA I	DDB
	TAD	(4000+TTYBIT+OUTBIT+STSBIT
	DCA I	DDBSTS		/SET INITIAL TTY STATUS WORD
	ISZ	AUTO1		/SKIP LDBADR
	DCA I	AUTO1		/SET LDBCOL
	ISZ	AUTO1		/SKIP LDBWID
	TAD	(RSTMSG-1
	DCA I	AUTO1		/SET LDBXPT
	DCA I	AUTO1		/CLEAR LDBFPT
	DCA I	AUTO1		/SET LDBCHR
	DCA I	AUTO1		/	"	LDBIPT
	NLOAD	DEVCHK
	TAD	DDB
	DCA	TEMPA
	TAD	[TTYCHK
	DCA I	TEMPA		/STORE OUTPUT CHUNK LIMIT
	JMP I	INITTY

/HERE TO INITILIZE AN OUTPUT DEVICE BLOCK
INIODB,	0
	JMS	INIDDB
	TAD	(OUTBIT
	DCA I	DDBSTS
	JMP I	INIODB
SNDOBJ,	0			/SEND OBJECT TYPE
	TAD I	DDB		/FIRST WORD OF DDB
	AND	(7700		/CLEAR RIGHT HALF
IFZERO	PDP8I	<
	CLL RTR
	CLL RTR
	CLL RTR
>/END OF IFZERO	PDP8I
IFZERO	PDP8E	<
	BSW
>/END OF IFZERO	PDP8E
	JMS	SNDCHR		/OBJECT TYPE
	JMP I	SNDOBJ		/RETURN
PAGE
/HERE TO INITIALIZE A DEVICE BLOCK
INIDDB,	0
	ISZ	TEMP6		/ADVANCE DEVICE NUMBER
	TAD	TEMP6		/GET NEW DEVICE NUMBER
	JMS	GETDDB		/GET DEVICE BLOCK ADR AND SET UP DDBSTS
	DCA	AUTO1
 TAD	(1-DEVLNK 	/CLEAR ONLY PORTION
	DCA	INTMP1
INIDD0,	DCA I	AUTO1		/ZERO DEVICE BLOCK
	ISZ	INTMP1
	  JMP	INIDD0
	ISZ	AUTO1		/SKIP LINK
	TAD I	DDB
	AND	(7700
	DCA I	DDB
	JMP I	INIDDB
IFNZRO FTDC02F <
/HERE TO SELECT ALL LINES AGAIN(SO INTERRUPTS WILL WORK)
ALLSEL,	0
IFNZRO TTYN <
	NL0
	TAD	DC1MSK		/MASK FOR 1ST GROUP
	DCMTON			/SELECT LINES
IFDEF DC2MSK <
	NL0
	TAD	DC2MSK
	DCMTON			/SELECT LINES IN 2ND GROUP
>/END OF IFDEF DC2MSK
IFDEF DC3MSK <
	NL0
	TAD	DC3MSK
	DCMTON			/SELECT LINES IN 3RD GROUP
>/END OF IFDEF DC3MSK
IFDEF DC4MSK <
	NL0
	TAD	DC4MSK
	DCMTON			/SELECT LINES IN 4TH GROUP
>/END OF IFDEF DC4MSK
>/END OF IFNZRO TTYN
	JMP I	ALLSEL		/ALL DONE SO DISMISS
>/END OF IFNZRO FTDC02F
IFNZRO FTDEBUG <
/HERE TO PUT A WORD INTO THE TRACE
TRACEW,	0
	CDFCNK			/CHANGE TO TRACE FIELD		########
	DCA I	BUGGER
	CDFCNK			/CHANGE TO NORMAL DATA FIELD
TRCWD1,	NL1			/OR CHANGED TO JMP I TRACEW	########
	TAD	BUGGER
	SZA CLA
TRCWD2,	  JMP I	TRACEW
	TAD	(7577
	DCA	BUGGER
	JMP I	TRACEW
>/END OF IFNZRO FTDEBUG
/IRMA CATCHER
/ COME HERE ONCE PER SECOND
/ IF A TTY IS ACTIVELY OUTPUTING SET IRMA BIT IN LDBSTS UNLESS
/ IRMA BIT IS STILL ON FROM LAST TIME, IN WHICH CASE TTY HAS LOST XMT SO FAKE ONE

IRMA,	IFNZRO TTYN <
	IFNZRO FTDC02F <
	NL1			/REENABLE INTERRUPTS ON ALL LINES
	DCMINT			/(IN CASE FLIPFLOP CLEARED)
>/END OF IFNZRO FTDC02F
>/END OF IFNZRO TTYN
	 NL0		/START WITH CTY
	DCA	TEMP5
IRMA1,	TAD	TEMP5		/GET NUMBER OF NEXT DEVICE
	JMS	GETDDB		/GET ADDRESS OF BLOCK FOR THIS DEVICE
	IOF			/IN CASE OF XMT INTERRUPTS
	DCA	INTDDB		/SAVE ADR OF DEVICE BLOCK
	TAD I	DDBSTS
	SMA			/IS DEVICE ACTIVE ?
	  JMP	IRMA7		/NO
	AND	[TTYBIT
	SNA CLA			/IS DEVICE A TTY ?
	  JMP	IRMA9		/NO SO DONE
	TAD	(DEVTIM		/RELATIVE ADR OF FILLER TIMER
	TAD	INTDDB		/MAKE ABSOLUTE
	DCA	INTMP1		/SAVE POINTER TO FILLER
	TAD I	INTMP1		/GET FILL TIMER
	SZA CLA			/SKIP IF FILLING
	  JMP	IRMA7
	NLOAD	IRMBIT		/MASK FOR IRMA BIT
	AND I	DDBSTS		/GET BIT FROM OLD STATUS
	SZA CLA			/SKIP IF WE LOST AN XMTINT
	  JMS	XMTINT		/FAKE A XMT INTERRUPT
	NLOAD	IRMBIT		/GET BIT FOR IRMA

	TAD I	DDBSTS		/PUT INTO STATUS WORD
	DCA I	DDBSTS
IRMA7,	ION
	NL0
	ISZ	TEMP5		/ADVANCE 1 DEVICE
	TAD	TEMP5
	TAD	[-DEVN
	SZA CLA
	  JMP	IRMA1
IRMA9,	/DCA	BROADC		/CLEAR BROADCAST MESSAGE POINTER
	JMP	LOOP		/ALL DONE
/HERE ONCE PER TICK TO CHECK TTY'S
/ SEE IF THERE IS AN ERROR MESSAGE FOR THE CTY
/ CHECK FILLERS FOR ALL LINES
CLKTTY,	TAD I	(CTYBLK+LDBFPT
	SZA CLA
	  JMP	CLKTY2		/ALREADY TYPING
	TAD	ERRFLG
	SNA
	  JMP	CLKTY2		/NO MSG SO DONE
	DCA I	(CTYBLK+LDBFPT
	DCA	ERRFLG		/SETUP MSG
	TAD	(CTYBLK
	DCA	DDB
	TAD	(CTYBLK+DEVSTS
	DCA	DDBSTS
	JMS	TTYGO		/START CTY IF NEED TO
CLKTY2,
	TAD	(FIRTTY		/GET ADR OF FIRST TTY BLOCK
CLKTY3,	IOF			/DISABLE INTERRUPTS FOR A WHILE
	DCA	INTDDB
	TAD	(DEVTIM		/RELATIVE ADR OF TIMER
	TAD	INTDDB
	DCA	TEMP2		/SAVE POINTER TO TIMER
	TAD I	TEMP2		/GET TIMER FOR FILLER
	SZA CLA
	ISZ I	TEMP2
	  JMP	CLKTY5		/HASN'T TIMED OUT
	NLOAD	IRMBIT		/FLAG TRANSMITTER IS ACTIVE
	AND I	DDBSTS
	SNA CLA			/DON'T START IF STILL TYPING
	  JMS	XMTINT
	NL0			/BECAUSE XMTINT RETURNS GARBAGE
CLKTY5,	ION
	TAD	INTDDB
	TAD	(DEVLNK
	DCA	TEMP1
	TAD I	TEMP1
	SZA
	  JMP	CLKTY3
	JMP	CLKTY9

IFNZRO	TTYN	<
IFZERO	FTDC02F	<
	DISCDE
	JMP	DISSN1
>/END OF IFZERO	FTDC02F
>/END OF IFNZRO	TTYN
	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DESCRIPTION				***
/	***							***
/	***********************************************************
/	***********************************************************

IFNZRO 0 <
THIS FILE CONTAINS TWO SYNCHRONOUS INTERFACE MOUDLES(SIM) UNDER
CONDITIONAL FTDP01 AND ONE PROTOCOL MODULE (PM) COMBINING DDCMP
AND NCS.

SYNCHRONOUS OUTPUT:
 A SIM IS ALWAYS IN ONE OF FOUR STATES:
	T10FLG=-2	MESSAGE READY TO TRANSMIT
	T10FLG=-1	MESSAGE IS BEING TRANSMITTED
	T10FLG=0	LINE IS SENDING IDLES
	T10FLG=1	LINE IS SENDING SYNCS
 WHEN T10FLG IS -2 T10NWC(T0 10 NEXT WORD COUNT) AND T10NCA(TO 10 NEXT
 CURRENT ADDRESS) DESCRIBE THE NEXT MESSAGE.

SYNCHRONOUS INPUT:
 THE SIM IS ALWAYS IN ONE OF THREE STATES:
	A.)	IDLE
	B.)	RECEIVING A UNNUMBERED MESSAGE(ACK, NAK, ETC.).
	C.)	RECEIVING NUMBERED MESSAGE DATA.
 THE STATE IS SET BY THE PM BY SETTING INRCPV TO BE:
	A.)	INRC10
	B.)	INRC20
	C.)	INRC70
 WHEN THE SIM IS IN STATE C, AND ONLY THEN, INCOMING CHARS ARE PLACED
 IN CHUNKS RATHER THAN A FIXED BUFFER.
 THE SIM USES F10WC AND F10CA TO STORE THE DATA.
 WORD COUNT OVERFLOWS WILL CAUSE THE SIM:
	A.)	RESETS TO JUNK BUFFER
	B.)	TRANSFERS TO INTP40
	C.)	TRANSFERS TO INTP60
 WHEN THE RECEIVER IS IDLE AND ONE OF THE FOUR CHARS AT F10TCH IS
 FOUND IN AN INPUT STREAM THE SIM NOTIFIES THE PM BY BRANCHING TO:
	INTP00		WHEN FINDS CHAR AT F10TCH
	INTP10		WHEN FINDS CHAR AT F10TCH+1
	INTP20		WHEN FINDS CHAR AT F10TCH+2
	INTP30		WHEN FINDS CHAR AT F10TCH+3
 WHEN THE RECEIVER IS IN STATE B THE PM IS NOT NOTIFIED OF SPECIAL
 CHARS.
 WHEN THE RECEIVER IS IN STATE C THE SIM WILL NOTIFIY THE PM
 OF SPECIAL CHARS BY JMPING TO INTP70(CHAR IN INTMP1, ADR IN INTMP5);
 WHEN THE PM IS DONE WITH THE CALL TO INTP70 IT WILL RETURN TO INRC80.

>/END OF IFNZRO 0
/HERE AT INTERRUPT LEVEL TO SET RECEIVER TO IDLE MODE
INRCID,	0
	NLM1
	CDFINS			/WC IS IN FIELD 0
	DCA I	[F10WC
	NLM1
	TAD	RCVPTR		/POINT TO BEGINNING OF BUFFER
	DCA I	[F10CA		/SAVE
	TAD	(INRC10
	DCA	INRCPV		/INITIALIZE DP01 INPUT PIVOT
	CDFCNK			/BACK TO NORMAL FIELD
	JMP I	INRCID

/HERE AT INTERRUPT LEVEL WHEN RECEIVER HAS FOUND A SOH
INTP00,	TAD	(-7 		/HEADER IS ALWAYS 8 CHARS
	JMS	INTP41
	TAD	(INRC70		/WE ARE NOW RECEIVING NUMBERED MSG DATA
	DCA	INRCPV		/SET SIM MODE

	TAD	RCVPTR		/GET ADR OF MESSAGE HEADER
	JMS	GETLEN		/GET LENGTH OF MESSAGE
	TAD	(0002		/FUDGE FOR CRC
	DCA	F10TWC
	DCA	INTMP1		/INITIALIZE FOR INRC80
	TAD	(0010 		/DISPLACEMENT TO CHUNK COUNTER
	TAD	RCVPTR		/ADD TO START OF BUFFER
	DCA	INTMP2		/SAVE CHUNK COUNTER ADDRESS
	TAD	INTMP2		/GET CHUNK COUNTER ADDRESS
	DCA	CNTPNT		/STORE FOR INRC80
	DCA I	INTMP2		/CLEAR CHUNK COUNTER
	ISZ	INTMP2		/SKIP OVER CHUNK COUNTER TO LINK TO CHUNKS
	DCA I	INTMP2		/CLEAR LINK TO 1ST CHUNK
	JMP	INRC80


INTP20,			/SHOULDN'T HAPPEN
INTP30,			/SHOULDN'T HAPPEN !
/HERE AT INTERRUPT LEVEL WHEN RECEIVER DETECTS BEGINING OF UNNUMBERED MESSAGE = ENQ
INTP10,	TAD	(-7		/UNNUMBERED MESSAGES ARE ALWAYS 8 CHAR LONG

INTP31,	JMS	INTP41		/WAIT FOR REST OF MESSAGE FROM DECSYSTEM-10
INTP33,	NLM1
	DCA	WRKREQ		/SO NON-INTERRUPT LEVEL CODE WAKE UP
	TAD	(CTLSIZ		/ADVANCE TO NEXT CTL BUFFER
	TAD	RCVPTR
	TAD	(-RCVLIM
	SNA
	  TAD	(RCVQUE-RCVLIM
	TAD	(RCVLIM
	DCA	RCVPTR
	TAD	RCVPTR
	NEGATE
	TAD	RCVTKR
	SNA CLA			/DO WE HAVE TOO MANY MSGS READY
	  HLT
	JMS	INRCID		/SET RECEIVER TO IDLE STATE
	JMP	INTP42

/HERE AT INTERRUPT LEVEL WITH WC OVERFLOW ON UNNUMBERED MESSAGE
INTP40,	JMP I	INTP41
INTP41,	0
	CDFINS			/NEED TO SET WC AND CA IN FIELD 0
	DCA I	[F10WC		/SAVE LENGTH
	TAD	RCVPTR		/ADR OF BUFFER FOR HEADER
	DCA I	[F10CA		/SET BUFFER ADR FOR RECEIVER
	TAD	(INRC20
	DCA	INRCPV
	CDFCNK			/RESET NORMAL DATA FIELD
INTP42,
IFZERO FTDP01 <	DPSGRR >	/ENABLE RECEIVER
	JMP	INTDIS

/HERE AT INTERRUPT LEVEL WITH WC OVERFLOW ON NUMBERED MSG DATA
INTP60=INTP33		/JUST CALL CURRENT MSG DONE


INTP70=INTDIS		/NO SPECIAL CHAR HANDLING IN MIDDLE OF JUNK
/	***********************************************************
/	***********************************************************
/	***							***
/	***			DDCMP				***
/	***							***
/	***********************************************************
/	***********************************************************

/MESSAGE PROTOCOL
	SYN=226
	IDLE=SYN		/NO SPECIAL IDLE CHARACTER
	ENQ=005		/1ST CHAR IN UNNUMBERED MESSAGES
	DLE=220		/1ST CHAR IN BOOTSTRAP MESSAGES
	SOH=201		/1ST CHAR IN NUMBERED MESSAGES

/NUMBERED MESSAGES
/	SOH CC1 CC2 R N A0 BCC1 BCC2 DEV CNT TYPE DATA BCC3 BCC4
/	CC1&CC2 ARE TOTAL LENGTH OF DATA(BCC2 THRU BCC3 EXCLUSIVE)
/	CC1 IS LOWORDER 8BITS OF NUMB
/	R IS # OF LAST GOOD MESSAGE RECEIVED
/	N IS THIS MESSAGE NUMBER
/	A0 IS THE DESTINATION STATION ADR(ALWAYS 1)
/	BCC1 BCC2 IS THE CRC ON SOH THROUGH A0 INCLUSIVE
/	DATA IS ADR N TYPE MUMBLE, ETC(WHERE N IS LENGTH OF MUMBLE)
/	  N TYPE MUMBLE MAY BE REPEATED
/	BCC3 BCC4 ARE THE CRC OF BCC2 THRU BCC3 EXCLUSIVE
/	DEV IS THE DESTINATION DEVICE; 1 IS STATION
/	CNT(EXTENSIBLE) IS LENGTH OF (TYPE-DATA)
/	TYPE IS	1=INITIAL CONFIGURATION MESSAGE
/		2=CONNECT FOLLOWED BY:
/			DEVICE ADR(OR 0 FOR PICK ONE)
/			DEVICE TYPE
/			FEATURES
/		3=DISCONNECT
/		4=REJECT
/		5=ACCEPT
/		6=STATION GOING DOWN
/		7=REQUEST STATUS
/		10=STATUS MESSAGE
/		11=REQUEST MODE
/		12=SET MODE
/		13=DATA REQUEST BY RECORD
/		14=DATA REQUEST BY CHAR
/	DATA IS WHAT MAY FOLLOW TYPE
/	(CNT TYPE DATA) MAY BE REPEATED
/UNNUMBERED MESSAGES
	FILL=000		/FILL CHARACTER
	A0=1		/DESTINATION STATION ADR

/ACK:	ENQ	ACK	FILL	MSG#	FILL	A0	BCC1	BCC2
	ACK=001
/	MSG# IS LAST GOOD MSG RECEIVED

/NAK:	ENQ	NAK	RNAK	MSG#	FILL	A0	BCC1	BCC2
	NAK=002		/NEGATIVE ACKNOWLEDGE
/	RNAK=1	BCC ERROR
/	RNAK=3	REP RESPONSE
/	RNAK=10	SHORT TERM HIGH LEVEL EXCEPTION
/	RNAK=11	RECEIVER OVERRUN
/	RNAK=20	MESSAGE TOO LONG
/	RNAK=21	HEADER FORMAT ERROR
/	MSG# IS LAST GOOD MSG RECEIVED

/REP:	ENQ	REP	FILL	FILL	N	A0	BCC1	BCC2
	REP=003		/REPLY TYPE
/	N IS THE LAST MESSAGE# SENT

/RESET:	ENQ	RESET	FILL	FILL	N	A0	BCC1	BCC2
	RESET=4		/DC72NP WILL NOT SEND THIS TYPE/WILL RESPOND WITH START

/RESAK:	ENQ	RESAK	FILL	R	FILL	A0	BCC1	BCC2
	RESAK=5		/DC72NP WILL NOT SEND THIS TYPE/WILL RESPOND WITH START

/START:	ENQ	STRT	FILL	FILL	FILL	A0	BCC1	BCC2
	STRT=006		/START TYPE
/	THE NEXT NUMBERED MESSAGE TO BE SENT IS 1

/STACK:	ENQ	STACK	FILL	FILL	FILL	A0	BCC1	BCC2
	STACK=007		/START ACKNOWLEDGE
/	THE NEXT MESSAGE SENT, AND NEXT MESSAGE EXPECTED
/	ARE BOTH 1.

/BOOT:	DLE	CC1	CC2	R	N	A0	BCC1	BCC2	S1	S2	DATA	BCC3	BCC4

DEFINE T10ADJ Q <	XLIST
	TAD	Q
	TAD	(-T10LST	/CHECK FOR LAST BUF
	SNA
	  TAD	(T10BF1-T10LST-T10LEN	/ADJUST IF LAST
	TAD	(T10LEN+T10LST
	DCA	Q		/ADJUST & SAVE NEW VALUE
XLIST	>/END OF T10CHK

MSNMAX=377		/MAXIMUM MESSAGE NUMBER

/WHEN A MSG IS RECEIVED CORRECTLY AN ACK IS SENT BACK;
/ AN ACK IMPLIES ACK OF ALL LOWER NUMBERED MESSAGES
/WHEN A MSG IS RECEIVED INCORRECTLY A NAK MSG IS SENT BACK;
/ A NAK IMPLIES ACK OF ALL LOWER NUMBERED MSGS.
/HERE TO PROCESS MESSAGE RECEIVED FROM THE DECSYSTEM-10
RCVCHK,	DCA	CRC1
CRCXI1,	DCA	CRC2		/INITIALIZE CRC			########
	TAD	(-6
	DCA	TEMP3		/6 CHARS IN ALL MESSAGES
	NLM1
	TAD	RCVTKR
	DCA	AUTO1		/MESSAGE POINTER
RCVCK2,	TAD I	AUTO1
IFZERO	DP8ETR	<
	JMS	CRCALC		/PUT NEXT CHAR INTO CRC
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCRC		/TRACE AND ACCUM CRC
>/END OF IFNZRO	DP8ETR
	ISZ	TEMP3
	JMP	RCVCK2

IFZERO	DP8ETR	<
	NL4
	TAD	AUTO1
	DCA	TEMP5		/SAVE POINTER TO ADR OF CHUNK STRING
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCR2		/STASH CRC IN TRACE
>/END OF IFNZRO	DP8ETR
	TAD I	AUTO1
	NEGATE
	TAD	CRC2		/COMPARE HALF OF CRC
	SZA CLA
	JMP	BADCRC		/BRANCH IF BUM CRC
	TAD I	AUTO1
	NEGATE
	TAD	CRC1		/GET SECOND HALF OF CRC
	SZA CLA
	JMP	BADCRC		/BRANCH IF BUM
	TAD I	RCVTKR
	TAD	(-SOH
	SNA			/TEST FOR NUMBERED MESSAGE
	  JMP	RCVMSG
	TAD	(SOH-ENQ
	SZA CLA
	HLT			/BE SURE IS ENQ
	TAD	RCVTKR
	DCA	AUTO1
	TAD I	AUTO1		/GET MESSAGE TYPE CODE
	SPA SNA
	JMP	RCVGAG		/CHECK CODE LARGE ENOUGH
	TAD	(-10
	SMA
	JMP	RCVGAG		/CHECK FOR TOO LARGE
	TAD	(JMP I	RCVTAB+7
	DCA .+1
	7402			/DISPATCH ON MESSAGE CODE
RCVTAB,	RCVACK;	RCVNAK;	RCVREP;	RRESET;	RRSACK;	RCVSRT;	RCVSTK

	PAGE

/HERE WHEN RECEIVE AN ACK MESSAGE
RCVACK,	JMS	RCVRCK		/DO RIGHT THING BY MSG#
	JMP	RCVADV


/HERE WHEN RECEIVE A NAK MESSAGE
RCVNAK,	JMS	RCVRCK		/DO RIGHT THING BY MSG#
	TAD	T10AKR
	DCA	T10TKR		/RESET BUFFER TO SEND NEXT
	JMP	RCVADV

/HERE TO CHECK MSG# IN ACK OR NAK OR NUMBERED MSG
/ ADJUSTS QUEUE ETC.
RCVRCK,	0
	NL3
	TAD	RCVTKR
	DCA	TEMP2		/POINTER TO MSG#
	TAD I	TEMP2
	JMS	RCVRC8
	DCA	TEMP1		/SAVE ADJ #
	TAD	T10HSN
	JMS	RCVRC8
	NEGATE
	TAD	TEMP1
	SPA CLA
	JMP	RCVGAG		/IF NOT REASONABLE RESTART
RCVRC0,	TAD I	TEMP2
	NEGATE
	TAD	T10LAN		/COMPARE LAST ACKED & THIS
	SNA CLA
	JMP I	RCVRCK		/IF SAME DONE
	TAD	T10AKR
	NEGATE
	TAD	T10TKR
	SZA CLA
	  JMP	RCVRC1
	T10ADJ	T10TKR
RCVRC1,	TAD	T10LAN
	JMS	COUNT
	DCA	T10LAN		/ADJUST MSG #
	T10ADJ	T10AKR
	TAD	T10LAN
	DCA I	TEMP2
	TAD	(-REPTIM	/TIME TILL NEXT REP
	DCA	REPTCK
	JMP	RCVRC0
/FOLLOWING RETURNS LAN-N OR LAN-N-MSNMAX-1
RCVRC8,	0
	NEGATE
	TAD	T10LAN		/COMPARE TO LAST ACKED
	SMA SZA
	TAD	(-MSNMAX-1
	JMP I	RCVRC8

/HERE WHEN RECEIVE A REP MESSAGE
RCVREP,	NL3
	DCA	NAKFLG		/SEND NAK WITH REASON = 3
	JMP	RCVADV		/DONE WITH BLOCK

/HERE WHEN RECEIVE A RESET MESSAGE
RRESET,

/HERE WHEN RECEIVE A RESET ACKNOWLEDGE MESSAGE
RRSACK,
/HERE WHEN RECEIVE A MESSAGE WITH TYPE OUT OF RANGE(E.G. POLL)
RCVGAG,	IOF
	NL0			/CLEAR AC & INTERRUPTS
	TAD	(BMTMSG-1
	JMS	CTYEXC		/COMPLAIN TO OPERATOR
	JMP	INIALL		/RESTART STATION

/HERE WHEN RECEIVE A START MESSAGE
RCVSRT,	JMS	RVSTK2		/INITIALIZE RECVOK
	IOF			/TURN INTERRUPTS OFF
	NLM1			/FLAG TO SEND A STACK
	DCA	STACKF		/SET FLAG
	JMP	INISUM		/REINITIALIZE STATION

/HERE WHEN RECEIVE A STACK MESSAGE
RCVSTK,	JMS	RVSTK2		/INITIALIZE RECVOK
	DCA	STACKF		/FLAG WE ARE UP NOW
	JMP	RCVADV
RVSTK2,	0
/	NL4
/	TAD	RCVTKR
/	DCA	TEMP1		/NEXT MSG # WILL GET
/	NLM1
/	TAD I	TEMP1		/DECREMENT IT
/	AND	[0377
	NL0			/ZERO IS LAST MESSAGE RECEIVED
	DCA	RECVOK		/LAST # RECEIVED OK
	JMP I	RVSTK2
/HERE WHEN RECEIVE A NUMBERED MESSAGE
RCVMSG,	JMS	RCVRCK		/DO RIGHT THING BY RESPONSE FIELD
	NLM3
	TAD	AUTO1
	DCA	TEMP1		/POINTER TO MSG N#
	TAD	RECVOK
	JMS	COUNT
	NEGATE			/MAKE -# EXPECTED
	TAD I	TEMP1
	SZA CLA
	JMP	RCVFLU		/IF NOT EXPECTED DONE
CRCXI2,	DCA	CRC1		/				########
	DCA	CRC2		/INITILAIZE CRC FOR MESSAGE
	TAD I	TEMP5
	DCA	TEMP3		/ADR OF CHUNKS(IF ANY)
	TAD	RCVTKR		/GET ADR OF MESSAGE HEADER
	IOF
	JMS	GETLEN		/GET LENGTH OF MESSAGE
	ION
	NEGATE
	DCA	TEMP4		/AND SAVE DATA COUNT
	TAD	TEMP4
	DCA	TEMP2		/KEEP 2ND COPY OF COUNT
	JMP	RCMSG0

/HERE TO GET THE LENGTH FIELD FROM A MESSAGE HEADER
GETLEN,	0
	DCA	IAUTO1
	TAD I	IAUTO1
	DCA	INTMP1		/SAVE LOWORDER BITS
	TAD I	IAUTO1
	AND	(0007		/ONLY BELIVE 11BITS OF COUNT
IFZERO	PDP8I	<
	CLL RTL			/CAN'T ROTATE RIGHT
	CLL RTL			/THROUGH LINK THAT
	CLL RTL			/INTERRUPTS ZAP
>
IFZERO	PDP8E	<
	BSW
>
	CLL RTL
	TAD	INTMP1
	JMP I	GETLEN

	PAGE
RCMSG0,	JMS	GETCHR
	JMP	NRMNAK		/GET NEXT CHAR IF ANY
IFZERO	DP8ETR	<
	JMS	CRCALC
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCRC		/TRACE AND ACCUM CRC
>/END OF IFNZRO	DP8ETR
	ISZ	TEMP2
	JMP	RCMSG0		/LOOP BACK FOR REST OF DATA
	TAD	TEMP3		/GET ADR OF LAST DATA
	DCA	TEMP6		/SAVE IT
IFZERO	DP8ETR	<
	JMS	GETCHR
	  JMP	NRMNAK
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCR3		/GET CRC CHAR AND TRACE IT
>/END OF IFNZRO	DP8ETR
	NEGATE			/GET -CRC2
	TAD	CRC2		/GET LOW PART OF CRC
	SZA CLA
	JMP	BADCRC
IFZERO	DP8ETR	<
	JMS	GETCHR
	  JMP	NRMNAK
>/END OF IFZERO	DP8ETR
IFNZRO	DP8ETR	<
	JMS	ITRCR3		/GET CRC CHARACTER AND TRACE IT
>/END OF IFNZRO	DP8ETR
	NEGATE			/GET -CRC1
	TAD	CRC1		/GET HIGH ORDER PART OF CRC
	SZA CLA
	JMP	BADCRC
	NL4000			/LAST CHAR IN CHUNK FLAG
	TAD I	TEMP6
	SPA			/SKIP IF WAS ALREADY LAST CHAR IN CHUNK
	  DCA I	TEMP6		/SET FLAG ON CHAR
	NL0
	TAD	TEMP6		/GET ADR OF LAST CHAR AGAIN
	AND	[-CNKSIZ	/MAKE INTO CHUNK POINTER
	DCA	TEMP6
	NLM1
	TAD	TEMP5
	DCA	TEMP3		/STORE ADR OF CHUNK COUNT
	TAD I	TEMP6		/GET ADR OF CRC CHUNK IF NOT THIS ONE
	SNA			/SKIP IF THERE IS ONE FOR CRC
	  JMP	RCMSG1		/OTHERWISE SKIP OVER FOLLOWING
	JMS	FRECKS		/FREE CHUNK WITH CRC(MAYBE)
	DCA I	TEMP6		/CLEAR LINK TO CRC CHUNKS
	NLM1			/DECREMENT CHUNK COUNT
	TAD I	TEMP3
	DCA I	TEMP3
RCMSG1,
	TAD	RECVOK
	JMS	COUNT		/INCREMENT MSG#
	TAD	(4000
	DCA	RECVOK		/AND SAVE IT W FLAG TO ACK
	TAD I	TEMP5		/GET ADR OF 1ST CHUNK
	DCA	TEMP3		/SAVE ADR OF 1ST CHUNK
	JMS	GTCHR		/GET NCT
	DCA	RNCT		/STORE FOR A WHILE
	TAD	(10		/SELECT SNA/DNA PRESENT BIT
	AND	RNCT		/TURN OFF REST
	SNA			/SHOULD BE ON
	  JMP	NODNA		/SKIP OVER DNA,SNA GETTING
	JMS	GTCHR		/GET DNA
	JMS	GTCHR		/GET SNA
NODNA,
	DCA	RSNA		/SAVE IT FOR LATER
	JMS	GTCHR		/GET NCA
	JMS	GTCHR		/GET NCN
	NL0
	TAD	[7		/MASK OF TYPE BITS FOR NCT
	AND	RNCT		/TURN OFF ALL BUT LOW ORDER 3
	SNA			/SKIP IF UN-NUMBERED CONTROL
	  JMP	NMBRED		/HANDLE NUMBERED CONTROL OR DEVICE CONTROL
/ ONLY UN-NUMBERED CONTROL MESSAGE VALID IS NODE ID (6)
/IFNZRO	FTDEBUG	<
/	TAD	(-6		/CODE FOR NODE ID
/	SZA			/SKIP IF OK
/	  HLT			/HALT IF NOT
/>/END OF IFNZRO	FTDEBUG
	JMS	GETEXN		/GET NODE NUMBER
	DCA	RNOD		/STORE IT
	JMP	RCVFLU		/FLUSH IT AND CONTINUE BIG LOOP
NMBRED,	JMS	GETEXN		/GET DLA
	SZA			/TEST IF NUMBERED CONTROL
	  JMP	DVCTLM		/NO, DEVICE CONTROL
/ DLA OF ZERO MEANS NCS NUMBERED CONTROL MESSAGE
/ LEGAL ONES FOR 72 ARE:
/	CONNECT (1)
/	DISCONNECT (2)
/	NEIGHBORS (3) [ONLY FROM 72'S NEIGHBOR]
/	DATA REQUEST (6)
/	REQUEST CONFIG (4)
	JMS	GETEXN		/GET COUNT
	NEGATE
	DCA	TEMP4		/SAVE IN TEMP4
	JMS	GTCHR		/GET TYPE
	AND	[7		/CLEAR ALL BUT LOW ORDER
	TAD	(JMP I NBRDSP	/ADD BEGINNING OF TABLE+INSTRUCTION
	DCA	NBRJMP		/STORE DISPATCH ADDRESS
NBRJMP,	0			/DISPATCH

NBRDSP,	RCVKRD			/0 IS ILLEGAL
	RCVCON			/1 IS CONNECT
	RCVDIS			/2 IS DISCONNECT
	RCVNEI			/3 IS NEIGHBORS
	RCVRQC			/4 IS REQ CONFIG
	RCVFLU			/5 (CONFIG) IS IGNORED
	IFNZRO	CDRN	<
	RCVDRQ			/6 IS DATA REQUEST
>/END OF IFNZRO	CDRN
	IFZERO	CDRN	<
	RCVFLU			/6 (DATA REQUEST) INVALID UNLESS CDR
>/END OF IFZERO	CDRN
	RCVFLU			/7 (STA. CTL) IS IGNORED
/HERE TO ACCUMULATE CRC
/ ALGORITHM IS:
/	XOR	C,CRC
/	ANDI	C,377
/	LSH	CRC,-10
/	XOR	CRC,TAB(C)

CRCALC,	0

/XOR	C,CRC
	DCA	TEMP1
	TAD	TEMP1
	AND	CRC2
	CMA IAC
	CLL RAL
	TAD	TEMP1
	TAD	CRC2

/ANDI	C,377
/	AND	[0377		/8 BITS ONLY

/LSH CRC,-10 & XOR CRC,TAB(C)
	TAD	(CRCTAB
	DCA	TEMP1
	TAD I	TEMP1
	AND	CRC1
	CMA IAC
	CLL RAL
	TAD I	TEMP1
	TAD	CRC1
	DCA	CRC2
	TAD	(400
	TAD	TEMP1
	DCA	TEMP1
	TAD I	TEMP1
	DCA	CRC1

CRCRET,	JMP I	CRCALC
DOWN2,	TAD	(RCVDSP+1-SNATAB/POINT TO RCVDSP ENTRY
	DCA	TEMP1		/STORE ADDRESS
	TAD	(RCVKRD		/UN-USED VALUE
	DCA I	TEMP1		/NOW THIS CONNECTION IS AVAIL
	JMP	NEIG13		/RETURN TO LOOP
	PAGE
/HERE TO GET AN EXTENSIBLE NUMBER
/ CALL	JMS	GETEXN	WITH TEMP3 POINTING TO THE STRING OF CHUNKS
RCVADL,				/HERE WHEN YOU GET A REQUEST TO AUTODIAL
RCVKRD,	HLT			/HERE WHEN YOU GET VARIOUS FLAVORS OF GARBAGE
GETEXN,	0
	JMS	GTCHR
	DCA	TEMP1
	TAD	TEMP1
	AND	(0200		/MASK OFF EXT BIT
	SNA CLA	
	JMP	GETEX2
	JMS	GTCHR
	CLL RTL
	CLL RTL
	SPA
	  HLT
	CLL RTL
	CLL RAL
	TAD	(-200
GETEX2,	TAD	TEMP1
	JMP I	GETEXN

/HERE WHEN RECEIVE A DISCONNECT
RCVDIS,	JMS	GTCHR		/GET ADR OF DEVICE
	TAD	(CTRLTB-1
	DCA	TEMP1
	TAD I	TEMP1
IFNZRO FTDEBUG <
	SNA
	  HLT
>/END OF IFNZRO FTDEBUG
	DCA	DDB
	TAD	DDB
	TAD	(DEVSTS
	DCA	DDBSTS
IFNZRO FTDEBUG <
	NL2000
	AND I	DDBSTS
	SNA CLA
	  HLT			/NOT CONNECTED
>/END OF IFNZRO FTDEBUG
	TAD I	DDBSTS
	AND	(4777
	TAD	(1000		/BIT TO SEND AN ACCEPT
	DCA I	DDBSTS
	DCA I	TEMP1		/NO LONGER CONNECTED
	TAD	TEMP1
	TAD	(RCVDSP-CTRLTB+1
	DCA	TEMP1
	TAD	(RCVKRD
	DCA I	TEMP1
	JMP	RCVFLU		/DONE WITH MESSAGE
/HERE WHEN RECEIVE A CONNECT MESSAGE
RCVCON,	JMS	GETEXN		/GET DLA
	SNA			/CHECK FOR 0
	  JMP	RCVCN6		/YES SO MAKE ONE
/ HERE WHEN DLA IS NON-ZERO; THAT MEANS A CONNECT CONFIRM.
/ HOWEVER, DC72 NEVER DOES A CONNECT, SO SHOULDN'T HAPPEN.
	HLT
RCVCN2,	
	JMS	GETEXN		/GET SLA
	DCA	TEMP2		/STORE IT
	TAD	(DEVN		/LENGTH OF RCVDSP TABLE
	TAD	TEMPA		/ADD RCVDSP ENTRY POINTER
	DCA	TEMP1		/STORE ADDRESS FOR SLA
	TAD	TEMP2		/PICK UP SLA
	DCA I	TEMP1		/STASH IT
	TAD	(DEVTYP-1	/GET ADR OF DEVICE TYPE TABLE
	DCA	AUTO1
	TAD	(-CTRLN		/NUMBER OF POSSIBLE TYPES
	DCA	TEMPD		/NUMBER OF POSSIBLE TYPES
	JMS	GTCHR		/GET OBJECT TYPE (ONLY ONE BYTE)
/ LEGAL ARE 1=TTY,1=CARD READER,3=LINE PRINTER
RCVCN4,	TAD I	AUTO1
	SNA
	  JMP	RCVCN5		/THIS IS THE ONE WE NEEDED
	ISZ	AUTO1		/SKIP DISPATCH ADR
	ISZ	TEMPD		/HAVE CHECK ALL POSSIBLE ?
	  JMP	RCVCN4		/NO SO KEEP ON CHECKING
	JMP	BADTYP		/SEND DISCONNECT
RCVCN5,	TAD I	AUTO1
	DCA	TEMPB
	TAD	(-CONTTY	/SEE IF TTY
	TAD	TEMPB		/WE ARE DISPATCHING TO
	SNA CLA			/SKIP IF NOT
	  JMP	RCVCNT		/HANDLE TTY CASE
	JMS	SKPEXN		/SKIP PROCESS ID FIELD
RCVCN0,
	JMS	GETEXN		/GET OBJECT TYPE OF SENDER
	JMS	SKPEXN		/SKIP HIS PROCESS ID
	JMS	GETEXN		/MAX MESSAGE LENGTH
	DCA	TEMP1		/STORE
	TAD	(DEVN
	TAD	(DEVN
	TAD	TEMPA		/DISPATCH ADDRESS
	DCA	TEMP2		/STASH
	TAD	TEMP1		/GET MAX LENGTH
	DCA I	TEMP2		/STORE IT
	TAD	TEMP2		/GET ADDRESS
	TAD	(DEVN		/POINT TO NEXT TABLE
	DCA	TEMP2		/STORE IT
	TAD	RSNA		/GET SNA
	DCA I	TEMP2		/STORE IT
	JMP I	TEMPB		/GO TO DEVICE DEPENDENT CONNECT
RCVCNT,	JMS	GETEXN		/GET TTY NUMBER
	DCA	TTYNO
	JMP	RCVCN0		/CONTINUE

TTYNO,	-1
CONTTY,	TAD	(RCVTTY		/DISPATCH ADDRESS
	DCA I	TEMPA		/SAVE IT
	TAD	TTYNO
	JMS	TDBCHK		/CHECK TTY RANGE
	TAD	(DDBTAB
	DCA	TEMPC		/PROPER ENTRY
	TAD I	TEMPC		/PROPER DDB
	JMP	CONDEV
	IFNZRO	CDRN	<
CONCDR,	TAD	(RCVCDR		/DISPATCH ADDRESS
	DCA I	TEMPA		/INTO TABLE
	TAD	(CDRBLK		/GET DDB ADDRESS
	JMP	CONDEV		/DO REST
>/END OF IFNZRO	CDRN
	PAGE
/HERE TO FIND A VACANT SLOT FOR A CONNECT
RCVCN6,	TAD	(-DEVN
	DCA	TEMP2
	TAD	(RCVDSP+1
	DCA	TEMPA		/BEGINNING OF DISPATCH TABLE + 1
RCVCN7,	TAD I	TEMPA		/GET DISPATCH ADDRESS
	TAD	(-RCVKRD	/IS IT UNUSED?
	SNA CLA			/SKIP IF NOT
	  JMP	RCVCN2		/YES, WE'VE FOUND ONE
	ISZ	TEMPA		/ADVANCE TO NEXT DISPATCH ENTRY
	ISZ	TEMP2		/HAVE WE CHECKED ALL SLOTS ?
	  JMP	RCVCN7
	JMP	TOOMNY		/SEND DISCONNECT

	IFNZRO	LPTN	<
/HERE ON CONNECT FOR LPT
CONLPT,	TAD	(RCVLPT		/GET WHERE TO GO ON MESSAGE
	DCA I	TEMPA		/STORE IN RCVDSP TABLE
	TAD	(LPTBLK		/POINT TO DEVICE BLOCK
	JMP	CONDEV		/CONTINUE (I.E. SET CONNECT AND NEED-TO-ACCEPT BITS)
>/END OF IFNZRO	LPTN
DVCTLM,			/DEVICE CONTROL MESSAGE
/ AC HAS DLA IN IT
	ZZ=CTRLN
	ZZ=DEVN
	TAD	(-ZZ		/NEGATIVE OF (NO. OF ENTRIES+1)
	SMA SZA
	  JMP	RCVKRD		/OUT OF RANGE
	TAD	(RCVDSP+ZZ	/POINT TO DISPATCH TABLE ENTRY
	DCA	TEMP1		/SAVE IT
	TAD I	TEMP1		/GET DISPATCH ADDRESS
	DCA	TEMP2		/SAVE IT
	TAD	TEMP1		/DISPATCH ADDRESS
	TAD	(-ZZ-1		/POINT TO DDB ADDRESS
	DCA	TEMP1		/SAVE ADDR OF DDB ADDRESS
	TAD I	TEMP1		/GET DDB ADDRESS
	DCA	DDB		/STORE
	TAD	RNCT		/GET NCT
	AND	[40		/SEE IF INTERRUPT MESSAGE
	SNA CLA			/SKIP IF YES
	  JMS	DATDEC		/DECREMENT DATA REQUESTS
	JMS	GETEXN		/GET COUNT
	NEGATE
	DCA	TEMP4		/SAVE MINUS COUNT
	JMS	GETEXN		/GET DEVICE CTL MESSAGE TYPE
	JMP I	TEMP2

/DEVICE INDEPENDENT PORTION OF CONNECT
/ CALL WITH DEVICE BLOCK IN AC
CONDEV,	DCA	DDB		/SAVE DEVICE ADR
	NLOAD	DEVSTS
	TAD	DDB
	DCA	DDBSTS
	NLOAD	DEVRNN		/GET DISP OF RESTRICTED NODE NUMBER
	TAD	DDB		/IN THIS DDB
	DCA	TEMP2		/STORE ADDRESS
	TAD I	TEMP2		/GET RNN
	SNA			/SKIP IF NOT ZERO
	  JMP	CONANY		/ZERO MEANS ANYONE CAN CONNECT
	TAD	RSNA		/GET THIS NODE
	SZA CLA			/SKIP IF MATCHES
	  JMP	INUSE		/ELSE PRETEND ALREADY CONNECTED
CONANY,

	TAD	(CONBIT+1000	/CONNECTED AND ACCEPT BITS
	AND I	DDBSTS
	SZA CLA
	  JMP	INUSE		/DEVICE NOT AVAILABLE

	Q=DEVDRQ-DEVSTS
	NLOAD	Q
	TAD	DDBSTS
	DCA	TEMP2
	DCA I	TEMP2		/CLEAR DATA REQUESTS
	ISZ	TEMP2		/ADVANCE TO DEVDDC
	DCA I	TEMP2		/CLEAR DDCMP STATUS
	TAD	(4776		/MASK TO CLEAR CONNECT & ACCEPT & EOF BITS
	AND I	DDBSTS
	TAD	(3001		/CONNECT BIT & ACCEPT BIT & SEND STATUS
	DCA I	DDBSTS

	TAD I	DDB		/GET OLD DEVICE ADR
	AND	(7700		/STRIP IT
	TAD	TEMPA		/GET DISPATCH ADDRESS
	TAD	(-RCVDSP	/MAKES CONNECT CODE
	DCA I	DDB		/SAVE ADR

	TAD	TEMPA		/GET DISPATCH ADDRESS
	TAD	(-DEVN-1
	DCA	TEMP1
	TAD	DDB
	DCA I	TEMP1
	JMP	RCVFLU
IFNZRO LPTN <
RCVLPT,	NL0			/IGNORE MESSAGE TYPE
	TAD I	TEMP5		/GET ADR OF FIRST CHUNK IN MESSAGE
	DCA	AUTO1		/POINTER TO SHUFFLE TO
	NL6			/POINT TO COUNT
	TAD I	TEMP5
	DCA	TEMP3
RCVLP1,	ISZ	TEMP3
	TAD I	TEMP3
	DCA I	AUTO1		/PUT NEXT CHAR BACK INTO CHUNK
	TAD I	TEMP3		/GET CHAR AGAIN
	SMA CLA
	  JMP	RCVLP1

	IOF
	TAD I	(LPTBLK+DEVOAD	/GET CURRENT OUTPUT CHAR ADR
	SZA CLA			/IS THERE ONE ?
	  JMP	RCVLP3		/YES
	TAD I	TEMP5		/ADR OF NEW FIRST CHUNK
	DCA I	(LPTBLK+DEVOAD
	JMP	RCVLP5
RCVLP3,	TAD I	(LPTBLK+DEVOLC	/GET ADR OF LAST CHUNK
	DCA	TEMP1		/SAVE IT
	TAD I	TEMP5		/GET ADR OF 1ST CHAR WE ARE ADDING
	DCA I	TEMP1		/LINK INTO OUTPUT CHUNKS
RCVLP5,	TAD	TEMP6		/GET ADR OF LAST CHAR
	DCA I	(LPTBLK+DEVOLC	/SET NEW LAST CHUNK ADR
	JMP	RCVLP6		/GO UPDATE CHUNK COUNT
>/END OF IFNZRO LPT
IFNZRO	TTYN	<
IFZERO	FTDC02F	<
DISSN1,	DISCD1
	JMP	DISSN2
>/END OF IFZERO	FTDC02F
>/END OF IFNZRO	TTYN
	PAGE
IFNZRO CDRN <
/HERE WHEN RECEIVE A MESSAGE FOR THE CDR
/ REQUEST STATUS 7
/ REQUEST MODE 11
/ SET MODE 12
/ DATA REQUEST BY RECORD 13
/ NEGATIVE DATA REQUEST 15
RCVCDR,	TAD	(-3		/SEE IF STATUS
	SNA
	  JMP	RCDSTA		/HANDLE STATUS
	TAD	(-1		/SEE IF CONTINUE
	SZA			/SKIP IF YES
	  JMP	RCVFLU		/IGNORE OTHER MSGS
RCDCON,				/HERE TO PROCESS CONTINUE
	TAD	(CDRBLK
	DCA	INTDDB
	NL3777
	AND I	(CDRBLK+DEVDDC
	JMS	ISTDDC
	JMP	RCVFLU
RCVDRQ,				/HERE WHEN RECEIVE DATA REQUEST
	IFZERO	CDRN	<
	JMP	RCVFLU		/IGNORE EXCEPT FOR CARD READER
>/END OF IFZERO	CDRN
	IFNZRO	CDRN	<
	JMS	GETEXN		/GET DLA
	TAD	(RCVDSP		/ADD START OF DISPATCH TABLE
	DCA	TEMPA		/SAVE THIS ENTRY ADDRESS
	TAD I	TEMPA		/GET THIS ENTRY
	TAD	(-RCVCDR	/IS IT CDR?
	SZA CLA
	  JMP	RCVFLU		/NO, IGNORE
/	JMP	RCDDRQ		/GO DO DATA REQUEST
>/END OF IFNZRO	CDRN
RCDDRQ,	JMS	GETEXN		/GET DATA REQUEST
	TAD I	(CDRBLK+DEVDRQ
	DCA I	(CDRBLK+DEVDRQ
	JMP	RCVFLU		/DISPOSE OF MESSAGE
>/END OF IFNZRO CDR
RCDSTA,	JMS	GTCHR		/GET TYPE
	TAD	(-2		/CLEAR BITS?
	SZA CLA
	  JMP	RCVFLU
	TAD	[DEVDDC
	TAD	DDB
	DCA	TEMP6
	JMS	RCTBIT
	DCA I	TEMP6
	JMP	RCVFLU

IFNZRO PLTN <
RCVPLT,	HLT
>/END OF IFNZRO PLT

IFNZRO PTPN <
RCVPTP,	HLT
>/END OF IFNZRO PTP

RCTBIT,	0
	JMS	GETEXN		/GET BITS 10 WANTS TO CHANGE
	DCA	TEMP1		/SAVE THE BITS
	TAD	TEMP1		/GET CHANGE BITS AGAIN
	CMA			/COMPLEMENT
	AND I	TEMP6		/GET DDCMPSTATUS WORD WITHOUT BITS
	JMP I	RCTBIT
RCVTT0,	JMS	GETCHR
	  JMP	RCVFLU
	NEGATE
	IAC
	DCA	TEMP4
	JMS	GTCHR
	JMP	RCVTT6
RCVTTY,	
	DCA	TEMP1
	NLOAD	DEVSTS
	TAD	DDB
	DCA	DDBSTS
	TAD	DDB
	IAC
	DCA	TEMP7		/STORE DEVOAD ADDRESS
	TAD	TEMP4		/GET COUNT
	IAC			/SUBTRACT ONE FOR TYPE
	DCA	TEMP4
	NLOAD	DEVDDC-DEVSTS
	TAD	DDBSTS
	DCA	TEMP6		/STORE DEVDDC ADDRESS
	NLOAD	DEVOLC		/OFFSET FOR DEVOLC
	TAD	DDB		/MAKE ABSOLUTE ADR
	DCA	TEMP8		/SAVE POINTER TO DEVOLC
	NLOAD	DEVCHK
	TAD	DDB
	DCA	TEMPA		/STORE ADR OF CHUNK COUNT
	TAD	TEMP1		/GET TYPE
RCVTT6,	TAD	(-1		/TEST TYPE
	SZA			/SKIP IF DATA
	  JMP	RCVTTC		/NO, CONTROL OR STATUS
RCVTT1,	JMS	GTCHR		/GET THE NEXT CHARACTER FROM MESSAGE
	DCA	TEMP1		/SAVE IT
	IOF			/INTERRUPTS OFF WHILE WE CHANGE THINGS
	TAD I	TEMP7		/GET DEVOAD
	SZA CLA			/SKIP IF NO OUTPUT CHUNKS YET
	  JMP	RCVTT2		/ALREADY HAVE SOME CHUNKS
	JMS	ERSGET		/GET A CHUNK
	DCA I	TEMP7		/SET DEVOAD
	TAD I	TEMP7
	DCA I	TEMP8		/SET DEVOLC
	ISZ I	TEMPA		/INCREMENT CHUNK COUNT
	  NOP			/MAY SKIP
RCVTT2,	NL1
	TAD I	TEMP8		/GET DEVOLC
	AND	[CNKSIZ-1
	SZA CLA			/WAS THAT LAST SLOT IN CHUNK ?
	  JMP	RCVTT3		/NO
	TAD I	TEMP8		/GET DEVOLC
	AND	[-CNKSIZ	/MAKE INTO LINK ADR
	DCA	TEMP2		/SAVE LINK ADR
	JMS	ERSGET		/GET ANOTHER CHUNK
	DCA I	TEMP2		/SET LINK IN PREVIOUS CHUNK
	TAD I	TEMP2
	DCA I	TEMP8		/SET DEVOLC
	ISZ I	TEMPA		/INCREMENT COUNT OF CHUNKS
	  NOP			/MAY SKIP
RCVTT3,	TAD I	TEMP8		/GET DEVOLC
	DCA	TEMP2
	NLOAD	3777		/MASK FOR LAST CHARACTER BIT
	AND I	TEMP2		/STRIP LAST-CHAR BIT
	DCA I	TEMP2		/AND RESTORE TO CHUNK
	ISZ	TEMP2		/ADVANCE TO NEXT SLOT
	NLOAD	4000		/MAKE LAST-CHAR BIT
	TAD	TEMP1		/ADD CHARACTER
	DCA I	TEMP2		/AND PUT INTO CHUNK
	ISZ I	TEMP8		/ADVANCE DEVOLC
	ION
	ISZ	TEMP4		/COUNT CHAR OUT OF THE MESSAGE
	  JMP	RCVTT1		/KEEP GETTING CHARACTERS
	JMS	TTYGO		/START TTY IF IT NEEDS TO BE
	JMP	RCVTT0		/LOOP BACK FOR MORE KRUD
	PAGE
/TYPE 2 = ECHO PIPELINE MARKER
RCVEPL,	TAD	(LDBEPL		/OFFSET FOR PIPELINE MARKER
	TAD	DDB
	DCA	TEMP1		/SAVE POINTER TO MARKER
	JMS	GTCHR		/GET THE MARKER FROM THE MESSAGE
	NEGATE			/SO WE CAN COMPARE
	TAD I	TEMP1		/ADD IN WHAT WE SAID LAST
	AND	[0177		/SEVEN BITS ONLY
	SZA CLA
	  JMP	RCVTT0		/NOT THE SAME SO NO SPECIAL ACTION
	TAD I	AUTO1		/GET DEVBF1
	SZA CLA			/ARE WE HOLDING ANY INPUT CHARS ?
	  JMP	RCVTT0		/YES SO CAN'T ENTER LOCAL ECHO MODE
	NLOAD	7776		/MASK FOR DEFERRED ECHO BIT
	IOF
	AND I	TEMP6		/GET DDCMP STATUS WORD
	DCA I	TEMP6		/RESTORE STATUS WORD
	JMP	RCTRQS		/AND SEND STATUS TO 10

/TYPE 4 = CHARACTER GOBBLER
RCVGOB,
RCGOB1,	TAD	DDB
	IOF			/DISABLE INTERRUPTS FOR A WHILE
	DCA	INTDDB		/SETUP FOR CALL TO IGTOCH
	JMS	IGTOCH		/GET ANY OUTPUT CHARS
	  JMP	RCVTT0		/LOOP BACK FOR MORE MSGS
	ION
	CLA
	JMP	RCGOB1

/TYPE 5 = SET BITS
RCVSBT,	JMS	RCTBIT		/SET UP STUFF
	TAD	TEMP1		/ADD BITS
	DCA I	TEMP6
	JMP	RCTRQS		/SEND COPY OF UPDATED STATUS TO 10

/TYPE 6 = CLEAR BITS
RCVCBT,	JMS	RCTBIT		/SET UP STUFF
	DCA I	TEMP6		/RESTORE STATUS WORD
	JMS	TTYGO		/IN CASE CLEARED OUTPUT STOPPED BY XOF BIT
/	JMP	RCTRQS		/AND SENDCOPY OF UPDATED STATUS TO 10

/TYPE 7 = REQUEST STATUS
RCTRQS,	IOF			/DISABLE INTERRUPTS FOR A WHILE
	NLOAD	7776		/MASK FOR NEED TO SEND STATUS BIT
	AND I	DDBSTS		/CLEAR BIT FROM STATUS WORD
	IAC			/ADD BIT TO WORD
	DCA I	DDBSTS
	JMP	RCVTT0		/THEN ON TO NEXT SUBMESSAGE

/TYPE 10 = CHARACTERISTICS
RCVCHR,	TAD	(LDBFIL-1	/RELATIVE ADR OF FILLER BLOCK
	TAD	DDB
	DCA	AUTO1
	TAD	(-6		/NUMBER OF FILLERS
	DCA	TEMP4
RCVCH2,	JMS	GETEXN		/GET NEXT FILLER
	SNA			/SKIP IF NOT ZERO
	  JMP	RCVCH3		/GO RIGHT TO NEGATE
	TAD	(37		/ROUND OFF AND ADD 16
	CLL RTR			/DIVIDE BY 4
	CLL RTR			/MAKES DIVIDE BY 16
	AND	[0377		/EIGHT BITS ONLY
RCVCH3,
	NEGATE
	DCA I	AUTO1		/SET NEXT FILLER
	ISZ	TEMP4
	  JMP	RCVCH2		/ON TO THE NEXT FILLER
	TAD	(LDBWID
	TAD	DDB
	DCA	TEMP4
	JMS	GETEXN		/GET RECEIV SPEED
	JMS	GETEXN		/GET TRANSMIT SPEED
	JMS	GETEXN		/GET TTY WIDTH
	DCA I	TEMP4		/SAVE TTY WIDTH
	JMS	GETEXN		/GET COLUMN WHERE BLANKS TURN TO CRLF
	JMS	GETEXN		/GET 2741 TYPING ELEMENT
	JMS	GETEXN		/GET 2741 BITS
	JMP	RCVTT0		/ON TO NEXT SUBMESSAGE
RCVNRM,	0			/HERE BECAUSE RAN OUT OF ROOM FOR A MESSAGE
NRMNAK,	ISZ	RCVNRM		/COUNT TIMES WE NAKED BECAUSE OF NO ROOM
	  NOP
	TAD	(10
	DCA	NAKFLG		/REASON FOR NAK
	JMP	RCVFLU

RCVBCR,	0			/COUNT OF BLOCKS RECEIVED WITH A BAD CRC
/HERE TO NAK A MSG(NUMBERED OR UNNUMBERED BECAUSE OF BAD CRC)
BADCRC,	NL1
	DCA	NAKFLG		/SEND A NAK TO 10
	ISZ	RCVBCR
	SKP			/COUNT BAD CRC'S RECEIVED
	JMS	MYPTCH		/EVERY 4096 BAD CRC'S
	TAD I	RCVTKR
	TAD	(-SOH		/CHECK FOR NUMBERED MESSAGE TYPE
	SNA CLA			/SKIP IF NOT NUMBERED
RCVFLU,	TAD I	TEMP5
	JMS	FRECKS		/IF NUMBERED FREE CHUNKS
	JMP	RCVADV

/HERE WHEN SUBMESSAGE IS CONTROL
RCVTT5,	TAD	DDB		/DEVICE BLOCK ADR
	TAD	[DEVBF1-1	/MAKE AUTO-INCREMENT POINTER TO BUFFERS
	DCA	AUTO1
	JMS	GTCHR		/GET STATUS TYPE
	TAD	(-6		/HIGHEST LEGAL MESSAGE
	SMA			/SKIP IF MESSAGE TYPE IN RANGE
	  JMP	RCVKRD		/COMPLAIN
	TAD	(JMP I TTYDSP+6
	DCA	.+1
	7402
TTYDSP,	RCVEPL
	RCVGOB
	RCVCHR
	RCVADL
	RCVXOF

RCVTTC,	TAD	(-2		/SEE IF STATUS
	SZA CLA			/SKIP IF YES
	  JMP	RCVTT5		/MUST BE CONTROL
	JMS	GTCHR		/STC
	TAD	(JMP I	TTSDSP
	DCA	.+1
	7402
TTSDSP,	RCVKRD			/TYPE 0=UNKNOWN
	RCVSBT			/TYPE 1=SET BITS
	RCVCBT			/TYPE 2=CLEAR BITS
	PAGE
/HERE WHEN DONE WITH A MESSAGE(NUMBERED OR UNNUMBERED)
RCVADV,	NL0
	IOF
	TAD	(CTLSIZ
	TAD	RCVTKR		/ADVANCE TO NEXT SLOT
	TAD	(-RCVLIM
	SNA			/CHECK FOR OUT OF RANGE
	TAD	(RCVQUE-RCVLIM
	TAD	(RCVLIM		/ADJUST
	DCA	RCVTKR		/SAVE NEW SLOT ADR
	JMP	LOOP		/REENTER HUGE LOOP

/SUBROUTINE TO PUT OUT BEGINNING OF NCS MESSAGE
/ NOTE -- LEAVES ADR IN TEMB
NCSBEG,	0
	JMS	NCSBG		/BEGINNING
	JMS	SNDCHR		/ZERO DLA
	JMP I	NCSBEG		/RETURN
NCSBG,	0			/BEGINNING OF NCS MESSAGE
/ AC HAS NCT SUPPLIED BY CALLER
	JMS	SNDCHR		/PUT INTO MESSAGE
	TAD I	DDB		/GET 1ST WORD OF DDB
	AND	(0077		/CLEAR LEFT HALF
	DCA	TEMPB		/SAVE LINK NUMBER (OURS)
	TAD	TEMPB		/GET IT BACK
	TAD	(SNATAB-1	/GET DESTINATION NODE ADDRESS
	DCA	TEMPA		/SAVE ADDRESS
	TAD I	TEMPA		/GET DNA
	JMS	SNDCHR		/PUT INTO MESSAGE
	Z=OURNNM&177		/OUR NODE NUMBER
	TAD	(Z
	JMS	SNDCHR		/SNA
	JMS	SNDCHR		/NCA
	JMS	SNDCHR		/NCN
	JMP I	NCSBG		/RETURN

NCSDLA,	0			/SEND DLA
	TAD	TEMPB		/INDEX INTO TABLE
	TAD	(SLATAB-1	/GET LINK ADDRESS
	DCA	TEMPA
	TAD I	TEMPA		/DLA
	JMS	SNDEXN
	JMP I	NCSDLA		/RETURN
/HERE WHEN SYNCHRONOUS TRANSMITTER IS IDLE TO TRY TO START IT
/ FIRST SEE IF WE NEED TO SEND A START OR STACK MESSAGE
/ THEN SEE IF WE NEED TO SEND A NAK MESSAGE
/ THEN SEE IF WE HAVE A NUMBERED MESSAGE TO SEND
/ THEN SEE IF WE NEED TO SEND AN ACK
/ THEN SEE IF WE SHOULD SEND A REP

XSTART,	JMS	XSTRT0		/SET UP TO SEND A CTL MESSAGE
	TAD	(SYNBUF-1	/POINT TO ONE BEFORE SYN'S
	DCA	T10NCA		/ADR OF MESSAGE
	TAD	(-10-NUMSYN	/NEGATIVE OF NUMBER OF SYN'S
	DCA	T10NWC		/NEXT WC
	TAD	STACKF		/GET STACK FLAG (-1 FOR STACK, -2 FOR START)
	SPA CLA
	  JMP	SNDSTK		/NEED TO SEND START OR STACK
	TAD	NAKFLG
	SZA CLA
	JMP	SNDNAK		/CHECK FOR NEED NAK
	TAD	T10TKR
	NEGATE
	TAD	T10PTR		/CHECK FOR RETRANSMISSIONS
	SZA CLA			/DO WE HAVE A MESSAGE TO RETRANSMIT
	  JMP	SNDMSG		/IF HAVE A MESSAGE SEND IT
	TAD	T10PTR
	TAD	(-T10LST	/SEE IF TIME TO WRAP AROUND
	SNA
	  TAD	(T10BF1-T10LST-T10LEN
	TAD	(T10LEN+T10LST
	NEGATE
	TAD	T10AKR		/COMPARE TO LAST ACKED
	SNA CLA			/HAVE SENT ALL WE CAN ?
	  JMP	XSTRT9
	TAD	DISREA		/SEE IF WE NEED TO SEND DISCONNECT
	SZA CLA			/ZERO MEANS NO
	  JMP	XDISCN		/SEND IT
	TAD	CONSNA		/SEE IF NEED TO SEND CONFIG
	SZA CLA			/SKIP IF NO,
	  JMP	XSCONF		/YES, SEND IT
	JMS	DISCHK		/SEE IF NEED TO SEND DISCONNECT
	TAD	(FIRDDB		/GET ADR OF FIRST DDB
XSTRT1,	DCA	DDB		/SAVE ADR OF DEVICE BLOCK
	NLOAD	DEVSTS
	TAD	DDB
	DCA	DDBSTS		/SAVE ADR OF STATUS WORD
	TAD	(3000		/MASK FOR CONNECT & ACCEPT BIT
	AND I	DDBSTS
	SNA			/CHECK TO SEE IF 10 KNOWS ABOUT DEVICE
	  JMP	XSTRT8		/LEAVE THIS ORPHAN ALONE
	AND	(1000		/DO WE NEED AN ACCEPT ?
	IOF
	SNA CLA			/SKIP IF WE HAVE TO SEND CONNECT CONFIRM OR DISCONNECT
	  JMP	XSTRT2		/NO, TRY SOMETHING ELSE
	NL2000
	AND I	DDBSTS
	SNA CLA
	  JMP	XSDIS0
	TAD I	DDBSTS		/GET STATUS
	AND	(6777		/TURN OFF NEED-TO-ACCEPT BIT
	DCA I	DDBSTS		/UPDATE STATUS
	JMS	XSTMSG		/SET UP TO SEND A MESSAGE
	JMS	FEAPNT		/POINT TO FEATURES
	TAD	(10		/NCT
	JMS	NCSBEG		/PUT OUT BEGINNING
	JMP	XS1CON		/CONTINUE OVER PAGE
	PAGE
XS1CON,				/CONTINUATION OF PREVIOUS PAGE
	TAD	(12		/LENGTH OF CONNECT (EXCLUSIVE OF FEATURES)
/NOTE: ASSUMES EXTENSIBLE FIELDS ALWAYS SENT AS TWO BYTES
	TAD I	TEMP2		/ADD FEATURE LENGTH
	JMS	SNDEXN		/SEND COUNT (EXTENSIBLE NUMBER)
	NL1			/CONNECT=1
	JMS	SNDCHR		/TYPE
	JMS	NCSDLA		/SEND DLA
	TAD	TEMPB		/OUR LINK VALUE
	JMS	SNDCHR		/SLA
	JMS	SNDCHR		/DEST OBJ TYPE
	JMS	SNDCHR		/DEST PID
	JMS	SNDOBJ		/SEND OBJECT TYPE
	NLM1			/GET ADDRESS OF DEVICE NUMBER
	TAD	DDB		/WHICH IS ONE BEFORE START OF DDB
	DCA	TEMP1		/STORE ADDRESS
	TAD I	TEMP1		/GET DEVICE NUMBER
	JMS	SNDCHR		/PID
	TAD	TEMPB		/GET OUR INDEX
	TAD	(MMLTAB-1	/INTO MMLTAB
	JMS	SNDEXN		/SEND AS TWO BYTE FIELD
	TAD	TEMP2
	DCA	TEMP3
	TAD I	TEMP2		/GET COUNT
	NEGATE
	DCA	TEMP2
	ISZ	TEMP3
	TAD I	TEMP3		/GET NEXT CHAR
	JMS	SNDCHR
	ISZ	TEMP2
	  JMP	.-4
	JMP	FINMSG		/FINISH SETTING UP MESSAGE

XSTRT2,	TAD I	DDBSTS
	AND	(OUTBIT+TTYBIT	/MASK FOR OUTPUT DEVICES
	SNA			/SKIP IF EITHER OUTPUT OR TTY
	  JMP	XSTRT3		/NEITHER, SEE IF MESSAGE TO BE SENT
	AND	(TTYBIT		/SEE IF TTY
	SZA CLA			/SKIP IF NOT (I.E. OUTPUT)
	  JMP	XSTRT4		/DEVICE IS A TTY SO DO TTY STUFF
	JMS	XDRQ		/SEND DATA REQUEST IF NECESSARY
	JMP	XSTRT7		/WON'T RETURN IF DATA REQUEST SENT

XDRQ,	0
	NLOAD	DEVCHK		/POINT TO CHUNK COUNT
	TAD	DDB
	DCA	TEMP3
	TAD I	TEMP3		/GET CHUNK COUNT
	SMA CLA			/ONLY SEND DATA REQUEST IF MINUS
	  JMP I	XDRQ		/RETURN
	NLOAD	DEVDRQ		/ADDRESS OF DATA REQUEST COUNT WITHIN  DDB
	TAD	DDB		/DDB ADDRESS
	DCA	TEMP3		/STORE
	NLM2			/MAXIMUM DATA REQUESTS OUTSTANDING
	TAD I	TEMP3		/GET DATA REQUEST COUNT
	SMA CLA			/SKIP IF WE DON'T HAVE ENOUGH OUTSTANDING
	  JMP I	XDRQ		/RETURN
	ISZ I	TEMP3		/INCREMENT REQUEST COUNT
	JMS	XSTMSG
	TAD	(50		/INTERRUPT NCT
	JMS	NCSBEG		/BEGINNING OF MESSAGE
	NL4			/COUNT ASSUMES DLA IS 2 BYTE FIELD
	JMS	SNDCHR		/COUNT
	NL6			/DATA REQUEST
	JMS	SNDCHR		/TYPE
	JMS	NCSDLA		/DLA
	NL1			/REQUEST
	JMS	SNDCHR		/DRQ
	JMP	FINMSG

/HERE TO SEND A MESSAGE TO DECSYSTEM-10 ON BEHALF OF CDR OR PTR
XSTRT3,	TAD	(DEVBF1
	TAD	DDB
	DCA	TEMP4
	TAD I	TEMP4
	SNA
	  JMP	XSTRT7		/NO DATA TO SEND TO THE 10
	DCA	TEMP3		/SAVE POINTER TO BEGINING OF STRING
	JMS	XSTMSG		/SET UP TO SEND A MESSAGE
	TAD	(10		/NCT
	JMS	NCSBG		/BEGINNING MINUS DLA
	JMS	NCSDLA		/DLA
	SKP
	JMS	SNDCHR		/PUT INTO MESSAGE
	JMS	GETCHR		/GET THE NEXT CHARACTER
	  SKP
	JMP	.-3
	TAD I	TEMP4		/GET CHUNK STRING ADR AGAIN
	JMS	FRECKS
	DCA I	TEMP4
	JMP	FINMSG		/FINISH OFF MESSAGE

XSTRT0,	0
	TAD	(CTLBUF		/POINT TO START OF CONTROL MESSAGE
	DCA	AUTO1		/ASSUME WILL BE UNNUMBERED
CRCXI3,	DCA	CRC1		/CLEAR CRC		########
	DCA	CRC2
	TAD	[ENQ		/FIRST CHAR INTO CRC
	JMS	CRCALC		/CALCULATE CRC
	JMP I	XSTRT0

XDISBG,	0			/SUBR TO BEGIN DISCON OR CONF
	JMS	XSTMSG		/START OF DISCONNECT
	TAD	(10		/MAKE NCT
	JMS	SNDCHR		/NCT
	TAD	DISSNA
	JMS	SNDCHR		/DNA
	Z=OURNNM&177
	TAD	(Z
	JMS	SNDCHR		/SNA
	JMS	SNDCHR		/NCA
	JMS	SNDCHR		/NCN
	JMS	SNDCHR		/DLA
	JMP I	XDISBG		/RETURN
	PAGE
XSTRT4,	JMS	XSTMSG
	TAD	(50
	JMS	NCSBG
	JMS	NCSDLA
	TAD	[DEVDDC
	TAD	DDB
	DCA	TEMP7
	TAD	(DEVBF1		/ADR OF BUFFER
	TAD	DDB
	DCA	TEMP6
	JMS	RECI42		/PUT STATUS INTO MESSAGE
	TAD	DDB
	DCA	TEMP4		/SAVE ADR OF DDCMP ADR

/HERE TO THINK ABOUT SENDING CHARACTERS TO THE 10
XSTTRD,	TAD I	TEMP6		/GET DATA ADR(IF ANY)
	SNA			/IS THERE ANY ?
	  JMP	XSTTDN
	DCA	TEMP3		/SAVE ADR OF 1ST CHUNK
	JMS	GTCHR		/GET THE CHARACTER COUNT
	TAD	TEMP5
	TAD	(-MAXOLN+20
	SMA CLA			/ROOM ENOUGH FOR THIS DATA ?
	  JMP	XSTTDN		/NOT NOW SEND WITH THE NEXT MESSAGE
	TAD I	TEMP3		/GET THE CHARACTER COUNT AGAIN
	JMS	SNDCHR		/PUT THE CHAR INTO THE MESSAGE
	JMS	GETCHR		/GET THE NEXT CHARACTER, IF ANY
	  SKP
	JMP	.-3
	TAD I	TEMP6		/GET FIRST CHUNK ADR AGAIN
	JMS	FRECKS		/AND RELEASE THE CHUNKS
	DCA I	TEMP6		/CLEAR DEVBF1
	ISZ	TEMP6		/ADVANCE TO DEVBF2
	DCA I	TEMP6		/CLEAR DEVBF2

/HERE TO SEND AN ECHO-PIPELINE-MARKER(MAYBE)
	NL1			/MASK FOR DEFERRED ECHO MODE
	AND I	TEMP7		/SEE IF WE ARE IN THAT WAY
	SNA CLA			/SKIP IF TRUE
	  JMP	XSTTDN
	NL3			/COUNT
	JMS	SNDCHR
	NL4			/TYPE
	JMS	SNDCHR
	JMS	SNDCHR	
	TAD	(LDBEPL		/OFFSET FOR PIPELINE MARKER
	TAD	DDB
	DCA	TEMP1		/SAVE POINTER TO MARKER
	ISZ I	TEMP1		/ADVANCE MARKER
	  TAD I	TEMP1		/GET IT IF NOT ZERO
	AND	[0177		/7 BITS ONLY PLEASE
	JMS	SNDCHR		/PUT MARKER INTO THE MESSAGE
/HERE WHEN DONE WITH A LINE
XSTTDN,	ION
	TAD	TEMP5		/GET CURRENT MESSAGE SIZE
	TAD	(-MAXOLN+20	/COMPARE TO MAX
	SMA CLA
	  JMP	FINMSG		/SEND MESSAGE AS IS
	TAD	(-7
	TAD	TEMP5		/GET MESSAGE SIZE
	SZA CLA			/TEST FOR REAL MESSAGE
	  JMP	FINMSG		/REAL SO SEND MESSAGE
	JMS	XDRQ
	JMP	XSTRT8		/NOT REAL SO DON'T SEND IT
XSDIS0,	JMS	XSTMSG
	TAD	(50
	JMS	NCSBEG
	TAD	[5
	JMS	SNDCHR		/COUNT
	NL2
	JMS	SNDCHR		/TYPE=DISCONNECT
	JMS	NCSDLA		/DLA
	TAD	TEMPB
	JMS	SNDCHR		/SLA
	JMS	SNDCHR		/REASON=0
	TAD	TEMPB		/INDEX
	TAD	(RCVDSP
	DCA	TEMPB
	TAD	(RCVKRD
	DCA I	TEMPB
	TAD	(6777		/ALL EXCEPT ACCEPT BIT
	AND I	DDBSTS		/GET REST OF STATUS BITS
	DCA I	DDBSTS		/STORE THEM BACK
	JMP	FINMSG
RCVRQC,	TAD	CONSNA		/SEE IF WE'VE GOT ONE PENDING
	SZA CLA			/SKIP IF NOT
	  JMP	RCVFLU		/WE ALREADY HAVE ONE REQUEST PENDING,
				/SO IGNOR THIS ONE AND LET THE REQUESTING
				/NODE SEND ANOTHER MESSAGE LATER...
	TAD	RSNA		/GET SNA
	DCA	CONSNA		/INDICATE WE NEED TO SEND CONF
	JMP	RCVFLU
XSCONF,	TAD	CONSNA		/HERE TO SEND CONF: GET SNA
	DCA	DISSNA		/STORE FOR SUBROUTINE
	DCA	CONSNA		/CLEAR CONSNA
	JMS	XDISBG		/DO START OF MESSAGE
	TAD	(CNF		/POINT TO DATA PART OF MESSAGE
	DCA	TEMPC		/SAVE ADDRESS
	TAD I	TEMPC		/GET COUNT
	IAC			/INCLUDE ITSELF
	NEGATE			/FOR ISZ
	DCA	TEMPB		/LOOP CONTROL
XSCNF1,	TAD I	TEMPC		/GET NEXT CHARACTER
	ISZ	TEMPC		/POINT TO NEXT ONE
	JMS	SNDCHR		/PUT INTO MESSAGE
	ISZ	TEMPB		/CHECK IF DONE
	  JMP	XSCNF1		/NO, CONTINUE
	JMP	FINMSG		/END IT
	PAGE
XDISCN,	JMS	XDISBG		/SEND BEGINNING OF MSG
	TAD	[5		/COUNT
	JMS	SNDCHR		/COUNT
	NL2
	JMS	SNDCHR		/TYPE=DISCONNECT
	TAD	DISSLA		/GET LINK WHO REQUESTED CONNECT
	JMS	SNDEXN		/DLA
	JMS	SNDCHR		/SLA=0
	TAD	DISREA		/PICK UP REASON
	JMS	SNDCHR		/RSN
	DCA	DISREA		/CLEAR REASON
	JMP	FINMSG		/FINISH MESSAGE
/HERE TO SEE IF WE NEED TO SEND A STATUS MESSAGE TO THE 10
XSTRT7,	NL1			/MASK FOR NEED TO SEND STATUS BIT
	AND I	DDBSTS
	SZA CLA			/SKIP IF WE DON'T NEED TO SEND STATUS
	  JMP	SNDSTS		/SEND STATUS TO THE 10

XSTRT8,	ION
	TAD	(DEVLNK
	TAD	DDB
	DCA	DDB
	TAD I	DDB		/GET ADR OF NEXT DDT
	SZA			/SEE IF THERE IS ONE
	  JMP	XSTRT1		/CHECK IT FOR POSSIBLE SERVICE

XSTRT9,	JMS	XSTRT0
	TAD	RECVOK
	SPA CLA
	  JMP	SNDACK		/CHECK FOR NEED ACK

/HERE TO SEND A REP MESSAGE
SNDREP,	JMS	CKREPT		/CHECK REP TIMER
	NLOAD	REP
	JMS	SNDCHR		/2ND CHAR IS REP
SNDRP3,	JMS	SNDFIL
	JMS	SNDFIL		/3RD & 4TH ARE FILLS
SNDRP5,	TAD	T10HSN
	JMS	SNDCHR		/5TH CHAR IS HIGHEST MSG # SENT
	JMP	SNDAK6		/REST IS LIKE AN ACK MSG

/HERE TO SEE IF REP TIMER HAS GONE OFF
CKREPT,	0
	TAD	REPTCK
	SPA CLA
	JMP	LOOP30		/IF STILL COUNTING DON'T SEND
	TAD	(-REPTIM
	DCA	REPTCK		/RESET TIMER
	JMP I	CKREPT


SNDSTS,	NL7776			/MASK TO CLEAR NEED TO SEND STATUS BIT
	AND I	DDBSTS		/CLEAR BIT FROM WORD
	DCA I	DDBSTS		/SAVE UPDATED WORD
	JMS	XSTMSG		/BEGIN BUILDING MESSAGE
	TAD	(50		/NCT FOR STATUS MESSAGE
	JMS	NCSBG		/BEGINNING OF DEVICE CONTROL MSG
	JMS	NCSDLA		/DLA
	NL4			/COUNT
	JMS	SNDCHR
	NL3			/TYPE
	JMS	SNDCHR
	JMS	SNDCHR
	TAD	[DEVDDC
	TAD	DDB
	DCA	TEMP3
	TAD I	TEMP3
	AND	[0177		/STRIP EXTRA BITS
	TAD	[0200		/ADD EXTENSIBLE BIT
	JMS	SNDCHR
	TAD I	TEMP3		/GET HIGH ORDER BITS OF STATUS WORD
IFZERO	PDP8I	<
	CLL RTR			/CAN'T USE RTL
	CLL RTR			/BECAUSE INTERRUPT
	CLL RTR			/ZAPS LINK
>
IFZERO	PDP8E	<
	BSW
>
	CLL RAR
	AND	(0037		/CLEAR EXTRA BITS
	JMS	SNDCHR
	JMP	FINMSG		/SEND MESSAGE
/TEMP CONVENTIONS WHEN BUILDING MESSAGES
/ TEMP5 IS COUNT OF DATA PORTION
XSTMSG,	0
	ION
CRCXI4,	DCA	CRC1		/CLEAR 1ST HALF OF CRC		########
	DCA	CRC2		/CLEAR 2ND HALF OF CRC
	TAD	T10PTR		/POINTER TO NEW MESSAGE
	TAD	[7		/MAKES POINTER TO DATA
	DCA	AUTO1
	DCA	TEMP5
	JMP I	XSTMSG
FINMSG,				/END UP MESSAGE
	TAD	CRC2		/GET LOW PART OF CRC
	DCA I	AUTO1
	TAD	CRC1		/GET HIGH PART OF CRC
	DCA I	AUTO1
	TAD	T10PTR
	DCA	AUTO1
	TAD	TEMP5		/GET SIZE OF MESSAGE
	DCA I	AUTO1		/PUT INTO HEADER
	TAD	TEMP5		/GET MESSAGE SIZE AGAIN
	CLL RTR
	CLL RTR
	CLL RTR
	CLL RTR
	AND	(0017		/ONLY 4 BITS ARE REAL
	DCA I	AUTO1		/PUT REST OF COUNT IN
	ISZ	AUTO1		/SKIP RESPONSE FIELD
	TAD	T10HSN		/GET HIGHEST MESSAGE NUMBER SENT SO FAR
	JMS	COUNT
	DCA	T10HSN
	TAD	T10HSN
	DCA I	AUTO1		/PUT MESSAGE NUMBER INTO HEADER
	T10ADJ	T10PTR
	JMP	LOOP		/BACK TO BIG LOOP AND THEN SEND MESSAGE

	PAGE
/HERE TO SEND A STACK MESSAGE
SNDSTK,	TAD	STACKF		/GET START-STACK FLAG
	IAC
	SPA CLA			/SKIP TO SEND A STACK
	  JMP	SNDSRT		/NEED TO SEND A START
	DCA	STACKF		/DONE WHEN HAVE RESPONDED
	TAD	(STACK
	JMS	SNDCHR		/2ND CHAR IS STACK
	JMS	SNDFIL		/3RD CHAR IS A FILL
	JMS	SNDCHR		/4TH CHAR IS A FILL
SNDSK5,
	JMS	SNDCHR		/5TH CHAR IS A FILL
	JMP	SNDAK6		/6TH IS DEST STA ADR


/HERE TO SEND A START MESSAGE
SNDSRT,	JMS	CKREPT		/CHECK REP TIMMER
	TAD	(STRT
	JMS	SNDCHR		/2ND WORD IS START
	JMS	SNDFIL
	JMS	SNDFIL		/3RD & 4TH ARE FILLS
	JMP	SNDSK5		/REST IS LIKE A STACK

/HERE TO SEND A NAK MESSAGE
SNDNAK,	NLOAD	NAK
	JMS	SNDCHR		/2ND CHAR IS A NAK
	TAD	NAKFLG
	JMS	SNDCHR		/3RD IS REASON
	DCA	NAKFLG		/CLEAR NAK FLAG
	JMP	SNDAK4		/REST IS LIKE AN ACK MSG

/HERE TO SEND AN ACK MESSAGE
SNDACK,	NL3777
	AND	RECVOK
	DCA	RECVOK		/CLEAR NEED ACK FLAG
	NLOAD	ACK
	JMS	SNDCHR		/2ND CHAR IS ACK
	JMS	SNDFIL		/3RD IS FILL
SNDAK4,	TAD	RECVOK
	JMS	SNDCHR		/4TH IS LAST GOOD MSG #
	JMS	SNDFIL		/5TH CHAR IS FILL
/HERE TO PUT DESTINATION STATION ADR AND CRC ON MESSAGE
SNDAK6,	NL1
	JMS	SNDCHR		/6TH CHAR IS ALWAYS 1
	TAD	CRC2		/GET LOW PART OF CRC
	DCA I	AUTO1		/PUT HALF OF CRC IN MSG
	TAD	CRC1		/GET HIGH PART OF CRC
	DCA I	AUTO1		/ DITTO
IFNZRO	DP8ETR	<
	JMS	OTR		/TRACE MESSAGE
>/END OF IFNZRO	DP8ETR
	NLM2
	DCA	T10FLG
	JMP	LOOP		/FLAG FOR XMITTER

/HERE TO PUT A FILL CHARACTER INTO A MESSAGE
SNDFIL,

/HERE TO PUT A CHAR INTO A MESSAGE
SNDCHR,	0
	AND	[0377		/STRIP EXTRA BITS IF ANY
	DCA	TEMP1		/SAVE COPY OF CHAR
	TAD	TEMP1		/GET CHAR AGAIN
	DCA I	AUTO1		/PUT CHARACTER INTO MESSAGE

	TAD	TEMP1		/GET CHARACTER AGAIN
	JMS	CRCALC		/PUT INTO CRC CALCULATION
	ISZ	TEMP5		/COUNT CHAR
	JMP I	SNDCHR
	JMP I	SNDCHR

/HERE TO SKIP AN EXTENSIBLE FIELD
/ CALL	JMS	SKPEXN	WITH TEMP3 POINTING TO THE STRING OF CHUNKS
SKPEXN,	0
	JMS	GTCHR
	AND	(0200		/CHECK EXTENSIBLE BIT
	SZA			/SKIP IF DONE
	  JMP	SKPEXN+1	/OTHERWISE CONTINUE
	JMP I	SKPEXN		/RETURN
SNDEXN,	0			/SEND EXTENSIBLE NUMBER
/ NOTE: ALWAYS SENDS TWO BYTE EXTENSIBLE NUMBER, SINCE
/ OTHERWISE TOO HARD TO CALCULATE COUNTS.
	DCA	TEMPD		/SAVE IT
	TAD	TEMPD		/GET IT AGAIN
	AND	[177		/TURN OFF ALL BUT BOTTOM SEVEN
	TAD	(200		/TURN ON EXTENSIBLE BIT
	JMS	SNDCHR		/SEND LOW BITS
	TAD	TEMPD		/GET CHARACTER
	AND	(7600		/TURN OFF BOTTOM 7 BITS
IFZERO	PDP8I	<
	CLL RTR			/CAN'T USE RTL THRU LINK
	CLL RTR
	CLL RTR
>
IFZERO	PDP8E	<
	BSW
>
	CLL RAR
	JMS	SNDCHR		/SEND HIGH BITS
	JMP I	SNDEXN		/RETURN
/HERE TO SEND A NUMBERED MESSAGE TO 10
SNDMSG,	NLM1
	TAD	T10TKR
	DCA	T10NCA		/ADR OF BUFFER
	TAD	T10TKR
	DCA	AUTO1
	TAD I	AUTO1		/GET LENGTH OF DATA
	TAD	(12
	NEGATE
	DCA	T10NWC		/SET WC FOR BLOCK
CRCXI5,	DCA	CRC1		/				########
	DCA	CRC2		/INITIALIZE THE CRC
	TAD	T10TKR
	DCA	AUTO1		/POINTER TO HEADER
	TAD	(SOH
	JMS	CRCALC		/FIRST CHAR IS ALWAYS SOH
	TAD I	AUTO1
	JMS	CRCALC		/2ND IS HALF OF LENGTH
	TAD I	AUTO1
	JMS	CRCALC		/3RD IS HALF OF LENGTH
	TAD	RECVOK
	JMS	SNDCHR		/4TH IS LAST # RECEIVED
	TAD I	AUTO1		/5TH CHAR IS MESSAGE NUMBER
	JMS	CRCALC		/PUT INTO CRC
	T10ADJ	T10TKR
	JMP	SNDAK6		/REST IS LIKE AN ACK

SECOND,	DCA	SECFLG
	NL6000			/LIMIT # OF SPURIOUS INTERRUPTS
	DCA	INTCNT		/  PER SECOND
/	JMP	SECSYN		/GO DO ONCE A SECOND STUFF
SECSYN,	JMP	SECDP		/CHECK SYNCHRONOUS INTERFACE
/HERE TO INCREMENT A MSG NUMBER
/ CALL	JMS	COUNT		/WITH MSG # IN AC
/	RETURN		/WITH MSG#+1 IN AC
COUNT,	0
	IAC
	AND	[0377
	JMP I	COUNT

	PAGE

	LISTOG	FTDP01
IFNZRO FTDP01 <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP01 MODEM HANDLING			***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO SEE IF SYNCHROUS MODEM HAS INTERRUPTED
INTMOD,	DPSEF			/SKIP ON RECEIVE END FLAG
	  JMP	INTMD2
	DPSRI			/SKIP ON RING INDICATOR
	  JMP	INTMD5
	JMP	INTMO9		/NOT MODEM SO CHECK FOR MEMORY PARITY
INTMD2,	DPCEF			/CLEAR END FLAG
	TAD	(ENDMSG
	DCA	ERRFLG		/LEAVE MSG FOR OPERATOR
	JMP	INTDIS
INTMD5,	DPCRF
	DPSTR
	JMP	INTDIS


SECDP=IRMA			/NO ONCE/SEC STUFF FOR DP01
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP01 INPUT PROCESSING			***
/	***							***
/	***********************************************************
/	***********************************************************


/HERE AT INTERRUPT LEVEL TO SEE IF DP01 HAS INTERRUPTED
INTDPX,	DPSRF			/SKIP ON NOT DP01 RECEIVE FLAG
	  JMP	INRC00		/YES
	DPSTF			/SKIP ON NOT TRANSMIT FLAG
	  JMP	INTN00		/GO SERVICE TRANSMIT INTERRUPT
	JMP	INTDP9		/NOT DP01

/HERE AT INTERRUPT LEVEL TO HANDLE DP01
INRC00,	DPRRB			/GET CHARACTER FROM DP01
	DCA	INTMP1
	TAD	INTMP1		/GET CHAR
	ISZ	F10CA		/ADVANCE BUFFER ADR
	DCA I	F10CA		/SAVE CHAR IN BUFFER

IFNZRO FTDEBUG <
	TAD	(-SYN
	TAD	INTMP1
	SNA CLA
	  JMP	INRC04
	NL4000
	TAD	INTMP1		/GET CHARACTER RECEIVED
	JMS	TRACEW		/PUT WORD INTO THE TRACE
INRC04,
>/END OF IFNZRO FTDEBUG

	JMP I	INRCPV		/DISPATCH TO CORRECT ROUTINE

/HERE WHEN RECEIVE INPUT ON INACTIVE LINE
INRC10,	NLM1			/SET UP NEW CA IN CASE CHAR WAS UNINTERESTING
	TAD	RCVPTR
	DCA	F10CA
		/DON'T NEED TO DO ANYTHING ABOUT WC FOR DP01
	JMS	INRC50		/SEE IF CHAR WAS SPECIAL
INRC12,	  /DON'T RETURN IF NOT SPECIAL
	TAD	(-F10TCH
	TAD	INTMP3		/GET CHAR NUMBER WHICH WE FOUND
	TAD	(JMP I	INRC16
	DCA	.+1
	0
INRC16,	INTP00
	INTP10
	INTP20
	INTP30

/HERE WHEN RECEIVING AN UNNUMBERED MESSAGE
INRC20,	ISZ	F10WC
	  JMP	INTDIS
	JMP I	.+1
	INTP40

/INRC40=INTDIS		/NOT NECCESSARY TO ENABLE INPUT

/HERE TO SEE IF LAST CHAR RECEIVED WAS SPECIAL
/CALL	JMS	INRC50
/	RETURN IF CHAR WAS SPECIAL(ELSE JMP INTDIS)
INRC50,	0
	TAD	INTMP1		/GET THIS CHAR
	TAD	(-SYN
	SNA CLA
	  JMP	INTDIS		/IGNORE SYNCHS
	TAD	INTMP1		/GET RECEIVED CHAR
	NEGATE			/FOR TEST FOR SPECIAL CHARS
	DCA	INTMP2
	TAD	[F10TCH
	DCA	INTMP3
	TAD	(-4
	DCA	INTMP4
	CDFINS			/TABLE IS IN FIRST FIELD
INRC53,	TAD I	INTMP3
	TAD	INTMP2
	SNA CLA			/HAVE WE FOUND A MATCH ?
	  JMP	INRC54		/YES SO RETURN TO CALLER
	ISZ	INTMP3		/ADVANCE TO NEXT CHAR
	ISZ	INTMP4		/HAVE WE CHECKED ENOUGH ?
	  JMP	INRC53		/NO
	TAD	INRC50
	TAD	(-INRC12
	SNA CLA			/ARE WE RECEIVING MSG ?
	  DPCRA			/CLEAR RECEIVER ACTIVE
	CDFCNK			/SET NORMAL DATA FIELD
	JMP	INTDIS		/DISMISS INTERRUPT
INRC54,	CDFCNK
	JMP I	INRC50

/HERE WHEN RECEIVING DATA FROM A NUMBERED MESSAGE
INRC70,
	ISZ	F10WC
	  JMP	INRC75		/ENOUGH ROOM GO SEE IF CHAR IS SPECIAL
	NL4000			/FLAG LAST CHAR IN BUFFER
	TAD	INTMP1		/GET CHAR
	DCA I	F10CA		/PUT CHAR+FLAG IN CHUNK
	TAD	F10CA		/LAST ADR IN CHUNK
	AND	[-CNKSIZ	/LEAVES 1ST ADR IN CHUNK
	DCA	INTMP2		/SAVE IT
	TAD	F10TWC
	SNA CLA
	  JMP	INTP60
INRC80,	JMS	IGTCNK
	  JMP	INTP60		/PRETEND F10TWC EXHAUSTED
	DCA I	INTMP2
	ISZ I	CNTPNT		/INCREASE CHUNK COUNT
	TAD I	INTMP2
	DCA	F10CA
	TAD	F10TWC
	TAD	(1-CNKSIZ
	SPA
	  JMP	INRC83
	DCA	F10TWC
	TAD	(1-CNKSIZ
	DCA	F10WC
INRC75,	
	JMP	INTDIS
INRC83,	NL0
	TAD	F10TWC
	NEGATE
	DCA	F10WC
	DCA	F10TWC
	JMP	INRC75

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP01 OUTPUT PROCESSING			***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE AT INTERRUPT LEVEL TO HANDLE DP01 OUTPUT

/HERE WHEN LINE IS IDLING
INTN00,	ISZ	T10CA		/ADVANCE CURRENT ADDRESS
	TAD I	T10CA		/GET THE NEXT CHAR TO SEND
	DPTAC DPCTF		/SEND CHAR AND CLEAR TRANSMIT FLAG
	  NOP			/DPCTF SKIPS SOMETIMES

IFNZRO FTDEBUG <
	AND	[0377		/BE SURE 8BITS ONLY
	TAD	(-IDLE
	SNA
	  JMP	INTN01
	TAD	(IDLE
	JMS	TRACEW		/PUT WORD INTO THE TRACE
>/END OF IFNZRO FTDEBUG

INTN01,	NLM3
	DCA	T10CLK
	ISZ	T10WC		/COUNT THIS DATA
	  JMP	INTDIS		/DISMISS INTERRUPT

/HERE WHEN CURRENT TRANSMIT BUFFER IS EMPTY
	NL0
	TAD	T10FLG
	SNA
	  JMP	INTN99		/IDLING
	SMA CLA
	  JMP	INTN10		/WE ARE SYNCHING LINE
	ISZ	T10FLG		/DID WE JUST COMPLETE A MESSAGE ?
	  JMP	INTN20		/NO WE ARE JUST READY TO BEGIN
	NLM1			/WE JUST FINISHED A MESSAGE(DAT ACK ETC)
	DCA	WRKREQ		/WAKE NONINTERRUPT LEVEL CODE
	ISZ	T10FLG		/STATE IS NOW SYNCHING = 1
INTN10,	TAD	(SYNBUF-1	/4 SYNCHS
	DCA	T10CA
	TAD	[-NUMSYN
	DCA	T10WC
	JMP	INTDIS

/HERE TO BEGIN A MESSAGE
INTN20,	TAD	T10NCA		/ADR OF NEXT BUFFER TO SEND
	DCA	T10CA
	TAD	T10NWC		/LENGTH OF NEW BUFFER
	DCA	T10WC
	JMP	INTDIS

/HERE WHEN LINE IS IDLING
INTN99,	TAD	(IDLBUF-1
	DCA	T10CA
	TAD	[-NUMSYN
	DCA	T10WC
	JMP	INTDIS

>/END OF IFNZRO FTDP01
	LISTOG 0
IFZERO FTDP01 <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP8E MODEM HANDLING			***
/	***							***
/	***********************************************************
/	***********************************************************

INTMOD,	DPSSRG			/SKIP IF RING FLAG SET
	  JMP	INTMD5
	ISZ	RNGCNT
	JMP	INTDIS
RNGCNT,	0
INTMD5,	DPSSBE			/SKIP ON BUS ERROR
	  JMP	INTMD7
	ISZ	BERCNT		/COUNT BUS ERROR
	  TAD	(DBEMSG-1	/IF WE GET 4096 BUS ERRORS THIS WILL
				/ BE SKIPPED (WHAT ME WORRY ?)

	JMP	INTMD8		/TYPE MESSAGE THEN JMP INTDIS
BERCNT,	0			/COUNT OF BUS ERROR COUNTS

INTMD7,	DPSSCA			/SKIP IF CARRIER FLAG FLIPPED
	  JMP	INTMO9		/NOT MODEM SO ON DOWN SKIP CHAIN
	DPSRS2
	SMA CLA			/SKIP ON CARRIER
	  TAD	(LCRMSG-CARMSG	/WE HAVE LOST CARRIER
	TAD	(CARMSG-1
INTMD8,	DCA	ERRFLG		/LEAVE MSG FOR OPERATOR
	JMP	INTDIS

/HERE ONCE PER SECOND TO CHECK MODEM
SECDP,	DPSRS1			/GET STATUS 1
	DCA	DPSTS1
	DPSRS2
	DCA	DPSTS2
	JMP	IRMA
DPSTS1,	0
DPSTS2,	0
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP8E INPUT PROCESSING			***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO SEE IF RECEIVER HAS INTERRUPTED
INTDPX,	DPSSCD			/SKIP IF SPECIAL CHAR DETECTED
	  SKP			/NO
	JMP	INRC00		/WAS A SPECIAL CHARACTER
	DPSSRO			/SKIP ON RECEIVE WC OVERFLOW
	  JMP	INTDPO		/NOT RECEIVER SO TRY TRANSMITTER
	JMP I	INRCPV		/WC OVERFLOW ON RECEIVER

/WC OVERFLOW WHILE RECEIVER IS IDLE
INRC10,	DPSSCD			/WAS IT A SPECIAL CHAR ?
	  JMP	INRC11		/NO

/HERE FOR SPECIAL CHAR INTERRUPT
INRC00,	DPSRCD			/GET INDEX OF CHAR WHICH INTERRUPTED
	TAD	[F10TCH		/ADD ADR OF TABLE OF SPECIAL CHARS
	DCA	INTMP1		/TO ADDRESS THIS SPECIAL CHAR
	TAD	INRCPV
	TAD	[-INRC10
	SZA CLA			/ARE WE IN STATE A (IDLE)?
	  JMP	INTDIS		/NO SO IGNORE INTERRUPT
	DPSSRO
	  NOP
	CDFINS
	TAD I	INTMP1		/GET SPECIAL CHAR FROM TABLE
	CDFCNK
	NEGATE
	TAD I	RCVPTR		/GET SPECIAL CHAR AS RECEIVED
	SZA CLA			/ARE THEY THE SAME ?
	  JMP	INRC01		/THIS IS EITHER A HDW PROBLEM
				/ OR WE ARE TAKING TOO LONG TO SERVICE INTERRUPTS
	TAD	INTMP1		/GET F10TCH+INDEX
		ZZ=JMP I INRC02
		ZZ=ZZ-F10TCH
	TAD	(ZZ
	DCA	.+1
	7402			/MODIFIED BY PROGRAM
INRC02,	INTP00
	INTP10
	INTP20
	INTP30

INERRC,	0			/COUNT OF SP. CHAR ERRORS
INRC01,	ISZ	INERRC		/COUNT ERROR
	JMP	INTDIS		/DISMISS INTERRUPT
	HLT

/WC OVERFLOW ON UNNUMBERED MSG
INRC20,	DPSSCD			/CLEAR CHAR DETECTED FLAG
	  JMP	INTP40
	JMP	INTP40

/HERE WITH WC OVERFLOW WHILE IDLE
INRC11,	CDFINS
	TAD I	[F10CA
	CDFCNK
	DCA	INTMP1
	TAD I	INTMP1		/GET LAST CHAR
	TAD	[-SYN
	SZA CLA			/WAS RANDOM CHAR A SYNC ?
	  DPSCSD		/ NO - SO CLEAR SYNC DETECT
	JMS I	[INRCID		/RESET WC AND CA
/	JMP	INRC40		/SET RECEIVER RDY, THEN JMP INTDIS
/
/INRC40,	DPSSRO		/SKIP IF RECEIVE WC OVERFLOW
/	  NOP
/	DPSSCD			/SKIP ON SPECIAL CHAR
/				/ IN CASE GOT HERE FOR FUNNY REASON
/	  NOP
	DPSGRR			/ENABLE INPUT
	JMP	INTDIS

/WC OVERFLOW ON NUMBERED MSG DATA
INRC70,	CDFINS
	TAD I	[F10CA		/GET ADR OF LAST CHAR
	CDFCNK
	DCA	INTMP1
	NL4000
	TAD I	INTMP1
	DCA I	INTMP1
	TAD	INTMP1		/ADR OF LAST DATA IN CHUNK
	AND	[-CNKSIZ	/MAKES ADR OF LINK
	DCA	INTMP2
	TAD I	INTMP2
	SZA CLA
	  HLT
	TAD	F10TWC
	SNA CLA			/MIGHT THERE BE MORE IN MESSAGE ?
	  JMP	INTP60		/NO

INRC80,	IFNZRO FTDEBUG <
	TAD I	INTMP2		/GET LINK WORD IN LAST CHUNK
	SZA
	  HLT
>/END OF IFNZRO FTDEBUG
	JMS	IGTCNK		/TRY TO GET ANOTHER CHUNK
	  JMP	INTP60		/NO SO PRETEND WC EXHAUSTED
	DCA I	INTMP2		/SET LINK IN PREVIOUS CHUNK
	ISZ I	CNTPNT		/INCREMENT NUMBER OF CHUNKS
	TAD I	INTMP2
	CDFINS
	DCA I	[F10CA
	TAD	F10TWC
	TAD	[1-CNKSIZ
	SPA
	  JMP	INRC83
	DCA	F10TWC
	TAD	[1-CNKSIZ
	DCA I	[F10WC
	JMP	INRC84

INRC83,	NL0
	TAD	F10TWC
	NEGATE
	DCA I	[F10WC
	DCA	F10TWC
INRC84,	CDFCNK
	DPSGRR
	JMP	INTDIS
/	JMP	INRC40		/SET RECEIVE RDY, THEN JMP INTDIS

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DP8E OUTPUT PROCESSING			***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE AT INTERRUPT LEVEL TO HANDLE DP8E OUTPUT

INTDPO,	DPSSTO			/SKIP ON TRANSMIT WC OVERFLOW
	  JMP	INTDP9		/NOT DP8E SO TRY CARD READER

	TAD I	(IDLBUF		/IDLE BUFFER IS NEVER WRITTEN
	TAD	(-IDLE		/SO LETS BE SURE IT STILL IS
	SZA			/SKIP IF OK

	  HLT			/THIS IS VERY LIKELY A HARDWARE FAILURE
				/ PLEASE CHECK ECO IS INSTALLED !
				/ THE USUAL EXPLANATION FOR THIS FAILURE IS
				/ THE DP8E HAS ADDED TO THE TRANSMIT BUFFER THE
				/ LAST CHAR RECEIVED, USUALLY SYNC=226

/HERE WHEN CURRENT TRANSMIT BUFFER IS EMPTY
	TAD	T10FLG
	SNA
	  JMP	INTN97		/IDLING
	SMA CLA
	  JMP	INTN10		/WE ARE SYNCHING LINE
	ISZ	T10FLG		/DID WE JUST COMPLETE A MESSAGE ?
	  JMP	INTN20		/NO WE ARE JUST READY TO BEGIN
	ISZ	T10FLG		/STATE IS NOW SYNCHING
	NLM1			/WE JUST FINISHED A MESSAGE(DAT ACK ETC)
	DCA	WRKREQ		/WAKE NONINTERRUPT LEVEL CODE
INTN10,	TAD	[SYNBUF-1	/BUFFER OF SYNCHS
	JMP	INTN98		/SET UP CA, WC AND CLOCK FOR 1 CHAR

/HERE TO BEGIN A MESSAGE
INTN20,	TAD	T10NCA		/ADR OF NEXT BUFFER TO SEND
	CDFINS
	DCA I	[T10CA
	TAD	T10NWC		/LENGTH OF NEW BUFFER
	DCA I	[T10WC
	CDFCNK
	TAD	T10NWC
	CLL CML RAR
INTN21,	CLL CML RAR		/FOR SPEED .LT. 2400 WILL BE NOP	########
	TAD	[-3
	JMP	INTN99

/HERE WHEN LINE IS IDLING
INTN97,	TAD	(IDLBUF-1
INTN98,	CDFINS
	DCA I	[T10CA
	TAD	[-NUMSYN
	DCA I	[T10WC
	CDFCNK
	SYNCLK=NUMSYN^3		/3 PER CHARACTER
	TAD	[-SYNCLK	/RESET CLOCK ON XMTR
INTN99,	DCA	T10CLK
	DPSGTT			/REENABLE XMTR
	JMP	INTDIS

>/END OF IFZERO FTDP01
	XISTOG	FTDP01
/	***********************************************************
/	***********************************************************
/	***							***
/	***		NON-INTERRUPT LEVEL CODE		***
/	***							***
/	***********************************************************
/	***********************************************************

/ FIRST SCAN FOR THINGS TO DO LEFT BY INTERRUPT LEVEL CODE
/ THEN DISPLAY CONTENTS OF ADR IN SWITCHES

LOOP,	ION
	NL0			/RESET INTERRUPTS & AC

	TAD	CLKFLG
	SZA CLA
	  JMP	SCHED		/CHECK FOR ONCE PER TICK DUTIES

	TAD	SECFLG
	SZA CLA
	  JMP	SECOND		/CHECK FOR ONCE PER SECOND DUTIES

	TAD	TIQPTR
	NEGATE
	TAD	TIQTKR		/CHECK TTY RECEIVE QUEUE
	SZA CLA
	  JMP	RECINT		/IF ANY RECEIVE STUFF HANDLE IT

	TAD	RCVTKR
	NEGATE
	TAD	RCVPTR
	SZA CLA
	  JMP	RCVCHK		/THERE IS INPUT FROM DECSYSTEM-10 WAITING

	TAD	T10FLG		/CHECK SYNCHRONOUS TRANSMIT STATE
	SMA CLA
	  JMP	XSTART		/IDLE OR SYNCH

LOOP30,	
/IDLE - SO DISPLAY DATA ADDRESSED BY CONSOL SWITCHES
	CLA OSR			/GET CONTENTS OF SWITCHES
	DCA	TEMP1
	TAD	TEMP1
	TAD	DISMIN
	SMA
	  JMP	LOOP90
	TAD	DISMAX		/LIMIT TEST FOR DISPLAY FIELD
	SPA
	  JMP	LOOP90		/OUT OF RANGE
	CLL RTL
	CLL RAL
	TAD	(CDF
	DCA	LOOP90
LOOP90,	CDFINS			/INITIALLY DISPLAY INSTRUCTION FIELD
	NL0
	TAD	LOOP90
	DCA	LOOP99
	TAD I	TEMP1
IFZERO	PDP8E	<
	MQL			/LOAD INTO MQ
	TAD I	TEMP1		/GET IT BACK
>/END IFZERO	PDP8E
LOOP99,	7402
	ISZ	WRKREQ		/DISPLAY 4096 TIMES OR UNTIL INTERRUPTED
	JMP	LOOP99
	CDFCNK			/BACK TO NORMAL DATA FIELD
	JMP	LOOP

/NOTE THAT DISMIN+DISMAX MUST = 0010
DISMIN,	10
DISMAX,	0			/FIRST FIELD WHICH MAY NOT BE DISPLAYED
/HERE ONCE PER CLOCK TICK(UNLESS WE OVERRUN)
SCHED,	DCA	CLKFLG		/MARK WE SAW FLAG
	IOF
	TAD	REPTCK
	SPA CLA			/ARE WE TIMEING OUT ?
	ISZ	REPTCK		/YES HAVE WE
	  JMP	SCHED2		/NO TO ONE OF ABOVE

SCHED2,	ISZ	T10CLK		/HAS SYNCHRONOUS TRANSMITTER TAKEN TOO LONG ?
	  JMP	SCHED9		/NO
	TAD	(DPTMSG		/SYNCHROUS LINE TIMEOUT MSG
	DCA	ERRFLG		/LEAVE MSG FOR OPERATOR
	JMS	INISYN		/POKE TRANSMITTER
SCHED9,	ION
	JMP	CLKCDR		/TO CDR STUFF FIRST

/	***********************************************************
/	***********************************************************
/	***							***
/	***		COMMON SUBROUTINES			***
/	***							***
/	***********************************************************
/	***********************************************************


/HERE TO FREE A CHUNK
/CALL	JMS	FRECNK	(CALL WITH CNK ADR IN AC
/	RETURN
/FRECNK,	0
/	IOF
/	JMS	IFRCNK		/RELEASE CHUNK
/	ION
/	JMP I	FRECNK

/HERE TO FREE A NUMBER OF CHUNKS
/CALL	JMS	FRECKS	(WITH ADR OF FIRST CHUNK IN AC)
/	RETURN
FRECKS,	0
	ION
	SNA			/ANY CHUNKS LEFT ?
	  JMP I	FRECKS		/NO SO RETURN TO CALLER
	IOF			/FOR CALL TO IFRCNK
	DCA	INTMP1		/SAVE ADR OF THIS CHUNK
	TAD I	INTMP1		/GET ADR OF NEXT CHUNK
	DCA	INTMP2		/SAVE IT
	TAD	INTMP1
	JMS	IFRCNK		/RELEASE THIS CHUNK
	ISZ	FREDCK		/COUNT THIS CHUNK
	NOP			/SINCE IT MIGHT SKIP
	TAD	INTMP2		/GET ADR OF NEXT CHUNK IN STRING
	JMP	FRECKS+1	/LOOP FOR NEXT CHUNK

	 PAGE 

/HERE TO GET A FREE(NOT ERS) CHUNK AT INTERRUPT LEVEL
/ CALL	JMS	IGTCNK
/	ERROR RETURN
/	RETURN	WITH CHUNK ADR IN AC
IGTCNK,	0
	NL0
	TAD	(-ERSCNT
	TAD	FRECNT
	SPA CLA
	  JMP I	IGTCNK		/NOT ENOUGH CHUNKS LEFT TO PASS ANY OUT
	JMS	ERSGET		/GET A CHUNK
	ISZ	IGTCNK
	JMP I	IGTCNK
/HERE TO GET DDB ADR
/CALL	JMS	GETDDB	(WITH DEVICE # IN AC)
/	RETURN	WITH DDB, DDBSTS STEUP & BLOCK ADR IN AC
GETDDB,	0
	SPA
	  HLT
	TAD	(-DEVN
	SMA
	  HLT
	TAD	(DDBTAB+DEVN
	DCA	DDB
	TAD I	DDB
	DCA	DDB		/SAVE DEVICE BLOCK ADR
	NLOAD	DEVSTS		/RELATIVE ADR OF DEVICE STATUS WORD
	TAD	DDB
	DCA	DDBSTS		/SAVE ADR OF STATUS WORD
	TAD	DDB
	JMP I	GETDDB
/HERE TO GET THE NEXT OUTPUT CHAR FROM CHUNK
/ USES INTMP1 - INTMP4
/CALL	PUT DEVICE BLOCK ADR IN INTDDB
/	JMS	IGTOCH
/	RETURN IF NONE( AC=0 )
/	RETURN WITH CHAR IN AC

IGTOCH,	0
	NLOAD	DEVOAD
	TAD	INTDDB		/ADD DEVICE DATA BLOCK ADR
	DCA	INTMP3
	TAD I	INTMP3		/GET OUTPUT CHAR COUNT
	SNA			/DO WE HAVE ANY OUTPUT CHARS ?
	  JMP I	IGTOCH		/NO - DISMISS
	ISZ	IGTOCH		/SKIP RETURN TO CALLER
	ISZ I	INTMP3		/ADVANCE CHAR POINTER
	IAC 			/MAKE ADR OF CURRENT CHAR
	DCA	INTMP4
	TAD I	INTMP4		/PICK UP CURRENT CHAR
	SMA			/ALL DONE WITH CURRENT CHUNK ?
	  JMP I	IGTOCH		/NO - EXIT ROUTINE
	DCA	INTMP2		/SAVE CHARCTER
	TAD	INTMP4		/CURRENT CHAR POINTER
	AND	[-CNKSIZ	/MAKES POINTER TO LINK WORD
	DCA	INTMP4
	TAD I	INTMP4		/GET ADR OF NEXT CHUNK

IFNZRO FTDEBUG <
	SNA
	  JMP	.+3
	JMS	ICNKCK		/CHECK CHUNK ADR IS KOSHER
	TAD	INTMP1		/GET ADR OF CHUNK AGAIN
>/END OF IFNZRO FTDEBUG

	DCA I	INTMP3		/SET NEW CHAR POINTER
	TAD	INTMP4		/ADR OF USED CHUNK
	JMS	IFRCNK		/FREE CURRENT CHUNK
	NLOAD	DEVCHK		/DISPLACEMENT OF CHUNK COUNT
	TAD	INTDDB		/PLUS DDB START
	DCA	INTMP3		/SAVE DEVCHK ADDRESS
	NLM1			/DECREMENT
	TAD I	INTMP3		/ CHUNK COUNT
	DCA I	INTMP3		/ AND STORE
	TAD	INTMP2		/GET CURRENT CHAR AGAIN
	JMP I	IGTOCH		/DONE
/HERE TO GET AN EXTENSIBLE NUMBER USING IGTOCH
IGTEXN,	0
	JMS	IGTOCH
	  JMP I	IGTEXN		/TRY AGAIN LATER
	AND	[0377
	DCA	INTMP5		/SAVE LOW ORDER BITS
	TAD	INTMP5
	AND	[0200
	SNA CLA
	  JMP	IGTEN9		/RETURN
	JMS	IGTOCH
	  HLT
	CLL RAL			/PUT SIGN BIT IN LINK
	CLL RTL			/CLEAR FORMER SIGN BIT
	CLL RTL
IFNZRO FTDEBUG <
	SZL			/CHECK FOR 200 BIT WHICH SAYES EXTENSIBLE
	  HLT			/CAN'T HACK NUMBERS THAT LARGE !
>/END OF IFNZRO FTDEBUG
	CLL RTL
	TAD	(-200
IGTEN9,	TAD	INTMP5
	ISZ	IGTEXN		/SKIP RETURN
	JMP I	IGTEXN

MYPTCH,	0
	TAD	(INTMSG
	DCA	ERRFLG
	JMP I	MYPTCH
	/HERE WHEN THE -10 WANTS TTY INPUT STOPPED ON A LINE
RCVXOF,	CLA
	TAD	(LDBXPT		/GET THE X-OFF WORD OFFSET IN THE LDB
	TAD	DDB		/ADD IN THE ADDRESS OF THE INDICATED LDB
	DCA	TEMP6		/AND STUFF IT IN A TEMP REGISTER
	TAD	(XOFMSG-1	/GET THE ADDRESS OF THE X-OFF MESSAGE
	DCA	I TEMP6		/AND STICK IT IN THE LDB
	JMS	TTYGO		/GO AND START TTY
	JMP	RCVTT0		/AND GO BACK TO WORK
	PAGE 

IACTCK,	0
	DCA	INTDDB		/SAVE DEVICE BLOCK ADR
	NLOAD	DEVSTS
	TAD	INTDDB
	DCA	IDBSTS
	TAD I	IDBSTS		/GET DEVSTS
	SMA CLA			/SKIP IF DEVICE IS ACTIVE
	  JMP	INTDIS	/DISMISS INTERRUPT
	JMP I	IACTCK		/RETURN TO CALLER

/HERE TO GET A FREE CHUNK AT INTERRUPT LEVEL
/ (-) CYCLES + JMS CYCLES
/CALL	JMS	ERSGET
/	ERROR RETURN
/	SUCCESS RETURN WITH CHUNK ADR IN AC

ERSGET,	0
	NL0
	TAD	FIRFRE		/GET ADR OF 1ST CHUNK
	SNA			/IS THERE A FIRST CHUNK ?
	  HLT			/MUST NEVER HAPPEN
				/ IMPLIES STARTED SOMETHING WE CAN'T FINISH

IFNZRO FTDEBUG < JMS ICNKCK >	/BE SURE ADR IS KOSHER
IFZERO FTDEBUG < DCA INTMP1 >	/SAVE ADR OF FIRST CHUNK

	TAD I	FIRFRE		/AND GET ADR OF 2ND CHUNK
	DCA	FIRFRE		/SET NEW FIRST FREE CHUNK
	DCA I	INTMP1		/CLEAR LINK IN THIS CHUNK

	NLM1
	TAD	FRECNT		/UPDATE FREE COUNT
IFNZRO FTDEBUG <
	SPA
	  HLT			/IT IS ALWAYS POSITIVE
>/END OF IFNZRO	FTDEBUG
	DCA	FRECNT

	TAD	INTMP1		/GET ADR OF CHUNK WE ARE GETTING
	JMP I	ERSGET

/HERE TO FREE A CNK
/(12-16) CYCLES + JMS CYCLES
/CALL	JMS	IFRCNK	(CALL WITH CNK ADR IN AC
/	RETURN		AC WILL BE 0, LINK UNDEFINED
IFRCNK,	0

IFZERO FTDEBUG <
	DCA	INTMP1		/SAVE ADR OF CHUNK
>/END OF IFZERO FTDEBUG

IFNZRO FTDEBUG <
	JMS	ICNKCK		/CHECK CHUNK ADR IS KOSHER
>/END OF IFNZRO FTDEBUG

	TAD	FIRFRE		/ADR OF FIRST FREE CHUNK
	DCA I	INTMP1		/SET LINK IN NEW FIRST CHUNK
	TAD	INTMP1
	DCA	FIRFRE
	ISZ	FRECNT		/COUNT FREE CHUNKS
	JMP I	IFRCNK
	HLT
/HERE TO CHECK A CHUNK ADR IS LEGAL
/ CALL	JMS	ICNKCK		/WITH IOF AND ADR IN AC
/	RETURN			/(AC)=0 AND ADR OF CHUNK IN INTMP1
ICNKCK,	0
	DCA	INTMP1		/SAVE CHUNK ADR
	TAD	INTMP1
	AND	[CNKSIZ-1
	SZA			/ALL CHUNKS BEGIN ON EVEN BOUNDRY
	  HLT			/THIS ONE DOESN'T ?
	CLL CLA			/CLEAR LINK
	TAD	FIRADR		/GET ADDRESS OF FIRST CHUNK
	CMA IAC			/CONVERT TO NEGATIVE
	TAD	INTMP1		/GET ADDR OF CHUNK AGAIN
	SNL CLA
	  HLT
	JMP I	ICNKCK

/HERE TO  MARK A DEVICE AS NOT ACTIVE
/ CALL	JMS	CLRACT		/WITH IOF AND INTDDB SETUP
/	RETURN
CLRACT,	0
	NLOAD	DEVSTS
	TAD	INTDDB		/MAKE ADR OF DEVSTS
	DCA	INTMP1
	NL3777			/MASK TO CLEAR ACTIVE BIT
	AND I	INTMP1
	DCA I	INTMP1		/SAVE NEW STATUS WORD
	JMP I	CLRACT

/HERE TO SET DDCMP STATUS WORD
/ CALL	SET UP INTDDB
/	LOAD NEW STATUS INTO AC
/	JMS	ISTDDC
ISTDDC,	0
	DCA	INTMP3		/SAVE NEW DDCMP STATUS WORD
	TAD	[DEVDDC		/OFFSET FOR DDCMP STATUS WORD
	TAD	INTDDB
	DCA	INTMP2
	TAD I	INTMP2
	NEGATE
	TAD	INTMP3		/GET NEW DDCMP STATUS WORD
	SNA CLA			/ARE THEY DIFFERENT ?
	  JMP I	ISTDDC		/NO SO RETURN
	TAD	INTMP3		/GET NEW STATUS WORD
	DCA I	INTMP2		/AND SET IT
	NLOAD	DEVSTS
	TAD	INTDDB
	DCA	INTMP1		/SAVE ADR OF STATUS WORD
	NL7776			/MASK FOR NEED-TO-SEND-STATUS BIT
	AND I	INTMP1		/CLEAR IT
	IAC			/SET IT
	DCA I	INTMP1		/SAVE IT
	JMP I	ISTDDC

/HERE TO SET A BIT IN THE DEVDDC WORD
/ CALL	JMS	ISBDDC	/WITH INTDDB SETUP AND BITS IN AC
/			/USES INTMP1 - INTMP4
ISBDDC,	0
	DCA	INTMP1		/SAVE BITS
	NLOAD	DEVSTS		/RELATIVE ADR OF STATUS WORD
	TAD	INTDDB
	DCA	INTMP3		/SAVE ADR OF STATUS WORD
	Q=DEVDDC-DEVSTS
	NLOAD	Q
	TAD	INTMP3		/MAKES ADR OF DEVDDC
	DCA	INTMP4		/SAVE ADR OF DEVDDC
	TAD I	INTMP4		/GET OLD DEVDDC
	DCA	INTMP2		/SAVE FOR FUTURE REFERENCE
	TAD	INTMP1		/GET BITS TO SET
	CMA			/MAKE INTO A MASK
	AND I	INTMP4		/CLEAR BITS IN DEVDDC
	TAD	INTMP1		/ADD BITS
	DCA I	INTMP4		/AND SAVE IN DEVDDC
	NL7776			/MASK TO REQUEST STATUS
	AND I	INTMP3		/CLEAR BIT FROM DEVSTS
	IAC			/SET BIT
	DCA I	INTMP3
	JMP I	ISBDDC
/HERE TO GET THE NEXT CHAR FROM A STRING OF CHUNKS POINTED TO BY TEMP3
/CALL	JMS	GETCHR
/	  RETURN WHEN NO MORE CHARS IN STRING(I.E. TEMP3 NOW 0
/	RETURN WITH CHAR IN AC(WILL BE 11 BITS ONLY)
GETCHR,	0
	NL0			/IN CASE AC NONZERO
	TAD	TEMP3
	SNA			/IS  STRING NULL ?
	  JMP I GETCHR		/YES SO NONSKIP RETURN
	AND	[CNKSIZ-1
	IOF
	SNA CLA			/ARE WE POINTING TO A LINK WORD ?
	  JMP	GETCH3		/YES
	TAD I	TEMP3		/GET THE LAST CHAR
	SPA CLA			/WAS LAST CHAR LAST IN ITS CHUNK ?
	  JMP	GETCH7		/YES SO ADVANCE CHUNKS

IFNZRO FTDEBUG <
	NL1
	TAD	TEMP3
	AND	[CNKSIZ-1
	SNA CLA
	  HLT
>/END OF IFNZRO FTDEBUG

GETCH3,	ISZ	TEMP3		/ADVANCE TO NEXT CHAR
	NL3777			/STRIP LAST DATA BIT IF PRESENT
	AND I	TEMP3		/GET NEXT CHAR
	ISZ	GETCHR		/SKIP RETURN
GETCH5,	ION
	JMP I	GETCHR
GETCH7,	TAD	TEMP3		/GET POINTER TO CURRENT CHAR
	AND	[-CNKSIZ	/MAKE POINTER TO FIRST WORD OF CHUNK
	DCA	TEMP3
	TAD I	TEMP3		/GET ADR OF NEXT CHUNK
	SNA
	  JMP	GETCH5		/NO MORE CHUNKS SO DONE

IFNZRO FTDEBUG <
	JMS	ICNKCK		/CHECK LINK HAD LEGAL CHUNK ADDRESS
	TAD	INTMP1
>/END OF INZRO FTDEBUG

	DCA	TEMP3
	JMP	GETCH3		/GO GET NEXT CHAR

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CTY SERVICE				***
/	***		GAS FOR LESS				***
/	***							***
/	***********************************************************
/	***********************************************************


/HERE AT INTERRUPT LEVEL TO TEST FOR CTY INTERRUPTS
INTCTY,	CTYKSF			/TYPING SOMETHING?
	  JMP	INTCTO		/NOT KEYBOARD - CHECK XMTR
	TAD	(CTYBLK		/ADR OF DEVICE BLOCK
	DCA I	TIQPTR		/SAVE ADR
	CTYKRB			/READ KEYBOARD & RESET FLAG
/HERE TO PUT CHAR INTO TTI QUEUE AND BE SURE QUEUE IS NOT GARBLED
INTYI9,	DCA I	TIQPTR		/SAVE CHAR
	TAD	TIQPTR
	TAD	(1-TTIQUE-TIQLEN
	SZA CLA			/HAVE WE FILLED THE QUEUE ?
	  JMP	.+3		/NO
	TAD	(TTIQUE-1
	DCA	TIQPTR

/NOW CHECK TO SEE QUEUE HASN'T OVERFLOWED
	TAD	TIQPTR
	NEGATE
	TAD	TIQTKR		/HAVE WE FILLED THE QUEUE
	SNA CLA
	  HLT
	NLM1
	DCA	WRKREQ		/FIND THIS ASAP
IFNZRO FTDC02F <
	JMS	ALLSEL		/REENABLE ALL LINES
>/END OF IFNZRO FTDC02F
	JMP	INTDIS

INTCTO,	CTYTSF			/SKIP ON CTY TRANSMIT FLAG
	  JMP	INTCT9		/NOT CTY - CHECK NEXT DEVICE
	TAD	(CTYBLK
INTTYX,	DCA	INTDDB
	JMS	XMTINT		/SEE WHAT IS LEFT TO GO
	JMP	INTDIS
/ CALL:	JMS	TTYGO	WITH DDB& DDBSTS SETUP
/	RETURN			/POSSIBLY WITH GARBAGE IN AC
/HERE AT NONINTERRUPT LEVEL TO START A TTY IF IT WERE INACTIVE
TTYGO,	0
	TAD	DDB		/GET DEVICE BLOCK ADR
	IOF
	DCA	INTDDB		/SAVE IT WHERE XMTINT WANTS IT
	NL4000
	TAD I	DDBSTS		/MAKE ACTIVE STATUS
	SMA
	  JMP	.+3		/EXIT BECAUSE ALREADY ACTIVE
	DCA I	DDBSTS
	JMS	XMTINT
	NL0			/CLEAR AC
	JMP I	TTYGO

GTCHR,	0
	JMS	GETCHR
	  HLT
	JMP I	GTCHR

IFNZRO	DP8ETR	<
OTR,	0			/TRACE OUTPUT MESSAGE
	TAD	T10NWC		/NUMBER OF CHARACTERS
	DCA	TEMP1		/SAVE FOR LOOP CONTROL
	TAD	T10NCA		/BEGINNING OF MESSAGE
	DCA	AUTO1		/ INTO AUTOINDEX POINTER
OTRL,	TAD I	AUTO1		/GET NEXT CHARACTER
	IOF
	JMS	TRACEW		/TRACE IT
	ION
	ISZ	TEMP1		/SKIP IF FINISHED
	  JMP	OTRL		/ELSE CONTINUE
	JMP I	OTR
>/END OF IFNZRO	DP8ETR
DEFINE	DISCDE	<
DISSND,				/SEND DEVICE UNAVAILABLE DISCONNECT
	TAD	TEMPC		/RCVDSP TABLE ENTRY
	TAD	(-RCVDSP-1+SNATAB/POINT TO SNATAB ENTRY
	DCA	TEMP1
	TAD I	TEMP1		/GET DNA
	DCA	DISSNA		/STORE FOR XDISBG
	DCA I	TEMP1		/CLEAR SNATAB ENTRY
	JMS	XDISBG		/BEGINNING OF DISCONNECT
	TAD	[5		/COUNT
	JMS	SNDCHR
	NL2
	JMS	SNDCHR		/TYPE=DISCONNECT
	TAD	TEMPC		/RCVDSP ENTRY
>/END OF DEFINE	DISCDE
DEFINE	DISCD1	<
	TAD	(-RCVDSP-1+SLATAB/SLATAB ENTRY
	DCA	TEMP1
>/END OF DEFINE	DISCD1
DEFINE	DISCD2	<
	TAD I	TEMP1		/GET DLA
	JMS	SNDEXN
	JMS	SNDCHR		/SLA=0
	TAD	TEMPC
	TAD	(-RCVDSP-1+MMLTAB/MMLTAB HOLDS REASON
	DCA	TEMP1
	TAD I	TEMP1
	JMS	SNDCHR
	TAD	(RCVKRD		/UNUSED VALUE
	DCA I	TEMPC		/INTO RCVDSP
	JMP	FINMSG
>/END OF DISCD2 DEFINITION
IFZERO TTYN <
	DISCDE
	DISCD1
	DISCD2
	PAGE 
>/END OF IFZERO	TTYN
	LISTOG	TTYN
IFNZRO TTYN <
	LISTOG	FTDC02F
IFNZRO FTDC02F <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		DC02F SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

INTTTY,	DCA	INTMP2		/SET UP FOR A COUNTER
	TAD	(0010		/SELECT GROUP 1 ONLY
	DCMTKF			/GET THE KEYBOARD FLAGS
	AND	DC1MSK		/SOME TTY'S WE DON'T CARE ABOUT

IFDEF DC2MSK <
	SZA
	  JMP	INTYI2		/ONE OF THESE HAS GONE OFF
	TAD	(10
	DCA	INTMP2
	NL4			/MASK FOR SECOND GROUP
	DCMTKF			/GET KEYBOARD FLAGS FOR 2ND GRP
	AND	DC2MSK
>/END OF IFDEF DC2MSK

IFDEF DC3MSK <
	SZA
	  JMP	INTYI2		/ONE OF THESE HAS GONE OFF
	TAD	(20
	DCA	INTMP2
	NL2			/MASK FOR THIRD GROUP
	DCMTKF			/GET KEYBOARD FLAGS FOR 3RD GRP
	AND	DC3MSK
>/END OF IFDEF DC3MSK

	SNA
	  JMP	INTTTO
INTYI2,	JMS	INTTY5
	DCA I	TIQPTR		/SAVE DDB ADR
	TAD	(17
	DCMTON			/SELECT NO LINES
	NL0
	TAD I	INTMP3		/GET DDB ADR
	TAD	[LDBADR	
	DCA	INTMP3
	TAD I	INTMP3		/GET BITS FOR STATION SELECT
	DCMTON			/SELECT LINE
	NL0			/CLEAR AC AGAIN
	DCMKRS DCMKCC
	JMP	INTYI9		/CHECK TO BE SURE TTI QUEUE IS STILL KOSHER
	HLT
/HERE TO TEST FOR POSSIBLE XMT INTERRUPTS
INTTTO,
IFDEF DC3MSK <
	NL2			/MASK FOR 3RD GROUP
	DCMTPF			/GET PRINTER FLAGS
	AND	DC3MSK
	SZA
	  JMP	INTYO2
	DCA	INTMP2
>/END OF IFDEF DC3MSK

IFDEF DC2MSK <
	NL4			/MASK FOR 2ND GROUP
	DCMTPF			/GET PRINTER FLAGS
	AND	DC2MSK
	SZA
	  JMP	INTYO2
	DCA	INTMP2
>/END OF IFDEF DC2MSK

	TAD	(0010		/MASK FOR 1ST GROUP
	DCMTPF			/GET PRINTER FLAGS
	IFNDEF DC2MSK <
	AND	DC1MSK
>/END OF IFNDEF DC2MSK
	SNA			/ANY READY
	  JMP	INTTY9		/NO
INTYO2,	JMS	INTTY5		/CONVERT BIT PATTERN TO LINE INDEX
	JMP	INTTYX		/GO TO XMTINT THEN DISMISS

/ROUTINE TO CONVERT RESULTS OF DCMTKF OR DCMTPF TO A LINE INDEX
INTTY5,	0
	SPA
	  JMP	INTTY6
	ISZ	INTMP2
	CLL RAL
	JMP	INTTY5+1
INTTY6,	NL0
	TAD	INTMP2
	TAD	(DDBTAB+1
	DCA	INTMP3
	TAD I	INTMP3		/GET TTY DDB ADR
	JMP I	INTTY5

/HERE FROM CODE FOLLOWING XMTINT TO CLEAR ALL OUTPUT FLAGS
TTOFIN,	JMS	TTOSEL
	DCMTCF
	JMS	ALLSEL		/SELECT ALL LINES AGAIN
	JMP	XMTDIS		/DISMISS CALL TO XMTINT

/HERE FROM CODE FOLLOWING XMTINT TO TYPE AN OUTPUT CHAR
INTYPE,	JMS	TTOSEL
	NL0
	TAD	INTMP6		/GET CHAR TO TYPE
	DCMTCF DCMTPC		/TYPE IT
	JMS	ALLSEL		/SELECT ALL LINES AGAIN
	JMP	XMTDIS		/DISMISS CALL TO XMTINT
TTOSEL,	0
	TAD	(17
	DCMTON
	NL0
	TAD	[LDBADR
	TAD	INTDDB
	DCA	INTMP2
	TAD I	INTMP2
	TAD I	INTDDB		/GET HDW ADR FOR DC02 LINE
	DCMTON
	JMP I	TTOSEL

	PAGE
>/END OF IFNZRO FTDC02F
	LISTOG 0
IFZERO FTDC02F <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		KL8E SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

INTYI1,	0
	CDFINS
	TAD I	INTYI1		/GET DDB ADR
	SNA			/DO WE BELIEVE IN HIM ?
	  JMP	INTYI3		/NO SO FLUSH IT
	CDFCNK			/BACK TO NORMAL DATA FIELD
	DCA I	TIQPTR		/PUT INTO TTY INPUT QUEUE
	NLM3
	TAD	INTYI1
	DCA	INTMP1
	CDFINS			/CHANGE TO INSTRUCTION FIELD
	TAD I	INTMP1
	CDFCNK			/BACK TO NORMAL DATA FIELD
	TAD	[0005		/MAKES A KRB
	DCA	.+1
	0
	JMP	INTYI9

INTYI3,	NLM3
	TAD	INTYI1		/MAKES ADR OF KRB
	DCA	INTMP1
	NL1			/WILL CONVERT KSF TO KCF
	TAD I	INTMP1		/MAKES KCF
	CDFCNK			/BACK TO NORMAL DATA FIELD
	DCA	.+1
	0			/THIS IS A KCF
	JMP	INTDIS

/HERE WHEN A KL8E LINE HAS AN XMT INTERRUPT
INTYO1,	0
	CDFINS			/CHANGE DATA FIELD TO PICK UP AN INSTRUCTION
	TAD I	INTYO1
	CDFCNK			/BACK TO NORMAL DATA FIELD
	JMP	INTTYX		/POKE XMTINT

/HERE FROM CODE FOLLOWING XMTINT TO CLEAR ALL OUTPUT FLAGS
TTOFIN,	
	TAD	[LDBADR
	TAD	INTDDB
	DCA	INTMP2
	TAD	(7773		/MASK TO MAKE TLS INTO TCF
	AND I	INTMP2
	DCA	.+1
	0
	JMP	XMTDIS

/HERE FROM CODE FOLLOWING XMTINT TO TYPE AN OUTPUT CHAR
INTYPE,	
	TAD	[LDBADR		/POINT TO ADDRESS FIELD
	TAD	INTDDB		/IN DDB
	DCA	INTMP2		/STORE ADDRESS OF IOT INSTRUCTION
	TAD I	INTMP2		/GET IOT
	DCA	.+2
	TAD	INTMP6		/GET CHAR
	0
	JMP	XMTDIS
DISSN2,	DISCD2

	PAGE
DEFINE KSF Q QQ <	XLIST
	IFDEF QQ <	XLIST
		Q			/SKIP ON KYBD INTERRUPT
		JMP	.+3
		JMS I	[INTYI1		/KYBD INTERRUPT
		QQ	/ADR OF DDB
		XLIST	>/END OF IFDEF QQ
	XLIST	>/END OF DEFINE	KSF

INTTTY,	KSF T00KSF,T00BLK		/TEST FOR KYBD ON LINE 0
	KSF T01KSF,T01BLK		/TEST FOR KYBD ON LINE 1
	KSF T02KSF,T02BLK		/TEST FOR KYBD ON LINE 2
	KSF T03KSF,T03BLK		/TEST FOR KYBD ON LINE 3
	KSF T04KSF,T04BLK		/TEST FOR KYBD ON LINE 4
	KSF T05KSF,T05BLK		/TEST FOR KYBD ON LINE 5
	KSF T06KSF,T06BLK		/TEST FOR KYBD ON LINE 6
	KSF T07KSF,T07BLK		/TEST FOR KYBD ON LINE 7
	KSF T10KSF,T10BLK		/TEST FOR KYBD ON LINE 10
	KSF T11KSF,T11BLK		/TEST FOR KYBD ON LINE 11
	KSF T12KSF,T12BLK		/TEST FOR KYBD ON LINE 12
	KSF T13KSF,T13BLK		/TEST FOR KYBD ON LINE 13
	KSF T14KSF,T14BLK		/TEST FOR KYBD ON LINE 14
	KSF T15KSF,T15BLK		/TEST FOR KYBD ON LINE 15
	KSF T16KSF,T16BLK		/TEST FOR KYBD ON LINE 16
	KSF T17KSF,T17BLK		/TEST FOR KYBD ON LINE 17

/NOW CHECK FOR TRANSMIT INTERRUPTS
ZZ=TTYN

DEFINE TSF Q QQ <	XLIST
	IFNZRO ZZ <
	ZZ=ZZ-1
		XLIST
		Q			/SKIP ON XMT FLAG
		XLIST
	IFNZRO ZZ <	XLIST
	 	JMP	.+3
		XLIST>/END OF IFNZRO ZZ
	IFZERO ZZ <	XLIST
		JMP I	[INTTY9
		XLIST>/END OF IFZERO ZZ
		XLIST
		JMS I	[INTYO1
		QQ	/ADR OF DEVICE BLOCK
		XLIST	>/END OF IFNZRO	ZZ
	XLIST	>/END OF TSF DEFINITION

	TSF T00TSF,T00BLK		/CHECK LINE 0 FOR XMT INTERRUPT
	TSF T01TSF,T01BLK		/CHECK LINE 1 FOR XMT INTERRUPT
	TSF T02TSF,T02BLK		/CHECK LINE 2 FOR XMT INTERRUPT
	TSF T03TSF,T03BLK		/CHECK LINE 3 FOR XMT INTERRUPT
	TSF T04TSF,T04BLK		/CHECK LINE 4 FOR XMT INTERRUPT
	TSF T05TSF,T05BLK		/CHECK LINE 5 FOR XMT INTERRUPT
	TSF T06TSF,T06BLK		/CHECK LINE 6 FOR XMT INTERRUPT
	TSF T07TSF,T07BLK		/CHECK LINE 7 FOR XMT INTERRUPT
	TSF T10TSF,T10BLK		/CHECK LINE 10 FOR XMT INTERRUPT
	TSF T11TSF,T11BLK		/CHECK LINE 11 FOR XMT INTERRUPT
	TSF T12TSF,T12BLK		/CHECK LINE 12 FOR XMT INTERRUPT
	TSF T13TSF,T13BLK		/CHECK LINE 13 FOR XMT INTERRUPT
	TSF T14TSF,T14BLK		/CHECK LINE 14 FOR XMT INTERRUPT
	TSF T15TSF,T15BLK		/CHECK LINE 15 FOR XMT INTERRUPT
	TSF T16TSF,T16BLK		/CHECK LINE 16 FOR XMT INTERRUPT
	TSF T17TSF,T17BLK		/CHECK LINE 17 FOR XMT INTERRUPT

Z=.-INTTTY
Z=Z-200
IFNZRO Z <PAGE>

>/END OF IFZERO FTDC02F
	XISTOG	FTDC02F
>/END OF IFNZRO TTYN
	LISTOG	TTYN
/	***********************************************************
/	***********************************************************
/	***							***
/	***			RECINT-DDCMP			***
/	***		BASE LEVEL TTY INPUT HANDLING		***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO HANDLE TTY INPUT
/ CALLED FROM LOOP - WILL RETURN TO LOOP
/ TAKES NEXT CHAR FROM TTIQUE AND PUTS IT INTO AN INPUT CHUNK
/TEMP USAGE IS
/	TEMP8	IS POINTER TO LDBXPT
/	TEMP7	ADR OF DDCMP STATUS WORD
/	TEMP6	ADR OF DEVBF1
/	TEMP5	CHAR
/	TEMP4	ADR OF CHRTAB BITS

/DEVDDC BITS
/	0001	/DEFERED ECHO MODE
/	0002	/TRANSLATE LOWER CASE TO UPPER
/	0004	/OUTPUT HAS BEEN FROZEN BY TYPEIN OF XOF
/	0010	/IMAGE MODE INPUT
/	0020	/IMAGE MODE OUTPUT
/	0040	/TTY PAGE IN EFFECT
/	0100	/TTY TAPE FEATURE(IMPLIES SUPPRESS NORMAL CR HANDLING)
/	0200	/TTY HAS HDW TAB
/	0400	/INPUT STOPPED BY SENDING XOFF TO TTY
/	1000	/DATA TERMINAL READY
/	6000	/0=NONE
/		/1 NG
/		/2 DATA SET READY
/		/3 CARRIER DETECT

RECINT,	IOF			/SO WE DON'T MISS A QUEUE OVERFLOW
	TAD I	TIQTKR		/GET LINE #
	DCA	DDB
	TAD I	TIQTKR		/GET CHAR
	AND	[0377		/8 BITS ONLY(THIS ISN'T NECESSARY)
	DCA	TEMP5		/SAVE CHAR

	TAD	TIQTKR
	TAD	(1-TTIQUE-TIQLEN
	SZA CLA
	  JMP	RECIN0		/DON'T NEED TO RESET POINTERS
	TAD	(TTIQUE-1
	DCA	TIQTKR

RECIN0,	ION			/MATCHES IOF AT RECINT
	TAD	TEMP5		/GET CHARACTER
	AND	[0177		/SEVEN BITS ONLY
	TAD	(CHRTAB		/SCNSER CHAR TABLE ADR
	DCA	TEMP4		/SAVE ADR OF CHAR TYPE BITS

	NLOAD	DEVSTS
	TAD	DDB		/MAKE STATUS ADR
	DCA	DDBSTS		/SAVE FOR TTYGO

	Q=DEVBF1-DEVSTS
	NLOAD	Q
	TAD	DDBSTS
	DCA	TEMP6		/SAVE POINTER TO DEVBF1

	TAD	(LDBXPT
	TAD	DDB
	DCA	TEMP8		/SAVE POINTER TO XOF LEVEL STRING

	Q=DEVDDC-DEVSTS
	NLOAD	Q
	TAD	DDBSTS		/DEVICE STATUS
	DCA	TEMP7		/SAVE ADR OF DEVDDC

	TAD	(0010		/MASK FOR IMAGE MODE INPUT
	AND I	TEMP7		/COMPARE AGAINST DDCMP STATUS
	SZA CLA			/SKIP IF NOT IN IMAGE MODE INPUT
	  JMP	RECIN1		/IMAGE MODE INPUT
	TAD	TEMP5		/GET CHARACTER
	SNA CLA			/CHECK FOR NULL
	  JMP	LOOP		/FLUSH NULLS

	NLOAD	CHRLC		/MASK FOR CHAR IS LOWER CASE
	AND I	TEMP4		/TEST AGAIN CHRTAB
	SNA CLA
	  JMP	RECIN1		/CHAR IS NOT LOWER CASE
	NLOAD	2		/MASK FOR SHOULD TRANSLATE
	AND I	TEMP7		/COMPARE AGAINST DDCMP STATUS
	SZA CLA
	  TAD	(-240		/CONVERT TO UPPER CASE
	TAD	TEMP5		/ AND COMPLEMENT PARITY BIT
	AND	(0377		/CLEAR EXTRANEOUS BITS, INCLUDING "LAST IN CHUNK" FLAG
	DCA	TEMP5		/ AND SAVE CHAR AGAIN

RECIN1,	NLOAD	CONBIT		/MASK FOR DEVICE CONNECTED
	AND I	DDBSTS
	SNA CLA			/IS IT CONNECTED ?
	  JMP	CONTYP		/NO SO TELL USER
	TAD	(-ERSCNT
	TAD	FRECNT
	SPA CLA
	  JMP	BELTYP		/NO FREE CHUNKS
	TAD I	TEMP6		/GET CONTENTS OF DEVBF1
	DCA	TEMP3		/SAVE WHERE GETCHR CAN USE IT
	JMS	GETCHR
	  NL0			/COUNT IS ZERO
	TAD	(-30		/24 DECIMAL
	SMA CLA			/HAS USER TYPED FAR AHEAD ?
	  JMP	BELTYP		/YES SO DING HIM
RECIN2,	JMS	RECI42		/PUT STATUS INTO THE MESSAGE
	NLOAD	1		/MASK FOR DEFERRED ECHO
	AND I	TEMP7		/COMPARE WITH DEVDDC
	SZA CLA			/SKIP IF NOT DEFERRED ECHO
	  JMP	RECIN5		/ALREADY IN DEFERRED ECHO MODE

	NLOAD	DEVOAD		/POINTER TO OUTPUT DATA
	TAD	DDB
	DCA	TEMP1
	TAD I	TEMP1
	SZA CLA			/IS THERE OUTPUT DATA WAITING ?
	  JMP	RECIN4		/YES SO GO INTO DEFERRED ECHO MODE
	Q=LDBFPT-LDBXPT
	NLOAD	Q
	TAD	TEMP8
	IOF			/WE WILL MODIFY INTERRUPT LOCATIONS
	DCA	TEMPA		/SAVE POINTER TO LDBFPT
	TAD	TEMPA		/GET LDBFPT
	IAC
	DCA	TEMPB		/SAVE POINTER TO LDBCHR
	TAD I	TEMPA		/GET FILLER WAITING
	TAD I	TEMPB		/ANY CHARS LEFT TO ECHO FROM BEFORE ?
	SZA CLA
	  JMP	RECIN4		/YES SO ENTER DEFERRED ECHO MODE
	TAD I	TEMP4		/GET CHRTAB BITS FOR THIS CHARACTER
	SPA CLA			/IS CHAR A BREAK CHAR ?
	  JMP	RECIN4		/YES SO ENTER DEFERRED ECHO MODE
	JMS	RECIN6		/PUT CHAR INTO THE INPUT CHUNKS
	TAD	TEMP5		/GET CHAR TO ECHO
	AND	[0177		/SEVEN BITS ONLY
	TAD	(-15		/TEST FOR CARRIAGE RETURN
	SNA CLA
	  JMP	RECI36		/CHAR IS A CR
	TAD	TEMP5		/GET CHAR TO ECHO
	DCA I	TEMPB		/AND PUT IT INTO LDBCHR
TSTART,	JMS	TTYGO		/TRY TO START THE TTY
	JMP	LOOP		/AND BACK TO THE BIG LOOP

/HERE TO LOCAL-ECHO A CR
RECI36,	TAD	(CRLMSG-1	/CR-LF STRING
	DCA I	TEMPA		/SET LDBFPT
	JMS	RECI37		/SET DEFERRED ECHO MODE
	JMP	TSTART		/ALL DONE
BELTYP,	NL0
	TAD	(TTOBEL-1	/THIS IS JUST A BELL
CNTYP2,
	DCA I	TEMP8		/SET LDBXPT
	JMP	TSTART

	PAGE

/HERE TO SET DEFERRED ECHO MODE
RECI37,	0
	TAD	DDB
	IOF			/IN CASE NEED TO CALL ISBDDC
	DCA	INTDDB
	NLOAD	1		/DEFERRED ECHO MODE BIT
	JMS	ISBDDC		/SET BIT IN DEVDDC
	JMS	RECI42		/PUT STATUS INTO THE MESSAGE
	JMP I	RECI37

/HERE TO SET DEFERRED ECHO MODE
RECIN4,	JMS	RECI37		/SET DEFERRED-ECHO MODE

/HERE IF TTY IS IN DEFERRED ECHO MODE
RECIN5,	JMS	RECIN6		/PUT CHAR INTO THE INPUT CHUNKS
	TAD	DDB
	IOF			/IN CASE NEED TO CALL ISBDDC
	DCA	INTDDB
	TAD	(CHRXOF		/MASK FORXOF BIT
	AND I	TEMP4		/MASK AGAINST CHRTAB BITS
	SNA CLA
	  JMP	LOOP		/NOT AN XOF
	TAD I	TEMP7		/GET DEVDDC
	AND	[0040		/MASK FOR TTY PAGE
	SNA CLA
	  JMP	LOOP		/NOT IN TTY PAGE
	NLOAD	4		/FLAG OUTPUT FROZEN
	JMS	ISBDDC		/SET BIT IN DEVDDC AND TELL 10
	JMS	RECI42		/PUT STATUS INTO STRING MAYBE
	JMP	LOOP

/HERE TO PUT AN INPUT CHAR INTO THE CHUNKS
RECIN6,	0
	TAD	TEMP6		/GET ADR OF DEVBF1
	IAC
	DCA	TEMP2		/SAVE POINTER TO DEVBF2
	TAD I	TEMP2		/GET DEVBF2(=POINTER TO DATA COUNT)
	SZA CLA
	  JMP	RECI62
	NL1
	JMS	RECI70		/PUT COUNT INTO THE CHUNKS
	TAD I	TEMP3		/GET LDBIPT
	DCA I	TEMP2		/SET DEVBF2
	NL1			/TYPE=1 FOR DATA
	JMS	RECI70		/PUT LINE NUMBER INTO THE CHUNKS
RECI62,	TAD	TEMP5		/GET THE CHARACTER WE JUST GOT
	JMS	RECI70		/PUT IT INTO THE CHUNKS
	TAD I	TEMP2		/GET DEVBF2
	DCA	TEMP2
	ISZ I	TEMP2		/COUNT IT
	JMP I	RECIN6

/HERE TO PUT STATUS INTO INPUT STRING FOR A LINE
RECI42,	0
	NLOAD	1		/MASK FOR NEED TO SEND STATUS
	AND I	DDBSTS		/CHECK AGAINST DEVSTS
	SNA CLA
	  JMP I	RECI42		/DON'T NEED TO
	TAD	TEMP6		/GET POINTER TO DEVBF1
	IAC			/MAKE INTO POINTER TO DEVBF2
	DCA	TEMP1
	DCA I	TEMP1
	NLOAD	4		/CHAR COUNT FOR STATUS IS ALWAYS 4 CHARS
	JMS	RECI70
	NL3			/STATUS IS TYPE 3
	JMS	RECI70		/PUT CODE INTO THE MESSAGE
	JMS	RECI70		/STC=0
	TAD I	TEMP7		/GET DEVDDC
	AND	[0177		/SEVEN BITS ONLY
	TAD	(0200		/ADD EXTENSIBLE BIT
	JMS	RECI70		/PUT 1ST HALF OF STATUS INTO STRING
	TAD I	TEMP7		/GET DEVDDC AGAIN
IFZERO	PDP8I	<
	CLL RTR			/NOT RTL
	CLL RTR			/THRU LINK
	CLL RTR
>
IFZERO	PDP8E	<
	BSW
>
	CLL RAR
	AND	(0037		/STRIP EXTRA BITS
	JMS	RECI70		/PUT INTO THE STRING
	NLOAD	7776		/MASK FOR NEED-TO-SEND-STATUS BIT
	IOF
	AND I	DDBSTS
	DCA I	DDBSTS
	JMP I	RECI42
/HERE TO PUT A CHARACTER INTO THE CHUNKS
/ CALL	JMS	RECI70	WITH CHAR IN AC
/	RETURN
RECI70,	0
	IOF
	DCA	INTMP4		/SAVE CHAR
	TAD	(LDBIPT
	TAD	DDB
	DCA	TEMP3		/SAVE POINTER TO LDBIPT
	TAD I	TEMP6		/GET DEVBF1
	SZA CLA
	  JMP	RECI72		/ALREADY HAVE AT LEAST ONE CHUNK
	JMS	ERSGET		/GET A CHUNK
	DCA I	TEMP6		/SET DEVBF1
	TAD I	TEMP6		/GET DEVBF1 AGAIN
	DCA I	TEMP3		/SET LDBIPT
RECI72,	TAD I	TEMP3		/GET LDBIPT
	IAC
	AND	[CNKSIZ-1
	SZA CLA
	  JMP	RECI75
	TAD I	TEMP3		/GET LDBIPT
	AND	[-CNKSIZ	/MAKE ADR OF LINK WORD
	DCA	INTMP3		/SAVE ADR OF LINK WORD
	JMS	ERSGET		/GET ANOTHER CHUNK
	DCA I	INTMP3		/SET LINK ADR IN PREVIOUS CHUNK
	TAD I	INTMP3		/GET CHUNK ADR AGAIN
	DCA I	TEMP3		/SET LDBIPT
RECI75,	TAD I	TEMP3		/GET ADR OF PREVIOUS CHAR
	DCA	INTMP3
	NLOAD	3777		/MASK FOR LAST DATA BIT
	AND I	INTMP3		/STRIP PREVIOUS CHAR OF LAST BIT
	DCA I	INTMP3		/AND SAVE IT AGAIN WITHOUT BIT
	ISZ	INTMP3		/ADVANCE TO NEXT CHAR SLOT
	NLOAD	4000		/MASK FOR LAST CHAR IN CHUNK
	TAD	INTMP4		/GET CHAR
	DCA I	INTMP3
	ISZ I	TEMP3		/ADVANCE LDBIPT
	ION
	JMP I	RECI70		/RETURN TO CALLER

TDBCHK,	0			/CHECK TTY NUMBER IS VALID
	TAD	(-TTYN-1	/MAKE NEGATIVE IF OK
	SMA			/IS TTY INRANGE?
	  JMP	BADTYP		/REJECT CONNECTION
	TAD	(TTYN+1		/RESTORE TTY NUMBER
	JMP I	TDBCHK		/RETURN
	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***			DDCMP - XMTINT			***
/	***		INTERUPT LEVEL TTY HANDLING		***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE AT INTERRUPT LEVEL TO GET NEXT CHAR TO SEND TO A TTY
/ CALL	LOAD INTDDB WITH ADR OF BLOCK
/	JMS	XMTINT	WILL FIND NEXT CHAR AND TYPE IT
/	RETURN		WILL CLRACT IF ALL DONE
/		AC MAY CONTAIN GARBAGE ON RETURN
/
/ TEMPORARY STOARAGE IS:
/	INTMP7		/POINTER TO DEVTIM
/	INTMP6		/CHAR TO TYPE
/	INTMP5		/POINTER TO DEVSTS

XMTDIS,	JMP I	XMTINT
XMTINT,	0

/CLEAR IRMA BIT
	NLOAD	DEVSTS		/RELATIVE ADR OF STATUS WORD
	TAD	INTDDB
	DCA	INTMP5		/SAVE POINTER TO DEVSTS
	TAD	(DEVTIM		/RELATIVE ADR OF DEVICE TIME
	TAD	INTDDB		/MAKE ABSOLUTE
	DCA	INTMP7		/SAVE POINTER TO DEVTIM

/CLEAR THE IRMA BIT
	Q=-IRMBIT-1
	NLOAD	Q		/MASK TO CLEAR IRMA BIT
	AND I	INTMP5
	DCA I	INTMP5

/SEE IF WE ARE SIMULATING A TAB
	TAD	(CHRBLA		/POINT TO A WORD WHICH HAS HORIZONTAL MOTION BIT ON
	DCA	INTMP1		/STORE ADDRESS OF THIS WORD
	NL4			/MASK FOR TAB SIMULATION BIT
	AND I	INTMP5		/LOOK AT STATUS
	SZA CLA
	  JMP	IXMT33		/YES, CONTINUE

/CHECK TO SEE IF WE ARE TIMING A FILLER
	TAD I	INTMP7		/GET DEVTIM
	SZA CLA			/ARE WE DOING A FILLER ?
	  JMP	IXMT92		/YES SO JUST CLEAR THE INTERRUPT

/FIRST CHECK IF THERE IS ANY XON/XOF LEVEL OUTPUT
	TAD	(LDBXPT
	TAD	INTDDB
	DCA	INTMP4
	TAD I	INTMP4		/PICK UP POINTER
	SZA
	  JMP	IXMT15		/YES THERE IS XON/XOF OUTPUT
	ISZ	INTMP4		/NOW TRY FILL CLASS POINTER
	TAD I	INTMP4
	SNA			/IS THIS POINTER READY ?
	  JMP	IXMT17		/KEEP LOOKING

/FOLLOWING IS USED BOTH FOR XON/XOF LEVEL, AND FOR FILL LEVEL OUTPUT
IXMT15,	ISZ I	INTMP4		/ADVANCE MEMORY COPY OF POINTER
	IAC			/ADVANCE AC COPY OF POINTER
	DCA	INTMP1
	TAD I	INTMP1		/GET NEXT CHAR
	SMA			/IS THIS LAST CHAR IN STRING ?
	  JMP	IXMT30		/NO SO JUST TYPE IT
	DCA	INTMP6		/SAVE CHAR
	DCA I	INTMP4		/CLEAR POINTER
	JMP	IXMT32		/GO TYPE THE CHAR

IXMT17,	ISZ	INTMP4		/ADVANCE TO LDBCHR
	TAD I	INTMP4		/SEE IF THERE IS A CHAR IN SLOT
	SNA			/WAS THERE A CHAR ?
	  JMP	IXMT20		/NO - TRY FOR OUTPUT
	DCA	INTMP6		/SAVE CHAR
	DCA I	INTMP4		/CLEAR LDBCHR
	JMP	IXMT31		/TYPE CHAR(WITH SPECIAL ECHO PROCESSING)

/CHECK TO SEE IF THERE ARE ANY OUTPUT CHARS
IXMT20,	Q=DEVDDC-DEVSTS
	NLOAD	Q
	TAD	INTMP5		/MAKES ADR OF DEVDDC
	DCA	INTMP1
	NLOAD	4		/MASK FOR OUTPUT FROZEN WITH XOF
	AND I	INTMP1		/COMPARE AGAINST DEVDDC
	SNA CLA			/WAS OUTPUT FROZEN ?
	JMS	IGTOCH		/TRY TO GET ANOTHER CHAR FROM THE CHUNKS
	  JMP	IXMT90		/NONE LEFT OR OUTPUT FROZEN

	DCA	INTMP6		/SAVE THE CHAR
	JMP	IXMT32
/HERE TO TYPE NEXT CHAR
IXMT30,	DCA	INTMP6		/SAVE CHAR
IXMT31,
IXMT32,	TAD	INTMP6		/GET CHARACTER AGAIN
	AND	[0177		/7 BITS ONLY
	TAD	(CHRTAB		/MAKE POINTER INTO THE CHARACTER TABLE
	DCA	INTMP1		/ADDRESS OF CHARACTER TABLE ENTRY
	TAD	(CHRHT
	AND I	INTMP1		/GET HT BIT
	SNA CLA
	  JMP	IXMT50
/HERE TO CHECK IF TTY HAS HARDWARE TABS
	NLOAD	Q
	TAD	INTMP5
	DCA	INTMP2
	TAD I	INTMP2		/DEVDDC
	AND	(220		/HDW TAB BIT OR IMAGE OUTPUT
	SZA CLA			/SKIP IF NEITHER
	  JMP	IXMT50		/EITHER OR BOTH, SO PRINT TAB
/START OF TAB SIMULATION
	NL4
	TAD I	INTMP5
	DCA I	INTMP5
	TAD	(CHRBLA		/POINT TO CHARACTER WITH HMO BIT ON
	DCA	INTMP1		/SAVE ADDRESS
	JMP	IXMT33
IXMT50,
	NLOAD	CHRFLL		/MAKE MASK FOR CHAR NEEDS A FILLER
	AND I	INTMP1		/GET SPECIAL CHARACTER BITS
	SNA CLA
	  JMP	IXMT33		/DOESN'T NEED A FILLER
	TAD	INTMP6		/GET CHARACTER AGAIN(MUST BE IN RANGE 10-15)
	AND	[0007		/THREE BITS ONLY
	TAD	(LDBFIL
	TAD	INTDDB
	DCA	INTMP2
	TAD I	INTMP2		/GET TIME TO STALL ON THIS CHAR
	SNA			/IS THERE ANY FILLER FOR THIS ONE ?
	  JMP	IXMT33		/NO
	DCA I	INTMP7		/AND SET DEVTIM
IXMT33,	TAD	(LDBCOL		/RELATIVE ADR OF HORIZONTAL POSITION
	TAD	INTDDB		/MAKE ABSOLUTE
	DCA	INTMP3		/SAVE LDBCOL ADDRESS
	TAD I	INTMP1		/GET CHRTAB BITS
	AND	(CHRHMO		/MASK FOR HORIZONTAL MOTION
	SZA CLA
	  ISZ I	INTMP3		/INCREMENT HORIZONTAL POSITION
	NL4			/TAB BIT MASK
	AND I	INTMP5		/SEE IF ON
	SNA CLA			/SKIP IF YES
	  JMP	IXMT34		/JMP IF NOT
	TAD I	INTMP3		/GET POSITION
	AND	[7		/LOOK AT LOW ORDER BITS
	SZA CLA			/SKIP IF AT TAB STOP
	  JMP	IXMT61
	TAD I	INTMP5		/GET STATUS
	AND	(7773
	DCA I	INTMP5
IXMT61,	TAD	(40		/GET BLANK
	DCA	INTMP6		/STORE AS CHARACTER
	JMP	IXMT38		/TYPE IT
	PAGE
IXMT34,
	TAD I	INTMP1		/GET CHRTAB BITS
	AND	(CHRCR		/MASK FOR CARRIAGE RETURN
	SZA CLA			/IS CHAR A CR ?
	  DCA I	INTMP3		/YES SO RESET TO COLUMN 0

IXMT38,	IFNZRO TTYN <
	TAD	INTDDB
	TAD	(-CTYBLK
	SZA CLA			/IS THIS CHAR FOR THE CTY
	  JMP	INTYPE		/NO SO BRANCH TO DC02F OR KL8E ROUTINE
>/END OF IFNZRO TTYN

	TAD	INTMP6		/RETREIVE CHAR
IXMT60,	CTYTLS			/ECHO IT
	JMP	XMTDIS
/HERE WHEN NOTHING FOR A TTY TO DO
IXMT90,	NL3777			/MASK TO STRIP ACTIVE BIT
	AND I	INTMP5		/CLEAR ACTIVE BIT
	DCA I	INTMP5

IXMT92,	IFNZRO TTYN <
	TAD	INTDDB
	TAD	(-CTYBLK
	SZA CLA
	  JMP	TTOFIN		/CLEAR TTY
>/END OF IFZERO TTYN

	CTYTCF			/CLEAR TELEPRINTER FLAG
	JMP	XMTDIS		/DISMISS CALL TO XMTINT
IFZERO	LPTN <	PAGE	>/BECAUSE XMTINT USES FIRST FEW LOCATIONS ON PAGE
	DEFINE	INSRT2	<
FEAPNT,	0			/SUBROUTINE TO POINT TO FEATURES
	TAD	(TTYFEA		/GET TTY FEATURES
	DCA	TEMP2
	TAD I	DDBSTS		/GET DDB STATUS
	AND	(TTYBIT
	SZA CLA
	  JMP	.+4
	TAD	[DDBSIZ
	TAD	DDB
	DCA	TEMP2
	JMP I	FEAPNT
DATDEC,	0
/	NLOAD	DEVDRQ		/POINT TO DATA REQUESTS
	XXXX=DEVDRQ-4
IFNZRO XXXX <NLOAD DEVDRQ>
	NL4
	TAD	DDB
	DCA	TEMP1
	NLM1			/LOAD -1
	TAD I	TEMP1		/ADD DATA REQUEST
	DCA I	TEMP1		/STORE NEW ONE
	JMP I	DATDEC
INUSE,	TAD	TEMPA		/GET DISPATCH ADDRESS
	TAD	(DEVN^2
	DCA	TEMP2		/MMLTAB ENTRY
	NL1			/REASON  (NOT AVAIL)
	DCA I	TEMP2		/SAVE IN MMLTAB
	DCA I	TEMPA		/CLEAR DISPATCH ADDRESS TO
				/INDICATE WE MUST SEND DISCONNECT
	JMP	RCVFLU
DISCHK,	0			/CHECK IF A DEVICE CONNECTED DISCONNECT MUST BE SENT
	TAD	(-DEVN		/LOOP CONTROL
	DCA	TEMPD		/ INITIALIZATION
	TAD	(RCVDSP+1	/FIRST ENTRY
	DCA	TEMPC
DISCLP,	TAD I	TEMPC		/GET ENTRY
	SNA CLA			/SKIP UNLESS DISCONNECT REQUIRED
	  JMP	DISSND		/SEND DISCONNECT
	ISZ	TEMPC		/ADVANCE POINTER
	ISZ	TEMPD		/UP COUNTER AND SKIP IF DONE
	  JMP	DISCLP		/CONTINUE
	JMP I	DISCHK		/RETURN TO CALLER
IFNZRO	DP8ETR	<
ITRCRC,	0			/TRACE INPUT CHARACTERS
	DCA	TEMP1		/STORE CHARACTER
	NL4000			/BIT TO INDICATE INPUT
	TAD	TEMP1		/+CHARACTER=TRACE ENTRY
	JMS	ITRCW		/STORE IN TRACE BUFFER
	TAD	TEMP1		/GET CHARACTER
	JMS	CRCALC		/ACCUMULATE CRC
	JMP I	ITRCRC		/RETURN
ITRCR2,	0			/STORE CRC IN TRACE
	TAD	AUTO1		/ADDRESS BEFORE CRC
	DCA	TEMP5		/AT END TEMP5 WILL POINT AT CHUNK POINTER
	ISZ	TEMP5		/ADVANCE TO NEXT CRC CHARACTER
	NL4000			/MASK FOR INPUT
	TAD I	TEMP5		/GET TRACE ENTRY
	JMS	ITRCW		/STORE IN TRACE BUFFER
	ISZ	TEMP5		/ADVANCE TO NEXT CRC CHARACTER
	NL4000			/MASK FOR INPUT
	TAD I	TEMP5		/GET TRACE ENTRY
	JMS	ITRCW		/STORE IN TRACE BUFFER
	ISZ	TEMP5		/SKIP OVER CHUNK COUNT
	ISZ	TEMP5		/POINT TO CHUNKS
	JMP I	ITRCR2		/RETURN
ITRCR3,	0			/TRACE CRC OF DATA PART
	JMS	GETCHR		/GET NEXT CRC CHARACTER
	  JMP	NRMNAK		/NO ROOM
	DCA	TEMPA		/SAVE CHARACTER
	NL4000			/INPUT MASK BIT
	TAD	TEMPA		/+CHARACTER
	JMS	ITRCW		/STORE IN TRACE BUFFER
	TAD	TEMPA		/GET BACK CHARACTER
	JMP I	ITRCR3		/RETURN
ITRCW,	0			/TURN OFF INTERRUPTS AND TRACE
	IOF
	JMS	TRACEW
	ION
	JMP I	ITRCW
>/END OF IFNZRO	DP8ETR
>/END OF DEFINE INSRT2


IFZERO	LPTN	<INSRT2
IFNZRO	TTYN	<
IFNZRO	FTDC02F	<
	DISCDE
	DISCD1
	DISCD2
>/END OF IFNZRO	FTDC02F
>/END OF IFNZRO	TTYN
>/END OF IFZERO	LPTN

	LISTOG	LPTN
IFNZRO LPTN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		LPT SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

/DDCMP COMPRESSES LINE PRINTER DATA AS FOLLOWS
/	1CCCCCCC	CCCCCCC IS CHARACTER
/	01XXXXXX	XXXXXX IS NUMBER OF BLANKS
/	001XXXXX	XXXXX IS REPETITION FOR FOLLOWING CHAR
/DEVDDC BITS
/	0001	FATAL ERROR
/	0002	OFF LINE
/	0004	OUT OF PAPER
/	0010	PAPER JAM
/	0020	OFF LINE BECAUSE OF OPERATOR
/	0040	SLEW ERROR
/	0100	HAMMER FIRING ERROR
/	0200	LOW ON PAPER
/	0400	STACKER FULL
/	1000	OUT OF INK
/	2000	PRINT QUALITY BAD

LPTVTB,	DCA	INTMP1		/SAVE MASK FOR VFU SEARCH
	TAD	[0012		/LINE FEED
	DCA	LPTCHR
	TAD	LPTLNE		/LINE # WE ARE ON
	DCA	INTMP3		/SAVE POINTER TO VFU TAPE
LPTVT3,	ISZ	LPTLNE
	TAD I	LPTLNE		/GET CURRENT LINE STOPS
	SPA
	  JMP	LPTVT4		/END OF TAPE SO DO A FF
	AND	INTMP1		/USE MASK ON IT
	SNA CLA			/IS THIS HOLE PUNCHED ON TAPE ?
	  JMP	LPTVT3
	TAD	LPTLNE		/GET POINTER TO VFU TABLE
	CMA			/MAKE -LPTLNE-1
	TAD	INTMP3		/MAKES # OF LINES TO SKIP
	JMP	LPTX15		/ZERO LPTCOL THEN GO PRINT CHAR
LPTVT4,	TAD	LPTLNE
	NEGATE
	TAD	INTMP3		/LEAVES NUMBER OF LINES TO SKIP-1
	SZA CLA			/WERE WE ON LAST LINE ?
	  JMP	LPT014		/NO SO DO A FORM FEED
	JMP	LPTX14		/YES SO DO A LINE FEED

LPTHN2,	TAD	[0040
	ISZ	LPTZCT
	  JMP	INTLP4		/PRINT SPACE
	NL6000
	TAD	LPTOPV
	CDFINS
	DCA	LPTPIV
	CDFCNK
	JMP	INTLP0+1

INTLPT,	LPTSKF			/SKIP ON LPT FLAG
	  JMP	INTLP8		/NOT LPT SO KEEP LOOKING
	JMS	INTLP0
	JMP	INTDIS

INTLP8,	TAD I	(LPTBLK+DEVSTS	/GET LPT STATUS
	SPA CLA			/SKIP IF NOT ACTIVE
LPXXSE,	LPTSKE			/SKIP ON LPT ERROR		########
				/ INSTRUCTION CHANGED BY SYSCHK FOR LS8E
	  JMP	INTLP9		/NOT LPT ERROR OR NOT ACTIVE
	TAD	(LPTBLK		/POINT TO DDB
	DCA	INTDDB		/SAVE FOR ISBDDC
	NL2			/OFF-LINE
	JMS	ISBDDC		/SET BIT, AND SEND STATUS
	NL3777			/CLEAR ACTIVE
	AND I	(LPTBLK+DEVSTS
	DCA I	(LPTBLK+DEVSTS
	LPTCIE			/CLEAR INTERRUPT ENABLE
	JMP	INTDIS
/HERE ONCE PER CLOCK TICK TO SEE IF LPT NEEDS SERVICE
CLKLPT,	IOF			/DISABLE INTERRUPTS WHILE CHECK LPT
	TAD I	(LPTBLK+DEVSTS	/GET ACTIVE/INACTIVE STATUS
	SMA CLA			/IS LPT ACTIVE ?
	  JMP	STRLPT		/NO TRY TO START IT
	ISZ I	(LPTBLK+DEVTIM	/YES HAVE WE TIMED OUT ?
	  JMP	CLKLP8		/HASN'T TIMED OUT
/HERE WHEN LPT TIMES OUT
	TAD	(LPTBLK
	DCA	INTDDB		/SAVE ADR OF LPT DEVICE BLOCK
	NL2			/OFF-LINE FLAG
	JMS	ISBDDC		/SET FLAG AND TELL 10
	NL2000
	CDFINS
	TAD	LPTPIV
	SMA			/IS PIVOT ALREADY A JMP(I.E. OPCODE 5) ?
	  DCA	LPTOPV		/NO SO SAVE PIVOT
	NL0
	TAD	LPTCOL
	CMA
	DCA	LPTZCT
	TAD	(JMP I LPTHNG
	DCA	LPTPIV
	CDFCNK
IFNZRO FTTRBL <
	TAD	(LPTMSG-1
	DCA	ERRFLG		/LEAVE MSG FOR OPERATOR
>/END OF IFNZRO FTTRBL
	TAD	[0015		/CARRIAGE RETURN
	LPTSTB			/PRINT IT
	JMP	CLKLP8

/HERE TO TRY TO START LPT WHEN NOT ACTIVE
STRLPT,
	TAD I (LPTBLK+DEVOAD  /GET OUTPUT CHAR ADR
LPXYSE,	LPTSKE			/DON'T TRY IF LPT IS IN TROUBLE		########
				/ INSTRUCTION CHANGED BY SYSCHK FOR LS8E
	SNA CLA			/ANY OUTPUT FOR LPT ?
	  JMP	CLKLP8		/NO
	NL1			/NEED FOR LS8E
	LPTSIE			/SET INTERRUPT ENABLE
	NLOAD	4000		/FLAG DEVICE IS ACTIVE
	TAD I	(LPTBLK+DEVSTS
	DCA I	(LPTBLK+DEVSTS
	JMS	INTLP0		/BEGIN PRINTING
CLKLP8,	ION
	NL0			/BECAUSE THERE MAY BE GARBAGE IN AC
	JMP	CLKLP9

	PAGE
LPTBBB,	JMS	IGTEXN		/GET THE EXTENSIBLE NUMBER = COUNT
	  JMP	LPTFIN		/NONE SO DONE
IFNZRO FTDEBUG <
/	SNA
/	  HLT
>/END OF IFNZRO FTDEBUG
	TAD	[-1
	DCA	LPTCNT
	JMS	IGTOCH
	  JMP	LPTFIN
LPTGGG,	NLM1			/PREPARE TO DECREMENT COUNT
	TAD	LPTCNT
	SPA			/ARE THERE CHARS LEFT ?
	  JMP	LPTBBB		/NO SO GET A COUNT
	DCA	LPTCNT		/YES RESTORE COUNT
	JMS	IGTOCH		/GET THE NEXT CHAR
	  JMP	LPTFIN
	DCA	LPTCCH		/SAVE CHAR AND FLAG BITS
	TAD	LPTCCH
	AND	[0200		/IS THIS A COMPRESSED CHAR ?
	SZA CLA			/IS THIS A NICE CHAR
	  JMP	LPTFFF
LPTXXX,	TAD	LPTCCH		/GET FLAG BITS AGAIN
	AND	(0100		/WAS THIS COMPRESSED BLANKS ?
	SZA CLA
	  JMP	LPTZZZ		/YES
	NLM1
	TAD	LPTCCH		/GET COUNT
	AND	(0037
	DCA	LPTCCN
	JMP	LPTGGG		/GO GET CHAR TO REPEAT
LPTZZZ,	TAD	LPTCCH
	AND	(0077		/LEAVE ONLY COUNT
	DCA	LPTCCN		/SAVE COUNT
	TAD	[0040		/BLANK
LPTVVV,	DCA	LPTCCH
	JMP	INTLP0+1

	INSRT2
IFNZRO	TTYN	<
IFNZRO	FTDC02F	<
	DISCDE
	DISCD1
	DISCD2
>/END OF IFNZRO	FTDC02F
>/END OF IFNZRO	TTYN
	PAGE

/HERE WHEN USER SENT LINE LONGER THAN PRINTER LINE
LPTWRP,	TAD	LPTCHR
	DCA	LPTOCH
	TAD	[0012		/PUT OUT A LINE FEED
	JMP	INTLP1

/HERE WHEN OUTPUT DATA FOR LPT IS EXHAUSTED
LPTFIN,	LPTCLF			/CLEAR ANY FLAGS
	JMS	CLRACT
	JMS	ISTDDC	/UPDATE DDCMP STATUS
LPXXCE,	LPTCIE			/CLEAR INTERRUPT ENABLE		########
				/ INSTRUCTION CHANGED BY SYSCHK FOR LS8E
	JMP I	INTLP0		/RETURN TO CALLER

/HERE AT INTERRUPT LEVEL WHEN LPT INTERRUPTS
INTLP0,	0
	NL0			/IN CASE CAME FROM SPECIAL CHAR CODE
	TAD	(LPTBLK
	DCA	INTDDB
LPTPIV,	7402			/LPT PIVOT(SET TO NOP, SKP OR JMP)
	  JMP	INTLP6		/DO TAB FUNCTION
	NLM1			/GET SET TO DECREMENT
	TAD	LPTCCN		/DECREMENT COMPRESSED CHAR COUNT
	SPA			/ARE WE DECOMPRESSING ?
	  JMP	LPTGGG		/NO SO GET A CHAR FROM CHUNKS
LPTYYY,	DCA	LPTCCN		/SAVE COMPRESSED CHAR COUNT
LPTFFF,
	TAD	LPTCCH		/GET CHAR AGAIN
	AND	[0177		/SEVEN BITS ONLY
INTLP1,	DCA	LPTCHR		/SAVE CHAR
INTLPA,
	TAD	LPTCHR
	TAD	(CHRTAB
	DCA	INTMP1
	TAD I	INTMP1
	RTR
	SZL SPA			/SKIP IF NORMAL CHAR
	  JMP	INTLP5		/SPECIAL MOTION OR FLUSH

IFNZRO FTLPLC <	NL0	>
IFZERO FTLPLC <			/SPECIAL HANDLING FOR LPT'S WITHOUT LOWER CASE
	RAR			/SHIFT BIT FOR LC INTO POSITION
	SNL CLA			/IS CHAR LOWER CASE ?
	  JMP	INTLP2		/NOT LOWER CASE
	TAD	LPTCHR		/GET CHAR AGAIN
	TAD	(-40		/CONVERT TO UPPER CASE
	DCA	LPTCHR		/AND SAVE CHAR
>/END OF IFZERO FTLPLC

INTLP2,
	ISZ	LPTCOL		/THIS ADVANCES PRINTER ONE COLUMN
	TAD	LPTCOL
	TAD	(-LPTWID
	SMA SZA CLA
	  JMP	LPTWRP		/NEED TO DO WRAP AROUND

INTLP3,	NL0
	TAD	LPTCHR		/GET CHAR AGAIN
INTLP4,
	LPTSTB
	TAD	(-14
	SNA CLA			/WAS THIS A FORM FEED ?
	  TAD	LPTTFF		/YES
	TAD	LPTTCH		/TIME FOR NORMAL CHAR
	DCA I	(LPTBLK+DEVTIM
	JMP I	INTLP0
LPTTFF,	-100			/TIME FOR A FORM FEED		########
LPTTCH,	-32			/TIME FOR A NORMAL CHARACTER	########

/HERE WHEN CHAR MAY BE SPECIAL MOTION
INTLP5,				/CHECK IF CHAR TO BE FLUSHED
	SNL CLA			/IS CHAR GARBAGE ?
	  JMP 	LPTFLS		/FLUSH CHAR & RETURN TO CALLER
	TAD	LPTCHR		/GET CHAR AGAIN
	TAD	(LPTTBL-11
	DCA	INTMP1
	TAD I	INTMP1
	SNA			/IS THIS A TAB ?
	  JMP	LPT011		/YES
	SMA			/IS THIS A FF OR A CR ?
	  JMP	LPTVTB		/NO
	IAC
	SNA			/IS CHAR A CARRIAGE RETURN ?
	  JMP	LPT015		/YES
/HERE TO PRINT A FF ON LPT
LPT014,	NL0
	TAD	[0014
	DCA	LPTCHR
LPTX14,	TAD	(LPTVFU-1
	DCA	LPTLNE		/WE ARE AT LINE 0 AGAIN
	NLM2			/SAYS PRINT ONCE
LPTX15,	DCA	LPTRCT		/SET REPETITION COUNT
	TAD	(NOP
	DCA	LPTPIV
LPT015,	DCA	LPTCOL		/SET COLUMN 0 AGAIN
	TAD	[0015		/CARRIAGE RETURN
	JMP	INTLP4

/HERE TO SIMULATE A HORIZONTAL TAB ON LPT
LPT011,	TAD	LPTCOL		/GET CURRENT COLUMN
	AND	(0007
	TAD	(-10
	DCA	LPTRCT		/REPETITION COUNT
	TAD	(10
	TAD	LPTCOL
	AND	(7770
	DCA	LPTCOL
	TAD	[0040		/SPACE
	DCA	LPTCHR
	TAD	(NOP
	DCA	LPTPIV
	JMP	INTLP3		/GO PRINT FIRST COPY

INTLP6,	ISZ	LPTRCT		/INCREMENT COUNT
	  JMP	INTLP3		/PRINT CHAR
	TAD	(SKP
	DCA	LPTPIV
	TAD	LPTOCH
	SNA
	  JMP	INTLP0+1
	DCA	LPTCHR
	DCA	LPTOCH
	JMP	INTLPA

/HERE ON HUNG LPT
LPTHN1,	ISZ	LPTPIV
	JMP	LPT015

LPTFLS,	DCA	LPTCCN		/HERE TO FLUSH CHARACTER
IFNZRO	CDRN	<
	TAD I	(CDRBLK+DEVSTS	/SEE IF CDR ACTIVE
	SMA CLA			/SKIP IF ACTIVE
>/END OF IFNZRO	CDRN
	  JMP	INTLP0+1	/DO NEXT CHARACTER
IFNZRO	CDRN	<
	JMP	LPTFIN		/TURN OFF LPT ACTIVE; TICKS
				/WILL START IT UP AGAIN
>/END OF IFNZRO	CDRN

	PAGE
>/END OF IFNZRO LPTN
	LISTOG	LPTN
	DEFINE	INSRT1	<
BADTYP,	NL1		/REASON CODE =1
	JMP	DISCON
TOOMNY,	JMS	GETEXN		/GET SLA
	DCA	TEMP2		/SAVE IT
	NL2			/REASON
DISCON,	DCA	TEMPA		/SAVE REASON
	TAD	DISREA		/GET CURRENT REASON
	SZA CLA			/CHECK IF WE'VE GOT DISCONNECT WAITING
/	  HLT			/TOO MANY TOO FAST
	  JMS I	[DMPTRP
	TAD	TEMP2		/PICK UP SLA
	DCA	DISSLA		/SAVE IT
	TAD	RSNA
	DCA	DISSNA
	TAD	TEMPA		/GET REASON
	DCA	DISREA		/STORE AND INDICATE THAT WE NEED TO SEND DISCONNECT
	JMP	RCVFLU		/GET RID OF MESSAGE

CONTYP,	NL0
	TAD	(NCOMSG-1
	JMP	CNTYP2
>/END OF DEFINE INSRT1

IFZERO	CDRN	<INSRT1>

IFZERO	LPTN	<PAGE>
	LISTOG	CDRN
IFNZRO CDRN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CDR SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

/DATA SENT TO DECSYSTEM-10 IS ESSENTIALY IMAGE MODE
/	IF BIT 100 IS ZERO THEN DATA IS LOW ORDER 6BITS OF TWO CHARS
/	IF BIT 100 IS SET THEN DATA IS COMPRESSED:
/	BITS 060 SPECIFIY ZONE PUNCH:
/		0 IS NO ZONE PUNCH
/		1 IS 12 PUNCH
/		2 IS 11 PUNCH
/		3 IS 0 PUNCH
/	BITS 17 SPECIFY COLUMN PUNCH:
/		0 IS NO PUNCH
/		1 IS 1 PUNCH
/		2 IS 2 PUNCH
/		ETC.
/	TRAILING BLANKS ARE NOT TRANSMITTED.
/	REPRESENTATION	MEANING
/	1CCCCCCC	CCCCCCC = SEVEN BIT ENCODED CHARACTER
/	01XXXXXX	XXXXXX =COUNT OF BLANKS
/	001XXXXX	XXXXX = COUNT OF REPETITIONS, 0-31
/	0000CCCC
/	CCCCCCCC	CCCCCCCCCCCC = TWELVE BIT ENCODED CHARACTER
/
/ DEVDDC	-	DDCMP STATUS WORD
/	0001	CARD READER ERROR(MASTER ERROR)
/	0002	HOPPER EMPTY
/	0004	REGISTRATION ERROR
/	0010	INVALID PUNCH
/	0020	STACKER FULL
/	0040	JAM WHILE FEEDING
/	0100	PICK FAILURE
/	0200	END OF FILE CARD
/	0400	HDW EOF
/	1000	CDR OVERRAN THE PROCESSOR
/	2000	CDR HAS GONE OFF LINE
/	4000	CDR STOPPED(MAY BE CLEARED WITH A SET MODE)
/
/ DEVICE BLOCK
/	DEVOLC IS USED TO COUNT COLUMNS OF CARD
/	DEVOAD IS ADR OF LAST NONBLANK CHAR
/	DEVSTS USES EOFBIT

/CDRCNK IS WORST CASE NUMBER OF CHUNKS/CARD
	Z=CNKSIZ-4;	IFZERO Z <CDRCNK=66>
	Z=CNKSIZ-10;	IFZERO Z <CDRCNK=27>
	Z=CNKSIZ-20;	IFZERO Z <CDRCNK=13>
	Z=CNKSIZ-40;	IFZERO Z <CDRCNK=6>
	Z=CNKSIZ-100;	IFZERO Z <CDRCNK=3>
	Z=CNKSIZ-200;	IFZERO Z <CDRCNK=2>
/HERE FOR A DATA READY INTERRUPT FROM CARD READER
ICDRD0,	CDRCRB			/READ CARD COLUMN
	DCA	INTMP5		/SAVE IT
	TAD I	(CDRBLK+DEVSTS	/GET STATUS WORD FOR THE CDR
	SMA CLA			/IS CARD READER ACTIVE ?
	  JMP	INTDIS		/NO - PROBABLY LOCAL MODE
	TAD I	(CDRBLK+DEVOLC	/GET COUNT OF COLUMNS READ SO FAR
	TAD	(-120		/COMPARE COLUMN TO 80
	SMA CLA			/WAS IT GT 80 ?
	  JMP	ICDRD5		/ONLY READ 80 COLUMNS !!
	TAD I	(CDRBLK+DEVOLC	/GET CARD COLUMN COUNTER
	SZA CLA			/IS THIS THE FIRST COLUMN ?
	  JMP	ICDC14
	TAD	INTMP5		/GET CHARACTER AGAIN
	DCA I	(CDRBLK+DEVIAD	/SAVE COLUMN ONE
	JMP	ICDC19
ICDC14,	TAD	INTMP5		/GET THE CHARACTER AGAIN
	NEGATE
	TAD	CDCCHR		/GET LAST CHAR READ
	SZA CLA			/IS THIS A REPETITION
	  JMP	ICDC18		/NO SO PUT PREVIOUS CHAR INTO CHUNKS
	TAD	CDCCNT		/GET COUNT OF REPETITIONS
	TAD	(-37
	SMA CLA			/HAVE WE DONE AS MANY AS POSSIBLE
ICDC18,	  JMS	ICDC30		/PUT PREVIOUS CHARS INTO CHUNKS
ICDC19,	TAD	INTMP5		/GET THIS COLUMN AGAIN
	DCA	CDCCHR		/SAVE IT
ICDC20,	ISZ	CDCCNT		/COUNT REPETITION
ICDRD5,	ISZ I	(CDRBLK+DEVOLC
	TAD I	(CDRBLK+DEVOLC
	TAD	(-120		/CHECK FOR THIS IS THE LAST COLUMN
	SNA CLA
	  JMS	ICDC30
	JMP	INTDIS

ICDC30,	0
	NLM1
	TAD	CDCCNT		/GET COUNT FOR COMPRESSION
	SNA			/DID WE HAVE ANY REPETITIONS ?
	  JMP	ICDC35		/NO JUST SEND THE CHAR
	TAD	(0041		/FLAG THIS IS A REPETION COUNT
	JMS	ICDRD6		/PUT COUNT INTO CHUNKS
ICDC35,	NL6000
	IAC CML RAR		/SET LINK & LOAD 7000
	AND	CDCCHR		/GET ROWS 12,11, & 0
	RTR
	RTR
	RAR			/POSITION BITS
	DCA	INTMP3		/AND SAVE FOR LATER USE
	TAD	CDCCHR		/GET THE CHAR AGAIN
	AND	(0017		/GET ROWS 6,7,8,9
	TAD	(CD2TAB
	DCA	INTMP2
	TAD	CDCCHR		/GET COLUMN AGAIN
	AND	(0760		/LEAVE ONLY ROWS 1/2/3/4/5
	RTR
	RTR
	TAD	(CD1TAB
	DCA	INTMP1
	TAD I	INTMP1
	TAD I	INTMP2
	TAD	INTMP3		/ADD ROWS 12/11/0
	SMA SNL			/CAN THE CHAR BE COMPRESSED ?
	  JMP	ICDC39		/PUT CHAR INTO CHUNKS
	NL6000			/BEGIN TO ASSEMBLE MASK
	CLL CML IAC RTR		/LEAVES 7400 IN AC
	AND	CDCCHR		/GET THE CHARACTER AGAIN
	RTL
	RTL
	RAL
	JMS	ICDRD6		/PUT HALF OF CHAR INTO THE CHUNKS
	NL3777			/MASK TO STRIP SIGN BIT
	AND	CDCCHR
ICDC39,	JMS	ICDRD6		/PUT REST OF COLUMN INTO CHUNKS
	DCA	CDCCNT		/INITIALIZE THE COUNT
	JMP I	ICDC30
/HERE TO PUT A CHAR INTO THE CHUNK BUFFER
ICDRD6,	0
	DCA	INTMP2		/SAVE CHAR
	NL1
	TAD	CDRADR
	AND	[CNKSIZ-1
	SZA CLA			/HAVE WE HIT A CHUNK BOUNDRY ?
	  JMP	ICDRD7		/NO
	NL4000
	TAD I	CDRADR
	DCA I	CDRADR		/FLAG LAST CHAR IN CHUNK
	TAD	CDRADR
	AND	[-CNKSIZ
	DCA	CDRADR		/MAKE POINTER TO LINK WORD
	JMS	ERSGET		/GET ANOTHER CHUNK FROM ERS
	DCA I	CDRADR
	TAD	INTMP1
	DCA	CDRADR		/LINK CHUNK INTO STRING

ICDRD7,	ISZ	CDRADR		/ADVANCE BUFFER POINTER
	TAD	INTMP2		/GET CHAR AGAIN
	DCA I	CDRADR		/SAVE CHAR IN BUFFER
	ISZ I	CDREXT		/COUNT CHAR INTO CHUNKS
	JMP I	ICDRD6		/RETURN TO CALLER
/HERE TO CHECK FOR LOW PRIORITY CARD READER INTERRUPTS
INTCDR,	CDRSD			/SKIP ON CARD DONE FLAG
	  JMP	INTCD9		/NO TRY NEXT DEVICE
	CDRCRD			/CLEAR DONE FLAG
	TAD I	(CDRBLK+DEVSTS
	SMA CLA			/IS READER SUPPOSED TO BE ACTIVE ?
	  JMP	INTDIS		/NO SO JUST DISMISS
	TAD I	(CDRBLK+DEVOLC	/GET COUNT OF COLUMNS ON CARD
	TAD	(-120		/SHOULD BE 80 DECIMAL
	SZA CLA			/IS IT ?
	  JMP	INTCD2		/NO

	NL4000			/FLAG FOR LAST CHAR IN CHUNK
	TAD I	CDRADR		/GET LAST CHAR IN CARD
	DCA I	CDRADR		/SAVE IT WITH FLAG
	TAD	(0200
	AND I	CDREXT		/GET COUNT FOR BUFFER
	JMP	INTCD4

	PAGE
INTCD4,	SNA CLA
	  JMP	INTCD1
	ISZ	CDREXT
	NL1
	SKP
INTCD1,	TAD	(0200
	TAD I	CDREXT
	DCA I	CDREXT
	TAD I	(CDRBLK+DEVIAD	/GET COLUMN 1
	TAD	(-7417		/COMPARE WITH EOF
	SZA CLA
	  JMP	INTCD0		/WASN'T EOF SO CONTINUE
	TAD	(CDRBLK		/ADR OF DEVICE BLOCK
	DCA	INTDDB
	TAD	(4200		/FLAG CDR HAS STOPPED AND READ EOF
	JMS	ISBDDC		/TELL 10 WE SAW IT AND STOPPED
INTCD0,

	JMP	INTCD3

INTCD3,	JMS	INTCD5		/TRY SEND CARD TO 10
	JMS	STCARD		/TRY TO KEEP CDR MOVING
	JMP	INTDIS		/DISMISS INTERRUPT

INTCD2,	TAD	(RCKMSG-1
	DCA	ERRFLG		/COMPLAIN ABOUT CARD
	JMP	INTDIS		/ DEVICE WILL TIME OUT AND USER WILL GET MESSAGE FROM 10
/HERE TO TRY TO SEND CARD TO 10
INTCD5,	0


	TAD I	(CDRBLK+DEVBF2
	SZA CLA
	  JMP I	INTCD5
	TAD	CDRNXT
	DCA I	(CDRBLK+DEVBF2
	DCA	CDRNXT
	NLM1			/DECREMENT DATA REQUESTS
	TAD I	(CDRBLK+DEVDRQ
	DCA I	(CDRBLK+DEVDRQ
	JMP I	INTCD5
/HERE ONCE PER CLOCK TICK TO CHECK THE CARDREADER
/ IF ACTIVE SEE IF IT HAS TIMED OUT(PICK FAIL ?)
/ IF NOT ACTIVE TRY TO START IT
CLKCDR,	IOF			/LEAVE INTERRUPTS OFF FOR A WHILE
	TAD	(CDRBLK		/IN CASE WE CALL ISTDDC, ETC.
	DCA	INTDDB
	TAD I	(CDRBLK+DEVBF1	/GET ADR OF 1ST CARD
	SZA CLA
	  JMP	CLKCD2
	TAD I	(CDRBLK+DEVBF2
	DCA I	(CDRBLK+DEVBF1
	DCA I	(CDRBLK+DEVBF2
CLKCD2,	TAD I	(CDRBLK+DEVSTS	/GET DEVICE STATUS
	SPA CLA			/TEST FOR ACTIVE
	  JMP	CLKCD5		/IS ACTIVE
	NL1
	AND I	(CDRBLK+DEVDDC
	SZA CLA			/IS TROUBLE BIT UP ?
	  JMP	CLKCD4		/YES SO CHECK IT
	TAD I	(CDRBLK+DEVDRQ
	SNA CLA			/DO WE HAVE ANY DATA REQUESTS ?
	  JMP	CLKCD8		/NONE SO DONE
	TAD	CDRNXT
	SZA CLA
	  JMS	INTCD5		/IF HOLDING DUMP
	NL4000			/ACTIVE FLAG
	TAD I	(CDRBLK+DEVSTS
	DCA I	(CDRBLK+DEVSTS	/FLAG ACTIVE
	JMS	STCARD		/TRY TO MOVE A CARD
CLKCD8,	ION
	NL0
	JMP	CLKCD9		/DONE FOR THIS TICK

CLKCD4,	ISZ I	(CDRBLK+DEVTIM	/SEE IF WE HAVE WAITED A WHILE
	  JMP	CLKCD8		/NO LONG ENOUGH YET
	NL4000			/JUST STOP BIT
	JMS	ISTDDC		/SET NEW DEVICE STATUS
	JMP	CLKCD8

/HERE AT ONCE PER TICK IF CDR IS ACTIVE
CLKCD5,	ISZ I	(CDRBLK+DEVTIM	/INCREMENT TIMER
	  JMP	CLKCD8		/HASN'T TIMED OUT SO WE ARE DONE

/CDR HAS TIMED OUT = PICK FAILURE
	JMS	CLRACT		/CLEAR DEVICE ACTIVE
	TAD	(4101		/CDR STOPPED & PICK CHECK
	JMS	ISBDDC		/SET DDCMP STATUS
	NL6000			/THIS IS ABOUT 17 SECONDS(60HZ)
	DCA I	(CDRBLK+DEVTIM	/SET TIMER
	TAD	CDRNXT		/GET ADR OF CARD WE WERE TRYING TO READ
	JMS	FRECKS		/FREE CHUNKS
	DCA	CDRNXT		/FREE CURRENT BUFFER(& ION)
	JMP	CLKCD9		/ON TO NEXT DEVICE
	INSRT1

	PAGE
/HERE TO START CARD MOVING
STCARD,	0
	NLOAD	STSBIT		/MASK FOR HAVE TO SEND STS
	AND I	(CDRBLK+DEVSTS	/GET CURRENT STATUS BITS
	SZA CLA			/CHECK FOR EOF OR NEED TO SEND STATUS
	  JMP	STCDR8		/STSBIT MUST BE CLEARED BEFORE READING
	TAD I	(CDRBLK+DEVDDC	/GET DDCMP STATUS
	SPA CLA			/TEST FOR CDR STOPPED BIT
	  JMP	STCDR8		/HAS STOPPED
	TAD I	(CDRBLK+DEVDRQ	/GET DATA REQUESTS
	SNA CLA
	  JMP	STCDR8		/NO DATA REQUESTS SO DON'T MOVE CARDS
	TAD I	(CDRBLK+DEVBF2
	SNA CLA			/CHECK TO SEE IF HOLDING
	JMS	IGTCNK		/GET FIRST CHUNK TO STORE CARD IN
	  JMP	STCDR8		/HOLDING OR OUT OF CORE
	DCA	CDRNXT
	TAD	CDRNXT		/GET ADR OF LINK WORD
	IAC			/MAKES ADR OF COUNT FIELD
	DCA	CDREXT		/SAVE ADR OF COUNT FIELD(LOW ORDER)
	DCA I	CDREXT		/CLEAR COUNT(LOW ORDER)
	TAD	CDREXT
	IAC			/MAKES ADR OF COUNT FIELD(HIGH ORDER)
	DCA	CDRADR		/SAVE ADR
	DCA I	CDRADR		/CLEAR HIGH ORDER COUNT
	TAD	(2		/DATA WITH EOR
	JMS	ICDRD6		/PUT CODE INTO CHUNKS
	DCA	CDCCNT		/HAVE READ NO CHARS YET
	TAD I	(CDRBLK+DEVDDC	/GET DEVICE STATUS BITS
	AND	(7177		/TURN OFF BOTH EOF BITS
	DCA I	(CDRBLK+DEVDDC	/STASH BACK
	CDRCSE
	NOP			/START CARD READER
	TAD	(-200
	DCA I	(CDRBLK+DEVTIM	/TWO SECOND TIMEOUT
	DCA I	(CDRBLK+DEVOLC	/INITIALIZE COLUMN COUNTER
	JMP I	STCARD
STCDR8,	NL3777			/MASK TO CLEAR ACTIVE
	AND I	(CDRBLK+DEVSTS
	DCA I	(CDRBLK+DEVSTS	/CLEAR ACTIVE
	JMP I	STCARD

>/END OF IFNZRO CDRN
	LISTOG	CDRN
	LISTOG	PTRN
IFNZRO PTRN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		PTR SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

PTRCNT,	0			/COUNT OF CHARS

/HERE AT INTERRUPT LEVEL WHEN PTR INTERRUPTS
INTPTR,	PTRSF			/SKIP ON PTR FLAG
	  JMP	INTPR9		/NOT PTR CHECK NEXT DEVICE
	PTRRB			/GET FRAME FROM PTR AND CLEAR FLAG
	DCA	INTMP5		/SAVE CHAR
	TAD	(PTRBLK		/ADDRESS OF DEVICE BLOCK
	JMS	IACTCK		/CHECK DEVICE SHOULD BE ACTIVE
				/ IF NOT DON'T RETURN

	TAD	INTMP5		/GET CHAR AGAIN
	JMS	IPUTCH		/PUT CHAR INTO THE CHUNKS
	NLOAD	-1
	TAD I	(PTRBLK+DEVDRQ	/UPDATE DATA REQUEST COUNT
	DCA I	(PTRBLK+DEVDRQ	/AND SAVE NEW COUNT
	ISZ	PTRCNT		/COUNT CHAR IN CURRENT BUFFER
	TAD	PTRCNT		/GET CHAR COUNT
	TAD	(-240
	SMA CLA
	  JMP	INTPR5		/BRANCH IF HAVE ENOUGH
	JMS	PTRMOV		/MOVE TAPE AGAIN
	JMP	INTDIS

INTPR5,	JMS	INTPR7		/QUEUE DATA TO 10
	JMP	INTDIS

/HERE TO SEND PTR DATA TO 10
INTPR7,	0
	TAD	PTRCNT
	SNA CLA
	  JMP I	INTPR7		/IF NO DATA DONE
	JMS	CLRACT		/CLEAR DEVICE ACTIVE
	TAD I	(PTRBLK+DEVBF2
	DCA I	(PTRBLK+DEVBF1
	DCA I	(PTRBLK+DEVBF2
	JMP I	INTPR7
/HERE ONCE PER CLOCK TICK TO CHECK PTR

CLKPTR,	IFZERO PDP8E <
	PTRPE			/REENABLE PTR/PTP INTS
>/END OF IFZERO PDP8E
	TAD	(PTRBLK		/PREPARE
	IOF
	DCA	INTDDB		/FOR VARIOUS SUBROUTINES
	TAD I	(PTRBLK+DEVSTS	/GET CURRENT STATUS
	SMA CLA			/IS DEVICE ACTIVE ?
	  JMP	STRPTR		/NO YET - TRY TO START IT
	ISZ I	(PTRBLK+DEVTIM	/HAS DEVICE TIMED OUT ?
	  JMP	CLKPR8		/NO
	JMS	INTPR7		/QUEUE DATA TO 10
	TAD I	(PTRBLK+DEVSTS
	TAD	(4001		/SET EOF & CLRACT
	DCA I	(PTRBLK+DEVSTS
CLKPR8,	ION
	JMP	CLKPR9

/HERE TO PERHAPS START PTR MOVING
STRPTR,
	TAD I	(PTRBLK+DEVDRQ	/GET DATA REQUEST COUNT
	SNA CLA
	  JMP	CLKPR8		/NONE SO DON'T START PTR
	DCA	PTRCNT		/HAVE READ NOTHING YET
	NLOAD	4000		/FLAG DEVICE IS ACTIVE
	TAD I	(PTRBLK+DEVSTS
	DCA I	(PTRBLK+DEVSTS
	JMS	PTRMOV		/START TAPE MOVING
	JMP	CLKPR8
/SUBROUTINE TO MOVE THE TAPE
/ IF THERE AREN'T ENOUGH CHUNKS LEFT STOP READER
/ AND SEND WHAT WE HAVE SO FAR
PTRMOV,	0
	TAD	FRECNT
	TAD	(-ERSCNT
	SPA CLA			/SKIP IF HAVE CORE
	JMP	PRMOV3
	PTRFC			/START TAPE MOVING
	TAD	(-100
	DCA I	(PTRBLK+DEVTIM	/RESET TIMER
	JMP I	PTRMOV
PRMOV3,	JMS	CLRACT		/CLEAR DEVICE ACTIVE FLAG
	JMS	INTPR7		/SEND DATA TO 10
	JMP I	PTRMOV

	PAGE
>/END OF IFNZRO PTRN
	LISTOG	PTRN
	LISTOG	PTPN
IFNZRO PTPN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		PTP SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

PTPCNT,	0			/COUNTER FOR HEADER & TRAILER

/HERE AT INTERRUPT LEVEL TO CHECK FOR PTP INTERRUPTS
INTPTP,	PTPSF			/SKIP ON PTP FLAG
	  JMP	INTPP9		/NOT PTP SO CHECK NEXT DEVICE
	JMS	INTPP0
	JMP	INTDIS
INTPP0,	0
	TAD	PTPCNT
	SZA CLA			/DO WE NEED HEADER/TRAILER ?
	  JMP	INTPP5		/YES
	TAD	(PTPBLK
	DCA	INTDDB
	JMS	IGTOCH		/GET NEXT CHAR IF ANY
	  JMP	PTPFIN		/NONE
	CLL			/CLEAR LINK
	TAD	(2000
	SZL
	  JMP	INTPP7		/THIS IS REALLY AN OPEN !
INTPP1,	PTPLS			/PUNCH CHAR
	NLM3			/FOR TIMEOUT
	DCA I	(PTPBLK+DEVTIM
	JMP I	INTPP0
INTPP5,	ISZ	PTPCNT
	JMP	INTPP1		/GO PUNCH A 0
	JMP	INTPP1		/ DITTO
INTPP7,	NL0
	TAD	(-200		/THIS IS APP TWO FOLDS OF TAPE
	DCA	PTPCNT
	JMP	INTPP1		/GO PUNCH 1ST PART OF HEADER/TRAILER
/HERE WHEN DATA FOR PTP IS EXHAUSTED
PTPFIN,	PTPCF			/CLEAR ANY FLAGS
	JMS	CLRACT		/MARK DEVICE AS NOT ACTIVE
	JMP	INTDIS

CLKPTP,	IFZERO PTRN <
	IFZERO PDP8E <
	PTRPE			/REENABLE READER/PUNCH INTERRUPTS
>/END OF IFZERO PDP8E
>/END OF IFZERO PTRN
	TAD I	(PTPBLK+DEVSTS
	SMA CLA			/IS PTP ACTIVE ?
	  JMP	STRPTP		/NO SO TRY TO START IT
	ISZ I	(PTPBLK+DEVTIM	/YES - IS THIS TIMEOUT ?
	JMP	CLKPP9		/NO
IFNZRO FTTRBL <
	TAD	(PTPMSG-1
	DCA	ERRFLG		/LEAVE MSG FOR OPERATOR
>/END OF IFNZRO FTTRBL
	JMP	CLKPP9

STRPTP,	TAD I	(PTPBLK+DEVOCN
	SNA CLA
	  JMP	CLKPP9		/NOTHING TO DO SO GO TO NEXT DEVICE
	NL4000
	IOF
	TAD I	(PTPBLK+DEVSTS
	DCA I	(PTPBLK+DEVSTS
	JMS	INTPP0
	ION
	JMP	CLKPP9

/	PAGE
>/END OF IFNZRO PTPN
	LISTOG	PTPN
	LISTOG	PLTN
IFNZRO PLTN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		PLT SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************


/DATA FOR THE PLT COMES IN 10 FORMAT - I.E. 6 BIT BYTES AS FOLLOWS:
/	0040	PEN UP
/	0020	PEN DOWN
/	0010	DRUM UP
/	0004	DRUM DOWN
/	0002	PEN LEFT
/	0001	PEN RIGHT

/HERE AT INTERRUPT LEVEL TO CHECK FOR PLT INTERRUPTS
INTPLT,	PLTSKF			/SKIP ON PLOTTER FLAG
	  JMP	INTPL9		/CHECK NEXT DEVICE
INTPL0,	TAD	(PLTBLK
	DCA	INTDDB
	JMS	IGTOCH		/GET NEXT CHAR IF ANY
	  JMP	PLTFIN		/NONE
/	PLOT HERE
	JMP	INTDIS
PLTFIN,	PLTCLF			/CLEAR ANY FLAGS
	JMS	CLRACT		/MARK DEVICE AS NOT ACTIVE
	JMP	INTDIS


CLKPLT,	TAD I	(PLTBLK+DEVSTS
	SMA CLA			/IS PLT ACTIVE ?
	  JMP	CLKPL2		/NO TRY TO START IT
	ISZ I	(PLTBLK+DEVTIM	/YES - IS THIS TIMEOUT ?
	JMP	CLKPL9		/NO
	JMP	CLKPL9

CLKPL2,	JMP	CLKPL9		/CAN'T START PLT

/	PAGE
>/END OF IFNZRO PLTN
	LISTOG	PLTN
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CLOCK SERVICE				***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE AT INTERRUPT LEVEL WHEN CLOCK GOES OFF

/TEST FOR CLK INTERRUPTS
INTCLK,	CLKSCF			/DID CLOCK GO OFF?
	  JMP	INTCL9		/NOT CLOCK SO CHECK NEXT DEVICE

IFZERO PDP8E <
	NL1			/IGNORE EVERY OTHER TICK
	AND	JIFSEC+1
	SZA CLA
	  JMP	INTCK4
>/END OF IFZERO PDP8E

	ISZ	CLKFLG		/FLAG FOR NONINTERRUPT LEVEL CODE
	SKP
	  HLT			/WENT A MINUTE WITHOUT FINDING CLOCK FLAG ??
	NLM1
	DCA	WRKREQ		/SO WE FIND CLOCK FLAG
	TAD	JIFSEC+1
IFZERO PDP8I <	AND	(0077	>
IFZERO PDP8E <	AND	(0176	>
	SZA CLA
	  JMP	INTCK4
	ISZ	SECFLG		/FLAG TIME FOR 64TH TICK CODE(APP. 1 / SEC)

	IFNZRO FTDEBUG <
	NLM1
	JMS	TRACEW		/PUT WORD INTO THE TRACE
>/END OF IFNZRO FTDEBUG

INTCK4,	ISZ	JIFSEC+1
	  JMP	INTDIS
	ISZ	JIFSEC
	  JMP	INTDIS
	JMP	INTDIS
JIFSEC,	ZBLOCK	2		/TICKED ONCE PER JIFFY


IFZERO FTDP01 <
/7720 THROUGH 7731 INCLUSIVE ARE USED BY DP8E
ZZ=.&4000
IFNZRO ZZ <
ZZ=7720-.
ZZ=ZZ&4000
IFNZRO ZZ <
	ERROR		/CODE OVERLAPS DP8E HARDWARE ADDRESSES
>/END OF IFNZRO ZZ

*7732		/SKIP DP8E ADDRESSES

>/END OF IFNZRO ZZ
>/END OF IFZERO FTDP01

/TEST FOR PARITY INTERRUPTS
INTMEM,	MEMSMP MEMCMP		/DID WE WIN A MEMORY PARITY ERROR
MEMTST,	  MEMSPO		/ MAYBE - DO WE HAVE THE OPTION ?
	  JMP	INTNOT		/DON'T HAVE OPTION OR NO ERROR
	HLT			/HAVE MEMORY PARITY ERROR SO HALT

/HERE IF GOT INTERRUPT WHICH WE CAN'T DETECT
INTNOT,	ISZ	INTCNT		/COUNT UNKNOWN DEVICE INTERRUPTED
	  JMP	INTDIS		/DISMISS INTERRUPT
	TAD	(INTMSG-1	/ "INT ERR"
	JMS	CTYEXC		/TELL OPR
	HLT

RCVLP6,	NLOAD	DEVCHK		/DISPLACEMENT OF CHUNK COUNT
	TAD	DDB
	DCA	TEMPA		/SAVE ADR OF DDB CHUNK COUNT
	NLM1
	TAD	TEMP5
	DCA	TEMPB		/SAVE ADR OF MSG'S CHUNK COUNT
	TAD I	TEMPB		/NO OF CHUNKS IN THIS MESSAGE
	TAD I	TEMPA		/PLUS PREVIOUS
	DCA I	TEMPA		/STORE BACK
	ION
	JMP	RCVADV		/FORGET MESSAGE BUT NOT CHUNKS
	PAGE
IFNZRO CNKFLD <

FIELD	CNKFLD

DEFINE HLT <7402>

CHK1=1
CHK2=2
CHK3=3
CHK4=4
CHK5=5
CHK6=6
CHK7=7
CHAUTO=17
*20
>/END OF IFNZRO CNKFLD
/NODEID MESSAGE
NCLNID,	BLOCK	100

/PER CONNECTION TABLES
CTRLTB,	BLOCK	DEVN

RCVDSP,	BLOCK	1
	BLOCK	DEVN

/	THESE TABLES MUST FOLLOW AND BE SAME LENGTH
/ AS RCVDSP.

SLATAB,
	BLOCK	DEVN
MMLTAB,
	BLOCK	DEVN
SNATAB,		/SOURCE NODE
	BLOCK	DEVN


ZZ=CTRLTB
ZZ=RCVDSP
ZZ=SLATAB
ZZ=MMLTAB
ZZ=SNATAB

/	OUTPUT MESSAGE BUFFERS

CTLSIZ=12		/DDCMP HEADER (8) + CHUNK COUNT (1) + CHUNK POINTER
SYNCHS,	BLOCK	20	/WHERE SYN BUF WILL GO
SYNBUF=.-NUMSYN
IDLBUF=SYNBUF		/NO SPECIAL BUFFER FOR IDLE MODE

CTLBUF,	BLOCK	10
	Z=4+MAXOLN+6
	T10LEN=12+MAXOLN
T10BF1,	BLOCK	Z
T10BF2,	BLOCK	Z
T10LST,	BLOCK	Z

ZZ=T10BF1
ZZ=T10BF2
ZZ=T10LST

/QUEUE OF MESSAGES FROM DECSYSTEM-10 WHICH HAVEN'T BEEN LOOKED AT YET

RCVQUE,
ZZ=CTLSIZ^10
	BLOCK	ZZ
RCVLIM,
	ZZ=RCVQUE
	ZZ=RCVLIM
/STORAGE FOR TTY'S

/QUEUE OF INPUT FROM TTY'S
/ FIRST WORD IS LINE #
/ SECOND IS 8BIT CHAR
IFNDEF TIQLEN <TIQLEN=100>
TTIQUE,	BLOCK	TIQLEN
	Z=.-BOOTSZ		/BOOTSZ IS FIRST ADDR AFTER BOOT
	ZZ=Z&4000		/SIGN OF DIFFERENCE
	IFNZRO	ZZ	<*BOOTSZ>
/MACRO TO MAKE A DEVICE BLOCK FOR A TTY
/ 1ST ARG IS DEVICE BLOCK LABEL
/ 2ND ARG IS DEVICE ADR FOR DC02 TTY'S
/ 3RD ARG IS DEVICE ADR FOR KL8E TTY'S
/ 4TH ARG IS NONZERO IF TTY HAS HDW TABS
/ 5TH ARG IS TTY CARRIAGE WIDTH
/ 6TH ARG IS TTY FILLER CLASS
/ 7TH ARG IS RESTRICTED NODE NUMBER
DEFINE TTBLK NAME Q QQ QQQ QQQQ QQQQQ QQQQQQ <XLIST
	IFNZRO	FTDC02F	<ZZ=Q>
	IFZERO	FTDC02F	<ZZ=QQ+5>
	TTYCNT=TTYCNT+1
	XLIST
	-QQQQQQ			/DEVRNN
	TTYCHK
	TTYCNT-1
NAME,	100		/LH=OBJ TYPE,RH=CONNECT
	XLIST
	*.+DEVLNK-1
	XLIST
	FIRTTY		/ADR OF PREVIOUS DEVICE BLOCK
	XLIST
	FIRTTY=.-DEVLNK-1
	FIRDDB=FIRTTY
	XLIST
	ZZ		/DEVICE ADDRESS
	XLIST
	ZZZ=ZZZ+1
		*.+1		/SKIP LDBCOL
	IFNDEF QQQQ < QQQQ=110	>		/DEFAULT WIDTH IS 72
		XLIST
	QQQQ		/TTY WIDTH
		XLIST
		ZZ=LDBFIL-1-LDBWID
		*.+ZZ
	-10	/FILLER FOR 10
	-10	/FILLER FOR 11
	-10	/FILLER FOR 12
	-10	/FILLER FOR 13
	-10	/FILLER FOR 14
	-10	/FILLER FOR 15
	Z=Z-1
	IFNZRO Z <
XLIST	>/END OF IFNZRO Z
>/END OF TTBLK

	ZZZ=200		/DEVICE NUMBER FOR CTY
			FIRTTY=0	

	Z=TTYN+1
/DEVICE DATA BLOCK FOR CTY
	TTYCNT=0
	TTBLK	CTYBLK,0,0,CTYTAB,CTYWID,CTYFIL,CTYRNN

IFNZRO Z <	TTBLK	T00BLK,4010,T00TSF,T00TAB,T00WID,T00FIL,T00RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T01BLK,2010,T01TSF,T01TAB,T01WID,T01FIL,T01RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T02BLK,1010,T02TSF,T02TAB,T02WID,T02FIL,T02RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T03BLK,0410,T03TSF,T03TAB,T03WID,T03FIL,T03RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T04BLK,0210,T04TSF,T04TAB,T04WID,T04FIL,T04RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T05BLK,0110,T05TSF,T05TAB,T05WID,T05FIL,T05RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T06BLK,0050,T06TSF,T06TAB,T06WID,T06FIL,T06RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T07BLK,0030,T07TSF,T07TAB,T07WID,T07FIL,T07RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T10BLK,4004,T10TSF,T10TAB,T10WID,T10FIL,T10RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T11BLK,2004,T11TSF,T11TAB,T11WID,T11FIL,T11RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T12BLK,1004,T12TSF,T12TAB,T12WID,T12FIL,T12RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T13BLK,0404,T13TSF,T13TAB,T13WID,T13FIL,T13RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T14BLK,0204,T14TSF,T14TAB,T14WID,T14FIL,T14RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T15BLK,0104,T15TSF,T15TAB,T15WID,T15FIL,T15RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T16BLK,0044,T16TSF,T16TAB,T16WID,T16FIL,T16RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T17BLK,0024,T17TSF,T17TAB,T17WID,T17FIL,T17RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T20BLK,4002,0,T20TAB,T20WID,T20FIL,T20RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T21BLK,2002,0,T21TAB,T21WID,T21FIL,T21RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T22BLK,1002,0,T22TAB,T22WID,T22FIL,T22RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T23BLK,0402,0,T23TAB,T23WID,T23FIL,T23RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T24BLK,0202,0,T24TAB,T24WID,T24FIL,T24RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T25BLK,0102,0,T25TAB,T25WID,T25FIL,T25RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T26BLK,0042,0,T26TAB,T26WID,T26FIL,T26RNN
 >/END OF IFNZRO Z
IFNZRO Z <	TTBLK	T27BLK,0022,0,T27TAB,T27WID,T27FIL,T27RNN
 >/END OF IFNZRO Z
IFZERO Z <	XLIST	>

TTYFEA,	2		/NUMBER OF CHARS IN FEATURES
	0		/NOTHING FANCY
	TTYN+1		/NUMBER OF LINES
/ MACRO TO MAKE DEVICE BLOCK FOR NON-TELETYPE DEVICES
/ 1ST ARGUMENT IS DDB LABEL NAME
/ 2ND ARGUMENT IS DEVICE TYPE CODE
/ 3RD ARGUMENT IS RESTRICTED NODE NUMBER
DEFINE DBLOCK NAME Q QQ <XLIST
	XLIST
	ZZ=-1			/DEFAULT
IFNZRO	LPTN	<
	IFZERO	.+2-LPTBLK <ZZ=LPTCHK>/IF LPT, USE LPT VALUE
>/END OF IFNZRO	LPTN
	DEVCNT=DEVCNT+1
	XLIST
	-QQ			/DEVRNN
	ZZ			/MAX CHUNKS
	DEVCNT-1
NAME,	Q^100
	XLIST
	Z=DEVLNK-1
	*.+Z
	XLIST
	FIRDDB		/ADR OF PREVIOUS DEVICE BLOCK
	XLIST
	FIRDDB=.-DEVLNK-1
	XLIST	>/END OF DEFINE DBLOCK


IFNZRO CDRN <
/DEVICE DATA BLOCK FOR CDR
	DEVCNT=0
	DBLOCK	CDRBLK,2,CDRRNN
	3		/LENGTH OF FEATURES
	1		/DECIMAGE
	120		/COLUMNS/CARD=80
	1		/LOW SPEED
>/END OF IFNZRO CDRN

IFNZRO LPTN <
/DEVICE DATA BLOCK FOR LPT
/ SPECIAL DEVSTS BITS:
/	LOW ORDER BIT IS A COUNT OF OPENS EXERCISED
	DEVCNT=0
	DBLOCK	LPTBLK,3,LPTRNN
	Z=LPTWID&7200
IFNZRO Z <	5	>		/LENGTH OF FEATURES
IFZERO Z <	4	>		/LENGTH OF FEATURES
IFZERO FTLPLC <	10	>		/ANSI 68
IFNZRO FTLPLC <	12	>		/ANSI 68, LOWER CASE
IFZERO Z <	LPTWID	>		/CARRIAGE WIDTH
IFNZRO Z <	Z=LPTWID&177;	200+Z;	1>		/CARRIAGE WIDTH

	305		/OVERPRINT, MULTIPART PAPER, LOWSPEED
	4		/FORMS WIDTH CHANGEABLE,
>/END OF IFNZRO LPTN

IFNZRO PTRN <
/DEVICE DATA BLOCK FOR PTR
	DEVCNT=0
	DBLOCK	PTRBLK,6,PTRRNN
	1;	0		/FEATURES
>/END OF IFNZRO PTRN

IFNZRO PTPN <
/DEVICE DATA BLOCK FOR PTP
	DEVCNT=0
	DBLOCK	PTPBLK,5,PTPRNN
	1;	0		/FEATURES
>/END OF IFNZRO PTPN

IFNZRO PLTN <
/DEVICE DATA BLOCK FOR PLT
	DEVCNT=0
	DBLOCK	PLTBLK,20,PLTRNN
	1;	0		/FEATURES
>/END OF IFNZRO PLTN

DEFINE X Q <IFDEF Q <	Q	>>

/TABLE OF DDB ADDRESSES
DDBTAB,
	X	CTYBLK
	X	T00BLK
	X	T01BLK
	X	T02BLK
	X	T03BLK
	X	T04BLK
	X	T05BLK
	X	T06BLK
	X	T07BLK
	X	T10BLK
	X	T11BLK
	X	T12BLK
	X	T13BLK
	X	T14BLK
	X	T15BLK
	X	T16BLK
	X	T17BLK
	X	T20BLK
	X	T21BLK
	X	T22BLK
	X	T23BLK
	X	T24BLK
	X	T25BLK
	X	T26BLK
	X	T27BLK
  IFDEF CDRBLK <	CDRBLK>
  IFDEF LPTBLK <	LPTBLK>
  IFDEF PTRBLK <	PTRBLK>
  IFDEF PTPBLK <	PTPBLK>
  IFDEF PLTBLK <	PLTBLK>
/STRINGS PUT OUT BY SCNSER

XOFMSG,	0223		/XOF = ^S
	4377		/FILLER (WITHOUT REGARD FOR RACE CREED OR CLASS)

TTOSPC,	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	" 		/BLANK
	4000+" 		/FINAL BLANK

CRLMSG,	0215		/CARRIAGE RETURN
	4012		/LINE FEED

DEFINE DC7MSG <	XLIST
		0104		/ASCII "D"
		0303		/ASCII "C"
		0267		/ASCII "7"
IFZERO PDP8I <	0261 >		/ASCII "1"
IFZERO PDP8E <	0262 >		/ASCII "2"
		0116		/ASCII "N"
		0120		/ASCII "P"
	XLIST>/END OF DEFINE DC7MSG

DEFINE DPMSG <	XLIST
		0104		/ASCII "D"
		0120		/ASCII "P"
IFNZRO FTDP01 <	0060		/ASCII "0"
		0261 		/ASCII "1"
>/END OF IFNZRO	FTDP01
IFZERO FTDP01 <	0270		/ASCII "8"
		0305 		/ASCII "E"
>/END OF IFZERO	FTDP01
	0040
	XLIST>/END OF DEFINE DPMSG

DEFINE	BEGMSG <	XLIST
		0215		/CARRIAGE RETURN
		0215		/ EXTRA CR FOR FILLER
		0012		/LINE FEED
		0207		/BELL
		0207		/BELL
		0245		/ASCII "%"
		0245		/ASCII "%"
	XLIST	>/END OF DEFINE BEGMSG

/COMMON MESSAGE BEGINNER FOR FATAL MESSAGES
DEFINE	FATMSG <	XLIST
		0215		/CARRIAGE RETURN
		0215		/ EXTRA CR FOR FILLER
		0012		/LINE FEED
		0207		/BELL
		0207		/BELL
		0077		/ASCII "?"
		0077		/ASCII "?"
	XLIST	>/END OF DEFINE FATMSG
/MESSAGE SENT WHEN STATION RESTARTS
RSTMSG,	377
	0012		/EXTRA LINE FEED
	207		/EXTRA BELL
	0012		/EXTRA LINE FEED
	BEGMSG
	"R
	0145		/E
	0363		/S
	0164		/T
	0341		/A
	0162		/R
	0164		/T
	0151		/I
	0356		/N
	0347		/G
	" 		/BLANK
	DC7MSG
	" 		/BLANK
	0116		/N
	0117		/O
	0104		/D
	0105		/E
	" 		/BLANK
	0042		/"
OURID,
IFDEF DC72ID <
	DC72ID
>/END OF IFDEF DC72ID
IFNDEF	DC72ID	<
	"D;"C;"7;PDP8+260;"N;"P
>/END OF IFNDEF	DC72ID
	0042		/"
	240		/SPACE
	215
	012
TTOBEL,	4207		/BELL
NCOMSG,	BEGMSG
	"T;"T;"Y;" ;"N;"O;"T;" ;"C;"O;"N;"N;"E;"C;"T;"E;"D;215;4012

/MESSAGE WHEN GET CHAR FROM TTY KEYBOARD AND STATION NOT IN CONTACT
NICMSG,	FATMSG
	"N;"O;"T;" ;"I;"N;" ;"C;"O;"N;"T;"A;"C;4000+"T

/MESSAGE FOR CTY WHEN MAKE CONTACT
CONMSG,	BEGMSG
TENID,	240;240;240;240;240;240	
	" ;"H;"A;"S;" ;"M;"A;"D;"E;" ;"C;"O;"N;"T;"A;"C;"T;215;4012


BMTMSG,	377		/SPECIAL FILLER
	FATMSG
	"B;"A;"D;" ;"M;"S;"G;" ;"T;"Y;"P;4000+"E

/UNRECOGNIZED INTERRUPT MSG
INTMSG,	377		/SPECIAL FILLER TO START
	FATMSG
	DC7MSG
	" ;"I;"N;"T;" ;"E;"R;4000+"R

/AUTODUMP MESSAGE
DMPMSG,	377			/RUBOUT TO BEGIN
	FATMSG
	DC7MSG
	" ;"C;"R;"A;"S;"H;" ;"P;"C;4000+"=
DPTMSG,	BEGMSG
	DPMSG
	" ;"T;"I;"M;"E;"O;"U;4000+"T

IFNZRO CDRN <		/MESSAGE WHEN GET READ CHECK ON CARDREADER
RCKMSG,	BEGMSG
	"R;"D;"C;"H;"K;" ;"-;" ;"R;"E;"F;"E;"E;"D;" ;"C;"A;"R;"D;215;4012
>/END OFIFNZRO CDRN

IFNZRO FTTRBL <
IFNZRO LPTN <
/MESSAGE WHEN LPT TIMES OUT
LPTMSG,	BEGMSG
	"L;"P;"T;" ;"T;"R;"B;4000+"L
>/END OF IFNZRO LPTN

IFNZRO PTPN <
/MSG WHEN PTP TIMES OUT
PTPMSG,	BEGMSG
	"P;"T;"P;" ;"T;"R;"B;4000+"L
>/END OF IFNZRO PTPN
>/END OF IFNZRO FTTRBL


IFZERO FTDP01 <
/MESSAGE IF DP8E GETS A BUS ERROR
DBEMSG,	BEGMSG
	DPMSG
	" ;"B;"U;"S;" ;"E;"R;4000+"R

/MESSAGE WHEN CARRIER LOST
LCRMSG,	BEGMSG
	"C;"A;"R;"R;"I;"E;"R;" ;"L;"O;"S;"T;215;4012
CARMSG,	BEGMSG
	"C;"A;"R;"R;"I;"E;"R;" ;"B;"A;"C;"K;215;4012
>/END OF IFZERO FTDP01

IFNZRO FTDP01 <
/MSG WHEN SYNCHRONOUS MODEM LOSES CONTACT
ENDMSG,	BEGMSG
	DPMSG
	" ;"E;"N;"D;" ;"F;"L;"A;4000+"G
>/END OF IFNZRO FTDP01
IFNZRO CDRN <
/CARD CODE TRANSLATION TABLES
/ TRICK IS USE ROWS TO INDEX INTO THE TABLES
/ IF THE RESULT HAS THE SIGN BIT ON CAN'T COMPRESS COLUMN
/TABLE TO TRANSLATE ROWS 1/2/3/4/5
CD1TAB,	0000;	2005;	2004;	4000;	2003;	4000;	4000;	4000
	2002;	4000;	4000;	4000;	4000;	4000;	4000;	4000
	3001;	4000;	4000;	4000;	4000;	4000;	4000;	4000
	4000;	4000;	4000;	4000;	4000;	4000;	4000;	4000

/TABLE TO TRANSLATE ROWS 6/7/8/9
CD2TAB,	0000;	2011;	1010;	4000;	2007;	4000;	2017;	4000
	2006;	4000;	2016;	4000;	4000;	4000;	4000;	4000
>/END OF IFNZRO CDRN
/TABLE FOR INTERPRETING TTY & LPT CHAR FUNCTIONS
/ BIT DEFINITIONS ARE:
	CHRBRK=0
	CHRARR=0
	CHRSUP=0
	CHRALT=0
	CHRFLL=2000
	CHRDEF=4000		/GO INTO DEFERRED ECHO
	CHRXOF=0200		/CHAR IS AN XOF
	CHRHT=0040		/CHAR IS AN HT
	CHRHMO=0020		/CHAR PERFORMS HORIZONTAL MOTION
	CHRCR=0010		/CHAR IS A CARRIAGE RETURN
	CHRLC=0004		/CHAR IS LOWER CASE
/	0002		/FOR LPT CHAR IS SPECIAL MOTION
/	0001		/FOR LPT FLUSH CHAR

CHRTAB,	0001			/ASCII 0
	CHRDEF+CHRARR+0001	/ASCII 1 = ^A
	CHRDEF+CHRARR+0001	/ASCII 2 = ^B
	CHRDEF+CHRBRK+CHRARR+0001	/ASCII 3 = ^C
	CHRDEF+CHRARR+0001	/ASCII 4 = ^D
	CHRDEF+CHRARR+0001	/ASCII 5 = ^E
	CHRDEF+CHRARR+0001	/ASCII 6 = ^F
	CHRDEF+CHRBRK+0001	/ASCII 7 = ^G = BELL
	CHRDEF+CHRFLL+0001	/ASCII 10 = ^H
	CHRFLL+CHRHT+0002	/ASCII 11 = ^I = HORIZONTAL TAB
	CHRDEF+CHRBRK+CHRFLL+0002	/ASCII 12 = LINE FEED
	CHRDEF+CHRBRK+CHRFLL+0002	/ASCII 13 = VERT TAB
	CHRDEF+CHRBRK+CHRFLL+0002	/ASCII 14 = FORM FEED
	CHRFLL+CHRCR+0002	/ASCII 15 = CARRIAGE RETURN
	CHRDEF+CHRARR+0001	/ASCII 16 = ^N
	CHRDEF+CHRARR+0001	/ASCII 17 = ^O
	CHRDEF+CHRARR+0002	/ASCII 20 = ^P
	CHRDEF+CHRARR+0002	/ASCII 21 = ^Q = XON
	CHRDEF+CHRARR+0002	/ASCII 22 = ^R
	CHRDEF+CHRARR+CHRXOF+0002	/ASCII 23 = ^S = XOF
	CHRDEF+CHRARR+0002	/ASCII 24 = ^T
	CHRDEF+CHRSUP+0001	/ASCII 25 = ^U - NOT CHRARR BECAUSE SPECIAL HANDLING
	CHRDEF+CHRARR+0001	/ASCII 26 = ^V
	CHRDEF+CHRARR+0001	/ASCII 27 = ^W
	CHRDEF+CHRARR+0001	/ASCII 30 = ^X
	CHRDEF+CHRARR+0001	/ASCII 31 = ^Y
	CHRDEF+CHRBRK+CHRARR+0001	/ASCII 32 = ^Z
	CHRDEF+CHRBRK+CHRALT+0001	/ASCII 33 = ALTMODE
	CHRDEF+CHRARR+0001	/ASCII 34 = ^\
	CHRDEF+CHRARR+0001	/ASCII 35 = ^]
	CHRDEF+CHRARR+0001	/ASCII 36 = ^^
	CHRDEF+CHRARR+0001	/ASCII 37 = ^_
CHRBLA,				/CHARACTER WITH CHRHMO BIT SET FOR TAB SIMULATION
	CHRHMO			/ASCII 40 =  
	CHRHMO			/ASCII 41 = !
	CHRHMO			/ASCII 42 = "
	CHRHMO			/ASCII 43 = #
	CHRHMO			/ASCII 44 = $
	CHRHMO			/ASCII 45 = %
	CHRHMO			/ASCII 46 = &
	CHRHMO			/ASCII 47 = '
	CHRHMO			/ASCII 50 = (
	CHRHMO			/ASCII 51 = )
	CHRHMO			/ASCII 52 = *
	CHRHMO			/ASCII 53 = +
	CHRHMO			/ASCII 54 = ,
	CHRHMO			/ASCII 55 = -
	CHRHMO			/ASCII 56 = .
	CHRHMO			/ASCII 57 = /
	CHRHMO			/ASCII 60 = 0
	CHRHMO			/ASCII 61 = 1
	CHRHMO			/ASCII 62 = 2
	CHRHMO			/ASCII 63 = 3
	CHRHMO			/ASCII 64 = 4
	CHRHMO			/ASCII 65 = 5
	CHRHMO			/ASCII 66 = 6
	CHRHMO			/ASCII 67 = 7
	CHRHMO			/ASCII 70 = 8
	CHRHMO			/ASCII 71 = 9
	CHRHMO			/ASCII 72 = :
	CHRHMO			/ASCII 73 = ;
	CHRHMO			/ASCII 74 = <
	CHRHMO			/ASCII 75 = =
	CHRHMO			/ASCII 76 = >
	CHRHMO			/ASCII 77 = ?
	CHRHMO			/ASCII 100 = @
	CHRHMO			/ASCII 101 = A
	CHRHMO			/ASCII 102 = B
	CHRHMO			/ASCII 103 = C
	CHRHMO			/ASCII 104 = D
	CHRHMO			/ASCII 105 = E
	CHRHMO			/ASCII 106 = F
	CHRHMO			/ASCII 107 = G
	CHRHMO			/ASCII 110 = H
	CHRHMO			/ASCII 111 = I
	CHRHMO			/ASCII 112 = J
	CHRHMO			/ASCII 113 = K
	CHRHMO			/ASCII 114 = L
	CHRHMO			/ASCII 115 = M
	CHRHMO			/ASCII 116 = N
	CHRHMO			/ASCII 117 = O
	CHRHMO			/ASCII 120 = P
	CHRHMO			/ASCII 121 = Q
	CHRHMO			/ASCII 122 = R
	CHRHMO			/ASCII 123 = S
	CHRHMO			/ASCII 124 = T
	CHRHMO			/ASCII 125 = U
	CHRHMO			/ASCII 126 = V
	CHRHMO			/ASCII 127 = W
	CHRHMO			/ASCII 130 = X
	CHRHMO			/ASCII 131 = Y
	CHRHMO			/ASCII 132 = Z
	CHRHMO			/ASCII 133 = [
	CHRHMO			/ASCII 134 = \
	CHRHMO			/ASCII 135 = ]
	CHRHMO			/ASCII 136 = ^
	CHRHMO			/ASCII 137 = _
	CHRHMO			/ASCII 140 =
	CHRLC+CHRHMO		/ASCII 141 = LC A
	CHRLC+CHRHMO		/ASCII 142 = LC B
	CHRLC+CHRHMO		/ASCII 143 = LC C
	CHRLC+CHRHMO		/ASCII 144 = LC D
	CHRLC+CHRHMO		/ASCII 145 = LC E
	CHRLC+CHRHMO		/ASCII 146 = LC F
	CHRLC+CHRHMO		/ASCII 147 = LC G
	CHRLC+CHRHMO		/ASCII 150 = LC H
	CHRLC+CHRHMO		/ASCII 151 = LC I
	CHRLC+CHRHMO		/ASCII 152 = LC J
	CHRLC+CHRHMO		/ASCII 153 = LC K
	CHRLC+CHRHMO		/ASCII 154 = LC L
	CHRLC+CHRHMO		/ASCII 155 = LC M
	CHRLC+CHRHMO		/ASCII 156 = LC N
	CHRLC+CHRHMO		/ASCII 157 = LC O
	CHRLC+CHRHMO		/ASCII 160 = LC P
	CHRLC+CHRHMO		/ASCII 161 = LC Q
	CHRLC+CHRHMO		/ASCII 162 = LC R
	CHRLC+CHRHMO		/ASCII 163 = LC S
	CHRLC+CHRHMO		/ASCII 164 = LC T
	CHRLC+CHRHMO		/ASCII 165 = LC U
	CHRLC+CHRHMO		/ASCII 166 = LC V
	CHRLC+CHRHMO		/ASCII 167 = LC W
	CHRLC+CHRHMO		/ASCII 170 = LC X
	CHRLC+CHRHMO		/ASCII 171 = LC Y
	CHRLC+CHRHMO		/ASCII 172 = LC Z
	CHRDEF			/ASCII 173 =
	CHRDEF			/ASCII 174 =
	CHRDEF+CHRBRK+CHRALT	/ASCII 175 = ALTMODE
	CHRDEF+CHRBRK+CHRALT	/ASCII 176 = ALTMODE
	CHRDEF+CHRSUP+0001	/ASCII 177 = RUBOUT
	LISTOG	LPTN
IFNZRO LPTN <
LPTTBL,	0		/CHAR 11 = HORIZONTAL TAB
	0001		/CHAR 12 = LF = CHANNEL 8
	0002		/CHAR 13 = VT = CHANNEL 7
	-2		/CHAR 14 = FORM FEED = CHANNEL 1
	-1		/CHAR 15 = CARRIAGE RETURN
	0		/CHAR 16 = CHANGE RIBBON TO RED
	0		/CHAR 17 = CHANGE RIBBON TO BLACK
	0100		/CHAR 20 = DC0 = CHANNEL 2
	0040		/CHAR 21 = DC1 = CHANNEL 3
	0020		/CHAR 22 = DC2 = CHANNEL 4
	0010		/CHAR 23 = DC3 = CHANNEL 5
	0004		/CHAR 24 = DC4 = CHANNEL 6


/SIMULATED CARRIAGE CONTROL TAPE FOR LPT

LPTVFU,	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8

	051		/ 3-5-8
	031		/ 4-5-8
	055		/ 3-5-6-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8

	051		/ 3-5-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8
	057		/ 3-5-6-7-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8

	071		/ 3-4-5-8
	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	175		/ 2-3-4-5-6-8
	011		/ 5-8

	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8

	057		/ 3-5-6-7-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8
	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8

	071		/ 3-4-5-8
	011		/ 5-8
	055		/ 3-5-6-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	071		/ 3-4-5-8
	011		/ 5-8

	051		/ 3-5-8
	031		/ 4-5-8
	051		/ 3-5-8
	011		/ 5-8
	010		/ 5
	010		/ 5
	010		/ 5
	010		/ 5

	010		/ 5
	010		/ 5
	-1		/FLAG END OF TAPE
>/END OF IFNZRO LPTN
	LISTOG	LPTN
STARTC,	ENQ;6;0;0;0;1;111;225	/DDCMP START MESSAGE
STARTD,	SOH;0;0;0;0;1		/START OF DATA MESSAGE
 DEFINE VAL Q <	Q
	 XLIST; ZZZ=ZZZ+1; XLIST>/END OF DEFINE VAL
	ZZZZ=.
CNF,	0			/LENGTH 
	ZZZ=0
	VAL	5		/MESSAGE TYPE
	IFNZRO	LPTN	<
	VAL	3		/OBJECT CLASS
	VAL	LPTN
	VAL	0		/DESCRIPTION
>/END OF IFNZRO	LPTN
	VAL	1		/OBJECT TYPE
	VAL	TTYN+1
	VAL	0		/DESCRIPTION
	IFNZRO	CDRN	<
	VAL	2		/OBJECT TYPE
	VAL	CDRN
	VAL	0		/DESCRIPTION
>/END OF IFNZRO	CDRN
	ZZZZZ=.
	*ZZZZ
	ZZZ
	*ZZZZZ

FREDCK,	0		/COUNT OF CHUNKS FREED BY FRECKS


DEFINE	X	Q QQ QQQ <XLIST
IFNZRO Q <XLIST
	Z-QQ
	QQQ
XLIST
	Z=QQ	>/END OF IFNZRO	Q
XLIST	>/END OF X
	Z=0
DEVTYP,	X	1,1,CONTTY		/CONNECT FOR TTY
	X	CDRN,2,CONCDR
	X	LPTN,3,CONLPT
/CONSIDER THE FOLLOWING METHOD OF CACULATING CRC-16
/ CALL:	PUSHJ	P,CRCALC
/ CRCALC:	XOR	C,CRC
/	ANDI	C,377
/	LSH	CRC,-10
/	XOR	CRC,TAB(C)
/RH OF TABLE FOLLOWS IMMEDIATELY, LH IS CRCTAB+400
CRCTAB,
/	***********************************************************
/	***********************************************************
/	***							***
/	***			CHUNKS				***
/	***							***
/	***********************************************************
/	***********************************************************


/FORMAT OF CHUNKS IS
/	LINK WORD (I.E. POINTER TO NEXT CHUNK)
/	DATA
/	LAST DATA WORD WITH SIGN BIT SET(FLAGS END OF DATA IN BUFFER)
/	REMAINING SPACE IN CHUNK, IF ANY

/CHUNKS MUST BEGIN ON A MULTIPLE OF CNKSIZ
Z=.+CNKSIZ-1
ZZ=-CNKSIZ
*Z&ZZ

	FIRCNK=.+1000		/START CHUNKS AFTER CRC TABLE

	PAGE		/SO SYSCHK BEGINS ON A PAGE BOUNDRY
/	***********************************************************
/	***********************************************************
/	***							***
/	***		SYSCHK - ONCE ONLY SYSTEM DIAGNOSTIC	***
/	***							***
/	***********************************************************
/	***********************************************************

/ONCE ONLY SYSTEM ANALYZER
/ CODE IS OVERWRITTEN BY CHUNKS SO CAN ONLY BE EXECUTED ONCE

SYSCHK,	SKP			/TRY TO SKIP
	  7402			/IT DIDN'T WORK ? ! ?
	NL0			/ZERO AC
	SZA			/SKIP IF AC IS ZERO
	  7402			/HARDWARE FAILURE
	SPA			/SKIP IF AC IS POSITIVE
	  7402			/HARDWARE FAILURE
	SMA			/SKIP IF AC IS NEGATIVE
	  SKP			/SHOULDN'T HAVE SKIPPED SO OK
	  7402			/HARDWARE FAILURE
	NL1			/PUT 1 IN AC
	SNA			/BE SURE AC IS NON ZERO
	  7402

	BSW			/IF AN 8E SWAP HALVES
	TAD	(7700
	IFZERO PDP8I <
	SZA CLA
>/END OF IFZERO	PDP8I
	IFNZRO PDP8I <
	SNA CLA
>/END OF IFNZRO	PDP8I
	  JMP	SCHK00		/CODE IS FOR RIGHT MACHINE
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INLTYP		/TRYING TO RUN 8I CODE ON AN 8E(OR VICE VERSA)
	DC7MSG
	" ;"W;"O;"N;47;"T;" ;"R;"U;"N;" ;"O;"N;" ;"A;" ;"P;"D;"P;"8
IFZERO PDP8I <	4000+"E	>
IFZERO PDP8E <	4000+"I	>
	HLT			/RETURNS HERE AFTER TYPEING MESSAGE
	JMP	SYSCHK		/IF OPERATOR CONTINUES TEST AGAIN
SCHK00,	JMS	INLTYP
	15;15;207;12;377
	"[;"I;"N;"I;"T;"I;"A;"L;"I;"Z;"I;"N;"G
	" ;"N;"E;"T;"W;"O;"R;"K;" 
IFNZRO FTLBACK < "L;"O;"O;"B;"A;"C;"K;" ;"T;"E;"S;"T;"  >
IFZERO FTLBACK < DC7MSG >
	" ;4366
	CDFINS			/PICK UP WORD FROM INSTRUCTION FIELD
	TAD I	(202		/GET VERSION NUMBER
	DCA	CHK1		/SAVE IT
	CDFCNK
	TAD	CHK1		/GET VERSION
	AND	(7700
	CLL RTR
	RTR
	RTR
	JMS	INIOCT
	JMS	INLTYP
	".+4000
	TAD	CHK1
	AND	(0077
	JMS	INIOCT		/TYPE VERSION NUMBER
	JMS	INLTYP

	" ;"N;"O;"D;"E
	240			/BLANK
	42
IFDEF DC72ID <
	DC72ID
>/END OF IFDEF DC72ID
IFNDEF	DC72ID	<
	"D;"C;"7;PDP8+260;"N;"P
>/END OF IFNDEF	DC72ID
	4042
	JMS	INLTYP
	"];15;15;12;4012
	JMP	SCHK01


	PAGE
SCHK01,	IFZERO PDP8E <CAF>	/ON 8E CLEAR ALL FLAGS

/HERE TO CHECK SYSTEM CLOCK IS PRESENT AND ACCURATE
	CLKECI			/RESET THE CLOCK
	NL0			/GIVE IT LOTS OF TIME FOR FIRST TICK
	JMS	SCHK02		/GO GET 1ST TICK
	CLKSCF			/AND THERE SHOULD NOT BE ANOTHER FLAG UP YET
	  SKP			/OK IT WASN'T UP AGAIN
	JMP	SCHK03		/IT DID COME UP AGAIN ??

/ASSUME LINE FREQUENCY IS 50CYCLE
IFZERO PDP8E <TAD (-6231-240 >	/6231 = 3226.
IFZERO PDP8I <TAD (-3636-240 >	/3636 = 1951.
	JMS	SCHK02		/TIME TICK
	TAD	CHK1
	SMA			/BE SURE IT ALMOST TOOK UP ALL OF TIME
	  JMP	SCHK03		/NO WHERE NEAR RIGHT
	TAD	(500
	SMA CLA			/IS THIS IN RANGE FOR 50 CYCLE ?
	  JMP	SCHK04		/YES
	DCA	HERTZF		/NOT 50 CYCLE

/NOT 50 CYCLES SO ASSUME 60 CYCLES
IFZERO PDP8E <TAD (-5177-240 >	/5177 = 2688.
IFZERO PDP8I <TAD (-3131-240 >	/3131 =3225.
	JMS	SCHK02
	TAD	CHK1
	SMA
	  JMP	SCHK03
	TAD	(500
	SPA CLA
	  JMP	SCHK03
	JMP	SCHK04		/CLOCK IS OK SO GO ON

/HERE TO WAIT FOR A CLOCK TICK
/ LOOP TAKES 10.25US ON PDP8I
/ LOOP TAKES 6.2US ON A PDP8E
SCHK02,	0
	DCA	CHK1		/SAVE MAX COUNT

IFZERO PDP8E <			/TIME TWO TICKS FOR PDP8E
	CLKSCF			/(1.2US)IS CLOCK FLAG UP ?
	  SKP			/(1.2US) NO
	JMP	.+4		/HAVE SEEN ONE CLOCK TICK
	ISZ	CHK1		/(2.6US)
	  JMP	.-4		/(1.2US)KEEP WAITING FOR CLOCK
	JMP	SCHK03		/TIMED OUT ON FIRST TICK !?!
>/END OF IFZERO PDP8E

	CLKSCF			/(1.2 OR 4.25US)IS CLOCK FLAG UP ?
	  SKP			/(1.2 OR 1.5US) NO
	JMP I	SCHK02		/HAVE SEEN ONE CLOCK TICK
	ISZ	CHK1		/(2.6 OR 3.0US)
	  JMP	.-4		/(1.2 OR 1.5US)KEEP WAITING FOR CLOCK

/HERE WHEN CLOCK IS MISBEHAVING
SCHK03,	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INLTYP
IFZERO PDP8E <	"D;"K;"8	>
IFZERO PDP8I <	"K;"W;"8	>
	" ;"E;"R;"R;"O;"R;215;4012
	HLT
	JMP	SCHK01		/TRY AGAIN IF HE INSISTS

HERTZF,	6			/NONZERO MEANS RUNNING ON 50 CYCLE
/MEMORY PARITY CHECK

SCHK04,

/HERE TO SEE IF MEMORY PARITY OPTION IS PRESENT
/ NOT NECESSARY ON PDP8E'S
IFNZRO PDP8E <
	TAD	(NOP
	CDFINS			/PREPARE TO WRITE INSTRUCTION FIELD
	MEMCMP			/CLEAR MEMORY PARITY ERROR FLAG
	MEMSMP			/SKIP IF WE HAVE PARITY OPTION
	  DCA I	(MEMTST		/WE DON'T
	NL0
	TAD I	(MEMTST		/PICK UP SKP OR NOP
	CDFCNK
	DCA	SCHK05
>/END OF IFNZRO PDP8E

	JMP	SCHK06

SCHK05,	0
/HERE TO SEE HOW MUCH MEMORY IS PRESENT
/ ADJUST DISMAX, DISCDF AND TRACE CODE ACCORDINGLY

SCHK06,	CDFINS			/SET TO INSTRUCTION FIELD TO CHANGE BUGGER
	DCA I	(DISMAX		/INITIALIZE MAX FIELD WE HAVE
	TAD	(7577
	DCA I	(BUGGER		/INITIALIZE BUGGER TO POINT TO 200 WORD AREA
SCHK07,	TAD I	(DISMAX
	CLL RAL
	CLL RTL
	TAD	(CDF
	DCA	.+1
	CDFINS
	TAD	(7402		/BIT PATTERN TO STORE INTO FIELD
	DCA I	(0		/AND STORE IN MEMORY
	TAD	(-7402
	TAD I	(0		/WILL LEAVE 0 IF THERE BANK PRESENT
	CDFINS
	SZA CLA			/IS THIS MEMORY BANK THERE ?
	  JMP	SCHK08		/NO
	ISZ I	(DISMAX
	TAD I	(DISMAX
	TAD	(-10
	SZA CLA
	  JMP	SCHK07
SCHK08,	TAD I	(DISMAX
	NEGATE
	TAD	(0010
	DCA I	(DISMIN

/NOW CHANGE TRACE IF WE HAVE AN EXTRA FIELD
	TAD	(-CNKFLD-1
	TAD I	(DISMAX
	SPA SNA CLA
	  JMP	SCHK10		/NO NEXT FIELD SO LEAVE WELL ENOUGH ALONE

	CDFINS			/NOW WE ARE CHANGING INSTRUCTIONS IN FIELD 0
	TAD	(CDFCNK+0010
	DCA I	(TRACEW+1	/SET SO DUMP INTO TRACE FIELD
	TAD I	(TRCWD2		/ THIS IS A (JMP I TRACEW)
	DCA I	(TRCWD1		/EXIT ROUTINE EARLY
	NLM1
	DCA I	(BUGGER		/START BY DUMPING INTO WORD 0

	CDFCNK+10	
	DCA	CHK1
	TAD	(7402
	DCA I	CHK1
	ISZ	CHK1
	JMP	.-3

	JMP	SCHK10

	PAGE
SCHK10,
	LISTOG	TTYN
IFNZRO TTYN <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		SYSCHK FOR TTY LINES			***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO CHECK TTYS ARE REASONABLE
/ FIRST CHECK THAT CHAR OUTPUT DOES NOT RAISE FLAG IMMEDIATELY
/ AND THAT IT DOES RAISE FLAG A REASONABLE AMOUNT OF TIME

	CDFCNK

IFNZRO FTDC02F <		/FIRST BE SURE DC02F IS INSTALLED
	TAD	(0017		/SELECT ALL GROUPS
	DCMTPF			/GET TRANSMIT FLAGS
	AND	(0017		/SHOULD HAVE CLEARED GROUP SELECT
	SZA CLA
	  JMP	SCHK25		/COMPLAIN ABOUT DC02F THEN FIX IT
>/END OF IFNZRO FTDC02F

	DCA	CHK1		/START WITH TTY0
SCHK11,	CDFCNK			/SET TO CHUNK DATAFIELD
	TAD	CHK1
	TAD	(DDBTAB+1
	DCA	CHK2
	TAD I	CHK2		/GET ADR OF DEVICE BLOCK
	TAD	[LDBADR		/POINT TO DEVICE ADDRESS WORD
	DCA	CHK2		/SAVE ADR OF WORD WITH DEVICE ADR
	TAD	(-15		/GIVE TTY .208 SEC TO XMT FLAG
	DCA	INISEC
	DCA	CHK5		/SET NONZERO TO FLAG LINE IS RUNNING OPEN

	TAD	(207		/ASCII BELL

IFNZRO FTDC02F <
/HERE TO TYPE A CHAR ON TTY
	DCA	CHK3		/SAVE CHAR
	TAD	(0017		/SELECT ALL GROUPS, NO LINES
	DCMTON
	NL0
	TAD I	CHK2		/SELECT THIS GROUP, THIS LINE
	DCMTON
	NL0
	TAD	CHK3		/GET CHAR AGAIN
	DCMTCF DCMTPC		/TYPE CHAR
	NL0
>/END OF IFNZRO FTDC02F

IFZERO FTDC02F <
/HERE TO TYPE A CHAR
	DCA	CHK3		/SAVE CHAR
	TAD I	CHK2		/GET TLS FOR LINE
	DCA	.+2
	TAD	CHK3		/GET CHAR AGAIN
	0			/TYPE CHAR
	NL0
>/END OF IFZERO FTDC02F

	JMS	SCHK17		/SEE IF XMT FLAG IS UP
	  JMP	SCHK29		/YES THAT IS TOO FAST
SCHK12,	JMS	SCHK17		/SEE IF LINE HAS XMT INTERRUPTED YET
	  JMP	SCHK20		/IT HAS

	JMS	SCHK19		/GET CHAR FROM TTY IF ANY
	  JMP	SCHK13		/NONE
	SNA			/IS IT A NULL ?
	  ISZ	CHK5		/FLAG LINE IS RUNNING OPEN
	TAD	(-207
	SNA CLA			/IS TTY IN LOOP BACK MODE ?
	  JMP	SCHK26		/YES SO TELL OPERATOR

SCHK13,	JMS	SCHK98		/HAVE WE WAITED TOO LONG ?
	  JMP	SCHK12		/NO KEEP WAITING
	JMS	SCHK28		/GIVE TTY ID
	JMS	INLTYP
	"N;"O;" ;"X;"M;"T;" ;"F;"L;"A;4000+"G
	JMP	SCHK22

SCHK20,	JMS	SCHK19		/SEE IF THERE IS ANY TYPEIN
	  JMP	SCHK21		/NONE
	SNA			/IS IT NULL
	  ISZ	CHK5		/YES
	TAD	(-207
	SNA CLA			/IS TTY IN LOOPBACK MODE ?
	  JMP	SCHK26		/YES SO TELL OPERATOR
SCHK21,	JMS	SCHK98		/CHECK CLOCK
	  JMP	SCHK20		/ KEEP WAITING TO TEST FOR LOOP BACK MODE
SCHK22,	NL0
	JMS	SCHK17		/CLEAR XMT FLAG IF UP
	  NOP
	TAD	CHK5		/IS LINE RUNNING OPEN ?
	SNA CLA
	  JMP	SCHK23		/NOT RUNNING OPEN
	JMS	SCHK28		/TYPE TTY LINE #
	TAD	(ERR23-1
	JMS	INITYP

SCHK23,	ISZ	CHK1		/ADVANCE TO NEXT TTY #
	TAD	CHK1		/GET NEW LINE #
	TAD	(-TTYN
	SZA CLA			/HAVE WE DONE ALL OF THE LINES ?
	  JMP	SCHK11		/GO DO NEXT TTY LINE
	JMP	SCHK30

IFNZRO FTDC02F <
/HERE TO SEE IF A LINE HAS XMT INTERRUPTED
/ CALL	JMS	SCHK17
/	RETURN IF HAS XMT INTERRUPTED
/	NORMAL RETURN
SCHK17,	0
	NL0
	TAD I	CHK2		/SELECT FOR THIS LINE & GROUP
	AND	(0017		/SELECT GROUP ONLY
	DCMTPF			/GET TRANSMIT FLAGS
	AND I	CHK2		/AND LEAVE ONLY FLAG FOR OUR LINE
	SZA CLA			/HAS IT COME UP YET
	  JMP	.+3		/YES SO CLEAR FLAG THEN RETURN
	ISZ	SCHK17		/YES SO SKIP RETURN
	JMP I	SCHK17
	DCMTCF			/CLEAR FLAG
	JMP I	SCHK17
/HERE TO GET A CHAR FROM A TTY KEYBOARD
/ CALL	JMS	SCHK19
/	RETURN		/IF NONE
/	RETURN WITH CHAR IN AC
SCHK19,	0
	TAD I	CHK2
	AND	(0017		/SELECT GROUP ONLY
	DCMTKF			/GET KEYBOARD FLAGS
	AND I	CHK2
	SNA CLA			/DOES KEYBOARD HAVE FLAG UP ?
	JMP I	SCHK19		/NO SO RETURN
	TAD	(0017		/SELECT ALL GROUPS, NO LINES
	DCMTON
	NL0
	TAD I	CHK2		/GET SELECT FOR THIS LINE
	DCMTON
	NL0
	DCMKRS DCMKCC		/GET CHAR
	ISZ	SCHK19		/SKIP RETURN
	JMP I	SCHK19
>/END OF IFNZRO FTDC02F

IFZERO FTDC02F <
/HERE TO SEE IF TTY HAS XMT INTERRUPTED
SCHK17,	0
	TAD I	CHK2		/GET THE TLS INSTRUCTION
	TAD	(-5		/MAKES A TSF INSTRUCTION
	DCA	.+1
	0
	ISZ	SCHK17		/NORMAL(I.E. SKIP) RETURN
	JMP I	SCHK17
/HERE TO GET A CHAR FROM A TTY
SCHK19,	0
	TAD	CHK1		/GET LINE NUMBER
	CLL RTL			/MULTIPLY BY 4
	TAD	(INTTTY
	DCA	CHK3
	CDFINS
	TAD I	CHK3		/GET KSF
	CDFCNK
	DCA	.+1
	7402
	JMP I	SCHK19		/NO CHAR SO RETURN
	ISZ	SCHK19		/SKIP RETURN
	TAD	.-3		/PICK UP KSF AGAIN
	DCA	.+5		/SAVE FOR TEST AFTER KRB
	TAD	.+4		/GET KSF AGAIN
	TAD	(0005		/MAKES A KRB
	DCA	.+1
	7402			/PUT KRB HERE
	7402			/PUT KSF HERE
	JMP I	SCHK19
>/END OF IFZERO FTDC02F

	PAGE
IFNZRO FTDC02F <
SCHK25,	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INLTYP
	"D;"C;"0;"2;"F;" ;"I;"S;" ;"N;"O;"T;" ;"P;"R;"E;"S;"E;"N;4000+"T
	CDFINS			/CHANGE DATA FIELD TO GET INSTRUCTION FIELD
IFDEF DC1MSK < DCA I (DC1MSK >		/MAKE MASK ZERO SO DON'T USE DC02F
IFDEF DC2MSK < DCA I (DC2MSK >
IFDEF DC3MSK < DCA I (DC3MSK >
IFDEF DC4MSK < DCA I (DC4MSK >
	CDFCNK			/CHANGE BACK TO NORMAL DATA FIELD
	JMP	SCHK30		/THEN CHECK SYN STUFF
>/END OF IFNZRO FTDC02F

/HERE WHEN TTY IS APPARENTLY IN LOOP BACK MODE
SCHK26,	JMS	SCHK28		/TYPE TTYP#
	JMS	INLTYP
	"I;"S;" ;"I;"N;" ;"L;"O;"O;"P;"B;"A;"C;"K;" ;"M;"O;"D;4000+"E
	JMS	SCHK27		/TRY TO FLUSH TTY ENABLE
	JMP	SCHK23		/WE ARE DONE WITH THIS LINE

/HERE TO FLUSH TTY FROM INTERRUPTING IF IT IS BAD
SCHK27,	0
	NL0
	TAD	CHK1		/GET LINE NUMBER

IFNZRO FTDC02F <
	RTR
	RAR
	AND	(0007		/LEAVE GROUP ONLY
	TAD	(DC1MSK
	DCA	CHK3
	TAD I	CHK2		/GET MASK FOR LINE
	AND	(7760		/LEAVE LINE SELECT BITS ONLY
	CMA			/MAKE A MASK FOR DC1MSK(ETC)
	CDFINS
	AND I	CHK3		/STRIP ENABLE BIT FROM DC1MSK(ETC)
	DCA I	CHK3
	CDFCNK
>/END OF IFNZRO FTDC02F

IFZERO FTDC02F <
	CLL RTL			/MULTIPLY BY 4
	TAD	(INTTTY+3
	DCA	CHK3
	CDFINS
	DCA I	CHK3		/CLEAR DDB ADR IN KSF CHAIN
	CDFCNK
>/END OF IFZERO FTDC02F

	JMP I	SCHK27

/HERE TO TYPE TTY IDENTIFICATION
SCHK28,	0
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INLTYP
	"T;"T;4000+"Y
	TAD	CHK1		/GET LINE NUMBER
	JMS	INIOCT		/TYPE OCTAL NUMBER
	JMS	INLTYP
	4240			/SPACE
	JMP I	SCHK28

SCHK29,	JMS	SCHK28		/TYPE TTY NAME
	JMS	INLTYP
	"X;"M;"T;4240
	JMS	SCHK93		/TYPE "FLAG WON'T CLEAR"
	HLT
	JMP	SCHK10		/REDO SYSCHK FOR TTY'S

SCHK24,	JMS	SCHK28		/TYPE TTY ID
	JMS	INLTYP
	"R;"C;"V;4240
	JMS	SCHK93		/TYPE "FLAG WON'T CLEAR
	HLT
	JMP	SCHK10		/TRY AGAIN IF HE INSISTS

ERR23,	"I;"S;" ;"R;"U;"N;"N;"I;"N;"G;" ;"O;"P;"E;4000+"N

	PAGE
>/END OF IFNZRO TTYN
	LISTOG	TTYN
/	***********************************************************
/	***********************************************************
/	***							***
/	***	SYSCHK FOR SYNCHRONOUS INTERFACE - XMT		***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO CHECK SYNCHRONOUS INTERFACE
/ CHK6 IS A FLAG FOR XMT TEST
/ CHK5 IS A FLAG FOR ANY CHAR RECEIVED
/ CHK4 IS A FLAG FOR NONSYNCH RECEIVED TEST

CHKDPT=200		/TIME FOR SYNCHRONOUS INTERFACE TO COME ALIVE
			/ APP 2 SECONDS

	SKP
	HLT

SCHK30,	CDFCNK			/SET RIGHT DATA FIELD
	JMS	SCHKA1		/INITIALIZE BUFFERS
	NLM1
	DCA	CHK6		/FLAG 1ST TIME THROUGH XMT TEST
IFNZRO FTDP01 <	NLM1	;	DCA	CHKST1 >	/ DITTO
IFZERO FTDP01 <
	TAD	(0020
	DCA	CHKST1		/INITIAL STS1
	TAD	(5400
	DCA	CHKST2		/INITIAL STS2
>/END IFZERO FTDP01

IFZERO FTDP01 <
	CDFINS
	TAD	(F10TCH-1	/POINTER TO TEST CHARS
	DCA	AUTO1
	DCA I	AUTO1
	DCA I	AUTO1
	DCA I	AUTO1
	TAD	(SYN
	DCA I	AUTO1
	CDFCNK
>/END OF IFZERO FTDP01

SCHK31,	NLM1
	DCA	CHK5		/FLAG FIRST TIME THROUGH BASIC REC TEST
	NLM1
	DCA	CHK4
SCHK32,
IFNZRO FTDP01 <
	DPSTR			/SET TERMINAL READY
	DPCEF			/CLEAR END FLAG
	TAD	(SYN
	DPTAC DPCTF		/START BY SENDING ONE SYNCH
	  NOP
	NL0
>/END OF IFNZRO FTDP01

IFZERO FTDP01 <
	DPSCSI			/CLEAR SYNCHRONOUS INTERFACE
	TAD	(5400		/TERMINAL READY; INTERFACE ENABLE; TRANS REQ
	DPSLCC			/SET INITIAL CONDITIONS
	NL0
		Z=CNKFLD^1100
	TAD	(Z
	DPSLFL
	NL0
>/END OF IFZERO FTDP01

	CDFINS
	TAD	(SYNBUF-1
	DCA I	(T10CA		/SET UP BUFFER TO SEND SYNCHS
	TAD	(-4
	DCA I	(T10WC		/SET UP WC TO SEND SYNCHS
	DCA I	(T10NCA		/SEND SYNCH'S WHEN DONE
	CDFCNK
	DCA	CHOCNT		/NO CHARS SEND YET
	TAD	(-SYNBUF-3
	DCA	T10LCA
IFZERO FTDP01 <	DPSGTT	>	/ENABLE DP8E TRANSMITTER
	JMS	SCHK77		/ENABLE RECEIVER

	TAD	(-CHKDPT
	DCA	INISEC		/TIME FOR INTERFACE TO COME ALIVE

SCHK33,

IFNZRO FTDP01 <
	DPSSR			/SKIP ON DATASET READY
	  JMP	SCHK35		/NOT READY SO WAIT
>/END OF IFNZRO FTDP01

IFZERO FTDP01 <
	Z=CNKFLD^40
	DPSRS1			/GET RECEIVE FIELD SELECT
	AND	(0340
	TAD	(-Z
	SZA			/IS IT OK ?
	  JMS	SCHK39
	DPSRS2			/GET TRANSMIT FIELD SELECT
	AND	(0340
	TAD	(-Z
	SZA			/IS IT OK ?
	  JMS	SCHK39

	DPSRS1			/GET STATUS 1
	AND	(0020		/MASK FOR MODEM READY
	SNA CLA
	  JMP	SCHK35

	DPSRS2
	AND	(5400		/MASK FOR TERMINAL READY,CARRIER, &CLEAR TO SEND
	TAD	(-5400
	SZA CLA
	  JMP	SCHK35		/WAIT A WHILE

>/END OF IFZERO FTDP01
	JMS	SCHK75
	NOP
	NL0			/CHECK RECEIVER
	JMS	SCHK66		/SERVICE TRANSMITTER
	TAD	CHOCNT
	TAD	(40		/SEE HOW MANY CHARS SENT
	SPA CLA
	  JMP	SCHK40		/BRANCH IF XMTTER GOING
SCHK35,	JMS	SCHK98		/SEE IF CLOCK HAS TIMED OUT
	  JMP	SCHK33		/NOT YET

/HERE IF TIMER GOES OFF WHILE TRYING TO INITIALIZE DP01 OR DP8E
	NL0

IFNZRO FTDP01 <
	DPSSR	
	JMP	SCHK36		/BRANCH IF DATASET NOT READY
	NLM1	
	DCA	CHKST1		/REENABLE SCHK36
	JMP	SCHK37
SCHK36,	NLM1	
	DCA	CHK6		/REENABLE SCHK37
	ISZ	CHKST1
	JMP	SCHK31		/IF HAVE ALREADY COMPLAINED DONE
	JMS	INBTYP		/TYPE CR/LF/%
	JMS	INDTYP		/TYPE DP01
	JMS	INLTYP
	"D;"A;"T;"A;"S;"E;"T;" ;"N;"O;"T;" ;"R;"E;"A;"D;4000+"Y
	JMP	SCHK31		/KEEP TRYING
CHKST1,	0			/COUNTED WHEN MODEM NOT READY

>/END OF IFNZRO FTDP01

IFZERO FTDP01 <
	DPSRS1
	AND	(0020
	NEGATE			/GET MODEM READY BIT
	TAD	CHKST1
	SZA CLA
	  JMP	SCHK36		/IF STATUS CHANGED DISPLAY IT
	DPSRS2
	AND	(5400
	NEGATE			/GET STS2 BITS
	TAD	CHKST2
	SZA CLA	
	JMP	SCHK36
	TAD	CHKST1
	SNA CLA	
	JMP	SCHK31		/KEEP ONWAITING
	TAD	CHKST2
	TAD	(-5400		/CHECK OTHER STS WORD
	SZA CLA	
	JMP	SCHK31
	JMP	SCHK37

	PAGE
SCHK36,	NLM1	
	DCA	CHK6		/ENABLE SCHK37
	DPSRS1	
	AND	(0020
	DCA	CHKST1		/GET 1ST STATUS
	DPSRS2	
	AND	(5400
	DCA	CHKST2		/GET 2ND STATUS
	TAD	CHKST1
	SZA CLA	
	JMP	SCHKX1
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"M;"O;"D;"E;"M;" ;"N;"O;"T;" ;"R;"E;"A;"D;4000+"Y
SCHKX1,	NL4000	
	AND	CHKST2		/MASK FOR CARRIER
	SZA CLA	
	JMP	SCHKX2
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"N;"O;" ;"C;"A;"R;"R;"I;"E;4000+"R
SCHKX2,	TAD	(1000
	AND	CHKST2		/MASK FOR TERMINAL READY
	SZA CLA	
	JMP	SCHKX3
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"T;"E;"R;"M;" ;"N;"O;"T;" ;"R;"E;"A;"D;4000+"Y
SCHKX3,	TAD	(0400
	AND	CHKST2		/MASK FOR CLEAR TO SEND
	SZA CLA	
	JMP	SCHKX4
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"N;"O;"T;" ;"C;"L;"E;"A;"R;" ;"T;"O;" ;"S;"E;"N;4000+"D
SCHKX4,	JMP	SCHK31		/KEEP TRYING
CHKST1,	0
CHKST2,	0
>/END OF IFZERO FTDP01
SCHK37,	ISZ	CHK6		/HAVE WE COMPLAINED ONCE ALREADY ?
	  JMP	SCHK31		/YES SO JUST KEEP TRYING
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"X;"M;"T;" ;"N;"O;"T;" ;"R;"E;"A;"D;4000+"Y
	JMP	SCHK31

	PAGE
	LISTOG	FTDP8E
IFZERO FTDP01 <
/HERE BECAUSE WC OR CA DOESN'T LOOK RIGHT AT END OF XMISSION
	0			/PUT AC HERE WHEN CALLED
SCHK38,	0
	CDFCNK
	DCA	SCHK38-1	/SAVE AC CONTENTS
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"W;"C;" ;"O;"R;" ;"C;"A;" ;"W;"R;"O;"N;4000+"G
	JMP	SCHK30-1	/TRY ALL OVER AGAIN IF HE CONTINUES

/HERE BECAUSE FIELD SELECT FAILED
SCHK39,	0
	DCA	CHK3
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"F;"I;"E;"L;"D;" ;"S;"E;"L;"E;"C;"T;" ;"F;"A;"I;"L;"E;4000+"D
	TAD	CHK3		/GET BAD VALUE-CNKFLD
	TAD	(CNKFLD		/LEAVES ONLY BAD VALUE
	JMS	INIOCT		/TYPE IT
	TAD	(257		/ASCII /
	JMS	INITY8
	NL0
	TAD	(CNKFLD		/GET RIGHT VALUE
	JMS	INIOCT		/AND TYPE IT
	JMP	SCHK30-1	/TRY ALL OVER AGAIN IF HE INSISTS


/HERE WHEN SPECIAL CHAR DETECT FAILS
SCHK57,	0
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"C;"H;"A;"R;" ;"D;"E;"T;"E;"C;"T;" ;"S;"K;"I;"P;" ;"F;"A;"I;"L;"E;4000+"D
	JMP	SCHK30-1	/TRY AGAIN IF HE INSISTS

SCHK55,	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"R;"E;"A;"D;" ;"C;"H;"A;"R;" ;"D;"E;"T;"E;"C;"T;"E;"D;4240
	TAD	CHK1
	JMS	INIOCT
	NL0
	JMS	INLTYP
	" ;"R;"I;"G;"H;"T;4000+"=
	NL3
	JMS	INIOCT
	JMP	SCHK30-1	/TRY AGAIN IF HE INSISTS

	PAGE
>/END OF IFZERO FTDP01
	LISTOG	FTDP8E
/	***********************************************************
/	***********************************************************
/	***							***
/	***	SYSCHK FOR SYNCHRONOUS INTERFACE - RECEIVE	***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO SEE WHAT WE ARE RECEIVING
/ BE SURE STUFF IS ALSO GOING OUT(TO EXECISE LOOPBACK, CROSSTALK, ETC.)
SCHK40,	NLM1	
	DCA	CHK6		/FLAG 1ST TIME THROUGH XMT TEST
	TAD	(-CHKDPT
	DCA	INISEC		/TIME TO COME ALIVE

SCHK42,	JMS	SCHK66		/CHECK SYNCHRONOUS TRANSMITTER

	JMS	SCHK75		/GET NEXT CHAR FROM RECEIVER
	  JMP	SCHK45		/NONE FOR A WHILE
	DCA	RCVQUE		/SAVE CHAR
	NLM1
	DCA	CHK5		/FLAG FOR BASIC REC TEST
	TAD	RCVQUE
	TAD	(-SYN
	SZA CLA			/WAS CHAR A SYNC ?
	  JMP	SCHK44		/NO SO COMPLAIN

IFZERO FTDP01 <
	DPSSCD			/SKIP ON SPECIAL CHAR DETECT
	  JMS	SCHK57		/SHOULD HAVE SKIPPED
	DPSSCD			/SKIP ABOVE SHOULD HAVE CLEARED FLAG
	SKP CLA
	  JMS	SCHK57		/IT DIDN'T SO COMPLAIN
	DPSRCD			/GET SPECIAL CHAR INDEX
	DCA	CHK1
	NLM3			/SHOULD BE 3
	TAD	CHK1
	SZA CLA
	  JMP	SCHK55		/IT WASN'T ?
>/END OF IFZERO FTDP01

	JMP	SCHK50		/YES SO ON TO NEXT TEST

SCHK44,	TAD	RCVQUE
	NEGATE
	TAD	CHK4
	SNA CLA			/HAVE WE DISPLAYED THIS ONE ALREADY ?
	  JMP	SCHK32		/YES SO DON'T SHOW AGAIN
	TAD	RCVQUE
	DCA	CHK4
	JMS	INBTYP		/TYPE CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"R;"C;"V;"';"D;4000+" 
	TAD	RCVQUE
	JMS	INIOCT
	JMP	SCHK32		/LOOP ON ERROR

SCHK45,	JMS	SCHK98		/CHECK CLOCK
	  JMP	SCHK42		/KEEP WAITING
	NLM1
	DCA	CHK4		/FLAG TO DISPLAY ANY RECEIVED CHAR
	ISZ	CHK5
	  JMP	SCHK32		/DON'T COMPLAIN EVERY TIME
	JMS	INBTYP		/TYPE A CR/LF/%
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"N;"O;"T;" ;"R;"E;"C;"E;"I;"V;"I;"N;4000+"G
	JMP	SCHK32

/**DEBUG	PAGE
/HERE TO CHECK SYNCHRONOUS TRANSMITTER
/ IF T10WC HAS EXPIRED USE T10NWC&T10NCA TO REFRESH IT
/ ELSE SEND SYNCH'S
SCHK66,	0

IFNZRO FTDP01 <
	DPSTF	
	SKP CLA	
	JMP I	SCHK66		/CHECK FOR XMT FLAG
	CDFINS
	ISZ I	(T10CA
	TAD I	(T10CA
	DCA	CHK1		/GET CURRENT ADDRESS
	CDFCNK
	TAD I	CHK1
	DPTAC DPCTF
	NOP			/SEND NEXT CHAR
	NL0	
	DPSTF	
	JMS	SCHK56		/CHECK FLAG CLEARED
	CDFINS
	ISZ I	(T10WC
	JMP	SCHK69		/CHECK FOR OVERFLOW
>/END OF IFNZRO FTDP01

IFZERO FTDP01 <
	DPSSTO	
	JMP I	SCHK66		/CHECK DP8E FOR WC OVERFLOW
	DPSSTO	
	SKP CLA	
	JMS	SCHK56		/BE SURE FLAG CLEARED
	CDFINS	
	TAD I	(T10CA
	TAD	T10LCA		/CHECK CA
	SZA
	  JMS	SCHK38		/BE SURE IT IS KOSHER
	TAD I	(T10WC
	SZA
	  JMS	SCHK38		/CHECK WC ALSO
>/END OF IFZERO FTDP01

	TAD I	(T10NCA
	SNA	
	JMP	SCHK67
	DCA I	(T10CA
	DCA I	(T10NCA
	TAD I	(T10NWC
	DCA I	(T10WC
	JMP	SCHK68
SCHK67,	TAD	(SYNBUF-1
	DCA I	(T10CA		/NO MSG SO SEND SYNCS
	NLM1	
	DCA I	(T10WC
SCHK68,	TAD I	(T10WC
	TAD	CHOCNT
	DCA	CHOCNT
IFZERO FTDP01 <
	TAD I	(T10CA
	NEGATE	
	TAD I	(T10WC
	DCA	T10LCA
	DPSGTT
>/END OF IFZERO FTDP01
SCHK69,	CDFCNK	
	JMP I	SCHK66		/RETURN

CHOCNT,	0
T10LCA,	0			/EXPECTED T10CA WHEN DONE

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***	CHECK TO SEE IF SYN LINK IS LOOPED BACK		***
/	***							***
/	***********************************************************
/	***********************************************************

SCHK50,	TAD	(-CHKDPT
	DCA	INISEC		/TIME TO HEAR LOOPBACK

SCHK51,	TAD	(SCHKRD
	DCA	CHK2		/POINTER TO WATCH RECEIVE

SCHK52,	CDFINS
	TAD	(SCHKRD-5
	DCA I	(T10NCA		/SET UP JUNK TO GO
	TAD	(-7
	DCA I	(T10NWC		/WC FOR JUNK
	CDFCNK

	JMS	SCHK66		/SERVICE TRANSMITTER

	JMS	SCHK75		/TRY TO GET ANOTHER CHAR FROM THE SYN RECEIVER
	  JMP	SCHK54		/NOT READY YET
	NEGATE
	TAD I	CHK2
	SZA CLA			/IS THIS ONE OF JUNK CHARS ?
	  JMP	SCHK51		/NO
	ISZ	CHK2		/ADVANCE STATE
	TAD	CHK2
	TAD	(-SCHKRD-3
	SZA CLA
	  JMP	SCHK54		/STILL NOT FATAL
IFNZRO FTLBACK <JMP	SCHK60	>	/MODEM IS IN LOOPBACK MODE

SCHK53,	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	INLTYP
	"I;"S
IFNZRO FTLBACK < " ;"N;"O;"T >
	" ;"I;"N;" ;"L;"O;"O;"P;"B;"A;"C;"K;" ;"M;"O;"D;4000+"E
	JMP	SCHK30-1	/RECHECK ALL SYNCHRONOUS STUFF

SCHK54,	JMS	SCHK98
	  JMP	SCHK52		/CHECK CLOCK
IFNZRO FTLBACK < JMP SCHK53 >	/MUST BE FOR LOOPBACK TEST

SCHK60,	TAD	HERTZF
	TAD	(-36
	DCA	INISEC		/HALF SECOND
	DCA	CHOCNT		/SO WE CAN COUNT CHARS
	JMS	SCHK75		/CHECK RECEIVER
	JMS	SCHK66		/SERVICE TRANSMITER
	NL0	
	JMS	SCHK98
	JMP	.-4
IFZERO FTDP01 <
	TAD	CHOCNT
	TAD	(207
	SPA CLA	
	JMP	SCHK61
	CDFINS
	TAD	(NOP
	DCA	INTN21
	CDFCNK
SCHK61,
>/END OF IFZERO FTDP01
	TAD	CHOCNT
	TAD	(1200		/COMPARE TO 640.
	SPA CLA
	DCA	SCHK62
	JMP	SCHK70

/JUNK CHARACTERS TO SEND TO 10
/ NOTE THAT ONLY BITS USED ARE BITS WE KNOW DP01/DP8E CAN SEE
	SYN	;	SYN	;	SYN	;	SYN
SCHKRD,	206;	202;	220
/JMS HERE IF CAN'T CLEAR FLAG ON DP01 OR DP8E
SCHK56,	0
	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INDTYP		/TYPE DP8E OR DP01
	JMS	SCHK93		/TYPE FLAG WON'T CLEAR
	JMP	SCHK30-1	/TRY AGAIN

	PAGE
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CHECK TO BE SURE 10 ANSWERS		***
/	***							***
/	***********************************************************
/	***********************************************************

/HERE TO SEND A START(REP) MESSAGE TO 10 AND AWAIT A STACK(RACK)

SCHK70,	TAD	(-CHKDPT
	DCA	INISEC		/TIME TO GET A STACK(RACK)


/SEND START MSG
	CDFINS
	TAD	(-10-NUMSYN
	DCA I	(T10NWC
	TAD	(SYNBUF-1
	DCA I	(T10NCA
	CDFCNK

SCHK71,	TAD	(JMP I SCHK73+1
	DCA	SCHK73

SCHK72,	JMS	SCHK66		/CHECK TRANSMITTER
	JMS	SCHK75
	JMP	SCHK74		/GET NEXT CHAR FROM RECEIVER
SCHK73,	7402			/WILL BE A JMP I SCHK73+#


	CHKENQ;	CHKSTK;	CHKFLL
	SCHK62
SCHK62,	JMP	SCHK80
	JMS	INBTYP
	JMS	INDTYP
	JMS	INLTYP
	"G;"T;" ;"9;"6;"0;"0;" ;"B;"A;"U;4000+"D
	JMP	SCHK80
SCHK74,	JMS	SCHK98
	JMP	SCHK72		/CHECK CLOCK

	JMS	INBTYP		/TYPE CR/LF/%
	JMS	INLTYP
	"N;"O;" ;"R;"E;"S;"P;"O;"N;"S;"E;" ;"T;"O
	" ;"S;"T;"A;"R;4000+"T 
	JMP	SCHK30		/KEEP TRYING

CHKSTK,	TAD	(ENQ-STACK
CHKENQ,	TAD	(-ENQ
CHKFIL,	SZA CLA
	  JMP	SCHK71
	ISZ	SCHK73
	JMP	SCHK74
CHKFLL,	AND	(077		/STRIP SELECT AND QSYNC BITS
	JMP	CHKFIL

	PAGE
/HERE TO ACCUMULATE A CRC IN CHK6 & CHK7
SCHK78,	0
	DCA	CHK1
	TAD	(-10
	DCA	CHK2
	TAD	CHK6
	CLL RAR
	DCA	CHK6
	SZL	
	TAD	(0400
	TAD	CHK7
	CLL RAR	
	DCA	CHK7
	SZL	
	JMS	SCHKCC
	TAD	CHK1
	CLL RAR
	DCA	CHK1
	SZL	
	JMS	SCHKCC
	ISZ	CHK2
	JMP	SCHK78+4
	JMP I	SCHK78

SCHKCC,	0
	TAD	CHK7
	CLL RAR
	CML
	RAL	
	DCA	CHK7
	TAD	CHK6
	AND	(240
	CMA IAC
	CLL RAL
	TAD	CHK6
	TAD	(240
	DCA	CHK6
	JMP I	SCHKCC
/HERE TO GET THE NEXT CHAR FROM THE SYNCHRONOUS RECEIVER
/ CALL	JMS	SCHK75
/	RETURN		/IF NOTHING HAPPENING
/	RETURN WITH RECEIVED CHAR IN AC
SCHK75,	0

IFNZRO FTDP01 <			/CODE FOR DP01
	DPSRF
	SKP
	JMP I	SCHK75		/CHECK RECEIVE FLAG
	DPRRB			/GET CHAR
	DPSRF
	JMS	SCHK56		/BE SURE WE CLEARED FLAG
>/END OF IFNZRO FTDP01

IFZERO FTDP01 <			/CODE FOR DP8E
	DPSSRO
	  JMP I	SCHK75		/CHECK FOR FLAG
	DPSSRO
	SKP
	JMS	SCHK56		/FLAG IS SUPPOSED TO HAVE CLEARED
	CDFINS
	TAD I	(F10WC		/CHECK TO BE SURE HDW MEANT IT
	SZA
	  JMS	SCHK38		/COMPLAIN WC ISN'T RIGHT
	TAD I	(F10CA
	TAD	(-RCVQUE
	SZA
	  JMS	SCHK38
	JMS	SCHK76		/REENABLE RECEIVER
	TAD	RCVQUE		/GET CHAR
>/END OF IFZERO FTDP01

	ISZ	SCHK75
	JMP I	SCHK75		/SKIP RETURN WITH CHAR

IFZERO FTDP01 <
/HERE TO ENABLE DP8E RECEIVER
SCHK76,	0
	CDFINS	
	NLM1	
	DCA I	(F10WC		/RESET RECEIVE WC
	TAD	(RCVQUE-1
	DCA I	(F10CA
	CDFCNK			/RESET RECEIVE CA
	DPSGRR			/REENABLE RECEIVER
	JMP I	SCHK76
>/END OF IFZERO FTDP01

/HERE TO INITIALIZE THE SYNCHRONOUS RECEIVER
/ CALL	JMS	SCHK77
/	RETURN
SCHK77,	0

IFNZRO FTDP01 <	DPCRA	>	/CLEAR RECEIVE ACTIVE

IFZERO FTDP01 <
	DPSCSD			/CLEAR SYNC DETECT
	JMS	SCHK76		/RESET WC & CA
>/END OF IFZERO FTDP01

	JMP I	SCHK77

/	SUBROUTINE TO BUILD BEGINNING OF OUTPUT BUFFERS
SCHKA1,	0
	TAD	(SYNCHS-1
	DCA	CHAUTO
	TAD	(-20		/16
	DCA	CHK6
SCHKA2,	TAD	(SYN
	DCA I	CHAUTO
	ISZ	CHK6
	  JMP	SCHKA2
	TAD	(STARTC-1	/BEGINNING OF CONTROL
	DCA	CHAUTO
	TAD	(CTLBUF-1	/WHERE IT HAS TO GO
	DCA	CHAUTO-1
	TAD	(-10-6		/BOTH CTL AND 1ST DATA BUFFER
	JMS	CHCOPY		/COPY IT
	TAD	(STARTD-1
	DCA	CHAUTO
	TAD	(T10BF2-1
	DCA	CHAUTO-1
	TAD	(-6
	JMS	CHCOPY
	TAD	(T10LST-1
	DCA	CHAUTO-1
	TAD	(STARTD-1
	DCA	CHAUTO
	TAD	(-6
	JMS	CHCOPY
	JMP I	SCHKA1
CHCOPY,	0
	DCA	CHK6
CHCOPL,	TAD I	CHAUTO
	DCA I	CHAUTO-1
	ISZ	CHK6
	  JMP	CHCOPL
	JMP I	CHCOPY

	PAGE
SCHK80,
	XISTOG	PDP8E
IFZERO PDP8E <
/	***********************************************************
/	***********************************************************
/	***							***
/	***		CHECK KG8E IS OK			***
/	***							***
/	***********************************************************
/	***********************************************************

	CDFCNK			/SET RIGHT DATA FIELD
	NL0			/CLEAR AC
	TAD	(0100		/MASK TO SET 16-BIT CRC+BCC
	BCCLCL			/LOAD CONTROL REGISTER
	BCCCLR			/CLEAR CRC ACCUMLUATION
	NL0			/CLEAR AC
	DCA	CHK6		/CLEAR CRC ACCUMULATION
	DCA	CHK7		/ DITTO
	DCA	CHK5		/FIRST CHAR TO ADD TO MESSAGE
SCHK81,	TAD	CHK5		/GET NEXT CHAR TO COMPUTE CRC ON
	JMS	SCHK78		/GO CALCULATE CRC
	TAD	CHK5		/GET CHARACTER
	BCCGEN			/MAKE KG8E COMPUTE CRC ALSO
	CLA			/CLEAR OUT AC
	BCCRDH			/GET HIGH ORDER PART OF CRC
	NEGATE
	TAD	CHK6
	SZA CLA			/CHECK FOR CALCULATION OK SO FAR
	  JMP	SCHK83		/NO GO
	BCCRDL			/GET LOW ORDER PART OF CRC
	NEGATE
	TAD	CHK7		/ADD CALCULATED VALUE
	SZA CLA
	  JMP	SCHK83		/LOST ON LOW ORDER CHAR
	ISZ	CHK5
	TAD	CHK5
	AND	(0400		/MASK FOR OVERFLOW
	SNA CLA			/HAVE WE DONE ALL 256 POSSIBLE CHARS ?
	  JMP	SCHK81		/NOT YET
/HERE BECAUSE DC72 HAS A WORKING KG8E
	CDFINS			/POINT TO INSTRUCTION FIELD
	TAD	(BCCGEN		/CHANGE CRCALC TO USE KG8E
	DCA I	(CRCALC+1
	TAD	(DCA TEMP1
	DCA I	(CRCALC+2
	TAD	(BCCRDL
	DCA I	(CRCALC+3
	TAD	(DCA CRC2
	DCA I	(CRCALC+4
	TAD	(BCCRDH
	DCA I	(CRCALC+5
	TAD	(DCA CRC1
	DCA I	(CRCALC+6
	TAD I	(CRCRET
	DCA I	(CRCALC+7
	TAD	(BCCCLR		/CHANGE DCA CRC TO BCCCLR
	DCA I	(CRCXI1
	TAD	(BCCCLR
	DCA I	(CRCXI2
	TAD	(BCCCLR
	DCA I	(CRCXI3
	TAD	(BCCCLR
	DCA I	(CRCXI4
	TAD	(BCCCLR
	DCA I	(CRCXI5
	TAD	(FIRCNK-1000	/CHANGE START OF CHUNKS (DON'T NEED BCC TABLE)
	DCA I	(FIRADR
	JMP	SCHK90

/HERE BECAUSE KG8E NOT INSTALLED OR NOT WORKING
SCHK83,	JMS	INBTYP	/TYPE CR/LF/%/%
	JMS	INLTYP
	"K;"G;"8;"E;" ;"N;"O;"T;" ;"W;"O;"R;"K;"I;"N;4000+"G
	JMP	SCHK90

	PAGE
>/END OF IFZERO PDP8E
	XISTOG	PDP8E
/HERE TO SEE IF LINE PRINTER IS LS8E(CENTRONICS) OR LE8(LP02)

SCHK90,	CDFCNK			/RESET NORMAL DATA FIELD
	LISTOG	LPTN
	IFNZRO LPTN <
	LPTCLF			/CLEAR LPT FLAG
	LPTSKF			/IS FLAG STILL UP ?
	  JMP	SCHK92		/NO SO OK
SCHK91,	JMS	INFTYP		/TYPE CR/LF/?
	JMS	INLTYP
	"L;"P;"T;4240
	JMS	SCHK93		/TYPE FLAG WON'T CLEAR
	HLT
	JMP	SCHK90		/TRY AGAIN IF HE CONTINUES

SCHK92,	LPTSTF			/SET THE FLAG IF THIS IS AN LS8E
	LPTSKF			/SKIP ON FLAG
	  JMP	SCHK96		/THIS IS AN LE8=LP08
/CENTRONICS PRINTER SO ADJUST TIMEOUTS
	LPTCLF
	LPTSKF
	  SKP			/GOOD - WE CLEARED FLAG
	JMP	SCHK91		/FATAL - CAN'T CLEAR FLAG
	CDFINS			/WE ARE CHANGING DATA IN FIRST FIELD
	TAD	(LPTSIE		/USE THIS TO CLEAR INTERRUPT ENABLE
	DCA I	(LPXXCE		/SET IN LPTFIN
	TAD	(NOP
	DCA I	(LPXXSE
	TAD	(NOP
	DCA I	(LPXYSE
	TAD	(-200		/TWO SECONDS ON A FORM FEED
	DCA I	(LPTTFF
	TAD	(-100		/ONE SECOND ON RANDOM CHAR
	DCA I	(LPTTCH
	CDFCNK			/BACK TO NORMAL DATA FIELD

>/END OF IFNZRO LPTN
	LISTOG	LPTN

SCHK96,

	TAD	(377		/START WITH THE LAST ENTRY IN THE TABLE
	DCA	CHK3
	DCA	CHK6		/CLEAR HALF OF CRC
	DCA	CHK7		/CLEAR REST OF CRC
	TAD	CHK3		/GET CHAR TO MAKE CRC FOR
	JMS	SCHK78		/GO COMPUTE THE CRC FOR IT
	TAD	CHK3
	TAD	(CRCTAB
	DCA	CHK1
	TAD	CHK7
	DCA I	CHK1
	TAD	CHK1
	TAD	(400
	DCA	CHK1
	TAD	CHK6
	DCA I	CHK1
	NLM1
	TAD	CHK3
	SMA			/HAVE WE FILLED THE TABLE ?
	  JMP	SCHK96+1	/NOT YET SO KEEP ON
	NL0

	JMP	SCHK94

SCHK93,	0
	JMS	INLTYP
	"F;"L;"A;"G;" ;"W;"O;"N;"';"T;" ;"C;"L;"E;"A;4000+"R
	JMP I	SCHK93

	PAGE
/HERE WHEN DONE CHECKING SYSTEM
SCHK94,	CDFINS

	NL0
	TAD	(F10TCH-1	/ADDRESS OF TEST CHAR TABLE
	DCA	AUTO1

/FILL OUT THE SPECIAL CHAR TABLE

	TAD	(SOH		/START OF A NUMBERED MESSAGE
	DCA I	AUTO1
	TAD	(ENQ
	DCA I	AUTO1
	TAD	(ENQ
	DCA I	AUTO1		/PAD OUT TABLE
	TAD	(ENQ
	DCA I	AUTO1		/PAD OUT TABLE

/HERE TO BUILD NODE ID MESSAGE
	CDFCNK			/POINT TO DATA FIELD
	DCA	CHK6		/INITIALIZE THE CRC CALCULATION
	DCA	CHK7
	TAD	(NCLNID		/ADDRESS OF MESSAGE
	DCA	AUTO1		/SET UP AUTO INDEX REGISTER
	DCA I	(NCLNID		/CLEAR COUNTER
	NL6			/NCL-NODE-ID MSG TYPE IS 6
	JMS	SCHK95		/PUT INTO MSG
	JMS	SCHK95		/FIELD FOR #
	JMS	SCHK95		/FIELD FOR #
	Z=OURNNM&177		/ONLY 7 BITS
	TAD	(Z		/OUR NODE NUMBER
	JMS	SCHK95		/PUT INTO NODE ID MSG
	TAD	(OURID		/POINTER TO NAME FIELD
	DCA	CHK3		/SAVE POINTER
SCHKNI,	TAD	CHK3
	IAC
	DCA	CHK1
	TAD I	CHK1
	AND	(200
	SNA CLA
	  JMP	SCHKSI		/PUT SOFTWARE ID IN NOW
	TAD I	CHK3		/GET NEXT CHAR
	AND	(177		/STRIP EXTRA BITS
	TAD	(200		/FLAG FOR EXTENSIBLE FIELD
	JMS	SCHK95		/PUT INTO THE MESSAGE
	ISZ	CHK3		/ADVANCE CHAR POINTER
	JMP	SCHKNI		/AND BACK FOR MORE
SCHKSI,	TAD I	CHK3		/GET LAST CHAR OF NAME
	AND	(177		/STRIP EXTRA BITS
	JMS	SCHK95		/AND PUT INTO NODEID
	TAD	(SID-1		/POINT TO SOFTWARE ID
	DCA	CHAUTO		/SAVE ADDRESS OF COUNT
	TAD I	CHAUTO		/GET COUNT (NEG NO OF CHARACTERS)
	DCA	CHK3		/STORE FOR LOOP CONTROL
SCHSID,	TAD I	CHAUTO		/GET NEXT CHARACTER
	JMS	SCHK95		/PUT CHARACTER INTO MESSAGE
	ISZ	CHK3		/TEST IF LAST
	  JMP	SCHSID		/ELSE GO BACK FOR MORE
	TAD	CHK7		/GET HALF OF BCC
	DCA I	AUTO1		/PUT AFTER MSG
	TAD	CHK6		/GET REST OF BCC
	DCA I	AUTO1		/PUT AFTER MSG ALSO
	JMP	SCHK97
SCHK95,	0
	DCA	CHK1		/HOLD CHAR A SEC
	TAD	CHK1		/ GET IT AGAIN
	DCA I	AUTO1		/PUT NEXT CHAR INTO THE MESSAGE
	TAD	CHK1		/GET CHAR AGAIN
	JMS	SCHK78		/INCLUDE IN BCC
	ISZ I	(NCLNID		/COUNT CHAR
	JMP I	SCHK95
SCHK97,
	CDFINS

	NL0			/DEFENSIVE CODE
	DCA I	(INICIF		/CHANGE CIFCNK TO AND 0
IFZERO PDP8E <TAD	(CAF>	/MAKE INTO CLEAR ALL FLAGS ON PDP8E
	DCA I	(INIJMP		/CHANGE JMP I (SYSCHK TO 0
	CDFCNK			/SET NORMAL CHUNK FIELD
	CIFINS			/SET NORMAL INSTRUCTION FIELD
	JMP I	(INIJMP		/RETURN TO INITIALIZATION
/HERE TO SEE IF CLOCK HAS TIMED OUT
/ CALL	JMS	SCHK98
/	RETURN		/IF INISEC HAS NOT TIMED OUT
/	RETURN		/IF INISEC WENT TO ZERO
SCHK98,	0
	NL0
	CLKSCF			/SKIP ON CLOCK FLAG
	  JMP I	SCHK98		/HASN'T TICKED

IFZERO PDP8E <			/BECAUSE 8E CLOCKS TICK TWICE AS FAST
	ISZ	INISEC+1	/ COUNT INISEC+1 EVERY TICK
	  NOP			/ AND INISEC ON EVERY OTHER TICK
	NL1
	AND	INISEC+1
	SNA CLA
	  JMP I	SCHK98
>/END OF IFZERO PDP8E

	ISZ	INISEC		/CLOCK HAS TICKED - DID TIMER EXPIRE ?
	  JMP I	SCHK98		/NO SO JUSTRETURN
	ISZ	SCHK98		/YES SO SKIP RETURN
	JMP I	SCHK98

/TIMERS FOR SYSCHK CODE
INISEC,	0
	0

SID,	0			/LENGTH (MINUS)
	SIDTXT
SIDEND,
	*SID
	ZZ=SID+1-SIDEND
	ZZ
	PAGE
/HERE TO TYPE A MESSAGE WHILE IN THE SYSCHK CODE
/ CALL	JMS	INITYP		/WITH MSG ADR-1 IN AC
/	RETURN			/AFTER MSG IS TYPED
INITYP,	0
	DCA	AUTO1		/SAVE MSG ADR IN AUTOINDEX REGISTER
INITY1,	TAD I	AUTO1		/GET NEXT CHAR FROM MSG
	JMS	INITY8
	SMA CLA			/IS MESSAGE FINISHED ?
	  JMP	INITY1
	JMP I	INITYP
INITY8,	0
	DCA	INICHR		/SAVE CHAR TO TYPE
	TAD	INICHR
	AND	(0177		/STRIP PARITY
	TAD	(-40
	SPA CLA			/IS CHAR A CR/LF(MAYBE) ?
	  DCA	INIFLG		/YES SO TURN OFF ^O IF IT WAS ON
	TAD	INIFLG		/GET CONTROL O FLAG
	SZA CLA			/IF IT IS ON DON'T TYPE CHAR
	  JMP	INITY9		/IT WAS ON
	TAD	INICHR
	CTYTLS
	CTYTSF
	JMP	.-1
	CTYTCF			/CLEAR FLAG

	CTYKSF			/SKIP ON KEYBOARD FLAG
	  JMP	INITY9
	CTYKRB			/GET CHAR
	NLM1
	DCA	INIFLG
INITY9,	NL0
	TAD	INICHR		/GET CHAR AGAIN
	JMP I	INITY8
INIFLG,	0			/SET NONZERO IF USER TYPES IN WHILE SYSCHK IS TYPING OUT
				/ WILL FLUSH TTY OUTPUT TO NEXT CR/LF
INICHR,	0			/CHAR TO TYPE
INITMP,	0			/LOCATION TO GO INDIRECT ON TO GET PARITY FOR CHAR

INIOCT,	0
	DCA	CHK3
	TAD	CHK3
	AND	(7000
	SZA CLA
	  JMP	INIOC4		/PRINT ALL FOUR DIGITS
	TAD	CHK3
	AND	(0700
	SZA CLA
	  JMP	INIOC3		/PRINT THREE DIGITS ONLY
	TAD	CHK3
	AND	(0070
	SZA CLA
	  JMP	INIOC2		/PRINT TWO DIGITS ONLY
	JMP	INIOC1		/ONLY ONE DIGIT
INIOC4,	TAD	CHK3
	RTL
	RTL
	JMS	INITYO
INIOC3,	TAD	CHK3
	RTR
	RTR
	RTR
	JMS	INITYO
INIOC2,	TAD	CHK3
	RTR
	RAR
	JMS	INITYO
INIOC1,	TAD	CHK3
	JMS	INITYO
	JMP I	INIOCT

INITYO,	0
	AND	(0007
	TAD	(0060		/CONVERT TO OCTAL
	JMS	INITY8		/TYPE CHAR
	NL0
	JMP I	INITYO

/ROUTINE TO TYPE INLINE MESSAGE
INLTYP,	0	
	NL0
INLTY2,	TAD I	INLTYP
	JMS	INITY8
	ISZ	INLTYP		/TYPE NEXT CHAR
	SMA CLA
	JMP	INLTY2
	JMP I	INLTYP

/HERE TO TYPE CR/LF??
INFTYP,	0
	JMS	INLTYP
	FATMSG
	4207			/FINAL BELL
	JMP I	INFTYP

/HERE TO TYPE CR/LF/%
INBTYP,	0
	JMS	INLTYP
	215;215;215;12;207;207;"%;4000+"%
	JMP I	INBTYP

/HERE TO TYPE DP8E OR DP01
INDTYP,	0
	JMS	INLTYP
IFNZRO FTDP01 < "D;"P;"0;"1;4240 >
IFZERO FTDP01 <	"D;"P;"8;"E;4240 >
	JMP I	INDTYP
FIELD	0

*DC72		/STARTING ADDRESS FOR LOADER

$
