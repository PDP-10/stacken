TITLE	CUSPSW - PASSWORD PROCESSING AND ENCRYPTION ALGORITHMS

	SEARCH	ACTPRM
	MODULE	(CUSCRP)

	ENTRY	ENCRYP,	ENCRYN,	LENPSW,	SETPSW,	CHKPSW

CURALG::EXP	3		;CURRENT ENCRYPTION ALGORITHM INDEX
;LENPSW - DETERMINE AND VALIDATE PASSWORD LENGTH
; CALL:	MOVE	S1, ADDRESS OF PROFILE
;	MOVE	S2, ADDRESS OF PASSWORD
;	PUSHJ	P,LENPSW
;
; TRUE RETURN:	LENGTH OK
; FALSE RETURN:	LENGTH LESS THAN MINIMUM REQUIRED
;
; ON EITHER RETURN, S1 CONTAINS THE MINIMUM REQURED LENGTH

LENPSW::LOAD	TF,.AEREQ(S1),AE.PWL ;GET MINIMUM LENGTH REQUIRED
	JUMPE	TF,.RETT	;RETURN IF ZERO
	PUSHJ	P,.SAVE2	;SAVE P1
	DMOVE	P1,S1		;COPY ARGS
	HRLI	P2,(POINT 8,)	;8-BIT ASCIZ
	MOVSI	S2,-.APWLC	;MAXIMUM LENGTH

LENPS1:	ILDB	S1,P2		;GET A CHARACTER
	JUMPE	S1,LENPS2	;DONE?
	AOBJN	S2,LENPS1	;LOOP

LENPS2:	HRRZS	S2		;KEEP ONLY COUNT
	LOAD	S1,.AEREQ(P1),AE.PWL ;GET MINIMUM LENGTH REQUIRED
	CAIGE	S2,(S1)		;CHECK IT
	$RETF			;TOO SMALL
	$RETT			;RETURN GOODNESS
; SETPSW - STORE PASSWORD IN RECORD
; CALL:	MOVE	S1, ADDRESS OF PASSWORD IN 8-BIT ASCIZ
;	MOVE	S2, ADDRESS OF BUFFER CONTAINING RECORD
;	PUSHJ	P,SETPSW
;
; TRUE RETURN:	PASSWORD SET IN RECORD
; FALSE RETURN:	ENCRYPTION ALGORITHM FAILED
;
; GETTING THE RECORD IN CORE, AND PUTTING IT BACK ARE THE CALLER'S PROBLEM

SETPSW::$SAVE	P1		;SAVE P1
	MOVE	P1,S2		;KEEP ADDRESS OF BUFFER
	MOVE	T1,S1		;COPY ADDRESS OF NEW PASSWORD
	MOVE	T3,.AEPPN(P1)	;AND PPN FOR SALT
	PUSHJ	P,ENCRYP	;ENCRYPT IT, PLEASE
	$RETIF			;RETURN PROPAGATING ERROR IF ANY
	MOVE	T1,P1		;PROFILE ADDRESS
	MOVE	T2,S1		;GET -LENGTH,,0
	HRRI	T2,.AEPSW	;PROFILE OFFSET
	MOVE	T3,S2		;ENCRYPTED PASSWORD ADDRESS
	MOVEI	T4,0		;CLEAR .AEMAP ENTRY
	PUSHJ	P,A$EBLK##	;UPDATE PROFILE
	MOVE	S1,CURALG	;GET THE ALGORITHM USED
	STORE	S1,.AEFLG(P1),AE.PWE ;STORE ENCRYPTION ALGORITHM NUMBER
	$RETT			;RETURN
; CHKPSW - CHECK PASSWORDS
; CALL:	MOVE	S1, ADDRESS OF PASSWORD IN 8-BIT ASCIZ
;	MOVE	S2, ADDRESS OF PROFILE CONTAINING RECORD
;	PUSHJ	P,CHKPSW
;
; TRUE RETURN:	PASSWORD MATCHES
; FALSE RETURN:	PASSWORD DOES NOT MATCH
; IT IS THE CALLERS RESPONSIBILITY TO SET THE VALIDATION FAILED BIT.

CHKPSW::$SAVE	P1		;SAVE P1
	MOVE	P1,S2		;SAVE RECORD ADDRESS
	MOVE	T1,S1		;POINT TO PASSWORD SUPPLIED BY CALLER
	MOVEI	T2,PSWBLK	;POINT TO PLACE TO RECEIVE PASSWORD
	MOVE	T3,.AEPPN(P1)	;AND PPN FOR SALT
	LOAD	T4,.AEFLG(P1),AE.PWE ;GET THE ENCRYPTION VERSION
	PUSHJ	P,ENCRYN	;ENCRYPT IT
	$RETIF			;RETURN IF UNKNOWN ALG #
	HLLZ	T1,.AEPSW(P1)	;-NUMBER OF WORDS OF PASSWORD
	HRRZ	T2,.AEPSW(P1)	;GET OFFSET
	ADDI	P1,(T2)		;INDEX INTO PROFILE
	HRLI	P1,(IFIW 0(T1))	;MAKE AN INDIRECT PTR TO CURRENT WORD
CHKPS1:	MOVE	S1,@P1		;GET A WORD OF USER-SUPPLIED PASSWORD
	CAME	S1,PSWBLK(T1)	;COMPARE IT
	$RETF			;FAILED TO COMPARE
	AOBJN	T1,CHKPS1	;AND LOOP
	$RETT			;SUCCESS
;ENCRYP - Routine to take a 39 character password and encrypt it non-reversably
;	into a 144 bit quantity.
;Calling sequence
;	T1/ Pointer to 8-BIT ASCIZ string to encrypt.
;	T2/ Four word block to receive encrypted password
;	T3/ PPN to be used as salt.
;	T4/ALGORITHM NUMBER TO USE
;Return
;	Always,

ENCRYP::MOVE	T4,CURALG	;USE CURRENT ALGORITHM
ENCRYN::SKIPLE	T4		;CAN'T BE NEGATIVE OR ZERO
	CAILE	T4,AL$MAX	;OR GREATER THAN MAXIMUM?
	$RETF			;CAN ONLY HAPPEN IF ENTER FROM ENCRYN
	MOVEI	T2,PSWBLK	;WHERE ENCRYPED PASSWORD WILL GO
	PUSHJ	P,@ALGTAB-1(T4)	;DISPATCH
	MOVSI	S1,-4		;-LENGTH
	MOVEI	S2,PSWBLK	;ADDRESS
	$RETT			;RETURN

ALGTAB:	IFIW	ALG1		;6-BIT CRC
	IFIW	ALG2		;6-BIT POLYNOMIAL
	IFIW	ALG3		;8-BIT ASCIZ CRC
	IFIW	ALG4		;8-BIT POLYNOMIAL
	IFIW	ALG5		;NCRYPT
	IFIW	ALG6		;ALTERNATE NCRYPT
AL$MAX==.-ALGTAB		;LENGTH OF TABLE
	SUBTTL	ALGORITHMS 1 & 3 - 6 & 8 BIT CRC

; 6-BIT CRC
ALG1:	$SAVE	<P1,P2,P3,P4>	;WE TRASH THESE ACS
	PUSHJ	P,CNVSIX	;CONVERT 8-BIT ASCIZ PASSWORD TO SIXBIT
	DMOVE	P1,T2		;COPY ARGS
	PUSHJ	P,SMTH6		;SMOOTH THE PASSWORD ACROSS FOUR WORD BLOCK
	JRST	ALG1.0		;ENTER COMMON CODE

; 8-BIT ASCIZ CRC
ALG3:	PUSHJ	P,.SAVE4	;SAVE SOME ACS
	DMOVE	P1,T2		;COPY ARGS
	PUSHJ	P,CVTCAS	;DO CASE CONVERSION
	PUSHJ	P,SMTH8		;SMOOTH THE PASSWORD ACROSS FOUR WORD BLOCK

ALG1.0:	IMUL	P2,[^D10006721*^D3167] ;SPREAD SALT AROUND SALT WORD
	ADDI	P2,^D84857	;AVOID PROPAGATING TRALING ZEROES
	HRLI	P1,-WRDS	;MAKE AN AOBJN POINTER TO ENCRYPTED BLOCK

ALG1.1:	SETZB	T1,T2		;CLEAR DESTINATION
	DMOVE	T3,(P1)		;GET TWO WORDS OF PASSWORD
	TLC	P1,3
	TLCN	P1,3		;WAS THIS THE LAST WORD IN THE BLOCK?
	MOVE	T4,-3(P1)	;YES, DON'T USE JUNK BEYOND END
	MOVE	P3,(P1)		;GET A WORD FROM THE PASSWORD BLOCK
	XOR	P3,T4		;COMBINE IT WITH NEXT WORD
	ROT	P3,^D2		;ROTATE IT ODDLY
	ADD	P3,P2		;ADD IN THE "SALT" (SCRAMBLED PPN)
	MOVEI	P4,^D72		;NUMBER OF BITS WE ARE GOING TO DO

ALG1.2:	TRNE	P3,1		;ODD COMMAND BIT?
	DADD	T1,T3		;YES, ADD IN CURRENT OPERAND
	ROTC	T1,1		;SHIFT
	ROT	P3,-1		;ROTATE COMMAND BITS IN OPPOSITE DIRECTION
	SOJGE	P4,ALG1.2	;LOOP FOR EVERY BIT IN GROUP
	MOVEM	T1,(P1)		;STASH ENCRYPTED WORD
	AOBJN	P1,ALG1.1	;REPEAT FOR NEXT GROUP
	$RETT			;DONE


CNVSIX:	MOVE	T4,T1		;COPY ORIGINAL PASSWORD BLOCK ADDRESS
	MOVEI	T1,PSW6		;WILL USE THIS INSTEAD
	PUSHJ	P,.SAVET	;SAVE T1-T4
	MOVE	T1,T4		;GET ORIGINAL BLOCK ADDRESS BACK
	HRLI	T1,(POINT 8,)	;BYTE POINTER TO SOURCE
	MOVE	T2,[POINT 6,PSW6] ;BYTE POINTER TO DESTINATION
	MOVEI	T3,.APWLC	;MAX CHARACTER COUNT
	MOVE	T4,[PSW6,,PSW6+1] ;SET UP BLT
	SETZM	PSW6		;CLEAR FIRST WORD
	BLT	T4,PSW6+<.APWLC/6> ;ZERO INTERMEDIATE STORAGE
CNVSI1:	ILDB	T4,T1		;GET A CHARACTER
	JUMPE	T4,.POPJ	;RETURN IF ALL DONE
	ANDI	T4,177		;MASK DOWN
	CAIL	T4,"A"+40	;RANGE
	CAILE	T4,"Z"+40	; CHECK
	SUBI	T4,40		;CONVERT TO LOWER
	IDPB	T4,T2		;PUT A CHARACTER
	SOJG	T3,CNVSI1	;LOOP
	POPJ	P,		;RETURN


CVTCAS:	PUSHJ	P,.SAVET	;SAVE SOME ACS
	HRLI	T1,(POINT 8,)	;8-BIT ASCIZ
	MOVEI	T2,.APWLC	;CHARACTER COUNT
CVTCA1:	SOJL	T2,.POPJ	;DON'T GO OFF THE DEEP END
	ILDB	T3,T1		;GET A CHARACTER
	JUMPE	T3,.POPJ	;RETURN IF END OF STRING
	CAIL	T3,"A"+40	;LOWER CASE?
	CAILE	T3,"Z"+40
	CAIL	T3,340
	CAILE	T3,375
	JRST	CVTCA1		;NO
	SUBI	T3," "		;YES, MAKE UPPER
	DPB	T3,T1		;CONVERT IN PLACE
	JRST	CVTCA1		;LOOP OVER ALL CHARACTERS
	SUBTTL	ALGORITHMS 2 & 4 - 6 & 8 BIT POLYNOMIALS

;THIS COMPUTES  P^(2^30+36) +A1*P^(2^30) +A2*P^3 +A3*P^2 +A4*P +A5
;COPIED FROM TOPS20 MODULE CRYPT.MAC

	P5==P4+1

; 6-BIT POLYMONIAL
ALG2:	$SAVE	<P1,P2,P3,P4,P5> ;P ACS
	PUSHJ	P,CNVSIX	;CONVERT 8-BIT ASCIZ PASSWORD TO SIXBIT
	MOVE	P1,T2		;SAVE POINTER TO FOUR-WORD BLOCK
	PUSHJ	P,SMTH6		;SPREAD THE BITS AROUND
	JRST	ALG2.0		;ENTER COMMON CODE

; 8-BIT ASCIZ POLYNOMIAL
ALG4:	$SAVE	<P1,P2,P3,P4,P5> ;P ACS
	MOVE	P1,T2		;SAVE POINTER TO FOUR-WORD BLOCK
	PUSHJ	P,CVTCAS	;CONSISTENT CASING
	PUSHJ	P,SMTH8		;SPREAD THE BITS AROUND

ALG2.0:	MOVE	T1,P1		;GET BACK POINTER TO DATA
	MOVEI	P5,2		;NUMBER OF DOUBLE WORD GROUPS TO ENCODE
	DMOVE	P3,2(T1)	;FROM SCRATCH

ALG2.1: TDC	P3,0(T1)	;FIRST HALF
	TDC	P4,1(T1)	;SECOND HALF
	DMOVE	P1,P3		;DOUBLE WORD TO ENCODE
	LSHC	P1,-1		;PUT SIGNIFICANT BITS WHERE THEY BELONG
	DDIV	P1,HSHMOD	;TAKE MOD
	DMOVE	T3,P3 		;SAVE ORIGINAL NUMBER
	MOVEI	T2,5 		;LOOP COUNT

ALG2.2: DMOVE	P1,P3 		;COPY NUMBER FOR SQUARE
	DMUL	P1,P3 		;SQUARE IT
	DDIV	P1,HSHMOD 	;TAKE MOD
	SOJG	T2,ALG2.2 	;LOOP TO RAISE IT TO THE 32 POWER
	DMOVEM	P3,1(T1)	;SAVE PWD^32
	DMOVE	P1,P3 		;MOVE FOR MULTIPLY
	DMUL	P1,T3		;MAKE PWD^33
	DDIV	P1,HSHMOD 	;TAKE MOD
	DADD	P3,HSHA1 	;ADD IN FIRST COEFFICIENT
	SETZB	P1,P2 		;MAKE QUAD-WORD
	DDIV	P1,HSHMOD 	;TAKE MOD
	DMOVE	P1,1(T1)	;GET PWD^32 BACK
	DMOVEM	P3,1(T1)	;SAVE A1+PWD^33
	DMOVE	P3,P1 		;COPY FOR SQUARE
	MOVEI	T2,^D25 	;LOOP COUNT

ALG2.3:	DMUL	P1,P3 		;SQUARE IT
	DDIV	P1,HSHMOD 	;TAKE MOD
	DMOVE	P1,P3 		;COPY FOR SQUARE
	SOJG	T2,ALG2.3 	;LOOP TO PRODUCE (PWD^(2^30))
	DMUL	P1,1(T1)	;MULTIPLY BY A1+PWD^33
	DDIV	P1,HSHMOD 	;TAKE MOD
	DADD	P3,HSHA2 	;YES
	SETZB	P1,P2 		;MAKE A QUAD-WORD
	DDIV	P1,HSHMOD 	;TAKE MOD
	SETZ	T2,		;OFFSET FOR COEFFICIENTS

ALG2.4: DMOVE	P1,P3 		;MOVE FOR MULTIPLY
	DMUL	P1,T3		;MULTIPLY BY PWD
	DDIV	P1,HSHMOD 	;TAKE MOD
	DMOVE	P1,P3 		;MOVE FOR MULTIPLY
	DADD	P1,HSHA3(T2)	;YES
	DDIV	P1,HSHMOD 	;TAKE MOD
	ADDI	T2,2 		;NEXT COEFFICIENT
	CAIGE	T2,6 		;ONLY 3 MORE COEFFICIENTS
	JRST	ALG2.4 		;KEEP GOING
	DMOVEM	P3,1(T1)	;STORE ENCODED PASSWORD DOUBLEWORD
	ADDI	T1,2 		;POINT TO NEXT DOUBLEWORD
	SOJG	P5,ALG2.1 	;DO BOTH DOUBLEWORDS
	SETZ	T2,		;APPEND A ZERO
	$RETT			;RETURN

HSHMOD: OCT 377777777777,377777777735	;(2^70-35) PRIME MODULUS
HSHA1:	OCT 305301317120,157221260120	;THE RANDOMLY CHOSEN COEFFICIENTS
HSHA2:	OCT 147300565442,275156661305
HSHA3:	OCT 276504256001,246721554756
	OCT 226461502774,377222042231
	OCT 040267005300,343010077117
;SMTH6/SMTH8 - ROUTINE TO TAKE AN 8-BIT ASCIZ PASSWORD STRING AND
;CONVERT IT INTO A SMOOTH 144 BIT QUANTITY
;Call
;	T1/ Pointer to source string
;	T2/ Pointer to four word block to receive data
;Return
;	always

SRCBPT==<SRCCNT==<DSTADR==0>-1>-1
BYTES==.APWLC			;NUMBER OF INCOMING BYTES
BYTSIZ==1			;BYTE SIZE TO SPREAD AROUND
WRDS==4				;NUMBER OF WORDS IN DESTINATION
ORGWRD==2			;FIRST WORD TO DEPOSIT STUFF INTO
ORGPOS==21			;ORIGINAL POSITION TO DEPOSIT BYTES
ROTPOS==13			;HOW FAR TO ROTATE ON EACH ITERATION


SMTH6:	SKIPA	T4,[<BYTES*6>/BYTSIZ] ;6-BIT ENTRY POINT
SMTH8:	MOVE	T4,[<BYTES*8>/BYTSIZ] ;8-BIT ENTRY POINT
	PUSH	P,[POINT BYTSIZ,(T1)];POINTER TO SOURCE STRING
	PUSH	P,T4		;SAVE NUMBER OF ITERATIONS TO MAKE
	PUSH	P,T1		;SAVE T1
	MOVSI	T1,0(T2)	;POINT TO DESTINATION BLOCK
	HRRI	T1,1(T2)	;MAKE A BLT POINTER
	SETZM	(T2)		;CLEAR THE FIRST WORD
	BLT	T1,WRDS-1(T2)	;CLEAR THE ENTIRE BLOCK
	POP	P,T1		;RESTORE T1
	HRLI	T2,(IFIW (T2))	;MAKE AN INDIRECT POINTER TO DESTINATION
	PUSH	P,T2		;AND SAVE IT ON STACK
	MOVEI	T2,ORGWRD	;WORD TO START AT
	MOVEI	T4,ORGPOS	;ORIGINAL POSITION

SMTH.1:	SOSGE	SRCCNT(P)	;ALLOCATE A BIT FROM INPUT
	JRST	SMTH.2		;DONE, EXIT
	ILDB	T3,SRCBPT(P)	;GET A BYTE
	ROT	T3,(T4)		;POSITION IT CORRECTLY
	XORM	T3,@DSTADR(P)	;ADD IT INTO DESTINATION
	ADDI	T4,ROTPOS	;NEXT TIME'S ROTATION
	CAIL	T4,^D36		;MORE THAN A WORD'S ROTATION?
	SUBI	T4,^D36		;YES, LIMIT IT
	SOSGE	T2		;DECREMENT RELATIVE WORD TO DEPOSIT
	MOVEI	T2,WRDS-1	;START AT TOP IF OFF BOTTOM
	JRST	SMTH.1		;AND LOOP

SMTH.2:	ADJSP	P,-3		;BLOW AWAY THREE LOCATIONS ON THE STACK
	POPJ	P,		;AND RETURN
	SUBTTL	ALGORITHM 5 - NCRYPT


;Although this algorithm looks impressive, it is not.  To take advantage
;of the enhanced security offered by this release, we recommend that you
;force your users to change their passwords immediately on LOGIN.  This
;algorithm is provided only so that they can login that one time.

ALG5:	PUSHJ	P,CNVSIX	;CONVERT 8-BIT ASCIZ PASSWORD TO SIXBIT
	PUSH	P,T1		;SAVE T1
	MOVSI	T1,0(T2)	;POINT TO DESTINATION BLOCK
	HRRI	T1,1(T2)	;MAKE A BLT POINTER
	SETZM	(T2)		;CLEAR THE FIRST WORD
	BLT	T1,WRDS-1(T2)	;CLEAR THE ENTIRE BLOCK
	POP	P,T1		;RESTORE T1
	PUSH	P,T2		;SAVE WHERE TO STORE RESULT
	PUSH	P,T3		;SAVE PPN
	MOVE	T2,(T1)		;GET PSWD IN T2
	MOVE	T1,T2		;AND T2
	HRRZ	T4,(P)		;GET PROGRAMMER NUMBER
	IDIVI	T2,(T4)		;DIVIDE INTO PASSWORD
	MOVM	T3,T3		;GET ABS(REMAINDER)
	MOVE	T4,T3		;COPY FOR A LOOP COUNTER
ALG5.1:	MUL	T1,T1		;SQUARE THE PASSWORD
	ROTC	T1,^D18		;GET MIDDLE 36 BITS OF RESULT
	JUMPN	T1,.+2		;MAKE SURE NON-ZERO
	MOVE	T1,T2		;IF ZERO, PICK UP PSWD AGAIN
	SOJG	T4,ALG5.1	;DO THIS A LARGE (RANDOM) NO. OF TIMES
	XOR	T1,PSW6		;MUNGE IT WITH THE FIRST WORD OF THE PASSWORD
	IDIVI	T3,^D35		;DIVIDE LOOP COUNTER
	ROT	T1,1(T4)	;ROTATE T1 BY REMAINDER
	MOVEM	T1,@-1(P)	;STORE INADEQUATE RESULT
	ADJSP	P,-2		;TOSS OUR SCRATCH SPACE
	$RETT
	SUBTTL	ALGORITHM 6 - ALTERNATE NCRYPT


;Although this algorithm looks impressive, it is not.  To take advantage
;of the enhanced security offered by this release, we recommend that you
;force your users to change their passwords immediately on LOGIN.  This
;algorithm is provided only so that they can login that one time.

ALG6:	PUSHJ	P,CNVSIX	;CONVERT 8-BIT ASCIZ PASSWORD TO SIXBIT
	PUSH	P,T1		;SAVE T1
	MOVSI	T1,0(T2)	;POINT TO DESTINATION BLOCK
	HRRI	T1,1(T2)	;MAKE A BLT POINTER
	SETZM	(T2)		;CLEAR THE FIRST WORD
	BLT	T1,WRDS-1(T2)	;CLEAR THE ENTIRE BLOCK
	POP	P,T1		;RESTORE T1
	MOVE	T4,T2		;WHERE TO STORE RESULT
	MOVS	T1,(T1)		;GET PASSWORD
	XOR	T1,T3		;VARY A BIT
	MUL	T1,[^D1220703125] ;5**13
	LSHC	T1,^D18		;GET MIDDLE 36 BITS OF RESULT
	XOR	T1,T3		;VARY A BIT
	MUL	T1,[^D1220703125] ;5**13
	LSHC	T1,^D18		;GET MIDDLE 36 BITS OF RESULT
	MOVEM	T1,0(T4)	;STORE INADEQUATE RESULT
	$RETT

	LIT

	RELOC	0

PSWBLK:	BLOCK	WRDS         	;TEMPORARY STORAGE FOR ENCRYPTED PASSWORD
PSW6:	BLOCK	.APWLC/6+1	;8-BIT TO SIXBIT CONVERTED PASSWORD RESULT

	PRGEND
TITLE	CUSREA - CUSTOMER INTERFACE TO REACT


	SEARCH	ACTPRM,ORNMAC
	MODULE	(CUSREA)

	ENTRY	CMDCUS,	CMDCUP,	ENTCUS

;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1985,1986.  ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.


	ND	FTISWS,0	;NORMALLY TURNED OFF
				; SET NON-ZERO FOR IN-HOUSE CORPORATE
				; DATA CENTER
	ND	FTXMPL,0	;NORMALLY TURNED OFF
				; SET NON-ZERO TO ASSEMBLE IN EXAMPLES
				; SHOWING HOW TO ADD CUSTOMER DEFINED
				; PRIVILEGED AND UNPRIVILEGED COMMANDS,
				; AND CUSTOMER DEFINED PROFILE ENTRY TYPES
SUBTTL	CUSTOMER COMMAND TABLES


; PRIVILEGED ADMINISTRATIVE COMMANDS
CMDCUS::$STAB
IFN FTXMPL,<
	DSPTAB	(PFOO00,PFOO,<PRVFOO>)
> ;END IFN FTXMPL
	$ETAB


; UNPRIVILEGED USER COMMANDS
CMDCUP::$STAB
IFN FTXMPL,<
	DSPTAB	(UFOO00,UFOO,<USRFOO>)
> ;END IFN FTXMPL
	$ETAB

IFN FTXMPL,<
PFOO00:	$NOISE	(CONFRM##,<privileged>)
UFOO00:	$NOISE	(CONFRM##,<unprivileged>)
> ;END IFN FTXMPL
SUBTTL	PFOO COMMAND


IFN FTXMPL,<

	XWD	PFOHLP,[ASCIZ /Performs the privileged FOO function/]
PFO:	$RETT


PFOHLP:	ASCIZ	\
The FOO command.
\

> ;END IFN FTXMPL
SUBTTL	UFOO COMMAND


IFN FTXMPL,<

	XWD	UFO,[ASCIZ /Performs the unprivileged FOO function/]
UFO:	$RETT

UFOHLP:	ASCIZ	\
The UFOO command.
\

> ;END IFN FTXMPL
SUBTTL	CUSTOMER ENTRIES -- PRIVILEGES


CPV010::$STAB
IFN FTXMPL,<
	DSPTAB	(PRV010##,CPVXXX,<X-PRIV>)
	DSPTAB	(PRV010##,CPVYYY,<Y-PRIV>)
> ;END IFN FTXMPL

IFN FTISWS,<
	DSPTAB	(PRV010##,CPVCPN,<CHANGE-PPN>)
	DSPTAB	(PRV010##,CPVMDC,<MDC-SET-P>)
	DSPTAB	(PRV010##,CPVNEX,<NETWORK-EXAMINE>)
	DSPTAB	(PRV010##,CPVTRD,<TRMOP-READ>)
	DSPTAB	(PRV010##,CPVTWR,<TRMOP-WRITE>)
> ;END IFN FTISWS

	$ETAB

CPVBPS::!
IFN FTXMPL,<
CPVXXX:	XWD	[POINT	1,.AEPRV(U),35],[ASCIZ /X-priv/]
CPVYYY:	XWD	[POINT	1,.AEPRV(U),34],[ASCIZ /Y-priv/]
> ;END IFN FTXMPL

IFN FTISWS,<
CPVCPN:	XWD	[POINT	1,.AEPRV(U),35],[ASCIZ /Change-PPN/]
CPVNEX:	XWD	[POINT	1,.AEPRV(U),34],[ASCIZ /Network-examine/]
CPVTWR:	XWD	[POINT	1,.AEPRV(U),33],[ASCIZ /TRMOP-write/]
CPVTRD:	XWD	[POINT	1,.AEPRV(U),32],[ASCIZ /TRMOP-read/]
CPVMDC:	XWD	[POINT	1,.AEPRV(U),18],[ASCIZ /MDC-Set-P/]
> ;END IFN FTISWS
CPVBPE::!

CPVPRT::SKIPL	S1,[IOWD CPVBPE-CPVBPS,CPVBPS] ;IOWD POINTER TO BITS
	$RETT			;TABLE IS EMPTY
	$TEXT	(,<    ^A>)	;INDENT NEXT SET OF TYPEOUT
	PUSHJ	P,PRTBTS##	;AND OUTPUT THE FIRST SET OF BITS
	$RETT
	SUBTTL	CUSTOMER FIELDS


ENTCUS::$STAB
	KEYTAB	(NUL##,<NULL-ENTRY>,CM%NOR!CM%INV)
IFN FTXMPL!FTISWS,<
	KEYTAB	(DLG,<LOG-FILE-DEFAULT>)
> ;END IFN FTXMPL!FTISWS
	$ETAB
SUBTTL	CUSTOMER ENTRIES -- LOG-FILE-DEFAULT


IFN FTXMPL!FTISWS,<

	.ENTRY	(DLG,.AELOG,<Log file default>)

DLGPRS:	$FILE	(CONFRM##,<filespec>,<$PREFIL(DLGACT)>)

DLGACT:	MOVE	S1,[GJFBLK##,,GJFBLK##+1] ;SET UP TO ZERO BLOCK
	SETZM	GJFBLK##	;CLEAR 1ST WORD
	BLT	S1,GJFBLK##+GJFSIZ-1 ;CLEAR THE REST
	MOVSI	S1,'...'	;GET SOMETHING TO MARK OUR PLACE
	MOVEM	S1,GJFBLK##+.FDSTR ;STORE IT
	$RETT			;RETURN


; GET ROUTINE
DLGGET:	PUSHJ	P,.SAVE1	;SAVE P1
	PUSHJ	P,PROFSP##	;FETCH FILESPEC
	JUMPF	PRSERR##	;CHECK FOR ERRORS
	MOVE	P1,S1		;SAVE FD ADDRESS
	PUSHJ	P,P$CFM##	;GET EOL
	JUMPF	PRSERR##	;CHECK FOR ERRORS
	MOVEI	S1,(P1)		;FD (PARSER DATA BLOCK) ADDRESS
	MOVE	S2,DLG+CG.PFL	;PROFILE OFFSET
	PUSHJ	P,PROBLK##	;ADD/DELETE EXTENSIBLE BLOCK
	SKIPT			;CHECK FOR ERRORS
	WARN	(NRM,<No room in profile for LOG-FILE-DEFAULT>,,DLGRES)
DLGGO:	MOVEI	S1,.AELOG	;PROFILE OFFSET
	PJRST	CMPVLC##	;SET CHANGE FLAGS AND RETURN


; COMPARE ROUTINE
DLGCMP:	MOVEI	S1,.AELOG	;PROFILE OFFSET
	PJRST	COMPAR##	;GO COMPARE


; CHANGE ROUTINE
DLGCHG:	MOVEI	S1,.AELOG	;PROFILE OFFSET
	PJRST	QUECHG##	;QUEUE UP THE CHANGE


; RESTORE ROUTINE
DLGRES:	MOVEI	T1,(U)		;POINT TO PROFILE
	HLLZ	T2,.AELOG(X)	;-LENGTH
	HRRI	T2,.AELOG	;OFFSET
	MOVE	T3,.AELOG(X)	;ORIGINAL OFFSET POINTER
	ADDI	T3,(X)		;INDEX INTO PROFILE
	MOVX	T4,DF.LOG	;DEFAULT BIT FOR FIELD
	TDNN	T4,DF$LOG(X)	;WANT IT DEFAULTED?
	TDZA	T4,T4		;NO, RESTORE THE ZERO
	MOVEI	T4,1		;YES, RESTORE THE ONE
	PUSHJ	P,A$EBLK##	;RESTORE ORIGINAL DEFAULT LOG FILE
	SETZM	@CHGADR##	;INDICATE NOT CHANGING PROFILE ENTRY
	SETZM	CHGMSK##+.AELOG	;IN BOTH PLACES
	$RETT			;RETURN


; DEFAULTING ROUTINE
DLGDFL:	MOVX	S1,DF.LOG	;DEFAULT BIT
	IORM	S1,DF$LOG(U)	;LIGHT IT
	SETOM	PRSDFV##	;SETTING TO DEFAULT VALUE
	PJRST	DLGGO		;SETUP MASKS AND RETURN


; PRINT ROUTINE
DLGPRT:	SKIPE	S1,.AELOG(U)	;GET AOBJN POINTER TO FILESPEC
	JRST	DLGPR1		;GOT ONE
	$TEXT	(,<-none->)	;NOPE
	$RETT			;RETURN

DLGPR1:	ADDI	S1,(U)		;INDEX INTO PROFILE
	HLRE	S2,S1		;GET -LENGTH OF FILESPEC
	MOVMS	S2		;MAKE POSITIVE
	HRLZM	S2,FDBLK##+.FDLEN ;SAVE AS FD LENGTH
	HRLZS	S1		;PUT FILESPEC ADDRESS IN LH
	HRRI	S1,FDBLK##+.FDSTR ;MAKE A BLT POINTER
	BLT	S1,FDBLK##+.FDPAT+4 ;COPY FOR GLXTXT
	$TEXT	(,<^F/FDBLK/>)	;DISPLAY
	$RETT			;RETURN
; HELP TEXT
DLGHLP:	ASCIZ	\
Default batch log file
\

> ;END IFN FTXMPL!FTISWS


	END
