TITLE TRACK A PROGRAM TO TRACK JOB EXECUTION AND SYSTEM PERFORMANCE
SUBTTL IRWIN L. GOVERMAN/ILG/EVS/ILG/RBP	12-JAN-77

	MLON
	IFNDEF BIGLST, <BIGLST==0> ;DEFAULT TO CLEAN LISTING
	IFN BIGLST, <LALL>
	IFE BIGLST, <SALL>

	UNILOG==1
	UNISYS==3
	UNICHN==5
	UNISTS==36
	UNINAM==0

; SEARCH MACTEN,UUOSYM
	SEARCH MACTEN,UUOSYM

;	SHOW VERSION OR ERROR MESSAGE

	IFNDEF %%MACT,<PRINTX ?NEEDS MACTEN.MAC OR MACTEN.UNV
	PASS2
	END>
	SHOW.(%%MACT)
	IFNDEF %%UUOS,<PRINTX ?NEEDS UUOSYM.MAC OR UUOSYM.UNV
	PASS2
	END>
	SHOW.(%%UUOS)



; VERSION AND EDIT NUMBERS

	TRKVER==5
	TRKEDT==225
	TRKMIN==1
	TRKWHO==0

	LOC 137
	VRSN. (TRK)	;FORMAT VERSION NUMBER

;   SET REENTRY POINT
	LOC 124
	RESTRT
	RELOC


COMMENT @

	Development by Pito Salas includes the following:

	1) Adding a /DAILY switch to have the following function:
		a: IF the output file specified in a command
		   does not already exist, THEN it is created.
		   ELSE,
			the date of the existing one is checked.
			IF it is equal to todays date, THEN the current data
			   is appended to that file.
			ELSE,
			     that file is renamed to be MMDDYY.ext,
					where MM=this month
					      DD=today's date
					      YY=this year
					      ext= TRK or TXT depending on /FORMAT
			      and a new file is started with the specified
			      name.
		b: IF TRACK is running when daytime goes through midnite,
		   THEN the output file is renamed to MMDDYY.ext as above,
		        and a new file of the specified name is started.

	2) The header of the TRACE files is slightly changed, so as
	   to conform with FACT files. This allows piping together of
	   TRACE files with FACT files for later analysis, without 
	   confusing FACT analysis programs.

	3) Adding a 'Real' response time measure.
@
SUBTTL	REVISION HISTORY
;** EDIT HISTORY **
;225	Slight change in format of output for non-TRACE mode,
;	so that mean and SD are on 1 line together
;	Changed DEXTT to be TRC rather than TRK, to both make sense
;	and to conform with documentation
;224	Removed the code to track %busy rather than queue lengths for
;	disks/tapes.  Too costly under post 7.01A monitors where the
;	disk database is accessible only via PEEK UUOs, not SPY hiseg.
;223	?
;222	Changed TRACEH to put out V4 TRACK format entries:  first word
;	 is entry type, second is length, and data follows immediately.
;	removed all of the snet hack for disk names
;	reorganized entries in SYSDAT call to be by function, not
;	 cpu#
;221	added switches to control use of meter boards on a system-wide
;	of per-cpu basis.  use  /METER for all cpus, or /METERn for
;	cpu n.

;220	Hacked SNEBSY to not die if a non-RP disk is seen.  Will fix
;	this routine later, or turn of SNET ft switch that munges disk names.

;217	Add support for more than 2 processors.  Use NCPU for multi-CPU
;	tests instead of CPU.1 /rbp
;;** END OF 4(216).  5(217) HAS FULL SMP SUPPORT
;** TRACK-X VERSION STARTED HERE

;216	FIX BUG THAT CAUSED EXTRA DISK IO FOR SYSTEM TRACKS
;215	ALLOW SWAPPING DISK IO TO BE TRACKED WITHOUT USER DISK IO
;214	CALCULATE USER MEM AS TOTAL-(MONITOR HIGH+MONITOR LOW)
;213	REDO THE UNIT/CHANNEL STUFF SO NOT INTERDEPENDENT
;212	ADD SWAP SPACE LEFT TO SYSDAT,REMOVE SWAPPER DATA
;211	FLAG VIRTUAL JOBS WITH "V", ON PRINTOUT
;210	RE-DO UNITYP, INCLUDING NEWER DISK TYPES
;207	USE FILOP. FOR OUTPUT FILE SAVE FUNCTION, PRODUCES SMALLER FILE
;206	ADD EXIT COMMAND
;205	ADD /HELP:KEYWORD FOR GETTING VALUES OF COMPARE, INCLUDE/EXCLUDE
;204	BET YOU THOUGHT EDIT 203 WAS CORRECT, DIDN'T YOU?
;203	MAKE GETCOR A LITTLE BRIGHTER ON VM SYSTEMS
;202	ADD WILD CARD "*" TO PPN MATCH CODE
;201	MAKE PPN AND PROGRAM WATCHING ABLE TO DO MULTIPLE JOBS
;200	MAKE CHANNEL AND DISK STUFF NORMALLY EXCLUDED
;177	REMOVE RT/WANTED TO RT SINCE WAS NEVER RIGHT
;176	DON'T PRINT USERS PROLOG IF NO JOBS MATCH SPECS
;175	IMPLEMENT HELP:SWITCHES

;174	GIVE RIGHT TTY NUMBER IF JOB TRACKED VIA 'PROG'
;173	CORE SIZE COMPUTATION INCORRECT FOR VM SYSTEMS
;172	CORRECT THE BYTE POINTER USED FOR IMGIN IN ROUTINE VMSEG
;171	CLEAN UP "?TRKSVS SWITCH VALUE TOO SMALL" TYPEOUT
;170	CLEAR TAB.P ON RESTART OF TRACK
;167	ADD TRACKING OF A PROGRAM VIA 'PROGNM' TYPE CONSTRUCTION
;166	ADD TRACKING OF SCANNER SERVICE RECEIVE AND XMIT INTERUPTS
;165	REMOVE /CHANNEL AND /DISK:NONE
;164	ADD /INCLUDE AND /EXCLUDE SWITCHES
;163	INCREASE SIZE OF SEGTAB
;162	ADD ARGUMENTS FOR /COMPARE
;161	DONT PRINT RUNTIME IF DOING ALL USERS
;160	CHANGE DEFAULT VALUE OF GETUNI
;157	ADD ENQ TO LIST OF PRIVELEGES A JOB MIGHT HAVE
;156	B%RPT WORD OF %BSGO IN TRACE REPORT WAS MISSING
;155	ADD UUOS PER SECOND ON EACH CPU
;154	IDLE TIME WAS REALLY NULL TIME - CHANGE TO REAL IDLE TIME
;153	DON'T PRINT OUT POSTITION WAIT QUEUE FOR RS04 - REQUIRES
;	  .DCCFS DO BE DEFINED IN UUOSYM, WHICH IT WAS NOT IN TIME
;	  FOR 602 MONITOR
;152	CHANGE KL10 CACHE VARIABLES TO PER SECOND QUANTITIES
;151	CHANGE SYSGET AND SYSDIS TO CALL ITEM DEPENDENT ROUTINE
;	  ONLY IF AN ENTRY EXISTS IN TAB.P FOR THE ITEM.
;150	FIX EDIT 147
;147	ADD NEW 1088 KL10 CACHE RELATED VARIABLES TO SYSTEM DISPLAY
;146	ADD NUMBER OF UNWINDS, NUMBER OF TIMES JOB WAS RUN TO GIVE
;	 UP RESOURCE BECAUSE IT WAS SELECTED TO SWAP OUT, SWAPPER
;	 NULL AND LOST TIME TO SYSTEM DISPLAY
;145	ADD % OF TTY CHUNKS USED TO SYSTEM DISPLAY
;144	USE MAXMAX (%NSMXM) INSTEAD OF SUBTRACTING SYSSIZ FROM CORE SO
;	TRACK WORKS WITH TWO SEGMENT MONITOR
;143	GET LENGTH OF DISK RELATED QUEUES FROM DSKCHR
;142	SEARCH MACTEN,UUOSYM INSTEAD OF C
;141	ADD MISSING CHECK FOR COMMA IN TPPN ROUTINE
;140	FIX UNITIALIZED BLT IN CHAN%I ROUTINE
;137	CHANGE LOOKUP AND ENTER ERROR PREFIXES
;136	ADD REPORT ON FREE CORE USAGE TO SYSTEM DATA
;135	MAKE "." WORK SAME AS SYSTAT, MAKE [,], [PROJ,],[,PROG] WORK
;134	ADD TRACE PACKAGE UNDER CONDITIONAL FTTRC
; ** END OF VERSION 3, VERSION 4 HAS TRACE CAPABILITY
;133	CLEAN GETCOR 
;132	SPLIT DEFAULTS UP SO CAN HAVE DIFFERENT FOR USERS,SYS,JOB ETC.
;131	FIX MONDEP VALUES THAT WERE WRONG
;130	REMOVE INTERNAL HELP TEXT
;127	FIX SPACING PROBLEM IN CONFIG DATA PRINTOUT
;126	CLEAR CTRKJ BETWEEN USER PRINTOUTS
;125	FIX ^Z FROM INDIRECT DEVICE, MAKE IT FORCE A BREAK LIKE SCAN
;124	ADD INDIRECT FILE
;123	ADD MORE CONFIGURATION INFO
;122	ADD W TO RUNNING COMMANDS
;121	ADD FF TO SEPARATE APPENDED SYS REPORTS
;120	ADD MORE SYSINI CONFIGURATION DATA
;117	ADD DISK AND CHANNEL SWITCHES
;116	FIX BUG IN FILSPC THAT CHANGED FOO. TO FOO.TXT
;115	MORE OF EDIT 114
;114	MAKE A "USERS" COMMAND BE REPEATABLE
;113	MAKE [P,PN]/NOKILL  WORK THE SAME AS FOR JOBS
;112	ADD /SUMMARY SWITCH FOR DELETION OF FREQ ON SYSDAT
;111	BEGIN RESTRUCTURING OF COMMAND SCANNER
;;** END OF VERSION 2, VERSION 3 HAS NEW COMMAND FORMAT
;110	ADD LOCK UUO SWITCH
;107	ADD HPQ SWITCH
;106	REDUCE CORE IF WE HAVE SWOLLEN
;105	STEAL SYSTAT'S SUPERIOR INTEGER SQUARE ROOT ROUTINE
;104	RE-DO REGISTER ALLOCATIONS, CHECK FOR ILLEGAL TTY AND JOB NRS
;103	RE-FORMAT THE STD. DEVIATION AND CLEAN CODE
;102	ADD BRANDEIS STUFF (FORMAX)
;101	ADD STD. DEVIATION TO DB PRINTOUT ROUTINE
;100	CLEAN UP OF SEVERAL CODE AREAS 
;77	BETTER ERROR MESSAGES FOR SWITCH PROCESSOR
;76	FIX SOME ERRORS CAUSED BY EDIT 74
;75	ADD DDT COMMAND TO ENTER DEBUGGER , IF LOADED
;74	CHANGE ERROR MESSAGES SO ABLE TO DO LONG AND SHORT
;73	CHECK THAT CORE ASSIGNMENTS ARE REALLY MADE FOR VM SYSTEM
;72	UPDATE INTERNAL HELP TEXT
;71	ADD AVG. RESP. TIME TO SYSDAT TRACKING
;70	FIX OUTDBX ROUTINE SO IT CAN PRINT NUMBERS > 2 **18
;67	FIX BUG THAT WAS SHOWN UP BY PRINTING OF UNPRIVELEGED TRACKS
;66	MAKE /C MORE USEFUL BY NOT COMPARING QUITE SO MANY ITEMS
;65	CHANGE SOME DEFAULT PARAMETERS
;64	FIX SWITCH SECTION VALUE GETTER AND CLEAN CODE
;63	FIX BUG IN GETTAB SIMULATOR INTRODUCED BY EDIT 61
;62	ADD IPCF PRIVELEGE FUNCTION TO PUTPRV MODULE
;61	CHANGE TO USE C UNIVERSAL FILE
;60	MAKE /NOKILLWORK THE WAY HELP FILE SAYS IT DOES
;57	BE SUPER CAREFUL ABOUT DISK AND CHANNEL STUFF
;56	IMPLEMENT A WAY THAT SUB-VERSIONS OF MONITOR CAN BE IN MVTAB
;55	DONT TAB AFTER PPN (USERS) IF PPN > 11 CHARS
;54	EXIT ON ^Z INPUT
;53	MORE COMPLETE FILE ERROR MESSAGES
;52	ADD /NODISK SWITCH TO DELETE DISK & CHANNEL REPORT FOR SYSDAT
;51	RE-DO SWITCH MODULE
;50	TELL ABOUT KSYS TIMER (IF SET) WHEN DOING SYSTEM DATA
;47	ADD USERS COMMAND TO TAKE SINGLE SWEEP OF WHOLE SYSTEM
;46	INSERT .TEXT LOADING OF HELPER SO CAN JUST LOAD TRACK
;45	CHANGE CLRBFI UUO USAGE TO FLUSH ROUTINE SO PTY'S NOT A PROBLEM
;44	UPDATE THE INTERNAL HELP TEXT
;43	STOP TRACKING POSITION WAIT Q LENGTH FOR FIXED HEAD DEVICES
;42	MAKE MONITOR DEPENDENT THINGS MORE CHANGEABLE
;41	COMPUTE RT BEFORE WANTED TO RUN TIME SO DONT GET % > 100 IF BUSY
;40	ADD SYSTEM TRACKING OF RT/TIME WANTED TO RUN
;37	CLEANUP, 1 MORE WORD FOR SYS NAME AND ALLOW USER CORE >128 UNITS
;36	ADD TRACKING FOR SECOND CPU
;35	USE LESS STORAGE SPACE FOR EDIT 34
;34	IMPLEMENT CHANNEL WATCHING (NR OF REQUESTS PER CHN)
;33	IMPLEMENT DISK UNIT WATCHING (POSITION WAIT Q)
;32	IMPLEMENT JOB QUEUE INFORMATION WATCHING
;31	IMPLEMENT USER KCS/SECOND AND USER DISK IO/SECOND 
;30	INCLUSION OF THE SYSTEM DATA WATCHING MODULE
;** END OF VERSION 1, START OF VERSION 2 FROM HERE ON UP
;27	ALLOW WATCHING OF NULL JOB (JOB 0)
;26	STOP DOING GETTABS WHEN INFO IS IN PROCESS DATA BLOCK
;25	STOP SPACING SO MUCH BEFORE RUNTIME PRINT
;24	SUBTRACT PROCESSING TIME FROM SLEEP TIME
;23	IMPLEMENT SPY UUO SO FASTER FOR PRIVELEGED USERS
;22	CHECK FOR NO RESPONSE TIME TABLE IN MONITOR
;21	IMPLEMENT /S (STATISTICS) SWITCH
;20	IMPLEMENT SHORT FORM OF JOB SPECIFICATIONS
;17	INCORPORATE STANDARD HELP MODULE
;16	TAKE ACCOUNT OF FACT USER MAY HAVE GONE VIRTUAL
;15	RE-WRITE GETCOR ROUTINE TO BE FASTER
;14	CLEAN UP PRINT-OUT A LITTLE
;13	IMPLEMENT STANDARD INPUT ROUTINES FOR CHARACTER CONVERSION
;12	IMPLEMENT /U SWITCH TO TELL USER NAME AND PPN
;11	IMPLEMENT /P SWITCH TO TELL PRIVELEGE BITS
;10	RE-DO DATA STRUCTURES TO USE NESTED MACROS
;7	FIX ZEROING OF JOB AREA SO /I WORKS BETTER
;6	IMPLEMENT PPN,MYPPN JOB SPECIFICATIONS
;5	FIX HIBER SO DONT GET SPURIOUS WAKES
;4	CHANGE TO DEC STANDARD ERROR MESSAGES
;3	IMPLEMENT /D FOR DISK I/O SWITCH
;2	IMPLEMENT CURSOR POSITIONING ROUTINE
;1	THE FIRST ATTEMPT


SUBTTL AC AND MISC. DECLARATIONS
; DEFINE THE ACS USED BY THE PROGRAM

	DEFINE ACS.(AA)<
	AA==ZZ
	ZZ=ZZ+1>

	ZZ==0

	ACS.(SW)	;SWITCH REGISTER, USED TO HOLD FLAGS
	ACS.(T1)	;TEMP, USED FOR ARGUMENT PASSING
	ACS.(T2)	;TEMP
	ACS.(T3)	;TEMP
	ACS.(T4)	;TEMP
	ACS.(N1)	;USED BY ROUTINES
	ACS.(N2)	;USED BY ROUTINES
	ACS.(N3)	;USED BY ROUTINES
	ACS.(GT)	;USED FOR GETTAB AND SPY
	ACS.(J)		;USUALLY INDEX FOR JOB TABLES
	ACS.(FP)	;POINTER TO CURRENT OUTPUT FIELD
	ACS.(CHRCNT)	;COUNTER OF CHARACTERS USED
	ACS.(L)		;USED FOR INDIRECT PTR TO CURRENT SYSDAT PEEK NR.
	ACS.(STR)	;POINTS TO OUTPUT ASCIZ STRING OR ERROR MESSAGE
	ACS.(CHR)	;CURRENT INPUT/OUTPUT CHARACS.TER
	ACS.(P)		;THE OMNIPRESENT PUSH DOWN POINTER

	LUEB==T1	;LOOKUP/ENTER BLOCK STARTING LOCATION
	
	IFN P-17,<PRINTX %AC P IS NOT AC 17>

; OUTPUT CHANNEL INFORMATION
	TY==1		;OUTPUT CHANNEL
	TYB==2		;NUMBER OF OUTPUT BUFFERS

; CODE TO LOCK UUO
	LOCCOD==LK.LLS!LK.LNE!LK.LNP	;LOCK ONLY


; EXTERNAL DECLARATIONS
	
	EXTERNAL .JBREL, .JBFF,.JBOPS,.JBDDT
;
;
; OTHER STUFF
	; JOBSTATUS BITS
	JDC==100000
	CMWB==200000
	CLKR==1B18
	JDCON==20000
	JLOG==1B15
	SWP==1B7
	RUN==1B0
	SHRSEG==1B1


SUBTTL DEFINE BITS IN FLAG REGISTER
; MACRO TO DEFINE SINGLE BIT SWITCHES

	DEFINE SW.(NAME)<
	IFE ZZ, <PRINTX ?TOO MANY SWITCHES DEFINED FOR FLAG REGISTER>
	NAME==ZZ
	ZZ=ZZ*2
	>; END OF SW. MACRO DEFINITION

	ZZ==1	;INITIALIZE

	SW.(OPT.S)	;/S, STATISTICS WANTED FOR TRACKED JOB
	SW.(OPT.C)	;/C,  OUTPUT ONLY WHEN CHANGE IN TRACKED JOB
	SW.(OPT.I)	;/I,  DO RUNTIME AND DISK IO INCREMENTAL
	SW.(OPT.F)	;F,   FORCED LOOK AND PRINTOUT
	SW.(OPT.K)	;/K,  DO NOT EXIT  WHEN TRACKED JOB DISAPPEARS
	SW.(OPT.U)	;/U,   PRINT USER NAME AND PPN 
	SW.(OPT.P)	;/P,  WATCH PRIVELEGE BITS THIS JOB
	SW.(R.SUMM)	;WANT SUMMARY OF DB PRINTOUT
	SW.(L.TTY)	;TRACKING A TTY
	SW.(L.JOB)	;TRACKING A JOB
	SW.(L.PPN)	;TRACKING A PPN
	SW.(L.PROG)	;TRACKING A PROGRAM
	SW.(L.USRS)	;TRACKING ALL USERS
	SW.(REGET)	;REGET LAST CHARACTER SCANNED
	SW.(BRK)	;SET BY INPUT, BREAK CHARACTER SEEN
	SW.(KI.10)	;SET IF ON A KI 10 PROCESSOR
	SW.(T.FLG)	;TEMPORARY FLAG USED BY VARIOUS ROUTINES
	SW.(NO.RSP)	;RESPONSE TIME TABLES NOT IN THIS MONITOR
	SW.(Y.SPY)	;CAN DO SPY
	SW.(SYSD)	;DOING SYSTEM DATA GATHERING
	SW.(SYSD.I)	;JUST INITIALIZED SYSTEM DATA
	SW.(GT.OPT)	;CURRENT GETTAB IS FOR OPTIONAL TABLE
			;AND ITS NOT FATAL IF GETTAB FAILS
	SW.(F.TTY)	;FORCE OUTPUT TO TTY EVEN IF /SAVE OR /L IN EFFECT
	SW.(F.SPEC)	;A FILE SPEC WAS GIVEN ("=" SEEN)
	SW.(DEVTTY)	;OUTPUT DEVICE IS USER TTY
	SW.(MRET)	;DO AN EXIT 1, JUST BEFORE STARTING MAIN LOOP
			;SO AN UPRIVELEGED USER CAN DO "CCONT"  "DET" SEQUENCE
	SW.(R.LOCK)	;LOCKED JOB REQUESTED
;[rbp]	SW.(CPU.1)	;SET IF SECOND PROCESSOR EXISTS
	SW.(NO.PRF)	;OMIT PREFIX FROM ERROR MESSAGES (E=2)
	SW.(NO.LIN)	;OMIT REST OF LINE FROM ERROR MESSAGES (E=1)
	SW.(MD.TRC)	;MODE OF OUTPUT FILE IS TRACE (BINARY)
	SW.(INDFLG)	;INDIRECT FILE "@" IS BEING READ
	SW.(FT.VM)	;THIS SYSTEM SUPPORTS VM
	SW.(UHP)	;ON MEANS USER HEADER PROLOG IS PRINTED

	ZZ==ZZ	;SHOW NUMBER OF BITS IN USE

	;BITS TO BE MEMORIZED AND NOT FORGOTTEN BETWEEN COMMANDS

	STKDFL==KI.10!Y.SPY!F.TTY!FT.VM

SUBTTL TRACK TRACING FORMAT (BINARY FORMAT)


COMMENT @
	TRACK USES A SPECIAL FORMAT FOR ITS BINARY OUTPUT. THIS MEANS
THAT THE FORMAT IS NOT FIXED BY POSITION.
	 EACH TYPE OF DATA THAT CAN
BE OUTPUT WHEN TRACK IS IN TRACE MODE IS OF THE FORM:


	-----------------------------------------------------
	!      BLOCK TYPE 		                    !
	-----------------------------------------------------
	!	      LENGTH     (including header)	    !
	-----------------------------------------------------
	! FIRST DATA WORD				    !
	-----------------------------------------------------
	! NEXT DATA WORD				    !
	-----------------------------------------------------
	  ....ETC



DEPENDING ON WHAT SWITCHES ARE GIVEN TRACK, AND WHAT TYPE OF TRACKING
IS BEING DONE, CERTAIN DATA BLOCKS WILL NOT APPEAR IN ALL RUNS.
THERE MAY ALSO BE ZERO WORDS BETWEEN DATA BLOCKS.

@
;	711	REPORT START BLOCK.  ALWAYS PRESENT. ALWAYS FIRST.
;		FORMAT:
;
		%BTRK==711		;FIRST WORD. FLAG WORD
		%BTRKL==4		;BLOCK LENGTH
		  B%VER==1		;DATA WD 1. COPY OF .JBVER
		  B%TYP==2		;DATA WD. 2. TYPE OF TRACKING
		   B%%S==0		;(VALUE)SYSTEM TRACKING
		   B%%J==1		;(VALUE)TRACKING A JOB NUMBER
		   B%%U==2		;(VALUE)TRACKING USERS
		   B%%P==3		;(VALUE)TRACKING A PPN
		   B%%T==4		;(VALUE)TRACKING A TTY NUMBER



;	721	SYSTEM DATA INITIALIZATION BLOCK.   IF TRACKING THE
;		SYSTEM THEN THIS BLOCK WILL FOLLOW THE REPORT
;		START BLOCK.
;		ALWAYS PRESENT IN THIS CASE.
;		FORMAT:
;
;
		%BSI==721		;FIRST WORD. FLAG WORD
		%BSIL==13		;BLOCK LENGTH
		  B%MVER==1		;1ST DATA WORD. MONITOR VERSION
		  B%ASER==2		;2ND D.W. APR SERIAL NUMBER
		  B%MXJB==3		;3RD D.W. NR. OF JOBS MAXIMUM
		  B%MXTY==4		;4TH D.W.  "   " TTYS    "
		  B%UMEM==5		;5TH D.W. USER MEMORY AVAILABLE (WORDS)
		  B%TMEM==6		;6TH DW,TOTAL SYSTEM MEMORY (WORDS)
		  B%INT== 7		;7TH DW,PEEK INTERVAL IN SECS
		  B%GRP==10		;8TH DW,NUMBER OF INTERVALS/REPORT
		  B%TIME==11		;9TH DW,TIME IN NBS UNIV DATE TIME FORMAT.



;	731	SYSTEM DATA DISPLAY BLOCK.  EVERY TIME A REPORT IS
;		PRODUCED BY THE SYSTEM DISPLAY MODULE, THIS
;		BLOCK IS PRODUCED BEFORE ANY ITEM BLOCKS
;		ARE OUTPUT. WILL APPEAR ONCE PER OUTPUT REPORT.
;		FORMAT:


		%BSGO==731		;1ST WORD. FLAG WORD
		%BSGOL==7		;BLOCK LENGTH
		  B%RPT==1		;NUMBER OF THIS REPORT
		  B%FRM==2		;STARTING TIME OF REPORT
					;IN UNIVERSAL DATE-TIME FORMAT
		  B%TO==03		;ENDING TIME OF THIS REPORT IN
					;UNIVERSAL DATE-TIME FORMAT
		  B%CMX==4		;CURRENT CORMAX, IN WORDS
		  B%SCHD==5		;SCHED BITS

;
;	732	SCHED PARMS BLOCK FOR SCHED LIR TO 6.03
		%BSCD==732
		%BSCDL==45	;43 DATA ITEMS PLUS 2 OVRHD
; MODIFIED SEPT 79 TO TACK ON BACKGROUND BATCH CLASS AND SWAP TIME
; AT END OF RECORD

repeat 0,<	FORMAT OF BLOCK TYPE 732:

		+---------------------------------------------+
		!            micro scheduling interval        !
		+---------------------------------------------+
		+  5  (the # of words of class information):  !
		!---------------------------------------------!
		!bit 0:		fixed class		      !
		!bits 1-27:	class number		      !
		!bits 18-35:	class quota		      !
		!					      !
		!					      !
		+---------------------------------------------+
		!  2  (the # of words of quantum runtimes):   !
		+---------------------------------------------+
		!	quantum runtime: PQ1		      !
		!	quantum runtime: PQ2		      !
		+---------------------------------------------+
		!	minimum core usage per job            !
		+---------------------------------------------+
		!	minimum core usage multiplier         !
		+---------------------------------------------+
		!	min core usage requeue constant       !
		+---------------------------------------------+
		!	minimum core usage maximum            !
		+---------------------------------------------+
		!  3	(# words of quantum miltipliers):     !
		+---------------------------------------------+
		!left half:	queue number	              !
		!right half:	quantum multiplier            !
		!                                             !
		+---------------------------------------------!
		!  2	(# words of quantum runtimes):	      !
		+---------------------------------------------+
		!left half:	queue number                  !
		!right half:	maximum time slice            !
		+---------------------------------------------+
		!  5	(# words of secondary class quotas):  !
		+---------------------------------------------+
		!left half:	class number                  !
		!right half:	quota                         !
		!                                             !
		!                                             !
		!                                             !
		+---------------------------------------------+
		!time % to scan queue swapped in before sub-q !
		+---------------------------------------------+
		!	swap scan time                        !
		+---------------------------------------------+
		!	scheduler fairness factor             !
		+---------------------------------------------+
		!	swapper fairness factor               !
		+---------------------------------------------+
		!	in-core fairness factor               !
		+---------------------------------------------+
		!	SCDCOR	                              !
		+---------------------------------------------+
		!	class number for batch background subq!
		+---------------------------------------------+
		!	background batch swaptime interval    !
		+---------------------------------------------+

> ;end repeat 0



;	741	SYSTEM DATA ITEM REPORT. OCCURS ONCE FOR
;		EACH ITEM DISPLAYED. THIS BLOCK GIVES INFORMATION
;		ABOUT WHICH ITEM IS NEXT TO BE WRITTEN OUT. THERE ARE
;		AS MANY BLOCKS OF THIS TYPE AS THERE CALLS TO THE
;		DATA BLOCK (DB) OUTPUT ROUTINE.
;		FORMAT:
;
;
		%BITM==741		;1ST WORD. FLAG WORD
		%BITML==4		;BLOCK LENGTH
		 B%CODE==1		;1ST DW. THIS WORD CONTAINS A
					;FOUR CHARACTER ASCII (7 BIT)
					;CODE IDENTIFIEING THE ITEM
					;TO FOLLOW. IT IS CREATED BY THE
					;2ND ARGUMENT TO THE SYSDAT MACRO
		 B%AUX==2		;AN AUXILLIARY WORD THAT IS USED
					;WHEN THERE ARE MULTIPLE CALLS TO
					;THE DB OUTPUT ROUTINE PER ENTRY
					;IN THE SYSDAT MACRO. FOR INSTANCE
					;THE DISK UNIT ROUTINE PUTS THE
					;SIXBIT UNIT NAME HERE



;	751	SYSTEM DATA ITEM FREQUENCY BLOCK. THIS BLOCK APPEARS
;		A VARIABLE NUMBER OF TIMES. IT GIVES THE
;		FREQUENCY BREAKDOWN
;		IF THIS TYPE BLOCK APPEARS, THE FIRST SUCH BLOCK
;		APPEARS AFTER A %BITM TYPE BLOCK AND THE LAST SUCH BLOCK
;		PRECEEDS A TYPE %BSUM TYPE BLOCK.
;		NOTE: IF /SUMMARY SWITCH IS USED, THIS TYPE BLOCK
;		DOES NOT APPEAR AT ALL, AND THE %BSUM BLOCK FOLLOWS
;		THE %BITM IMMEDIATELY.
;		FORMAT:

		%BFRQ==751		;1ST WORD, FLAG WORD
		%BFRQL==5		;BLOCK LENGTH
		  B%LOW==1		;1ST DW,LOWER LIMIT OF VALUES
					;IN THE RANGE
		  B%HIGH==2		;2ND DW,UPPER LIMIT OF VALUES
					;IN THE RANGE
		  B%PER==3		;FLOATING POINT FORMAT
					;WORD. THE PERCENT OF ALL VALUES
					;SEEN IN THIS RANGE




;	761	TYPE SUMMARY BLOCK. THIS BLOCK APPEARS ONCE
;		FOR EVERY CALL TO THE DB OUTPUT ROUTINE, THAT IS ONCE
;		FOR EACH TYPE %BITM BLOCK. IT GIVES THE MEAN AND
;		STAND. DEVIATION FOR ALL INTERVALS IN THE REPORT

;		FORMAT:
;
		%BSUM==761		;THE HEADER FLAG WORD
		%BSUML==5		;BLOCK LENGTH
		  B%SAMP=1		;1ST DW,THE NR. OF SAMPLES TAKEN
		  B%MEAN==2		;FLT. PT. FORMAT MEAN OF ALL
					;SAMPLES IN THIS REPORT.
		  B%STDD==3		;FLT. PT. FORMAT STANDARD DEVIATION
					;IN VALUES INCLUDED IN THIS REPORT




;	771	TYPE SYSTEM DATA END OF REPORT BLOCK
;		THIS BLOCK CONVEYS NO USEFUL INFORMATION EXCEPT THAT THE
;		SYSTEM DATA REPORT IS OVER. ESSENTIALLY, ALL WORDS, ZEROR
;		OR NON-ZERO BETWEEN AND THE FIRST FLAG WORD
;		FOR EITHER A %BTRK OR %BSGO TYPE BLOCK CAN BE IGNORED.
;		;FORMAT:

		%BEND==771		;FLAG WORD
		%BENDL==2		;LENGTH OF BLOCK DATA
					;NOTE:NO DATA WORDS.

; NOTE: AT THIS TIME THE ONLY BINARY TRACE FILE FACILITIES
;	INCLUDED IN TRACK ARE THOSE FOR SYSTEM TRACKING. A FUTURE
;	VERSION MAY INCLUDE TRACE SUPPORT FOR
;	OTHER TYPES.

SUBTTL DEFAULT DECLARATIONS
;
;************ DEFAULT VALUES AND SWITCH SETTINGS *************

	ND	PDSIZE,30		;DEFAULT PDL SIZE
	ND	PURESW,0		;1 FOR RE-ENTRANT, 0 IF NOT
	ND	SYS,1			;1 TO INCLUDE SYSDAT MODULE
	ND	DFLTQJ,^D10		;DEFAULT SLEEP INTERVAL JOBS
	ND	DFLTQU,^D60		;DEFAULT FOR USERS
	ND	DFLTQS,^D10		;  "        "  SYSTEM
	ND	DEFLTR,^D30		;DEFAULT LOOKS PER SYSDAT REPORT
	ND	CHNMAX,7		;MAXIMUM NUMBER OF CHANNELS ON SYSTEM
	ND	GETUNI,^D8		;NUMBER OF UNITS TO GRAB CORE FOR
					;NEED MORE CORE
					; FOR UNIT WATCHING TABLES

	ND	FTTRC,-1		;INCLUDE /FORMAT:TRACE FACILITIES
	ND	MAXTOK,^D14		;MAX. CHRS PER SWITCH
	ND	MAXSFD,7		;MAXIMUM NR. OF SFDS
	ND	DFILE,'TRACK '		;DEFAULT LISTING FILE
	ND	DEXT,'TXT   '		;AND EXT
	ND	DEXTT,'TRC   '		;EXT IF IN TRACE MODE
	ND	DDEV,'TTY   '		;DEFAULT OUTPUT DEVICE
	ND	DDEVF,'DSK   '		;DEFAULT OUTPUT DEVICE IS
					;A FILE SPEC IS GIVEN
	ND	COMMAX,^D144		;MAX COMMAND LINE
;*************************************************************



SUBTTL ERROR MESSAGE MACRO AND FLAGS

; FLAGS FOR ERROR MESSAGE PROCESSOR
; THESE FLAGS ARE OF THREE TYPES
; 1)WHAT TYPE OF MESSAGE
; 2)WHAT TO TYPE AFTER MESSAGE (IE T1 IS NULL,OCTAL,SIXBIT ETC.)
; 3)WHAT TO DO AFTER ERROR (EXIT,RESTART,CONTINUE)
	
	ZZ==1		;START
	SW.(EF.FAT)	;FATAL ERROR
	SW.(EF.CMT)	;COMMENT MESSAGE
	SW.(EF.WRN)	;WARN MESSAGE
	SW.(EF.RST)	;AFTER MESSAGE, RESTART
	SW.(EF.EXT)	;AFTER MESSAGE, EXIT PROGRAM
	SW.(EF.CON)	;AFTER MESSAGE, RETURN CPOPJ FOR SHORT
			;AND CPOPJ1 FOR LONG MESSAGE
	SW.(EF.DEC)	;AT END TYPE T1 IN DECIMAL
	SW.(EF.OCT)	;AT END TYPE T1 IN OCTAL
	SW.(EF.SIX)	;AT END TYPE T1 IN SIXBIT
	SW.(EF.PPN)	;AT END TYPE T1 AS PPN
	SW.(EF.MEM)	;AT END TYPE MEMORY UNITS
	SW.(EF.STR)	;T1 POINTS TO STRING

; ERROR MESSAGE PROCESS DESTRYS T3,T4 AND RESPECTS
; ALL OTHER REGISTERS
;
; WHEN CALLING WITH FLAG "EF.CON" ; FINAL CRLF MUST BE LABELED "X$$'PREFIX"
;
	DEFINE $ERROR($FLAGS,$PREFIX,$TEXT)<
E$$'$PREFIX:
	MOVX	T4,$FLAGS	;;PICK UP FLAGS
 IFE BIGLST,<XLIST>
	JSP	T3,ERRMSG	;;GO PROCESS THE ERROR
IFNB <$TEXT>,<XWD ''$PREFIX'',[ASCIZ\$TEXT\]>
IFB <$TEXT>, <XWD ''$PREFIX'',[0]>
IFN $FLAGS&EF.CON, <	JRST	X$$'$PREFIX>
	LIST
>
	


SUBTTL UTILITY MACROS


	DEFINE	HELPME <
	MOVE	1,[SIXBIT/TRACK/]	;MUST BE AC 1
	PUSHJ	P,.HELPR##		;EXTERNAL ENTRY		>

; LOAD HELPER WITH .TEXT IF WE CAN, AND LOAD INTO PROPER SEGMENT

		IFN PURESW,<
			IFDEF .TEXT,<.TEXT \,REL:HELPER\>>
		IFE PURESW,<
			IFDEF .TEXT,<.TEXT \,REL:HELPER/SEG:LOW\>>

;
; MACRO TO PACK SIXBIT CHARACTERS INTO WORDS
; AT END ZZ IS NUMBER OF CHARACTERS PACKED

	DEFINE STASH(A)<

	ZZ=0
	.C==0
	.D==-1
	IRPC A,<
		ZZ=ZZ+1
		.D==.D+6
		.C==<.C!<''A''B<.D>>>
		IFE .D-^D35,<EXP .C
				.D==-1
				.C==0>>
		IFG .D,<EXP .C>
	PURGE .D,.C
	>
; MACRO TO SEND ONE CHARACTER TO THE OUTPUT DEVICE

	DEFINE TYPEC(AA)<
	MOVEI	CHR,"AA"
	XLIST
	PUSHJ	P,PUTCHR 
	LIST
    >;END OF TYPEC DEFINITION

; MACRO TO SEND ASCIZ TEXT TO THE OUTPUT DEVICE

	DEFINE TYPES(AA)<
	MOVEI	STR,[ASCIZ\AA\]
	XLIST
	PUSHJ	P,PUTSTR
	LIST
 > ; END OF TYPES DEFINITION


; MACRO TO SEND CONTENTS OF T1, IN BIANRY TO OUTPUT DEVICE

	DEFINE TRACE <
IFN FTTRC, <
	PUSHJ	P,BINWRT
	   >
>

; MACRO TO SEND A CONSTANT TO TRACE DEVICE. USES T1

	DEFINE	TRACEI(CONS)<
IFN FTTRC, <
	MOVX	T1,CONS
	XLIST
	TRACE
	LIST
	   >
>


; MACRO TO SEND CONTENTS OF MEMORY LOCATION TO TRACE. USES T1

	DEFINE TRACEM(MEM)<
IFN FTTRC, <
	MOVE	T1,MEM
	XLIST
	TRACE
	LIST
	   >
>

;MACRO TO SET UP THE FACT-STYLE HEADER 

DEFINE TRACEH(TYPE),<
	XLIST
	TRACEI	%B'TYPE		;;TYPE OF ENTRY
	TRACEI	%B'TYPE'L	;;LENGTH OF ENTRY
	LIST
>
SUBTTL MACRO TO SET UP THE JOB TRACKING DATA AREA
; THIS MACRO SETS UP THE STUFF FOR THE JOB DATA ROUTINES.
; IT SETS UP DATA AREAS FOR JOB TRACKING.
; NEW ENTRIES SHOULD CONTAIN THE FOLLOWING:
;	1)UP TO FOUR CHARACTERS OF NAME FOR FIELD
;		C.'NAME IS LOCATION OF CURRENT DATA FOR THAT FIELD
;		O.'NAME IS OFFSET (RELOCATED BY CONTENTS OF AC J)
;		 OF THAT DATA ITEM FOR EACH JOB TRACKED
;
;	2)LENGTH OF THE FIELD FOR OUTPUT PURPOSES (OCTAL)
;
;	3)FOR /COMPARE SWITCH , VALUE "COMP" MEANS COMPARE THIS OLD VS
;	 CURRENT VALUE AND IF DIFFERENT PRINT, "NOCOMP" MEANS IGNORE
;	 ANY DIFFERENCES IN THIS FIELD
;	 THIS IS FOR DEFAULT /COMPARE AND CAN BE OVERIDDEN
;	 WITH ARGUMENTS.

	COMP==1
	NOCOMP==0

	DEFINE DATUMS <
	IFE BIGLST,<XLIST>

	X	FST,0,NOCOMP		;FIRST PRINT OF JOB FLAG
	X	DAY,10,NOCOMP		;TIME OF DAY OF PEEK
	X	JOB,4,COMP		;JOB NUMBER
	X	TTY,6,COMP		;TTY LINE NUMBER
	X	PROG,6,COMP		;PROGRAM NAME
	X	STAT,2,NOCOMP		;STATUS
	X	NSWP,2,NOCOMP		;NOT SWAPPED, IE IN CORE
	X	LOW,0,NOCOMP		;LOW SEG SIZE
	X	HIGH,6,NOCOMP		;HI-SEG SIZE
	X	RT,11,NOCOMP		;RUNTIME
	X	RD,7,NOCOMP		;DISK READS
	X	WR,7,NOCOMP		;DISK WRITES
	X	PRV,0,COMP		;PRIVELEGE BITS
	X	KCT,11,NOCOMP		;KILO-CORE-TICS FOR JOB
	X	GOD,^D22,COMP		;JACCT LIT (SPACING WIDTH USED FOR RT/ET)
	X	TLM,^D12,NOCOMP		;TIME LIMIT SET FOR JOB
	X	PPN,^D16,COMP		;PPN OF USER
	X	NAM1,0,COMP		;FIRST HALF OF USER NAME
	X	NAM2,^D17,COMP		;SECOND HALF
	LIST
> ;END OF DATUMS DEFINITION



;SET UP DEFCMP (DEFINE COMPARE) WORD FOR USE BY COMPARE ROUTINE
;FOR EACH FIELD DEFINED IN DATUMS MACRO, A CORRESPONDING
;BIT = 1 MEANS COMPARE FOR /C , A BIT =0 MEANS
;DONT COMPARE
	%CHKCM==0
	ZZ==0
;
	DEFINE X(A,Y,C)<
	IFE ^D37-ZZ, <PRINTX ? TOO MANY FIELDS FOR COMPILING %CHKCM!>
	%CHKCM==%CHKCM!<<C>B<ZZ>>
	ZZ==ZZ+1
>
	DATUMS			;DEFINE THE WORD
	SHOW.(%CHKCM)		;AND THATS WHAT RESULTS
				;THIS WILL BE USED LATER FOR /COMPARE
				;DEFAULT VALUE
SUBTTL MACRO TO DEFINE THE SYSTEM TRACKING PARAMETERS
; THIS MACRO SETS UP THE STUFF FOR THE SYSTEM DATA ROUTINES
; FOR EACH ITEM YOU WISH TO HAVE 'TRACKED' FOR THE SYSTEM
; YOU MUST INCLUDE AN ENTRY HAVEING THE FORM:
;
; X OUTPUT LABEL,4 CHR NAME,ADDR OF INITIALIZATION ROUTINE,
;	ADDR OF FETCH DATA ROUTINE,ADDR OF OUTPUT ROUTINE, RANGE FOR DATA
;	POINTS TO BE GROUPED TOGETHER

; A) OUTPUT LABEL WILL BE PRINTED ON THE REPORT
; B) NAME WILL BE USED TO CREATE UNIQUE TABLE NAMES
; C) INITIALIZATION ROUTINE (IF NON-ZERO) WILL BE PUSHJ P'ED TO
;    ONCE FOR EACH COMMAND STRING.
; D) FETCH ROUTINE (IF NON-ZERO) WILL PUSHJ P'ED TO EVERY LOOK
; E) OUTPUT ROUTINE (IF NON-ZERO) WILL BE PUSHJ P'D TO EVERY REPORT
;
; THE FOLLOWING TABLES ARE CREATED:
; 
; XXXX.N	TABLE OF POINTERS TO LABELS
; XXXX.I	TABLE OF INITIA ROUTINE ADDRESSES
; XXXX.P	TABLE OF POINTERS TO DATA AREA FOR EACH ITEM
;		EACH ENTRY IN THIS TABLE SHOULD BE OF THE FORM: L,,ADDR
;		THE INITIALIZATION ROUTINE HAS THE RESPONSIBILITY
;		OF CORRECTLY SETTING UP THIS WORD
;		L WILL ALWAYS CONTAIN THE LOOK NUMBER WE ARE DOING
;		AND ADDR THE START OF THE BLOCK "# OF LOOKS/REPORT"
;		LONG USED FOR HOLDING THE DATA SEEN FOR EACH LOOK
;
; XXXX.G	TABLE OF ADDRESSES OF DATA GATHERING ROUTINES
;		PUSHJ P'ED TO EACH LOOK (IF NON-ZERO)
; XXXX.D	SAME AS ABOVE, PUSHJ P'ED TO EVERY TIME WE REPORT
; XXXX.V	TABLE CONTAINING THE RANGE OVER WHICH TO
;		GROUP DATA POINTS TOGETHER WHEN MAKING OUTPUT
;		REPORTS
;
; XXXX.C	A TABLE OF 4 LETTER,LEFT JUSTIFIED SIXBIT
;		CODES IS CREATED FOR IDENTIFYING ITEMS IN THE TRACE
;		FORMAT REPORT AND FOR ARGUMENTS TO /INCLUDE,EXCLUDE
;		THIS TABLE IS MADE UP FROM THE 4 LETTER
;		SECOND ARGUMENT TO THE SYSDAT MACRO

; EACH TABLE IS PRECEDED BY THE LABEL 'TAB.X' AND ITS LENGTH IS
; LEN.X   
; ALSO, WHEN ROUTINES ARE BEING EXECUTED, INDEX REGISTER J
; WILL CONTAIN THE ITEM WE ARE WORKING, AND INDEX REGISTER L
; WILL CONTAIN THE NUMBER OF THE CURRENT LOOK

;
;
; SEE FOLLOWING CODE FOR DEFINITIONS OF AVAILABLE ROUTINES AND
; FOR VARIABLES ALWAYS AVAILABLE FOR ROUTINES TO USE
;


	DEFINE SYSDAT <
	IFE BIGLST,< XLIST>

X USER CPU JIFFIES/SECOND,CPUT,CPUT%I,CPUT%G,OUTDBI,^D10

X PERCENT IDLE TIME ON CPU0,CP0I,DBCORE,CP0I%G,OUTDBI,5
X PERCENT IDLE TIME ON CPU1,CP1I,CP1INI,CP1I%G,OUTDBI,5
X PERCENT IDLE TIME ON CPU2,CP2I,CP2INI,CP2I%G,OUTDBI,5
X PERCENT IDLE TIME ON CPU3,CP3I,CP3INI,CP3I%G,OUTDBI,5
X PERCENT IDLE TIME ON CPU4,CP4I,CP4INI,CP4I%G,OUTDBI,5
X PERCENT IDLE TIME ON CPU5,CP5I,CP5INI,CP5I%G,OUTDBI,5

X PERCENT LOST TIME ON CPU0,CP0L,DBCORE,CP0L%G,OUTDBI,5
X PERCENT LOST TIME ON CPU1,CP1L,CP1INI,CP1L%G,OUTDBI,5
X PERCENT LOST TIME ON CPU2,CP2L,CP2INI,CP2L%G,OUTDBI,5
X PERCENT LOST TIME ON CPU3,CP3L,CP3INI,CP3L%G,OUTDBI,5
X PERCENT LOST TIME ON CPU4,CP4L,CP4INI,CP4L%G,OUTDBI,5
X PERCENT LOST TIME ON CPU5,CP5L,CP5INI,CP5L%G,OUTDBI,5

X CPU0 EXEC TIME(%),EXEC,EXEC%I,EXEC%G,OUTDBF,^D10
X CPU1 EXEC TIME(%),EXE1,EXE1%I,EXE1%G,OUTDBF,^D10
X CPU2 EXEC TIME(%),EXE2,EXE2%I,EXE2%G,OUTDBF,^D10
X CPU3 EXEC TIME(%),EXE3,EXE3%I,EXE3%G,OUTDBF,^D10
X CPU4 EXEC TIME(%),EXE4,EXE4%I,EXE4%G,OUTDBF,^D10
X CPU5 EXEC TIME(%),EXE5,EXE5%I,EXE5%G,OUTDBF,^D10

X CPU0 MBOX REFS(K/SEC),MBXR,MBXR%I,MBXR%G,OUTDBF,^D10
X CPU1 MBOX REFS(K/SEC),MBX1,MBX1%I,MBX1%G,OUTDBF,^D10
X CPU2 MBOX REFS(K/SEC),MBX2,MBX2%I,MBX2%G,OUTDBF,^D10
X CPU3 MBOX REFS(K/SEC),MBX3,MBX3%I,MBX3%G,OUTDBF,^D10
X CPU4 MBOX REFS(K/SEC),MBX4,MBX4%I,MBX4%G,OUTDBF,^D10
X CPU5 MBOX REFS(K/SEC),MBX5,MBX5%I,MBX5%G,OUTDBF,^D10

X PERCENT OVERHEAD TIME ON CPU0,CP0O,DBCORE,CP0O%G,OUTDBI,5
X PERCENT OVERHEAD TIME ON CPU1,CP1O,CP1INI,CP1O%G,OUTDBI,5
X PERCENT OVERHEAD TIME ON CPU2,CP2O,CP2INI,CP2O%G,OUTDBI,5
X PERCENT OVERHEAD TIME ON CPU3,CP3O,CP3INI,CP3O%G,OUTDBI,5
X PERCENT OVERHEAD TIME ON CPU4,CP4O,CP4INI,CP4O%G,OUTDBI,5
X PERCENT OVERHEAD TIME ON CPU5,CP5O,CP5INI,CP5O%G,OUTDBI,5

X CONTEXT SWITCHES PER SECOND ON CPU0,CP0C,DBCORE,CP0C%G,OUTDBI,^D10
X CONTEXT SWITCHES PER SECOND ON CPU1,CP1C,CP1INI,CP1C%G,OUTDBI,^D10
X CONTEXT SWITCHES PER SECOND ON CPU2,CP2C,CP2INI,CP2C%G,OUTDBI,^D20
X CONTEXT SWITCHES PER SECOND ON CPU3,CP3C,CP3INI,CP3C%G,OUTDBI,^D30
X CONTEXT SWITCHES PER SECOND ON CPU4,CP4C,CP4INI,CP4C%G,OUTDBI,^D40
X CONTEXT SWITCHES PER SECOND ON CPU5,CP5C,CP5INI,CP5C%G,OUTDBI,^D50

X UUOS PER SECOND ON CPU0,CP0U,DBCORE,CP0U%G,OUTDBI,^D10
X UUOS PER SECOND ON CPU1,CP1U,CP1INI,CP1U%G,OUTDBI,^D10
X UUOS PER SECOND ON CPU2,CP2U,CP2INI,CP2U%G,OUTDBI,^D20
X UUOS PER SECOND ON CPU3,CP3U,CP3INI,CP3U%G,OUTDBI,^D30
X UUOS PER SECOND ON CPU4,CP4U,CP4INI,CP4U%G,OUTDBI,^D40
X UUOS PER SECOND ON CPU5,CP5U,CP5INI,CP5U%G,OUTDBI,^D50

X CACHE SWEEPS PER SECOND ON CPU0,L0SN,CL0INI,L0SN%G,OUTDBI,^D10
X CACHE SWEEPS PER SECOND ON CPU1,L1SN,CL1INI,L1SN%G,OUTDBI,^D10
X CACHE SWEEPS PER SECOND ON CPU2,L2SN,cl2ini,l2SN%G,OUTDBI,^D10
X CACHE SWEEPS PER SECOND ON CPU3,L3SN,cl3INI,l3SN%G,OUTDBI,^D10
X CACHE SWEEPS PER SECOND ON CPU4,L4SN,cl4INI,l4SN%G,OUTDBI,^D10
X CACHE SWEEPS PER SECOND ON CPU5,L5SN,cl5INI,l5SN%G,OUTDBI,^D10

X CACHE SWEEP REQUESTS PER SECOND BY CPU0 SCHEDULER,L0LN,CL1INI,L0LN%G,OUTDBI,^D10
X CACHE SWEEP REQUESTS PER SECOND BY CPU1 SCHEDULER,L1LN,CL1INI,L1LN%G,OUTDBI,^D10
X CACHE SWEEP REQUESTS PER SECOND BY CPU2 SCHEDULER,L2LN,CL2INI,L2LN%G,OUTDBI,^D20
X CACHE SWEEP REQUESTS PER SECOND BY CPU3 SCHEDULER,L3LN,CL3INI,L3LN%G,OUTDBI,^D30
X CACHE SWEEP REQUESTS PER SECOND BY CPU4 SCHEDULER,L4LN,CL4INI,L4LN%G,OUTDBI,^D40
X CACHE SWEEP REQUESTS PER SECOND BY CPU5 SCHEDULER,L5LN,CL5INI,L5LN%G,OUTDBI,^D50

X CACHE SWEEP REQUESTS CPU0 SWEPT FOR PER SECOND,L0RN,CL1INI,L0RN%G,OUTDBI,^D10
X CACHE SWEEP REQUESTS CPU1 SWEPT FOR PER SECOND,L1RN,CL1INI,L1RN%G,OUTDBI,^D10
X CACHE SWEEP REQUESTS CPU2 SWEPT FOR PER SECOND,L2RN,CL2INI,l2RN%G,OUTDBI,^D10
X CACHE SWEEP REQUESTS CPU3 SWEPT FOR PER SECOND,L3RN,CL3INI,l3RN%G,OUTDBI,^D10
X CACHE SWEEP REQUESTS CPU4 SWEPT FOR PER SECOND,L4RN,CL4INI,l4RN%G,OUTDBI,^D10
X CACHE SWEEP REQUESTS CPU5 SWEPT FOR PER SECOND,L5RN,CL5INI,l5RN%G,OUTDBI,^D10

X PERCENT CACHE LOST TIME ON CPU1,L1LT,CL1INI,L1LT%G,OUTDBI,5
X PERCENT CACHE LOST TIME ON CPU2,L2LT,CL2INI,L2LT%G,OUTDBI,5
X PERCENT CACHE LOST TIME ON CPU3,L3LT,CL3INI,L3LT%G,OUTDBI,5
X PERCENT CACHE LOST TIME ON CPU4,L4LT,CL4INI,L4LT%G,OUTDBI,5
X PERCENT CACHE LOST TIME ON CPU5,L5LT,CL5INI,L5LT%G,OUTDBI,5

X DECTAPE GENERATED SLEEPS(#),SDGS,SDGS%I,SDGS%G,OUTDBI,^D10
X MAGTAPE GENERATED SLEEPS(#),SMGS,SMGS%I,SMGS%G,OUTDBI,^D10
X EVENT WAIT SATISFIED(#),SEWS,SEWS%I,SEWS%G,OUTDBI,^D10
X TTY INPUT WAIT SATISFIED(#),STIS,STIS%I,STIS%G,OUTDBI,^D10
X TTY OUTPUT WAIT SATISFIED(#),STOS,STOS%I,STOS%G,OUTDBI,^D10
X PTY INPUT WAIT SATISFIED(#),SPIS,SPIS%I,SPIS%G,OUTDBI,^D10
X PTY OUTPUT WAIT SATISFIED(#),SPOS,SPOS%I,SPOS%G,OUTDBI,^D10
X SS REQUEUE TO PQ1(#),SRS1,SRS1%I,SRS1%G,OUTDBI,^D10
X WAKE REQUEUE TO PQ1(#),SRW1,SRW1%I,SRW1%G,OUTDBI,^D10
X DAEMON SATISFIED REQUEUE TO PQ1(#),SRD1,SRD1%I,SRD1%G,OUTDBI,^D10
X ALL OTHER REQUEUE TO PQ1(#),SRO1,SRO1%I,SRO1%G,OUTDBI,^D10

X PQ1 JOBS EXPIRING QUANTUM(#),SQR1,SQR1%I,SQR1%G,OUTDBI,^D10
X PQ2 JOBS EXPIRING QUANTUM(#),SQR2,SQR2%I,SQR2%G,OUTDBI,^D10
X HPQ JOBS EXPIRING QUANTUM(#),SQRH,SQRH%I,SQRH%G,OUTDBI,^D10

X PQ1 JOBS EXPIRING ICPT(#),SIP1,SIP1%I,SIP1%G,OUTDBI,^D10
X PQ2 JOBS EXPIRING ICPT(#),SIP2,SIP2%I,SIP2%G,OUTDBI,^D10
X HPQ JOBS EXPIRING ICPT(#),SIPH,SIPH%I,SIPH%G,OUTDBI,^D10

X PQ1 SWAP IN MEMORY(K)(#),SKS1,SKS1%I,SKS1%G,OUTDBI,^D10
X PQ2 SWAP IN MEMORY(K)(#),SKS2,SKS2%I,SKS2%G,OUTDBI,^D10
X HPQ SWAP IN MEMORY(K)(#),SKSH,SKSH%I,SKSH%G,OUTDBI,^D10

X PQ1 JOBS SWAPPED IN(#),SNJ1,SNJ1%I,SNJ1%G,OUTDBI,^D10
X PQ2 JOBS SWAPPED IN(#),SNJ2,SNJ2%I,SNJ2%G,OUTDBI,^D10
X HPQ JOBS SWAPPED IN(#),SNJH,SNJH%I,SNJH%G,OUTDBI,^D10

X PQ1 EBOX/MBOX TICKS CHARGED(#),STC1,STC1%I,STC1%G,OUTDBI,^D10
X PQ2 EBOX/MBOX TICKS CHARGED(#),STC2,STC2%I,STC2%G,OUTDBI,^D10
X HPQ EBOX/MBOX TICKS CHARGED(#),STCH,STCH%I,STCH%G,OUTDBI,^D10

X AVERAGE WASTED CORE(PAGES),WASK,WASK%I,WASK%G,OUTDBI,^D10
X AVERAGE PQ1/CMQ SWAP IN RESPONSE(TICKS),CPSI,CPSI%I,CPSI%G,OUTDBI,^D10
X SWAPPING SPACE LEFT (PAGES),SWPS,DBCORE,SWPS%G,OUTDBF,^D50
X CACHE SWEEP REQUESTS BY SWAPPER PER SECOND,L0SD,CL1INI,L0SD%G,OUTDBI,^D10
X SWAPPER NULL TIME,SWPN,SWPN%I,SWPN%G,OUTDBI,^D10
X SWAPPER LOST TIME,SWPL,SWPL%I,SWPL%G,OUTDBI,^D10
X UNWIND COUNT,UNWD,UNWD%I,UNWD%G,OUTDBI,1
X SWAPPER FORCE COUNT,SWPF,SWPF%I,SWPF%G,OUTDBI,1
X PERCENT OF FREE CORE IN USE,PFCU,PFCU%I,PFCU%G,OUTDBF,5
X PERCENT TTY CHUNKS IN USE,PTCU,PTCU%I,PTCU%G,OUTDBF,5
X SCANNER SERVICE XMT INTERUPTS/SEC,SXMT,DBCORE,SXMT%G,OUTDBI,^D50
X SCANNER SERVICE RCV INTERUPTS/SEC,SRCV,DBCORE,SRCV%G,OUTDBI,^D50
X USER DISK BLOCKS PER SECOND,UDIO,UDIO%I,UDIO%G,OUTDBI,^D25
X SWAPPING BLOCKS PER SECOND,SWIO,SWIO%I,SWIO%G,OUTDBI,^D25
X USER KCS PER SECOND,UKCS,UKCS%I,UKCS%G,OUTDBI,5
X TERMINAL RESPONSE TIME (MS),RESP,DBCORE,RESP%G,OUTDBI,^D100
X AVERAGE RESPONSE TIME (MILLISECONDS),AVRT,DBCORE,AVRT%G,OUTDBI,^D25
X NUMBER OF JOBS LOGGED IN,JLGN,DBCORE,JLGN%G,OUTDBF,1
X PERCENT OF PHYS. CORE IN USE BY ACTIVE JOBS,ACCR,DBCORE,ACCR%G,OUTDBF,^D20
X PERCENT OF PHYS. CORE IN USE BY ALL JOBS,PHCR,DBCORE,PHCR%G,OUTDBF,^D20
X AVERAGE JOB SIZE (TO NEAREST UNIT),AVJS,DBCORE,AVJS%G,OUTDBF,^D5
X NR OF JOBS IN RUN QUEUES,NRJR,DBCORE,NRJR%G,OUTDBF,1
X PERCENT OF RUNNABLE JOBS IN CORE,PRJC,DBCORE,PRJC%G,OUTDBF,^D5
X JOBS IN TTY IO WAIT,TIOW,DBCORE,TIOW%G,OUTDBF,^D1
X JOBS IN IO WAIT OTHER THAN TTY,IOW,DBCORE,IOW%G,OUTDBF,^D1
X JOBS IN SHAREABLE RESOURCE QUEUES,JSHQ,DBCORE,JSHQ%G,OUTDBF,^D1
X 0,DISK,DISK%I,DISK%G,DISK%D,1		;% busy for each disk unit
X 0,CHAN,CHAN%I,CHAN%G,CHAN%D,1		;% busy for each channel



	LIST
> ;END OF SYSDAT MACRO

; POSSIBLE START OF HIGH SEGMENT CODE
	IFN  PURESW, 	<TWOSEG
			RELOC	400000>

SUBTTL INITIALIZE AND GET COMMAND STRING


TRACK:	JFCL				;IN CASE CCL ENTRY
	RESET
	MOVE	T1,[XWD LOWBEG,LOWBEG+1];CLEAR IMPURE AREA
	SETZB	SW,LOWBEG		;IN CASE OF RESTART
	BLT	T1,LOWEND		;ZAP
	MOVE	T1,.JBFF		;PICK UP JOBFF
	MOVEM	T1,SAVFF		;AND REMEMBER IT
	MOVEI	T1,DEBBLK		;DEBUG VARIABLES
	MOVEM	T1,.JBOPS##		;FOR CATASTROPHES
	JUMPPT	(T1,K.CORE,K.CORE,P.CORE,P.CORE) ;EXAMINE PROCESSOR
P.CORE:	TXOA	SW,KI.10		;SET IT DOWN , ITS PAGES
K.CORE:	TROA	CHR,"K"			;MEMORY UNIT FOR K OF CORE
	MOVEI	CHR,"P"			;FOR PAGES THE SYMBOL IS "P"
	MOVEM	CHR,MEMUNI		;FOR PRINTOUT ROUTINES
	MOVE	P,[IOWD PDSIZE,PDL]	;SET UP PUSHDOWN LIST
IFE PURESW,<
	PUSHJ	P,SETTAB		;SET UP GETTABS
>
	MOVX	GT,%CCTYP		;GET CPU TYPE
	PUSHJ	P,FETTAB
	MOVEM	GT,CPUTYP		;REMEMBER IT
	MOVX	GT,%CNST2		;LOOKUP FT TABLE
	PUSHJ	P,FETTAB
	TXNE	GT,ST%VMS		;CONTAINS VMSER?
	TXO	SW,FT.VM		;YES, REMEMBER THAT
	MOVX	GT,%CNLNP		;LOOK UP NUMBER OF LINES
	PUSHJ	P,FETTAB		;FROM MONITOR
	HLROS	GT			;MAKE FULL WORD NEGATIVE
	MOVMM	GT,MAXTTY		;MAXTTY BECOMES LARGEST TTY NR
	SOS	MAXTTY			;AFTER ACCOUNTING FOR ZERO
	MOVX	GT,%CNSJN		;DO SAME FOR NUMBER OF JOBS
	PUSHJ	P,FETTAB		;I.E. GET MAXIMUM NUMBER
	HRRM	GT,MAXJOB		;STORE FOR LATER GOOD THINGS
	SOS	MAXJOB			;ACCOUNT FOR NULL JOB
	PJOB	T1,			;SAVE OUR JOB
	MOVEM	T1,MYJOB		;FOR LATER USE
	GETPPN	T1,			;SAVE PPN
	 JFCL
	MOVEM	T1,MYPPN		;ALSO


TRACK1:	SETZM	LOOKS			;CLEAR ALL
	SETZM	HPQREQ			;
	SETZM	AVAL			;CLEAR /SAVE SWITCH
	SETZM	SDISK			;DEFAULT IS SYSTEM DISKS
	MOVEI	T1,DFLTQJ		;PICK UP DEFAULT SLEEP TIME FOR A JOB
	MOVEM	T1,QTUM
	MOVEI	T1,DEFLTR		;PICK UP DEFAULT LOOKS/REPORT
	MOVEM	T1,RVAL			;FOR SYSDAT STUFF
	SETZM	DEFCMP			;NO COMPARISON BITS DEFINED
IFN SYS,<
	MOVE	T1,[TAB.P,,TAB.P+1]	;CLEAR POINTERS FOR CORE TABLES (DB'S)
	SETZM	TAB.P			;TO CLEAR EXCLUDE/INCLUDES
	BLT	T1,TAB.P+LEN.P-1	;AND ALLOCATIONS
	SETOM	CHAN.P			;START OUT EXCLUDING CHANNEL
	SETOM	DISK.P			;AND DISK STUFF
     > ; END OF SYS CONDITIONAL
	AND	SW,[STKDFL]		;CLEAR ALL BUT STICKY DEFAULTS
	SETOM	C.FST			;SET FIRST FLAG
TRACK2:	PUSHJ	P,GETLIN		;LOAD COMMAND LINE
	PUSHJ	P,PRESCAN		;PRESCAN FOR FILESPEC
	  TXO	SW,F.SPEC		;MARK AS PRESENT
	MOVE	T1,[XWD [.IOASC
		         DDEV
			 Z
			 DFILE
		         DEXT
			 Z
			 Z],FILMOD]	;LOAD DEFAULT FILE SPECS
	BLT	T1,FILPPN		;INTO FILE BLOCK
	TXNN	SW,F.SPEC		;FILE SPEC GIVEN?
	JRST	NOSPEC			;NO
	MOVX	T1,DDEVF		;LOAD DEFAULT FILE DEVICE
	MOVEM	T1,FILDEV		;
	PUSHJ	P,FILSPC		;GET FILE SPECIFICATION
	PUSHJ	P,GETCHR		;GET NEXT CHARACTER
	CAIE	CHR,"="			;IS IT DELIMITER "=" 
	JRST  [$ERROR(EF.FAT!EF.RST,FDM,FILE SPECIFICATION DELIMITER "="  MISSING)]
NOSPEC:	MOVE	N1,COMPTR		;SAVE THE COMMAND POINTER
	PUSHJ	P,GETCHR		;GET A CHARACTER
	TXNE	SW,BRK			;BREAK CHARACTER?
	JRST	RESTRT			;YES,RECYCLE
	CAIL	CHR,"0"			;COULD BE JUST A NUMBER
	CAILE	CHR,"9"			;FOR JOB NUMBER TO WATCH
	SKIPA
	JRST	TJOBS			;AND IT IS
	MOVEM	N1,COMPTR		;RESTORE THE COMMAND POINTER
	PUSHJ	P,TOKEN			;GET FIRST TOKEN
	JUMPE	T1,[ MOVEI T1,-" "(CHR)  ;IF NOT ALPHANUMERIC
		     LSH T1,^D30
		     JRST NOSPC1]	;USE TOKEN'S DELIMITER
	TXO	SW,REGET		;DELIMITER STILL VALID
NOSPC1:	MOVE	T2,[-CSDLEN,,CSNAME]	;GET READY FOR TABLE LOOKUP
	PUSHJ	P,TABLUK		;LOOK IT UP
	 JRST	[ JUMPL T1,[$ERROR(EF.FAT!EF.RST,CNU,COMMAND NOT UNIQUE)]
		  JRST BADCOM]
	JRST	@CSDISP(T1)		;DISPATCH ON COMMAND
BADCOM:	MOVEI	T1,LASTOK		;PICK UP LAST TOKEN
	$ERROR(EF.FAT!EF.RST!EF.STR,UCS,UNKNOWN COMMAND )

 ; DEFINE COMMANDS
	DEFINE CSCREATE<
	IFE BIGLST, <XLIST>

X	(MYPPN,TMPPNS)	;; "MYPPN"
X	(SYSTEM,TSYS)	;; "SYSTEM"
X	(#,TTTYS)	;;#NN (TTYNN)
X	(/,TRYHLP)	;;/SWITCH
X	([,TPPNS)	;;[P,PN] 
X	(<'>,TPROG)	;;'PROGRAM'
X	(PPN,TPPNS)	;;PPN[P,N]
X	(DEBUG,TDDT)	;;DDT
X	(USERS,TUSERS)	;;USERS
X	(<.>,TMYJOB)	;;TRACK YOURSELF
X	(<@>,TIND)	;;INDIRECT FILE SPECIFICATION
X	(EXIT,FINISH)	;;EXIT FROM TRACK

	LIST
> ; END OF CSCREATE DEFINITION


; NOW MAKE THE TABLE

	DEFINE  X(AA,BB)< SIXBIT\AA\>

CSNAME:	CSCREATE
	CSDLEN==.-CSNAME

	DEFINE X(AA,BB)< XWD 0,BB>

CSDISP:	CSCREATE

TRYHLP:	PUSHJ	P,GETSW			;GET SWITCH
	CAIE	CHR,"/"			;ANOTHER SWITCH?
	JRST	RESTRT			;NO
	JRST	TRYHLP			;YES


TMYJOB:	MOVE	T1,MYJOB		;TRACK YOURSELF
	MOVEM	T1,SAVNUM		;STORE IT
	TXO	SW,L.JOB		;LOOKING AT JOB
	PUSHJ	P,GETCHR		;LOAD CHARACTER
	JRST	SWCHK			;PROCESS SWITCHES

TPROG:	PUSHJ	P,TOKEN			;GET THE PROGRAM NAME
	JUMPE	T1,[$ERROR(EF.FAT!EF.RST,IPN,ILLEGAL PROGRAM NAME)]
	MOVEM	T1,SAVPOP		;STORE IT AWAY
	TXO	SW,L.PROG		;WATCHING A PROGRAM
	CAIN	CHR,"'"			;DELIMITED BY MATCHING '?
	PUSHJ	P,GETCHR		;YES,EAT IT
	JRST	TUSE.1			;JOIN COMMON MULTIPLE JOB CODE


TPPNS:	PUSHJ	P,OCTIN			;GET FIRST HALF (PROJ)
	JUMPN	T1,TPPNS1		;IF NOT, BLANK CONTINUE
	CAIN	CHR,"*"			;BLANK DELIMITED BY STAR?
	SOJA	T1,[PUSHJ P,GETCHR	;GET DELIMITER
		    JRST TPPNS1 ]	;ALL FILLED IN WITH -1
	HLR	T1,MYPPN		;ELSE USE MY PPN
TPPNS1:	CAIE	CHR,","			;DELIMITED BY COMMA
	JRST	BPPN			;NOPE
	HRLZM	T1,SAVPOP		;STASH IT
	PUSHJ	P,OCTIN			;GET PROGRAMMER NUMBER
	JUMPN	T1,TPPNS2		;IF GIVEN, JUST CONTINUE
	CAIN	CHR,"*"			;DELIMITED BY STAR?
	SOJA	T1,[PUSHJ P,GETCHR	;EAT THE STAR
		    JRST TPPNS2]	;AND CONTINUE
	HRR	T1,MYPPN		;GET PROG NUMBER RUNNING UNDER
TPPNS2:	TXNN	SW,BRK			;BREAK SEEN ?, OR
	CAIN	CHR,"]"			;DELIMITED BY ]
	CAIA
	JRST	BPPN
	HRRM	T1,SAVPOP		;AND DONE WITH PPN!
	JRST	TMPSET			;AND CONTINUE WITH INITITALIZATION

TMPPNS:	MOVE	T1,MYPPN		;USE OWN PPN
	MOVEM	T1,SAVPOP
TMPSET:	TXO	SW,L.PPN		;WATCHING PPN
	TXNN	SW,BRK			;BREAK?
	PUSHJ	P,GETCHR		;NO,LOAD CHAR
	JRST	TUSE.1			;JOIN COMMON MULTI-JOB CODE

BPPN:	$ERROR(EF.FAT!EF.RST,BPN,BAD FORMAT FOR PROJECT-PROGRAMMER NUMBER)


TSYS:
IFN SYS, <
	TXO	SW,SYSD			;DOING SYSTEM DATA
	MOVEI	T1,DFLTQS		;RESET DEFAULT SLEEP TIME
	MOVEM	T1,QTUM
	PUSHJ	P,GETCHR		;LOAD NEXT CHR
	JRST	SWCHK			;GO PICK UP SWITCHES  >
IFE SYS, <
	$ERROR(EF.FAT!EF.RST,SNI,SYSTEM TRACKING NOT INCLUDED IN THIS VERSION)
>; IF NOT INCLUDED (IE FT SYS=0)

TUSERS:	TXO	SW,L.USRS		;TURN ON USERS 
	MOVEI	T1,DFLTQU		;LOAD INTERVER FOR USERS
	MOVEM	T1,QTUM			;BECAUSE ITS LONGER
	PUSHJ	P,GETCHR		;GET NEXT CHARACTER LOADED
TUSE.1:	MOVEI	T1,1			;START WITH JOB 1
	MOVEM	T1,SAVNUM
	JRST	SWCHK			;START WITH SWITCHES

TDDT:	PUSHJ	P,EATLIN		;EAT REST OF LINE
	SKIPN	N1,.JBDDT##		;DEBUGGER LOADED?
	JRST	[$ERROR(EF.FAT!EF.RST,DNL,DEBUGGER NOT LOADED)] ;NO
	$ERROR(EF.CMT,DEB,ENTERING DEBUGGER)
	JRST	(N1)			;ENTER DDT
XDDT:	JRST	TRACK1			;SO " XCT XDDT$X" GOES BACK
					;TO COMMAND LEVEL


TIND:	MOVE	T1,[XWD [.IOASC
			 SIXBIT/DSK   /
			 0,,TYBUF
			 SIXBIT/TRACK/
			 SIXBIT/CCL/
			 0
			 0],FILMOD]
	BLT	T1,FILPPN
	PUSHJ	P,FILSPC		;LOAD DEFAULTS,GET USER SPEC
	PUSHJ	P,GETCHR		;SEE IF ENDS W/BREAK
	TXNN	SW,BRK			;
	JRST	BADCOM			;NO
	PUSHJ	P,REDUCE		;GET RID OF EXCESS CORE
	TXO	SW,INDFLG		;MARK INDIRECT FILE ACTIVE
	JRST	TRACK2			;AND GET COMMANDS

TJOBS:	TXO	SW,REGET+L.JOB		;LOOKING FOR JOB,REGET THE FIRST DIGIT
	JRST	GETNUM			;GET JOB NUMBER

TTTYS:	TXO	SW,L.TTY		;SET SWITCH FOR TTY LOOKS
	PUSHJ	P,OCTIN			;TTY #S ARE OCTAL
	SKIPA
GETNUM:	PUSHJ	P,DECIN			;GET DECIMAL JOB NO.
	MOVEM	T1,SAVNUM		;SAVE FOR GOOD THINGS
	TXNE	SW,L.TTY		;LOOKING AT TTY?
	JRST	VALTTY			;YES
	SKIPL	T1			;NO, DOING JOB. IS THIS NR. TOO LOW?
	CAMLE	T1,MAXJOB		;OR TOO HIGH?
	JRST	[MOVE	T1,MAXJOB  ;SET UP AND DO ERROR MESSAGE
	 $ERROR(EF.FAT!EF.RST!EF.DEC,JMR,JOB NUMBER MUST BE IN RANGE 0-)]
	JRST	SWCHK			;NO,ITS OK

VALTTY:	SKIPL	T1			;ALSO MUST BE IN RANGE 0-MAXTTY
	CAMLE	T1,MAXTTY		;
	JRST	[MOVE T1,MAXTTY
	 $ERROR(EF.FAT!EF.RST!EF.OCT,TMR,TTY NUMBER MUST BE IN RANGE 0-)]
SWCHK:	TXNE	SW,BRK			;BREAK CHR ENDS THINGS
	JRST	START			;BUT IT WASNT
	CAIE	CHR,"/"			;MIGHT BE SWITCH
	JRST	BADCOM			;BUT IT WASNT
	PUSHJ	P,GETSW			;PICK UP SWITCH
	JRST	SWCHK			;GET NEXT SWITCH OR END

SUBTTL INITIALIZE PRIOR TO COMMENCEING TRACK LOOP

START:	RELEAS	TY,			;CLOSE OUTPUT
	PUSHJ	P,REDUCE		;REDUCE CORE TO STARTING SIZE
	TXNE	SW,OPT.S		;DO STATISTICS?
	TXNN	SW,NO.RSP		;ARE RESPONSE TIMES OFF
	JRST	STATOK
	$ERROR(EF.WRN,JRU,JOB RUN QUEUE TIME UNAVAILABLE)
STATOK:	PUSHJ	P,FILOPN		;OPEN FILE
	TXZ	SW,F.TTY		;DONT FORCE OUTPUT TO TTY
	TXNN	SW,L.USRS!L.JOB!L.TTY!L.PPN!L.PROG ;JOB TRACKING?
	JRST	STRT1			;NO.SKIP THE OLD DATA AREA SETUP
	MOVEI	T1,SIZDAT		;SIZE OF BLOCK PER JOB
	TXNE	SW,L.USRS!L.PPN!L.PROG	;NEED FOR ALL JOBS?
	IMUL	T1,MAXJOB		;YES,MULTIPLY
	PUSHJ	P,ASSCOR		;GET THE CORE
	MOVEM	T1,OLDPTR		;SAVE THE POINTER
STRT1:	TRACEH	(TRK)			;[*]OUTPUT FILE START HEADER
	TRACEM	.JBVER##		;PUT OUT VERSION OF TRACK
	TRACEI	B%%S			;SAY ITS A SYSTEM TRACK
IFN SYS, <
	TXNE	SW,SYSD			;DOING SYSTEM DATA?
	PUSHJ	P,SYSINI		;YES,GO START UP >
	TXNE	SW,MRET			;[*]DOES THE USER WISH A MONRET. (EXIT 1,)?
	SKIPE	STRTED			;[*] YES-BUT IS THIS THE FIRST TIME?
	JRST	GODO			;START
	$ERROR(EF.CMT,PTC,PLEASE TYPE CONTINUE TO COMMENCE TRACKING)
	EXIT	1,			;HERE IS THE MONRET.
GODO:	SETOM	STRTED			;[*]INDICATE THAT WE ARE STARTED.
	SKIPN	T1,HPQREQ		;ASK FOR HPQ?
	JRST	NOHPQ			;NO
	HPQ	T1,			;TRY IT
	 JRST	[ MOVE	T1,HPQREQ	;GET HPQ REQUESTED
	  $ERROR(EF.WRN!EF.OCT,HPQ,CANNOT SET TO HPQ)
		  JRST	NOHPQ]		;RETURN
NOHPQ:	TXNN	SW,R.LOCK		;LOCK REQUESTED?
	JRST	NOLOCK			;NO
IFN PURESW, <
	MOVE	T1,[XWD LOCCOD,LOCCOD]	>;LOCK BOTH SEGMENTS
IFE PURESW, <
	MOVEI	T1,LOCCOD		;LOCK LOW SEGMENT
	LOCK	T1,			;LOCK HIM
	 JRST	[$ERROR(EF.WRN!EF.OCT,CLJ,<CANNOT LOCK JOB, ERROR CODE=>)
		 JRST NOLOCK]	;AND RETURN
NOLOCK:	TXNE	SW,DEVTTY!MRET		;TO TTY OR DETACHED?
	JRST	STRT2			;YES,SKIP BANNER
	$ERROR(EF.CMT,TRK,TRACKING...)
STRT2:	MSTIME	T1,
	MOVEM	T1,SAVST		;SAVE START TIME
IFN FTTRC, <
	TXNN	SW,MD.TRC		;DOING TRACE?
	JRST	MAIN			;NO,SKIP EXTRA UUO
	MOVX	GT,%CNDTM		;FOR TRACE, USE UNIVERSAL DATE-TIME
	PUSHJ	P,FETTAB
	MOVEM	GT,SAVSTU		;SAVE UNIVERSAL START TIME
> ;END OF CONDITIONAL ON FTTRC
	JRST	MAIN			;START PROCESSING
SUBTTL RESTART,EXIT AND FILE ROUTINES
; HERE TO CLOSE OUTPUT, RELEASE DEVICE AND EXIT

FINISH:	CLOSE	TY,			;CLOSE FILE
	RELEAS	TY,			;RELEASE CHANNEL
	EXIT

; HERE TO UNLOCK, CLEAN UP AND GO BACK TO COMMAND LEVEL
;

RESTRT:	CLOSE	TY,			;CLOSE FILES
	RELEAS	TY,
	TXO	SW,F.TTY		;FORCE OUTPUT TO TTY
	TXNN	SW,R.LOCK		;WAS I LOCKED?
	SKIPE	HPQREQ			;OR IN HPQ?
	RESET				;YES, UNDO THE CONDITION
	MOVE	P,[IOWD PDSIZE,PDL]	;RE-SET UP PDP
	PUSHJ	P,REDUCE		;RESTORE SIZE
	JRST	TRACK1			;AND READY FOR NEXT COMMAND



; ROUTINE TO OPEN,LOOKUP AND APPEND THE OUTPUT REPORT

FILOPN:	MOVE	T1,FILDEV		;LOAD T1 WITH DEVICE
	MOVE	N1,T1			;GET COPY
	DEVCHR	N1,			;LOOK UP
	JUMPE	N1,[$ERROR(EF.FAT!EF.SIX!EF.RST,DDE,DEVICE DOES NOT EXIST: )]
	TXNN	N1,DV.OUT		;DOES OUTPUT?
	JRST	[$ERROR(EF.FAT!EF.SIX!EF.RST,CDO,DEVICE CANNOT DO OUTPUT: )]
	MOVE	T2,FILMOD		;CHECK MODE
	MOVEI	T3,1			;FOR LEGALITY
	LSH	T3,(T2)
	TRNN	N1,(T3)			;
	JRST	[$ERROR(EF.FAT!EF.SIX!EF.RST,IDM,ILLEGAL DATA MODE FOR DEVICE )]
	TXNE	N1,DV.TTA		;USER TTY?
	TXO	SW,DEVTTY		;YES,SET FLAG
	MOVE	LUEB,FILMOD		;[*]GET MODE
	MOVE	LUEB+1,FILDEV		;[*]AND DEVICE
	MOVSI	LUEB+2,TYBUF		;[*]POINT TO BUFFER
	OPEN	TY,LUEB			;[*]OPEN THE FILE
	 JRST	[MOVE T1,FILDEV
		 $ERROR(EF.FAT!EF.SIX!EF.RST,OPN,OPEN FAILED FOR DEVICE )]
	OUTBUF	TY,TYB			;[*]SET BUFFERS
	SETOM	FSTFLG			;[*]SET FIRST LOOKUP FLAG
	PUSHJ	P,FSAV1			;[*]AND OPEN FILE
	TXNN	N1,DV.DIR		;[*]WILL LOOKUP NEVER FAIL?
	POPJ	P,			;[*]RIGHT-SKIP MS
	SKIPN	FSTFLG			;[*]DID WE APPEND?
	POPJ	P,			;[*]NO
	$ERROR(EF.WRN,APP,APPENDING TO EXISTING OUTPUT FILE)
	MOVEI	CHR,14			;[*]
	PJRST	PUTCHR			;[*]OUTPUT IT AND RETURN

; THIS ROUTINE CLOSES THE OUTPUT FILE, RE-OPENS IT IN APPEND MODE

FILSAV:	SKIPGE	AVAL			;-1 MEANS SAVE EVERY TIME
	JRST	FSAVA			;[*]ELSE SAVE EVERY TIME
	SKIPG	AVAL
	POPJ	P,			;SHOULDN'T REALLY HAPPEN
	SOSE	AVALC			;DECREMENT COUNTER AND IF NOT 0
	POPJ	P,			;RETURN IMMEDIATELY
	MOVE	T1,AVAL			;PICK UP MASTER COUNT
	MOVEM	T1,AVALC		;AND RESET COUNTER
FSAVA:	MOVEI	T1,1			;[*]MAKE FSTFLG BE POS.
	MOVEM	T1,FSTFLG
FSAV1:	PUSHJ	P,GENNAM		;[*]MAKE UP A 'MMDDYY' NAME IF /DAILY
	MOVE	LUEB,FILNAM		;[*]RE-OPEN
	MOVE	LUEB+1,FILEXT		;[*]
	MOVE	LUEB+2,FILDAT		;[*]LOAD
	MOVE	LUEB+3,FILPPN		;[*]REST OF BLOCK
	LOOKUP	TY,LUEB			;[*]LOOKUP THEN ENTER
	 JRST	NOTHR			;[*]IT AINT THERE...
FSAV2:	MOVE	LUEB+1,FILEXT		;[*]RELOAD
	MOVE	LUEB+2,FILDAT		;[*]
	MOVE	LUEB+3,FILPPN		;[*]
	ENTER	TY,LUEB			;[*]AND HERES THE ENTER
	  JRST	E$$OPE			;[*]GIVES US UPDATE MODE
	SKIPE	FSTFLG			;[*]IF FIRST LOOKUP FAILED SKIP, ELSE
	USETI	TY,-1			;[*] DO APPENDING
	POPJ	P,			;[*]AND RETURN TO CALLER

NOTHR:	AOSN FSTFLG			;[*]FIRST LOOKUP?
	 JRST FSAV2			;[*]YES-NO PROBLEM
	HRRZ	T1,LUEB+1		;[*]GET ERROR CODE
	JUMPN	T1,LUPERR		;[*]OTHER THAN FILE NOT FOUND
	POP	P,(P)			;[*]WE AINT RETURNING...
	JRST	START			;[*]JUST RESTARTING

SUBTTL DAILY SWITCH ROUTINE FILE HANDLING

;[*]THIS ROUTINE WILL GENERATE A 'MMDDYY' TYPE FILENAME
GENNAM:	SKIPL	DAILYF			;[*]DID HE WANT /DAILY?
	POPJ	P,			;[*]NOPE
	MOVX	GT,%CNDAY		;[*]WHAT IS TODAY?
	PUSHJ	P,FETTAB		;[*]ASK MON
	CAMN	GT,TODAY		;[*]SAME AS LAST LOOP?
	POPJ	P,			;[*]THEN SKIP ALL THIS B/S
	EXCH	GT,TODAY		;[*]UPDATE TODAY, AND LOOK AT LAST
	JUMPN	GT,NOTFST		;[*]GT=0 IMPLIES FIRST LOOP...
	MOVE	LUEB,FILNAM		;[*]GET FILE NAME ASKED
	MOVE	LUEB+1,FILEXT		;[*]FOR BY USER TO SEE
	MOVE	LUEB+2,FILDAT		;[*]IF IT ALREADY
	MOVE	LUEB+3,FILPPN		;[*]EXISTS
	LOOKUP	TY,LUEB			;[*]CHECK...
	 JRST 	NOREN			;[*]ASSUME NO FILE W/ OLD NAME
	PUSHJ	P,DATCHK		;[*]ITS THERE-CHECK CREATION DATE...
	JRST	NOREN			;[*]ITS NOT THERE ANYMORE UNLESS IT
					;[*]WAS CREATED TODAY...
;[*]HERE IF THIS IS NOT THE FIRST LOOP, AND THE DATE JUST CHANGED (MIDNITE)
;[*]IN THIS CASE RENAME CURRENT FILE TO 'NEWNAME'...
NOTFST:	MOVE	LUEB,NEWNAM		;[*]THE NAME
	TXNE	SW,MD.TRC		;[*]ARE WE TRACING OR TEXTING
	SKIPA	LUEB+1,[DEXTT]		;[*]TRACING
	MOVE	LUEB+1,[DEXT]		;[*]TEXTING
	MOVE	LUEB+2,FILDAT		;[*]
	MOVE	LUEB+3,FILPPN		;[*]MKE IT LOOK LIKE USER WANTS
	RENAME	TY,LUEB			;[*]RENAME IT
	 JRST	RENERR			;[*]ERROR CONDITION
NOREN:	MOVE	T1,[POINT 6,NEWNAM]	;[*]TO BUILD THE NAME
	MOVX	GT,%CNMON		;[*]MONTH FIRST
	PUSHJ	P,FETTAB		;[*]ASK THE MON...
	PUSHJ	P,BLDNAM		;[*]ADD TO THE NAME
	MOVE	GT,TODAY		;[*]WE ALREADY HAVE TODAY
	PUSHJ	P,BLDNAM		;[*]ADD ON
	MOVX	GT,%CNYER		;[*]AND NOW FOR YEAR...
	PUSHJ	P,FETTAB		;[*]GET IT FROM THE MONITR.
	SUBI	GT,^D1900		;[*]- 1900 TO MAKE JUST 2 DIGITS
	PUSHJ	P,BLDNAM		;[*]ADD ON
	POPJ	P,

BLDNAM:	IDIVI	GT,^D10			;[*]GET EACH DIGIT...
	ADDI	GT,20			;[*]ASCIZIZE FIRST ONE
	IDPB	GT,T1			;[*]AND LOAD
	ADDI	GT+1,20			;[*]TAKE THE REMAINDER=2ND DIG
	IDPB	GT+1,T1			;[*]SAME
	POPJ	P,

;[*]THIS ROUTINE WILL CHECK THE CREATION DATE OF THE FILE, AND IF
;[*]IT IS NOT EQUAL TO TODAY, IT WILL RENAME THAT FILE TO A MMDDYY NAME
;[*]CORRESPONDING TO ITS CREATION...
DATCHK:	LDB	T2,[POINT 3,LUEB+1,20]	;[*]GET THE CREAT DATE FOR FIL
	LSH	T2,^D12
	ANDI	LUEB+2,007777		;[*]MASK OUT ALL BUT LOW 12 BITS
	IOR	T2,LUEB+2		;[*]AND OR IN THE FIRST 12 BITS
	DATE	T1,			;[*]GET TODAYS DATE
	CAMN	T1,T2			;[*]DIFFERENT?
	POPJ	P,			;[*]NO=NOTHING
	IDIVI	T2,^D31*^D12		;[*]TO GET YEARS
	IDIVI	T3,^D31			;[*]AND DAYS
	ADDI	T2,^D64			;[*]CORRECT FOR 1964 START
	ADDI	T3,1			;[*]AND FOR 0 OFFSET MONTH
	ADDI	T4,1			;[*]AND DAY
	MOVE	T1,[POINT 6,NEWNAM]	;[*]PREPARE TO BUILD NAME
	MOVE	GT,T3				;[*]GET MONTH
	PUSHJ	P,BLDNAM
	MOVE	GT,T4			;[*]AND DAY
	PUSHJ	P,BLDNAM
	MOVE	GT,T2			;[*]AND YEAR
	PUSHJ	P,BLDNAM
	MOVE	LUEB,NEWNAM		;[*]PREP FOR RENAME
	TXNE	SW,MD.TRC		;[*]GET THE RIGHT EXT
	SKIPA	LUEB+1,[DEXTT]
	MOVE	LUEB+1,[DEXT]
	MOVE	LUEB+2,FILDAT		;[*]GET ALL THE LUEB
	MOVE	LUEB+3,FILPPN		;[*]STUFF...
	RENAME	TY,LUEB			;[*]RENAME THE BOOGER
	 JRST	RENERR			;[*]ERROR ON RENAME
	POPJ	P,			;[*]VOILA

SUBTTL MAIN PROGRAM LOOP


MAIN:	SKIPE	AVAL			;[*]IS SAVING DONE?
	SKIPG	FSTFLG			;[*]IF SO: IS THIS FIRST TIME?
	CAIA				;[*]YES...
	PUSHJ	P,FILSAV		;[*]SAVE FILES

IFN FTTRC, <
	TXNN	SW,MD.TRC		;DOING TRACE?
	JRST	NTRC1			;NO
	MOVX	GT,%CNDTM		;FOR TRACE, GET UDT
	PUSHJ	P,FETTAB
	MOVEM	GT,SAVUPU		;AS SAVE IT
NTRC1:
> ;END OF CONDITIONAL ON FTTRC
	SETZM	CTRKJ			;NOT CURRENTLY TRACKING JOB
	TXNE	SW,L.USRS!L.PPN!L.PROG	;TRACKING ALL USERS?
	TXO	SW,UHP			;YES, REMEMBER WE NEED HEADER
	MSTIME	T1,			;GET TIME OF DAY
	MOVEM	T1,SAVUP		;TIME WE START LOOP
	SKIPA				;SKIP A UUO, WE JUST DID MSTIME
MAIN1A:	MSTIME	T1,			;USER TYPE THINGS
	MOVEM	T1,C.DAY		;AND STORE
IFN SYS, <
	TXNE	SW,SYSD			;DOING SYSTEM DATA?
	JRST	SYSGET			;YES,DO IT NOTE ,WE RETURN  
					;AFTER GATHERING AT REJOIN
	>; END OF SYS CONDITIONAL
	MOVE	T1,SAVNUM		;GET MAGIC NUMBER
	PUSHJ	P,SETJ			;SET UP AC J FOR RELOCATION
	TXNE	SW,L.JOB!L.USRS!L.PPN!L.PROG 	;WATCHING JOB?
	JRST	WJOB			;YES
	TXNE	SW,L.TTY		;WATCHING TTY
	JRST	WTTY			;YES
WJOB:	MOVEM	T1,C.JOB		;STORE AS JOB NUMBER.
	PUSHJ	P,GETTY			;GET ASSOC. TTY #
	  JRST	GONJOB			;??JOB IS GONE
	JRST	MAIN1			;GOT IT
WTTY:	MOVEM	T1,C.TTY		;STORE AS TTY NUMBER
	PUSHJ	P,GETJOB		;GET ASSOC. JOB
	  JRST	GONJOB			;??JOB IS GONE
MAIN1:	SETOM	CTRKJ			;TRACKING A JOB
	PUSHJ	P,GETCOR		;GET CORE SIZE OF JOB
	PUSHJ	P,GETSTA		;GET STATUS
	PUSHJ	P,GETRUN		;GET RUN-TIME
	PUSHJ	P,GETNAM		;GET PROGRAM NAME
	PUSHJ	P,GETSTC		;GET RUN STATISTICS
	PUSHJ	P,GETPRV		;GET THEM
	PUSHJ	P,GETDSK		;GET DSK STATS
	PUSHJ	P,GETU			;GET IT
	PUSHJ	P,CHK2			;MAKE SURE SAME JOB
	MOVE	N1,SAVPOP		;GET SAVED PPN OR PROGRAM
	TXNN	SW,L.PROG		;WATCHING PROGRAM?
	JRST	MAIN0A			;NO
	CAME	N1,C.PROG		;PROGRAM MATCH?
	JRST	MCONT			;NO, DISCARD IT
MAIN0A:	TXNN	SW,L.PPN		;WATCHING PPN?
	JRST	MAIN0B			;NO, GO ON
	SETCA	N1,			;GET COMPLEMENT OF PPN
	TLCN	N1,-1			;WAS PROJ NUMBER WILD?
	HLL	N1,C.PPN		;YES, INSURE MATCH
	TRCN	N1,-1			;WAS PROG NUMBER WILD?
	HRR	N1,C.PPN		;YES, INSURE MATCH
	CAME	N1,C.PPN		;A MATCH ON PPN?
	JRST	MCONT			;NO, DISCARD THIS JOB
MAIN0B:	TXNN	SW,OPT.C		;IF COMPARE IS ON
	JRST	MAIN2			;DONT JUMP YET
	PUSHJ	P,COMPR			;DO COMPARE
	  JRST	MCONT			;SAME, SKIP PRINT-OUT
MAIN2:	TXZE	SW,UHP			;IS USER HEADER PROLOG NEEDED?
	PUSHJ	P,USRPRO		;YES, PRINT IT
	PUSHJ	P,PRNT			;PRINT JOB  DATA
MCONT:	SETZM	C.FST			;SHUT OFF FIRST SWITCH
	MOVSI	N1,CURDAT		;PREPARE TO MAKE OLD=NEW
	HRRI	N1,OLDAT(J)
	BLT	N1,OLDAT+SIZDAT-1(J)	;DONE
REJOIN:	TXZE	SW,OPT.F		;[*]IF JUST DID A FORCED,
	TXZ	SW,F.TTY		;[*]FIX UP TO NORMAL OUTPUT
	TXNN	SW,L.USRS!L.PROG!L.PPN	;[*]DOING USERS?
	JRST	NOTUSR			;[*]NO
	AOS	T2,SAVNUM		;INCREMENT JOB NUMBER
	CAMG	T2,MAXJOB		;
	JRST	MAIN1A			;DO NEXT JOB
	MOVEI	T2,1			;START OVER
	MOVEM	T2,SAVNUM		;AFTER SLEEP/EXIT CHECK
	SETZM	CTRKJ			;CLEAR CURRENT-JOB-ACTIVE FLAG
NOTUSR:	SKIPN	LOOKS			;[*]ZERO LOOKS = INFINITE
	JRST	SLEEPY			;[*]SO JUST CONTINUE
	SOSG	LOOKS			;[*]WHEN ZERO EXIT
	JRST	FINISH			;[*] GO AWAY
SLEEPY:	SKIPE	AVAL			;[*]IF WE ARE SAVING...
	CLOSE	TY,			;[*]RELEASE THE FILE WHILE SLEEPING
	MOVEI	N1,1			;[*]A NON ZERO QUANTITY
	MOVEM	N1,FSTFLG		;[*]TO ALLOW FILSAV TO DO ITS STUFF
	MOVE	N1,QTUM			;[*]GET SLEEP TIME
	JUMPE	N1,SLP2			;[*]IF NO SLEEP
	MULI	N1,^D1000		;MAKE MSEC
	MSTIME	T1,			;GET DAYTIME
	MOVEM	T1,SLPTIM		;STORE AS TIME WE WENT TO SLEEP
	SUB	T1,SAVUP		;T1 NOW HAS TIME SPENT
					;IN LOOKING AND PRINTING
	JUMPGE	T1,.+2			;IF NEGATIVE
	ADDX	T1,^D1000*^D60*^D60*^D24 ;WE WENT AROUND MIDNITE
	SUB	N2,T1			;CORRECT SLEEP TIME
	JUMPLE	N2,SLP2			;CHECK FOR NEG OR ZERO SLEEP TIME
	MOVEM	N2,SLPQT		;SAVE
RSLEEP:	CAILE	N2,^D63000		;IF LESS < 63K MS
	JRST	UDAEM			;THEN DONT USE DAEMON
SLP1:	TXO	N2,<HB.RTL!HB.RTC>	;WAKE ON TTY ACTIVITY
	HIBER	N2,
	  JRST	USLP			;HIBER FAILED, USE SLEEP
SLP2:	INCHRS	CHR			;GET CHARACTER,SKIP IF ONE
	  JRST	MAIN			;AND DO AGAIN
	JRST	NEWSPC			;WANT NEW SPECS

UDAEM:	MOVEI	T1,N1			;SET UP FOR CLOCK REQUEST
	MOVX	N1,.CLOCK		;TIME FUNCTION
	DAEMON	T1,
	  JRST	USLP			;IF FAILURE
	SETZ	N2,			;SET FOR INFINITE SLEEP
	JRST	SLP1			;GO HIBERNATE
USLP:	MOVE	N1,QTUM			;GET SECS OF SLEEP
	CAILE	N1,77			;IF NOT IN 63 SEC BRACKET
	MOVEI	N1,77			;SET FOR MAX
	SLEEP	N1,
	JRST	SLP2			;AND CONTINUE


SUBTTL SYSTEM TRACKING **DATA GATHERING MODULE **
; DO THE SYSTEM DATA GATHERING IF WE WANT TO
; AND THE RETURN TO REJOIN TO CHECK TIMEING,EXITS ETC.
; NOTE THAT NO ITEM DEPENDENT ROUTINE IS CALLED IF TAB.P IS ZERO
; FOR THAT ITEM; THIS WAY, IF AN ITEM IS NOT AVAILABLE WHEN
; TRACK IS RUNNING ON A CERTAIN SYSTEM, THE INITIALIZATION ROUTINE
; CAN SIMPLY NOT ALLOCATE CORE FOR THE ITEM AND THE ITEM WILL NOT
; BE GATHERED.  THE SAME IS TRUE OF SYSDIS.



IFN SYS, <
SYSGET:	MOVX	GT, %NSHJB		;GET HIGHEST JOB NUMBER
	PUSHJ	P,FETTAB		;CAUSE MANY WANT TO KNOW
	MOVEM	GT,HIJOB		;THIS LOCATION AVAILABLE
	MOVX	GT, %CNLNM		;LOOKUP NUMBER OF JOBS TOO
	PUSHJ	P,FETTAB		;FOR ASR,SWR ETC
	MOVEM	GT,NUMJOB		;STORE THIS TOO
	MOVE	J,HIJOB			;SET UP J
LGNCHK:	MOVX	GT,.GTSTS		;LOOK UP STATUS
	HRLI	GT,(J)
	PUSHJ	P,FETTAB		;OF THIS JOB
	TXNN	GT,JLOG			;LOGGED IN?
	JRST	NOTLGN			;NO
	PUSH	P,GT			;SAVE STATUS WORD FOR LATER
	MOVEM	J,C.JOB			;ROUTINES EXPECT IT IN C.JOB
	PUSHJ	P,GETCOR		;GET HIS CORE ALLOCATION
	MOVE	T1,C.LOW		;AND STASH IT IN JOBTB1
	HRLM	T1,@JOBTB1		;LEFT HALF
	SKIPGE	T2,C.HIGH		;PICK UP HI CORE
	SETZ	T2,			;DONT BOTHER WITH SPY
	HRRM	T2,@JOBTB1		;HIGH CORE ALLOCATION
	PUSHJ	P,GETSTA		;GET HIS STATUS TOO
	MOVE	T1,C.STAT		;SO CAN DO ASR,Q INFO ETC
	HRL	T1,HISEGN		;HI-SEG # TO LH OF JOBTB2 ENTRY
	SKIPN	C.NSWP			;IF HES SWAPPED OUT
	TLO	T1,400000		;SIGN BIT OF JOBTB2 ENTRY GOES ON
	POP	P,GT			;JOB STATUS WORD
	TXNE	GT,RUN			;IN RUN STATE?
	TRO	T1,400000		;YES, BIT 18 OF JOBTB2 GOES ON
	MOVEM	T1,@JOBTB2		;STORE IT
	SKIPA				;SKIP SETTING NOT LOGGED IN BIT
	
NOTLGN:	SETOM	@JOBTB1			;INDICATE NOT LOGGED IN
	SOJG	J,LGNCHK		;BACK FOR NEXT JOB
	PUSHJ	P,ANALYZ		;CALL COMMON JOB ANALYSIS ROUTINE
	PUSHJ	P,CELPST		;GET ELAPSED TIME
	MOVSI	J,-LEN.G		;LENGTH OF GET TABLE
SYSG1:	SKIPLE	TAB.P(J)		;WAS THERE CORE ALLOCATED?
	SKIPN	TAB.G(J)		;AND IS THERE A ROUTINE TO XCT?
	JRST	SYSG2			;ONE OR THE OTHER IS NOT TRUE
	PUSHJ	P,@TAB.G(J)		;EXE2UTE PROPER ROUTINE
SYSG2:	AOBJN	J,SYSG1			;SEE IF MORE
	MOVEM	L,T.LOOK		;TOTAL LOOKS DONE (START W/0)
	MOVE	N1,CU.TIC		;FIX UP TIMERS FOR NEXT LOOK
	MOVEM	N1,LS.TIC		;LAST = CURRENT
	MOVE	N1,CU.MS		;
	MOVEM	N1,LS.MS		;ALL DONE
	SOSLE	RVALC			;DECREMENT COUNTER
	AOJA	L,REJOIN		;MORE LOOKS LEFT
	PUSHJ	P,SYSDIS		;ELSE DO A DISPLAY
	MOVE	T1,RVAL			;RESET REPORT COUNTER
	MOVEM	T1,RVALC		;TO WANTED VALUE
	SETZB	L,T.LOOK		;RESET INDEX TO DATA AREA
	MOVE	T1,SAVUP		;RESET START TIME
	MOVEM	T1,SAVST		;SAVE IT
IFN FTTRC, <
	MOVE	T1,SAVUPU		;FOR TRACE, ROTATE TIMES
	MOVEM	T1,SAVSTU		;
> ;END OF IFN FTTRC
	TXZ	SW,SYSD.I		;HAVE DONE AT LEAST ONE LOOK
	JRST	REJOIN			;THEN CONTINUE


; SUBROUTINE TO CALCULATE ELAPSED TIME BETWEEN NOW AND LAST SEEN
; VALUES OF MS AND TICS

CELPST:	MOVX	GT, %CNTIM		;MANY THINGS LIKE TICS
	PUSHJ	P,FETTAB		;SO USE TICS
	MOVEM	GT,CU.TIC		;STASHED
	SUB	GT,LS.TIC		;MAKE INCREMENTAL
	JUMPGE	GT,.+2			;IN CASE WENT PAST MIDNITE
	ADDX	GT,^D60*^D60*^D60*^D24	;ADJUST IT
	MOVEM	GT,EL.TIC		;ELAPSED TICS
	MSTIME	N1,			;CURRENT MS TIMER
	MOVEM	N1,CU.MS		;SET IT
	SUB	N1,LS.MS		;LAST SEEN MS
	JUMPGE	N1,.+2			;TAKE CARE OF NITE OWLS
	ADDX	N1,^D1000*^D60*^D60*^D24
	MOVEM	N1,EL.MS		;STASH IT
	POPJ	P,


 ;;STILL UNDER "IFN SYS" CONDITIONAL
SUBTTL SYSTEM TRACKING **DATA DISPLAY MODULE **

SYSDIS:	TRACEH	(SGO)			;[*]PUT ON A HEADER
	MOVEI	CHR,14			;GIVE A FORM-FEED
	PUSHJ	P,PUTCHR		;TO SEPARATE REPORTS
	TYPES	(<		STATUS FROM >);OUTPUT HEADER
	MOVE	T1,SAVST		;GET STARTING TIME
	PUSHJ	P,PUTDAY		;OUTPUT DAYTIME STARTED
	TYPES	(< TO >)
	MOVE	T1,SAVUP		;AND OUTPUT
	PUSHJ	P,PUTDAY		;DAYTIME STOPPED
	PUSHJ	P,CRLF
	TYPES	(<REPORT #>)		;GIVE SEQUENCE NUMBER
	AOS	T1,NLOOK		;PRINT NUMBER OF THIS REPORT
	TRACE				;SEND IT TO THE TRACE FILE
	PUSHJ	P,DECOUT		;AND TO LISTING
	TRACEM	SAVSTU			;FOR TRACE, GIVE UNIVERSAL REPORT
	TRACEM	SAVUPU			;START TIME & END TIME
	TXNE	SW,OPT.F		;WAS THIS FORCED?
	SOS	NLOOK			;FIX UP LOOK NUMBER
	TYPES	(<	UPTIME: >)	;PRINT UPTIME LABEL
	MOVX	GT, %NSUPT		;LOOKUP SYSTEM UPTIME
	PUSHJ	P,FETTAB		;
	MOVE	T1,GT			;CONVERT TICS TO MS
	IMULI	T1,^D100		;
	IDIVI	T1,^D6			;BY MULTIPLYING BY 16.666
	PUSHJ	P,PUTDAY		;PRINT IT HH:MM:SS
	TYPES	(<  CORMAX:>)		;ALSO TELL CORMAX
	MOVX	GT, %NSCMX		;BECAUSE IT TOO CHANGES
	PUSHJ	P,FETTAB		;
	MOVE	T1,GT			;OUTPUT AS K OR P
	TRACE				;CORMAX,IN WORDS, TO TRACE FILE
	PUSHJ	P,MEMPNT		;
	TYPES	(<	SCHED:>)	;TELL IF OPR THERE, ETC.
	MOVX	GT, %CNSTS		;
	PUSHJ	P,FETTAB		;SEE IF THERE
	ANDI	GT,777			;RIGHT MOST BITS OF WORD
	MOVE	T1,GT			;TO ARG REGISTER
	TRACE				;SCHED TO TRACE FILE
	PUSHJ	P,OCTOUT		;AND PRINT IT

	PUSHJ	P,SCDWRT		;GO MAKE SCHED BLOCK
	TYPES	(<
		STRUCTURES MOUNTED: >)
	MOVEI	CHRCNT,^D100
	SETZ	T1,			;START LIST
SMLOOP:	SYSSTR	T1,			;GET STRUCTURE NAME
	 JRST SMDONE			;UUO FAILURE , FAKE DONE
	JUMPE	T1,SMDONE		;OR IF EXHAUSETED
	CAILE	CHRCNT,^D41		;ROOM LEFT?
	JRST	[TYPES (<
			>)		; CRLF, 3<TAB>
		 SETZ CHRCNT,		; CLEAR COUNTER
	         JRST SMNOC]
	TYPEC	(<,>)			;COMMA
SMNOC:	PUSHJ	P,SIXPNT		;PRINT NAME
	JRST	SMLOOP			;BACK FOR MORE

SMDONE:	MOVX	GT, %NSKTM		;EXAMINE KSYS
	PUSHJ	P,FETTAB		;TIMER
	JUMPLE	GT,NOKSYS		;IF ZERO, NOT PENDING
	TYPES	(<
		KSYS: >)		;TELL IF SYSTEM GOING DOWN
	MOVE	N1,GT			;SO THEY KNOW WHATS DOING
	IDIVI	N1,^D60			;
	PUSH	P,N2			;SAVE MINUTES
	JUMPE	N1,NOHRS		;
	MOVE	T1,N1			;PRINT KSYS HRS
	PUSHJ	P,DECOUT
	TYPES	(< HRS. >)
NOHRS:	POP	P,T1			;AND MINUTES
	PUSHJ	P,DECOUT		;
	TYPES	(< MINS.>)		;AND IN WHAT UNITS
NOKSYS:	MOVEI	J,5			;GIVE 5 CRLFS
	PUSHJ	P,CRLF			;
	SOJG	J,.-1			;
	MOVSI	J,-LEN.D		;GET LENGTH OF DISPLAY TABLE

SYSDS1:	SKIPG	TAB.P(J)		;WAS THERE CORE ALLOCATED?
	JRST	SYSDS2			;NO, THERE IS NOTHING TO DISPLAY
	SKIPE	N1,TAB.D(J)		;GET AN ITEM AND IF NON-ZERO
	PUSHJ	P,(N1)			;DO IT
SYSDS2:	AOBJN	J,SYSDS1		;IF MORE TO DO
	TRACEH	(END)			;[*]AND A REP END HEADER
	POPJ	P,			;RETURN TO CALLER

;scheduler data output
SCDWRT:	MOVE	T1,[XWD SCDLEN,SCDBLK]
	SCHED.	T1,
	  JRST SCDDON
	TRACEH(SCD)
	MOVNI	T2,SCDL2
SCDMOR:	AOJGE	T2,SCDDON
	MOVE	T1,SCDEND(T2)
	PUSHJ	P,BINWRT
	JRST	SCDMOR
SCDDON:	POPJ	P,
;

 ;;STILL UNDER "IFN SYS" CONDITIONAL
SUBTTL SYSTEM TRACKING **DATA INITIALIZATION MODULE **
; ROUTINE TO DO INITIALIZATION OF DATA AREA

SYSINI:	
	TRACEH	(SI)			;[*]SYSTEM INIT HEADER
	PUSHJ	P,JOBBLK		;GET A BLOCK FOR JOBTB1
	MOVEM	T1,JOBTB1		;THIS BLOCK IS SET UP BEFORE GET ROUTINES
					;ARE CALLED.  SEE IMPURE SECTION
					;FOR DEFINITION OF JOBTB1,JOBTB2
	PUSHJ	P,JOBBLK		;GET SECOND BLOCK
	MOVEM	T1,JOBTB2		;STASH PTR WORD
	MOVX	GT,%CNCPU		;[217] GET NUMBER OF CPUS
	PUSHJ	P,FETTAB		;[217]
	MOVEM	GT,NCPU			;[217]
	MOVX	GT,%CNVER		;LOOK UP THE MONITOR VERSION
	PUSHJ	P,FETTAB		;FROM THE MONITOR
	TRACEM	GT			;PUT IT OUT TO THE TRACE FILE
	ANDI	GT,-1			;CLEAR THE LH
	MOVEM	GT,SYSVER		;AND STORE SIGNIFICANT PART
	MOVE	T1,RVAL			;SET COUNTER FOR REPORTS
	MOVEM	T1,RVALC		;NUMBER OF LOOKS/REPORT
	SETZB	L,T.LOOK		;SET OTHER COUNTERS
	SETZM	LS.TIC			;SET UP TIMERS
	SETZM	LS.MS			;CLEAR
	MOVSI	J,-5			;LOOK UP SYSTEM NAME
SINAMG:	MOVX	GT,%CNFG0		;A WORD OF NAME
	HRLZ	T2,J			;ADD OFFSET
	ADD	GT,T2			;FIN
	PUSHJ	P,FETTAB		;LOOK IT UP
	MOVEM	GT,SYSNAM(J)		;AND STORE IT
	AOBJN	J,SINAMG		;GO BACK TO SYSINI NAME GET
	MOVX	GT,%CNDT0		;GET DATE TOO
	PUSHJ	P,FETTAB
	MOVEM	GT,SYSDTE		;
	MOVX	GT,%CNDT1		;TWO WORDS
	PUSHJ	P,FETTAB
	MOVEM	GT,SYSDTE+1
	MOVX	GT, %CNSIZ		;ALSO LOOK UP SIZE
	PUSHJ	P,FETTAB		;LOOK UP
	MOVEM	GT,SYSSIZ		;AND STORE IT
	TYPES <
	REPORT ON SYSTEM PERFORMANCE AND UTILIZATION
	     BY TRACK %>
	MOVEI	T1,TRKVER		;GET VERSION NUMBER
	PUSHJ	P,OCTOUT		;AND PRINT IT
IFN TRKMIN, <
	MOVEI	T1,TRKMIN		;MINOR VERSION
	IDIVI	T1,^D27			;SEPARATE THE LETTERS
	JUMPE	T1,MIN01		;IF ZERO
	MOVEI	T1,'A'-1(T1)		;FOR OUTPUT
	PUSHJ	P,SIXPNT		;
	AOS	T2			;ADJUST FOR ROUNDING
MIN01:	SKIPN	T1,T2			;GET REST
	JRST	MIN02			;IF ZERO
	MOVEI	T1,'A'-1(T1)		;AND DO IT
	PUSHJ	P,SIXPNT		;FINISHED
MIN02:
>; END OF IFN TRKMIN
	TYPEC	(<(>)			;PRINT EDIT NR. TOO
	MOVEI	T1,TRKEDT		;THE EDIT NUMBER
	PUSHJ	P,OCTOUT		;OUT IT GOES
	TYPEC	(<)>)			;
IFN TRKWHO,<
	TYPEC	(-)			;PRINT MINOR VERSION
	MOVEI	T1,TRKWHO
	PUSHJ	P,OCTOUT		;DO IT
> ;END OF IFN TRKWHO
	TYPES	(< ON >)		;DAY IT IS
	MOVX	GT, %CNDAY		;GET DAY
	PUSHJ	P,FETTAB		;FROM MONITOR
	MOVEM	GT,T1			;AND OUTPUT AS DECIMAL
	PUSHJ	P,DECOUT		;DONE
	MOVX	GT, %CNMON		;AND MONTH
	PUSHJ	P,FETTAB		;OUR OWN GETTAB
	MOVE	T1,MONTAB-1(GT)		;PICK OUR MONTH
	PUSHJ	P,SIXPNT		;AND PRINT IT
	MOVX	GT, %CNYER		;GET YEAR
	PUSHJ	P,FETTAB		;DONE
	MOVE	T1,GT			;AND IT GETS PRINTED TOO
	SUBI	T1,^D1900		;MAKE IT 2 DIGIT
	PUSHJ	P,DECOUT		;FINISH
	TYPEC	(< >)			;ONE SPACE
	MOVX	GT,%CNSER		;[*]GET OUR APR SER NUM
	PUSHJ	P,FETTAB		;[*]FROM THE SYSTEM
	TRACEM	GT			;[*]AND PUT INTO TRACE FILE
	MOVX	GT, %CNDTM		;LOOK UP THE DAY OF WEEK
	PUSHJ	P,FETTAB		;VIA 15 BIT UNIVERSAL DATE
	HLRZ	N1,GT			;THEN DATE IN LEFT HALF
	IDIVI	N1,7			;THERE SHOULD BE 7 DAYS/WEEK
	MOVE	T1,DAYTAB(N2)		;FROM DAY TABLE
	PUSHJ	P,SIXPNT		;PRINT IT
	TYPES	(<

	      CONFIGURATION DATA FOR SYSTEM:>)
	TYPES	(<

SYSTEM RUNNING  >)
	MOVEI	STR,SYSNAM		;POINT TO SYSTEM NAME
	PUSHJ	P,PUTSTR		;AND PRINT IT
	TYPES	(< (>)
	MOVE	T1,SYSVER
	PUSHJ	P,OCTOUT
	TYPEC	(<)>)
	TYPES	(< BUILT ON >)
	MOVEI	STR,SYSDTE		;GIVE BUILD DATE
	PUSHJ	P,PUTSTR		;
	TYPES	(<
MAX. NUMBER OF JOBS: >)
	MOVE	T1,MAXJOB		;GIVE CONFIGURATION MAX. JOB NR.
	TRACE				;THIS GOES TO TRACE FILE
	PUSHJ	P,DECOUT		;
	TYPES	(<  MAX. NUMBER OF TTY LINES: >)
	MOVE	T1,MAXTTY		;AND TTY LINES
	TRACE				;THIS TOO GOES TO TRACE FILE
	PUSHJ	P,DECOUT		; OR TEXT FILE
	MOVX	GT, %NSMMS		;LOOK UP MEMORY SIZE
	PUSHJ	P,FETTAB		;
	PUSH	P,GT			;SAVE IT
	SUB	GT,SYSSIZ		;SUBTRACT MONITOR LOW SEG SIZE
	MOVE	N1,GT			;HANG ON TO THAT FIGURE
	MOVX	GT,%CNHSL		;MONITOR MAY BE TWO SEGMENT
	PUSHJ	P,FETOPT		;SO LOOK UP HIGH SEG LENGTH
	  SETZ	GT,			;FAKE 0 LENGTH IF NOT THERE
	SUB	N1,GT			;SUBTRACT HI SIZE FROM TOTAL
	MOVE	T1,N1			;GET USER MEMORY AVAILABLE
	TYPES	(<
USER MEMORY: >)
	TRACE				;TRACE USER MEMORY SIZE
	PUSHJ	P,MEMPNT		;PRINT IT
	MOVEM	T1,USIZ			;AND STORE USER MEMORY SIZE
	TYPES	(< FROM TOTAL OF >)
	POP	P,T1			;PRINT IN K OR P
	TRACE				;AND TOTAL MEMORY SIZE IN WORDS
	PUSHJ	P,MEMPNT		;STD ROUTINE
	TYPES	(<
DISK UNITS:
	NAME	STR	TYPE    CONTROL CHAN#   STATUS	MOUNTED?
>)
	SETZB	GT,T1			;GET NUMBER OF DISK UNITS ON SYSTEM
CNTUNI:	SYSPHY	GT,			;BY LOOPING THRU SYSPHY UUO
	  SETZ	GT,			;FAKE DONE IF FAILS
	SKIPE	J,GT			;IF 0,WE ARE DONE
	AOJA	T1,CNTUNI		;OTHERWISE, RETURN NOW FOR NEXT ONE
	HRLZM	T1,UNIPTR		;STORE COUNT OF POINTER
	MOVNS	UNIPTR			;NEGATE IT
	PUSH	P,T1			;SAVE SIZE
	PUSHJ	P,ASSCOR		;GET CORE FOR BLOCK
	HRRM	T1,UNIPTR		;STORE IT AWAY TOO
	POP	P,T1			;RESTORE SIZE
	PUSHJ	P,ASSCOR		;ASSIGN CORE
	MOVEM	T1,UNIDB		;STORE DB ADDRESS
OUTUNI:	SYSPHY	GT,			;
	  JRST DUNUNI			;UUO ERROR FAKES DONE
	JUMPE	GT,DUNUNI		;AS DOES 0 RETURN
	MOVEM	GT,ARGS			;SET UP FOR DSKCHR
	MOVE	GT,[XWD ARGSLN,ARGS]	;GET CHARACTERISTICS
	DSKCHR	GT,			;
	  JRST	DUNUNI			;IF UUO FAILS
	PUSHJ	P,TAB			;TAB OVER
	MOVE	T1,ARGS+.DCNAM		;GET UNIT NAME
	SKIPN	ARGS+.DCSNM		;IF STR, OK
	MOVEM	T1,ARGS+.DCSNM		;OTHERWISE, USE PHYS FOR STR[BOC]
	PUSHJ	P,SIXPNT		;OUTPUT IT
	PUSHJ	P,TAB			;TAB OVER
	MOVE	N1,UNIPTR
	ADDI	N1,0(J)
	MOVE	T1,ARGS+.DCULN		;WE WANT LOG UNIT NAME
	MOVEM	T1,0(N1)
	MOVE	T1,ARGS+.DCSNM		;WE WANT STR NAME
	PUSHJ	P,SIXPNT		;AND PRINT IT
	PUSHJ	P,TAB			;TAB OVER
	LDB	T4,[POINTR(GT,DC.CNT)]	;GET TYPE OF UNIT
	CAXE	T4,.DCCFS		;IS IT FIXED HEAD?
	CAXN	T4,.DCCFH		;OF SOME KIND
	SETO	T1,			;YES,FLAG WITH -1
	MOVE	N1,UNIDB		;GET BASE ADDRESS OF DBS
	ADDI	N1,0(J)			;GET THIS SLOT
	MOVEM	T1,0(N1)		;STORE FOR LATER USE
	PUSHJ	P,UNITYP		;TYPE OUT UNIT TYPE
	MOVEI	T1,'ON'
	TXNE	GT,DC.OFL		;OFF LINE?
	MOVEI	T1,'OFF'
	PUSHJ	P,SIXPNT
	TYPES	(<LINE>)
	PUSHJ	P,TAB			;TAB OVER
	LDB	T2,[POINTR(GT,DC.STS)]	;GET UNIT MOUNT STATUS
	MOVE	T1,[EXP 'YES','FUTURE','NO','DOWN'](T2)
	PUSHJ	P,SIXPNT
	PUSHJ	P,CRLF
	MOVE	GT,ARGS+.DCNAM		;FETCH LAST NAME TO GET NEXT
	AOJA	J,OUTUNI		;UPDATE COUNTER,LOOP FOR NEXT

DUNUNI:	TYPES	(<
DATA GATHERED EVERY >)
	MOVE	T1,QTUM			;
	TRACE				;TELL TRACE LOOK INTERVAL
	PUSHJ	P, DECOUT		;TIME IN SECONDS
	TYPES	(< SECONDS AND REPORTED EVERY >)
	MOVE	T1,RVAL			;IN DECIMAL.NUMBER
	TRACE				;TELL TRACE INTERVALS PER REPORT
	PUSHJ	P,DECOUT		;SO WE CAN SEE IT
	TYPES	(< LOOKS
>)
	MOVX	GT,%CNDTM		;[*]GET NBS TIME
	PUSHJ	P,FETTAB		;[*]FROM THE MON
	TRACEM	GT			;[*]AND STORE IN THE TRACE FILE
	MOVSI	J,-LEN.I		;LENGTH OF INITIALIZATION TABLE

SYSIN1:	SKIPGE	TAB.P(J)		;-1 IN TAB.P MEANS EXCLUDED
	JRST	SYSIN2			;SO DONT SET IT UP
	SKIPE	N1,TAB.I(J)		;FETCH ITEM AND IF NOT ZERO
	PUSHJ	P,(N1)			;GO THERE TO DO WHAT THEY WANT
SYSIN2:	AOBJN	J,SYSIN1		;IF MORE TO DO
	SETZM	NLOOK			;CLEAR REPORT COUNTER
	TXO	SW,SYSD.I		;MARK AS INITIALIZED
	POPJ	P,			;AND ON WITH THE SHOW
			;END OF CONDITIONAL STARTS WITH "SYSGET"    >


SUBTTL HANDLE DISSAPEARANCE OF A TRACKED JOB

GONJOB:	SKIPGE	O.FST(J)		;ALREADY BEEN GONE ONE PASS?
	JRST	GONJ1			;YES,SKIP ZEROING
	SETZM	OLDAT(J)		;BLT ZEROES
	MOVEI	T1,OLDAT+1(J)		;
	HRLI	T1,-1(T1)
	BLT	T1,OLDAT+SIZDAT-1(J)	;DONE
	SETOM	O.FST(J)		;FLAG AS GONE
GONJ1:	TXNN	SW,L.USRS!L.PPN!L.PROG	;DOING MULTI-USERS?
	JRST	GONJ2			;NO
	SETZM	C.FST			;CLEAR C.FST SO NEXXT JOB
					;DOESNT FIND IT SET
	JRST	REJOIN			;YES,JUST GET NEXT JOB

GONJ2:	TXNN	SW,OPT.K		; WANTS FATAL (NO /NOKILL DONE)
	JRST	GNJFAT			;THEN GIVE IT TO HIM
	$ERROR(EF.WRN,CFC,<CAN'T FIND JOB FITTING SPECIFICATIONS, CONTINUING...>)
	SETOM	C.FST			;SET FIRST TIME SWITCH
	JRST	MCONT			;AND GO ON

GNJFAT:	MOVE	T1,SAVNUM		;LOAD T1 WITH SPECIFICATION
	TXNE	SW,L.TTY		;WATCHING TTY?
	JRST	GOTTY			;YES
	$ERROR(EF.FAT!EF.DEC!EF.RST,NJN,NO JOB NUMBER )
GOTTY:	$ERROR(EF.FAT!EF.OCT!EF.RST,NJT,NO JOB ON TTY #)

CHK2:	SKIPE	C.FST			;ALREADY KNOW HE IS NEW?
	POPJ	P,			;YES,RETURN
	MOVE	T1,O.JOB(J)		;GET OLD JOB NUMBER
	CAME	T1,C.JOB		;SAME JOB?
	JRST	SETFST			;NO
	MOVE	T1,O.RT(J)		;RUNTIME DECREASED?
	CAMLE	T1,C.RT			;
SETFST:	SETOM	C.FST			;SET FLAG
	POPJ	P,			;RETURN

SUBTTL ROUTINE TO RELOCATE J TO POINT TO CURRENT OLD DATA BLOCK

SETJ:	MOVE	J,OLDPTR		;BASE ADDR
	TXNN	SW,L.USRS!L.PPN!L.PROG	;DOING MULTIPLE?
	POPJ	P,			;NO,ALL DONE
	PUSH	P,T1			;SAVE T1
	IMULI	T1,SIZDAT		;
	ADDI	J,-SIZDAT(T1)		;UPDATE,BACKING OFF 1 BLOCK
	SKIPGE	O.FST(J)		;SEE IF C.FST NEEDS TO BE SET
	SETOM	C.FST			;
	PJRST	TPOPJ			;RESTORE T1 AND RETURN

SUBTTL HANDLE RUNNING COMMANDS

NEWSPC:	PUSHJ	P,GETCH2		;CHECK/PROCESS THE CHARACTER
	CAILE	CHR," "		;SKIP
	TXNE	SW,BRK			;SKIP BREAK CHARACTERS
	JRST	NEWBCK			;
	PUSH	P,CHR			;SAVE CHARACTER
	TXO	SW,F.TTY		;RUNNING COMMANDS GO TO TTY
	PUSHJ	P,CRLF			;[5]GIVE A CR-LF
	PUSHJ	P,CRLF			;[5]AND A BLANK LINE
	POP	P,CHR			;UNSAVE CHARACTER
	MOVSI	T2,-RNCLEN		;LENGTH OF RUN COM TABLE

RCLOOP:	LDB	T1,[POINT 7,RUNTAB(T2),6] ;GET CHARACTER
	CAIN	CHR,(T1)		;A MATCH?
	JRST	@RUNTAB(T2)		;YES
	AOBJN	T2,RCLOOP
	$ERROR(EF.FAT,BRC,BAD RUNNING COMMAND-- TYPE "H" FOR HELP)
	CLRBFI				;GET RID OF TYPE AHEAD
NEWBCK:	TXZ	SW,F.TTY		;BACK TO NORMAL OUTPUT
	SKIPN	QTUM			;IF NO SLEEP TIME
	JRST	MAIN			;CLEAR AND GO BACK TO MAIN LOOP
	MSTIME	N2,			;GET CURRENT DAYTIME
	SUB	N2,SLPTIM		;SUBTRACT TIME WE WENT TO SLEEP
	JUMPLE	N2,MAIN			;IF NEG. WE WENT PAST MIDNITE
	CAML	N2,SLPQT		;IF ELAPSED > WANTED
	JRST	MAIN			;GO PROCESS
	SUB	N2,SLPQT		;SUBTRACT ELAPSED-WANTED
	MOVMS	N2			;CORRECT SIGN
	MOVEI	T1,1			;[3]CLEAR WAKE CONDITION
	HIBER	T1,			;[3]
	JFCL				;[3]
	JRST	RSLEEP			;GO BACK TO SLEEP
NEW8:	PUSHJ	P,CRLF			;RESTART
	PUSHJ	P,CRLF
	PUSHJ	P,CRLF			;2 CR-LF PAIRS AS OUTPUT DEL.
	MOVEI	T1,1			;[3]CLEAR WAKE CONDITION
	HIBER	T1,			;[3]
	JFCL				;[3]
	JRST	RESTRT			;AND GO RESTART
NEW4:	TXO	SW,OPT.F		;SAY ITS FORCED
	TXNN	SW,SYSD			;DOING SYSTEM DATA?
	JRST	MAIN			;NO,GO DO A FORCED LOOK
IFN SYS, <
	MOVE	T1,T.LOOK		;SEE HOW MANY LOOKS TAKEN
	CAIGE	T1,2			;0-2 MAKES FOR AT LEAST ON VALUE
	JRST	NOTYET			;ELSE TELL TO COME BACK LATER
	PUSH	P,SAVUP			;SAVE DAYTIME
	MSTIME	T1,			;AND MAKE A CURRENT ONE
	MOVEM	T1,SAVUP		;FOR THE FORCED LOOK
	PUSHJ	P,SYSDIS		;DO THE DISPLAY
	POP	P,SAVUP			;RESTORE TIME
	JRST	NEWBCK			;AND GO BACK TO SLEEP

NOTYET:	$ERROR(EF.WRN,NED,NOT ENOUGH DATA FOR DISPLAY)
	JRST	NEWBCK			;AND RETURN   >

H2:	HELPME				;ASK FOR HELP
	JRST	NEWBCK			;CLEAN UP AND RETURN
	
NEW5:	SKIPE	CTRKJ			;TRACKING A JOB?
	JRST	NEW5A			;YES, PROCEED

NEW5B:	$ERROR(EF.WRN,NTJ,NOT TRACKING A SINGLE JOB )
	JRST	NEWBCK			;[5]CONTINUE

NEW5A:	PUSHJ	P,GETU			;GET STUFF HE WANTS
	PUSHJ	P,PUTU			;[5]PUT OUT STUFF HE WANTS
	PUSHJ	P,CRLF			;AND A CR-LF PAIR
	JRST	NEWBCK			;[5]AND CONTINUE


NEW6:	SKIPL	CTRKJ			;JOB ACTIVE?
	JRST	NEW5B			;[11]NO, USER ERROR
	PUSHJ	P,GETPRV		;LOOKUP PRIVELEGES
	PUSHJ	P,PUTPRV		;PRINT STUFF
	PUSHJ	P,CRLF			;GIVE A CLEAR LINE
	JRST	NEWBCK			;AND GO BACK

NEW7:	SKIPL	CTRKJ			;JOB ACTIVE?
	JRST	NEW5B			;NO, ITS AN ERROR
	MSTIME	T1,			;NEED UPDATED ELAPSED TIME
	MOVEM	T1,C.DAY		;STASH IT
	PUSHJ	P,GETRUN		;ALSO NEW RUNTIME
	PUSHJ	P,GETSTC		;GET STATISTICS
	PUSHJ	P,PUTSTC		;AND PUT THEM OUT
	PUSHJ	P,CRLF			;AND PUT A CR-LF PAIR
	PUSHJ	P,CRLF			;AND A BLANK LINE
	JRST	NEWBCK			;AND CONTINUE

NEW11:	TYPES	(<PEEK INTERVAL IS: >)
	MOVE	T1,QTUM
	PUSHJ	P,DECOUT
	TYPES	(< SECONDS.
>)
	TXNN	SW,SYSD			;DOING SYSTEM?
	JRST	NEW11A			;NO
	TYPES	(<NUMBER OF INTERVALS PER REPORT IS: >)
	MOVE	T1,RVAL
	PUSHJ	P,DECOUT
	TYPES	(<
REPORTS WRITTEN: >)
	MOVE	T1,NLOOK
	PUSHJ	P,DECOUT
	TYPES	(<
INTERVALS TILL NEXT REPORT: >)
	MOVE	T1,RVALC
	PUSHJ	P,DECOUT
	PUSHJ	P,CRLF
NEW11A:	SKIPN	T1,LOOKS		;SEE IF EXIT COUNTER SET
	JRST	[  TYPES (<NO EXIT COUNTER SET>)
		  JRST NEW11B]
	TYPES	(<INTERVALS UNTIL EXIT: >)
	PUSHJ	P,DECOUT
NEW11B:	PUSHJ	P,CRLF
	JRST	NEWBCK


; TABLE FOR RUNNING COMMANDS

	DEFINE RCCREATE <
	IFE BIGLST,<XLIST>

X	(H,H2)			;;H FOR HELP
X	(F,NEW4)		;;F FOR FORCED LOOK
X	(P,NEW6)		;;P FOR PRINT PRIVELIGE BITS
X	(U,NEW5)		;;U FOR PRINT USER NAME
X	(S,NEW7)		;;S FOR USER STATISTICS LINE
X	(X,FINISH)		;;X FOR EXIT
X	(N,NEW8)		;;N FOR NEW COMMAND
X	(W,NEW11)		;;W FOR WHAT REPORT

	LIST
> ;END OF RCCREATE DEFINITION

	DEFINE X(AA,BB)<
	XWD "AA"_^D11,BB>
>
	

RUNTAB:	RCCREATE
	RNCLEN==.-RUNTAB
SUBTTL  ROUTINE TO GET SWITCH AND DATA


GETSW:	TXZ	SW,T.FLG		;CLEAR "VALID SW SEEN" FLAG
	PUSHJ	P,TOKEN			;GET SWITCH
	JUMPE	T1,[$ERROR(EF.FAT!EF.RST,NSS,NO SWITCH SPECIFIED)]
	MOVEM	T1,LASSW		;STORE SWITCH AWAY
	MOVE	T2,[-SWSLEN,,SWS]	;POINT TO SWITCH TABLE
	TRZ	T1,77			;INSURE NO CHARACTER IN LAST PLACE
	TRO	T1,'*'			;CHECK FOR EXACT MATCH
	ROT	T1,-6			;BY CHECKING FOR "*XXXXX"
	PUSHJ	P,TABLUK		;DO THE LOOKUP
	  SKIPA	T1,LASSW		;NOT FOUND,CHECK OTHERS
	JRST	GETSW1			;FOUND UNDER EXACT MATCH CODE
	MOVE	T2,[-SWSLEN,,SWS]	;INPUT TO TABLE LOOKUP
	PUSHJ	P,TABLUK		;LOOK IT UP
	  JRST	[ JUMPL T1,[ MOVEI T1,LASTOK
			$ERROR(EF.FAT!EF.RST!EF.STR,ABS,AMBIGUOUS SWITCH /)]
		  JUMPGE T1,[ MOVEI T1,LASTOK
		      $ERROR(EF.FAT!EF.RST!EF.STR,UKS,UNKNOWN SWITCH /)]]
GETSW1:	MOVE	T4,SWS(T1)		;REMEMBER SWITCH NAME
	MOVEM	T4,LASSW		;
	XCT	SWSTAB(T1)		;EXECUTE PROPER INSTRUCTION
	POPJ	P,			;THEN RETURN

 ;DEFINE SWITCHES AND THEIR INSTRUCTIONS

	DEFINE SWCREAT <
	IFE BIGLST,<XLIST>
X	(<COMPAR>,< JRST CSW>)		;;ONLY IF CHANGE
X	(<DAILY>,<SETOM DAILYF>)	;;DAILY FILE SAVING
X	(<DISK>,<JRST DISKSW>)		;;/DISK
X	(<EXCLUD>,<JRST EXCLSW>)	;;EXCLUDE
X	(<*EXIT>,<	 JRST XSW>)	;;EXIT
X	(<FORMAT>,<JRST FORMSW>)	;;FORMAT
X	(<GROUP>,<	JRST  RSW>)	;;R
X	(<*HELP>,<   JRST HELPER>)	;;HELP
X	(<HPQ>,<JRST HPQSW>)		;;HPQ
X	(<INCLUD>,<JRST INCLSW>)	;;INCLUDE
X	(<INCREM>,< TXO SW,OPT.I>)	;;DO INCREMENTAL DATA
X	(<INTERV>,<JRST QSW>)		;;Q SWITCH
X	(<*LIST>,<JRST	LISSW>)		;;
X	(<LOCK>,<TXO SW,R.LOCK>)	;;LOCK
X	(<MESSAG>,<JRST ESW>)		;;
X	(<NOKILL>,< TXO SW,OPT.K>)	;;DONT KILL IF JOB GOES AWAY
X	(<PAUSE>,<  TXO SW,MRET>)	;;DO MONRET AFTER INIT
x	(<METER0>,<setom mbord0>)	;;METER board on cpu0
x	(<METER1>,<setom mbord1>)	;;METER board on cpu1
x	(<METER2>,<setom mbord2>)	;;METER board on cpu2
x	(<METER3>,<setom mbord3>)	;;METER board on cpu3
x	(<METER4>,<setom mbord4>)	;;METER board on cpu4
x	(<METER5>,<setom mbord5>)	;;METER board on cpu5
x	(<METER>,<jrst mtrsw>)		;;METER board on all cpus
X	(<NOMETE>,<JRST NMTRSW>)	;;NO METER BOARD AT ALL
X	(<PRIVEL>,<TXO SW,OPT.P>)	;;PRIVELEGE BITS
X	(<SAVE>,<	 JRST ASW>)	;;SAVE OUTPUT FILE
X	(<STATIS>,< JRST SSW>)		;;STATISTICS
X	(<SUMMAR>,<TXO SW,R.SUMM>)	;;SUMMARY
X	(<USER>,<TXO SW,OPT.U>)		;;USER NAME AND PPN
X	(<X>,<	 JRST XSW>)		;; OLD FORM OF /EXIT

	LIST
> ;END OF SWCREAT MACRO


	DEFINE X(AA,BB)<
SIXBIT/AA/>

SWS:    SWCREAT
	SWSLEN==.-SWS

	DEFINE X(AA,BB)<
	 BB>

SWSTAB:	SWCREAT


HELPER:	TXO	SW,F.TTY		;FORCE ANY PRINTOUT TO TTY
	CAIE	CHR,":"			;FOLLOWED BY VALUE?
	JRST	HELP.5			;NO, USER HELPER
	PUSHJ	P,TOKEN			;GET SIXBIT TOKEN
	MOVE	T2,[-2,,[SIXBIT /SWITCH/
			 SIXBIT /KEYWOR/]] ;SWITCHES OR KEYWORDS
	PUSHJ	P,TABLUK		;
	  JRST	SAYUSV			;UNKNOWN SWITCH VALUE
	JUMPN	T1,HELP.K		;WANT KEYWORDS?
HELP.S:	MOVE	T2,[-SWSLEN,,SWS]	;NO, WANT SWITCHES
	TYPES	(<SWITCHES ARE:
>)
	PUSHJ	P,HELP.0		;CALL COMMON ROUTINE
	JRST	HELP.6			;AND EXIT

HELP.K:	TYPES	(</COMPARE KEYWORD VALUES ARE:	"ALL"
>)
	MOVE	T2,[-JTNLEN,,JTNAM]	;POINTER TO LIT
	PUSHJ	P,HELP.0		;CALL COMMON ROUTINE
	TYPES	(</INCLUDE/EXCLUDE KEYWORD VALUES ARE:	"ALL"
>)
	MOVE	T2,[-LEN.C,,TAB.C]	;POINTER TO LIST
	PUSHJ	P,HELP.0		;TYPE IT OUT
	JRST	HELP.6			;END IT
HELP.0:	MOVEI	T4,7			;ITEMS PER LINE
HELP.1:	MOVE	T1,0(T2)		;GET A NAME
	PUSHJ	P,SIXPNT		;PRINT IT
	SOJLE	T4,[PUSHJ P,CRLF
		      MOVEI T4,7 
		      JRST HELP.2 ]	;OUTPUT CRLF AND GO
	TYPES(<	>)			;ELSE PRINT TAB
HELP.2:	AOBJN	T2,HELP.1		;IF MORE TO DO
	PJRST	CRLF			;WHEN ALL DONE, ENDE W/CRLF
	JRST	HELP.6
HELP.5:	HELPME
HELP.6:	TXO	SW,T.FLG		;IN CASE WE ARE ASKED
	TXZ	SW,F.TTY		;CLEAR FORCED TTY OUTPUT
	POPJ	P,
XSW:	PUSHJ	P,GETVAL		;GET VALUE OF SW
	JUMPG	T1,GOTVAL		;HAVE A VALUE FOR IT?
	TXNN	SW,SYSD!L.USRS!L.TTY!L.JOB!L.PPN!L.PROG	;SEEN A COMMAND?
	EXIT				;NO, SO JUST LEAVE
	MOVEI	T1,1			;FAKE AN X:1
GOTVAL:	MOVEM	T1,LOOKS		;SAVE NUMBER OF LOOKS
	POPJ	P,			;GO BACK
QSW:	PUSHJ	P,GETVAL
	JUMPLE	T1,SAYSVS		;IF NEG OR ZERO
	MOVEM	T1,QTUM			;STORE
	POPJ	P,			;GO BACK
ASW:	PUSHJ	P,GETVAL		;SEE IF VALUE THERE
	SKIPG	T1			;NO VALUE SPECIFIED?
	SETO	T1,			;YES, MAKE IT SAVE ALWAYS (-1)
	MOVEM	T1,AVAL			;AND STORE IT
	POPJ	P,			;AND RETURN

SSW:	MOVX	GT, %FTDEB		;DEBUG WORD OF FEATURE TABLE
	PUSHJ	P,FETTAB		;LOOK IT UP
	TXNN	GT,RGHBT.(F%RSP)	;KEEPING RESPONSE TIME?
	TXO	SW,NO.RSP		;NO,REMEMBER THAT
	TXO	SW,OPT.S		;TURN ON STATISTICS WATCHING
	POPJ	P,

HPQSW:	MOVX	GT,.GTPRV		;GET PRIV WORD
	HRL	GT,MYJOB		;FOR THIS JOB
	PUSHJ	P,FETTAB		;
	LDB	GT,[POINTR(GT,JP.HPQ)]	;GET MAX HPQ
	MOVE	T1,GT			;
	CAIN	CHR,":"			;VALUE SUPPLIED?
	PUSHJ	P,OCTIN			;YES, GET IT
	JUMPE	GT,[$ERROR(EF.WRN,NHP,NO HPQ PRIVELEGES)
			POPJ P,]
	CAMLE	T1,GT			;UNDER MAX?
	JRST	[MOVE	T1,GT
	 $ERROR(EF.WRN!EF.OCT,HQV,HIGHEST HPQ YOU ARE PRIVELEGED FOR IS)
		JRST .+1]
	MOVEM	T1,HPQREQ
	POPJ	P,

RSW:	PUSHJ	P,GETVAL		;GET VALUE OF RVAL
	CAIGE	T1,2			;MUST BE AT LEAST TWO
	JRST	SAYSVS			;TELL ITS TOO SMALL
	MOVEM	T1,RVAL			;STORE IT
	POPJ	P,			;IT WAS, RETURN

ESW:	TXZ	SW,NO.LIN!NO.PRF	;WIPE OUT OLD VALUE
	CAIE	CHR,":"			;VALUE GIVEN?
	SKIPA	T1,[SIXBIT/C/]		;NO, FAKE CONTINUATION
	PUSHJ	P,TOKEN			;
	MOVE	T2,[-6,,[ SIXBIT/NOPREF/
			  SIXBIT/NOFIRS/
			  SIXBIT/FIRST /
			  SIXBIT/PREFIX/
			  SIXBIT/CONTIN/
			  SIXBIT/NOCONT/]]
	PUSHJ	P,TABLUK		;LOOK IT UPT
	 JRST	[JUMPL T1,SAYASV
		 JRST SAYUSV]
	XCT	[ TXO SW,NO.PRF		;EXECUTE PROPER INSTRUCTION
		  TXO SW,NO.LIN
		  JFCL
		  JFCL
		  JFCL
		  JFCL] (T1)
	TXO	SW,T.FLG
	POPJ	P,


LISSW:	MOVSI	T1,'LPT'		;
	MOVEM	T1,FILDEV		;CHANGE DEVICE TO LPT
	POPJ	P,			;AND RETURN

DISKSW:	SETZM	SDISK			;START WITH SYSTEM
	CAIE	CHR,":"			;ARGUMENT SUPPLIED?
	SKIPA	T1,[SIXBIT/SYS/]	;NO,SO PRETEND ARG IS "SYSTEM"
	PUSHJ	P,TOKEN			;ELSE GET USER ARGUMENT
	LSH	T1,-^D30		;SHIFT OUT DRECK
	CAIN	T1,'A'			;IS IT "ALL"?
	SOSA	SDISK			;YES, FLAG SDISK WITH -1,MEANS ALL
	CAIN	T1,'S'			;MAKE SURE ITS SYS
	POPJ	P,			;IT IS,RETURN
	JRST	SAYUSV			;UNKNOWN

FORMSW:	TXZ	SW,MD.TRC		;SET TO FORMAT:TEXT
	CAIE	CHR,":"			;ARG PROVIDED?
	SKIPA	T1,[SIXBIT/TEXT/]	;NO,DEFAULT TO TEXT
	PUSHJ	P,TOKEN			;GET TOKEN
	LSH	T1,-^D24		;MAKE SMALL,UNIQUE
	CAIN	T1,'TE'			;TEXT?
	JRST	[MOVX  T1,.IOASC         ;DEFAULT TEXT MODE
		 MOVEM	T1,FILMOD
		 POPJ   P,]
	CAIE	T1,'TR'			;TRACE?
	JRST	SAYUSV			;NO,NOT KNOWN
IFE FTTRC,<
	$ERROR(EF.FAT!EF.RST,TNI,TRACING NOT INCLUDED IN THIS VERSION)
	  >; END OF IFE FTTRC
	TXNN	SW,SYSD			;DOING SYSTEM?
	JRST	[$ERROR(EF.FAT!EF.RST,STI,SYSTEM DATA TRACING IMPLEMENTED ONLY)]
	TXO	SW,MD.TRC		;TRACE MODE MARK
	MOVX	T1,.IOIBN		;TRACE IO MODE
	MOVEM	T1,FILMOD
	MOVX	T1,DEXTT		;GET DEFAULT EXT FOR TRACE FILES
	MOVE	T2,FILEXT		;GET GIVEN EXT
	CAXN	T2,DEXT			;SET TO TEXT DEFAULT?
	MOVEM	T1,FILEXT		;YES,CHANGE TO TRACE DEFAULT
	POPJ	P,			;RETURN

CSW:	TXO	SW,OPT.C		;MARK COMPARISON WANTED
	CAIE	CHR,":"			;VALUE SPECIFIED?
	JRST	[MOVX T1,%CHKCM		;NO,SO LOAD DEFAULT
		 MOVEM T1,DEFCMP	;STORE IT
		 POPJ P,]		;AND RETURN
	PUSHJ	P,GETCHR		;GET NEXT CHARACTER
	CAIE	CHR,"("			;MIGHT BE OPEN PARENS
	TXO	SW,REGET		;IF SO,EAT IT
CSW1:	PUSHJ	P,TOKEN			;GET TOKEN
	CAMN	T1,[SIXBIT /ALL/]	;WANT ALL?
	JRST	[ MOVX T2,^-<1B1>	;TURN ON ALL BUT DAYTIME
		  JRST CSW2]
	MOVE	T2,[-JTNLEN,,JTNAM]	;LOOK IT UP
	PUSHJ	P,TABLUK		;
	 JRST	[ JUMPE T1,SAYUSV
		  JRST SAYASV]
	MOVX	T2,<1B0>		;GET MARKER
	JUMPE	T1,CSW2			;SAVE TIME IF POS 0
	MOVNS	T1			;MAKE IT NEGATIVE
	LSH	T2,0(T1)		;AND POSITION BIT
CSW2:	IORM	T2,DEFCMP		;MARK IT ON
	CAIN	CHR,","			;DELIMITED BY COMMA?
	JRST	CSW1			;YES,SO GO AGAIN
CSW3:	CAIN	CHR,")"			;MIGHT BE CLOSE PARENS
	PUSHJ	P,GETCHR		;IF IT IS,EAT IT
	POPJ	P,			; RETURN
; MAKE UP A LIST OF THE FOUR LETTER ABBREVIATIONS, IN SIXBIT
; LEFT JUSTIFIED. THERE IS ONE FOR EACH JOB TRACKING FIELD
;
	DEFINE X(A,Y,C)<  SIXBIT \A\>

JTNAM:  DATUMS
	JTNLEN==.-JTNAM


INCLSW:	SETZM	EXCFLG			;NOT EXCLUDE
	SKIPA
EXCLSW:	SETOM	EXCFLG			;EXCLUDE,MARK IT
	CAIE	CHR,":"			;FOLLOWED BY ARGS?
	POPJ	P,			;NO,RETURN
	PUSHJ	P,GETCHR		;GET A CHARACTER
	CAIE	CHR,"("			;IF OPEN PARENS
	TXO	SW,REGET		;EAT IT
EXCL1:	PUSHJ	P,TOKEN			;GET ARGUMENT
	CAMN	T1,[SIXBIT /ALL/]	;IS IT ALL?
	JRST	EXCALL			;YES,GO HANDLE IT
	MOVE	T2,[-LEN.C,,TAB.C]	;PREPARE TO LOOK IT UP
	PUSHJ	P,TABLUK		;DO SO
	 JRST	[JUMPE T1,SAYUSV
		 JRST SAYASV]		;IF NOT FOUND,AMBIGUOUS
	MOVE	T2,EXCFLG		;PICK UP FLAG
	MOVEM	T2,TAB.P(T1)		;AND MARK ITEM AS SUCH
EXCL2:	CAIN	CHR,","			;ANOTHER ARG FOLLOWS?
	JRST	EXCL1			;YES
	JRST	CSW3			;NO

EXCALL:					;HANDLE ALL
	MOVE	T1,EXCFLG		;GET FLAG
	MOVEM	T1,TAB.P		;STORE IN FIRST WORD
	MOVE	T1,[TAB.P,,TAB.P+1]	;BLT POINTER
	BLT	T1,TAB.P+LEN.P-1	;STORE ACROSS WHOLE ARRAY
	JRST	EXCL2			;REJOIN COMMON CODE

;here on /meter to flag all cpus meter boards as possiblities
mtrsw:	setom	mbord0
	setom	mbord1
	setom	mbord2
	setom	mbord3
	setom	mbord4
	setom	mbord5
	popj	p,
;here on /nometer to flag all cpus meter boards as non-possiblities
nmtrsw:	setzm	mbord0
	setzm	mbord1
	setzm	mbord2
	setzm	mbord3
	setzm	mbord4
	setzm	mbord5
	popj	p,

SUBTTL SWITCH ERRORS AND ROUTINES

SAYUSV:	MOVE	T1,LASSW		;PICK UP SWITCH NANE
	$ERROR(EF.FAT!EF.CON!EF.SIX,USV,UNKNOWN VALUE FOR SWITCH )
	TYPES	(<: >)
	MOVEI	STR,LASTOK		;POINT TO VALUE GIVEN
	PUSHJ	P,PUTSTR
X$$USV:
X$$ASV:
X$$SVS:	PUSHJ	P,CRLF
	JRST	RESTRT

SAYASV:	MOVE	T1,LASSW		;PICK UP NAME
	$ERROR(EF.FAT!EF.CON!EF.SIX,ASV,AMBIGUOUS VALUE FOR SWITCH )
SVL.1:	TYPES	(<: >)
	POP	P,T1
	PUSHJ	P,OCTOUT
	JRST	X$$USV

SAYSVS:	PUSH	P,T1
	MOVE	T1,LASSW		;GET SWITCH NAME
	$ERROR(EF.FAT!EF.CON!EF.SIX,SVS,VALUE TO SMALL FOR SWITCH )
	JRST	SVL.1

GETVAL:	SETZM	T1			;START WITH NO VALUE
	TXNN	SW,BRK			;BREAK NEXT
	CAIN	CHR,"/"			;OR ALREADY TO NEXT SWITCH?
	POPJ	P,			;YES, SO NO VALUE GIVEN
	CAIN	CHR,":"			;IF WE SEE COLON 
	PUSHJ	P,DECIN			;GET VALUE
	POPJ	P,			;AND RETURN

SUBTTL	COMPARE ROUTINE SKIPS IF DIFFERENCE IN OLDAT VS CURDAT


COMPR:	SKIPE	C.FST			;IF FIRST TIME
	JRST	CPOPJ1			;THEN PRETEND THERES A DIFFERENCE
	MOVEI	T1,OLDAT(J)		;PICK UP PTR TO OLD
	MOVSI	N1,-SIZDAT		;AOBJN PTR TO DATA AREAS
	SKIPA	N3,DEFCMP		;GET COMPARE/NO COMPARE WORD
CMLOOP:	LSH	N3,1			;SHIFT RIGHT BIT INTO SIGN POSITION
	JUMPGE	N3,BLOOP		;IF COMP BIT OFF, TRY NEXT
	MOVE	N2,CURDAT(N1)		;CURRENT DATA
	CAME	N2,(T1)			;SAME AS OLD?
	JRST	CPOPJ1			;NO,TAKE SKIP RETURN
BLOOP:	AOS	T1			;UPDATE OLD POINTER
	AOBJN	N1,CMLOOP		;MORE TO DO?
	POPJ	P,			;RETURN TO MAIN LOOP

SUBTTL ROUTINE TO GIVE PROLOGUE TO USERS REPORT



USRPRO:	TXNN	SW,L.USRS		;REAL "USERS" COMMAND?
	PJRST	CRLF			;NO, JUST GIVE BLANK LINE
	MOVEI	CHR,14			;SEPARATE
	PUSHJ	P,PUTCHR
	TYPES	(<TIME: >)
	MSTIME	T1,			;USE TIME NOW
	PUSHJ	P,PUTDAY		;TELL DAYTIME
	PUSHJ	P,TAB
	MOVX	GT,%CNLNM		;SEE HOW MANY JOBS LOGGED IN
	PUSHJ	P,FETTAB
	MOVE	T1,GT
	PUSHJ	P,DECOUT
	TYPES	(< JOBS LOGGED IN OUT OF >)
	MOVX	GT,%CNLMX		;TELL MAX
	PUSHJ	P,FETTAB		;
	MOVE	T1,GT
	PUSHJ	P,DECOUT		;
	TYPES	(< MAXIMUM (LOGMAX)

>)
	POPJ	P,			;RETURN

SUBTTL ROUTINE TO PRINT OUT THE DATA IN BLOCK "CURDAT"


PRNT:	TXNE	SW,L.USRS		;SKIP CHECK FOR DIFF IF ALL USERS
	JRST	PUTALL	
	TXNN	SW,OPT.U		;[5]NOT WANT USER NAME AND PPN
	JRST	PUTD1			;IF SW NOT SET
	MOVE	T1,C.PPN		;CHECK FOR DIFFERENCE
	MOVE	T2,C.NAM1		;IN PPN OR NAME, IF NON, SKIP
	CAMN	T1,O.PPN(J)
	CAME	T2,O.NAM1(J)
PUTALL:	PUSHJ	P,PUTU			;[5]ELSE PUT USER NAME,PPN
PUTD1:	SETZB	FP,CHRCNT		;CLEAR COUNTERS
	TXNE	SW,L.USRS!L.PPN!L.PROG	;SKIP TIME STAMP IF MULITIPLE USERS
	AOJA	FP,PUTD1A		;AND FIX UP FIELD POINTER
	MOVE	T1,C.DAY		;CURRENT TIME
	TXNE	SW,OPT.I		;DOING INCREMENTAL
	SUB	T1,O.DAY(J)		;SUBTRACT
	PUSHJ	P,PUTDAY		;OUTPUT DAYTIME
	PUSHJ	P,POSIT			;CHARACTER POSITION
PUTD1A:	TYPEC	(J)			;JOB NUMBER
	MOVE	T1,C.JOB		;GET #
	PUSHJ	P,DECOUT		;OUTPUT
	PUSHJ	P,POSIT			;CORRECT POSITION
	SKIPGE	C.TTY			;IF TTY <0 THEN DETACHED
	JRST	DETACH
	TYPES	(<TTY>)			;START IT
	MOVE	T1,C.TTY		;PRINT IT
	PUSHJ	P,OCTOUT		;DONE
	JRST	TCONT

DETACH:	SKIPN	C.JOB			;IF WATCHING NULL JOB
	SKIPA	STR,[[ASCIZ/[NULL /]]	;SAY SO
	MOVEI	STR,[ASCIZ/DET/]	;THATS IT
	PUSHJ	P,PUTSTR
TCONT:	PUSHJ	P,POSIT			;CORRECT POSITION
	SKIPN	C.JOB			;IF NULL JOB
	SKIPA	T1,[SIXBIT/JOB]/]	;SAY SO
	MOVE	T1,C.PROG		;OUTPUT PROGRAM NAME
	PUSHJ	P,SIXPNB
	PUSHJ	P,POSIT			;CORRECT POSITION
	MOVE	T1,C.STAT			;GET STATUS
	PUSHJ	P,SIXPNT		;FININSHED THAT UP
	PUSHJ	P,POSIT			;TAKE CARE OF INCORE/SW
	MOVEI	T1,'SW'			;SET UP FOR SWAPPED
	SKIPLE	C.NSWP			;SEE IF VIRTUAL
	MOVEI	T1,'V '			;
	SKIPL	C.NSWP			;BUT IF IN CORE DONT
	PUSHJ	P,SIXPNT		;PRINT ANYTHING
	PUSHJ	P,POSIT
	MOVE	T1,C.LOW		;GET LOW CORE ASSIGNMENT
	PUSHJ	P,DECOUT		;ALWAYS PRINT
	SKIPGE	C.HIGH			;-1 HICOR IS SPY
	JRST	SPYER			;SO SAY SO
	SKIPN	C.HIGH			;MAYBE NO HI-SEG
	JRST	ORUN			;THER ISNT
	TYPEC	(+)			;THERE IS
	MOVE	T1,C.HIGH		;PRINT IT
	PUSHJ	P,DECOUT
	JRST	ORUN			;AND GO DO MORE


SPYER:	TYPES	(<+SPY>)		;FLAG MONITOR AS HI-SEG
ORUN:	TXNE	SW,L.USRS		;DOING ALL USERS?
	JRST	DONEO			;YES,SO WE ARE DONE
	PUSHJ	P,POSIT			;CORRECT CURSOR POSITION
	MOVSI	N1,-3			;SET UP FOR RT,RD,WR SETUP
	MOVEI	N3,O.RT(J)		;SET UP SOURCE
ORUNL:	MOVE	N2,C.RT(N1)		;GET A WORD
	TXNE	SW,OPT.I		;IF /I THEN SUB OLD
	SUB	N2,(N3)			;DONE
	MOVEM	N2,OUTRUN(N1)		;PUT IT AWAY
	AOJ	N3,
	AOBJN	N1,ORUNL		;IF MORE TO DO
	MOVE	T1,OUTRUN		;GET RT
	TXNE	SW,L.PPN!L.PROG		;DOING MORE THAN ONE JOB?
	SKIPA	N1,[EXP MSOUTJ]		;YES, ALIGN OUTPUT
	MOVEI	N1,MSOUT		;ELSE DONT BOTHER
	PUSHJ	P,0(N1)			;CALL APPROPRIATE ROUTINE
	PUSHJ	P,POSIT
	TYPES	(<RD:>)			;DSK RDS
	MOVE	T1,OUTRD		;GET # READS AS ADJUSTED
	PUSHJ	P,DECOUT		;AND PRINT
	PUSHJ	P,POSIT			;POSITION
	TYPES	(<WR:>)			;
	MOVE	T1,OUTWR		;GET NUMBER OF WRITES
	PUSHJ	P,DECOUT		;PRINT
DONEO:	TXNE	SW,OPT.S		;WANT STATISTICS
	PUSHJ	P,PUTSTC		;YES
	TXNN	SW,OPT.P		;[11]DONT WANT PRIVELEGES
	JRST	RFINP			;SO GO HOME
	SKIPGE	C.FST			;DO ON FIRST TIME
	JRST	PUTAL1
	MOVE	T1,C.GOD		;CHECK FOR A CHANGE
	MOVE	T2,C.PRV		;IN EITHER WORD
	CAMN	T1,O.GOD(J)	
	CAME	T2,O.PRV(J)	
PUTAL1:	PUSHJ	P,PUTPRV		;[11]ELSE PRINT
RFINP:	PUSHJ	P,CRLF			;[14]REALLY FINISHED WITH PRINTING
	TXNE	SW,OPT.S		;IF DOING STATISTICS GIVE XTRA
	PUSHJ	P,CRLF			;CR-LF PAIR
	POPJ	P,			;END OF ROUTINE

SUBTTL ROUTINE TO GET STATE OF JOB


GETSTA:	HRLZ	GT,C.JOB		;GET JOB NUMBER
	HRRI	GT,.GTSTS		;GET STATUS WORD
	PUSHJ	P,FETTAB		
	MOVE	T1,GT			;GET RESULT
	LDB	N1,[POINT 5,T1,14]	;GET Q #
	IDIVI	N1,3			;NAMES PACKED 3 TO A WORD
	MOVX	GT,.GTWSN		;GET NAME
	HRL	GT,N1
	PUSHJ	P,FETTAB		;DO GETTAB
	MOVE	N3,GT
	MOVE	N1,[POINT 12,N3,11]	;PICK OUT TWO CHARS
	JUMPE	N2,.+3
	IBP	N1
	SOJG	N2,.-1			;MORE INCREMENTING?
	LDB	N2,N1			;NO, GET BYTE
	MOVEI	N1,'^W'			;COMMAND WAIT
	TLNE	T1,400000		;TRY IT
	MOVEI	N1,'CW'
	TLNE	T1,CMWB
	JRST	GOTSIT			;WE HAVE IT
	MOVEI	N1,'OW'			;OPERATOR WAIT
	TRNE	T1,JDCON		;MAYBE
	JRST	GOTSIT			;YES
	MOVEI	N1,'^D'			;DEAMON WAIT
	TRNE	T1,JDC			;POSSIBLY
	JRST	GOTSIT			;YES
	MOVEI	N1,'^C'			;IN MONITOR MODE
	JUMPGE	T1,GOTSIT		;SIGN BIT ON?
	MOVEI	N1,'SL'			;JOB SLEEPING?
	CAIE	N2,'SL'			;IF IN THAT Q
	JRST	TIWAIT			;COULD BE TTY INPUT
	TRNN	T1,CLKR			;GOT A CLOCK REQUEST?
	MOVEI	N1,'HB'			;NO, HIBERNATING
	JRST	GOTSIT
TIWAIT:	CAIE	N2,'TI'			;COULD BE TI
	JRST	ISIT			;YUP
	MOVEI	N1,'TI'			;SET IT UP
	MOVN	N3,C.JOB		;MAKE NEG JOB #
	JOBSTS	N3,			;GET JOB STATUS
	  JFCL
	TXNE	N3,JB.UOA		;IF OUTPUT AVAILABLE
	MOVEI	N1,'TO'			;THEN MUST BE TO STATE
	SKIPA
ISIT:	MOVE	N1,N2			;A CORRECTED STATE
GOTSIT:	MOVEM	N1,C.STAT		;STORE IN CURDAT
	POPJ	P,			;AND GO HOME
SUBTTL	ROUTINE TO GET THE HI AND LO CORE USED BY A JOB


GETCOR:	SETOM	C.NSWP			;MARK AS IN CORE
	MOVE	N1,C.JOB		;GET CURRENT JOB
	SETOM	C.HIGH			;MARK AS DOING LOW SEGMENT
	PUSHJ	P,GETSIZ		;GET SIZE OF LOW-SEG
	MOVEM	GT,C.LOW		;STORE IT
;** THIS CODE FOR FLAGGING VIRTUAL JOBS LIES, SO REMOVE IT FOR NOW
;	MOVS	GT,C.JOB		;GET JOB INTO LH
;	HRRI	GT,.GTVRT		;LOOK UP VIRTUAL STATS FOR JOB
;	TXNE	SW,FT.VM		;SKIP LOOKING IF NON-VM SYSTEM
;	PUSHJ	P,FETOPT		;MAY NOT BE VM SYSTEM
;	  SETZ	GT,			;IF NOT VM, FORCE NON-VIRTUAL
;	TLNE	GT,-1			;SEE IF FAULT INTERVAL SET
;	HRRZS	C.NSWP			;IF FAULT INTERVAL, SET AS "V"

IFN SYS,<
	SETZM	HISEGN			;
>
	SETZM	C.HIGH
	MOVX	GT,.GTSGN		;LOOKUP HI-SEG NUMBER
	HRLI	GT,(N1)			;OF THIS JOB
	PUSHJ	P,FETTAB		;
	JUMPE	GT,CPOPJ		;IF NONE, WE ARE DONE
	JUMPL	GT,[SETOM C.HIGH	;SPY SEGEMENT, MARK AS C.HIGH= -1
		    POPJ P,]		;AND RETURN
	MOVE	N1,GT			;MAKE HI-SEG BE OUR GOAL
	
IFN SYS,<
	HRRZM	N1,HISEGN		;FOR SYSTEM STASH HI-SEG NUMBER
>
	PUSHJ	P,GETSIZ		;GET SIZE OF SEGMENT
	MOVEM	GT,C.HIGH		;STORE SIZE
	TXNE	SW,FT.VM		;IS THIS A VM SYSTEM?
	TXNE	N1,SHRSEG		;WAS THIS A SHAREABLE HI-SEG?
	POPJ	P,			;NO TO ONE OF THEM, WE ARE DONE
	SUBM	GT,C.LOW		;VM AND NON-SHAREABLE HI SEG
	MOVNS	C.LOW			;MEANS UPDATED LOWSEG SIZE
	POPJ	P,			;WE ARE DONE

GETSIZ:	TXNN	SW,FT.VM		;IS ITHIS A VM SYSTEM?
	JRST	GTSIZ7			;NO, USE OLD METHOD
	MOVSI	GT,(N1)			;LOOK UP IN SWAPPING TABLE
	HRRI	GT,.GTSWP		;FROM MONITOR
	PUSHJ	P,FETTAB		;
	SKIPE	C.HIGH			;IF THIS IS NOT HIGH SEGMENT
	JRST	GTSIZ6			;THEN RETURN LAST 9 BITS
	TXNE	N1,SHRSEG		;IS THIS SEGMENT SHAREABLE?
	JRST	GTSIZ7			;YES, SHAREABLE HI-SEG IS DONE OLD WAY
	MOVSS	GT			;IT IS NON-SHAREABLE, SO
	JRST	GTSIZ6			;USE 9 BIT FIELD
GTSIZ7:	MOVX	GT,.GTSTS		;LOOK UP THE JOBS STATUS
	HRLI	GT,0(N1)		;FROM MONITOR TABLE
	PUSHJ	P,FETTAB		;
	MOVE	N2,GT			;REMEMBER IT
	MOVX	GT,.GTADR		;USE IN CORE SIZE
	HRLI	GT,0(N1)		;
	PUSHJ	P,FETTAB		;
	MOVSS	GT			;GET RID OF RELOCATION
	JUMPE	GT,GTSIZ1		;NOT IN CORE IF 0 HERE
	SKIPE	C.HIGH			;IF HIGH SEGMENT
	TXNN	N2,SWP			;IF SWAPPED OUT
	JRST	GTSIZ2			;JUMP FOR HI-SEG OR IN-CORE LOWSEG
GTSIZ1:	PUSHJ	P,SEGSWP		;FETCH SWAPPING DATA
	TRNE	GT,377			;SEE IF OUT YET
	JRST	GTSIZ3			; USE IN CORE SIZE
	MOVX	GT,.GTADR		;USE IN CORE SIZE
	HRLI	GT,0(N1)
	PUSHJ	P,FETTAB
	MOVSS	GT
GTSIZ2:	TXNE	SW,KI.10		;IS THIS A KI OR KL?
	JRST	GTSIZ5			;YES
	ADDI	GT,1777			;ROUND UP
	ASH	GT,-^D10		;DIVIDE TO K
GTSIZ3:	ANDI	GT,377			;MASK TO 256 K
	POPJ	P,			;RETURN
GTSIZ5:	ADDI	GT,777			;ROUND UP TO P BOUNDARY
	LSH	GT,-^D9			;
GTSIZ6:	ANDI	GT,777			;MASK TO 512P
	POPJ	P,			;RETURN

; ROUTINE TO CONVERT CONTENTS OF N2 TO K OR P

KIKA:	ADDI	N2,777			;ROUND TO PAGE BOUND
	TXNN	SW,KI.10		;IF KA, ROUND TO K
	ADDI	N2,1000			;
	LSH	N2,-11			;MAKE PAGES
	TXNN	SW,KI.10		;AND IF KA, MAKE TO K
	LSH	N2,-1			;DONE
	POPJ	P,
SEGSWP:	SETZM	C.NSWP			;MARK AS SWAPPED
	MOVSI	GT,(N1)			;PICK UP SEGMENT NUMBER
	HRRI	GT,.GTSWP		;SWAPPING STAT. TABLE
	PJRST	FETTAB			;GET IT AND RETURN
SUBTTL	ROUTINE TO GET PROGRAM NAME


GETNAM:	MOVE	N1,C.JOB		;GET JOB NUMBER
					;ALT ENTRY POINT FOR PPN,MYPPN LOOP
GETP2:	MOVX	GT,.GTPRG		;TABLE OF NAMES
	HRL	GT,N1			;SETUP
	PUSHJ	P,FETTAB		;AND GET
	MOVEM	GT,C.PROG		;STORE
	POPJ	P,			;AND RETURN


SUBTTL	ROUTINE TO GET RUNTIME IN MS
GETRUN:	HRLZ	GT,C.JOB		;GET JOB NUMBER
	HRRI	GT,.GTTIM		;GET THE RUN TIME USED
	PUSHJ	P,FETTAB		;LOOK IT UP
	MOVE	T1,GT			;GET RESULT
	IMULI	T1,^D100		;CONVERT TICS TO MS
	IDIVI	T1,6			;FOR LATER USE
	MOVEM	T1,C.RT			;STORE IT
	POPJ	P,			;AND GO BACK



SUBTTL	ROUTINE TO PICK UP STATISTICS FOR A JOB (/S STUFF)

GETSTC:	MOVE	N1,C.JOB		;GET JOB NUMBER
	MOVX	GT,.GTKCT		;PICK UP KCT
	HRLI	GT,(N1)			;PICK UP JOB #
	PUSHJ	P,FETTAB		;GETTAB
	MOVEM	GT,C.KCT		;STORE RESULT

	MOVSI	GT,(N1)			;JOB #
	HRRI	GT,.GTLIM		;TIME LIMIT
	PUSHJ	P,FETTAB
	MOVEM	GT,C.TLM
	POPJ	P,


SUBTTL  ROUTINE TO GET JACCT BIT AND PRIVELEGE WORD OF JOB

GETPRV:	SETZM	C.GOD				;TURN OFF HES GOT JACCT
	MOVN	T1,C.JOB			;GET JOB NUMBER
	JOBSTS	T1,				;DO A JOB STATUS UUO
	  JFCL					;DONT REALLY CARE
	TXNE	T1,JB.UJC			;IS JACCT ON?
	SETOM	C.GOD				;YES, FLIP SWITCH
	MOVS	GT,T1				;FLIP FOR GETTAB
	HRRI	GT,.GTPRV			;SET FOR PRIV. GETTAB
	PUSHJ	P,FETTAB			;DO IT
	MOVEM	GT,C.PRV			;STORE
	POPJ	P,				;GO HOME


SUBTTL	ROUTINE TO GET DSK IO STUFF


GETDSK:	MOVX	GT,.GTRCT		;GET DSK READS
	HRL	GT,C.JOB		;GET JOB #
	PUSHJ	P,FETTAB
	LDB	N1,DBP			;GET THE POINTER
	MOVEM	N1,C.RD			;STORED
	MOVX	GT,.GTWCT		;SAME FOR WRITES
	HRL	GT,C.JOB		;
	PUSHJ	P,FETTAB
	LDB	N1,DBP			;
	MOVEM	N1,C.WR			;STORED
	POPJ	P,			;AND GO HOME
DBP:	POINT 23,GT,35			;DISK BYTE POINTER


SUBTTL ROUTINE TO GET USER NAME AND PPN

GETU:	MOVS	GT,C.JOB		;GET USER NAME
	HRRI	GT,.GTNM1		;FIRST HALF
	PUSHJ	P,FETTAB
	MOVEM	GT,C.NAM1		;STORE FIRST HALF
	MOVS	GT,C.JOB		;DO AGAIN FOR SECOND HALF
	HRRI	GT,.GTNM2		;
	PUSHJ	P,FETTAB		;SECOND HALF,USERNAME
	MOVEM	GT,C.NAM2		;STASH SECOND HALF
	MOVS	GT,C.JOB		;GET JOB NUMBER
	HRRI	GT,.GTPPN		;PPN TABLE
	PUSHJ	P,FETTAB		;LOOK IT UP
	MOVEM	GT,C.PPN		;STORE PPN
	POPJ	P,			;AND RETURN


SUBTTL	OUTPUT ROUTINE PUTS OUT "USER:" USER-NAME, PPN

PUTU:	TXNE	SW,L.USRS		;NO TAB FOR USERS
	JRST	PUTU1			;OR LABEL
	TYPES	(<	USER:>)		;GIVE "TAB USER"
PUTU1:	MOVE	T1,C.NAM1		;GET USER NAME
	PUSHJ	P,SIXPNB		;OUTPUT IT (WITH BLANKS)
	MOVE	T1,C.NAM2		;SECOND HALF OF NAME
	PUSHJ	P,SIXPNB		;OUTPUT
	MOVEI	STR,[ASCIZ/		/];TWO TABS
	TXNE	SW,L.USRS		;UNLESS USERS, THEN ONLY ONE
	MOVEI	STR,[ASCIZ/ /]		;SPACE OR SO
	PUSHJ	P,PUTSTR
	MOVE	T1,C.PPN		;GET PPN
	SETZ	CHRCNT,			;CLEAR CHARACTER COUNTER
	MOVEI	STR,[ASCIZ/PPN:/]	;PREPARE FOR PPN
	TXNN	SW,L.USRS		;SHORT FOR USERS
	PUSHJ	P,PUTSTR		;AND OUTPUT 'PPN:['
	MOVEI	CHR,"["			;BRACKET OPENS
	TXNN	SW,L.USRS		;EXCEPT FOR USERS
	PUSHJ	P,PUTCHR
	PUSH	P,T1			;SAVE
	HLRZS	T1			;MAKE PROJ BE IN R. HALF
	PUSHJ	P,OCTOUT		;OUTPUT IT
	TYPEC	(<,>)			;OUTPUT A COMMA
	POP	P,T1			;RESTORE
	ANDI	T1,-1			;AND MAKE IT CORRECT
	PUSHJ	P,OCTOUT		;OUTPUT IT
	TXNE	SW,L.USRS		;DOING USERS? IF YES THEN
	JRST	FPPNU			;FINISH PPN ALA USERS
	TYPEC	(])			;RIGHT BRACKET
	PJRST	CRLF			;GIVE CRLF, WILL RETURN FROM THERE
FPPNU:	CAIGE	CHRCNT,^D11		;NO TAB IF GONE TOO FAR
	PJRST	TAB			;TAB FOR USERS
	POPJ	P,			;OR MAYBE JUST RETURN
SUBTTL ROUTINE TO PRINT OUT THE PRIVELEGES FOR A JOB

PUTPRV:	PUSHJ	P,CRLF				;PUT OUT A CR-LF
	SETOM	CHRCNT				;USED FOR OUTPUT CHECK
	MOVEI	STR,[ASCIZ/JACCT /]		;SET FOR JACCT
	SKIPE	C.GOD				;WAS JACCT ON?
	PUSHJ	P,PUTSTR			;IT IS SO SAY SO
	MOVE	T1,C.PRV			;PICK UP PRIVS
	TXNE	T1,JP.HPQ			;SEE IF HPQ > 0
	PUSHJ	P,Y.HPQ				;YES, SO GIVE HPQXX
	TXNE	T1,JP.DPR			;SEE IF DISK PRIORITY
	PUSHJ	P,Y.DPR				;YES , SO GIVE DSKQX
	MOVEI	STR,[ASCIZ/MTR /]		;READY FOR METER
	TXNE	T1,JP.MET			;IS METER LIT?
	PUSHJ	P,PUTSTR			;YES
	MOVEI	STR,[ASCIZ/POK /]		;IS POKE LIT?
	TXNE	T1,JP.POK			;
	PUSHJ	P,PUTSTR			;YES
	MOVEI	STR,[ASCIZ/CPU /]		;IS CPU CHANGE LIT?
	TXNE	T1,JP.CCC			;
	PUSHJ	P,PUTSTR			;YES IT IS
	MOVEI	STR,[ASCIZ/UNSPL /]		;READY FOR UNSPOOL
	TXNE	T1,JP.NSP			;TEST THE BIT
	PUSHJ	P,PUTSTR			;IF ON
	MOVEI	STR,[ASCIZ/RTTRP /]		;SEE IF REAL TIME
	TXNE	T1,JP.RTT			;ETC
	PUSHJ	P,PUTSTR
	MOVEI	STR,[ASCIZ/LCK /]		;CHECK FOR LOCK ON
	TXNE	T1,JP.LCK			;TEST IT
	PUSHJ	P,PUTSTR			;AND PUT IT
	MOVEI	STR,[ASCIZ/TRPST /]		;TRAP SET UUO ENABLED?
	TXNE	T1,JP.TRP			;SET?
	PUSHJ	P,PUTSTR			;YES, SO PRINT IT
	MOVEI	STR,[ASCIZ/IPCF /]		;IPCF PRIVELEGED FUNCTIONS
	TXNE	T1,JP.IPC			;ARE THEY ON?
	PUSHJ	P,PUTSTR			;YES
	MOVEI	STR,[ASCIZ/ENQ /]		;ENQUE
	TXNE	T1,JP.ENQ			;SEE IF THEY HAVE IT
	PUSHJ	P,PUTSTR			;IF THEY DO,SAY SO
	MOVEI	STR,[ASCIZ/PEEK-ALL /]		;CAN PEEK ON ALL OF CORE
	TXNE	T1,JP.SPA			;WE SHALL SEE
	PUSHJ	P,PUTSTR
	MOVEI	STR,[ASCIZ/PEEK-MONITOR /]	;WHAT ABOUT ON MONITOR
	TXNN	T1,JP.SPA			;DONT SAY MON IF SAID ALL
	TXNN	T1,JP.SPM			;TEST
	CAIA					;SKIP OVER
	PUSHJ	P,PUTSTR			;AND MAYBE PRINT
	MOVEI	STR,[ASCIZ/*UNPRIVELEGED*/]
	SKIPGE	CHRCNT				;HAVE WE SAID ANYTHING?
	PUSHJ	P,PUTSTR			;NO,NOW DO SO
	PJRST	CRLF				;AND GIVE CR-LF AND RETURN


Y.HPQ:	PUSH	P,T1				;SAVE T1
	TYPES	(<HPQ>)				;SAY "HPQ"
	LDB	T1,[POINTR( T1,JP.HPQ)]		;GET Q NUMBER
	PUSHJ	P,OCTOUT			;AND PRINT
	PJRST	DUNQUE				;AND RESTORE, RETURN


Y.DPR:	PUSH	P,T1				;SAVE T1
	TYPES	(<DSKQ>)
	LDB	T1,[POINTR (T1,JP.DPR)]		;GET Q
	PUSHJ	P,OCTOUT			;AND PRINT IT
DUNQUE:	TYPEC	( )				;PRINT A BLANK
	PJRST	TPOPJ				;RESTORE T1 AND RETURN

SUBTTL ROUTINE TO OUTPUT KCS,RT/ET,RT/TRQ,TIME LIMIT
;
; EXPECTS TO FIND CURRENT DATA AREA LOADED

PUTSTC:	PUSHJ	P,CRLF			;GIVE LEADING CRLF
	SETZ	CHRCNT,			;FIX CURSOR AND CHAR COUNT
	MOVEI	FP,P.KCT-SPATAB		;POSITION IN SPATAB
	TYPES	(<KCS:>)			;LABEL
	MOVE	T1,C.KCT		;PICK UP KILO-CORE-TICKS
	IDIVI	T1,^D60			;60 TIC/SEC
	PUSHJ	P,DECOUT		;AND PRINT IT
	PUSHJ	P,POSIT			;CORRECT CURSOR POSITION
	
	SKIPE	C.FST			;DONT DO IT THE FIRST TIME
	JRST	NOET			;CAUSE YOU GET GARBAGE
	MOVEI	STR,[ASCIZ!RT/ET:!]	;RUNTIME/ELAPSED TIME
	MOVE	T1,C.RT			;PICK UP RUNTIME
	SUB	T1,O.RT(J)		;MAKE INCREMENTAL
	MOVEM	T1,ARGS			;STORE IT IN ARG BLOCK
	MOVE	T1,C.DAY		;PICK UP DAYTIME
	SUB	T1,O.DAY(J)		;MAKE INCREMENTAL
	JUMPGE	T1,.+2			;ADJUST IF WENT AROUND CLOCK
	ADDX	T1,^D1000*^D60*^D60*^D24
	MOVEM	T1,ARGS+1		;STASH IT
	PUSHJ	P,PUTMES		;OUTPUT THE STUFF
	PUSHJ	P,POSIT
NOET:					;SKIPPED OVER ABOVE, THE FIRST TIME
	LDB	T1,[POINTR(C.TLM,JB.LTM)]	;PICK IT UP
	IMULI	T1,^D1000		;CONVERT TO MS
	IDIVI	T1,^D60			
	JUMPE	T1,CPOPJ		;IF ZERO TLM , SKIP THE PRINT
	TYPES	(<TLM:>)			;LABEL
	PJRST	MSOUT			;OUTPUT T1 AS MILLISECONDS

SUBTTL  ROUTINE TO DO GETTABS OR SPYS DEPENDING ON PRIV.

;	ROUTINE HAS TWO ENTRY POINTS:
;  FETOPT:	DOING GETTAB ON AN OPTIONAL TABLE,  TAKE SKIP RETURN
;		IF GOOD LOOKUP, NON-SKIP IF GETTAB FAILS
;  FETTAB:	TABLE BEING LOOKED AT IS NON-OPTIONAL, IF THE
;		GETTAB OR GETTAB SIMULATION FAIL THEN GO TO GFAIL
;		WHICH IS A FATAL ERROR. (USER MAY "CONTINUE")
;		THE ONLY RETURN IS A NON-SKIP RETURN


FETOPT:	TXOA	SW,GT.OPT		;MARK AS OPTIONAL
FETTAB:	TXZ	SW,GT.OPT		;NON-OPTIONAL
	MOVEM	GT,SAVGT		;SAVE FOR EXAMINATION IF WE GET A FAILURE
	TXNE	SW,Y.SPY		;CAN WE SPY?
	JRST	USPY			;YES, GO DO IT
UGET:	GETTAB	GT,			;NO, DO A GETTAB
	  PJRST	GFAIL			;IF A FAILURE
	TXNE	SW,GT.OPT		;IF DOING OPTIONAL TABLE THEN
	AOS	(P)			;SKIP FOR GOOD RETURN
	POPJ	P,

USPY:	HRRE	T3 ,GT			;T3  GETS TABLE NUMBER
	HLRZ	T4 ,GT			;AND T4  THE ITEM NUMBER
	CAMLE	T3 ,MAXGTB		;UNDER THE LIMIT?
	PJRST	GFAIL			;NO, GIVE ERROR RETURN
	ADD	T3 ,TABTAB		;GET ADDR OF ADDR OF TABLE
	MOVE	T3 ,400000(T3 )		;AND FETCH ADDR OF WANTED TABLE
	LDB	GT,[POINT 9,T3 ,8]	;GET MAX LENGTH
	CAMLE	T4 ,GT			;THIS ITEM # <= MAX?
	JRST	UZERO			;NO, RETURN ZERO RESULT
	TLNE	T3 ,400			;IF ITS PROCESS DATA
	JRST	UPROC			;USE PROCESS TABLES
SPYBCK:	ADDI	T3 ,(T4 )		;NOW T3  HAS ADDR OF EXACT ITEM
	MOVEM	T3 ,SAVADR		; SAVE ADDRESS OF EXEC LOC THIS ITEM
	SKIPA
UZERO:	TDZA	GT,GT			;FOR RETURNING ZERO RESULT
	MOVE	GT,400000(T3 )		;PICK UP ITEM
	TXNE	SW,GT.OPT		;IF OPTIONAL TABLE, GOOD LOOKUP GETS
CPOPJ1:	AOS	(P)			;SKIP RETURN
CPOPJ:	POPJ	P,			;AND RETURN


UPROC:	MOVE	GT,SAVGT		;RESTORE GT INCASE GETTAB
	SKIPN	PDBPTR			;HAVE PTR TO PROCESS DATA?
	JRST	UGET			;NO,USE GETTAB
	ADD	T4 ,PDBPTR		;T4  GETS ADDRESS OF ADDRESS OF PDB
	SKIPN	T4 ,(T4 )		;IF NOT ZERO
	JRST	UZERO			;UNLESS THERE IS NO PDB
	JRST	SPYBCK			;AND GO BACK TO SPY


; ROUTINE TO RETURN A VALUE IN THE MONITOR WITHOUT GOING THRU GETTAB/SPY
; EXPECTS EXEC ADDRESS IN GT, RETURNS VALUE IN GT
; RETURNS ZERO IF CANT DO A SPY OR PEEK

MONVAL:
IFE PURESW,<
	TXNE	SW,Y.SPY		;CAN HE SPY?
	SKIPA	GT,400000(GT)		;YES, SO DO SO  >
	PEEK	GT,			;PEEK HAS NO ERROR RETURN
	POPJ	P,			;NOW GO HOME	

SUBTTL ROUTINE TO SET UP THE GETTAB SIMULATOR
IFE PURESW,<
SETTAB:	MOVX	GT, %CNSIZ		;LOOKUP SIZE OF MONITOR
	PUSHJ	P,FETTAB
	SOJ	GT,			;BACK OFF BY 1
	SPY	GT,			;TRY TO SPY
	  JRST	XSPY			;CANT, NO PRIV, ETC
	MOVE	GT,[XWD .GTSLF,.GTSLF]	;[63]GET ADDRESS OF SELF TABLE
	PUSHJ	P,FETOPT		;THIS IS NON FATAL IF NOT FOUND
	  JRST	XSPY			;AND ITS NOT
	JUMPE	GT,XSPY			;IF NO IMMEDIATE TABLE,DONT SPY
	HRRZM	GT,TABTAB		;STORE IT
	LDB	N2,[POINT 9,GT,8]	;GET MAX SIZE
	MOVEM	N2,MAXGTB		;STASH THAT TOO
	MOVX	GT, %CNPDB		;GET PROCESS DATA BLOCK ADDRESS
	PUSHJ	P,FETTAB		;STORING FOR LATER STUFF
	TRO	GT,400000		;MAKE A SPY POINTER
	MOVEM	GT,PDBPTR		;AND STASH IT
	TXO	SW,Y.SPY		;FINALLY,TURN SPYING ON
XSPY:	POPJ	P,			;RETURN

>	;END OF CONDITIONAL


SUBTTL ROUTINE TO ASSIGN CORE WHEN NEEDED FOR TABLE SPACE
;
;ROUTINE ASSCOR	:   EXPECTS T1 TO CONTAIN NUMBER OF WORDS WANTED,
; ON RETURN T1 CONTAINS ADDRESS OF START OF GIVEN BLOCK

ASSCOR:	EXCH	T1,.JBFF		;T1 CONTAINED WORDS WANTED
	ADDM	T1,.JBFF		;.JBFF NOW UPDATED
	PUSH	P,T1			;SAVE T1 WHILE WE CLEAR OR GET CORE
	MOVE	T1,.JBFF		;DID WE GO OVER?
	TLNE	T1,-1			;MAKE SURE ITS REASONABLE
	JRST	NOCORE			;IE <= 2**18.
	SOS	T1			;LAST WORD USED IS FIRST FREE-1
	CAMG	T1,.JBREL		;COMPARE TO .JBREL
	JRST	CLRCOR			;NO, SO JUST CLEAR CORE GIVEN
	CORE	T1,			;AND REQUEST CORE
	  JRST	NOCORE			;COULDNT GET IT
CLRCOR:	MOVE	T1,(P)			;GET START
	SETZM	0(T1)			;
	AOS	T1			;
	HRLI	T1,-1(T1)		;
	BLT	T1,@.JBREL		;CLEAR CORE
TPOPJ:	POP	P,T1			;RESTORE T1
	POPJ	P,			;AND RETURN

NOCORE:	MOVE	T1,.JBFF##
	MOVEI	T1,-1(T1)
	$ERROR(EF.FAT!EF.MEM!EF.RST,CEF,CORE EXPANSION FAILED WHEN TRYING TO GET )


SUBTTL ROUTINE TO REDUCE SIZE BACK TO ORIGINAL

REDUCE:	PUSH	P,T1			;SAVE T1
	MOVE	T1,SAVFF		;GET ORIGINAL SIZE
	MOVEM	T1,.JBFF##		;RESTORE IT
	SUBI	T1,1			;BACK OFF ONE FOR LAST USED
	CORE	T1,			;AND MAKE OURSELVES THE RIGHT SIZE
	  JFCL				;DONT CARE
	JRST	TPOPJ			;RETURN TO CALLER
SUBTTL	ROUTINE TO GET THE TTY # ATTACHED TO JOB


GETTY:	TXNE	SW,SYSD			;DOING THE SYSTEM?
	MOVEI	T1,(J)			;YES, SO J HAS JOB NUMBER
	SKIPN	N1,T1			;GET JOB
	JRST	YDET			;MARK NULL JOB AS DETACHED
	TRMNO.	N1,			;UUO
	  JRST	DET			;MAY BE DETACHED
	SUBI	N1,.UXTRM		;SUBTRACT IO INDEX
	MOVEM	N1,C.TTY		;STORE
	JRST	CPOPJ1			;TAKE A SKIP RETURN
DET:	MOVN	N1,T1			;SETUP FOR JOB STATUS
	JOBSTS	N1,
	  JRST	NOJOB			;NO JOB THIS NUMBER
	JUMPL	N1,YDET			;DETACHED
NOJOB:	POPJ	P,
YDET:	SETOM	C.TTY			;-1 TTY # MEANS DETACHED
	JRST	CPOPJ1			;RETURN VIA SKIP



SUBTTL	ROUTINE TO GET JOB ATTACHED TO A TTY


GETJOB:	MOVE	N1,T1			;GET LINE #
	MOVEI	T2,3			;3 TIMES
	IDIVI	N1,10			;GET A DIGIT
	LSHC	N2,-6			;SHIFT INTO N3 THE REMAINDER
	SOJG	T2,.-2			;IF MORE
	HLRZS	N3			;PUT INTO RIGHT HALF
	ADD	N3,[SIXBIT/TTY000/]	;ADD TTY HANDLE
	SETZM	C.JOB			;ZERO THE JOB #
	DEVTYP	N3,
	  JFCL				;DEVTYPE RETURNS JOB #
	HRRZS	N3			;GET RID OF LEFT HALG
	LSH	N3,-11			;AND SHIFT OVER JOB NUMBER
	SKIPN	N3			;IF NOT 0 THEN THERE IS A JOB
	POPJ	P,
	MOVEM	N3,C.JOB		;STORE
	JRST	CPOPJ1			;SKIP RETURN = FOUND A JOB #
SUBTTL	OUTPUT ROUTINES AND INPUT ROUTINES
SUBTTL	ROUTINE TO OUTPUT DAYTIME AS HH:MM:SS
;	T1 MUST CONTAIN DAYTIME OR SOME TIME IN MS

PUTDAY:	PUSH	P,T1			;SAVE T1
	IDIVI	T1,1750			;GET AS SECS
	IDIVI	T1,74			;SECS IN T2, MIN IN T1
	PUSH	P,T2			;STORE ON STACK
	IDIVI	T1,74			;GET AS HRS MINS
	PUSH	P,T2			;SAVE MIN ON STACK
	CAIGE	T1,12			;IF <10
	PUSHJ	P,ZEROUT		;OUTPUT LEADING 0
	PUSHJ	P,DECOUT
	TYPEC	(:)			;AND COLON
	POP	P,T1			;SAME FOR MINUTES
	CAIGE	T1,12
	PUSHJ	P,ZEROUT
	PUSHJ	P,DECOUT
	TYPEC	(:)
	POP	P,T1			;AND SECS
	CAIGE	T1,12	
	PUSHJ	P,ZEROUT
	PUSHJ	P,DECOUT		;ALWAYS PRINT
	MOVEI	CHRCNT,10		;UPDATE CHARACTER COUNTER
	PJRST	TPOPJ			;RESTORE T1 AND RETURN



SUBTTL ROUTINE TO OUTPUT MILLISECONDS AS HH:MM:SS.SS
; EXPECTS MS IN T1
; MSOUTJ IS LIKE MSOUT EXCEPT THAT IT RIGHT-JUSTIFIES
; THE OUTPUT SO THAT THINGS LINE UP NICE

MSOUTJ:	SOSA	JSTFLG			;JUSTIFY
MSOUT:	SETZM	JSTFLG
	MOVE	N1,T1			;NEED 3 CONTIG. REGISTERS
	IDIVI	N1,1750			;OFF THE MS
	IDIVI	N2,12			;MS
	PUSH	P,N2			;STORE ARGS
	IDIVI	N1,74			;GET SECS
	PUSH	P,N2			;STORE SECS
	IDIVI	N1,74			;SEPARATE MINS,HOURS
	PUSH	P,N2			;STORE MINS
	PUSH	P,N1			;STORE HOURS ON STACK
	TXZ	SW,T.FLG		;SET FLAG FOR NO LEADING ZERO
	MOVEI	T3 ,":"			;FIELD DELIMITER
	SETZ	T4 ,			;INIT COUNTER
ORUN2:	AOJ	T4 ,			;INCR CNT
	CAIN	T4 ,3			;IF 3RD ONE
	MOVEI	T3 ,"."			;NEW FILED DEL.
	POP	P,T1			;POP OFF A NUMBER
	SKIPN	T1			;IF NON-ZERO
	PUSHJ	P,ZERUN			;DONT FAKE IT
	CAIL	T1,^D10			;IF >=10 NO NEED FOR DIGIT FILL
	JRST	ORUN2A			;SO SKIP IT
	MOVEI	CHR,"0"			;ELSE FILL WITH BLANK OR ZERO
	TXNN	SW,T.FLG		;DEPENDING ON PREV. TYPEOUT
	MOVEI	CHR," "			;BLANK IF LEADING
	PUSHJ	P,PUTCHR		;AND PUT IT OUT
ORUN2A:	PUSHJ	P,DECOUT		;OUT IT
	TXO	SW,T.FLG		;SAY WE HAVE DONE OUTPUT
	CAIN	T4 ,4			;NO FD FOR FRACTIONS
	JRST	ORUN3
	MOVE	CHR,T3 
	PUSHJ	P,PUTCHR
ORUN3:	CAIE	T4 ,4
	JRST	ORUN2
	POPJ	P,			;GO HOME
ZERUN:	TXNN	SW,T.FLG		;IF NOT A LEADING TYPE ZERO
	CAILE	T4 ,2			;OR IF NOT HRS OR MINS OF RT
	POPJ	P,			;GO BACK AND PRINT
	POP	P,(P)			;POP OFF CALL
	MOVEI	STR,[ASCIZ!   !]	;UNLESS WANT JUSTIFICATION
	SKIPE	JSTFLG			;THEN SPACE OVER
	PUSHJ	P,PUTSTR		;TO LINE UP TIMES
	JRST	ORUN3			;AND GO BACK TO END OF LOOP


SUBTTL ROUTINE TO PUT OUT "MESS"ARG1/ARG2=NN%
; EXPECTS MESSAGE ADDR IN REG. STR
;  AND ARGS IN ARG: AND ARGS+1, ARG PRESERVED, ARG+1 DESTROYED

PUTMES:	PUSHJ	P,PUTSTR		;PUT OUT MESSAGE
	MOVE	T1,ARGS			;GET FIRST ARG
	PUSHJ	P,MSOUT			;OUTPUT IT
	MOVE	T1,ARGS			;FETCH FIRST ARG AGAIN
	IMULI	T1,^D1000		;1ST ARG * 1000 (AVOID FL. PT)
	IDIV	T1,ARGS+1		;DIVIDE BY 2ND ARG
	ADDI	T1,5			;ROUND IT
	IDIVI	T1,^D10			;AND MAKE 2 PLACE PERCENT
	EXCH	T1,ARGS+1		;STASH IT FOR NOW
	TYPEC	(/)			;DIVIDE SIGN
	PUSHJ	P,MSOUT			;OUTPUT THE 2ND NUMBER
	TYPEC	(=)			;NOW THE =NN%
	MOVE	T1,ARGS+1		;PICK UP PERCENT
	CAILE	T1,^D100		;IF MORE THAN 100%, SET IT TO THAT
	MOVEI	T1,^D100		;ERROR PROB. DUE TO SLOWNESS IN TRACK
	PUSHJ	P,DECOUT
	MOVEI	CHR,"%"			;THATS THE PERCENT SIGN
	PJRST	PUTCHR			;OUTPUT IT AND RETURN FROM THERE



SUBTTL OUTDBF, OUTDBI, OUTDBX - OUTPUT THE SYSDAT DATA BLOCK

; ROUTINE TO TAKE A DATA BLOCK AND OUTPUT IT AS
; 
;  "LABEL"
;
;  R1	-	R2	XX%
;	.
;	.
;	ETC
;
;    "AVERAGE VALUE : " NN
;
; ROUTINE EXPECTS SYSDAT TABLES TO BE SET UP, T.LOOK TO CONTAIN
; NUMBER OF LOOKS TAKEN AND EXPECTS J TO BE SET TO CURRENT DATA ITEM

; ROUTINE HAS THREE ENTRY POINTS:
;  ENTRY POINT ONE:  'OUTDBF'  OUT DATA BLOCK FLASH
;	OUTPUTS RANGE USING ALL DATA POINTS IN THE BLOCK
;  ENTRY POINT TWO:	'OUTDBI' OUT DATA BLOCK INCREMENTAL
;	THIS ENTRY POINT IS USED IN CONJUNCTION WITH THE
;	ROUTINES MEASURING SOMETHING AS A FUNCTION OF UNITS PER
;	ELAPSED TIME.  USER ROUTINES USING 'OUTDBI' SHOULD
;	BE SET UP VIA DBCORE
;	DBCORE SETS UP A DATA BLOCK OF SIZE '# OF LOOKS/REPORT'+1
;	THE ACTION IS THAT STONXT, OR THE USER ROUTINE IS USED TO PLACE
; CURRENT CUMMALATIVE VALUE IN CURRENT DB CELL+1. WHEN
; OUTDBI IS CALLED THE FIRST TIME, IT IGNORES CELL ONE, FROM
; THEREAFTER, IT USES ALL CELLS.  AFTER REPORTING, IT PLACES THE VALUE
; IN THE LAST DB CELL INTO THE FIRST DB CELL. THAT IS THE
; "EXTRA CELL" IS WRAPPED AROUND
;  ENTRY POINT THREE:	'OUTDBX'  OUT DATA BLOCK EXTRODINARY
;	SAME AS OTHERS AS FAR AS OUTPUT GOES, DIFFERENCE
;	IS THAT ADJPTR AND ADJLOK MUST BE SET UP BEFORE THE CALL
;	THIS ALLOWS A USER ROUTINE TO MAKE THESE POINTERS REFERENCE
;	ANY ARBITRARY DATA AREA AND CALL OUTDBX TO DO THE STANDARD
;	OUTPUT.


;


IFN SYS, <

OUTDBF:	HRRZ	N1,TAB.P(J)		;PICK UP TABLE PTR TO DB
	MOVE	N2,T.LOOK		;ALSO GET # LOOKS
	JRST	OUTDBX			;DEPOSIT AND GO SORT

OUTDBI:	HRRZ	N1,TAB.P(J)		;GET DB PTR
	MOVE	N2,T.LOOK		;AND DATA BASE LENGTH -1
	TXNE	SW,SYSD.I		;
	AOJ	N1,			;INCREMENT BASE ADDRESS
					;TO IGNORE 1ST VALUE
					;IF FIRST REPORT
	TXNE	SW,SYSD.I		;IF FIRST REPORT, VALUE IN
	SOJ	N2,			;IF FIRST REPORT THEN LOOKS =LOOKS-1
	SETOM	ROTFLG			;TURN ON ROTATE VALUE FLAG
	SKIPA				;AND SKIP TURNING IT OFF
OUTDBX:	SETZM	ROTFLG			;TURN OFF ROTATE VALUE FLAG
	MOVEM	N1,ADJPTR		;STORE ADJUSTED PTR
	MOVEM	N2,ADJLOK		;AND ADJUSTED LOOKS
	TRACEH	(ITM)			;[*]PUT THE HEADER
IFN FTTRC,<
	PUSHJ	P,ITMCOD		;PUT OUT ASCII CODE
> ; END OF FTTRC CONDITIONAL
	TRACEM	BAUXWD			;AND AUXILLIARY ID WORD
	SETZM	SUMSQ			;CLEAR SUM OF SQUARES

	HRRZ	N3,ADJPTR		;PICK UP POINTER TO DATA BLOCK
	ADD	N3,ADJLOK		;GIVES N3 LAST ADDR IN BLOCK
	HRRZ	N1,ADJPTR		;N1 GETS BEGINNING ADDRESS
CSRT1:	MOVEI	N2,1(N1)		;N2 CONTAINS ADDR 1 GREATER N1

CSRT2:	MOVE	T1,(N1)			;GET DATA IN BLOCK
	CAMG	T1,(N2)			;DATA IN ORDER?
	JRST	NOEXCH			;YES, SKIP EXCHANGE
	EXCH	T1,(N2)			;EXCHANGE TWO ITEMS
	EXCH	T1,(N1)
NOEXCH:	CAIGE	N2,(N3)			;DONE WITH INNER LOOP?
	AOJA	N2,CSRT2		;NO,GO BACK
	CAIGE	N1,-1(N3)		;YES,DONE WITH OUTER LOOP?
	AOJA	N1,CSRT1		;NO, GO BACK

	;NOW DATA IS SORTED, OUTPUT LABEL THEN DATA

	SKIPE	STR,TAB.N(J)		;FETCH ADDR OF LABEL
	PUSHJ	P,PUTSTR		;OUTPUT IT IF NOT NULL
	TXNE	SW,R.SUMM		;SUMMARY ONLY?
	JRST	SKPLB1			;YES
	PUSHJ	P,CRLF			;GIVE CR-LF
	PUSHJ	P,CRLF			;AND ANOTHER
	TYPES	(<    VALUE              FREQUENCY

>)
SKPLB1:	SETZ	GT,			;GT USED TO TOTAL ALL POINTS
	SETZB	T4,DONFLG		;ZERO INDEX AND DONE FLAG
	SKIPA	N1,ADJPTR		;MAKE N1 POINT TO START OF DB
COUT:	MOVE	N1,ARGS			;RESTORE N1 AFTER PRINTING
	MOVE	N2,(N1)			;GET A READING
	MOVE	T2,TAB.V(J)		;GET VARIANCE OF THIS ITEM
	IDIV	N2,T2			;GET TO A BOUNDARY
	IMUL	N2,T2			;IE INT*VARIANCE
	MOVEM	N2,LL			;STORE AS LOWER LIMIT
	MOVE	N3,TAB.V(J)		;VARIANCE
	ADD	N3,N2			;[70]THATS THE UPPER LIMIT
	SOJ	N3,			;PLUS 1
	MOVEM	N3,UL			;AND STORE IT TOO
	SETZ	T3 ,			;T3  USED AS TMP CNTER
	
COUT2:	MOVE	N2,(N1)			;GET A POINT
	CAMLE	N2,N3			;[70]FALL BELOW LIMIT?
	JRST	CBRK			;NO,SO PRINT AND BREAK
	MOVEI	T3 ,1(T3 )		;INCREMENT
	MOVEI	T4 ,1(T4 )		;BOTH COUNTERS
	ADD	GT,N2			;ADD INTO GRAND TOTAL
	IMUL	N2,N2			;ADD IT
	ADDM	N2,SUMSQ		;AND SUM THE SQUARES
	CAMLE	T4 ,ADJLOK		;DONE?
	SOSA	DONFLG			;MARK AS DONE, AND SKIP
	AOJA	N1,COUT2		;NO,GET ANOTHER POINT
CBRK:	IMULI	T3 ,^D1000		;GET PERCENT OF TOTAL
	MOVE	N2,T3 			;DO IDIV UNCRAZY
	MOVE	N3,ADJLOK		;DIVIDE THIS COUNT/TOTAL LOOKS
	IDIVI	N2,1(N3)		;TO GET PERCENT OF TOTAL
	MOVEM	N1,ARGS			;SAVE DB PTR
	MOVEM	N2,VAL			;OUTPUT ROUTINES USE N1-N3
	TXNE	SW,R.SUMM		;ONLY SUMMARY?
	JRST	SKPLB2			;YES
	TRACEH	(FRQ)			;[*]FREQ BLOCK HEADER
	MOVE	T1,LL			;OUTPUT LOWER LIMIT-UPPER LIMIT
	TRACE				;GIVE TRACE THE LOWER LIMIT
	PUSHJ	P,DECOUT
	PUSHJ	P,TAB			;TAB
	TYPEC	(-)			;DASH
	PUSHJ	P,TAB
	MOVE	T1,UL			;UPPER LIMIT
	TRACE				;GIVE TRACE THE UPPER LIMIT
	CAME	T1,LL			;DONT PRINT IF SAME AS LOWER
	PUSHJ	P,DECOUT		;OUT
	PUSHJ	P,TAB			;TAB
	MOVE	T1,VAL			;ACTUAL PERCENT
	MOVEI	CHR," "			;MAKE DECIMAL POINT LINE UP
	CAIGE	T1,^D1000		;FOR PERCENT LESS THAN 100%
	PUSHJ	P,PUTCHR		;ONE LEADING SPACE
	CAIGE	T1,^D100		;FOR PERCENT LESS THAN 10
	PUSHJ	P,PUTCHR		;USE ANOTHER LEADING SPACE
IFN FTTRC, <
	PUSHJ	P,BFP10			;IF DOING TRACE,GIVE IT FP FORMAT
> ;END OF IFN FTTRC
	PUSHJ	P,SCD10			;SCALED DECIMAL, DIVIDE BY 10.
	TYPEC	(%)			;ITS A PERCENT
	PUSHJ	P,CRLF			;FOLLOWED BY CRLF
SKPLB2:	SKIPL	DONFLG			;DONE?
	JRST	COUT			;NO
	TRACEH	(SUM)			;[*]AND PUT THE SUMMARY BL HEADER
	TYPES	(<
MEAN VALUE FOR >)
	MOVE	T1,T4 			;OUTPUT SAMPLES
	TRACE				;PUT TO TRACE, THE NUMBER OF SAMPLES
	PUSHJ	P,DECOUT
	TYPES	(< SAMPLES=  >)
	MOVE	N1,GT			;GRAND TOTAL
	IMULI	N1,^D100		;DONT LOSE PRECISION
	IDIVI	N1,(T4 )		;DIVIDE BY NR OF SAMPLES
	MOVE	T1,N1			;T1 GETS NUMBER *100
IFN FTTRC, <
	PUSHJ	P,BFP100		;GIVE TRACE GOOD FLT. PT. FORMAT
>; END OF IFN FTTRC
	PUSHJ	P,SCD100		;SCALED DECIMAL OUT
	MOVE	N1,GT			;PICK UP SUM
	MUL	N1,N1			;SQUARE IT
	DIV	N1,T4 			;DIVIDE BY NR. POINTS
	MOVE	N2,SUMSQ		;SUM OF POINT SQUARES
	SUB	N2,N1			;N2 GETS NR. WE WANT ROOT OF
	IMULI	N2,^D100		;DONT LOSE PRECISION
	IDIV	N2,T4 
	LSH	N3,1
	JUMPE	N3,.+3			;DONT ROUND UP ZERO
	CAML	N3,N2			;ROUND UP
	ADDI	N2,1
	MOVEM	N2,N3			;N3 GETS NUMBER WE WANT ROOT OF
	PUSHJ	P,ISQRT			;GET ROOT OF NR IN N3
	TYPES	(<;  STD. DEVIATION=  >)

IFN FTTRC, <
	PUSHJ	P,BFP10			;GIVE TRACE FLOATING POINT FORMAT
	SETZM	BAUXWD			;ALSO,ZERO OUT BINARY AUX WORD
> ;END OF IFN FTTRC
	PUSHJ	P,SCD10			;PRINT
	PUSHJ	P,CRLF
	PUSHJ	P,CRLF			;GIVE A FEW CARRIAGE RETURN LINE-FEEDS
	PUSHJ	P,CRLF
	TXZN	SW,OPT.F		;NEVER ROLL FOR FORCED LOOK
	SKIPN	ROTFLG			;WANT "EXTRA CELL" TO CELL 1?
	JRST	OUTEND			;NO SO SKIP IT
	HRRZ	N1,ADJPTR		;GET DB PTR
	ADD	N1,ADJLOK		;AND LENGTH
	MOVE	N1,1(N1)		;GET EXTRA CELL CONTENTS
	TXNE	SW,SYSD.I		;IF WE DIDDLED BASE PTR UP ONE
	SOS	ADJPTR			;PUT IT BACK TO BASE OF CELL
	MOVEM	N1,@ADJPTR		;AND PUT IT AWAY
OUTEND:	POPJ	P,			;AND RETURN   
;CALLED WITH POS ARG IN N3, RESULT RETURNED IN T1, USES N2
; THIS ROUTINE STOLEN FROM SYSTAT

ISQRT:	SETZB	T1,N2		;ZERO ANSWER TO START
	JUMPLE	N3,CPOPJ	;IF ARG IS .LE. 0
	TRO	N3,1		;FORCE SOME BITS ON TO TERMINATE
ISQ1:	ASH	T1,1		;MOVE TO NEXT BIT
	CAMG	N2,T1		;SEE IF REMAINDER IS BIG
	JRST	ISQ2		;NO--LOOP ON
	SUB	N2,T1			;DECREASE REMAINDER
	SUBI	N2,1		; ..
	TRO	T1,2		;INCREASE RESULT
ISQ2:	LSHC	N2,2		;SHIFT REMAINDER TWO BITS
	JUMPN	N3,ISQ1		;LOOP UNTIL DONE
	ASH	N2,-1		;BACK OFF REMAINDER
	JUMPE	N2,CPOPJ
	CAML	N2,T1		;SEE IF ROUNDING NEEDED
	ADDI	T1,1		;YES--INCREASE RESULT
	POPJ	P,		;RETURN

; OUTPUT THE INDEXED ITEM IN TAB.C IN ASCII FORM TO TRACE FILE

ITMCOD:	MOVE	T2,TAB.C(J)	;GET IT
	MOVEI	T3,5		;FIVE LETTERS
	LSHC	T1,6		;GET 1 LETTER
	LSH	T1,1		;MAKE ROOM FOR 7TH BIT
	SOJG	T3,.-2		;REPEAT SIX TIMES
	ADD	T1,[BYTE (7)" "," "," "," "," "];CONVERT TO 7 BIT
	TRACE			;OUTPUT IT TO TRACE FILE
	POPJ	P,		;AND RETURN

> ; END OF CONDITIONAL AROUND OUTDBI & ISQRT ROUTINE


SUBTTL ROUTINE TO TYPE OUT THE UNIT TYPES
;
; INPUT IS AC GT CONTAINING THE DSKCHR BITS

UNITYP:	SETZ	T1,			;ASSUME UNKNOWN TYPE OF CONTROLLER
	LDB	T2,[POINTR(GT,DC.CNT)]	;PICK OUT CONTROLLER INFO
	CAIG	T2,.DCCRP		;MAKE RANGE CHECK
	MOVE	T1,[ EXP 0		;0=NOT USED
		     SIXBIT /RC10/	;1=RC10
		     SIXBIT /RP10/	;2=RP10
		     SIXBIT /RH10/	;3=RH10 (FIXED HEAD)
			SIXBIT /RH10/	;4=RH10 (MULTIPLE HEAD)
		     SIXBIT /RH20/](T2)	;5=RH20 (MULTIPLE HEAD)
	PUSHJ	P,SIXPNT		;PRINT THE CONTROLLER TYPE
	TYPES	(<	>)		;TAB OVER
	SETZ	T1,			;ASSUME UNKNOWN DISK TYPE
	LDB	T3,[POINTR(GT,DC.UNT)]	;GET UNIT INFO
	CAIG	T3,.DCUR6		;MAKE RANGE CHECK
	JRST	@[EXP DU.0,DU.1,DU.2](T3);DISPATCH ON UNIT TYPE
UNIT.1:	PUSHJ	P,SIXPNT		;PRINT UNIT TYPE
	TYPES	(<	>)		;TAB OVER
	LDB	T1,[POINTR(GT,DC.DCN)]	;GET CHANNEL NUMBER
	PUSHJ	P,DECOUT		;PRINT IT
	PJRST	TAB			;RETURN,TABBING OVER

DU.0:	MOVE	T1,[SIXBIT/RD10/]	;ASSUME DRUM
	CAXN	T2,.DCCFS		;IS THIS ON A FIXED HEAD RH10?
	MOVE	T1,[SIXBIT/RS04/]	;YES,ADJUST
	CAXN	T2,.DCCRP		;IS THIS ON A MULTI-HEAD RH10?
	MOVE	T1,[SIXBIT/RP04/]	;YES,MUST BE RP04
	CAXN	T2,.DCCRN		;RP20?
	 MOVE	T1,[SIXBIT/RP20/]	;YES
	JRST	UNIT.1			;PRINT,CONTINUE

DU.1:	MOVE	T1,[SIXBIT/RM10B/]	;DRUM?
	CAXN	T2,.DCCDP		;MAYBE, SO SEE IF THIS IS A PACK
	MOVE	T1,[SIXBIT/RP02/]	;COULD BE RP02
	CAXN	T2,.DCCRP		;CHECK FOR RP06,SINCE IT LOOKS
	MOVE	T1,[SIXBIT/RP06/]	;LIKE AN RP05
	JRST	UNIT.1			;

DU.2:	MOVE	T1,[SIXBIT/RP03/]	;ASSUME RP03
	CAXN	T2,.DCCRP		;UNLESS THIS IS AN RH10 CONTROLLER
	MOVE	T1,[SIXBIT/RP06/]	;WHICH MEANS ITS AN RP06
	JRST	UNIT.1			;CONTINUE
SUBTTL UTILITY INPUT/OUTPUT ROUTINES

; NUMERIC OUTPUT ROUTINES

DECOUT:	SKIPA	N3,[^D10]			;DECIMAL OUTPUT
OCTOUT:	MOVEI	N3,10			;OCTAL OUTPUT ROUTINE
	MOVE	N1,T1			;GET NUMBER TO BE OUTPUT
	JUMPGE	N1,ONL			;IF NEGATIVE, SAY SO
	TYPEC	(-)			;BY MINUS SIGN
	MOVMS	N1			;AND MAKE IT THE MAGNITUDE
ONL:	IDIV	N1,N3			;GET A DIGIT
	HRLM	N2,(P)			;STORE IT
	SKIPE	N1			;END?
	PUSHJ	P,ONL			;NO
	HLRZ	CHR,(P)			;GET DIGIT BACK
	ADDI	CHR,"0"			;ASCIISIZE IT
	PJRST	PUTCHR			;PUT OUT DIGIT 


; SCALED DECIMAL OUTPUT ROUTINES

SCD10:	SKIPA	N3,[^D10]		;SCALED DOWN BY 10
SCD100:	MOVEI	N3,^D100		;SCALED DOWN BY 100
	PUSH	P,T1			;SAVE T1 ACROSS CALL
	MOVE	N1,T1			;READY FOR OUTPUT
	IDIV	N1,N3			;DIVIDE
	PUSH	P,N2			;SAVE REMAINDER
	MOVE	T1,N1			;READY FOR PRINT
	PUSHJ	P,DECOUT		;PRINT IT
	TYPEC	(.)			;PRINT THE DOT
	POP	P,T1		
	PUSHJ	P,DECOUT		;PRINT FRACTION TOO
	PJRST	TPOPJ			;RESTORE T1 AND RETURN



; NUMERIC INPUT ROUTINES

DECIN:	SKIPA	N3,[12]			;DECIMAL INPUT ROUTINES
OCTIN:	MOVEI	N3,10			;OCTAL INPUT
	SETZ	N2,
INL:	PUSHJ	P,GETCHR		;GET A CHARACTER
	CAIL	CHR,"0"			;IF LESS THAN ZERO
	CAILE	CHR,"0"-1(N3)		;OR MORE THAN BASE
	JRST	ENDNI			;THEN END
	IMUL	N2,N3			;MULTIPLY WHAT WE HAVE
	ADDI	N2,-"0"(CHR)		;AND ADD NEW STUFF
	JRST	INL			;GO BACK FOR MORE
ENDNI:	MOVE	T1,N2			;RETURN # IN T1
	POPJ	P,
SUBTTL TOKEN INPUT ROUTINE
; ROUTINE TO RETURN IN T1 A SIXBIT TOKEN
; AND IN THE LASTOK BLOCK THE UNNABREVIATED ASCIZ VERSION
; OF THE INPUT
; UPON RETURN THE CHARACTER THAT DELIMITED THE TOKEN IS IN CHR
; IE. WAS OUTSIDE ASCII 0-9,A-Z
;

TOKEN:	PUSH	P,T2			;SAVE T2
	MOVE	STR,[POINT 7,LASTOK]	;POINT TO BLOCK
	MOVE	N3,[POINT 6,T1]		;POINT TO T1
	SETZB	T2,T1			;CLEAR
	MOVEI	N1,6			;NUMBER OF CHR TO T1
	MOVEI	N2,MAXTOK		;MAXIMUM TO TAKE INTO LASTOK
TOKE1:	IDPB	T2,STR			;ZERO TO DELIMIT STRING
	PUSHJ	P,GETCHR		;GET A CHARACTER
	CAIL	CHR,"0"			;CHECK FOR DELIMITED
	CAILE	CHR,"Z"
	JRST	 TOKE2			;.LT.0 OR .GT. Z
	CAILE	CHR,"9"
	CAIL	CHR,"A"
	TXNE	SW,BRK
	JRST	TOKE2			;BREAK OR BETWEEN 9 AND A
	SOSLE	N2
	DPB	CHR,STR			;DEPOSIT IN LASTOK IF ROOM
	SOJL	N1,TOKE1		;AND IN T1 IF ROOM
	SUBI	CHR,40			;SIXBIT IT
	IDPB	CHR,N3			;AND DEPOSIT
	JRST	TOKE1			;GET NEXT CHARACTER

TOKE2:	POP	P,T2			;RESTORE T2
	POPJ	P,			;AND RETURN
SUBTTL ROUTINE TO INPUT A FILESPEC

FILSPC:	MOVE	T1,[XWD PTHADR,PTHADR+1]	;CLEAR PATH
	SETZM	PTHADR
	BLT	T1,PTHADR+PTHLEN-1
	PUSHJ	P,TOKEN			;GET FIRST TOKEN
	CAIE	CHR,":"			;FIRST DEVICE COMES?
	JRST	NODEV			;NO
	JUMPE	T1,E$$NDI		;NULL DEVICE ILLEGAL
	MOVEM	T1,FILDEV		;SET IT
	PUSHJ	P,FENCHK		;SEE IF END
	PUSHJ	P,TOKEN			;GET NEXT TOKEN
NODEV:	SKIPE	T1			;DONT DEPOSIT NULL FILENAME
	MOVEM	T1,FILNAM		;
	CAIN	CHR,"["			;PPN?
	JRST	GPPN			;YES, GET IT
	PUSHJ	P,FENCHK		;CHECK FOR END
	CAIE	CHR,"."			;EXT NEXT?
	JRST	FILERR			;NO,ERROR
	PUSHJ	P,TOKEN			;GET NEXT TOKEN
	MOVEM	T1,FILEXT		;STORE
	PUSHJ	P,FENCHK		;SEE IF DONE
	CAIE	CHR,"["			;PPN?
	JRST	FILERR			;NO
GPPN:	PUSHJ	P,OCTIN			;GET PRJ
	JUMPE	T1,[  CAIN  CHR,"-"
		      JRST  DEFPATH    ;SET DEFAULT PATH
		      CAIE  CHR,","    ;DEF. PPN?
		      JRST  FILERR
		      HLRZ  T1,MYPPN   ;YES
		      JRST .+1]      ;CONTINUE
	HRLZM	T1,FILPPN		;STORE
	CAIE	CHR,","			;COMMA?
	JRST	FILERR			;NO
	PUSHJ	P,OCTIN			;GET PRG NR.
	SKIPN	T1			;DEFAULT?
	MOVE	T1,MYPPN		;YES
	HRRM	T1,FILPPN		;STASH
	CAIN	CHR,"]"			;OK?
	POPJ	P,			;RETURN
	CAIE	CHR,","			;SFDS FOLLOW
	JRST	E$$BPS			;NO, BAD PATH SPECIFIED
	MOVE	T1,FILPPN		;POINT TO PATH BLOCK
	MOVEM	T1,PTHADR+2		;
	MOVEI	T1,PTHADR
	MOVEM	T1,FILPPN
	MOVEI	T2,1			;1ST SFD
SFDLP:	PUSHJ	P,TOKEN			;GET SFD NAME
	JUMPE	T1,E$$NSI		;NULL SFD ILLEGAL
	CAILE	T2,MAXSFD		;ROOM?
	JRST	E$$TMS			;TOO MANY SFDS
	MOVEM	T1,PTHSFD-1(T2)		;PLACE
	CAIN	CHR,"]"			;DONE?
	POPJ	P,			;YES
	CAIE	CHR,","			;COMMA?
	JRST	E$$BPS			;NO,BAD PATH
	AOJA	T2,SFDLP		;GET NEXT SFD


DEFPATH:	MOVX	T1,-1			;GET DEFAULT PATH
	MOVEM	T1,PTHADR		;FROM MONITOR
	MOVE	T1,[XWD PTHLEN,PTHADR]	;SET UP FOR PATH. UUO
	PATH.	T1,
	  JRST E$$PUF			;PATH UUO FAILURE
	PUSHJ	P,GETCHR		;SHOULD END STRING WITH ]
	CAIE	CHR,"]"			;END CORRECTLY?
	JRST	E$$BPS			;NO
	MOVEI	T1,PTHADR		;MAKE FILPPN POINT TO PATH
	HRRZM	T1,FILPPN




FENCHK:	CAIE	CHR,"="			;END IS "="?
	TXNE	SW,BRK			;OR BREAK?
	TXOA	SW,REGET		;YES,REGET IT FLAG ON AND
	POPJ	P,			;NOT END RETURN
	PJRST	TPOPJ			;BALANCE STACK AND RETURN
;; ERROR MESSAGES FOR FILSPC


	$ERROR(EF.FAT!EF.RST,NDI,NULL DEVICE NAME IS ILLEGAL)
	$ERROR(EF.FAT!EF.RST,BPS,BAD PATH SPECIFICATION)
	$ERROR(EF.FAT!EF.RST,TMS,TOO MANY SFDS SPECIFIED)
	$ERROR(EF.FAT!EF.RST,PUF,PATH UUO FAILED)
	$ERROR(EF.FAT!EF.RST,NSI,NULL SFD ILLEGAL)
FILERR:	$ERROR(EF.FAT!EF.RST,FSE,FILE SPECIFICATION SYNTAX ERROR)
SUBTTL LINE MANIPULATION ROUTINES
; ROUTINE TO EAT REST OF LINE

EATLIN:	TXNE	SW,BRK			;BREAK SEEN?
	POPJ	P,			;YES, SO RETURN
	PUSHJ	P,GETCHR		;GET NEXT CHARACTER
	PJRST	EATLIN			;AND TRY AGAIN


; ROUTINE TO GET A CHARACTER FROM THE TELETYPE

GETCHR:	TXZN	SW,REGET		;CHECK FOR REGET
	ILDB	CHR,COMPTR		;GET A CHARACTER
	TXZA	SW,T.FLG		;REGULAR ENTRY
GETCH2:	TXO	SW,T.FLG		;RUNNING COMMAND ENTRY PT.
	TXZ	SW,BRK			;SHUT OFF BREAK INDICATOR
	CAIN	CHR,32			;IF IT IS ^Z
	EXIT	1,			;TEMPORARILY EXIT
	CAILE	CHR,140			;SEE IF ITS LOWER CASE
	SUBI	CHR,40			;CONVERT TO UPPER CASE
	CAIL	CHR,12			;IF NOT LF,VT OR FF
	CAILE	CHR,14			;THEN SKIP BREAK SET
	CAIN	CHR,33			;CHK FOR ALT. MODE
	JRST	BREAKX			;ELSE TAKE BREAK EXIT
	CAIE	CHR,";"			;ALLOW COMMENTS IN THE COMMAND
	CAIN	CHR,"!"			;STRINGS BY TURNING ON BREAK
	JRST	BREAKX			;HERE
	CAIG	CHR," "			;FINALLY , SKIP BLANKS AND
	JRST	SEECHK			;CONTROL CHARACTERS
	POPJ	P,			;RETURN
BREAKX:	TXOA	SW,BRK			;SET BREAK
SEECHK:	TXZE	SW,T.FLG		;CHECK FOR SPECIAL CASE
	POPJ	P,			;RETURN
	JRST	GETCHR			;NOT THIS TIME


; ROUTINE TO PRINT OUT VALUE IN T1 AS SO MANY K OR P
; DEPENDING ON PROCESSOR WE ARE RUNNING ON.  OUTPUT IS "NNK" OR "NNP"
; 
MEMPNT:	MOVE	N2,T1			;CONVERT USING GETCOR'S ROUTINE
	PUSHJ	P,KIKA			;SINCE ITS HANDY
	MOVE	T1,N2			;PRINT IT OUT
	PUSHJ	P,DECOUT		;PRINT IT OUT AS DECIMAL
	MOVEI	CHR,"K"			;PRETEND ITS A KA
	TXNE	SW,KI.10		;UNLESS ITS A KI
	MOVEI	CHR,"P"			;THEN ITS PAGES
	PJRST	PUTCHR			;OUTPUT CHAR AND RETURN


; ROUTINE TO TYPE A PPN AS "[PROJ,PROG]"

PPNTYP:	PUSH	P,T1			;SAVE T1
	TYPEC	([)			;OPEN BRACKET
	HLRZS	T1			;PROJECT NR.
	PUSHJ	P,OCTOUT
	TYPEC	(<,>)			;COMMA
	HRRZ	T1,0(P)			;GET PROGRAMMER NR.
	PUSHJ	P,OCTOUT
	TYPEC	(])			;CLOSE BRACKET
	PJRST	TPOPJ			;RESTORE T1 AND RETURN


; SIXBIT OUTPUT ROUTINES
SIXPNT:	TXZA	SW,T.FLG		;CLEAR T.FLG
SIXPNB:	TXO	SW,T.FLG		;SET SO PRINT BLANKS

	MOVEI	N1,6			;NUMBER OF CHARS
	MOVE	N2,[POINT 6,T1]		;POINTER TO T1
SIXP2:	ILDB	CHR,N2			;GET A BYTE
	TXNN	SW,T.FLG		;IF WANT BLANKS
	JUMPE	CHR,.+3			;SKIP BLANKS
	ADDI	CHR,40			;MAKE ASCII
	PUSHJ	P,PUTCHR		;AND PRINT
	SOJG	N1,SIXP2		;MORE TO DO
	POPJ	P,			;NO





; ROUTINE TO PRINT AN ASCIZ STRING

PUTSTR:	HRLI	STR,(POINT 7,0)		;MAKE A BYTE POINTER
P1:	ILDB	CHR,STR			;GET A BYTE
	JUMPE	CHR,CPOPJ
	PUSHJ	P,PUTCHR		;OUTPUT THE CHARACTER
	JRST	P1			;AND GO BACK FOR MORE


SUBTTL ROUTINE TO LOAD A COMMAND LINE FROM TTY OR TMPCOR

GETLIN:	MOVEI	T1,<COMMAX+4>/5	;GET CORE FOR COMMAND
	PUSHJ	P,ASSCOR		;GET IT
GTLIA:	HRLI	T1,(POINT 7,0)		;MAKE IT A BYTE POINTER
	MOVEM	T1,COMPTR
	SETZB	T2,CHR			;CLEAR COUNT AND CHR
	MOVEI	T2,COMMAX		;MAX LINE LENGTH
	TXNE	SW,INDFLG		;INDIRECT FILE?
	JRST	INDIR			;YES,GET IT
	TTCALL	3,[ASCIZ/
*/]
GTLI1:	CAILE	CHR," "			;IF NOT SPACE
	MOVEM	CHR,LASCHR		;SAVE LAST CHAR
	TTCALL	4,CHR			;GET CHARACTER
	CAIN	CHR,32			;^Z?
	JRST	[EXIT	1,
		 MOVE  T1,COMPTR
		 JRST GTLIA]		;YES
	SOJGE	T2,GTLI2
	$ERROR(EF.FAT!EF.RST,LTL,COMMAND LINE TOO LONG)
GTLI2:	CAIN	CHR,"-"			;SAVE BP TO LAST DASH
	MOVE	T4,T1		;IN CASE CONTINUATION
	IDPB	CHR,T1			;STORE CHAR
	CAIL	CHR,12			;CHECK FOR BREAK
	CAILE	CHR,14
	CAIN	CHR,33
	JRST	[MOVE T3,LASCHR	;CHECK FOR CONT
	         CAIE T3,"-"
	         POPJ  P,       ;ITS NOT
		 SETZM LASCHR   ;PREVENT LOOP
	         TTCALL 1,["#"] ;PROMPT
		 ADDI	T2,2
	         MOVEM T4,T1
		 JRST GTLI1]    ;AND CONTINUE
	JRST	GTLI1		;BACK FOR NEXT CHARACTER



;** PROCESS INDIRECT FILE

INDIR:	OPEN	TY,FILMOD		;OPEN UP FILE
	  JRST	[$ERROR(EF.FAT!EF.RST,CID,CANT OPEN INDIRECT DEVICE)]
	LOOKUP	TY,FILNAM		;FROM SPEC BLOCK
	  JRST	[ MOVE LUEB+1,FILEXT
		  PJRST LUPERR]		;ON LOOKUP ERROR
	INBUF	TY,1			;
INDIN:	SOSGE	TYBUF+2			;STANDARD INPUT
	JRST	[IN TY,
	         JRST INDIN
		 STATZ TY,74B23
		 CAIA
		 JRST INDEND
		 $ERROR(EF.FAT!EF.RST,ERI,ERROR READING INDIRECT FILE)]
	ILDB	CHR,TYBUF+1
	JUMPE	CHR,INDIN
	CAIN	CHR,32			;^Z FORCES AN END
	JRST	INDEND
	SOJL	T2,E$$LTL		;ROOM FOR CHARACTER?
	IDPB	CHR,T1			;STASH THE NON-ZERO CHR
	JRST	INDIN			;AND GET THE NEXT ONE

INDEND:	MOVEI	CHR,12			;INSURE A BREAK CHARACTER
	IDPB	CHR,T1			;STORE
	TXZ	SW,INDFLG		;DONE
	POPJ	P,			;DONE


SUBTTL PRESCAN FOR FILE SPEC DELIMITER

PRESCA:	MOVE	T1,COMPTR		;GET POINTER
PRESC1:	PUSHJ	P,GETCHR		;LOAD
	CAIN	CHR,"="			;SEE IT?
	JRST	PRESC2			;YES
	TXNN	SW,BRK			;
	JRST	PRESC1			;NOT BREAK,GET NEXT
	AOS	(P)			;SKIP RETURN,BREAK BEFORE
PRESC2:	MOVEM	T1,COMPTR		;RESTORE POINTER
	POPJ	P,			;RETURN
	SUBTTL MAIN CHARACTER OUTPUT ROUTINE
; ROUTINE TO OUTPUT A SINGLE CHARACTER


PUTCHR:	TXNE	SW,F.TTY		;SHOULD DO TTCALL?
	JRST	TYOUTP			; YES
	TXNE	SW,MD.TRC		;TRACING? 
DBLOC1:	POPJ	P,			;YES SKIP ASCII OUTPUT
					;NOTE: CHANGE POPJ TO JRST TYOUTP
					;TO DEBUG. GETS DUPLICATE TO TTY
	SOSG	TYBUF+2			;IF BUFFER NOT FULL
	PUSHJ	P,PUTBUF		;OUTPUT BUFFER
	IDPB	CHR,TYBUF+1		;DEPOSIT CHARACTER
	TXNE	SW,DEVTTY		;IF TTY IS OUTPUT DEVICE
	CAIE	CHR,12			;A LINE-FEED
	SKIPA
	PUSHJ	P,PUTBUF		;OUTPUT THE BUFFER
PUTINC:	AOJ	CHRCNT,			;UPDATE CHARACTER COUNTER
	POPJ	P,			;GO HOME

PUTBUF:	OUT	TY,			;OUTPUT BUFFER
	  POPJ	P,			;AND GO BACK
	$ERROR(EF.FAT!EF.CON,OUT,<OUTPUT UUO FAILED (>)
	GETSTS	TY,T1			;GET STATUS
	  JFCL
	TRZ	T1,17			;SHUT OFF MODE BITS
	PUSHJ	P,OCTOUT		;AND PRINT IT
	TTCALL	3,[ASCIZ/) ON DEVICE /]	;TELL USER THE DEVICE NAME
	MOVE	T1,FILDEV		;THAT WE SAVED EARLIER
	PUSHJ	P,SIXPNT
X$$OUT:	PUSHJ	P,CRLF
	JRST	RESTRT

TYOUTP:	TTCALL	1,CHR			;TTY OUTPUT
	PJRST	PUTINC			;INCREMENT CURSOR POS. AND RETURN


SUBTTL DO THE BINARY OUTPUT FOR TRACE MODE

IFN FTTRC, <

BINWRT:	TXNN	SW,F.TTY		;IN ERROR MODE?
	TXNN	SW,MD.TRC		;OR NOT IN TRACE MODE?
	POPJ	P,			;RETURN
	SOSG	TYBUF+2			;ROM IN BUFFER?
	PUSHJ	P,PUTBUF		;OUTPUT IT
	IDPB	T1,TYBUF+1		;DEPOSIT WORD
	POPJ	P,			;DONE


SUBTTL ROUTINE TO DO THE FLOATING FOR THE TRACE PACKAGE


BFP10:	SKIPA	T2,[10.0]		;DIVIDE BY 10
BFP100:	MOVE	T2,[100.0]		;DIVIDE BY 100
	CAIA				;SKIP
BFP001:	MOVE	T2,[1.0]		;JUST OUTPUT
	PUSH	P,T1			;SAVE T1
	PUSHJ	P,FLOAT			;FLOAT T1
	FDVR	T1,T2			;DIVIDE BY DESIRED FIGURE
	PUSHJ	P,BINWRT		;WRITE OUT THE RESULT
	PJRST	TPOPJ			;RESTORE T1


FLOAT:	TXNE	SW,KI.10		;ON A SMART MACHINE?
	JRST	[FLTR T1,T1		;YES, USE HARDWARE
		 POPJ P,]
	PUSH	P,T2			;SAVE T2
	HLRE	T2,T1			;THIS IS STOLEN FROM FOROTS
	HLL	T1,T2			;
	FSC	T1,233			;FLOAT THE LOW HALF OF THE INT
	SKIPGE	T1			;FOR NEGATIVE NUMBERS
	AOJE	T2,FLTXIT		;DONE?
	FSC	T2,255			;FLOAT THE HIGH PART
	FADR	T1,T2			;COMBINE THE TWO PARTS
FLTXIT:	POP	P,T2			;RESTORE T2
	POPJ	P,			;RETURN W/ T1 FLOATED

>; END OF IFN FTTRC


SUBTTL FIXED CHARACTER OUTPUT ROUTINES
; ROUTINE TO OUTPUT A ZERO

ZEROUT:	MOVEI	CHR,"0"			;GET ZERO
	PJRST	PUTCHR			;AND PRINT IT
; CURSOR POSITIONING ROUTINE


POSIT:	MOVE	N1,SPATAB(FP)		;GET MAX # CHARS THIS FIELD
	CAMG	N1,CHRCNT		;IF GT THAN USED
	TDZA	N1,N1			;
	SUB	N1,CHRCNT		;GET CHARACTTERS NEEDED
	AOJ	N1,			;INSURE 1 BLANK BETWEEN FIELDS
	PUSHJ	P,SPACES		;AND SPACE OVER
	AOJ	FP,			;CORRECT FIELD POSITION
	SETZ	CHRCNT,			;ZERO CHARACTER COUNT
	POPJ	P,			;AND GO BACK
;SPACES OUTPUT ROUTINE

SPACES:	MOVEI	CHR," "			;A SPACE
	JUMPE	N1,CPOPJ		;MAYBE NONE
	PUSHJ	P,PUTCHR		;PRINT A BLANK
	SOJG	N1,.-1			;IF MORE THAN 1
	POPJ	P,

; OUTPUT A TAB
TAB:	MOVEI	CHR,"	"		;A TAB
	PJRST	PUTCHR			;PRINT IT


;OUTPUT A CR-LF PAIR
CRLF:	MOVEI	CHR,15			;CARRIAGE RETURN
	PUSHJ	P,PUTCHR
	MOVEI	CHR,12			;LINE-FEED
	PJRST	PUTCHR



SUBTTL TABLE LOOKUP ROUTINE

; /TABLUK/ - LOOKS UP TOKEN IN AN UNORDERED TABLE
;	DOES THE USUAL UNIQUENESS CHECKING.
; INPUT - T1/ SIXBIT TOKEN TO BE MATCHED
;	  T2/ IOWD POINTING TO TABLE
; OUTPUT - T1 / INDEX INTO THE TABLE
; RETURNS - CPOPJ WITH T1/0 MEANS NOT FOUND
;           CPOPJ WITH T1=-1 MEANS AMBIGUOUS
;	    CPOPJ1 MEANS ALL IS OK, T1 HAS INDEX

TABLUK:	HRRZM	T2,SWIDX		;SAVE INITIAL ADDRESS
	MOVE	T3,T1			;COPY INPUT TOKEN
	SETO	T4,			;INITIAL MASK IS NO BITS
	LSH	T3,6			;GET RID OF ONE CHARACTER
	LSH	T4,-6			;ADJUST MASK
	JUMPN	T3,.-2			;REPEAT FOR ALL PRESENT CHRS
	SETZ	GT,			;CLEAR INDEX FOUND
TABL.3:	MOVE	T3,0(T2)		;GET AN ITEM
	TDZ	T3,T4			;MASK OUT UNWANTED PART
	CAMN	T1,T3			;IS THIS A MATCH?
	JRST	[ JUMPN GT,[ SETO T1,   ;YES,CHECK FOR MULTIPLE
	  		     POPJ P,]   ;MATCHES.
		  MOVEM T2,GT		;STORE INDEX
		  JRST .+1]		;AND CONTINUE
	AOBJN	T2,TABL.3		;SEE IF MORE TO DO
TABL.4:	HRRZ	T1,GT			;GET ADDRESS OF MATCH
	JUMPE	T1,CPOPJ		;IF NONE FOUND,RETURN
	SUB	T1,SWIDX		;CONVERT TO OFFSET
	JRST	CPOPJ1			;AND TAKE GOOD RETURN
SUBTTL ERROR MESSAGES


;ERROR MESSAGE PROCESSOR
; CALL IS : (PRODUCED BY $ERROR MACRO)
;	MOVE T1,<OPTIONAL VALUE TO BE TYPED> ;IF ANY
;	MOVX T4,<FLAGS FOR TYPE OF ERROR,RETURN DISPOSITION & TYPEOUT>
;	JSP	T3,ERRMSG
;	XWD SIXBIT CODE(3CHRS),ADDRESS OF ASCIZ STRING (OR 0)
;  AND IF EF.CON (MESSAGE CONTINUES) IS SET, THERE IS AN EXTRA
;  WORD "JRST AROUND.REST.OF.MESSAGE"(SKIPPED IF PREFIX-ONLY NOT SET)
;
ERRMSG:	MOVEM	0,SAVAC		;SAVE THE ACS
	MOVE	0,[XWD 1,SAVAC+1]
	BLT	0,SAVAC+17
	MOVE	0,SAVAC+0	;RESTORE BASHED AC
	MOVEM	T3,ERRPC	;SAVE ERROR PC
	TXO	SW,F.TTY	;ERRORS GO TO TTY
	PUSHJ	P,CRLF		;GIVE A CRLF PAIR
	MOVEI	CHR,"?"		;SET FOR FATAL ERROR
	TXNE	T4,EF.CMT	;IS IT A COMMENT?
	MOVEI	CHR,"["		;YES
	TXNE	T4,EF.WRN	;IS IT A WARNING
	MOVEI	CHR,"%"		;YES
	PUSHJ	P,PUTCHR	;TYPE IT
	GTMSG.	(CHR)		;GET OUR MESSAGE LEVEL
	TXNN	SW,NO.PRF	;/E VALUE SAYS NO PREFIX?
	TXNN	CHR,JW.WPR	;WANT PREFIX?
	JRST	NOPRFX		;NO
	PUSH	P,CHR		;SAVE MESSAGE LEVEL
	MOVEI	T1,'TRK'	;PUT OUT OUR PREFIX
	PUSHJ	P,SIXPNT	;
	HLLZ	T1,(T3)		;AND SPECIFIC CODE
	PUSHJ	P,SIXPNT	;
	TYPEC	(< >)		;AND A SPACE
	POP	P,CHR		;RESTORE MESSAGE LEVEL
NOPRFX:	TXNN	SW,NO.LIN	;/E VALUE SAYS NO REST OF LINE?
	TXNN	CHR,JW.WFL	;WANT SHORT ONLY ?
	JRST	ENDMSG		;ONLY PREFIX WANTED, SO GO BACK
	MOVE	STR,(T3)	;GET ADDRESS OF STRING
	PUSHJ	P,PUTSTR	;AND PRINT IT
	TXNN	T4,EF.DEC!EF.OCT!EF.SIX!EF.PPN!EF.MEM!EF.STR
	JRST	ENDMSG		;THATS ALL
	MOVE	T1,SAVAC+T1	;RESTORE ARGUMENT REGISTER
	TXNE	T4,EF.DEC	;DECIMAL?
	PUSHJ	P,DECOUT	;
	TXNE	T4,EF.OCT	;OCTAL?
	PUSHJ	P,OCTOUT	;
	TXNE	T4,EF.SIX	;SIXBIT?
	PUSHJ	P,SIXPNT	;
	TXNE	T4,EF.PPN	;AS A PPN?
	PUSHJ	P,PPNTYP	;YES
	TXNE	T4,EF.MEM	;IN TERMS OF CURRENT MEMEORY
	PUSHJ	P,MEMPNT	;YES
	TXNE	T4,EF.STR	;WANT STRING
	 JRST	[MOVE	STR,T1	;YES
		 PUSHJ	P,PUTSTR;
		 JRST	.+1]	;
ENDMSG:	MOVE	0,[XWD SAVAC+1,1] ;RESTORE THE ACS
	BLT	0,17	
	MOVE	0,SAVAC		;FROM SAVE BLOCK
	TXNE	T4,EF.CON	;WANT A CONTINUAI?
	JRST	[GTMSG. (T4)
		 TXNN	SW,NO.LIN
		 TXNN	T4,JW.WFL
		 JRST	1(T3)	;NO, RETURN+0 HAS JUMP AROUND REST
		 TXO	SW,F.TTY ;WANTS REST, TURN ON F.TTY AGAIN
		 JRST	2(T3)]	;AND SKIP JUMP,FALLING INTO REST OF MS.
	TXNE	T4,EF.CMT	;FINISH COMMENT
	TTCALL	1,["]"]		;IF DESIRED
	TTCALL	3,[ASCIZ/
/]				;CLEAN UP
	TXNE	T4,EF.EXT	;WANT TO EXIT?
	JRST	FINISH		;YES, SO DO SO
	TXNE	T4,EF.RST	;WANT TO EAT LINE AND GO TO "*"?
	JRST	[PUSHJ	P,EATLIN
		 JRST   RESTRT]	;YES
	JRST	1(T3)		;NORMAL OLD RETURN

SUBTTL NOTIFY OF GETTAB ERROR
; GETTAB FAILURE NOTIFICATION
; CALLED VIA PJRST FROM FETTAB.
; IF GT.OPT BIT IS SET, WE JUST DO A POPJ, GIVING
; USER A NON-SKIP (IE. BAD) RETURN
; IF GT.OPT NOT SET , WE TELL HIM LOC OF FAILING GETTAB
; AND EXIT. TYPING CONTINUE DOES A NON-SKIP RETURN
;	NOTE: FOR DEBUGGING-- LOCATION SAVGT HAS OFFENDING GETTAB PARAMETER


GFAIL:	TXZE	SW,GT.OPT		;OPTIONAL ?
	POPJ	P,			;YES, JUST DO A NON-SKIP RETURN
	PUSH	P,T1			;SAVE T1
	HRRZ	T1,-1(P)		;GET CALL ADDRESS
	SOJ	T1,			;MINUS ONE WAS CALL
	$ERROR(EF.FAT!EF.OCT,GTF,GETTAB UUO FAILURE AT PC )
	EXIT	1,			;EXIT
	PJRST	TPOPJ			;RESTORE T1 AND RETURN


;
;** LOOKUP , ENTER AND OPEN ERROR NOTIFICATION

RENERR:	$ERROR(EF.FAT!EF.CON,RNE,RENAME FAILURE FOR )
	JRST	IOERR1
LUPERR:	$ERROR(EF.FAT!EF.CON,LKE,LOOKUP FAILED FOR )
	JRST	IOERR1			;ENTER CHAIN OF MESSAGES

	$ERROR(EF.FAT!EF.CON,OPE,OUTPUT ENTER FAILED FOR )
IOERR1:	PUSH	P,LUEB+1		;SAVE ERROR CODE
	MOVE	T1,FILDEV		;PRINT DEVICE
	PUSHJ	P,SIXPNT
	TYPEC	(:)
	MOVE	T1,FILNAM		;FILENAME
	PUSHJ	P,SIXPNT
	TYPEC	(.)
	HLRZ	T1,FILEXT		;AND EXTENSION
	PUSHJ	P,SIXPNT
	SKIPN	T1,FILPPN		;PPN OR PATH?
	JRST	IOERR2			;NO
	TLNE	T1,-1			;POINTER TO PATH?
	JRST	[PUSHJ P,PPNTYP         ;NO,JUST TYPE PPN
		 JRST IOERR2]
	TYPEC	([)
	HLRZ	T1,PTHPPN		;GET PPN
	PUSHJ	P,OCTOUT		;
	TYPEC	(<,>)
	HRRZ	T1,PTHPPN
	PUSHJ	P,OCTOUT
	SETZ	T2,			;SEE IF SFDS SPECIFIED
ERRSFD:	SKIPN	T1,PTHSFD(T2)		;
	JRST	[MOVEI  CHR,"]"		;IF DONE GIVE "]" AND CONTINUE
		 PUSHJ P,PUTCHR
		 JRST IOERR2]
	TYPEC	(<,>)
	PUSHJ	P,SIXPNT		;TYPE SFD NAME
	AOJA	T2,ERRSFD		;BACK FOR MORE
IOERR2:	POP	P,T1			;GET ERROR CODE
	HRRZS	T1			;BLANK OUT GARBAGE
	TYPES	(< (>)			;ERROR CODE
	PUSHJ	P,OCTOUT		;IN OCTAL
	TYPES	(<) >)			;
	CAIG	T1,ERRLN.		;CODE GREATER THAN SIZE?
	TTCALL	3,@ERRTAB(T1)		;NO, OUTPUT THE STRING
X$$RNE:
X$$LKE:
X$$OPE:	PUSHJ	P,CRLF			;AND CRLF
	JRST	RESTRT			;BACK FOR NEXT COMMAND

; TABLE OF LOOKUP/ENTER FAILURE MESSAGES
; NON-APPLICABLE MESSAGES HAVE ZERO 

	DEFINE LEER(AA)<
IFNB <AA>,<[ASCIZ\AA\]>
IFB  <AA>,<[EXP 0]>
>

ERRTAB:	LEER(FILE NOT FOUND)
	LEER(NON-EXISTANT UFD)
	LEER(PROTECTION FAILURE)
	LEER(FILE BEING MODIFIED)
	LEER(ALREADY EXISTING FILENAME)
	LEER(ILLEGAL UUO SEQUENCE)
	LEER(BAD RIB OR UFD)
	LEER()
	LEER()
	LEER()
	LEER()
	LEER()
	LEER(NO ROOM OR QUOTA EXCEEDED)
	LEER(WRITE-LOCK ERROR)
	LEER(NOT ENOUGH MONITOR FREE CORE)
	LEER(PARTIAL ALLOCATION ONLY)
	LEER(BLOCK NOT FREE ON ALLOCATED POSITION)
	LEER(CANNOT SUPERSEDE DIRECTORY)
	LEER(CANNOT DELETE NON-EMPTY DIRECTORY)
	LEER(SFD NOT FOUND)
	LEER(SEARCH LIST EMPTY)
	LEER(SFD NESTING TOO DEEP)
	LEER(NO STRUCTURES IN PATH BOTH CREATABLE AND WRITEABLE)
	LEER()
	ERRLN.==.-ERRTAB	;LENGTH OF TABLE


SUBTTL SHARED UTILITY MODULES THAT CAN BE USED BY INITIA,GATHER, ETC
;
; THE FOLLOWING ROUTINES ARE AVAILABLE FOR USE BY ANY SYSTEM DATA
; ROUTINE. IN GENERAL THEY EXPECT USES FOR REGISTERS TO CONFORM
; TO THE STANDARD  SPECIFICALLY J,L,GT)
; REGISTER USAGE AND SIDE EFFECTS ARE AS DOCUMENTED


IFN SYS, <



; THIS ROUTINE TAKES CONTENTS OF GT AND PLACES THEM IN THE DB CELL
; IMMEDIATELY FOLLOWING THE CURRENT ONE.
;
; NOTE: ROUTINES USEING STONXT MUST ALLOCATE 1 MORE CELL PER DB THAN THERE
; ARE LOOKS PER REPORT

; EXPECTS VALUE IN GT,  PRESERVES ALL REGISTERS.

STONXT:	AOJ	L,			;POINT TO NEXT CELL
	MOVEM	GT,@TAB.P(J)		;PUT VALUE AWAY
	SOJ	L,			;FIX UP INDEX
	POPJ	P,			;AND RETURN


; ROUTINE TO MAKE GT BE A PERCENT OF THE CONTENTS OF GT
; DIVIDED BY THE NUMBER OF ELAPSED TICS
; EXPECTS GT TO HAVE VALUE.  ALL AC'S PRESERVED
;

PRETIC:	IMULI	GT,^D1000		;DONT LOSE PRECISION
	PUSH	P,GT+1			;GOING TO DO AN IDIV
	IDIV	GT,EL.TIC		;DO IT
	ADDI	GT,5			;ROUND IT
	IDIVI	GT,^D10			;DONE
	POP	P,GT+1			;RESTORE THE AC
	POPJ	P,			;AND RETURN

; DIVSEC:	DIVIDES BY NUMBER OF SECONDS THAT HAVE PASSED
;	EXPECTS VALUE IN GT, RETURNS VALUE IN GT.  USES EL.MS AS
;	ELAPSED SECONDS

DIVSEC:	IMULI	GT,^D1000		;MULTIPLY BY 1000
	PUSH	P,GT+1			;READY TO DO IDIV
	IDIV	GT,EL.MS		;DONE
	POP	P,GT+1			;RESTORE THE AC
	POPJ	P,			;AND RETURN


; ROUTINE TO TAKE A VALUE IN GT, LOOK IT UP AND CALL STONXT,
; GET CURRENT VALUE DIVIDED BY ELAPSED SECONDS AND DISMISS THE
; CALL.

INCSEC:	PUSHJ	P,FETTAB		;LOOK UP VALUE
	PUSHJ	P,STONXT		;STORE IN NEXT CELL
	SUB	GT,@TAB.P(J)		;SUBTRACT TO MAKE INCR.
	PUSHJ	P,DIVSEC		;DIVIDE BY ELAPSED SECS.
	MOVEM	GT,@TAB.P(J)		;STORE IT AWAY
	POPJ	P,			;AND RETURN

;CODE ADDED TO ALLOW FOR SIMPLE INCREMTAL VALUES
SIMINC:	PUSHJ	P,FETTAB		;LOOK UP VALUE
	PUSHJ	P,STONXT		;STORE IN NEXT CELL
	SUB	GT,@TAB.P(J)		;SUBTRACT TO MAKE INCR.
	MOVEM	GT,@TAB.P(J)		;STORE IT AWAY
	POPJ	P,			;AND RETURN

;ROUTINE TO SEE IF A GIVEN ITEM IS AVAILABLE, AND ALLOCATE CORE
; IF IT IS. CALL WITH THE GETTAB NUMBER IN GT.

DBOPTN:	PUSHJ	P,FETOPT		;IS THIS AVAILABLE?
	  POPJ	P,			;NO, DON'T ALLOCATE CORE
;	PJRST	DBCORE			;FALL THROUGH TO DBCORE


;	DBCORE  : SETS UP T1 WITH VALUE OF NUMBER OF LOOKS PER REPORT
;		AND THEN GOES TO ASSCOR. USED MAINLY TO SET UP
;		STANDARD LENGTH DATA BLOCKS FOR SYSTEM TRACKING.
;		ALSO SETS UP UP THE WORD POINTED TO BY REGISTER J
;		IN THE STANDARD DB FORMAT OF L,,ADDR
;		IE. SETS UP DB PTR UPON RETURN FROM ASSCOR

DBCORE:	MOVE	T1,RVAL			;GET LENGTH WANTED FOR DATA BLOCKS
	AOJ	T1,			;ADD ONE EXTRA CELL FOR INCR.
	PUSHJ	P,ASSCOR		;GO THERE, GET CORE
	TLO	T1,L			;MAKE INDEX REG. PTR
	MOVEM	T1,TAB.P(J)		;STASH IT AS WORD PTR
	TLZ	T1,L			;IN CASE A ROUTINE CHECKS
	POPJ	P,			;AND GO HOME




;	JOBBLK	: FINDS TOTAL NUMBER OF JOBS IN THE SYSTEM (POSSIBLE)
;		AND SETS UP A BLOCK OF THAT MANY WORDS.  IT THEN
;		RETURNS IN T1 A WORD OF THE FORM J,,ADDR
;		WHERE ADDR IS THE STARTING ADDRESS OF THE WORD
;	   NOTE: JOB 0 IS INCLUDED IN THE MAXIMUM

JOBBLK:	MOVE	T1,MAXJOB		;GET MAX NR OF JOBS
	MOVEI	T1,1(T1)		;PLUS ONE FOR NULL JOB
	PUSHJ	P,ASSCOR		;GET A BLOCK OF CORE
	TLO	T1,J			;MAKE AN INDEX REGISTER
	POPJ	P,			;AND RETURN


;*** END OF UTILITY ROUTINES ***		

> ; END OF SYS CONDITIONAL

SUBTTL INDIVIDUAL ROUTINES FOR GATHEREING,INITIA,AND DISPLAY
;
; ROUTINES OF A SPECIFIC NATURE FOR GATHERING INDIVIDUAL ITEMS
; AND FOR SPECIAL CASES WHERE UTILITY ROUTINES WONT WORK
;
; SEE SYSDAT MACRO FOR NAMES,CONVENTIONS

IFN SYS, <


;ROUTINE FOR GATHERING CPU0 LOST TIME

CP0L%G:	MOVX	GT, %CVLST		;LOOKUP LOST TIME
;	PJRST	CPCOMM			;FINISH UP

   ; OTHER CPU0 ROUTINES ENTER HERE FOR COMMON ACTIONS
CPCOMM:	PUSHJ	P,FETTAB		;DO IT
CPCOM2:	PUSHJ	P,STONXT		;STORE NEXT FOR INCREMENTAL
	SUB	GT,@TAB.P(J)		;MAKE THIS ONE INCREMENTAL
	PUSHJ	P,PRETIC		;MAKE IT A % OF ELAPSED TICS
	MOVEM	GT,@TAB.P(J)		;AND STASH IT
	POPJ	P,			;RETURN, WE ARE DONE

;ROUTINE FOR GATHERING CPU0 IDLE TIME

CP0I%G:	MOVX	GT,%CVNUL
	PUSHJ	P,FETTAB
	MOVE	T1,GT			;SAVE FOR SUBTRACT
	MOVX	GT,%CVLST		;NULL-LOST=IDLE
	PUSHJ	P,FETTAB
	SUBM	T1,GT			;RESULT IN GT
	PJRST	CPCOM2			;GO TO COMMON PLACE WITH ANSWER



;ROUTINE FOR GATHERING CPU0 OVERHEAD TIME

CP0O%G:	MOVX	GT, %CVOHT		;OVERHEAD TIME
	PJRST	CPCOMM			;DO COMMON CPU STUFF


;ROUTINE FOR GATHERING UUOS PER SECOND

CP0U%G:	MOVX	GT,%CVTUC		;GET
	PJRST	INCSEC			;STORE INCREMENTAL BY SECS

; ROUTINE FOR GATHERING CONTEXT SWITCHES PER SECOND

CP0C%G:	MOVX	GT, %CVTJC		;LOOK UP CONTEXT SWITCHES
	PJRST	INCSEC			;STORE INCREM./SECS ELAPSED


; SECOND PROCESSOR STUFF
	
;
;	INITIALIZE FOR LOST,IDLE,OVERHEAD AND CONTEXT ONLY IF CPU1 EXISTS

CP1INI:	MOVE	T1,NCPU			;[217] # CPUS BUILT FOR
	CAIGE	T1,2			;CPU1 THERE?
	POPJ	P,			;NO , RETURN
	PJRST	DBCORE			;GET CORE AND RETURN
;
; COMMON STUFF FOR SECOND PROCESSOR

CP1I%G:	MOVX	GT, %CVNUL+2		;NULL JOB TIME FOR CPU1
	PUSHJ	P,FETTAB		;GET
	MOVE	T1,GT			;SAVE FOR SUBTRACE
	MOVX	GT,%CVLST+2		;SAME AS ON CPU0
	PUSHJ	P,FETTAB
	SUBM	T1,GT
	PJRST	CPCOM2			;GO TO COMMON ROUTINE, NO GETTAB.
					; PRINT IN % ELAPSED TICKS.

CP1L%G:	MOVX	GT, %CVLST+2		;LOST TIME FOR CPU1
	PJRST	CPCOMM

CP1O%G:	MOVX	GT, %CVOHT+2		;OVERHEAD TIME FOR CPU1
	PJRST	CPCOMM

CP1C%G:	MOVX	GT, %CVTJC+2		;CONTEXT SWITCHES
	PJRST	INCSEC		;SAME AS FOR CPU0

;ROUTINE FOR GATHERING UUOS PER SECOND ON CPU1

CP1U%G:	MOVX	GT,%CVTUC+2		;UUOS PER SECOND
	PJRST	INCSEC			;PRINT THIS-LAST/<ELAPSED SECS>

;[217] THIRD PROCESSOR STUFF
	
;
;	INITIALIZE FOR LOST,IDLE,OVERHEAD AND CONTEXT ONLY IF CPU2 EXISTS

CP2INI:	MOVE	T1,NCPU			;[217] # CPUS BUILT FOR
	CAIGE	T1,3			;CPU2 THERE?
	POPJ	P,			;NO , RETURN
	PJRST	DBCORE			;GET CORE AND RETURN
;
; COMMON STUFF FOR SECOND PROCESSOR

CP2I%G:	MOVX	GT, %CVNUL+4		;NULL JOB TIME FOR CPU2
	PUSHJ	P,FETTAB		;GET
	MOVE	T1,GT			;SAVE FOR SUBTRACE
	MOVX	GT,%CVLST+4		;SAME AS ON CPU0
	PUSHJ	P,FETTAB
	SUBM	T1,GT
	PJRST	CPCOM2			;GO TO COMMON ROUTINE, NO GETTAB.
					; PRINT IN % ELAPSED TICKS.

CP2L%G:	MOVX	GT, %CVLST+4		;LOST TIME FOR CPU2
	PJRST	CPCOMM

CP2O%G:	MOVX	GT, %CVOHT+4		;OVERHEAD TIME FOR CPU2
	PJRST	CPCOMM

CP2C%G:	MOVX	GT, %CVTJC+4		;CONTEXT SWITCHES
	PJRST	INCSEC		;SAME AS FOR CPU0

;ROUTINE FOR GATHERING UUOS PER SECOND ON CPU2

CP2U%G:	MOVX	GT,%CVTUC+4		;UUOS PER SECOND
	PJRST	INCSEC			;PRINT THIS-LAST/<ELAPSED SECS>

;[217] FOURTH PROCESSOR STUFF
	
;
;	INITIALIZE FOR LOST,IDLE,OVERHEAD AND CONTEXT ONLY IF CPU3 EXISTS

CP3INI:	MOVE	T1,NCPU			;[217] # CPUS BUILT FOR
	CAIGE	T1,4			;CPU3 THERE?
	POPJ	P,			;NO , RETURN
	PJRST	DBCORE			;GET CORE AND RETURN
;
; COMMON STUFF FOR SECOND PROCESSOR

CP3I%G:	MOVX	GT, %CVNUL+6		;NULL JOB TIME FOR CPU3
	PUSHJ	P,FETTAB		;GET
	MOVE	T1,GT			;SAVE FOR SUBTRACE
	MOVX	GT,%CVLST+6		;SAME AS ON CPU0
	PUSHJ	P,FETTAB
	SUBM	T1,GT
	PJRST	CPCOM2			;GO TO COMMON ROUTINE, NO GETTAB.
					; PRINT IN % ELAPSED TICKS.

CP3L%G:	MOVX	GT, %CVLST+6		;LOST TIME FOR CPU3
	PJRST	CPCOMM

CP3O%G:	MOVX	GT, %CVOHT+6		;OVERHEAD TIME FOR CPU3
	PJRST	CPCOMM

CP3C%G:	MOVX	GT, %CVTJC+6		;CONTEXT SWITCHES
	PJRST	INCSEC		;SAME AS FOR CPU0

;ROUTINE FOR GATHERING UUOS PER SECOND ON CPU3

CP3U%G:	MOVX	GT,%CVTUC+6		;UUOS PER SECOND
	PJRST	INCSEC			;PRINT THIS-LAST/<ELAPSED SECS>

;[217] FIFTH PROCESSOR STUFF
	
;
;	INITIALIZE FOR LOST,IDLE,OVERHEAD AND CONTEXT ONLY IF CPU4 EXISTS

CP4INI:	MOVE	T1,NCPU			;[217] # CPUS BUILT FOR
	CAIGE	T1,5			;CPU1 THERE?
	POPJ	P,			;NO , RETURN
	PJRST	DBCORE			;GET CORE AND RETURN
;
; COMMON STUFF FOR FIFTH PROCESSOR

CP4I%G:	MOVX	GT, %CVNUL+10		;NULL JOB TIME FOR CPU4
	PUSHJ	P,FETTAB		;GET
	MOVE	T1,GT			;SAVE FOR SUBTRACE
	MOVX	GT,%CVLST+10		;SAME AS ON CPU0
	PUSHJ	P,FETTAB
	SUBM	T1,GT
	PJRST	CPCOM2			;GO TO COMMON ROUTINE, NO GETTAB.
					; PRINT IN % ELAPSED TICKS.

CP4L%G:	MOVX	GT, %CVLST+10		;LOST TIME FOR CPU4
	PJRST	CPCOMM

CP4O%G:	MOVX	GT, %CVOHT+10		;OVERHEAD TIME FOR CPU4
	PJRST	CPCOMM

CP4C%G:	MOVX	GT, %CVTJC+10		;CONTEXT SWITCHES
	PJRST	INCSEC		;SAME AS FOR CPU0

;ROUTINE FOR GATHERING UUOS PER SECOND ON CPU4

CP4U%G:	MOVX	GT,%CVTUC+10		;UUOS PER SECOND
	PJRST	INCSEC			;PRINT THIS-LAST/<ELAPSED SECS>


;[217] SIXTH PROCESSOR STUFF
	
;
;	INITIALIZE FOR LOST,IDLE,OVERHEAD AND CONTEXT ONLY IF CPU5 EXISTS

CP5INI:	MOVE	T1,NCPU			;[217] # CPUS BUILT FOR
	CAIGE	T1,6			;CPU5 THERE?
	POPJ	P,			;NO , RETURN
	PJRST	DBCORE			;GET CORE AND RETURN
;
; COMMON STUFF FOR SIXTH PROCESSOR

CP5I%G:	MOVX	GT, %CVNUL+12		;NULL JOB TIME FOR CPU5
	PUSHJ	P,FETTAB		;GET
	MOVE	T1,GT			;SAVE FOR SUBTRACE
	MOVX	GT,%CVLST+12		;SAME AS ON CPU0
	PUSHJ	P,FETTAB
	SUBM	T1,GT
	PJRST	CPCOM2			;GO TO COMMON ROUTINE, NO GETTAB.
					; PRINT IN % ELAPSED TICKS.

CP5L%G:	MOVX	GT, %CVLST+12		;LOST TIME FOR CPU5
	PJRST	CPCOMM

CP5O%G:	MOVX	GT, %CVOHT+12		;OVERHEAD TIME FOR CPU5
	PJRST	CPCOMM

CP5C%G:	MOVX	GT, %CVTJC+12		;CONTEXT SWITCHES
	PJRST	INCSEC		;SAME AS FOR CPU0

;ROUTINE FOR GATHERING UUOS PER SECOND ON CPU5

CP5U%G:	MOVX	GT,%CVTUC+12		;UUOS PER SECOND
	PJRST	INCSEC			;PRINT THIS-LAST/<ELAPSED SECS>




;ROUTINES FOR SPECIAL KL10 ONLY VARIABLES
; MOST OF THESE ARE ONLY USEFUL ON 1088 SYSTEMS

;ROUTINES TO INITIALIZE, IF NECESSARY

CL0INI:	PUSHJ	P,ISCPKL		;IS CPU A KL10?
	  POPJ	P,			;NO, DON'T ALLOCATE ANYTHING
	PJRST	DBCORE			;YES, ALLOCATE DB AND RETURN

;ROUTINE SAME AS CL0INI, EXCEPT CPU1 MUST EXIST TOO.

CL1INI:	PUSHJ	P,ISCPL1		;IS THIS 1088 SYSTEM?
	  POPJ	P,			;NO, RETURN
	PJRST	DBCORE			;YES, ALLOCATE DB AND RETURN

;ROUTINE SAME AS CL0INI, EXCEPT CPU2 MUST EXIST TOO.

CL2INI:	PUSHJ	P,ISCPL2		;IS THIS SMP SYSTEM?
	  POPJ	P,			;NO, RETURN
	PJRST	DBCORE			;YES, ALLOCATE DB AND RETURN

;ROUTINE SAME AS CL0INI, EXCEPT CPU3 MUST EXIST TOO.

CL3INI:	PUSHJ	P,ISCPL3		;IS THIS SMP SYSTEM?
	  POPJ	P,			;NO, RETURN
	PJRST	DBCORE			;YES, ALLOCATE DB AND RETURN

;ROUTINE SAME AS CL0INI, EXCEPT CPU4 MUST EXIST TOO.

CL4INI:	PUSHJ	P,ISCPL4		;IS THIS SMP SYSTEM?
	  POPJ	P,			;NO, RETURN
	PJRST	DBCORE			;YES, ALLOCATE DB AND RETURN

;ROUTINE SAME AS CL0INI, EXCEPT CPU5 MUST EXIST TOO.

CL5INI:	PUSHJ	P,ISCPL5		;IS THIS SMP SYSTEM?
	  POPJ	P,			;NO, RETURN
	PJRST	DBCORE			;YES, ALLOCATE DB AND RETURN


;ROUTINES TO GATHER KL10 CACHE RELATED INFO

L0SD%G:	MOVX	GT,%CVCSD		;NUMBER OF CACHE SWEEP REQ.
		PJRST	INCSEC			;PER SECOND
L1LN%G:	SKIPA	GT,[%CVCLN+2]		;FOR CPU1
L0LN%G:	MOVX	GT,%CVCLN		;SCHEDULER CACHE SWEEP REQ
	PJRST	INCSEC			;PER SECS ELASPED
L1RN%G:	SKIPA	GT,[%CVCRN+2]
L0RN%G:	MOVX	GT,%CVCRN		;REQ ACTUALLY SWEPT FOR
	PJRST	INCSEC			;PER SECOND
L1LT%G:	SKIPA	GT,[%CVCLT+2]		;FOR CPU1
L0LT%G:	MOVX	GT,%CVCLT
	PJRST	CPCOMM

L1SN%G:	SKIPA	GT,[%CVCSN+2]		;NUMBER OF CACHE SWEEPS
L0SN%G:	MOVX	GT,%CVCSN		;NUMBER OF CACHE SWEEPS
	PJRST	INCSEC			;PER SECOND


;CPU2 & CPU3
L3LN%G:	SKIPA	GT,[%CVCLN+6]		;FOR CPU3
L2LN%G:	MOVX	GT,%CVCLN+4		;CPU2:  SCHEDULER CACHE SWEEP REQ
	PJRST	INCSEC			;PER SECS ELASPED
L3RN%G:	SKIPA	GT,[%CVCRN+6]
L2RN%G:	MOVX	GT,%CVCRN+4		;REQ ACTUALLY SWEPT FOR
	PJRST	INCSEC			;PER SECOND
L3LT%G:	SKIPA	GT,[%CVCLT+6]		;FOR CPU3
L2LT%G:	MOVX	GT,%CVCLT+4		;FOR CPU2
	PJRST	CPCOMM
L3SN%G:	SKIPA	GT,[%CVCSN+6]		;NUMBER OF CACHE SWEEPS
L2SN%G:	MOVX	GT,%CVCSN+4		;NUMBER OF CACHE SWEEPS
	PJRST	INCSEC			;PER SECOND



;CPU4 & CPU5
L5LN%G:	SKIPA	GT,[%CVCLN+12]		;FOR CPU5
L4LN%G:	MOVX	GT,%CVCLN+10		;CPU4:  SCHEDULER CACHE SWEEP REQ
	PJRST	INCSEC			;PER SECS ELASPED
L5RN%G:	SKIPA	GT,[%CVCRN+12]
L4RN%G:	MOVX	GT,%CVCRN+10		;REQ ACTUALLY SWEPT FOR
	PJRST	INCSEC			;PER SECOND
L5LT%G:	SKIPA	GT,[%CVCLT+12]		;FOR CPU5
L4LT%G:	MOVX	GT,%CVCLT+10		;FOR CPU4
	PJRST	CPCOMM
L5SN%G:	SKIPA	GT,[%CVCSN+12]		;NUMBER OF CACHE SWEEPS
L4SN%G:	MOVX	GT,%CVCSN+10		;NUMBER OF CACHE SWEEPS
	PJRST	INCSEC			;PER SECOND



;ROUTINES TO CHECK ON WHETHER OR NOT THIS IS A SINGLE-CPU OR SMP SYSTEM.
; ISCPLn SKIPS IF RUNNING ON n+1 CPU SMP, ISCPKL SKIPS IF RUNNING ON KL10.
; USES T2

ISCPL1:	MOVE	T2,NCPU			;[217] GET #CPU
	CAIGE	T2,2			;ANY CPU1 AT ALL?
	POPJ	P,			;NO, CANT BE 1088
					;FALL INTO ISCPKL
ISCPKL:	MOVE	T2,CPUTYP		;GET CPU TYPE CODE
	CAXN	T2,.CCKLX		;IS THIS A KL10?
	AOS	(P)			;YES, SET SKIP RETURN
	POPJ	P,			;RETURN ONE WAY OR THE OTHER

;[217] SAME ROUTINES, FOR CPU2, CPU3, CPU4, CPU5
ISCPL2:	MOVE	T2,NCPU			;[217] GET #CPU
	CAIGE	T2,3			;ANY CPU2 AT ALL?
	POPJ	P,			;NO, CANT BE 1088
	JRST	ISCPKL

ISCPL3:	MOVE	T2,NCPU			;[217] GET #CPU
	CAIGE	T2,4			;ANY CPU3 AT ALL?
	POPJ	P,			;NO, CANT BE 1088
	JRST	ISCPKL

ISCPL4:	MOVE	T2,NCPU			;[217] GET #CPU
	CAIGE	T2,5			;ANY CPU4 AT ALL?
	POPJ	P,			;NO, CANT BE 1088
	JRST	ISCPKL

ISCPL5:	MOVE	T2,NCPU			;[217] GET #CPU
	CAIGE	T2,6			;ANY CPU5 AT ALL?
	POPJ	P,			;NO, CANT BE 1088
	JRST	ISCPKL


; ROUTINE FOR INITIALIZING  USER DISK STUFF

UDIO%I:	PUSHJ	P,JOBBLK		;SET UP A JOB TABLE BLOCK
	MOVEM	T1,DIOTAB		;STORE THE J,,ADDR PTR
	PJRST	DBCORE			;SET UP A DATA BLOCK, RETURN


; ROUTINE TO GATHER INCREMENTAL DISK I/O
; FILLS TWO VALUES, INCDIO: GETS DISK BLOCKS SINCE LAST CALL
;		    INCSWP: GETS DISK BLOCKS SWAPPED
;
; EXPECTS DIOTAB TO POINT TO A BLOCK OF WORDS AS LONG AS # JOBS
; IN SYSTEM,  DIOTAB WORD SHOULD HAVE FORM J,,ADDR
; NOTE: ALSO SETS UP INCSWP FOR SWAPPING STATISTICS SO MAKE
;  SURE USER DISK IO APPEARS BEFORE SWAPPING IO IN SYSDAT MACRO

UDIO%G:	PUSH	P,J			;SAVE REGISTER J
	SETZ	N2,			;N2 GETS TALLY
	MOVE	J,HIJOB			;J GETS HIGHEST JOB NUMBER ASSIGNED
UDILOP:	SKIPGE	@JOBTB1			;SEE IF JOB LOGGED IN
	JRST	NODIO			;HE IS NOT
	MOVSI	GT,(J)			;DO A DISK RD/WR GETTAB
	HRRI	GT,.GTRCT		;FIRST READS
	PUSHJ	P,FETTAB		;LOOKING UP
	LDB	T1,DBP			;GET JUST TOTAL
	MOVSI	GT,(J)			;LOOK UP WRITES TOO
	HRRI	GT,.GTWCT		;LOOK UP WRITES
	PUSHJ	P,FETTAB		;
	LDB	GT,DBP			;CLEAR INCREMENTAL
	ADD	GT,T1			;GET THE TOTAL OF THE TWO
	MOVE	N1,@DIOTAB		;PICK UP LAST SEEN VALUE
	MOVEM	GT,@DIOTAB		;AND STORE NEW ONE
	CAML	GT,N1			;IS CURRENT VALUE LESS?
	SUB	GT,N1			;NO, SUBTRACT OLD FROM NEW
	JUMPN	J,DIO1A			;DOING JOB 0?
	MOVEM	GT,INCSWP		;YES, STORE SWAPPED BLOCKS
	SKIPA				;AND DONT ADD TO USER TOTAL
DIO1A:	ADD	N2,GT			;ADD TO TOTAL
DIO1B:	SOJGE	J,UDILOP		;MORE TO DO?
	MOVEM	N2,INCDIO		;STORE THE NEW VALUE
	POP	P,J			;RESTORE J
	MOVE	GT,INCDIO		;GET USER DISK IO
	PUSHJ	P,DIVSEC		;DIVIDE BY NUMBER OF SECS PASSED
	SKIPL	TAB.P(J)		;MIGHT BE NO DB IF UDIO WAS EXCLUDED
	MOVEM	GT,@TAB.P(J)		;OTHERWISE STORE OBTAINED VALUE
	POPJ	P,			;AND RETURN

NODIO:	SETZM	@DIOTAB			;CLEAR THE LOCATION
	JRST	DIO1B			;AND RE-ENTER LOOP


; ROUTINE TO TAKE SWAPPING IO BLOCKS, DONE BY ABOVE
; AND STORE IN DB AS VALUE/SEC
; NOTE: THIS ROUTINE MUST BE CALLED AFTER UDIO%G

SWIO%G:	SKIPGE	UDIO.P			;WAS USER IO DONE?
	PUSHJ	P,UDIO%G		;NO,MUST CALL IT HERE THEN
	MOVE	GT,INCSWP		;GET SWAPPED VALUE
	PUSHJ	P,DIVSEC		;PER SECOND
	MOVEM	GT,@TAB.P(J)		;DONE
	POPJ	P,


SWIO%I:	SKIPGE	UDIO.P			;DID USER IO GET SET UP?
	PJRST	UDIO%I			;NO,DO IT HERE WHICH SETS UP OUR DB
	PJRST	DBCORE			;OTHERWISE JUST GET A DB

; ROUTINE TO FIND THE NUMBER OF PAGES OF SWAPPING SPACE LEFT

SWPS%G:	MOVE	GT,[%SWVRT]		;GET NUMBER OF PAGES LEFT
	PUSHJ	P,FETTAB		;LOOK IT UP
	MOVEM	GT,@TAB.P(J)		;STORE IT
	POPJ	P,			;RETURN



; ROUTINE TO INITIALIZE A JOB BLOCK AND DB FOR GETTING INCREMENTAL
; USER KCS/SECOND

UKCS%I:	PUSHJ	P,JOBBLK		;GET A JOB BLOCK
	MOVEM	T1,KCSTAB		;STORE IT
	PJRST	DBCORE			;GET DB AND RETURN FROM THERE


; ROUTINE TO GATHER DATA FOR INCREMENTAL KCS

UKCS%G:	PUSH	P,J			;SAVE J
	MOVE	J,HIJOB			;HIGHEST JOB NUMBER
	SETZ	N2,			;N2 IS THE ACCUM VALUE
UKLOP:	SKIPGE	@JOBTB1			;IF JOB NOT LOGGED IN
	JRST	NOKCS			;SKIP HIM
	MOVSI	GT,(J)			;LOOK UP JOB
	HRRI	GT,.GTKCT		;IN PDB OR VIA GETTAB
	PUSHJ	P,FETTAB		
	MOVE	N1,@KCSTAB		;PICK UP OLD VALUE
	MOVEM	GT,@KCSTAB		;STORE NEW VALUE
	CAML	GT,N1			;NEW LESS THAN OLD?
	SUB	GT,N1			;NO, SUBTRACT OLD
	ADD	N2,GT			;ADD TO TOTAL
UKCS1A:	SOJG	J,UKLOP			;MORE TO DO?
	POP	P,J			;RESTORE J
	IDIVI	N2,^D60			;DIVIDE BY 60 TO MAKE KCS FROM KCT
	MOVE	GT,N2			;GET A VALUE OVER ELAPSED SECONDS
	PUSHJ	P,DIVSEC		;
	MOVEM	GT,@TAB.P(J)		;STORED
	POPJ	P,			;AND RETURN

NOKCS:	SETZM	@KCSTAB			;CLEAR IT
	JRST	UKCS1A			;AND RE-ENTER LOOP
; ROUTINE TO INITIALIZE A JOB BLOCK AND DB FOR GETTING INCREMENTAL
; USER CPU TICKS/SECOND

CPUT%I:	PUSHJ	P,JOBBLK		;GET A JOB BLOCK
	MOVEM	T1,CPTTAB		;STORE IT
	PJRST	DBCORE			;GET DB AND RETURN FROM THERE
;


; ROUTINE TO GATHER DATA FOR INCREMENTAL CPU TICKS

CPUT%G:	PUSH	P,J			;SAVE J
	MOVE	J,HIJOB			;HIGHEST JOB NUMBER
	SETZ	N2,			;N2 IS THE ACCUM VALUE
CTLOP:	SKIPGE	@JOBTB1			;IF JOB NOT LOGGED IN
	JRST	NOCPT			;SKIP HIM
	MOVSI	GT,(J)			;LOOK UP JOB
	HRRI	GT,.GTTIM		;IN PDB OR VIA GETTAB
	PUSHJ	P,FETTAB		
	MOVE	N1,@CPTTAB		;PICK UP OLD VALUE
	MOVEM	GT,@CPTTAB		;STORE NEW VALUE
	CAML	GT,N1			;NEW LESS THAN OLD?
	SUB	GT,N1			;NO, SUBTRACT OLD
	ADD	N2,GT			;ADD TO TOTAL
CPUT1A:	SOJG	J,CTLOP			;MORE TO DO?
	POP	P,J			;RESTORE J
	MOVE	GT,N2			;GET A VALUE OVER ELAPSED SECONDS
	PUSHJ	P,DIVSEC		;
	MOVEM	GT,@TAB.P(J)		;STORED
	POPJ	P,			;AND RETURN

NOCPT:	SETZM	@CPTTAB			;CLEAR IT
	JRST	CPUT1A			;AND RE-ENTER LOOP
>
;HERE TO COMPUTE THE 'REAL RESPONSE TIME'. APPLIES THE FOLLOWING
;RELATIONSHIP: (FROM QUEUEING THEORY)
;	  # OF JOBS IN 'READY TO RUN OR RUNNING' STATE
;RESP =   ---------------------------------------------------
;	  # OF INTERACTIONS (CR'S) PER SECOND OVER INTERVAL
;
; WHICH REDUCES TO: RESP = (READY JOBS)*(PEEK INTERVAL)/(INTERACTIONS)
RESP%G:	MOVX	GT,%CCRSP		;GET OFFSET OF RESP SUB TAB
	PUSHJ	P,FETTAB		;FROM THE MON
	ADDI	GT,%CVRNX		;GET OFFSET INTO RESP TABLE
	HRLS	GT			;INTO LH
	HRRI	GT,.GTC0V		;GET THE VAR TABLE #
	PUSHJ	P,FETTAB		;FROM MON
	MOVE	T1,GT			;SAVE
	MOVX	GT,%SYNCP		;GET # RESP FROM COMMAND LEVEL
	PUSHJ	P,FETTAB		;..
	ADD	GT,T1			;TOTAL # OF RESPONSES
	PUSHJ	P,STONXT		;SAVE FOR INCREMENTAL
	SUB	GT,@TAB.P(J)		;GET DIFFERENCE FROM LAST TIME
	MOVE	T1,JOBRN		;GET JOBS IN 'RN' STATE
	ADD	T1,JOBSHR		;ADD JOBS IN SHAR RES WAIT STATE
	ADD	T1,JOBIO		;AND JOBS IN IO WAIT (LESS TTY)
	IMUL	T1,QTUM			;TIMES PEEK INTERVAL
	IMULI	T1,^D1000		;MAKE IT MILLESEC
	IDIV	T1,GT			;AND DIV BY RESPONSES
	MOVEM	T1,@TAB.P(J)		;STASH FOR REPORTER
	POPJ	P,

; ROUTINE TO GATHER THE AVERAGE RESPONSE TIME OVER EACH TRACK INTERVAL
; BY LOOKING AT THE NON-SWAPPING DATA TABLE AND DIVIDING THE INCREMENTAL
;TIME SPENT WAITING BY THE INCREMENTAL NUMBER OF RESPONSES.
; THE VALUE OBTAINED IS STORED IN MS. FORM IN THE DB ALLOCATED FOR THIS
; PARAMETER.

AVRT%G:	MOVX	GT,%NSNCR		;GET NUMBER OF RESPONSES (TOTAL)
	PUSHJ	P,FETTAB		;FROM THE MONITOR
	PUSH	P,GT			;SAVE IT
	SUB	GT,NSNCRL		;SUBTRACT LAST-SEEN VALUE
	POP	P,NSNCRL		;AND MAKE CURRENT THE LAST SEEN
	MOVEM	GT,T2			;SAVE FOR THE DIVIDE
	MOVX	GT,%NSACR		;GET THE TOTAL NUMBER OF RESPONSES
	PUSHJ	P,FETTAB		;
	PUSHJ	P,STONXT		;SAVE TOTAL IN CURRENT DB CELL+1
	SUB	GT,@TAB.P(J)		;AND MAKE (GT) BE INCR. VALUE
	MOVEM	GT,T1			;READY FOR THE DIVIDE
	IDIV	T1,T2			;T1 GETS AVG # OF JIFFIES/RESPONSE
	IMULI	T1,^D100		;CONVERT TO MS.
	IDIVI	T1,^D6			;
	MOVEM	T1,@TAB.P(J)		;STORE IT
	POPJ	P,			;AND RETURN



SUBTTL LOGGED IN JOB ANALYSIS ROUTINE
;  DOES ALL THE ANALYSIS FOR ALL JOB RELATED DATA
; SUCH AS ASR , AVE JOB SIZE, WHAT QUEUES JOBS ARE IN

ANALYZ:	PUSH	P,J			;SAVE J
	MOVE	T1,[XWD SEGTAB,SEGTAB+1]	;PREPARE TO ZERO JOB RELATED DATA AREA
	SETZM	SEGTAB			;
	BLT	T1,ACTCOR		;DONE
	MOVE	J,HIJOB			;GET HIGHEST JOB NUMBER ASSIGNED
	
ANAL1:	
	SKIPGE	@JOBTB1			;-1 ENTRY IN JOBTB1 MEANS NOT LOGGED IN
	JRST	NOTACT			;SO SKIP HIM
	HRRZ	T2,@JOBTB1		;GET HIGH CORE ALLOCATION
	HLRZ	T1,@JOBTB1		;AND LOW CORE ALLOCATION
	ADDM	T1,TOTCOR		;AND UPDATE TOTAL VIRT CORE IN USE
	ADDM	T2,TOTCOR		;FOR AVERAGE JOB SIZE
	ADDM	T1,SHRCOR		;STORE SHARED CORE
	PUSHJ	P,SEESHR		;SKIPS IF HAVE SEEN THIS HI-SEG
					;ALREADY IN DOING SHARED
	  ADDM	T2,SHRCOR		;ADD HIGH SEGMENT TOO(MAYBE)
	HRL	T3,@JOBTB2		;GET (RH) JOBTB2 ENTRY
	JUMPGE	T3,NOTACT		;IF RUN BIT OFF
	HLRZS	T3			;SWAP HALVES
	ANDI	T3,7777			;BLANK ALL BUT SIXBIT CODE
	CAIN	T3,'TI'			;IN TI STATE
	JRST	NOTRUN			;MEANS JOB NOT ACTIVE
	CAIE	T3,'SL'			;SLEEPING OR HIBERNATING
	CAIN	T3,'HB'			;MEANS
	JRST	NOTACT			;NOT ACTIVE
	ADDM	T1,ACTCOR		;UPDATE ACTIVE CORE
	PUSHJ	P,SEEACT		;DONT COUNT SHARED SEGMENTS TWICE
	  ADDM	T2,ACTCOR		;
	CAIE	T3 ,'RN'		;RUN QUEUE?
	JRST	NOTRUN			;NO
	AOS	JOBRN			;A RUNNING JOB
	SKIPL	@JOBTB2			;AND IN CORE?
	AOS	JOBRNC			;YES, COUNT HIM AS THAT
	JRST	NOTACT			;DONE WITH HIM

NOTRUN:	CAIN	T3 ,'PI'		;DOING PAGING I/O?
	JRST	YIO			;YES, COUNT HIM AS IN IO
	CAIE	T3 ,'TI'		;TI OR TO IS TTY IO
	CAIN	T3 ,'TO'		;SO COUNT HIM AS THAT
	AOSA	JOBTTY			;UPDATED COUNTER
	JRST	.+2
	JRST	NOTACT			;IF TTY PERSON, DONE WITH HIM
	CAIE	T3 ,'DI'		;OTHER IO
	CAIN	T3 ,'IO'		;DI OR IO
YIO:	AOSA	JOBIO			;JOBS DOING IO COUNTER
	JRST	.+2			;STILL HAVE NOT FOUND HIS SLOT
	JRST	NOTACT			;FOUND HIM
	MOVEI	N1,SHRQLN		;NUMBER OF SHARE QUEUE NAMES PACKED
					;THREE TO A WORD
	MOVE	N2,[POINT 12,SHRQ]	;BYTE POINTER TO SAME
SHRQL:	ILDB	N3,N2			;GET A SHARE Q NAME
	CAMN	N3,T3 			;IS IT HIM?
	AOSA	JOBSHR			;YES, FINIS
	SOJG	N1,SHRQL		;NO, SEE IF MORE TO DO
NOTACT:	SOJG	J,ANAL1		;IF MORE
	POP	P,J			;RESTORE J
	POPJ	P,			;AND RETURN


; THIS ROUTINE IS USED FOR ACCOUNTING FOR SHARED HISEGMENTS
; A BIT MAP IS USED , 1 BIT FOR EACH SEGMENT
; A 0 BIT INDICATES WE HAVE NOT SEEN THIS SEGMENT BEFORE
; A 1 BIT MEANS IT HAS BEEN COUNTED ALREADY.  WORDS 0-7 OF SEGTAB
; A THE MAP FOR ALL USERS, WORDS 10-17 ARE FOR ACTIVE USERS
SEESHR:	SKIPA	N1,[XWD N1,SEGTAB]	;INDIRECT WORD TO SEGTAB INDEX BY N1
SEEACT:	MOVE	N1,[XWD N1,SEGTAB+10]	;INDIRECT WORD FOR ACTIVE USERS
	MOVEM	N1,SEGPTR		;STORE IT
	JUMPE	T2,NOHIC		;IF HAS NO HI-SEG, NO NEED TO ADJUST IT
	HLRZ	N1,@JOBTB2		;GET HIGH SEGMENT NUMBER
	TRZ	N1,400000		;CLEAR SWAPPED OUT BIT
	IDIVI	N1,^D36			;FIND WORD IN SEGMENT BIT MAP
	MOVE	T4 ,@SEGPTR		;GET PROPER WORD
	MOVEI	N3,1			;READY TO SET UP FOR PARTICULAR BIT
	LSH	N3,(N2)			;DO IT
	TDOE	T4 ,N3			;READ AND UPDATE BIT MAP
	AOS	(P)			;ALREADY SEEN, TAKE SKIP RETURN
	MOVEM	T4 ,@SEGPTR		;STORE IT BACK
NOHIC:	POPJ	P,			;RETURN


SHRQ:	STASH(AUMQDACBD1D2DCM1M2T1CAEVJD^D^W)
	SHRQLN==ZZ/2		;NUMBER OF QUEUES IN TABLE



SUBTTL HANDLE ANALYZED JOB DATA

; ROUTINE TO STORE NUMBER OF JOBS LOGGED IN

JLGN%G:	MOVE	T1,NUMJOB		;GET IT
	MOVEM	T1,@TAB.P(J)		;AND STORE IN APPROPRIATE PLACE
	POPJ	P,			;THEN RETURN

; ROUTINE TO STASH ACTIVE SWAPPING RATIO

ACCR%G:	MOVE	N1,ACTCOR		;GET ACTIVE CORE IN USE
;  PHRC%G ENTERS HERE FOR COMMON STUFF
CORCOM:	IMULI	N1,^D1000		;GET READY TO DIVIDE
	IDIV	N1,USIZ			;SIZE OF USER MEMORY
	ADDI	N1,5			;ROUND IT
	IDIVI	N1,^D10			;DONE
	MOVEM	N1,@TAB.P(J)		;DONE AND STASHED
	POPJ	P,			;RETURN


; ROUTINE TO GET SWAPPING RATIO FROM SHRCOR AND USIZ

PHCR%G:	MOVE	N1,SHRCOR		;GET TOTAL CORE IN USE
	PJRST	CORCOM			;DO SAME AS ABOVE



; ROUTINE TO GET AVERAGE JOB SIZE FROM TOTCOR AND NUMJOB

AVJS%G:	MOVE	N1,TOTCOR		;TOTAL CORE IN USE
	IDIV	N1,NUMJOB		;DIVIDE BY NUMBER OF JOBS
	LSH	N2,1			;MULTIPLY REMAINDER BY 2
	CAML	N2,NUMJOB		;ROUND UP IF HAVE TO
	ADDI	N1,1
	MOVEM	N1,@TAB.P(J)		;STORE
	POPJ	P,			;AND RETURN


; ROUTINE TO STASH NUMBER OF JOBS IN RUN QUEUE

NRJR%G:	MOVE	N1,JOBRN		;GET IT
	MOVEM	N1,@TAB.P(J)		;STORE IT
	POPJ	P,			;AND RETURN


; ROUTINE TO GET PERCENT OF JOBS IN RUN QUEUE THAT ARE IN CORE


PRJC%G:	MOVE	N1,JOBRNC		;GET NUMBER OF JOBS IN RUN QUE IN COREUE
	IMULI	N1,^D1000		;READY TO DIVIDE
	IDIV	N1,JOBRN		;DIVIDE
	ADDI	N1,5			;ROUND
	IDIVI	N1,^D10			;DO IT
	MOVEM	N1,@TAB.P(J)		;STORE IT
	POPJ	P,			;AND RETURN


; ROUTINE TO STASH NR OF JOBS IN TTY IO QUEUES

TIOW%G:	MOVE	N1,JOBTTY		;GET NUMBER OF JOBS IN TTY QUEUES
	MOVEM	N1,@TAB.P(J)		;AND STORE IT
	POPJ	P,			;AND RETURN

; ROUTINE TO STASH NUMBER OF JOBS IN OTHER WAIT QUEUES

IOW%G:	MOVE	N1,JOBIO		;PICK UP COUNT AS SEEN BY OTHER ROUTINE
	MOVEM	N1,@TAB.P(J)		;STORE IT
	POPJ	P,			;AND THATS IT


; ROUTINE TO STORE NUMBER OF JOBS SEEN IN SHAREABLE RESOURCE QUEUES

JSHQ%G:	MOVE	N1,JOBSHR		;PICK UP
	MOVEM	N1,@TAB.P(J)		;AND STORE IT
	POPJ	P,			;AND THATS ALL


SUBTTL PHYSICAL DISK UNIT ANALYSIS/INITIALIZATION ROUTINES

; HERE WE GO OVER THE LIST POINTED TO BY THE POINTER "UNIPTR"
; AND DISCARD APPROPRIATE UNITS AND SET UP DBS FOR THE OTHERS

DISK%I:	SKIPN	N1,UNIPTR		;GET UNIT POINTER
	POPJ	P,			;IF NONE,NO NEED TO BOTHER
	MOVSI	T2,'DSK'		;MUST HAVE A DISK
	MOVEM	T2,ARGS+.DCNAM		;STORE AS FIRST ARGUMENT
	MOVE	T2,[ARGSLN,,ARGS]	;SET UP FOR DSKCHR
	DSKCHR	T2,			;DO IT
	  POPJ	P,			;IF NOT AVAILABLE,SKIP IT
	SKIPN	ARGS+.DCBUM		;CHECK NUMBER OF CYLINDERS
	POPJ	P,			;EXTENDED INFO NOT AVAILABLE
	MOVE	N2,UNIDB		;GET BASE OF DBS

DISK.1:	MOVE	T2,0(N2)		;GET THE STR NAME
	CAMN	T2,[-1]			;IS IT -1 (FIXED HEAD)?
	JRST	DISK.3			;YES,IGNORE THE DB SETUP
	SKIPE	SDISK			;WANT ONLY SYSTEM DISKS(SDISK=0)
	JRST	DISK.2			;NO,USE ALL
	MOVEM	T2,ARGS+2		;STORE AS GOBSTR ARG
	SETZM	ARGS+0
	SETZM	ARGS+1
	MOVE	T2,[3,,ARGS]		;SET IT UP
	GOBSTR	T2,			;SEE IF IN SYSTEM S.L.
	  TDZA	T1,T1			;FLAG WITH 0 DB SINCE NOT WANTED
DISK.2:	PUSHJ	P,DBCORE		;GET APPOPRIATE CORE
	HRRZM	T1,0(N2)		;STORE DB ADDRESS
DISK.3:	AOJ	N2,			;INCREMENT DB ADDRESS
	AOBJN	N1,DISK.1		;LOOP FOR ALL
	POPJ	P,			;THEN RETURN


DISK%G:	SKIPN	N1,UNIPTR		;GET ADDRESS OF POINTERS
	POPJ	P,			;RETURN IF NONE
	MOVE	N2,UNIDB		;GET DB ADDRESS TOO

DISG.1:	HRRZ	N3,0(N2)		;GET DB ADDRESS
	CAIE	N3,0			;IF 0 OR
	CAIN	N3,-1			;   -1 THEN WE DON'T DO THIS ONE
	JRST	DISG.2			;ITS EITHER FH OR NON SYS
	SKIPN	(N1)			;IF UNIT IS NULL, SKIPIT
	 JRST	DISG.2
	ADDI	N3,(L)			;UPDATE DB ADDRESS FOR CURRENT LOOK
	MOVE	T1,0(N1)		;GET NAME OF UNIT
	MOVEM	T1,ARGS			;STORE FOR DSKCHR
	MOVE	T1,[ARGSLN,,ARGS]	;SET FOR UUO
	DSKCHR	T1,			;DO IT
	  JRST	E$$DUF			;DSCHR UUO FAILED
	MOVE	T1,ARGS+.DCLPQ		;GET LENGTH OF POSITION WAIT Q
	MOVEM	T1,0(N3)		;STORE IT FOR THIS LOOK
DISG.2:	AOJ	N2,			;UPDATE DB POINTER
	AOBJN	N1,DISG.1		;REPEAT FOR ALL
	POPJ	P,			;THEN RETURN

$ERROR(EF.FAT!EF.EXT,DUF,DSKCHR UUO FAILED)


; HERE TO DISPLAY ALL SELECTED DISK UNITS

DISK%D:	SKIPN	N1,UNIPTR		;IF NO UNITS
	POPJ	P,			;RETURN
	MOVE	N2,UNIDB		;BASE OF DB LIST
UNIOL:	HRRZ	T2,0(N2)		;GET DB ADDRESS
	CAIE	T2,0			;IF ITS 0 OR
	CAIN	T2,-1			;   -1,THEN SKIP THIS ONE
	JRST	UNIFHD			;SKIP STUFF IF FIXED HEAD OR NON-SYS
	MOVEM	T2,TAB.P(J)		;STORE IT AS ADRESS THIS ITEM
	MOVE	T1,0(N1)		;GET UNITS NAME
	PUSH	P,N1			;SAVE N1 AND N2 ACROSS CALL
	PUSH	P,N2
	TYPES	(<LENGTH OF POSITION WAIT QUEUE FOR >)
	PUSHJ	P,SIXPNT		;AND PRINT IT
IFN FTTRC,<
	MOVEM	T1,BAUXWD		;STASH NAME FOR TRACE TOO.
>; END OF IFN FTTRC
	PUSHJ	P,CRLF
	PUSHJ	P,OUTDBF		;AND PRINT
	POP	P,N2
	POP	P,N1			;RESTORE THE ACS
UNIFHD:	AOJ	N2,			;UPDATE POINTER TO DBS
	AOBJN	N1,UNIOL		;LOOP FOR ALL IN LIST
	POPJ	P,			;ELSE RETURN


SUBTTL ANALYZE THE CHANNEL DATA
; ROUTINE TO INITIALIZE FOR WATCHING REQUESTS FOR EACH CHANNEL

CHAN%I:	MOVE	N1,UNIPTR		;GET POINTER TO STR NAMES
	MOVE	N2,UNIDB		;GET BASE OF DB LIST
	SETO	N3,			;INITIAL CHANNEL NUMBER

CHNI.1:	MOVE	T2,0(N1)		;GET UNIT NAME
	JUMPE	T2,CHNI.2		;SKIP IF NULL
	MOVEM	T2,ARGS+.DCNAM		;STORE AS DSKCHR ARG
	MOVE	T2,[ARGSLN,,ARGS]	;GET LENGTH,ADDRESS OF ARG BLOCK
	DSKCHR	T2,			;ASK MONITOR FOR INFO
	  JRST	E$$DUF			;IF UNAVAILABLE,COMPLAIN
	LDB	T2,[POINTR(T2,DC.DCN)]	;GET CHANNEL NUMBER
	CAMN	T2,N3			;SAME AS LAST ONE QUERIED?
	TDZA	T1,T1			;YES,DON'T SET UP A DB
	PUSHJ	P,DBCORE		;OTHERWISE ALLOCATE CORE
	HRLM	T1,0(N2)		;STORE IN LEFT HALF OF DB LIST
	MOVEM	T2,N3			;INSURE THAT CHANNEL NR. IS UPDATED
CHNI.2:	ADDI	N2,1			;UPDATE POINTER
	AOBJN	N1,CHNI.1		;LOOP FOR ALL UNITS IN LIST
	POPJ	P,			;THEN RETURN


; HERE TO FIND OUT THE LENGTH OF THE XFER WAIT QUEUE FOR EACH CHANNEL
; ON THE SYSTEM. 

CHAN%G:	MOVE	N1,UNIPTR		;GET UNIT NAME POINTER
	MOVE	N2,UNIDB		;GET BASE OF DB LIST
	
CHNG.1:	HLRZ	T1,0(N2)		;GET THIS DBS ADDRESS
	JUMPE	T1,CHNG.2		;IF NONE SET UP,SKIP THIS ENTRY
	HLLZ	T2,0(N1)		;GET LH OF UNIT NAME (IE KONTROLLER NAME)
	MOVEM	T2,ARGS+.DCNAM		;STORE INTO ARG BLOCK
	MOVE	T2,[ARGSLN,,ARGS]	;L,,A OF ARG BLOCK
	DSKCHR	T2,			;ASK MONITOR FOR DATA
	  JRST	E$$DUF			;SHOULDNT FAIL HERE
	MOVE	T2,ARGS+.DCLTQ		;GET LENGTH OF QUEUE
	ADDI	T1,0(L)			;UPDATE TO THIS LOOK
	MOVEM	T2,0(T1)		;AND STORE REPORT VALUE
CHNG.2:	ADDI	N2,1			;UPDATE DB LIST ADDRESS
	AOBJN	N1,CHNG.1		;AND LOOP FOR ALL UNITS
	POPJ	P,			;THEN RETURN

; ROUTINE TO PRINT NR OF REQUESTS PER CHANNEL

CHAN%D:	MOVE	N2,UNIPTR		;GET BASE POINTER OF LIST
	HRR	N2,UNIDB		;BUT MAKE IT POINT TO DB'S
	SETZ	N1,			;0 CHANNEL IS FIRST
CHND.1:	HLRZ	T1,0(N2)		;GET DB ENTRY
	JUMPE	T1,CHND.2		;SKIP IF NULL
	MOVEM	T1,TAB.P(J)		;STORE AS THE ADDRESS
	PUSH	P,N1			;STORE N1
	PUSH	P,N2			;AND N2 ACROSS DBOUT CALL
	TYPES	(<LENGTH OF TRANSFER WAIT QUEUE ON DATA CHANNEL >)
	MOVE	T1,N1			;GET CHANNEL NUMBER
	PUSHJ	P,OCTOUT		;PRINT IT
IFN FTTRC, <
	MOVEM	T1,BAUXWD		;STORE FOR TRACE
> ;END OF IFN FTTRC
	PUSHJ	P,CRLF			;PRINT A CR-LF PAIR
	PUSHJ	P,OUTDBF		;FLASH
	POP	P,N2			;RESTORE N2
	POP	P,N1			;RESTORE N1
	ADDI	N1,1			;UPDATE THE CHANNEL COUNTER
CHND.2:	AOBJN	N2,CHND.1		;REPEAT FOR ALL CHANNELS
	POPJ	P,			;THEN RETURN TO CALLER

SUBTTL ROUTINE TO DO FREE CORE ANALYSIS

PFCU%I:	MOVX	GT,%CNLOC		;GET FIRST EXEC ADDR USED FOR
	PUSHJ	P,FETTAB		;FREE CORE
	MOVE	T1,SYSSIZ		;TOTAL SYSTEM SIZE
	SUB	T1,GT			;GET SIZE OF FREE CORE
	LSH	T1,-2			;NR. OF 4 WORD CHUNKS
	MOVEM	T1,TNFCC		;TOTAL NR. OF FREE CORE CHUNKS
	PJRST	DBCORE			;GET DB AND RETURN

PFCU%G:	MOVX	GT,%CNFRU		;GET NR. CHUNKS USED
	PUSHJ	P,FETTAB		;
	MOVE	T1,GT
	IMULI	T1,^D100		;GET PERCENT OF TOTAL
	IDIV	T1,TNFCC
	MOVEM	T1,@TAB.P(J)		;STORE
	POPJ	P,			;AND RETURN


;ROUTINES TO DO TTY CHUNK USAGE ANALYSIS

PTCU%I:	MOVX	GT,%CNTTC		;NUMBER OF TTY CHUNKS
	PUSHJ	P,FETTAB
	HLRZM	GT,TNTCH		;STORE FOR LATER
					; (# CHUNKS IS IN LH)
	PJRST	DBCORE			;GET DB AND RETURN

PTCU%G:	MOVX	GT,%CNTTN		;GET NUMBER OF FREE CHUNKS
	PUSHJ	P,FETTAB
	MOVE	T1,GT			;GET INTO BETTER AC
	IMULI	T1,^D100		;TURN INTO % FREE
	IDIV	T1,TNTCH
	MOVEI	T2,^D100		;AND NOW INTO % USED
	SUB	T2,T1
	MOVEM	T2,@TAB.P(J)		;STORE
	POPJ	P,			;RETURN


; ROUTINE TO GET FROM MONITOR THE NUMBER OF XMT/RCV INTERUPTS FROM SCNSER

SRCV%G:	SKIPA	GT,[%SCNRI]		;SCANNER SERVICE RCV INTERUPTS
SXMT%G:	MOVX	GT,%SCNXI		;SCANNER SERVICE XMT INTERUPTS
	PJRST	INCSEC			;STORE AS PER SECOND

SUBTTL SCHEDULER PARAMETERS AVAILABLE  WITH 602 SCHEDULER
SWPN%I:	SKIPA	GT,[%SSNUL]		;SEE IF ITS THERE
SWPL%I:	MOVX	GT,%SSLOS		;DITTO
	PJRST	DBOPTN			;DO THE GETTAB, AND CALL DBCORE IF ITS THERE
SWPN%G:	MOVX	GT,%SSNUL		;GET SWAPPER NULL TIME, IN TICKS
	PJRST	CPCOMM			;IT WILL BE PRINTED AS TICKS
SWPL%G:	MOVX	GT,%SSLOS		;GET SWAPPER LOST TIME
	PJRST	CPCOMM			;GO JOIN COMMON % CODE
;REPORT NUMBER OF UNWINDS - TIMES A JOB WAS RUN OUT OF ORDER
SWPF%I:	SKIPA	GT,[%SSOSO]		;TEST FOR EXISTENCE OF NUMBER
UNWD%I:	MOVX	GT,%SSORJ		;DITTO
	PJRST	DBOPTN			;IF GETTAB EXISTS, CALL DBCORE
SWPF%G:	SKIPA	GT,[%SSOSO]
UNWD%G:	MOVX	GT,%SSORJ		;GET UNWIND COUNT
	PUSHJ	P,FETOPT		;GET THE COUNT
	  SETZ	GT,			;IGNORE ERROR
	PUSHJ	P,STONXT		;STORE AS NEXT
	SUBM	GT,@TAB.P(J)		;AND MAKE THIS INCREMENTAL
	POPJ	P,
;
;	THIS RUN TO METER EXEC TIME-CPU0
EXEC%I:	MOVE	T1,[XWD	2,PF0A1]	;TO GET METER
	skipn	mbord0			;user want on this cpu?
	 jrst	[setom	tab.p(j)
		 setzm	pf0a1b
		 POPJ	P,
		]
	PERF.	T1,			;TRY IT
	  JRST	[OUTSTR [ASCIZ/
NOT ABLE TO ALLOCATE PERFORMANCE METER-CPU0
/]
		SETOM	TAB.P(J)	;CLEAR IT
	SETZM	PF0A1B			;TELL MBXR NO GO
	POPJ	P,			;RETURN
]
	PJRST	DBCORE			;SET UP CORE
;
;
EXEC%G:	MOVE	T1,[XWD	1,PF0A3]	;READ METER
	PERF.	T1,			;DO IT
	  POPJ	P,			;NOPE GO AWAY
;
;
	PUSH	P,N1			;SAVE A FEW AC(S)
	PUSH	P,N2			;DITTO
	PUSH	P,N3			;DITTO
	PUSH	P,GT			;DITTO
;
;  COMPUTE % OF TIME SPEN IN EXEC MODE BASED ON TIME
;  BASE INCREMENT FROM PERF BOARD AND EXEC TIME BASE
;  INCREMENT FROM PERF BOARD.
;
;  NOTE THAT THE ELAPSED TIME ASSUMES A CLOCK RATE OF 1MHZ
;  AND THAT THE EXEC TIME BASE ASSUMES A CLOCK RATE OF 1/2 
;  THE SYSTEM CLOCK RATE.
;
;  FOR OUR SYSTEMS (KL1090-B) THE CLOCK RATE IS 30MHZ.
;  THE HALF CLOCK RATE IS 15MHZ.
;  SEE THE HARDWARE REF MANUAL ..PERFORMANCE AND ACCOUNTING
;
	DMOVE	T1,PF0A3B+2		;GET TIME WE FINISHED
	DSUB	T1,PF0A2B+2		;SUBTRACT ORIGINAL COUNT
	ASHC	T1 ,-^D12		;ELIMINATE RESERVED
	FLTR	T2,T2			;FLOAT...SINGLE PRESISION
	FDVR	T2,[EXP 1000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR TIME (SECONDS) SPENT IN EXEC MODE PC.
;
	DMOVE	N1,PF0A3B+4		;GET DURATION IN EXEC
	DSUB	N1,PF0A2B+4		;SUB FROM ORIG
	ASHC	N1,-^D12		;ELIMINATE RESERVED BITS
	FLTR	N2,N2			;FLOAT...SINGLE PRES.
	FDVR	N2,[EXP 15000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR THE PERCENTAGE CALULATION.
;
	FDVR	N2,T2			;EXEC/ELAPSED
	FMPR	N2,[EXP 100.]		;TO %
	FIXR	N2,N2			;TO INTEGER
	MOVEM	N2,@TAB.P(J)		;FOR TRACK
;
;  ALL DONE...
;
;DO STUFF FOR MBOX REFS 
	MOVE	T1,MB0ON		;MBOX ON???
	JUMPN	T1,N0MBX		;NOPE
	DMOVE	T3,PF0A3B+6		;GET NEW COUNT
	DSUB	T3,PF0A2B+6		;FROM ORIGINAL
	ASHC	T3,-^D12		;GET RID OF 00000'S
	FLTR	T4,T4			;MAKE ARITH EASY TO FOLLOW
	FDVR	T4,[EXP 1000.0]		;CONVERT TO K
	FDVR	T4,T2			;CONVERT TO K/SEC (PERF TIME BASE)
	FIXR	T4,T4			;SO TRACK WILL UNDERSTAND
	MOVEM	T4,MB0CT		;SAVE FOR MBXR%G
N0MBX:
	POP	P,GT			;RESTORE AC(S)
	POP	P,N3
	POP	P,N2
	POP	P,N1
;
	MOVE	T1,[XWD PF0A3B,PF0A2B]	;BLT SETUP
	BLT	T1,PF0A2B+10		;MAKE RECENT OLD
;
	POPJ	P,			;RETURN
;
;FUNCTION BLOCKS
;
	PF0A1:	1,,PF0A1B		;SET
	PF0A2:	2,,PF0A2B		;START
	PF0A3:	3,,PF0A3B		;READ
;
;SET FUNCTION ARG LIST
;
PF0A1B:	11				;LENGTH OF BLOCK
	EXP	1B3			;YES WE ARE A KL(!)
	EXP	1B18!1B19		;CPU0 ,CLEAR AND DURATION MODE
	0				;NO CACHE STUFF
	Z				;NO PI STUFF
	EXP	1B0			;EXEC MODE PC
	0				;NO MICROCODE ENA
	0				;NO PROBE ENABLES
	0				;NO JOB ENABLES
	0				;NO RH20 ENAABLE
;START
PF0A2B:	EXP	7			;DATA RETURNED IF OK
	BLOCK	7
;READ
PF0A3B:	EXP	7			;DATA RETURNED IF OK
	BLOCK	7
;
;HERE TO SET UP FOR MBOX REFERENCES COUNTS
MBXR%I:	MOVE	T1,PF0A1B		;IS EXEC ON???
	SKIPE	T1			;NOPE
	JRST	[SETZM	MB0ON
		PJRST	DBCORE
	]
	OUTSTR	[ASCIZ/
NEED PERF BOARD TO GET MBXR-CPU0
/]
	SETOM	TAB.P(J)		;TURN OFF MBXR
	POPJ	P,
;
MBXR%G:	MOVE	GT,MB0CT		;GET COUNT
	MOVEM	GT,@TAB.P(J)		;FOR TRACK
	POPJ	P,
MB0CT:	0
MB0ON:	-1

;
;	THIS RUN TO METER EXEC TIME-CPU1
EXE1%I:	MOVE	T1,NCPU			;[217] GET # CPUS
	skipe	mbord1		;user want board on cpu1?
	CAIGE	T1,2			;CPU1 EXIST??
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			setzm	pf1a1b
			POPJ	P,	;AND RETURN
		]			;END LITERAL..NO CPU1
	MOVE	T1,[XWD	2,PF1A1]	;TO GET METER
	PERF.	T1,			;TRY IT
	  JRST	[OUTSTR [ASCIZ/
NOT ABLE TO ALLOCATE PERFORMANCE METER-CPU1
/]
		SETOM	TAB.P(J)	;CLEAR IT
	SETZM	PF1A1B			;TELL MBXR NO GO
	POPJ	P,			;RETURN
]
	PJRST	DBCORE			;SET UP CORE
;
;
EXE1%G:	MOVE	T1,NCPU		;[217] # OF CPUS
	CAIGE	T1,2			;[217] DOES CPU1 EXIST?
	POPJ	P,			;NO..RETURN
	MOVE	T1,[XWD	1,PF1A3]	;READ METER
	PERF.	T1,			;DO IT
	  POPJ	P,			;NOPE GO AWAY
;
;
	PUSH	P,N1			;SAVE A FEW AC(S)
	PUSH	P,N2			;DITTO
	PUSH	P,N3			;DITTO
	PUSH	P,GT			;DITTO
;
;  COMPUTE % OF TIME SPEN IN EXEC MODE BASED ON TIME
;  BASE INCREMENT FROM PERF BOARD AND EXEC TIME BASE
;  INCREMENT FROM PERF BOARD.
;
;  NOTE THAT THE ELAPSED TIME ASSUMES A CLOCK RATE OF 1MHZ
;  AND THAT THE EXEC TIME BASE ASSUMES A CLOCK RATE OF 1/2 
;  THE SYSTEM CLOCK RATE.
;
;  FOR OUR SYSTEMS (KL1090-B) THE CLOCK RATE IS 30MHZ.
;  THE HALF CLOCK RATE IS 15MHZ.
;  SEE THE HARDWARE REF MANUAL ..PERFORMANCE AND ACCOUNTING
;
	DMOVE	T1,PF1A3B+2		;GET TIME WE FINISHED
	DSUB	T1,PF1A2B+2		;SUBTRACT ORIGINAL COUNT
	ASHC	T1 ,-^D12		;ELIMINATE RESERVED
	FLTR	T2,T2			;FLOAT...SINGLE PRESISION
	FDVR	T2,[EXP 1000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR TIME (SECONDS) SPENT IN EXEC MODE PC.
;
	DMOVE	N1,PF1A3B+4		;GET DURATION IN EXEC
	DSUB	N1,PF1A2B+4		;SUB FROM ORIG
	ASHC	N1,-^D12		;ELIMINATE RESERVED BITS
	FLTR	N2,N2			;FLOAT...SINGLE PRES.
	FDVR	N2,[EXP 15000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR THE PERCENTAGE CALULATION.
;
	FDVR	N2,T2			;EXEC/ELAPSED
	FMPR	N2,[EXP 100.]		;TO %
	FIXR	N2,N2			;TO INTEGER
	MOVEM	N2,@TAB.P(J)		;FOR TRACK
;
;  ALL DONE...
;
;DO STUFF FOR MBOX REFS 
	MOVE	T1,MB1ON		;MBOX ON???
	JUMPN	T1,N1MBX		;NOPE
	DMOVE	T3,PF1A3B+6		;GET NEW COUNT
	DSUB	T3,PF1A2B+6		;FROM ORIGINAL
	ASHC	T3,-^D12		;GET RID OF 00000'S
	FLTR	T4,T4			;MAKE ARITH EASY TO FOLLOW
	FDVR	T4,[EXP 1000.0]		;CONVERT TO K
	FDVR	T4,T2			;CONVERT TO K/SEC(PERF TIME BASE)
	FIXR	T4,T4			;SO TRACK WILL UNDERSTAND
	MOVEM	T4,MB1CT		;SAVE FOR MBXR%G
N1MBX:
	POP	P,GT			;RESTORE AC(S)
	POP	P,N3
	POP	P,N2
	POP	P,N1
;
	MOVE	T1,[XWD PF1A3B,PF1A2B]	;BLT SETUP
	BLT	T1,PF1A2B+10		;MAKE RECENT OLD
;
	POPJ	P,			;RETURN
;
;FUNCTION BLOCKS
;
	PF1A1:	1,,PF1A1B		;SET
	PF1A2:	2,,PF1A2B		;START
	PF1A3:	3,,PF1A3B		;READ
;
;SET FUNCTION ARG LIST
;
PF1A1B:	11				;LENGTH OF BLOCK
	EXP	1B3			;YES WE ARE A KL(!)
	EXP	1B17!1B18!1B19		;CPU1 ,CLEAR AND DURATION MODE
	0				;NO CACHE STUFF
	Z				;NO PI STUFF
	EXP	1B0			;EXEC MODE PC
	0				;NO MICROCODE ENA
	0				;NO PROBE ENABLES
	0				;NO JOB ENABLES
	0				;NO RH20 ENAABLE
;START
PF1A2B:	EXP	7			;DATA RETURNED IF OK
	OCT	1			;CPU1
	BLOCK	7
;READ
PF1A3B:	EXP	7			;DATA RETURNED IF OK
	OCT	1			;CPU1
	BLOCK	7
;
;HERE TO SET UP FOR MBOX REFERENCES COUNTS
MBX1%I:	MOVE	T1,NCPU		;[217] # OF CPUS
	CAIGE	T1,2			;217] CPU1 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			POPJ	P,	;AND RETURN
		]
	MOVE	T1,PF1A1B		;IS EXEC ON???
	SKIPE	T1			;NOPE
	JRST	[SETZM	MB1ON
		PJRST	DBCORE
	]
	OUTSTR	[ASCIZ/
NEED PERF BOARD TO GET MBXR-CPU1
/]
	SETOM	TAB.P(J)		;TURN OFF MBXR
	POPJ	P,
;
MBX1%G:	MOVE	GT,MB1CT		;GET COUNT
	MOVEM	GT,@TAB.P(J)		;FOR TRACK
	POPJ	P,
MB1CT:	0
MB1ON:	-1



;[217] BEGINNING OF PERFORMANCE METER CODE FOR CPU2

;
;	THIS RUN TO METER EXEC TIME-CPU2
EXE2%I:	MOVE	T1,NCPU			;GET # CPUS
	skipe	mbord2			;user want board on cpu2?
	CAIGE	T1,3			;CPU2 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			setzm	pf2a1b
			POPJ	P,	;AND RETURN
		]			;END LITERAL..NO CPU1
	MOVE	T1,[XWD	2,PF2A1]	;TO GET METER
	PERF.	T1,			;TRY IT
	  JRST	[OUTSTR [ASCIZ/
NOT ABLE TO ALLOCATE PERFORMANCE METER-CPU2
/]
		SETOM	TAB.P(J)	;CLEAR IT
	SETZM	PF2A1B			;TELL MBXR NO GO
	POPJ	P,			;RETURN
]
	PJRST	DBCORE			;SET UP CORE
;
;
EXE2%G:	MOVE	T1,NCPU			;[217] GET # CPUS
	CAIGE	T1,1+2			;[217] CPU2 EXIST?
	POPJ	P,			;NO..RETURN
	MOVE	T1,[XWD	1,PF2A3]	;READ METER
	PERF.	T1,			;DO IT
	  POPJ	P,			;NOPE GO AWAY
;
;
	PUSH	P,N1			;SAVE A FEW AC(S)
	PUSH	P,N2			;DITTO
	PUSH	P,N3			;DITTO
	PUSH	P,GT			;DITTO
;
;  COMPUTE % OF TIME SPENT IN EXEC MODE BASED ON TIME
;  BASE INCREMENT FROM PERF BOARD AND EXEC TIME BASE
;  INCREMENT FROM PERF BOARD.
;
;  NOTE THAT THE ELAPSED TIME ASSUMES A CLOCK RATE OF 1MHZ
;  AND THAT THE EXEC TIME BASE ASSUMES A CLOCK RATE OF 1/2 
;  THE SYSTEM CLOCK RATE.
;
;  FOR OUR SYSTEMS (KL1090-B) THE CLOCK RATE IS 30MHZ.
;  THE HALF CLOCK RATE IS 15MHZ.
;  SEE THE HARDWARE REF MANUAL ..PERFORMANCE AND ACCOUNTING
;
	DMOVE	T1,PF2A3B+2		;GET TIME WE FINISHED
	DSUB	T1,PF2A2B+2		;SUBTRACT ORIGINAL COUNT
	ASHC	T1 ,-^D12		;ELIMINATE RESERVED
	FLTR	T2,T2			;FLOAT...SINGLE PRESISION
	FDVR	T2,[EXP 1000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR TIME (SECONDS) SPENT IN EXEC MODE PC.
;
	DMOVE	N1,PF2A3B+4		;GET DURATION IN EXEC
	DSUB	N1,PF2A2B+4		;SUB FROM ORIG
	ASHC	N1,-^D12		;ELIMINATE RESERVED BITS
	FLTR	N2,N2			;FLOAT...SINGLE PRES.
	FDVR	N2,[EXP 15000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR THE PERCENTAGE CALULATION.
;
	FDVR	N2,T2			;EXEC/ELAPSED
	FMPR	N2,[EXP 100.]		;TO %
	FIXR	N2,N2			;TO INTEGER
	MOVEM	N2,@TAB.P(J)		;FOR TRACK
;
;  ALL DONE...
;
;DO STUFF FOR MBOX REFS 
	MOVE	T1,MB2ON		;MBOX ON???
	JUMPN	T1,N2MBX		;NOPE
	DMOVE	T3,PF2A3B+6		;GET NEW COUNT
	DSUB	T3,PF2A2B+6		;FROM ORIGINAL
	ASHC	T3,-^D12		;GET RID OF 00000'S
	FLTR	T4,T4			;MAKE ARITH EASY TO FOLLOW
	FDVR	T4,[EXP 1000.0]		;CONVERT TO K
	FDVR	T4,T2			;CONVERT TO K/SEC(PERF TIME BASE)
	FIXR	T4,T4			;SO TRACK WILL UNDERSTAND
	MOVEM	T4,MB2CT		;SAVE FOR MBXR%G
N2MBX:
	POP	P,GT			;RESTORE AC(S)
	POP	P,N3
	POP	P,N2
	POP	P,N1
;
	MOVE	T1,[XWD PF2A3B,PF2A2B]	;BLT SETUP
	BLT	T1,PF2A2B+10		;MAKE RECENT OLD
;
	POPJ	P,			;RETURN
;
;FUNCTION BLOCKS
;
	PF2A1:	1,,PF2A1B		;SET
	PF2A2:	2,,PF2A2B		;START
	PF2A3:	3,,PF2A3B		;READ
;
;SET FUNCTION ARG LIST
;
PF2A1B:	11				;LENGTH OF BLOCK
	EXP	1B3			;YES WE ARE A KL(!)
	EXP	2B17!1B18!1B19		;CPU2 ,CLEAR AND DURATION MODE
	0				;NO CACHE STUFF
	Z				;NO PI STUFF
	EXP	1B0			;EXEC MODE PC
	0				;NO MICROCODE ENA
	0				;NO PROBE ENABLES
	0				;NO JOB ENABLES
	0				;NO RH20 ENAABLE
;START
PF2A2B:	EXP	7			;DATA RETURNED IF OK
	OCT	2			;CPU2
	BLOCK	7
;READ
PF2A3B:	EXP	7			;DATA RETURNED IF OK
	OCT	2			;CPU2
	BLOCK	7
;
;HERE TO SET UP FOR MBOX REFERENCES COUNTS
MBX2%I:	MOVE	T1,NCPU			;[217] GET # CPUS
	CAIGE	T1,1+2			;[217] DOES CPU2 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			POPJ	P,	;AND RETURN
		]
	MOVE	T1,PF2A1B		;IS EXEC ON???
	SKIPE	T1			;NOPE
	JRST	[SETZM	MB2ON
		PJRST	DBCORE
	]
	OUTSTR	[ASCIZ/
NEED PERF BOARD TO GET MBXR-CPU2
/]
	SETOM	TAB.P(J)		;TURN OFF MBXR
	POPJ	P,
;
MBX2%G:	MOVE	GT,MB2CT		;GET COUNT
	MOVEM	GT,@TAB.P(J)		;FOR TRACK
	POPJ	P,
MB2CT:	0
MB2ON:	-1
;[217]  END OF PERF METER SUPPORT FOR CPU2




;[217] BEGINNING OF PERFORMANCE METER CODE FOR CPU3

;
;	THIS RUN TO METER EXEC TIME-CPU3
EXE3%I:	MOVE	T1,NCPU			;GET # CPUS
	skipe	mbord3			;user want board on cpu3?
	CAIGE	T1,4			;CPU3 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
	setzm	pf3a1b
			POPJ	P,	;AND RETURN
		]			;END LITERAL..NO CPU1
	MOVE	T1,[XWD	2,PF3A1]	;TO GET METER
	PERF.	T1,			;TRY IT
	  JRST	[OUTSTR [ASCIZ/
NOT ABLE TO ALLOCATE PERFORMANCE METER-CPU3
/]
		SETOM	TAB.P(J)	;CLEAR IT
	SETZM	PF3A1B			;TELL MBXR NO GO
	POPJ	P,			;RETURN
]
	PJRST	DBCORE			;SET UP CORE
;
;
EXE3%G:	MOVE	T1,NCPU			;[217] GET # CPUS
	CAIGE	T1,1+3			;[217] CPU3 EXIST?
	POPJ	P,			;NO..RETURN
	MOVE	T1,[XWD	1,PF3A3]	;READ METER
	PERF.	T1,			;DO IT
	  POPJ	P,			;NOPE GO AWAY
;
;
	PUSH	P,N1			;SAVE A FEW AC(S)
	PUSH	P,N2			;DITTO
	PUSH	P,N3			;DITTO
	PUSH	P,GT			;DITTO
;
;  COMPUTE % OF TIME SPENT IN EXEC MODE BASED ON TIME
;  BASE INCREMENT FROM PERF BOARD AND EXEC TIME BASE
;  INCREMENT FROM PERF BOARD.
;
;  NOTE THAT THE ELAPSED TIME ASSUMES A CLOCK RATE OF 1MHZ
;  AND THAT THE EXEC TIME BASE ASSUMES A CLOCK RATE OF 1/2 
;  THE SYSTEM CLOCK RATE.
;
;  FOR OUR SYSTEMS (KL1090-B) THE CLOCK RATE IS 30MHZ.
;  THE HALF CLOCK RATE IS 15MHZ.
;  SEE THE HARDWARE REF MANUAL ..PERFORMANCE AND ACCOUNTING
;
	DMOVE	T1,PF3A3B+2		;GET TIME WE FINISHED
	DSUB	T1,PF3A2B+2		;SUBTRACT ORIGINAL COUNT
	ASHC	T1 ,-^D12		;ELIMINATE RESERVED
	FLTR	T2,T2			;FLOAT...SINGLE PRESISION
	FDVR	T2,[EXP 1000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR TIME (SECONDS) SPENT IN EXEC MODE PC.
;
	DMOVE	N1,PF3A3B+4		;GET DURATION IN EXEC
	DSUB	N1,PF3A2B+4		;SUB FROM ORIG
	ASHC	N1,-^D12		;ELIMINATE RESERVED BITS
	FLTR	N2,N2			;FLOAT...SINGLE PRES.
	FDVR	N2,[EXP 15000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR THE PERCENTAGE CALULATION.
;
	FDVR	N2,T2			;EXEC/ELAPSED
	FMPR	N2,[EXP 100.]		;TO %
	FIXR	N2,N2			;TO INTEGER
	MOVEM	N2,@TAB.P(J)		;FOR TRACK
;
;  ALL DONE...
;
;DO STUFF FOR MBOX REFS 
	MOVE	T1,MB3ON		;MBOX ON???
	JUMPN	T1,N3MBX		;NOPE
	DMOVE	T3,PF3A3B+6		;GET NEW COUNT
	DSUB	T3,PF3A2B+6		;FROM ORIGINAL
	ASHC	T3,-^D12		;GET RID OF 00000'S
	FLTR	T4,T4			;MAKE ARITH EASY TO FOLLOW
	FDVR	T4,[EXP 1000.0]		;CONVERT TO K
	FDVR	T4,T2			;CONVERT TO K/SEC(PERF TIME BASE)
	FIXR	T4,T4			;SO TRACK WILL UNDERSTAND
	MOVEM	T4,MB3CT		;SAVE FOR MBXR%G
N3MBX:
	POP	P,GT			;RESTORE AC(S)
	POP	P,N3
	POP	P,N2
	POP	P,N1
;
	MOVE	T1,[XWD PF3A3B,PF3A2B]	;BLT SETUP
	BLT	T1,PF3A2B+10		;MAKE RECENT OLD
;
	POPJ	P,			;RETURN
;
;FUNCTION BLOCKS
;
	PF3A1:	1,,PF3A1B		;SET
	PF3A2:	2,,PF3A2B		;START
	PF3A3:	3,,PF3A3B		;READ
;
;SET FUNCTION ARG LIST
;
PF3A1B:	11				;LENGTH OF BLOCK
	EXP	1B3			;YES WE ARE A KL(!)
	EXP	3B17!1B18!1B19		;CPU3 ,CLEAR AND DURATION MODE
	0				;NO CACHE STUFF
	Z				;NO PI STUFF
	EXP	1B0			;EXEC MODE PC
	0				;NO MICROCODE ENA
	0				;NO PROBE ENABLES
	0				;NO JOB ENABLES
	0				;NO RH20 ENAABLE
;START
PF3A2B:	EXP	7			;DATA RETURNED IF OK
	OCT	3			;CPU3
	BLOCK	7
;READ
PF3A3B:	EXP	7			;DATA RETURNED IF OK
	OCT	3			;CPU3
	BLOCK	7
;
;HERE TO SET UP FOR MBOX REFERENCES COUNTS
MBX3%I:	MOVE	T1,NCPU			;[217] GET # CPUS
	CAIGE	T1,1+3			;[217] DOES CPU3 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			POPJ	P,	;AND RETURN
		]
	MOVE	T1,PF3A1B		;IS EXEC ON???
	SKIPE	T1			;NOPE
	JRST	[SETZM	MB3ON
		PJRST	DBCORE
	]
	OUTSTR	[ASCIZ/
NEED PERF BOARD TO GET MBXR-CPU3
/]
	SETOM	TAB.P(J)		;TURN OFF MBXR
	POPJ	P,
;
MBX3%G:	MOVE	GT,MB3CT		;GET COUNT
	MOVEM	GT,@TAB.P(J)		;FOR TRACK
	POPJ	P,
MB3CT:	0
MB3ON:	-1
;[217]  END OF PERF METER SUPPORT FOR CPU3




;[217] BEGINNING OF PERFORMANCE METER CODE FOR CPU4

;
;	THIS RUN TO METER EXEC TIME-CPU4
EXE4%I:	MOVE	T1,NCPU			;GET # CPUS
	skipe	mbord4			;user want board on cpu4?
	CAIGE	T1,5			;CPU4 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			setzm	pf4a1b
			POPJ	P,	;AND RETURN
		]			;END LITERAL..NO CPU1
	MOVE	T1,[XWD	2,PF4A1]	;TO GET METER
	PERF.	T1,			;TRY IT
	  JRST	[OUTSTR [ASCIZ/
NOT ABLE TO ALLOCATE PERFORMANCE METER-CPU4
/]
		SETOM	TAB.P(J)	;CLEAR IT
	SETZM	PF4A1B			;TELL MBXR NO GO
	POPJ	P,			;RETURN
]
	PJRST	DBCORE			;SET UP CORE
;
;
EXE4%G:	MOVE	T1,NCPU			;[217] GET # CPUS
	CAIGE	T1,1+4			;[217] CPU4 EXIST?
	POPJ	P,			;NO..RETURN
	MOVE	T1,[XWD	1,PF4A3]	;READ METER
	PERF.	T1,			;DO IT
	  POPJ	P,			;NOPE GO AWAY
;
;
	PUSH	P,N1			;SAVE A FEW AC(S)
	PUSH	P,N2			;DITTO
	PUSH	P,N3			;DITTO
	PUSH	P,GT			;DITTO
;
;  COMPUTE % OF TIME SPENT IN EXEC MODE BASED ON TIME
;  BASE INCREMENT FROM PERF BOARD AND EXEC TIME BASE
;  INCREMENT FROM PERF BOARD.
;
;  NOTE THAT THE ELAPSED TIME ASSUMES A CLOCK RATE OF 1MHZ
;  AND THAT THE EXEC TIME BASE ASSUMES A CLOCK RATE OF 1/2 
;  THE SYSTEM CLOCK RATE.
;
;  FOR OUR SYSTEMS (KL1090-B) THE CLOCK RATE IS 30MHZ.
;  THE HALF CLOCK RATE IS 15MHZ.
;  SEE THE HARDWARE REF MANUAL ..PERFORMANCE AND ACCOUNTING
;
	DMOVE	T1,PF4A3B+2		;GET TIME WE FINISHED
	DSUB	T1,PF4A2B+2		;SUBTRACT ORIGINAL COUNT
	ASHC	T1 ,-^D12		;ELIMINATE RESERVED
	FLTR	T2,T2			;FLOAT...SINGLE PRESISION
	FDVR	T2,[EXP 1000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR TIME (SECONDS) SPENT IN EXEC MODE PC.
;
	DMOVE	N1,PF4A3B+4		;GET DURATION IN EXEC
	DSUB	N1,PF4A2B+4		;SUB FROM ORIG
	ASHC	N1,-^D12		;ELIMINATE RESERVED BITS
	FLTR	N2,N2			;FLOAT...SINGLE PRES.
	FDVR	N2,[EXP 15000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR THE PERCENTAGE CALULATION.
;
	FDVR	N2,T2			;EXEC/ELAPSED
	FMPR	N2,[EXP 100.]		;TO %
	FIXR	N2,N2			;TO INTEGER
	MOVEM	N2,@TAB.P(J)		;FOR TRACK
;
;  ALL DONE...
;
;DO STUFF FOR MBOX REFS 
	MOVE	T1,MB4ON		;MBOX ON???
	JUMPN	T1,N4MBX		;NOPE
	DMOVE	T3,PF4A3B+6		;GET NEW COUNT
	DSUB	T3,PF4A2B+6		;FROM ORIGINAL
	ASHC	T3,-^D12		;GET RID OF 00000'S
	FLTR	T4,T4			;MAKE ARITH EASY TO FOLLOW
	FDVR	T4,[EXP 1000.0]		;CONVERT TO K
	FDVR	T4,T2			;CONVERT TO K/SEC(PERF TIME BASE)
	FIXR	T4,T4			;SO TRACK WILL UNDERSTAND
	MOVEM	T4,MB4CT		;SAVE FOR MBXR%G
N4MBX:
	POP	P,GT			;RESTORE AC(S)
	POP	P,N3
	POP	P,N2
	POP	P,N1
;
	MOVE	T1,[XWD PF4A3B,PF4A2B]	;BLT SETUP
	BLT	T1,PF4A2B+10		;MAKE RECENT OLD
;
	POPJ	P,			;RETURN
;
;FUNCTION BLOCKS
;
	PF4A1:	1,,PF4A1B		;SET
	PF4A2:	2,,PF4A2B		;START
	PF4A3:	3,,PF4A3B		;READ
;
;SET FUNCTION ARG LIST
;
PF4A1B:	11				;LENGTH OF BLOCK
	EXP	1B3			;YES WE ARE A KL(!)
	EXP	4B17!1B18!1B19		;CPU4 ,CLEAR AND DURATION MODE
	0				;NO CACHE STUFF
	Z				;NO PI STUFF
	EXP	1B0			;EXEC MODE PC
	0				;NO MICROCODE ENA
	0				;NO PROBE ENABLES
	0				;NO JOB ENABLES
	0				;NO RH20 ENAABLE
;START
PF4A2B:	EXP	7			;DATA RETURNED IF OK
	OCT	4			;CPU4
	BLOCK	7
;READ
PF4A3B:	EXP	7			;DATA RETURNED IF OK
	OCT	4			;CPU4
	BLOCK	7
;
;HERE TO SET UP FOR MBOX REFERENCES COUNTS
MBX4%I:	MOVE	T1,NCPU			;[217] GET # CPUS
	CAIGE	T1,1+4			;[217] DOES CPU4 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			POPJ	P,	;AND RETURN
		]
	MOVE	T1,PF4A1B		;IS EXEC ON???
	SKIPE	T1			;NOPE
	JRST	[SETZM	MB4ON
		PJRST	DBCORE
	]
	OUTSTR	[ASCIZ/
NEED PERF BOARD TO GET MBXR-CPU4
/]
	SETOM	TAB.P(J)		;TURN OFF MBXR
	POPJ	P,
;
MBX4%G:	MOVE	GT,MB4CT		;GET COUNT
	MOVEM	GT,@TAB.P(J)		;FOR TRACK
	POPJ	P,
MB4CT:	0
MB4ON:	-1
;[217]  END OF PERF METER SUPPORT FOR CPU4




;[217] BEGINNING OF PERFORMANCE METER CODE FOR CPU5

;
;	THIS RUN TO METER EXEC TIME-CPU5
EXE5%I:	MOVE	T1,NCPU			;GET # CPUS
	skipe	mbord5			;user want board on cpu5?
	CAIGE	T1,6			;CPU5 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			setzm	pf5a1b
			POPJ	P,	;AND RETURN
		]			;END LITERAL..NO CPU1
	MOVE	T1,[XWD	2,PF5A1]	;TO GET METER
	PERF.	T1,			;TRY IT
	  JRST	[OUTSTR [ASCIZ/
NOT ABLE TO ALLOCATE PERFORMANCE METER-CPU5
/]
		SETOM	TAB.P(J)	;CLEAR IT
	SETZM	PF5A1B			;TELL MBXR NO GO
	POPJ	P,			;RETURN
]
	PJRST	DBCORE			;SET UP CORE
;
;
EXE5%G:	MOVE	T1,NCPU			; GET # CPUS
	CAIGE	T1,1+5			; CPU5 EXIST?
	POPJ	P,			;NO..RETURN
	MOVE	T1,[XWD	1,PF5A3]	;READ METER
	PERF.	T1,			;DO IT
	  POPJ	P,			;NOPE GO AWAY
;
;
	PUSH	P,N1			;SAVE A FEW AC(S)
	PUSH	P,N2			;DITTO
	PUSH	P,N3			;DITTO
	PUSH	P,GT			;DITTO
;
;  COMPUTE % OF TIME SPENT IN EXEC MODE BASED ON TIME
;  BASE INCREMENT FROM PERF BOARD AND EXEC TIME BASE
;  INCREMENT FROM PERF BOARD.
;
;  NOTE THAT THE ELAPSED TIME ASSUMES A CLOCK RATE OF 1MHZ
;  AND THAT THE EXEC TIME BASE ASSUMES A CLOCK RATE OF 1/2 
;  THE SYSTEM CLOCK RATE.
;
;  FOR OUR SYSTEMS (KL1090-B) THE CLOCK RATE IS 30MHZ.
;  THE HALF CLOCK RATE IS 15MHZ.
;  SEE THE HARDWARE REF MANUAL ..PERFORMANCE AND ACCOUNTING
;
	DMOVE	T1,PF5A3B+2		;GET TIME WE FINISHED
	DSUB	T1,PF5A2B+2		;SUBTRACT ORIGINAL COUNT
	ASHC	T1 ,-^D12		;ELIMINATE RESERVED
	FLTR	T2,T2			;FLOAT...SINGLE PRESISION
	FDVR	T2,[EXP 1000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR TIME (SECONDS) SPENT IN EXEC MODE PC.
;
	DMOVE	N1,PF5A3B+4		;GET DURATION IN EXEC
	DSUB	N1,PF5A2B+4		;SUB FROM ORIG
	ASHC	N1,-^D12		;ELIMINATE RESERVED BITS
	FLTR	N2,N2			;FLOAT...SINGLE PRES.
	FDVR	N2,[EXP 15000000.]	;CONVERT TO SECONDS.
;
;  NOW FOR THE PERCENTAGE CALULATION.
;
	FDVR	N2,T2			;EXEC/ELAPSED
	FMPR	N2,[EXP 100.]		;TO %
	FIXR	N2,N2			;TO INTEGER
	MOVEM	N2,@TAB.P(J)		;FOR TRACK
;
;  ALL DONE...
;
;DO STUFF FOR MBOX REFS 
	MOVE	T1,MB5ON		;MBOX ON???
	JUMPN	T1,N5MBX		;NOPE
	DMOVE	T3,PF5A3B+6		;GET NEW COUNT
	DSUB	T3,PF5A2B+6		;FROM ORIGINAL
	ASHC	T3,-^D12		;GET RID OF 00000'S
	FLTR	T4,T4			;MAKE ARITH EASY TO FOLLOW
	FDVR	T4,[EXP 1000.0]		;CONVERT TO K
	FDVR	T4,T2			;CONVERT TO K/SEC(PERF TIME BASE)
	FIXR	T4,T4			;SO TRACK WILL UNDERSTAND
	MOVEM	T4,MB5CT		;SAVE FOR MBXR%G
N5MBX:
	POP	P,GT			;RESTORE AC(S)
	POP	P,N3
	POP	P,N2
	POP	P,N1
;
	MOVE	T1,[XWD PF5A3B,PF5A2B]	;BLT SETUP
	BLT	T1,PF5A2B+10		;MAKE RECENT OLD
;
	POPJ	P,			;RETURN
;
;FUNCTION BLOCKS
;
	PF5A1:	1,,PF5A1B		;SET
	PF5A2:	2,,PF5A2B		;START
	PF5A3:	3,,PF5A3B		;READ
;
;SET FUNCTION ARG LIST
;
PF5A1B:	11				;LENGTH OF BLOCK
	EXP	1B3			;YES WE ARE A KL(!)
	EXP	5B17!1B18!1B19		;CPU5 ,CLEAR AND DURATION MODE
	0				;NO CACHE STUFF
	Z				;NO PI STUFF
	EXP	1B0			;EXEC MODE PC
	0				;NO MICROCODE ENA
	0				;NO PROBE ENABLES
	0				;NO JOB ENABLES
	0				;NO RH20 ENAABLE
;START
PF5A2B:	EXP	7			;DATA RETURNED IF OK
	OCT	5			;CPU5
	BLOCK	7
;READ
PF5A3B:	EXP	7			;DATA RETURNED IF OK
	OCT	5			;CPU5
	BLOCK	7
;
;HERE TO SET UP FOR MBOX REFERENCES COUNTS
MBX5%I:	MOVE	T1,NCPU			;GET # CPUS
	CAIGE	T1,1+5			;DOES CPU5 EXIST?
	JRST	[	SETOM	TAB.P(J);CLEAR TABLE
			POPJ	P,	;AND RETURN
		]
	MOVE	T1,PF5A1B		;IS EXEC ON???
	SKIPE	T1			;NOPE
	JRST	[SETZM	MB5ON
		PJRST	DBCORE
	]
	OUTSTR	[ASCIZ/
NEED PERF BOARD TO GET MBXR-CPU5
/]
	SETOM	TAB.P(J)		;TURN OFF MBXR
	POPJ	P,
;
MBX5%G:	MOVE	GT,MB5CT		;GET COUNT
	MOVEM	GT,@TAB.P(J)		;FOR TRACK
	POPJ	P,
MB5CT:	0
MB5ON:	-1
;  END OF PERF METER SUPPORT FOR CPU5

;SCDPER DATA
;SEE SCHED1.MAC SCDPER:
;FOR USE IN 603+SCHED LIR OR 603.A + MONITORS
;
SDGS%I:	MOVE	GT,[%SPDGS]		;DTA GEN SLEEPS
	PJRST	DBOPTN
SDGS%G:	MOVE	GT,[%SPDGS]
	PJRST	SIMINC
;
SMGS%I:	MOVE	GT,[%SPMGS]		;MTA GEN SLEEPS
	PJRST	DBOPTN
SMGS%G:	MOVE	GT,[%SPMGS]
	PJRST	SIMINC
;
SEWS%I:	MOVE	GT,[%SPEWS]		;EVENT WAIT SATIS.
	PJRST	DBOPTN
SEWS%G:	MOVE	GT,[%SPEWS]
	PJRST	SIMINC
;
STIS%I:	MOVE	GT,[%SPTIS]		;TTY INP WAIT SATIS.
	PJRST	DBOPTN
STIS%G:	MOVE	GT,[%SPTIS]
	PJRST	SIMINC
;
STOS%I:	MOVE	GT,[%SPTOS]		;TTY OUTPUT SATIS.
	PJRST	DBOPTN
STOS%G:	MOVE	GT,[%SPTOS]
	PJRST	SIMINC
;
SPIS%I:	MOVE	GT,[%SPPIS]		;PTY INPUT SATIS.
	PJRST	DBOPTN
SPIS%G:	MOVE	GT,[%SPPIS]
	PJRST	SIMINC
;
SPOS%I:	MOVE	GT,[%SPPOS]		;PTY OUTPUT SATIS.
	PJRST	DBOPTN
SPOS%G:	MOVE	GT,[%SPPOS]
	PJRST	SIMINC
;
SRS1%I:	MOVE	GT,[%SPRS1]		;SS TO PQ1 REQ
	PJRST	DBOPTN
SRS1%G:	MOVE	GT,[%SPRS1]
	PJRST	SIMINC
;
SRW1%I:	MOVE	GT,[%SPRW1]		;WAKE TO PQ1 REQ
	PJRST	DBOPTN
SRW1%G:	MOVE	GT,[%SPRW1]
	PJRST	SIMINC
;
SRD1%I:	MOVE	GT,[%SPRD1]		;JD WAIT SATIS TO PQ1 REQ
	PJRST	DBOPTN
SRD1%G:	MOVE	GT,[%SPRD1]
	PJRST	SIMINC
;
SRO1%I:	MOVE	GT,[%SPRO1]		;OTHER TO PQ1 REQ
	PJRST	DBOPTN
SRO1%G:	MOVE	GT,[%SPRO1]
	PJRST	SIMINC
;
SQR1%I:	MOVE	GT,[%SPQR1]		;PQ1 QUANTUM EXPIRE
	PJRST	DBOPTN
SQR1%G:	MOVE	GT,[%SPQR1]
	PJRST	SIMINC
;
SQR2%I:	MOVE	GT,[%SPQR2]		;PQ2 QUANTUM EXPIRE
	PJRST	DBOPTN
SQR2%G:	MOVE	GT,[%SPQR2]
	PJRST	SIMINC
;
SQRH%I:	MOVE	GT,[%SPQRH]		;HPQ QUANTUM EXPIRE
	PJRST	DBOPTN
SQRH%G:	MOVE	GT,[%SPQRH]
	PJRST	SIMINC
;
SIP1%I:	MOVE	GT,[%SPIP1]		;PQ1 ICPT EXPIRE
	PJRST	DBOPTN
SIP1%G:	MOVE	GT,[%SPIP1]
	PJRST	SIMINC
;
SIP2%I:	MOVE	GT,[%SPIP2]		;PQ2 ICPT EXPIRE
	PJRST	DBOPTN
SIP2%G:	MOVE	GT,[%SPIP2]
	PJRST	SIMINC
;
SIPH%I:	MOVE	GT,[%SPIPH]		;HPQ ICPT EXPIRE
	PJRST	DBOPTN
SIPH%G:	MOVE	GT,[%SPIPH]
	PJRST	SIMINC
;
SKS1%I:	MOVE	GT,[%SPKS1]		;SWAP IN K PQ1
	PJRST	DBOPTN
SKS1%G:	MOVE	GT,[%SPKS1]
	PJRST	SIMINC
;
SKS2%I:	MOVE	GT,[%SPKS2]		;SWAP IN K PQ2
	PJRST	DBOPTN
SKS2%G:	MOVE	GT,[%SPKS2]
	PJRST	SIMINC
;
SKSH%I:	MOVE	GT,[%SPKSH]		;SWAP IN K HPQ
	PJRST	DBOPTN
SKSH%G:	MOVE	GT,[%SPKSH]
	PJRST	SIMINC
;
SNJ1%I:	MOVE	GT,[%SPNJ1]		;PQ1 JOBS SWAPPED IN
	PJRST	DBOPTN
SNJ1%G:	MOVE	GT,[%SPNJ1]
	PJRST	SIMINC
;
SNJ2%I:	MOVE	GT,[%SPNJ2]		;PQ2 JOBS SWAPPED IN
	PJRST	DBOPTN
SNJ2%G:	MOVE	GT,[%SPNJ2]
	PJRST	SIMINC
;
SNJH%I:	MOVE	GT,[%SPNJH]		;HPQ JOBS SWAPPED IN
	PJRST	DBOPTN
SNJH%G:	MOVE	GT,[%SPNJH]
	PJRST	SIMINC
;
;  EBOX/MBOX SINCE HI PRES ACCOUTING USED ...SEE CLOCK1.MAC
STC1%I:	MOVE	GT,[%SPTC1]		;PQ1 EBOX/MBOX TICKS
	PJRST	DBOPTN
STC1%G:	MOVE	GT,[%SPTC1]
	PJRST	SIMINC
STC2%I:	MOVE	GT,[%SPTC2]		;PQ2 EBOX/MBOX TICKS
	PJRST	DBOPTN
STC2%G:	MOVE	GT,[%SPTC2]
	PJRST	SIMINC
;
STCH%I:	MOVE	GT,[%SPTCH]		;HPQ EBOX/MBOX TICKS
	PJRST	DBOPTN
STCH%G:	MOVE	GT,[%SPTCH]
	PJRST	SIMINC
;
; NOW FOR THE WASTED CORE STUFF.
;
WASK%I:	MOVE	GT,[%SPMWC]		;# OF MEASUREMENTS
	PUSHJ	P,FETTAB		;NON OPTIONAL
	MOVEM	GT,WASK%C		;# OF MEASUREMEMTS.
	MOVE	GT,[%SPSWC]		;SUM OF WASTED PAGES
	PUSHJ	P,FETTAB		;NON OPTIONAL
	MOVEM	GT,WASK%P		;PAGES
	PJRST	DBCORE			;ALLOCATE CORE.
;
;INCREMETAL DATA COLLECTION
;
WASK%G:	MOVE	GT,[%SPMWC]		;# OF MEASUREMENTS
	PUSHJ	P,FETTAB		;NON OPTIONAL
	MOVEM	GT,WASK%D		;NEW COUNT...SAVE IT
	MOVE	GT,[%SPSWC]		;SUM OF WASTED PAGES
	PUSHJ	P,FETTAB		;NON OPTIONAL
	MOVEM	GT,WASK%Q		;NEW SUM OF PAGES
;
;  SAVE A FEW AC(S)
;
	PUSH	P,N1
	PUSH	P,N2
;
	MOVE	N1,WASK%P		;PREVIOUS PAGES
	MOVE	N2,WASK%C		;PREVIOUS COUNT
	SUBM	GT,N1			;INCREMENTAL PAGES .. N1
	MOVE	GT,WASK%D		;NEW COUNT
	SUBM	GT,N2			;INCREMENTAL COUNT
	FLTR	N1,N1			;MAKE THE ARITMETIC
	FLTR	N2,N2			;EASY TO DO
	FDVR	N1,N2			;INC PAGES/INC COUNT
	FIXR	N1,N1			;SO TRACK WILL UNDERSTAND
	MOVE	GT,N1			;FOR STONXT
;
;  RESTORE N1 & N2
;
	POP	P,N1
	POP	P,N2
	PUSHJ	P,STONXT		;STORE IN NEXT CELL
;
	MOVE	GT,WASK%D		;MAKE RECENT OLD
	MOVEM	GT,WASK%C		;COUNT...
	MOVE	GT,WASK%Q		;MAKE RECENT OLD
	MOVEM	GT,WASK%P		;PAGES
	POPJ	P,			;EXIT/RETURN
;
;
;THE FUNNY LITTLE DATA BASE
;
WASK%C:	Z
WASK%P:	Z
WASK%D:	Z
WASK%Q:	Z
;
; NOW FOR CMQ/PQ1 SWAP IN RESPONSE TIME
;
CPSI%I:	MOVE	GT,[%SPNRS]		;# OF RESPONSES CMQ/PQ1 SWAP IN
	PUSHJ	P,FETTAB		;NON OPTIONAL
	MOVEM	GT,CPSI%R		;# OF RESPONSES.
	MOVE	GT,[%SPNTS]		;TOTAL TICKS
	PUSHJ	P,FETTAB		;NON OPTIONAL
	MOVEM	GT,CPSI%T		;TICKS
	PJRST	DBCORE			;ALLOCATE CORE.
;
;INCREMETAL DATA COLLECTION
;
CPSI%G:	MOVE	GT,[%SPNRS]		;# OF RESPONSES
	PUSHJ	P,FETTAB		;NON OPTIONAL
	MOVEM	GT,CPSI%S		;NEW RESPONSE COUNT...SAVE IT
	MOVE	GT,[%SPNTS]		;SUM OF TICKS
	PUSHJ	P,FETTAB		;NON OPTIONAL
	MOVEM	GT,CPSI%U		;NEW TICK VALUE
;
;  SAVE A FEW AC(S)
;
	PUSH	P,N1
	PUSH	P,N2
;
	MOVE	N1,CPSI%T		;PREVIOUS TICKS
	MOVE	N2,CPSI%R		;PREVIOUS COUNT OF RESPONSES
	SUBM	GT,N1			;INCREMENTAL TICKS .. N1
	MOVE	GT,CPSI%S		;NEW COUNT OF RESPONSES
	SUBM	GT,N2			;INCREMENTAL COUNT
	FLTR	N1,N1			;MAKE THE ARITMETIC
	FLTR	N2,N2			;EASY TO DO
	FDVR	N1,N2			;TICKS/RESPONSES.
	FIXR	N1,N1			;SO TRACK WILL UNDERSTAND
	MOVE	GT,N1			;FOR STONXT
;
;  RESTORE N1 & N2
;
	POP	P,N1
	POP	P,N2
	PUSHJ	P,STONXT		;STORE IN NEXT CELL
;
	MOVE	GT,CPSI%S		;MAKE RECENT OLD
	MOVEM	GT,CPSI%R		;COUNT OF RESPONSES...
	MOVE	GT,CPSI%U		;MAKE RECENT OLD
	MOVEM	GT,CPSI%T		;TICKS
	POPJ	P,			;EXIT/RETURN
;
;
;THE FUNNY LITTLE DATA BASE
;
CPSI%R:	Z
CPSI%T:	Z
CPSI%S:	Z
CPSI%U:	Z
;
	;** END OF INDIVIDUAL ROUTINES ***		

SUBTTL	DATA AREA


;TABLE OF FIELD LENGTHS FOR POSITIONING ROUTINE
;	NOTE :  LENGTH OF HIGH CORE FIELD IS FOR BOTH HIGH AND LOW
;
	DEFINE	X(A,B,C) <
	IFN B, <P.'A:	EXP	B	>>

SPATAB:	DATUMS

	%NUMFL==.-SPATAB

; HERE WE MAKE A TABLE OF 12 MONTHS FOR THE SYSDAT MODULE

	DEFINE X(AA),
<IRP AA
<	SIXBIT/-'AA'-/>>
MONTAB:
	X <JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC>

;  AND MAKE A DAY TABLE TOO
DAYTAB:	SIXBIT/(WED)/
	SIXBIT/(THUR)/
	SIXBIT/(FRI)/
	SIXBIT/(SAT)/
	SIXBIT/(SUN)/
	SIXBIT/(MON)/
	SIXBIT/(TUES)/


; HERE WE DEFINE THE PURE TABLES FOR THE SYSDAT MODULE


IFN SYS, <


; NOW IS THE VARIANCE TABLE, FOR EACH ITEM IT CONTAINS THE RANGE
; OVER WHICH WE MAY GROUP ITEMS TOGETHER FOR THE "PERCENT OF TOTAL
; IN THE RANGE X TO Y" ROUTINE (OUTDB?)
; DEFINE THIS AS 1 IF EACH POINT IS TO BE DISCRETE
; EACH ENTRY HAS THE FORM  : 	XXXX.V:	   EXP	VARIANCE THIS ITEM
;

	DEFINE X(AA,BB,CC,DD,EE,FF)<
BB'.V:
	IFG FF, <EXP	FF>
	IFLE FF, <PRINTX ?VALUES FOR SYSDAT  VARIANCE MUST BE 1 OR GREATER
	EXP	1>>

TAB.V:	SYSDAT
	LEN.V==.-TAB.V


; HERE WE HAVE THE TABLE OF INITIALIZING ROUTINES
; THEY ARE CALLED ONCE , WHEN WE FIRST GO INTO THE SYSDAT MODULE
; THEY SET UP POINTERS, PERHAPS GET FIXED ADDRESSES TO AVOID GETTABS,ETC
; THIS TABLE CONTAINS THE ADDRESS OF THE INITIALIZING ROUTINES
; A ZERO ENTRY INDICATES NO ROUTINE
; NOTE: THESE ROUTINES CALL ASSCOR AND SET UP THE DATA BLOCKS
;

	DEFINE X(AA,BB,CC,DD,EE,FF)<
BB'.I:	EXP CC
>


TAB.I:	SYSDAT
	LEN.I==.-TAB.I


; HERE WE DEFINE TABLE OF ADDRESSES FOR GATHERING DATA ROUTINES
;
; EACH ENTRY IS THE ADDRESS OF A ROUTINE FOR PUSHING TO , TO GET
; DATA ON EACH LOOK.  ROUTINES FOR INITIALIZING,GETTING AND DISPLAYING
; SHOULD ALL END WITH A POPJ TO RETURN.
; AS WITH INITIALIZING, A ZERO ENTRY MEANS NO ROUTINE IS TO BE DONE
;
; EACH ENTRY IS OF THE FORM:	XXXX.G:	EXP  GATHER ROUTINE


	DEFINE	X(AA,BB,CC,DD,EE,FF)<
BB'.G:	EXP	DD
>


TAB.G:	
	SYSDAT
	LEN.G==.-TAB.G


; HERE WE MAKE THE TABLE OF POINTERS TO DATUM LABELS
; IT IS OF THE FORM XXXX.N:	0,,ADDR LABEL IN ASCIZ

	DEFINE X(AA,BB,CC,DD,EE,FF)<
IFDIF	<AA> <0>,<
BB'.N:	[ASCIZ\AA\]	>
IFIDN	<AA> <0>,<
BB'.N:	EXP	0>>

TAB.N:	SYSDAT
	LEN.N==.-TAB.N


; FINALLY, WE DEFINE A TABLE CONTAINING THE ADDRESSES OF THE OUTPUT
; ROUTINES. EACH ENTRY IS A POINTER TO A ROUTINE TO DO A  PRINTOUT
; OF THE DATA BLOCK.  SEE THE CODE FOR A DESCRIPTION OF AVAILABLE
; ROUTINES.
; 
; EACH ENTRY IS OF THE FORM	XXXX.D:	EXP	PRINT ROUTINE 
;
; A ZERO ENTRY IS OF COURSE AN INSTRUCTION TO DO NO DISPLAYING OF THE
; ITEM

	DEFINE	X(AA,BB,CC,DD,EE,FF)<
BB'.D:	EXP	EE
>


TAB.D:	
	SYSDAT
	LEN.D==.-TAB.D

; FORM A TABLE OF 4 LETTER SIXBIT CODES , 1 FOR EACH
; ITEM. THE TABLE IS USED FOR FORMAT:TRACE TYPE REPORTS AND FOR
; ARGUMENTS TO /INCLUDE AND /EXCLUDE
; THE 4 LETTERS ARE THE SECOND ARGUMENT IN THE SYSDAT MACRO

; FORM IS:	XXXX.C:	  SIXBIT/XXXX/
;

	DEFINE X(AA,BB,CC,DD,EE,FF)<

BB'.C:	SIXBIT/BB/>

TAB.C:	SYSDAT
	LEN.C==.-TAB.C


	; END OF CONDITIONAL FOR SYSDAT TABLES      >



;** POSSIBLE START OF IMPURE AREA **

	IFN PURESW,	< RELOC >

LOWBEG==.	;START OF CORE AREA TO CLEAR ON START AND RESTART



; THIS BLOCK CONTAINS THE CURRENT DATA ON JOB

	DEFINE X(A,B,C)<
C.'A:	BLOCK 	1	>

CURDAT:	DATUMS
	SIZDAT==.-CURDAT	;SIZE OF THIS BLOCK

; THIS BLOCK CONTAINS THE OLD CURRENT DATA ON JOB
	DEFINE X(A,B,C)<
O.'A==C.'A-CURDAT>


	;SINCE THESE ARE OFFSETS TO FREE CORE LOCATIONS
	;WITH AC J SET UP AS BASE ADDRESS, DONT GET REAL LOCATIONS
	DATUMS
	OLDAT==CURDAT-CURDAT


QTUM:	BLOCK	1	;TIME TO SLEEP BETWEEN LOOKS
SAVNUM:	BLOCK	1	;THE TTY OR JOB NUMBER USER WANTS TO WATCH

SAVPOP:	BLOCK	1	;PPN OR PROGRAM THAT WE ARE WATCHING
CTRKJ:	BLOCK	1	;-1 WHEN TRACKING AN ACTIVE JOB
DEFCMP:	BLOCK	1	;BIT MAP FOR DEFINING WHAT /COMPARE DOES

SLPTIM:	BLOCK	1	;TIME WE WENT TO SLEEP LAST IN MS SINCE MID.
SLPQT:	BLOCK	1	;SAME AS QTUM EXCEPT IN MILLISECONDS
LOOKS:	BLOCK	1	;NUMBER OF LOOKS TO TAKE BEFORE EXITING (0=INFINITE)
HIJOB:	BLOCK	1	;HIGHEST JOB NUMBER CURRENTLY ASSIGNED
MAXTTY:	BLOCK	1	;HIGHEST TTY NUMBER EXISTANT
MAXJOB:	BLOCK	1	;HIGHEST NUMBER OF JOBS
MYPPN:	BLOCK	1	;PPN OF THIS JOB
MYJOB:	BLOCK	1	;JOB NR. OF JOB RUNNING 
SAVUP:	BLOCK	1	;NEG. TIME OF DAY ENTERED LOOKUP&PRINT
SAVST:	BLOCK	1	;TIME STARTING REPORT
SAVSTU:	BLOCK	1	;REPORT START TIME IN UNIVERSAL FORMAT
SAVUPU:	BLOCK	1	;REPORT END TIME IN UNIVERSAL FORMAT
JSTFLG:	BLOCK	1	;SET TO -1 WHEN WANT OUTPUT LINED UP

RVAL:	BLOCK	1	;VALUE OF /R REPORT COUNTER
AVALC:	BLOCK	1	;COUNTER FOR FILSAV ROUTINE
AVAL:	BLOCK	1	;MASTER COPY OF AVALC, PRINTOUTS/SAVE
SDISK:	BLOCK	1	;-1 MEANS WATCH ALL DISKS
			;0  MEANS WATCH ONLY DISKS IN SYSTEM SL

OUTRUN:	BLOCK	1	;OUTPUT RUNTIME
OUTRD:	BLOCK	1	;OUTPUT READS
OUTWR:	BLOCK	1	;OUTPUT WRITES
NCPU:	BLOCK	1	; # CPUS MONITORS WAS BUILT FOR
mbord0:	block	1	;use meter board on cpu0
mbord1:	block	1	;use meter board on cpu1
mbord2:	block	1	;use meter board on cpu2
mbord3:	block	1	;use meter board on cpu3
mbord4:	block	1	;use meter board on cpu4
mbord5:	block	1	;use meter board on cpu5

; STUFF FOR SPYING

MAXGTB:	BLOCK	1	;CONTAINS NUMBER OF GETTAB TABLES
TABTAB:	BLOCK	1	;ADDRESS OF GETTAB IMMEDIATE TABLE
PDBPTR:	BLOCK	1	;POINTER TO PDB TABLE (JBTPDB)
 ; DEBUG BLOCK POINTED TO BY .JBOPS (LOC 135)
 ;MAY BE USEFUL SOME DAY FOR ERROR DEBUGGING
DEBBLK:
SAVGT:	BLOCK	1	;SAVE GETTAB ARGS
SAVADR:	BLOCK	1	;SAVE EXEC  ADDRESS OF LAST SPY
ERRPC:	BLOCK	1	;ADDRESS ERRMSG LAST CALLED FROM
MEMUNI:	BLOCK	1	;ASCII K OR P DEPENDING ON PROCESSOR
LASTOK:	BLOCK	<MAXTOK+1+4>/5	;LAST TOKEN INPUT
OLDPTR:	BLOCK	1	;POINTER TO BASE OF OLD DATA
SWIDX:	BLOCK	1	;BASE OF ADDRESS OF TABLE FOR TABLUK
LASSW:	BLOCK	1	;SIXBIT NAME OF LAST SWITCH SEEN
HPQREQ:	BLOCK	1	;HPQ NUMBER THAT USER REQUESTED
EXCFLG:	BLOCK	1	;0/-1 FOR INCLUDE/EXCLUDE

; IO AREA

TYBUF:	BLOCK	3
SAVFF:	BLOCK	1	;REMEMBERED VALUE OF JOBFF


; AREA FOR COMMAND INPUT
;[*] NEW AND OLDER LOCATIONS..
FSTFLG:	BLOCK 	1	;[*]SET TO -1 FOR FIRST TIME
TODAY:	BLOCK	1	;[*]TODAY'S DATE FOR DAILY STUFF
NEWNAM:	BLOCK	1	;[*]NAME FOR THE NEXT DAILY FILE
DAILYF:	BLOCK	1	;[*]SEEN /DAILY SWITCH
STRTED:	BLOCK	1	;[*]-1 MEANS THAT TRACK IS ALL INITED AND RUNNING

COMPTR:	BLOCK	1	;PTR TO BYTE IN COMBUF
LASCHR:	BLOCK	1	;LAST CHARACTER SEEN


; AREA FOR FILE SPECIFICATIONS

FILMOD:	BLOCK	1	;GETS FILE MODE FOR OPEN
FILDEV:	BLOCK	1	;GETS DEVICE NAME
FILBUF:	BLOCK	1	;GETS BUFFER ADDRESSES
FILNAM:	BLOCK	1	;GETS FILE NAME
FILEXT:	BLOCK	1	;GET FILE EXTENSION
FILDAT:	BLOCK	1	;GETS FILE DATE
FILPPN:	BLOCK	1	;GETS PPN OR PTR TO PATH BLOCK
	LUELEN==.-FILNAM ; SIZE OF LOOKUP BLOCK

PTHADR:	BLOCK	1	;GETS PATH UUO ARG
PTHSCN:	BLOCK	1	;SCAN SWITCH, CURRENTLY ALWAYS LEFT DEFAULT
PTHPPN:	BLOCK	1	;PPN OF PATH SPECIFICATION
PTHSFD:	BLOCK	MAXSFD+1;MAXIMUM SIZE SFD BLOCK
	PTHLEN==.-PTHADR



; ARG BLOCK FOR MULTIPLE ARGUMENT HANDLING
ARGS:	BLOCK	26
	ARGSLN==.-ARGS

SAVAC:	BLOCK	20	;SAVE THE ACS
CPUTYP:	BLOCK	1	;CPU TYPE OF CPU0 (SAME AS ALL TYPES, HOPEFULLY)



;** DATA AREA FOR SYSDAT MODULE


IFN SYS, <

T.LOOK:	BLOCK	1	;TOTAL LOOKS TAKEN,STARTS WITH LOOK ZERO
NLOOK:	BLOCK	1	;NUMBER OF REPORTS PRINTED
LS.TIC:	BLOCK	1	;LAST TICK TIMER
CU.TIC:	BLOCK	1	;CURRENT TICK TIMER
EL.TIC:	BLOCK	1	;ELAPSED TIME IN TICKS BETWEEN LS,CU.TIC
LS.MS:	BLOCK	1	;LAST MS TIMER
CU.MS:	BLOCK	1	;CURRENT MS TIME
EL.MS:	BLOCK	1	;ELAPSED MS BETWEEN LS.MS,CU.MS

ADJPTR:	BLOCK	1	;PTR TO CURRENT DATA BLOCK ADJUSTED FOR OUTPUT
ADJLOK:	BLOCK	1	;ADJUSTED NUMBER OF LOOKS TAKEN
UL:	BLOCK	1	;UPPER LIMIT OF OUTDB? ROUTINE
LL:	BLOCK	1	;LOWER LIMIT OF OUTDB? ROUTINE
DONFLG:	BLOCK	1	;FLAG IS -1 WHEN OUTDBX IS DONE
VAL:	BLOCK	1	;PERCENT OF TOTAL IN THE RANGE(INTEGER PART)
ROTFLG:	BLOCK	1	;FLAG FOR ROTATING INCREMENTAL VALUES
SUMSQ:	BLOCK	1	;SUM-OF-SQUARES FOR OUTDB? ITEMS
RVALC:	BLOCK	1	;COUNTDOWN OF LOOKS LEFT IN THIS REPORT
SYSNAM:	BLOCK	5	;SYSTEM NAME IN ASCIZ
SYSDTE:	BLOCK	2	;DATE SYSTEM WAS BUILT
SYSVER:	BLOCK	1	;MONITOR VERSION
SYSSIZ:	BLOCK	1	;SIZE OF MONITOR IN WORDS
USIZ:	BLOCK	1	;SIZE OF USER MEMORY IN APPROPRIATE UNITS (K OR P)
IFN FTTRC, <
BAUXWD:	BLOCK	1	;AUXIALLY ID WORD USED FOR TRACE REPORTS
>; END OF IFN FTTRC
INCDIO:	BLOCK	1	;INCREMENTAL USER DISK IO IN BLOCKS
INCSWP:	BLOCK	1	;INCREMENTAL DISK IO IN BLOCKS FOR SWAPPING
DIOTAB:	BLOCK	1	;PTR TO BLOCK LOGMAX LONG FOR DISK IO
KCSTAB:	BLOCK	1	;PTR TO BLOCK LOGMAX LONG FOR INCR. KCS
CPTTAB:	BLOCK	1	;PTR TO BLOCK LOGMAX FOR INCR. CPUT
;
NUMJOB:	BLOCK	1	;NUMBER OF JOBS CURRENTLY LOGGED IN
HISEGN:	BLOCK	1	;HIGH SEGMENT NUMBER SEEN BY GETCOR
JOBTB1:	BLOCK	1	;PTR TO TABLE WITH 1 ENTRY FOR EACH JOB
			;HAS FORM J,,ADDRESS OF BLOCK
			;FORMAT OF TABLE WORD IS:
			; XWD LOW CORE, HIGH CORE IF JOB IS LOGGED IN
			; -1 IF JOB NOT LOGGED IN. NOTE THAT
			;CORE IS IN UNITS OF K OR P
JOBTB2:	BLOCK	1	;POINTER TO JOB BLOCK . FORMAT OF PTR
			;IS SAME AS JOBTB1.  1 WORD FOR EACH JOB
			;WORD FORMAT:
			;BIT	0	=0 IF JOB IS IN CORE
			;		=1 IF JOB IS SWAPPED
			;BITS 1-17	HIGH SEGMENT NUMBER OR 0
			;BIT 18		ON IF STATUS RUN BIT WAS ON
			;BITS 19-23	CURRENTLY UNUSED
			;BITS 24-35	2 CHR SIXBIT STATUS CODE
;DO NOT SEPARATE SEGTAB THRU ACTCOR
SEGTAB:	BLOCK	20	;BIT MAP   1 BIT PER HISEG. 1 IF ALREADY COUNTED THIS HISEG
SEGPTR:	BLOCK	1	;WILL GET INDIRECT PTR OF SEGTAB+OFFSET(AC)
			;IN CORE USE TALLY.
JOBRN:	BLOCK	1	;JOBS IN "RN" STATE
JOBRNC:	BLOCK	1	;JOBS IN "RN" STATE AND IN CORE
JOBSHR:	BLOCK	1	;JOBS IN SHAREABLE RESOURCE QUEUES
JOBTTY:	BLOCK	1	;JOBS IN TI OR TO STATUS
JOBIO:	BLOCK	1	;JOBS IN IO STATUS, CURRENTLY IO,DI,PI
TOTCOR:	BLOCK	1	;TOTAL VIRTUAL CORE IN USE
SHRCOR:	BLOCK	1	;TOTAL CORE IN USE TAKING SHAREING INTO ACCOUNT
ACTCOR:	BLOCK	1	;LIKE SHRCOR, BUT FOR ACTIVE JOBS

UNIPTR:	BLOCK	1	;AOBJN POINTER TO LIST OF DISK UNIT NAMES
UNIDB:	BLOCK	1	;ADDRESS OF LIST OF DBS FOR DISK UNITS AND CHANNELS
NSNCRL:	BLOCK	1	;LAST SEEN VALUE OF MONITOR'S %NSNCR
TNFCC:	BLOCK	1	;TOTAL NR. OF FREE CORE CHUNKS
TNTCH:	BLOCK	1	;TOTAL NR. OF TTY CHUNKS



; HERE WE CREATE THE DATA BLOCK POINTER TABLE.
; NOTE THAT SPACE IS RESERVED FOR EVERY ITEM IN THE SYSDAT
; MACRO, BUT NO POINTERS ARE ACTUALLY CREATED, OR DATA BLOCKS
; CREATED. THIS IS THE RESPONSIBILTY OF THE INITIA ROUTINES
; THATS WHY THIS TABLE IS IN THE IMPURE SECTION OF THE PROGRAM
; EACH ITEM IN THIS TABLE IS INITIALLY OF THE FORM:
;	XXXX.P:	BLOCK	1
;
; AFTER INITIALIZATION IT IS USUALLY OF THE FORM:
;	XXXX.P:	L,,ADDR		WHERE ADDR IS THE START OF THE
;				DATA BLOCK FOR THIS ITEM

	DEFINE X(AA,BB,CC,DD,EE,FF)<
BB'.P:	BLOCK	1
>

TAB.P:	SYSDAT
	LEN.P==.-TAB.P


	; END OF CONDITIONAL FOR SYSDAT DATA AREA 	>


; PUSH DOWN LIST

PDL:	BLOCK PDSIZE

	VAR

LOWEND==.-1	;END OF CORE AREA TO CLEAR ON START AND RESTART
	IFN PURESW,	<RELOC >
SCD0:	BLOCK 1	;uscheduling interval (SCDINT)
SCD2:	5	;class quotas/flags:  b0=fixed, 1-17=class, 18-35=quota
	BLOCK 5
SCD3:	2	;pq1, pq2 quantum runtimes
	BLOCK 2
SCD6:	BLOCK 1	;min core usage per job (PROTO)
SCD11:	BLOCK 1	;min core usage multiplier (PROT)
SCD13:	BLOCK 1	;min core usage requeue constant (PROT1)
SCD14:	BLOCK 1	;min core usage maximum (PROTM)
SCD15:	3	
	block 1	;PQ1 quantum multiplier:  rh=quantum multiplier
	block 1	;PQ2 quantum multiplier:  rh=quantum multiplier
	BLOCK 1	;scaling factor
SCD16:	2	
	block 1	;PQ1 max quantum runtime/queue:  rh=max time slice
	block 1	;PQ2 max quantum runtime/queue:  rh=max time slice
SCD17:	5	;secondary class quota:  lh=class#, rh=quota
	BLOCK 5
SCD20:	BLOCK 1	;time % to scan q swapped in before subqueue (SCDJIL)
SCD21:	BLOCK 1	;swap scan time - (SCDSWP)
SCD24:	BLOCK 1	;scheduler fairness factor
SCD25:	BLOCK 1	;swapper fairness factor (MAXIFC)
SCD26:	BLOCK 1	;incore fairness factor (SCDIOF)
SCD27:	BLOCK 1	;SCDCOR
SCD22:	BLOCK 1		;BACKGROUND BATCH CLASS (BBSUBQ)
SCD23:	BLOCK 1		;BACKGROUND BATCH SWAP TIME (SCDBBS)
SCD4:	BLOCK 5	;CHAN USE FRACTION
			;LH=CHAN#, RH=USE FRACTION
SCDEND:
SCDL2=SCDEND-SCD0+1
;
SCDBLK:	0,,SCD0
	2,,SCD2
	3,,SCD3
	6,,SCD6
	11,,SCD11
	13,,SCD13
	14,,SCD14
	15,,SCD15
	16,,SCD16
	17,,SCD17
	20,,SCD20
	21,,SCD21
	24,,SCD24
	25,,SCD25
	26,,SCD26
	27,,SCD27
	22,,SCD22		;BB CLASS
	23,,SCD23		;BB SWAP TIME
	4,,SCD4		;CHAN USE FRACTION
SCDLEN=.-SCDBLK
	END	TRACK

