TITLE	D6DINT -- UUO AND INTERRUPT SERVICE FOR THE DL10 DN60 SERIES - V023
SUBTTL	ED FORTMILLER/EGF & JOHN SAUTER/JBS	22-DEC-87

	SEARCH	F,S
	$RELOC
	$HIGH


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1976,1977,1978,1979,1980,1982,1984,1986,1988.
;ALL RIGHTS RESERVED.

.CPYRT<1976,1988>


XP	V6DINT,023			;VERSION NUMBER

ENTRY	D6DINT

D6DINT:
SUBTTL	DL10 BYTE POINTER DEFINITION

COMMENT	\

	 0    2 3    5 6            13 14                    35
	--------------------------------------------------------
	I      I      I               I                        I
	I P(3) I S(3) I WORD COUNT(8) I    ADDRESS ADR (22)    I
	I      I      I               I                        I
	--------------------------------------------------------

	P	Position of byte in the PDP10 word
		(except when S=0 OR S=7)

	S	Size of byte in number of bits

	WC	Maximum number of PDP-10 words required
		for this transfer (in negative form)

	ADR	Address of indirect PDP-10 word when transfer
		is not immediate.  Data, when the transfer is immediate,
		resides in bits 20 - 35.


	S	MODE	BITS		FUNCTION

	0	I	16	The byte is put in the right-most 16
				bits, 20-35, of the ADR field of
				the Byte Pointer itself.

	1	NI	16	The byte is in location at a
				position determined by the P field. P
				is not incremented.

	2	NI I	16	The incremented pointer determines the
				byte position.  This is similar to the
				PDP-10 ILDB or IDPB operation and is used
				for packing or unpacking characters in
				PDP-10 memory. The pointer is incremented
				first before packing or unpacking.  When
				P=7, the P field is reset to 0 and no
				increment to the address is performed.

	3	NI I	12	Same as S = 2.

	4	NI I	8	Same as S = 2.

	5	NI I	7	Same as S = 2.

	6	NI I	6	Same as S = 2.

	7	I	16	Same as S = 0.

		I    = Immediate
		NI   = Not Immediate
		NI I = Not Immediate incrementing Byte Pointer

\
;D60DSP	ROUTINE CALLED BY NETSER THAT DISPATCHES TO THE PROPER FEK FUNCTION
;CALL	T1 := FUNCTION CODE
;	J := FEK ADDRESS
;RETURN	CPOPJ

D60DSP::CAIL	T1,FF.ONC	;RANGE CHECK THE FUNCTION
	CAILE	T1,FF.CPW	;  CODE AND STOP IF BAD
	STOPCD	CPOPJ,DEBUG,BFC,;++ BAD FUNCTION CODE TO FEK
	JRST	@.+1(T1)	;DISPATCH TO APPRIOATE ROUTINE
	IFIW	CPOPJ##		;ONCE ONLY CODE
	IFIW	D60SEC		;ONCE/SECOND CODE
	IFIW	CPOPJ##		;SET UP A READ REQUEST
	IFIW	CPOPJ##		;SET UP A WRITE REQUEST
	IFIW	CPOPJ##		;CRASH THE FEK (CPU WENT DOWN?)
	IFIW	CPOPJ##		;EXIT PRIMARY PROTOCOL (DTE ONLY)
	IFIW	CPOPJ##		;START PRIMARY PROTOCOL (DTE ONLY)
	IFIW	CPOPJ##		;WE DON'T CARE ABOUT STATION CONTROL
	IFIW	CPOPJ##		;SYSTEM SLEEP.  WHAT SHOULD I DO?
	IFIW	CPOPJ##		;SYSTEM WAKE.  WHAT SHOULD I DO?


;CALL11 ENTRY VECTOR FOR DL10 BASED DN60
D60CEV::JRST	D60UD			;CODE FOR UP/DOWN
	JRST	D60QU			;CODE FOR QUEUE11
	JRST	D60ED			;CODE FOR EXAMINE/DEPOSIT


D60SEC: HRRZ	W,FEKDLX(J)		;PICK UP BASE TABLE ADDRESS
	JUMPE	W,CPOPJ##		;RETURN IF NONE
	SKIPL	FEKBLK(J)		;IF FK.ONL CLEAR,
	POPJ	P,			;DON'T BOTHER ME
	PUSHJ	P,SAVE1##		;P1 USED FOR WINDOW POINTER
	SKIPE	P1,DLXWIN##(W)		;POINT P1 TO DL10 WINDOW
	XCT	DLXSTA##(W)		;MARK -10 AS BEING ALIVE
	PUSHJ	P,D60TMO##		;CHECK FOR TIME OUTS
	POPJ	P,			;RETURN
	POPJ	P,			;RETURN
SUBTTL	PDP-11 INTERFACE

;COME HERE WHEN A PDP11 IS FIRST RECOGNIZED AS BEING A DN60 PDP11
;
D60III::MOVE	J,DLXWIN##(W)		;POINT TO WINDOW
	MOVE	T1,DLXMOD##(J)		;PICK UP MOD NUMBER
	CAIE	T1,D60WVR##		;RIGHT?
	STOPCD	CPOPJ##,DEBUG,DN60VI, 	;++DN60 WRONG PDP11 CODE
	SETOM	DLXTA##(J)		;MARK 10 AS ALIVE
	SETZM	DLXADR##(J)		;CLEAR EXAMINE ADDRESS
	SETZM	DLXDAT##(J)		;AND EXAMINE DATA
	SETZM	DLXRST##(J)		;AND RESULT CODE FROM 11
	SETZM	DLXOPX##(J)		;AND OPERATION CODE FOR 11
	SETZM	DLXSWD##(J)		;AND EXM/DEP STATUS WORD
	MOVE	T1,[PUSHJ P,D60KII]
	MOVEM	T1,DLXINI##(W)		;INTERRUPT INSTRUCTION
	MOVE	T1,[BYTE (3) 1,1 (8) 377 (4) 0 (18) DLIGTS]
	MOVEM	T1,DLXLT1##(J)		;POINTER TO LOW IDLE WORD
	TLZ	T1,(<BYTE (3) 1>) 	;SET POSITION TO ZERO
	MOVEM	T1,DLXLT2##(J)		;POINTER TO HIGH IDLE WORD
	MOVE	T1,[PUSHJ P,REMPRG ]	;
	MOVEM	T1,DLXPRG##(W)		;PURGE INSTRUCTION
	SETOM	DLXTS##(J)		;MARK 10 AS RUNNING
	PJRST	D60SUP##		;GO FINISH SETUP
SUBTTL	HERE WHEN A KNOWN DN60 INTERRUPTS

;HERE WHEN THE DL10 INTERRUPTS
;
D60KII::				;INTERRUPT ROUTINE
	PUSHJ	P,SAVE1##		;SAVE P1
	HRRZ	J,DLXFEK##(W)		;GET FEK ADDRESS
	MOVE	P1,DLXWIN##(W)		;WINDOW ADDRESS
	MOVE	T1,DLXSWD##(P1)		;GET THE STATUS WORD FOR EXAMINE/DEPOSIT
	ANDCMI	T1,D60.ER##		;ZAP THE ERROR BIT
	JUMPE	T1,IWKJOB		;IF 0 STATUS OR ERROR WAKE THE JOB
	SKIPN	DLXRST##(P1)		;NOT EXM/DEP SO CHECK RESULT CODE
	  POPJ	P,			;DISMISS THE INTERRUPT
IWKJOB:	SKIPE	T1,DLXCEU##(W)		;SEE IF JOB USING THE CAL11.
	  PJRST	D60WAK##		;YES, GET JOB OUT OF EW
	POPJ	P,			;DISMISS THE INTERRUPT

;COME HERE WHEN A DN60 GOES DOWN
;
REMPRG:	PUSH	P,W			;SAVE W
	MOVE	W,P2			;ROUTINES NEED BASE TABLE IN W
	SKIPE	T1,DLXCEU##(W)		;USER OF THE CAL11 UUO?
	  PUSHJ	P,D60WAK##		;GO WAKE AND UNLOCK HIM IF NECESSARY
	SETZM	DLXTIM##(W)		;MAKE SURE TIMER IS CLEAR
	HRRZ	W,DLXFEK##(W)		;GET FEK POINTER
	MOVSI	T1,FK.ONL		;ON-LINE BIT
	ANDCAM	T1,FEKBLK(W)		;OFFLINE
	PJRST	WPOPJ##			;RESTORE AC(W) AND RETURN TO
					; THE CALLER

;HERE TO SEE IF THE PDP-11 IS UP OR DOWN
D60UD:	MOVE	P1,DLXWIN##(W)		;GET THE WINDOW ADDRESS
	SKIPLE	DLXDWN##(P1)		;SKIP IF DOWN
	AOS	(P)			;UP
	POPJ	P,			;RETURN
;HERE TO EXAMINE OR DEPOSIT PDP11 MEMORY
;
; CALL:	JRST	D6DED			;J CONTAINS JOB NUMBER
;					;T1 FUNCTION CODE
;					;T3 ADDRESS
;					;T4 DATA TO DEPOSIT
;					;W POINTS TO THE BASE TABLE
;
D60ED:	HRRZM	J,DLXCEU##(W)		;STORE OUR JOB NUMBER AND INDICATE
					; EXM/DEP BY 0 IN THE (LH)
	MOVE	P1,DLXWIN##(W)		;GET THE WINDOW ADDRESS
	MOVEM	T3,DLXADR##(P1)		;PUT THE ADDRESS IN THE WINDOW
	MOVEM	T4,DLXDAT##(P1)		;PUT DATA TO DEPOSIT INTO THE WINDOW
	MOVEM	T1,DLXSWD##(P1)		;TELL THE PDP11 THE FUNCTION
	MOVEI	T1,2			;TIME TO SLEEP WHILE WAITING FOR
					; A RESPONSE TO THE EXAMINE OR
					; DEPOSIT REQUEST.
	PUSHJ	P,D60EW			;GO OFF FOR A SNOOZE
	HRRZ	T1,DLXSWD##(P1)		;GET THE STATUS WORD
	SETZM	DLXSWD##(P1)		;NOW ZERO IT SO AT INTERRUPT
					; LEVEL WHEN DOING A QUE11 WE WON'T
					; GET FOOLED BY A BIT SET HERE
	TRNE	T1,D60.ER##		;SEE IF ERROR BIT UP
	  PJRST	ECOD10##		;**ERROR-10** BECAUSE PDP11 SAID
					; ILLEGAL ADDRESS.
	PJUMPN	T1,ECOD5##		;**ERROR-5** BECAUSE THE PDP11 DIDN'T
					; ANSWER OUR DEPOSIT OR EXAMINE REQUEST
	SKIPL	T1,DLXDAT##(P1)		;GET EXAMINE DATA
					; THIS WILL SKIP IF DEPOSIT
	  PJRST	STOTC1##		;GIVE USER SKIP RETURN AND DATA
	PJRST	CPOPJ1##		;GIVE USER SKIP RETURN

;HERE FROM D60SER TO PERFORM THE DL10 PORTION OF
; THE .C11QU FUNCTION
;
;AC CONTENTS AT THIS TIME
;
;	T1	FIRST ADDRESS IN THE BUFFER TO BE USED
;	T2	POSITIVE COMPUTED WORD COUNT
;	T3	N/A, WILL NOW BECOME A SCRATCH REGISTER
;	T4	LENGTH, WILL NOW BECOME A SCRATCH REGISTER
;	P2	LINE NUMBER,,DEVICE NUMBER
;	P3	START OF BUFFER, WILL NOW BE COUNTER
;		OF MAXIMUM BYTE COUNT AND BYTE POINTER ALLOWED
;	P4	FUNCTION CODE,,NUMBER OF BYTES
;	F	POSITION OF FIRST BYTE, WILL NOW CONTAIN
;		 (BYTE POSITION)- REMAINDER OF  (BYTE POSITION)/(BYTE SIZE)
;	J	JOB NUMBER, WILL NOW CONTAIN INDEX POINTER TO WINDOW
;	S	BYTE SIZE (THE NUMBER OF BYTES PER WORD)
;	U	REMAINDER FROM (BYTE POSITION)/(BYTE SIZE)
;	W	POINTER TO BASE TABLE
;
D60QU:	MOVE	P1,DLXWIN##(W)		;GET THE WINDOW ADDRESS
	HLRZM	P2,DLXLNX##(P1)		;STORE THE LINE NUMBER IN THE WINDOW
	HRRZM	P2,DLXDVX##(P1)		;STORE THE DEVICE NUMBER IN THE WINDOW
	MOVE	F,S			;COMPUTE (BYTE SIZE)-
	SUB	F,U			; REMAINDER OF (BYTE POSITION)/(BYTE SIZE)
	MOVEI	P3,^D15			;MAXIMUM NUMBER OF BYTE COUNT AND BYTE
					; POINTER PAIRS
	MOVEI	J,DLXCBP##(P1)		;WINDOW POINTER TO COUNT/POINTER PAIRS
QUE11L:	MOVE	T3,T1			;GET THE ADDRESS
	ANDI	T3,777			;MAKE IT ADDRESS WITHIN A PAGE
	MOVEI	T4,1000			;FIGURE MAX NUMBER OF WORDS
	SUBM	T4,T3			; THAT CAN BE USED IN THIS PAGE
	CAILE	T3,^D256		;IS IT MORE THAN A DL10 CAN HANDLE?
	  MOVEI	T3,^D256		;YES, SO USE ONLY DL10 MAX
	MOVE	T4,T3			;ASSUME RIGHT COUNT IS IN T3
	CAMLE	T3,T2			;BUT IS WORD COUNT LESS?
	  MOVE	T4,T2			;YES, SO USE THE WORD COUNT
	SUB	T2,T4			;COUNT-NUMBER OF WORDS FOR THIS POINTER
	PUSH	P,T1			;SAVE THE ADDRESS
	ADDM	T3,(P)			;ADD COUNT TO MAKE NEXT FIRST ADDRESS
;
;TO COMPUTE THE BYTE COUNT
;
;	((WORD COUNT - 1)*(BYTE SIZE))+((BYTE SIZE)-
;	 (REMAINDER FROM (BYTE POSITION)/(BYTE SIZE)))
;
	MOVEI	T3,-1(T4)		;WORD COUNT - 1
	IMUL	T3,S			;MULTIPLY BY BYTE SIZE
	ADD	T3,F			;SEE DEFINITION OF F ABOVE
	CAILE	T3,(P4)			;IS COMPUTED BYTE COUNT
					; .GT. REMAINING BYTE COUNT?
	  MOVEI	T3,(P4)			;YES, USE REMAINING BYTE COUNT
	SUB	P4,T3			;THE REMAINING BYTE COUNT FOR NEXT GO AROUND
	MOVEM	T3,(J)			;PUT BYTE COUNT IN THE WINDOW
	PUSHJ	P,MAKPHY		;MAKE USER VIRTUAL ADDRESS
					; INTO A 22-BIT PHYSICAL ADDRESS
;
;TO COMPUTE THE DL10 WORD COUNT FROM A
; POSITIVE WORD COUNT
;
;	400 - POSITIVE WORD COUNT
;
	MOVEI	T3,400			;MAKE COUNT IN T4 INTO
	SUBM	T3,T4			; INTO A DL10 WORD COUNT
	LSH	T4,^D22			;POSITION THE WORD COUNT
	IOR	T1,T4			;BUILD WORD COUNT INTO DL10 POINTER
	DPB	S,[POINT 3,T1,5]	;PUT THE BYTE SIZE IN
;
;TO COMPUTE THE DL10 BYTE POSITION FIELD
;
;	(BYTE SIZE) - (REMAINDER OF (BYTE POS)/(BYTE SIZE))
;		IF RESULT IS 0 MAKE IT 10
;			REGARDLESS SUBTRACT 1
;
	SUBI	U,1			;MAKE 1 LESS TO POINT TO RIGHT BYTE
					; IF WAS 0, IT IS NOW -1 WHICH TURNS
					; INTO 7 WHEN SHIFTED LEFT
	LSH	U,^D33			;POSITION FOR DL10 POINTER
	IOR	T1,U			;PUT THE POSITION FIELD IN THE DL10
					; BYTE POINTER WORD
	SETZ	U,			;MAKE 0 FOR NEXT TIME AROUND
					; NOW CAUSE WE'RE ALWAYS BEGINNING
					; AT THE BEGINNING OF WORD
	MOVE	F,S			;SAVE AS BYTE SIZE
	MOVEM	T1,1(J)			;PUT THE BYTE POINTER INTO THE WINDOW
	POP	P,T1			;GET THE NEXT ADDRESS
	ADDI	J,2			;POINT TO NEXT SPACE IN WINDOW FOR A PAIR
	JUMPLE	T2,QUE11O		;JUMP IF ALL DONE
	SOJG	P3,QUE11L		;GO MAKE THE NEXT POINTER
	  PJRST	ECOD11##		;**ERROR-11** BECAUSE OF BUFFER TO LARGE
QUE11O:	SETZM	(J)			;LAST WORD MUST BE ZERO
	SETZM	DLXRST##(P1)		;MAKE SURE RESULT CODE IS 0
	MOVE	J,.CPJOB##		;GET OUR JOB NUMBER
	TLO	J,D6.Q11##		;INDICATE QUE11 FUNCTION
	MOVSI	T1,NSHF!NSWP		;NO SHUFFLE AND NO SWAP
	TDNE	T1,JBTSTS##(J)		;SEE IF ALREADY LOCKED
	  TLO	J,D6.ALK##		;INDICATE ALREADY LOCKED
	IORM	T1,JBTSTS##(J)		;LOCK THE JOB
	MOVEM	J,DLXCEU##(W)		;STORE OUR JOB NUMBER
	PUSHJ	P,CSDMP##		;INVALIDATE THE CACHE (THE USERS
					; DATA MAY BE IN THE CACHE AND THE
					; PDP11 WILL GET DATA FROM REAL
					; MEMORY.
	HLRZM	P4,DLXOPX##(P1)		;TELL THE 11 THE FUNCTION CODE
	MOVEI	T1,2			;TIME TO SLEEP WHILE WAITING FOR
					; A RESPONSE TO REQUESTED OPERATION
	PUSHJ	P,D60EW			;GO OFF FOR A SNOOZE
					; DLXCEU WILL BE CLEARED UPON RETURN
	PUSHJ	P,CSDMP##		;INVALIDATE THE CACHE
	SKIPN	T1,DLXRST##(P1)		;SEE IF RESULT CODE FROM THE 11
	  PJRST	ECOD5##			;**ERROR-5** BECAUSE PDP11 DIDN'T RESPOND
	HRL	T1,DLXXFR##(P1)		;GET NUMBER OF BYTES TRANSFERRED
	SETZM	DLXRST##(P1)		;CLEAR THE RESULT CODE
	PUSHJ	P,PUTWD1##		;GIVE THE USER THE RESULT CODE
	PJRST	CPOPJ1##		; AND SKIP RETURN
;THIS ROUTINE IS CALLED TO WAKE THE PDP11
; AND PUT THE JOB INTO EVENT WAIT
;
; CALL:	PUSHJ	P,D60EW			;T1 CONTAINS NUMBER OF SECONDS
;					; TILL WE TIME-OUT
;					;W  POINTS TO THE BASE TABLE
;	RETURN				;ALWAYS WITH DLXCEU CLEAR
;
D60EW:	PUSHJ	P,D60TIM##		;PUT TIME IN THE BASE TABLE
					; THAT WE TIME-OUT AT.
	XCT	DLXI11##(W)		;TELL PDP11 THAT WE HAVE
					; SOMETHING FOR HIM TO DO.
	PJRST	D60EVW##		;GO WAIT FOR SOMETHING TO HAPPEN

;SUBROUTINE TO CONVERT A USER VIRTUAL ADDRESS INTO
;  A 22-BIT PHYSICAL ADDRESS
;
; CALL	PUSHJ	P,MAKPHY		;T1 CONTAINS THE USER VIRTUAL ADDRESS
;	RETURN				;T1 CONTAINS THE 22-BIT PHYSICAL ADDRESS
;
;DOESN'T WORK ON A KI10
MAKPHY: SE1ENT				;ALLOW NON-ZERO SECTION VIRTUAL ADDRESSES
	EXCTUX	<MAP T1,(T1)>		;GET PHYSICAL ADDRESS
	TLZ	T1,(MP.NAD)		;CLEAR JUNK
	POPJ	P,			;RETURN WITH 22-BIT PHYSICAL ADDRESS IN  IT
;LOW SEGMENT STORAGE

	$LOW

DLIGTS:	EXP	-1			;PDP-10 WORD FOR DL10 IDLE LIGHTS

	$HIGH

	$LIT

D6DEND::END
