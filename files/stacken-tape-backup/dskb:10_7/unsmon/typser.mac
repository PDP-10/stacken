TITLE	TYPSER INTERFACE BETWEEN D76INT AND I/O OPERATORS  V031
SUBTTL	TEUNIS KORTEWEG  /TK  10 SEP 85

	SEARCH	F,S
	$RELOC
	$HIGH


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1973,1974,1975,1976,1977,1978,1979,1980,1984,1986,1988.
;ALL RIGHTS RESERVED.

.CPYRT<1973,1988>


XP VTYPSE,031

	DLMAP		;DEFINE DL10 OFFSETS

	ENTRY	TYPSER
TYPSER::;REGISTER USE.

;T1,T2,T3 AND T4 ARE SCRATCH
;T1= INTERFACE TO PUTMSG
;T2-T4= USED FOR MESSAGES.
;U USED FOR DISPATCH ADDRESS IN TYPCOM OR LINE BY D76INT ENTRY
;J IS DL-10 MAP ADDRESS
;S IS DEVIOS
;F IS DEVICE LATCH BLOCK ADDRESS
;INTERFACES WITH OUTSIDE MODULES:
;1 SET DL-10 POINTER SDLPT2
; POINTER VALUE PASSED IN T2
; PDP-11 VALUE OF POINTER RETURNED IN T1
;T3 IS ASSUMED NOT TO BE DESTROYED:
;2 PDP-11 NUMBER IS SUPPOSED TO BE IN PDVSTA BYTE FIELD
;3 PUNIT IS ASSUMED TO CONTAIN DEVICE LINE NUMBER RELATIVE TO NTT
;NOTE: WILL THERE BE A FRONT END TABLE IN DL10 MAP
;	TERMINALS, PA611R ---- SUB (TOL])?
;4 DLXBAT ADDRESSED BY PDP-11 NUMBER GIVES THE DL10 MAP ADDRESS
;5 PUTMSG	J= MAP ADDRESS
;		T1= -N,,MESSAGE AREA
;6 HOW TO MAP CONTENT LINE TO DDB ADDRESS??
;NOTE:	CATCH DELAY PROBLEM IN RELEASE INIT SEQUENCE IN INI
;	BY SETTING INISYNC AND IOACT

;OPCODES SHIPPED TO THE PDP-10

DEVINI==20			;INITIALIZE A DEVICE
DEVREL==22			;RELEASE A DEVICE
DATREQ==24			;SIGNAL PRESENCE OF A BUFFER:
STSREQ==26			;SHIP STATUS

;STATUS BITS TRANSFERRED BY THE PDP-10 TO THE PDP-11 WITH STSREQ

SETEOF==40			;CLOSE DOWN OUTPUT:
SETBYT==2			;SET BYTE SIZE
SETSTA==1			;SET START:
SETDIA==20			;SET DIAGNOSTIC MODE FOR LINE

;STATUS BITS TRANSFERRED FROM THE PDP-11

EOFFLG==1			;END OF FILE FLAG SEEN
DIASTS==20			;ERROR DETECTED AT PDP-11 INTERRUPT LEVEL
				; FOR A DIAGNOSTIC LINE
DIAEXC==40			;ERROR DETECTED AT PDP-11 EXEC LEVEL
				; FOR A DIAGNOSTIC LINE
BADSTS==74			;ERROR BITS

;IOS BITS SPECIFIC FOR FRONT END DEVICES SERVICED BY THIS MODULE

WTRELB==400000			;WAITING FOR RELEASE CONFIRMATION, THIS
				;BIT WHEN SET CAUSES ALL OTHER QUEUE ENTRIES
				;TO BE IGNORED.
;BITS  1,2,3,4,5,6 ARE USED TO STORE THE BYTE SIZE LAST USED FOR THE DEVICE
	PAGE
;ENTRY DEFINITIONS
;TYIDSP AND TYODSP ARE  USED BY UUOCON TO DISPATCH TO THE
;DEVICE DEPENDENT PART OF THE I/O OPERATORS


	ENTRY	TYIDSP		;INPUT DEVICE DISPATCH TABLE
	ENTRY	TYODSP		;OUTPUT DEVICE DISPATCH TABLE

;DISPATCH TABLES


;TABLE FOR INPUT DEVICES

	POPJ	P,		;SPECIAL ERROR STATUS
	JRST	CHK11		;COMPUTE BUFFER SIZE
	POPJ	P,		;DO NOT DISTURB THE PDP-11
	JRST	TYPREL		;HUNG DEVICE
TYIDSP::JRST	TYPREL		;RELEASE THE DEVICE
	JRST	ILLOUT##	;OUTPUT CLOSE IS ILLEGAL
	JRST	ILLOUT##	;NO OUTPUT OPERATOR
	JRST	TYPINP		;DO INPUT


;OUTPUT DISPATCH TABLE

	JRST	CHK11		;NORMAL BUFFER SIZE
	POPJ	P,		;DO NO DISTURB THE PDP-11
	JRST	TYPREL		;HUNG DEVICE
TYODSP::JRST	TYPREL		;RELEASE THE DEIVICE
	JRST	TYPCLS		;CLOSE OUTPUT SMOOTHLY
	JRST	TYPOUT		;DO OUTPUT
	JRST	ILLINP##	;NO INPUT
	PAGE
;TYPCLS CLOSES OUTPUT IN AN ORDERLY FASHION, THE CLOSE DOWN IS
;EITHER REQUESTED BY THE RELEASE OR THE CLOSE PROCESSOR
;IT ISSUES A SETEOF STATUS REQUEST
;NOTE THAT IT DOES NOT CALL SETACT, BUT RAISES THE WTCLSB BIT,
;THIS DOES NOT TIE THE JOB IN CORE
;THE BIT CAN BE CLEARED BY:
;1 RECEIVING	EOF STATUS FOR THE LINE FROM THE PDP-11
;2 RECEIVING	RELBUF DUE TO A RELEASE CALL, IN THIS
;		CASE THE PDP-11 WILL SYNCHROMIZE:
TYPCLS:	PUSHJ	P,CHKUP		;CHECK IF PDP-11 IS UP
	POPJ	P,		;NO, OPERATOR IS DONE
	PUSHJ	P,OUT##		;OUTPUT LAST BUFFERS
	PUSHJ	P,WAIT1##	; AND WAIT TILL DONE
	MOVEI	T3,SETEOF	;SEND SET EOF WAIT:
CHK000:
;	PJRST	P,SNDSTS	;SEND IT AND WAIT:
	IF2	<
	IFN	<CHK000-SNDSTS>,<
	PRINTX	DO NOT INSERT INSTRUCTIONS AFTER TYPCLS BEFORE SNDSTS
>	;END OF IFN
>	;END OF IF2 STATEMENT
	PAGE

;SNDSTS IS CALLED WITH THE FOLLOWING PARAMETERS:
;.T3= BIT PATTERN TO SET THE PDP-11 STATUS
;.T4= ADDITIONAL DATA:

SNDSTS:	PUSHJ	P,MAPLIN	;MAP LINE INTO T2
	MOVEI	T2,<STSREQ>B27(T2)	;SET STATUS REQUEST.
	MOVE	T1,[-3,,T2]	;MESSAGE AREA T2,T3,T4.
	PJRST	PUTMSG##
	PAGE

;TYPREL CAN BE CALLED WHEN:
;1 AFTER A RELEASE OR CLOSE UUO CLOSED THE OUTPUT SIDE
;2 DUE TO A CALL BY THE RESET UUO.
;IN CASE 1 ALL I/O WAS CLOSED DOWN ORDERLY DUE TO THE
;SETACT CALL FOLLOWED BY THE WAIT1 CALL
;IN CASE 2 THE DEVICE WILL BE CLOSED DOWN IGNORING ANY PENDING REQUESTS.
;HOWEVER THERE MAY BE REQUESTS IN THE TO10 DELAY LINE, THIS CODE
;WILL SET THE WIRELB,WHICH WILL CAUSE ALL QUEUE ENTRIES FOR THIS LINE
;TO BE IGNORED UNTIL THE BUFREL IS TRUE STATUS IS TRANSMITTED VIA
;THE QUEUE OR AN EOF STATUS WHEN THE WTCLSB BIT IS SET.

TYPREL:	PUSHJ	P,CHKUP		;IS PDP-11 UP
	POPJ	P,		;NO OPERATOR IS DONE
	PUSHJ	P,MAPLIN	;MAP LINE INTO T2
	MOVEI	T2,<DEVREL>B27(T2)	;RELEASE THE DEVICE
	MOVSI	S,WTRELB	;SET WAIT BIT:
	IORM	S,DEVIOS(F)	;SET THE FLAG BEFORE
	MOVE	T1,[-1,,T2]	;THE TASK IS QUEUED.
	PUSHJ	P,PUTMSG##	;IN THE TO PDP-11 QUEUE.
	POPJ	P,
	PAGE
;TYPINP AND TYPOUT SERVICE ALL INPUT AND OUTPUT FOR BUFFERED
;LOCAL PDP-11 FRONT END DEVICES.
;THE DEVICES CAN BE RUN IN 2 MODES:
;1  MPX MODE.  .TY MPX BIT IN DEVTYP DDB ENTRY IS ON.
;2  NOW MPX MODE.  .TYMPX IS OFF:
;THE DIFFERENCE BETWEEN BOTH CASES IS THE FACT, THAT IN MPX MODE
;THE FIRST BUFFER WORD (THIRD OF BUFFER HEADER) SHOULD CONTAIN THE EXACT
;BYTE COUNT.  IN NOW MPX MODE A WORD COUNT IS STORED HERE.
;IN THE INPACT CASE THE WORD SHOULD BE DERIVED FROM THE BUFFER HEADER
;AS THE USER COULD BUILD HIS OWN BUFFER STRUCTURE (WHICH CAN BE
;DISADVANTAGEOUS FOR FRONT END DEVICES AS BIG BUFFERS WOULD NEED.
;SERVERAL COPY PASSES BY THE PDP-11).
;WITH THE EXCEPTION OF THE WORD COUNT LOGIC ALL OPERATIONS NEEDED
;FOR I/O ARE SIMILAR.  THIS FACT HAS BEEN USED BY INITIALIZING
;AN INPUT OPERATOR AND OUTPUT OPERATOR WITH THE LOADING OF THE
;PARAMETER SET CODE ADDRESS IN REGISTER U. AND CONFIRMING THEREAFTER
;WITH THE COMMON CODE IN TYPCOM
;LOGIC:
;    U _ 'IF' INPUT 'THEM' INPCNT 'ELSE' OUTCNT;    
;    T1 _ NUMBER OF BYTES PER PDP-10 WORD:
;    CALL  .U  ;    'COMMENT'	T2 _ BUFFER WORD COUNT;    
;			T3 _ BUFFER BYTE COUNT;
;			T4 _ ABSOLUTE BUFFER ADDRES 2;
;T2 _.ROT (.ROT(.T2, & 377,-8),-6)+.T4+2	;'COMMENT' DL-10 POINTER
;    T4 _ .SET DL-10 POINTER;
;    SEND11 <DATREG, LINE, .T3, .T4);
;    CALL SETACT:
	PAGE
TYPINP:	MOVEI	U,INPCNT	;IN PUT PARAMETER SET UP:
	PJRST	TYPCOM		;GO TO COMMON CODE:

TYPOUT:	MOVEI	U,OUTCNT	;OUTPUT PARAMETER SET UP
;	PJRST	TYPCOM		;FALL INTO COMMON CODE:

TYPCOM:	TLNN	S,IOEND		;CALLED FROM INTERRUPT LEVEL WITH
	TRNE	S,740000	; EOF OR ERROR BITS ON?
	POPJ	P,		;THEN IGNORE CALL
	TLZE	S,IOBEG		;IS THIS THE FIRST CALL??
	PUSHJ	P,TYPINI	;AND INIT DEVICE
IFN FTKL10,<
	PUSHJ	P,CSDMP##	;VALIDATE CORE
>
	LDB	T4,OLDBSZ	;GET THE BYTE SIZE FOR THE DEVICE
	MOVEI	T1,^D36		;COMPUTE NUMBER OF BYTES PER WORD
	IDIV	T1,T4		;AND LEAVE THE RESULT IN T1 TO
	PUSHJ	P,(U)		;ENABLE PARAMETER SET UP:
	JUMPE	T3,ADVBUF(U)	;IGNORE BUFFERS WITH ZERO BYTES
;	PJRST	STRT11		;START UP THE PDP-11
	PAGE
	COMMENT	&

THE DL-10 INTERFACE CAN TRANSFER UP TO ONLY 256 DECIMAL WORDS
PER NON IMMEDIATE BYTE POINTER.IN ADDITION TO THIS THE DATA
ADDRESSES HAVE TO BE CONTAINED IN A SINGLE PHYSICAL PAGE
PER BYTE POINTER.BOTH RESTRAINTS MAKE COMMON SOLUTION
POSSIBLE:
1 TRANSFER THE MINIMUM OF THE FOLLOWING QUANTITIES:	.1 THE REMAINDER OF THE PHYSICAL PAGE IN WORDS FROMT THE
	   CURRENT BUFFER POSITION
	.2 256 DECIMAL
	.3 THE REMAININGPNUMBER OF WORDS TO BE TRANSFERRED
2 UPDATE NUMBER OF REMAINING WORDS, REMAING BYTES ANDNEXT BUFFER ADDRESS
	THE	TRANSFER PARAMETERS ARE STORED IN THE DDB.
1.  A THE RIGHT HALF OF ENTRY DEVEXT IS THE CURRENT BUFFER ADDRESS
2.  L THE LEFT HALF OF ENTRY DEVEXT IS THE NUMBER OF WORDS STILL TO
	BE	TRANSFERRED 
3.  B THE ENTRY DEVPPN THE NUMBER OF BYTES STILL TO BE TRANSFERRED

THE INITIAL PARAMETER SET UP IS DONE BY THE I/O OPERATOR

THE SETACT ROUTINE WILL RESET THE HUNGTIME,IN THIS WAY THE LONG BUFFERS
HAVE VERY LONG HUNG TIMES

	&		;END OF COMMENT
	PAGE
STRT11:	TRO	S,IOACT
	LDB	T3,OLDBSZ	;GET BYTE SIZE OF THE BUFFER
	MOVEI	T1,^D36		;AND COMPUTE BUFFER LENGTH
	IDIV	T1,T3		;#OF BYTES PER WORD
	HRRZ	T3,DEVEXT(F)	;GET TLE START ADDRESS OF THE XFER
	ANDI	T3,377		;GET OFFSET IN CURRENT HALF PAGE
	MOVEI	T2,400		;LENGHTH OF A HALF PAGE
	SUB	T2,T3		;SO THIS NUMBER OF WORDS REMAINS IN PAGE
	HLRZ	T3,DEVEXT(F)	;THIS MANY STILL HAVE TO GO
	CAMLE	T2,T3		;IS .R>.L ALL IN ONE PASS?
	MOVE	T2,T3		;CERTAINLY
	SUB	T3,T2		;AMOUNT FOR NEXT TRANSFER
	HRLM	T3,DEVEXT(F)	;SAVE IT IN DDB
	HRRZ	T4,DEVEXT(F)	;GET START OF DATA
	ADDM	T2,DEVEXT(F)	;NEXT STARTING ADDRESS
	MOVE	T3,T2		;THIS MUCH WORDS GO
	IMUL	T3,T1		;AND THIS MUCH BYTES ARE IN IT
	CAMLE	T3,DEVPPN(F)	;IS THIS MORE THAN REMAINDER?
	MOVE	T3,DEVPPN(F)	;YES THEN DO ONLY REMAINDER
	SUBM	T3,DEVPPN(F)	;UPDATE BYTE REMAINDER
	MOVNS	DEVPPN(F)	;AND MAKE IT POSITIVE
	MOVNS	T2		;T2 IS NUMBER OF BUFFR WORDS
	ANDI	T2,377		;CONVERTED TO DL10 WORD COUNT FORMAT
	ROT	T2,-^D8		;MAKE FIRST TO BUILD DL-10 POINTER
	CAIN	T1,1		;36 BITS IS IMAGE
	MOVEI	T1,3		;WHICH HAS TO BYTES PER WORD
	IORI	T1,70		;MAKE P FIELD -1 SO INCREMENT GENERATES 0
	ADD	T2,T1		;NEXT ADD P=0 AND S FIELD
	ROT	T2,-6		;AND MOVE ALL THREE FIELDS TO THE RIGHT
	MAP	T1,(T4)		;GET PAGE ADDRESS _F EXEC
	LSH	T1,^D9		;SHIFT IT TO ADD IN OFFSET
	ANDI	T4,777		;GET PAGE OFFSET
	IORI	T4,(T1)		;AND ADD EXEC PAGE

	ADD	T2,T4		;PLACE AND ADD ABSOLUTE!!
	PUSH	P,T2		;SAVE THE DL10 POINTER
	PUSHJ	P,MAPLIN	;GET COMTEX LINE # AND MAP ADDRESS
	MOVE	T4,PIO(J)	;GET ADDRESS OF BYTEPOINTER POOL
	ADD	T4,T2		;ADD UP LINE NUMBER
	SUB	T4,NTT(J)	;BU MINUS DC76 LINES
	POP	P,(T4)		;AND SET THE POINTER
	SUB	T4,J		;TRANSLATE ADDRESS FOR PDP-11
	MOVEI	T2,<DATREQ>B27(T2)	;TO GIVE CONTEN LINE + FUNCTION
	MOVE	T1,[-3,,T2]	;PREPARE THE QUEING.
	IORM	S,DEVIOS(F)	;SET NEEDED BITS
	PUSHJ	P,PUTMSG##	;OF THE MESSAGE TO THE PDP-11
	PJRST	SETHNG##	;AND TELL THE SYSTEM THAT DEVICE IS ACTIVE
	;TYPINI INITIALIZE A DEVICE, THIS MUST BE SUCCESSFUL
;IF IT IS NOT THEN THE SOFTWARE SYSTEM IS LEAKING OR THE DL-10 NEEDS A NEW MODULE.
;SO TRY IT:

TYPINI:	PUSHJ	P,GBYTSZ	;GET THE USER'S BYTE SIZE T4
	LDB	T2,PIOMOD##	;WHAT MODE IS USED??
	CAIE	T2,PIMMOD	;IF PIM THEN VERIFY BYTE SIZE
	JRST	BYTOKA		;ELSE BYTE IS OKAY
	MOVE	T2,[ POINT 5,BYTTAB]	;GET TABLE WITH VALID BYTE SIZES
BYTVER:	ILDB	T3,T2		;GET A BYTE SIZE
	JUMPE	T3,ILLBYT##	;ILLEGAL BYTE SIZE
	CAME	T3,T4		;EQUAL TO ONE GIVEN
	JRST	BYTVER		;NO GO ON VERIFYING
BYTOKA:	DPB	T4,OLDBSZ	;DTORE THE BYTE SIZE USED
	PUSHJ	P,MAPLIN	;MAP F TO A LINE NUMBER IN T2 AND SET]
	CAML	T2,MAX(J)
	PJRST	UNAVLT##
	MOVEI	T2,<DEVINI>B27(T2)	;GET COMMAND
	MOVE	T1,[-1,,T2]	;ONE WORD GOES
	MOVEI	S,IOACT		;AND FLAG DEVICE ACTIVE
	IORM	S,DEVIOS(F)	;BY SETTING FLAG IN CORE BEFORE PUTTING REQUEST
	PUSHJ	P,PUTMSG##	;TELL PDP-11 INIT REQUEST
	PUSHJ	P,WSYNC##	;WAIT FOR PDP-11
;RETURN HERE WHEN INIT FINISHED ON THE PDP-11
	LDB	T2,PBYTE	;GET INIT STATUS
	CAIG	T2,INIPDL-INIDSP
	POP	P,T1
	PJRST	@INIDSP(T2)	;DISPATCH TO ALL SPECIAL CASES

;READY IS CALLED WHEN THE INIT OPERATION EAS SUCCESFULL

READY:	LDB	T4,OLDBSZ	;GET BYTE SIZE TO BE USED
	MOVEI	T3,SETBYT	;AND GET SET BYTE SIZE CODE
	MOVE	S,[IOBEG,,IOACT]	;BITS WHICH HAVE TO BE ZEROED
	ANDCAB	S,DEVIOS(F)	;ZAP THAT'S IT
	TRNE	S,IONRCK	;DIAGNOSING THE LINE?
	TRO	T3,SETDIA	;(YES) TELL IT THE PDP-11
	PUSHJ	P,SNDSTS	;AND SET IT TO THE 11
	LDB	T4,OLDBSZ	;GET THE BYTE SIZE AGAIN
	POPJ	P,
OFFLIN:	PUSHJ	P,HNGSTP##	;ASK OPERATOR TO HELP USER
	JRST	TYPINI		;AND MAKE A RETRY

INIDSP:	CMTERR##		;COMTEX ACCOUNTING HAS A HOLE
INIPDL:	UNAVLT##		;DEVICE IS UNAVAILABLE
	OFFLIN			;DEVICE IS OFFLIN
	READY		;IOGO ALL IS SET UP NOW
INIMAX=.-INIDSP		;CHECK FOR LEGAL CODES

;BYTE SIZE VERIFICATION TABLE

BYTTAB:	BYTE(5)	6,7,^D8,^D12,^D16,0	;ZERO TERMINATES TABLE
OLDBSZ:	POINT	6,DEVIOS(F),6	;FIELD RESERVED FOR OLD BYTE SIZE
	PAGE
;THE NEXT PAGE CONTAINS CODE , WHICH DIFFERS BETWEEN INPUT 
;AND OUTPUT.THIS CODE IS CALLED DURING TYPCOM EXECUTION
;THERE ARE 3 SPECIAL CASES:
;0 CODE TO IGNORE BUFFERS FOR BUFFERS WITH A ZERO BYTE COUNT
;1 FIND ADDRES OF A BUFFER HEADER
;2 COMPUTE BYTE AND WORD COUNT FOR A USER FUFFER
;THE SPECIAL CASES ARE ADDRESSED BY MEANS OF BASE REGISTER U.
;CASE 0 IS AT OFFSET ADVBUF
;CASE 1 IS AT OFFSET BFHADR AND CASE2 AT OFFSET 0
;NOTE: THE OFFSET DEFINITIONS ARE MADE SUCH THAT THE OFFSETS ARE KNOWN ON PASS 2
;OUTCNT AND INCNT COMPUTE THE NUMBER OF :
;BYTES IN A TRANSFER (RESULT IS IN T3)
;WORDS NEEDED TO STORE THE BYTES (RESULT IN T2)

DUM1:	PUSHJ	P,ADVBFE##	;GET NEXT OUTPUT BUFFER
	PJRST	CLRACT##	;NO EXIT THEN
	PJRST	TYPOUT		;DO NEXT BUFFER
DUM2:	HLRZ	T3,DEVBUF(F)	;GET OBUF ADDRESS
OUTCNT:
;DEFINE OFFSETS SUCH THAT PASS 2 KNOWS THEM

ADVBUF=DUM1-OUTCNT		;OFFSET OF BUFFER ADVANCE CODE
BFHADR=DUM2-OUTCNT		;OFFSET OF PROPER BUFFER HEADER
	MOVSI	S,IO		;FLAG THAT JOB IS DOING OUTPUT
	MOVEI	T4,@DEVOAD(F)	;ADDRESS OF SECOND BUFFER WORD
	MOVE	T2,1(T4)	;GET NUMBER OF BYTES
	LDB	T3,PIOMOD##	;GET I/O M_DE
	CAIE	T3,PIMMOD	;PACKED IMAGE MODE
	JRST	NONPMO		;NO NON PIM MODE
	IDIV	T2,T1		;/NUMBER OF BYTES PER WORD (T3 
	SKIPE	T3		;IS THERE A REMAINDER??
	AOS	T2		;YES, ONE WORD MORE!!
	MOVE	T3,1(T4)	;NUMBER OF BYTES:
	PJRST	SETDDB		;BUILD THE CORRECT DDB 


NONPMO:	MOVEI	T1,5		;5 BYTES PER WORD FOR ASCII
	CAILE	T3,AL		;ASCII MODE=0,1
	MOVEI	T1,1		;PDP11 WILL DO GOOD THINGS
	MOVE	T3,1(T4)	;GET THE NUMBER OF WORDS
	MOVE	T2,T3		; AND COPY THEM
	IMUL	T3,T1		;GET NUMBER OF BYTES
	PJRST	SETDDB		;FINISH THE DDB
	IF2	<
	IFN	<ADVBUF-.+INPCNT>,<
	PRINTX	ADVBFF## MUST BE AT DISTANCE ADVBUF FROM LABEL INPCNT
>>	;END OF IFN END OF IF2
	PUSHJ	P,ADVBFF##	;GET NEXT INPUT BUFFER
	PJRST	CLRACT##	;CLEAR THE ACTIVITY FLAG
	PJRST	TYPINP		;DO NEXT BUFFER

	IF2	<
	IFN	<BFHADR-.+INPCNT>,<
	PRINTX	ERROR HRRZ INSTRUCTION MUST BE AT OFFSET BFHADR FROM INPCNT
#$%&''()-:098	I	ERROR TO STOP BATCH
>	;END OF IFN
>	;END OF IF2
	HRRZ	T3,DEVBUF(F)	;GET IBUF ADDRESS
INPCNT:	SETZM	S		;FLAG THAT INPUT IS BEING DONE
	MOVEI	T4,@DEVIAD(F)	;ADDRESS OF SECOND BUFFER WORD
	HLRZ	T2,(T4)		;NUMBER OF WORDS PER BUFFER.
	TRZ	T2,400000	;CLEAR THE IOUSE BIT:
	SUBI	T2,1		;DO NOT USE BYTE COUNT WORD
	LDB	T3,PIOMOD##	;GET DATA MODE
	CAIE	T3,PIMMOD	;PACKED IMAGE MODE
	PJRST	NONPMI		;NON PIM INPUT
	MOVE	T3,T2		;NUMBER OF WORDS
	IMUL	T3,T1		;TIMES # OF BYTES PER WORD=#OF BYTES PER BYTE
	MOVEM	T3,1(T4)	;SET BYTE COUNT FOR USER
	PJRST	SETDDB		;FINISH THE DDB
NONPMI:	MOVEM	T2,1(T4)	;NUMBER OF WORDS
	MOVEI	T1,5		;5 BYTES PER WORD FOR ASCII
	CAILE	T3,AL		;IS IT ASCII
	MOVEI	T1,1		;NO ONLY ONE PER WORD
	IMUL	T1,T2		;GET NUMBER OF B2TES
	MOVE	T3,T1		;COPY IT TO RIGHT ACCU

SETDDB:	HRLM	T2,DEVEXT(F)	;STORE THE NUMBER OF WORDS
	MOVEM	T3,DEVPPN(F)	;AND THE NUMBER OF BYTES
	ADDI	T4,2		;SKIP BUFFER HEADER PART
	HRRM	T4,DEVEXT(F)	;AND STORE THE DATA ADDRESS
	POPJ	P,
	PAGE

;CHKUP IS USED WHEN MESSAGES HAVE TO BE SENT FROM UUO LEVEL
;TO THE PDP-11. WHEN THE PDP-11 IS DOWN AN NORMAL RETURN IS GIVEN
;ELSEWHISE A SKIP RETURN IS GIVEN. OTHER LEVELS CAUSE A HUNG DEVI
;STATUS, WHICH BY CALLING THE RELEASE OPERATOR WILL CAUSE THE
;IOACT STATUS TO BE CLEARED
CHKUP:	PUSHJ	P,MAPLIN	;GET LINE DATA
	SKIPLE	DWN(J)		;IS PDP-11 NOT RUNNING
	JRST	CPOPJ1##	;NO GIVE RUN RETURN
	MOVE	S,[WTRELB,,IOACT]	;IMPORTANT BITS
	ANDCAM	S,DEVIOS(F)	;WHICH SHOULD BE CLEARED
	POPJ	P,

;CHK11 IS CALLED FROM THE INIT UUO TO CHECK IF THE DC44
;IS RUNNING.  WHEN IT IS CALLED THE ASSPRG BIT HAS
;BEEN SET IN DEVMOD.  THIS BIT WILL BE CLEARED TO PREVENT
;FAILURE OF DVASRC FOR (E.G.) PAP DEVICE

CHK11:	PUSHJ	P,CHKUP		;IS PDP-11 RUNNING
	SKIPA			;(NO)ABOUT INIT
	PJRST	REGSIZ##	;REGULAR METHOD
	MOVEI	T1,ASSPRG	;CRITICAL BIT
	ANDCAB	T1,DEVMOD(F)	;SO GENERIC SEARCH FINDS IT
	SETZ	T2,		;ZERO JOV NUMBER
	TRNN	T1,ASSCON	;IF ONLY ASSIGNED BY PROGRAM
	DPB	T2,PJOBN##	;RELEASE THE DEVICE
	PJRST	DWND44##	;COMPLAIN


;MAPLIN LOADS REGISTER T=J WITH THE BASE ADDRESS OF THE DL-10 MAP
;AND LOADS THE COMTEX LINE NUMBER IN T2

MAPLIN:	LDB	T2,PBYTE1	;LOAD THE MAP NUMBER
	MOVE	J,@DLXBAT##(T2)	;GET DL10 MAP ADDRESS:
	HRRZ	T2,DEVFIL(F)	;GET COMTEX LINE NUMBER
	ADD	T2,NTT(J)	;CHANGE TO COMTEX LINE NUMBER
	POPJ	P,		;AND RETURN:

;BUFFER HEADER

GBYTSZ:	XCT	BFHADR(U)	;GET THE RIGHT ADDRESS
	ADDI	T3,1		;POINT TO POINTER
	EXCTUX	<MOVE T3,@T3>	;GET USER'S BYTE SIZE
	LDB	T4,PBYTSZ	;GET BYT SIZE
	POPJ	P,

	PAGE

;D76INT CALLS ROUTINES OUT THE FOLLOWING PAGES WHEN A
;DL-10 QUEUE ENTRY FOR THIS SERVICE WAS DISCOVERED:
;WHEN CALLED:
;U  CONTAIN S THE LINE INDEX FOR LINTAB
;H  ADDRESS OF DL-10 MAP:

;DATDON IS CALLED WHEN A LINE HAS FINISHED A DATA TRANSFER:
;INTO A PDP-10 INPUT BUFFER.  IN ADDITION TO THE DONE MESSAGE
;A MESSAGE COUNT IS TRANSMITTED.  THERE ARE 2 POSSIBILITIES:
;1.  THE MESSAGE COUNT IS EQUAL TO THE AMOUNT REQUESTED:
;2.  THE AMOUNTS DIFFER, WHICH MEASN ERRORS ON EOF
;CASE 2 HOWEVER MANIFESTS IT SELF IN A SPERATE QUEUE MESSAGE, WHICH
;WILL SIMPLIFY COMMAND DECODING:
DATDON:: PUSHJ	P,SETUP3	;INITIALIZE S,F AND DATA WORD
	POPJ	P,		;IGNORE THIS
	MOVSI	T2,DVIN		;CAN DEVICE DO INPUT??
	TDNN	T2,DEVMOD(F)	;IF NOT THEN
	POPJ	P,		;EXIT AND FORGET MESSAGE
	MOVEI	T2,@DEVIAD(F)	;GET BUFFER ADDRESS
	JUMPE	T1,DATDO0	;ALL IS FINE NO PROBLEMS
;AS DC44 BUFFERS ARE PAGED DURING TRANSFERS THE NUMBER OF
;BYTES NOT TRANSFERRED HAS TO BE INCREASED WITH THE NUMBER
;OF BYTES REMAING IN THE LAST BUFFER PAGES .DEVPPN(F)
	PUSHJ	P,STATUS	;ANALIZE
	ADDM	T3,DEVPPN(F)	;GET THE BALANCE
	PUSHJ	P,CHKPIM##	;CHECK IF PIM MODE
	JRST	DATDO1		;THEN ALL IS OKAY
	MOVEI	T3,^D36		;AND GET # OF BYTES PER WORD
	LDB	T4,OLDBSZ	;GET THE BYTE SIZE
	IDIV	T3,T4		;NOTE NO ROUNDING NOW
	MOVE	T4,T3		;GET IN CORRECT ACCU
	MOVE	T3,DEVPPN(F)	;GET THE REST
	IDIV	T3,T4		;AND GET REMAINDER
DATDO1:	SUBM	T3,1(T2)	;THAT'S ALL YOU GOT
	MOVNS	1(T2)		;BUT PASS THE RIGHT AMOUNT
	TLO	S,IOEND		;FLAG THE END OF FILE
DATDO0:	PUSHJ	P,CHKPAG	;CHECK IF MORE PAGES HAVE TO GO
	PJRST	STOIOS##	;WAIT TILL ALL PAGES ARE TRANSFERRED
IFN FTKL10,<
	PUSHJ	P,CSDMP##	;VALIDATE CORE
>
	PUSHJ	P,MAKRUN	;THEN MAKE HIM RUNNABLE AGAIN
	PUSHJ	P,ADVBFF##	;AND SEE IF THERE ARE MORE BUFFERS
	PJRST	STOIOS##	;NO, UPDATE DEVIOS
	MOVEM	S,DEVIOS(F)	;STORE UPDATED IOS.
	PJRST	TYPINP		;YES, MAKE AN INPUT OPERATION AND

	PAGE

;SETUP3,SETUP2 AND SETUP1 ARE ROUTINES CALLED WHEN RESPECTIVELY:
;3,2,1 WORDS WERE STORED IN THE PDP-11 TO PDP-10 QUEUE FOR THE CALLING
;COMMAND.CALLING THE SETUP ROUTINE SPECIFIC FOR A COMMAND GUARANTEES THE INTEGRITY
;OF THE QUEUE.
;QUEUE ENTRIES RETURNED:
;1 SETUP1 NONE
;2 SETUP2 IN T1
;3 SETUP3 ARGUMENT1 IN T3,ARGUMENT 2 IN T1
;ALL ROUTINES GIVE 2 RETURNS:
;NORMAL RETURN IGNORE ALL QUEUE ENTRIES UNTIL A DEVICE RELEASE SUCCEEDS
;		FOR THE ASSOCIATED LINE
;SKIP RETURN	PROCES QUEUE ENTRY
;IN ADDITION THE FOLLOWING REGISTERS WILL BE SETUP:
;S CONTAINS DEVIOS OF DDB
;F DDB ADDRESS OF LINE

SETUP3:	PUSHJ	P,GTMSGH##	;GET FIRST OPERAND
	PUSH	P,T1		;AND SAVE IT
	PUSHJ	P,SETUP2	;TAKE NOW THE SECOND ARGUMENT IN T1
	JRST	TPOPJ##		;IGNORE THE ENTRY EXET
	POP	P,T3		;GET THE FIRST ARGUMENT
	JRST	CPOPJ1##	;AND ALL IS OKAY

SETUP2:	PUSHJ	P,GTMSGH##	;GET THE QUEUE ENTRY IN T1
;	PJRST	SETUP1		;DO COMMON THINGS
	IF2	<
	IFN	<.-SETUP1>,<
	PRINTX	DO NOT INSERT CODE BETWEEN SETUP2 AND SETUP1
	PJRST	SETUP1		;GENERATE A PHASE ERROR
>	;END OF IFN CONDITION
>	;END OF IF2 CONDITION



SETUP1:	SUB	U,LTO(J)	;REDUCE U TO OUR WORLD
	CAMG	U,MAX(J)	;IS LINE NUMBER VALID??
	JRST	LINEOK		;YES IT IS OKAY
	AOS	TRBLE		;INCREASE TROUBLE COUNTER
	POPJ	P,		;IGNORE UNAVAILABLE
LINEOK:	SUB	U,NTT(J)	;GET PDP DDB INDEX
	MOVE	F,DC40TB##(U)	;GET DDB ADDRESS BUILT BY LINKSR!!!
	MOVE	S,DEVIOS(F)	;GET IOS BITS.
	TLNE	S,WTRELB	;IS RELEASE PENDING?
	POPJ	P,		;YES IGNORE ALL UNTIL RELEASE OAKY
	PJRST	CPOPJ1##
	PAGE

;DATREL IS RECEIVED IN RESPONSE TO A DEVICE RELEASE REQUEST.
;ITS TASK IS TO QUARANTEE, THAT THE T010 QUEUER IS OPENED AGAIN FOR
;TRAFFIC FOR THE DEVICE CONSERVED:

DATREL::PUSHJ	P,SETUP2	;IGNORE, IGNORE STATUS:
	TLZN	S,WTRELB	;ARE WE WAITING YES!!!
	JRST	FAILRL##	;NO SHOULD BE SO!!!
	JUMPE	T1,FAILRL##	;THE RELEASE FAILED
	PJRST	STOIOS##	;ALL IS OKAY
	PAGE

;TYPSTS IS CALLED WHEN STATUS INFORMATION FROM THE PDP-11
;THE FOLLOWING STATUS CAN BE PASSED:
;1  DEVICE ERROR (ACCOMPLANIED BY EOF)
;2  EOF FLAG CONFIRMS POSSIBLE CLOSE OUTPUT:
;3  OUTPUT FINISHED:
;NO OTHER STATUS TRANSFERS

TYPSTS::PUSHJ	P,SETUP2	;SET UP STANDARD DATA:
	POPJ	P,		;IGNORING ALL DATA FOR THIS LINE
	TRZE	T1,EOFFLG	;IF END OF FILE NOT SEEN THEN
	TLO	S,IOEND		;AND USER SHOULD KNOW IT FOR INPUT
	TRZE	T1,BADSTS	;ANY ERRORS SEEN
	TRO	S,IODERR	;YES FLAG THEM
MAKRUN:	TRZ	S,IOACT		;ALL CALLERS RESET IT
	PUSHJ	P,SETIOD##	;MAKE HIM RUNNABLE
	PJRST	STOIOS##	;NO GO AND STORE UPDATED IOS
	PAGE

;DATCOP IS CALLED WHEN AN OUTPUT BUFFER HAS BEEN TRANSMITTED
;TO THE ADDRESSED DEVICE . IN T1 WILL BE THE TRANSFER STATUS AFTER
;THE SETUP3 CALL AND IN T1 WILL BE THE NUMBER OF UNTRANSFERRED BYTES

DATCOP::	PUSHJ	P,SETUP3	;SET UP FOR 3 WORDS MESSAGE
	POPJ	P,		;IGNORING ALL QUEUE ENTRIES FOR LINE
	JUMPE	T1,DATCO0	;ALL WENT
	PUSHJ	P,STATUS	;ANALIZE ERROR STATUS
DATCO0:	PUSHJ	P,CHKPAG	;CHECK FOR MORE PAGES
	PJRST	STOIOS##	;WAIT TILL ALL PAGES WENT
	PUSHJ	P,MAKRUN	;MAKE JOB RUNNABLE AGAIN
	PUSHJ	P,ADVBFE##	;ARE THERE MORE BUFFERS
	PJRST	STOIOS##	;NO FORGET IT
	MOVEM	S,DEVIOS(F)	;UPDATE IOS E.G. IOW ZERO!!
	PJRST	TYPOUT		;AND OUTPUT NEXT BUFFER

;CHKPAG CHECK IF MORE PAGES HAVE TO GO T1 CONTAINS
;TRANSFER STAUS ON ENTRY IGNORE REST OF PAGES FOR
;DEVICES WITH ERRORS

CHKPAG:	JUMPN	T1,CPOPJ1##	;IGNORE ERRORS
	HLRZ	T1,DEVEXT(F)	;RESTING BUFFER LENGTH
	JUMPE	T1,CPOPJ1##	;ALL DONE FOR THIS BUFFER
	PJRST	STRT11		;RESTART PDP-11

;STATUS IS CALLED WITH THE PDP-11 ERROR STATUS
;IN REGISTER T1
;DIASTS MEANS A LINE IN 100(IORRCK) DETECTED
;AN ERROR AT INTERRUPT LEVEL SETS IODTER
;DIAEXC MEANS A LINE IN IONRCK MODE DETECTED
;AN ERROR AT EXEC LEVEL SETS IOBKTL
;IODERR IS SET ALWAYS:

STATUS:	TRNE	T1,DIASTS	;INTERRUPT LEVEL?
	TRO	S,IODTER	;(YES) TELL IT THE USER
	TRNE	T1,DIAEXC	;EXEC LEVEL?
	TRO	S,IOBKTL	;(YES) FLAG IT
	TRNE	T1,BADSTS	;ANY ERRORS?
	TRO	S,IODERR	;SET ALWAYS
	POPJ	P,		;RETURN
INITRT::	PUSHJ	P,SETUP2	;GET INIT STATUS
	POPJ	P,		;ILLEGAL LEGAL LINE NUMBER
	CAIL	T1,INIMAX	;IS THE CODE LEGAL??
	SETZ	T1,		;FLAG THAT PDP-11 IS CONFUSED
	DPB	T1,PBYTE	;LET UUO LEVEL HANDLE PROBLEMS
	PJRST	MAKRUN		;AND LET JOB RUN AGAIN
	COMMENT	&
WHEN THE PDP11 GOES DOWN THERE CAN BE DEVICES
ACTIVE WHICH HAVE THE E. G. THE WTRELB BIT SET,THERE IS A RACE 
CONDITION WHEN A DEVICE HANDS DUE TO A CRASHED PDP 11 AND CALLED
TYPHNG BEFORE THE D76DWN DODE DISCOVERED THE DISASTER. TO PREVENT
PROBLEMS OF THIS TYPE THE FOLLOWING LOGIC IS USED:
1 ALL UUO CODE DOES CHECKS WHETHER THE PDP-11 IS UP AND IF THE
	STATUS	IS STILL UP THEN IT SIMPLY SUBMITS ITS MESSAGES
	EVEN	THOUGH THE PDP-11 MIGHT BE DOWN AT THE MOMENT
2 WHEN THE DL-10 TIMER FLAGS A DL10 AS DOWN IT CALLS D44DWN
	TO	SCAN ALL THE DC44 DEVICES TO BE SURE THAT THERE WILL BE NO PROBLEMS
	&
D44DWN::PUSHJ	P,SAVE2##	;GET SOME SPARE ACCUS
	MOVE	P1,MAX(J)	;GET NUMBER OF LINES ON THIS FRONT END
	SUB	P1,NTT(J)	;ARE THERE DC44 LINES??
	JUMPLE	P1,CPOPJ##	;NO ONE THERE
	MOVEI	P2,DC40TB##	;GET LIST OF DDB'S FOR THIS DC44
	PUSH	P,F		;SAVE F FOR CALLER
	PUSH	P,S		;SAVE S FOR SOMEBODY ELSE
D44DW0:	MOVE	F,(P2)		;GET THE DDB ADDRESS
	MOVE	S,DEVIOS(F)	;GET I/O STATUS
	TLZE	S,WTRELB	;HAS A HUNG DEVICE BEEN CAUGHT?
	TRZA	S,IOACT		;CLEAR IOACT
	TRNN	S,IOACT		;IS DEVICE ACTIVE
	AOJA	P2,D44DW1	;NO FLAGS SET
	MOVEI	S,1		;TAKE LOWEST HUNG TIME
	DPB	S,PDVCNT##	;AND HANG DEVICE KNOWING DC44
	AOSA	P2		;IS DOWN, TAKE NEXT DEVICE
D44DW1:	MOVEM	S,DEVIOS(F)	;UPDATE STATUS
	SOJG	P1,D44DW0	;TAKE NEXT DEVICE
	POP	P,S		;AND S BACK
	POP	P,F		;GET F
	POPJ	P,		

;CONSTANTS:

PBYTSZ:	POINT	6,T3,11		;POINTER TO BYTE SIZE
	IFGE	<INIMAX-10>,<
	PRINTX	PBYTE SHOULD BE UPDATED AS ONLY 3 BITS ARE RESERVED
	PRINTX	AND MORE THAN 3 ARE NEEDE FOR INIDSP
>
PBYTE:	POINT	3,DEVFIL(F),2	;THE LEFT MOST 3 BITS
PBYTE1:	POINT	2,DEVFIL(F),17	;THE DL10 PORT NUMBER
	$LOW
TRBLE:	EXP	0		;COUNTER OF INVALID PDP-11 LINES
	$LIT

	END
