TITLE PLTSER - PLOTTER SERVICE ROUTINE - V051
SUBTTL T. EGGERS/GBH/TNM/RCC	21 JUNE 88

	SEARCH	F,S,DEVPRM
	$RELOC
	$HIGH

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1973,1974,1975,1976,1977,1978,1979,1980,1982,1984,1986,1988.
;ALL RIGHTS RESERVED.

.CPYRT<1973,1988>


XP VPLTSR,051			;PUT VERSION NUMBER IN STORAGE MAP AND GLOB

PLTSER::ENTRY	PLTSER		;LOAD IF LIBRARY SEARCH
SUBTTL	DEVICE DEFINITIONS


;DATAO BITS
	PEN.UP==40		;LIFT THE PEN
	PEN.DN==20		;LOWER THE PEN
	NEG.X== 10		;ROLL DRUM BACK
	POS.X==  4		;ROLL DRUM FORWARD
	POS.Y==  2		;MOVE CARRIAGE LEFT
	NEG.Y==  1		;MOVE CARRIAGE RIGHT
;CONI BITS
	PLBUSY==20		;PLOTTER IS BUSY
	PLDONE==10		;PLOTTER DONE FLAG
	PLPICH== 7		;PI CHANNEL ASSIGNMENT
PLTUP==200000		;LIFT PEN WHEN OUTPUT FINISHED
SUBTTL	AUTOCONFIGURE


;DRIVER CHARARCTERISTICS
;	PLT	= PLTCNF
;	PLT	= PLOTTER
;	7	= MAXIMUM DEVICES IN SYSTEM
;	0	= KONTROLLER TYPE
;	0	= MAXIMUM DRIVES PER KONTROLLER
;	0	= HIGHEST DRIVE NUMBER ON KONTROLLER
;	MDSEC0	= SECTION FOR KDB/UDB
;	MDSEC0	= SECTION FOR DDB
DRVCHR	(PLT,PLT,7,0,0,0,MDSEC0,MDSEC0,<DR.GCC!DR.NET>)

	 .ORG	DEVLLD

PLTCSO:! BLOCK	1		;ADDRESS OF INTERRUPT CODE
PLTIOB:!			;START OF I/O INSTRUCTIONS
PLTCNO:! BLOCK	1		;CONO
PLTDTO:! BLOCK	1		;DATAO
PLTIOE:!			;END OF I/O INSTRUCTIONS
PLTLEN:!			;LENGTH OF PLT DDB

	 .ORG


	$LOW
PLTDDB:	DDBBEG	(PLT,PLTLEN)
	SETWRD	(DEVCHR,<4*HUNGST,,PLTSIZ##>)	;DEVCHR
	SETWRD	(DEVSER,<MCSEC0+PLTDSP>)	;DEVSER
	SETWRD	(DEVMOD,<DVOUT,,<1_A+1_AL+1_I+1_IB+1_B>>) ;DEVMOD
	SETWRD	(DEVTYP,<<.TYPLT*.TYEST>!.SPPLT,,0>) ;DEVTYP
	SETWRD	(DEVCPU,<PLTCHN##>)		;DEVCPU
	SETWRD	(PLTCNO,<CONO  000,(T1)>)	;CONO
	SETWRD	(PLTDTO,<DATAO 000,T1>)		;DATAO
	DDBEND
	$HIGH


;CONSO SKIP CHAIN CODE (AUTCON WILL FILL IN THE BLANKS)
PLTICD:	PHASE	0
	CONSO	000,0			;(00) SKIP IF INTERRUPT FOR THIS LPT
	JRST	.-1			;(01) GO TO NEXT SKIP CHAIN ELEMENT
PLTCTA:!SOSGE	DEVCTR			;(02) OUTPUT CHARACTERS LEFT?
	JRST	PLTINX			;(03) NO
	MOVEM	T1,PLTSV1		;(04) SAVE T1
PLTPTA:!ILDB	T1,DEVPTR		;(05) GET NEXT CHARACTER
	DATAO	000,T1			;(06) SEND TO PLOTTER
	MOVE	T1,PLTSV1		;(07) RESTORE T1
	XJEN	-1			;(10) DONE
PLTINX:!JSR	PIERR##			;(11) SAVE ACS AND SETUP PDL
	SKIPA	F,.+1			;(12) SET UP DDB ADDRESS
PLTDDA:!EXP	0			;(13) DDB ADDRESS
	XJRST	.+1			;(14) CALL INTERRUPT HANDLER
PLTICN:!EXP	0			;(15) INTERRUPT HANDLER ADDRESS
PLTSV1:!EXP	-1			;(16) STORAGE FOR AC T1
	DEPHASE
PLTICL==.-PLTICD			;LENGTH OF CONSO SKIP CHAIN CODE

EQUATE	(LOCAL,0,<PLTCKT,PLTKDB,PLTKLN,PLTUDB,PLTULN>)
EQUATE	(LOCAL,0,<PLTULB,PLTULP>)

PLXDSP:	DRVDSP	(PLT,PLTCHN##,PLTDDB,PLTLEN,URDDIA##)

;DEFAULT MONGEN'ED DEVICE TABLE
DEFMDT:	MDKL10	(7,140,0,0,<MD.KON>)	;DEVICE CODE 140
	MDKL10	(7,144,0,0,<MD.KON>)	;DEVICE CODE 144
	EXP	0
PLTCFG:	XMOVEI	T1,PLTMDT##	;MONGEN'ED DEVICE TABLE
	XMOVEI	T2,DEFMDT	;DEFAULT TABLE
	MOVNI	T3,1		;NO MASSBUS UNIT OR DRIVE INFORMATION
	MOVEI	T4,MD.KON	;MATCH ON KONTROLLER DEFINITION
	PUSHJ	P,AUTMDT##	;SCAN THE TABLES
	  JRST	CPOPJ1##	;NO MATCHES
	PUSH	P,T1		;SAVE MDT DATA
	MOVEI	T1,PLTIOB	;WORD CONTAINING AN I/O INSTRUCTION
	PUSHJ	P,AUTFND##	;SEE IF THERE'S ALREADY A DDB
	  JRST	PLTCF1		;JUST MAKE SURE THE NUMBERS ARE OK
	PUSHJ	P,AUTADN##	;ALLOCATE A DEVICE NUMBER
	HRLI	T1,'PLT'	;INCLUDE GENERIC DEVICE NAME
	SETZ	T2,		;LOCAL DEVICE
	PUSHJ	P,AUTDDB##	;CREATE A DDB
	  JRST	[POP	P,T1	;NO CORE
		 PJRST	AUTDDN##] ;DEALLOCATE DEVICE NUMBER
PLTCF1:	MOVSI	T1,-<PLTIOE-PLTIOB> ;-LENGTH
	XMOVEI	T2,PLTIOB(F)	;STARTING ADDRESS
	HRRZ	T3,.CPDVC##	;DEVICE CODE
	PUSHJ	P,AUTDVC##	;FILL IN DEVICE CODES
	SKIPE	PLTCSO(F)	;BEEN HERE BEFORE?
	JRST	PLTCF3		;THEN DON'T MESS WITH THE SKIP CHAIN
	MOVE	T1,F		;DATA BLOCK ADDRESS
	XMOVEI	T2,PLTINT	;INTERRUPT SERVICE
	PUSHJ	P,AUTICD##	;GENERATE INTERRUPT ROUTINES
	  SKIPA	T2,F		;NO CORE
	JRST	PLTCF2		;ONWARD
	MOVEI	T1,PLTLEN	;GET DDB LENGTH
	PUSHJ	P,AUTKIL##	;DELETE THE DDB
	PUSHJ	P,AUTDDN##	;DEALLOCATE DEVICE NUMBER
	JRST	TPOPJ##		;PHASE STACK AND RETURN
PLTCF2:	MOVEM	T1,PLTCSO(F)	;SAVE ADDRESS
	MOVEI	T2,DEVCTR(F)	;COUNTER ADDRESS
	HRRM	T2,PLTCTA(T1)	;RELOCATE DDB BYTE COUNTER
	MOVEI	T2,DEVPTR(F)	;BYTE POINTER ADDRESS
	HRRM	T2,PLTPTA(T1)	;RELOCATE DDB BYTE POINTER
	MOVEI	T2,PLTCHN##	;PI CHANNEL
	PUSHJ	P,AUTCSO##	;LINK INTO CONSO SKIP CHAIN
PLTCF3:	POP	P,T1		;GET MDT DATA BACK
	POPJ	P,		;ALL DONE
;DISPATCH TABLE

	JRST	CPOPJ1##	;IF YOU'RE ASKING, IT'S ONLINE
	JRST	ECOD2##		;SPECIAL ERROR STATUS
	JRST	REGSIZ##	;BUFFER LENGTH CAN BE GOTTEN FROM DDB
	JRST	PLTINI		;INITIALIZE
	JRST	PLTHNG		;HUNG DEVICE ERROR
PLTDSP:	JRST	PLTREL		;RELEAS
	JRST	PLTCLS		;CLOSE
	JRST	PLTOUT		;OUTPUT
	JRST	ILLINP##	;INPUT

PLTCLS:	TLO	S,PLTUP		;PLOTTER END FLAG SET
	MOVEM	S,DEVIOS(F)
	JRST	OUT##		;DO AN OUTPUT

PLTINI:	MOVEI	PLTDDB		;ADDRESS OF PROTOTYPE
	CAIN	T1,(F)		;IF CALLED FOR PROTOTYPE,
	JRST	CPOPJ1##	;HOLD OUT FOR A REAL PLOTTER
	AOS	(P)		;CALL FOR EACH PLOTTER (AS IF THERE WERE TWO)
PLTHNG:
PLTREL:	MOVEI	T1,0
	XCT	PLTCNO(F)	;DEASSIGN PI CHANNEL, CLEAR DONE
	HLLZS	@PLTCSO(F)	;REMOVE PLOTTER FROM DEVICE CHAIN
	POPJ	P,

;HERE BEGINS THE "OUTPUT" UUO

PLTOUT:	PUSHJ	P,PLTSET	;SETUP BYTE POINTER AND COUNTER
	PUSHJ	P,SETACT##	;SET DEVICE ACTIVE BIT
	TLO	S,IO
	MOVEI	T1,10
	HRRM	T1,@PLTCSO(F)	;PUT PLOTTER INTO DEVICE CHAIN
	MOVEI	T1,PLTCHN##	;GET INTERRUPT CHANNEL
	XCT	PLTCNO(F)	;ASSIGN PRIORITY CHANNEL
	TLZE	S,IOBEG		;FIRST OUTPUT UUO?
	TLZA	S,PLTUP		;YES, INIT "CLOSE" BIT
	TDZA	T1,T1		;NO, 1ST PLOT CHAR IS ZERO
	MOVEI	T1,PEN.UP	;START PLOT WITH PEN UP
	MOVEM	S,DEVIOS(F)
	XCT	PLTDTO(F)	;START PLOTTER BY SENDING PEN.UP OR A NO-OP
	POPJ	P,
;FROM HERE THROUGH PLTOFF IS INTERRUPT SERVICE

PLTINT:		;THE PLOTTER CODE IN COMDEV TAKES CARE OF PLOTTER
		;DATA INTERRUPTS THAT REQUIRE ONLY A CHARACTER THAT
		;IS READILY AVAILABLE. TO ADVANCE BUFFERS OR SHUT
		;DOWN THE PLOTTER, THE CODE HERE FOLLOWING IS CALLED.

	PUSHJ	P,IOSET##	;SETS UP R AND S
	PUSHJ	P,ADVBFE##	;ADVANCE AND LOOK AT NEXT BUFFER
	  JRST PLTOFF		;NO MORE DATA AVAILABLE
	PUSHJ	P,PLTSET	;SETUP BYTE POINTER AND COUNTER
PLT2:	PUSHJ	P,SETIOD##	;LET JOB START AGAIN
	JRST	STOIOS##	;EVENTUALLY DISMISS INTERRUPT. IF ADVBFE
				;FOUND MORE DATA (IT SKIPPED), ANOTHER
				;INTERRUPT WILL IMMEDIATELY OCCUR BUT
				;IT WILL BE HANDLED WITHOUT GOING TO PLTNXT

PLTOFF:	PUSHJ	P,PLTREL	;SHUT DOWN PLOTTER
	TRZ	S,IOACT
	MOVEI	T1,PEN.UP	;PEN UP COMMAND
	TLZE	S,PLTUP		;HAS THE "CLOSE" BEEN DONE?
	XCT	PLTDTO(F)	;YES, LIFT PEN
	JRST	PLT2

;THIS SUBROUTINE CALCULATES A BYTE POINTER AND A BYTE COUNTER FOR
;THE BUFFER TO BE OUTPUT.

PLTSET:	MOVEI	T1,@DEVOAD(F)	;GET ADDRESS OF CURRENT BUFFER
	ADD	T1,[POINT 6,1,35]	;CONVERT TO 6 BIT BYTE POINTER WITH
				;ADDRESS OF BUFFER WORD COUNT
	TRNN	S,16		;IS THIS A TEXT DATA MODE?
	HRLI	T1,(POINT 7,0,35)	;YES, CONVERT TO 7 BIT BYTE POINTER
	MOVEM	T1,DEVPTR(F)	;SAVE BYTE POINTER
	HRRZ	T1,@T1		;GET BUFFER WORD COUNT
	MOVEM	T1,DEVCTR(F)	;SAVE AS POSITIVE WORD COUNT
	MOVEI	T1,6		;IMAGE OR BIN MODES - 6 BYTES/WORD
	TRNN	S,16		;IS OUTPUT A TEXT MODE (0 OR 1)?
	MOVEI	T1,5		;YES, 5 BYTES/WORD
	IMULM	T1,DEVCTR(F)	;CHANGE WORD COUNT TO BYTE COUNT
	POPJ	P,		;RETURN

	LIT

PLTEND:	END
