	Title	PPSSER - Paper Tape Punch Service Routine for KS10s - V004
	Subttl	Timothe Litt	17-FEB-87
	;From PTPSER V433

	SEARCH	F,S
	$RELOC


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1973,1974,1975,1976,1977,1978,1979,1980,1982,1986,1988.
;ALL RIGHTS RESERVED.

.CPYRT<1973,1988>


XP VPTPSR,004
		;PUT VERSION NUMBER IN GLOB LISTING AND LOADER STORAGE MAP


	ENTRY PTPSER
PTPSER::
;	CSR and DDB bit definitions
	PPS==PTPCNO##+0		;Word in DDB with IO address of CSR
	ERR==100000		;Error (No tape, or No power)
	RDY==000200		;Ready (Cleared on write to PPB, set by DONE)
	INTENB==100		;Interrupt enable

	PPB==PTPCNO##+1		;Word in DDB with IO address of data buffer

	PTPIVA==PTPCNO##+2	;Word in DDB with interrupt vector

	PTPIVI==PTPCNO##+3	;Word in DDB with interrupt instruction

;FORMAT CONTROL
	PTPFDN==200

;   SPECIAL IO STATUS WORD ASSIGNMENTS
	IODISC==400000
	PTPFED==200000
	PTPEOL==20000
	PTPBIN==4000	;CHECKSUM BINARY
	PTPIB==2000	;IMAGE BINARY

;   SPECIAL ASCII CHARACTERS
;   DEFINED WITH THE CORRECT PARITY
	RUBOUT==377
	HORTAB==11
	VERTAB==213
	FORMFD==14
	Subttl	UUOCON Interface -- Dispatch table

;PTP SERVICE DISPATCH TABLE
	JRST	PTPONL		;SEE IF ON-LINE
	JRST	ECOD2##		;SPECIAL ERROR STATUS
	JRST	REGSIZ##	;BUFFER LEN CAN BE GOTTEN FROM DDB
	JRST	PTPINI		;INITILIZE
	JRST	PTPREL		;HUNG DEVICE TIME-OUT ERROR.
PTPDSP::JRST	PTPREL		;RELEASE
	JRST	PTPCLS		;CLOSE
	JRST	PTPOUT		;OUTPUT
	JRST	ILLINP##	;INPUT
	SUBTTL	UUOCON Interface -- Initialize, CLOSE & RELEAS

PTPINI:	MOVE	T1,PPS(F)	;Get base address of IO registers
	PUSHJ	P,UBGOOD##	;Alive?
	 JRST	CPOPJ1##	;No, hopeless case
	HLRZ	T1,PPS(F)	;Get UNIBUS adapter number
	HRRZ	T2,PTPIVA(F)	;Get interrupt vector address
	PUSHJ	P,AUTVIA##	;Compute address of interrupt instruction
	MOVE	T2,PTPIVI(F)	;Get interrupt instruction
	MOVEM	T2,(T1)		;Save for interrupts
	PUSHJ	P,PTPREL	;Do the RELEAS code
	JRST	CPOPJ1##	;And return to SYSINI

PTPREL:	MOVE	T1,PPS(F)	;Get IO address
	PUSHJ	P,UBGOOD##	;Be sure it's alive
	 POPJ	P,		;Dead, don't touch
	MOVEI	T1,INTENB	;Get interrupt enable
	BCIO	T1,@PPS(F)	;Ensure it's clear
	POPJ	P,		;Done


PTPCLS:	PUSHJ	P,OUT##		;OUTPUT REMAINING BUFFERS
	PUSHJ	P,WAIT1##	;WAIT FOR IOACT=0.
	MOVE	S,DEVIOS(F)	;C(S):=C(PTPIOS)
	TLO	S,IODISC+PTPFED+IOW	;IODISC:=IOW:=PTPFED:=1
	PUSHJ	P,SETACT##	;SET ACTIVE FLAG,STORE S,AND
				;RESET HUNG DEVICE TIMEOUT COUNT
	MOVEI	T1,200
	MOVEM	T1,PTPCNT##(F)	;PTPCNT:=200
	MOVEI	T1,INTENB	;Get interrupt enable
	BSIO	T1,@PPS(F)	;Take an interrupt
	JRST	WAIT1##		;WAIT FOR IOACT=0, ALL BUFFERS FINISHED
	Subttl	UUOCON Interface -- OUT

PTPOUT:	MOVE	T1,PPS(F)	;Get CSR address
	PUSHJ	P,UBGOOD##	;Make sure we have a live one
	 JRST	PTPOU1		;We don't, say OPR ACTION REQUESTED
	MOVEI	T1,ERR		;Get error bit
	TION	T1,@PPS(F)	;Any errors?
	 JRST	PTPIN0		;No, proceed
PTPOU1:	PUSHJ	P,HNGSTP##	;ISSUE "DEVICE PTP OK?"
	JRST	PTPOUT		;TRY AGAIN WHEN "CONT" TYPED
PTPIN0:	TLZE	S,IOBEG		;VIRGIN DEVICE? (IOBEG:=0)
	JRST	PTPIN2		;YES
PTPIN1:	TLZ	S,IODISC	;CLEAR DISCONNECT BIT
	PUSHJ	P,SETACT##	;SET ACTIVE FLAG,STORE S, AND
				;RESET HUNG DEVICE TIMEOUT COUNT
	MOVEI	T1,INTENB	;Set to take an interrupt
	BSIO	T1,@PPS(F)	;Do so (may wait for a char to punch or feed)
	POPJ	P,		;RETURN

PTPIN2:	LDB	T1,PIOMOD##
	TLO	S,IOFST+PTPFED+IO	;IOFST:=PTPFED:=IO:=1
	TLZ	S,PTPBIN+PTPIB	;CLEAR BINARY AND IMAGE BINARY BITS
	CAIN	T1,IB		;IMAGE BINARY?
	TLO	S,PTPIB		;YES
	CAIN	T1,B		;MODE=BINARY?
	TLO	S,PTPBIN	;YES, PTPBIN:=1
	MOVEI	T1,PTPFDN	;PTPCNT:=PTPFDN
	MOVEM	T1,PTPCNT##(F)
	PUSHJ	P,SETBYT##	;SETBYT
	HLLM	T1,DEVPTR(F)	;PTPPTR0-5:=PTPPTR12-13:=0,PTPPTR6-11:=BYTE
				;SIZE;
	JRST	PTPIN1

PTPONL:	MOVE	T1,PPS(F)	;Get CSR address
	PUSHJ	P,UBGOOD##	;Alive?
	 POPJ	P,		;No, off-line
	MOVEI	T2,ERR		;Error set?
	TION	T2,(T1)		; ...
	 AOS	(P)		;No, on-line
	POPJ	P,		;Return
	Subttl	Punch Interrupt Service

PTPINT::
	RDIO	T1,@PPS(F)	;Read Punch status
	MOVEM	T1,DEVSTS(F)	;Save for watchers
	TRNE	T1,ERR		;Out of tape?
	 JRST	NOTAPE		;Yes, stop
	MOVE	S,DEVIOS(F)	;S:=C(PTPIOS)
	TLNE	S,PTPFED	;FEED REQUEST? (PTPFED=1?)
	JRST	PTPS2		;YES
	PUSHJ	P,IOSET##	;J=C(DEVCTR)
				;S:=C(PTRIOS)
	TLZE	S,IODISC	;DISCONNECT?  (IODISC=1?)
	JRST	PTPADV		;YES
	TLZE	S,IOFST		;IOFST=1? IOFST:=0
	JRST	PTP9		;YES
	TLNN	S,PTPBIN+PTPIB	;BINARY PUNCH MODE?
	JRST	PTP3		;NO

	;Here when processing binary output

	MOVE	T1,PTPCHA##(F)	;BINARY OUTPUT BYTE SIZE=36
	ROT	T1,6
	MOVEM	T1,PTPCHA##(F)
	ANDI	T1,77		;T1:=XX, SIXBIT SUB-BYTE
	ADDI	T1,200
	WRIOB	T1,@PPB(F)	;Punch 10xxxxxx (2XX)
	SOSL	PTPCNT##(F)	;C(PTPCNT):=C(PTPCNT)-1.  WORD DONE?
	JRST	STOIOS##	;NO
	SOSL	DEVCTR(F)	;C(PTPCTR):=C(PTPCTR)-1.  J COUNT .LT.  0?
	JRST	PTPB1		;NO
	TLNE	S,PTPIB		;IMAGE BINARY?
	TLOA	S,IODISC	;YES, SUPPRESS TAPE FEED.
	TLO	S,IODISC+PTPFED	;IODISC:=PTPFED:=1
	MOVEI	T1,10
	MOVEM	T1,PTPCNT##(F)	;PTPCNT:=10
	JRST	STOIOS##

	;Here to set up for next binary word

PTPB1:	MOVEI	T1,5		;PTPCNT:=5
	MOVEM	T1,PTPCNT##(F)
	MOVE	U,@DEVPTR(F)	;PTPCHA:=OUTPUT DATA WORD
	AOS	DEVPTR(F)	;PTPPTR:=C(PTPPTR)+1.  ADVANCE J POINTER.
	MOVEM	U,PTPCHA##(F)
	JRST	STOIOS##
	;Here when ready to punch next character in ASCII mode

PTP3:	MOVE	U,PTPCHA##(F)	;Get character
	WRIOB	U,@PPB(F)	;Punch it
	TRNE	S,14		;IS MODE AN ALPHA MODE
	JRST	PTP1		;NO
	CAIE	U,HORTAB	;HORIZONTAL OR VERTICAL TAB?
	CAIN	U,VERTAB
	JRST	PTPP1		;YES
	CAIE	U,FORMFD	;FORM FEED?
	JRST	PTP1		;NO
	TLO	S,PTPFED+PTPEOL	;PTPFED:=PTPEOL:=1
	MOVEI	U,20
	MOVEM	U,PTPCNT##(F)	;PTPCNT:=20
	JRST	STOIOS##
	;Here with no special fill initiated.  See if more in this buffer

PTP1:	SOSGE	DEVCTR(F)	;C(PTPCTR):=C(PTPCTR)-1.  IS C(PTPCTR) .LT. 0?
	JRST	PTP5		;YES
	ILDB	T3,DEVPTR(F)	;T3:=OUTPUT J
	LDB	T1,PIOMOD##
	CAIN	T1,I		;MODE=IMAGE?
	JRST	PTP6		;YES
	IORI	T3,200		;NO, INSERT EIGHTH HOLE
	TRNN	T1,14		;AN ASCII MODE?
	PUSHJ	P,PEVEN8##	;YES. TURN EIGHTH HOLE OFF IF
				; APPROPRIATE TO GET EVEN PARITY
	JUMPE	T3,PTP1		;IF AN ASCII NULL, IGNORE IT.
				; THEY ARE PUT IN BY PTPFED STUFF
				; ELSE FALL INTO PTP6

	;Here to set up char to punch at next interrupt

PTP6:	MOVEM	T3,PTPCHA##(F)	;PTPCHA:=OUTPUT J
	JRST	STOIOS##

PTPS2:	SETZB	T1,PTPCHA##(F)	;PUNCH FEED
	WRIOB	T1,@PPB(F)
	SOSG	PTPCNT##(F)	;COUNT FEED LINES
	TLZ	S,PTPFED	;PTPFED:=0
	MOVEM	S,DEVIOS(F)	;PTPIOS:=C(S)
	POPJ	P,		;Dismiss

PTP5:	TLO	S,IODISC	;IODISC:=1
	JRST	STOIOS##

PTPBN:	MOVEI	T2,@DEVOAD(F)	;T2:=BUFFER ADDRESS
	PUSHJ	P,CKS12##	;T1:=CALCULATE CHECKSUM
	ADD	T2,DEVOAD(F)
	HLLM	T1,@T2		;STORE CHECKSUM IN LEFT HALF OF FIRST BUFFER DATA WORD.
	JRST	PTPB1
	;Here at end of buffer, see if can start a new one

PTPADV:	PUSHJ	P,ADVBFE##	;ADVANCE BUFFER
	  JRST	PTPDSC		;EXIT1.  NEXT BUFFER EMPTY
	PUSHJ	P,SETIOD##	;IN A WAIT?  IOW:=0

	;Here to start a new buffer

PTP9:	TLZ	S,IOFST		;IOFST:=0
	MOVE	T1,DEVOAD(F)
	AOS	T1
	HRRM	T1,DEVPTR(F)	;PTPPTR18-35:=C(PTPADR18-35)+1
	HRRZ	J,@T1		;J:=WORD COUNT
	LDB	T2,PTP91	;PICK UP BYTE SIZE
	PUSHJ	P,ITMCT1##	;J:=WORD COUNT*[36/BYTE SIZE]
	MOVEM	J,DEVCTR(F)	;PTPCTR:=C(J)
	JUMPE	J,PTPADV	;IS J COUNT=0?
	TLNE	S,PTPBIN	;BINARY PUNCH MODE?
	JRST	PTPBN		;YES
	TLNN	S,PTPIB		;IMAGE BINARY?
	JRST	PTP1
	AOS	DEVPTR(F)	;YES
	SOS	DEVCTR(F)
	JRST	PTPB1

PTP91:	POINT	6,DEVPTR(F),11

PTPP1:	MOVEI	U,RUBOUT	;PTPCHA:=RUBOUT
	MOVEM	U,PTPCHA##(F)
	TLO	S,PTPEOL	;PTPEOL:=1
	JRST	STOIOS##

PTPDSC:	PUSHJ	P,PTPREL	;CLEAR PTP CONTROL REG AND CONSO BITS
	TRZ	S,IOACT		;IOACT:=0
	TLO	S,IOFST		;IOFST:=1
				;IN A WAIT?  IOW:=0
	PUSHJ	P,SETIOD##	;YES.  IOWS:=1
	JRST	STOIOS##	;STORE S, RESET HUNG TIMEOUT COUNT AND
				;DISMISS INTERRUPT
;WHEN END OF TAPE ENCOUNTERED, COME HERE TO FORCE A HUNG DEVICE
NOTAPE:	MOVEI	T1,INTENB	;Get interrupt enable
	BCIO	T1,@PPS(F)	;Turn the PTP off
	POPJ	P,		;Now dismiss the interrupt

	END
