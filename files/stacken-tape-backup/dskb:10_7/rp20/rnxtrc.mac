	TITLE	RNXTRC - TRACE RP20 OPERATIONS
	SUBTTL	G.M. UHLER/GMU


;THIS PROGRAM INSERTS SNOOP. BREAKPOINTS INTO THE RP20 DISK DRIVER
;(RNXKON) AT SELECTED POINTS TO GATHER DATA ON THE PERFORMANCE
;OF THE RP20.  IT IS ALSO VERY USEFUL IN DEBUGGING INTERMITANT BUGS
;SINCE IT GIVES A RECORD OF WHAT HAPPENED.  RNXTRC HAS TWO MODES,
;CONTINUOUS LOGGING, AND TERMINATION LOGGING.  CONTINUOUS LOGGING
;LOGS ALL OPERATIONS FROM THE TIME THE BREAKPOINTS ARE INSERTED UNTIL
;THE PROGRAM IS TERMINATED.  TERMINATION LOGGING ONLY LOGS THE LAST
;N EVENTS THAT OCCURRED PRIOR TO PROGRAM TERMINATION.  IT SHOULD BE
;NOTED THAT CONTINUOUS LOGGING CAUSES MASSIVE AMOUNTS OF DATA TO BE
;WRITTEN TO THE LOGGING DEVICE SO CARE SHOULD BE TAKEN.  IN EITHER
;MODE, THE RAW BINARY OUTPUT DATA IS WRITTEN TO RNXTRC:RNXTRC.BIN[-].
;A POSTPROCESSOR, RNXPRT, MUST THEN BE RUN TO FORMAT THE DATA INTO
;A FORM READABLE BY HUMANS.
;
;TO RUN RNXTRC, SIMPLY ASSIGN LOGICAL DEVICE RNXTRC AS YOUR FAVORITE
;PHYSICAL DEVICE, RUN THE PROGRAM AND FOLLOW THE DIRECTIONS.


	SEARCH	JOBDAT,MACTEN,UUOSYM,SNUP
	.REQUIRE SNUP
	SALL


;COPYRIGHT (C) 1980,1981,1982,1983 BY
;DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.


	RNTVER==1		;MAJOR VERSION
	RNTMIN==0		;MINOR VERSION
	RNTEDT==5		;EDIT
	RNTWHO==0		;WHO LAST EDITED

	LOC	.JBVER
	VRSN.	(RNT)
	RELOC
	SUBTTL	BREAKPOINT ENTRY FORMATS


ENTLEN==0			;INITIALIZE MAXIMUM ENTRY SIZE
BPNUM==0			;AND BREAKPOINT COUNT

;EACH ENTRY IN THE BUFFER CONTAINS THREE COMMON WORDS FOLLOWED BY
;N WORDS SPECIFIC TO EACH BREAKPOINT.  ALL ENTRIES ARE THE LENGTH
;OF THE LONGEST ENTRY AND SHORTER ENTRIES SIMPLY IGNORE THE UNUSED
;WORDS.  THE COMMON WORDS ARE AS FOLLOWS:

;  !=======================================================!
;  !        ENTRY TYPE         !      SEQUENCE NUMBER      !
;  !-------------------------------------------------------!
;  !             RDTIME VALUE IN MICROSECONDS              !
;  !-------------------------------------------------------!
;  !        CPU NUMBER         !     KONTROLLER NUMBER     !
;  !-------------------------------------------------------!

	PHASE	0
BPNTYP:! BLOCK	1		;TYPE OF ENTRY,,SEQUENCE NUMBER
BPNTIM:! BLOCK	1		;RDTIME VALUE IN MICROSECONDS
BPNCKU:! BLOCK	1		;CPU NUMBER,,KONTROLLER NUMBER
BPNHLN:!			;LENGTH OF THE HEADER
	DEPHASE


;ENTRY OFFSETS SPECIFIC TO BREAKPOINT 1 ARE AS FOLLOWS:

;  !-------------------------------------------------------!
;  !           DATAO TO CONTROL REGISTER OR STCR           !
;  !-------------------------------------------------------!
;  !                     BLOCK ON UNIT                     !
;  !-------------------------------------------------------!
;  !                 PHYSICAL UNIT NUMBER                  !
;  !=======================================================!

	PHASE	BPNHLN
BP1DTO:! BLOCK	1		;DATAO TO THE CONTROL REGISTER OR STCR
BP1BLK:! BLOCK	1		;BLOCK ON UNIT
BP1UNI:! BLOCK	1		;PHYSICAL UNIT NUMBER
IFG .-ENTLEN,<ENTLEN==.>	;FIND LARGEST ENTRY
BPNUM==BPNUM+1			;AND COUNT BREAKPOINTS
	DEPHASE
;ENTRY OFFSETS SPECIFIC TO BREAKPOINT 2 ARE AS FOLLOWS:

;  !-------------------------------------------------------!
;  !             ASYNCHRONOUS STATUS REGISTER              !
;  !-------------------------------------------------------!
;  !  ENDING STATUS REGISTER   !      ERROR REGISTER       !
;  !-------------------------------------------------------!
;  !      CHANNEL STATUS       !           CONI            !
;  !-------------------------------------------------------!
;  !                RNXKON FLAGS WORD (P1)                 !
;  !=======================================================!

	PHASE	BPNHLN
BP2ASY:! BLOCK	1		;ASYNCHRONOUS STATUS REGISTER
BP2ERG:! BLOCK	1		;ENDING STATUS,,ERROR REGISTERS
BP2CNI:! BLOCK	1		;CHANNEL STATUS,,CONI
BP2FLG:! BLOCK	1		;RNXKON FLAGS WORD (P1)
IFG .-ENTLEN,<ENTLEN==.>	;FIND LARGEST ENTRY
BPNUM==BPNUM+1			;AND COUNT BREAKPOINTS
	DEPHASE


;ENTRY OFFSETS SPECIFIC TO BREAKPOINT 3 ARE AS FOLLOWS:

;  !-------------------------------------------------------!
;  !           RNXKON/FILIO COMMUNICATIONS WORD            !
;  !-------------------------------------------------------!
;  !                RNXKON FLAGS WORD (P1)                 !
;  !-------------------------------------------------------!
;  !  ENDING STATUS REGISTER   !      ERROR REGISTER       !
;  !-------------------------------------------------------!
;  !      CHANNEL STATUS       !           CONI            !
;  !=======================================================!

	PHASE	BPNHLN
BP3COM:! BLOCK	1		;RNXKON/FILIO COMMUNICATION WORD (T1)
BP3FLG:! BLOCK	1		;RNXKON FLAGS WORD (P1)
BP3ERG:! BLOCK	1		;ENDING STATUS,,ERROR REGISTERS
BP3CNI:! BLOCK	1		;CHANNEL STATUS,,CONI
IFG .-ENTLEN,<ENTLEN==.>	;FIND LARGEST ENTRY
BPNUM==BPNUM+1			;AND COUNT BREAKPOINTS
	DEPHASE
;ENTRY OFFSETS SPECIFIC TO BREAKPOINT 4 ARE AS FOLLOWS:

;  !-------------------------------------------------------!
;  !             FUCTION FOR CURRENT OPERATION             !
;  !-------------------------------------------------------!
;  !      RNXKON FLAGS WORD FOR OPERATION IN PROGRESS      !
;  !-------------------------------------------------------!
;  !   PHYSICAL UNIT NUMBER FOR OPERATION TO BE STARTED    !
;  !=======================================================!

	PHASE	BPNHLN
BP4COP:! BLOCK	1		;FUNCTION FOR CURRENT OPERATION
BP4PFL:! BLOCK	1		;RNXKON FLAGS WORD FOR OPERATION IN PROGRESS
BP4UNI:! BLOCK	1		;PHYSICAL UNIT NUMBER
IFG .-ENTLEN,<ENTLEN==.>	;FIND LARGEST ENTRY
BPNUM==BPNUM+1			;AND COUNT BREAKPOINTS
	DEPHASE


;ENTRY OFFSETS SPECIFIC TO BREAKPOINT 5 ARE AS FOLLOWS:

;  !-------------------------------------------------------!
;  !                  ERROR BITS (KOP???)                  !
;  !-------------------------------------------------------!
;  !                         CONI                          !
;  !-------------------------------------------------------!
;  !  ENDING STATUS REGISTER   !      ERROR REGISTER       !
;  !-------------------------------------------------------!
;  !                 PHYSICAL UNIT NUMBER                  !
;  !=======================================================!

	PHASE	BPNHLN
BP5ERB:! BLOCK	1		;ERROR BITS (KOP???)
BP5CNI:! BLOCK	1		;CONI
BP5ERG:! BLOCK	1		;ENDING STATUS REGISTER,,ERROR REGISTER
BP5UNI:! BLOCK	1		;PHYSICAL UNIT NUMBER
IFG .-ENTLEN,<ENTLEN==.>	;FIND LARGEST ENTRY
BPNUM==BPNUM+1			;AND COUNT BREAKPOINTS
	DEPHASE
;ENTRY OFFSETS SPECIFIC TO BREAKPOINT 6 ARE AS FOLLOWS:

;  !-------------------------------------------------------!
;  !                         CONI                          !
;  !=======================================================!

	PHASE	BPNHLN
BP6CNI:! BLOCK	1		;CONI
IFG .-ENTLEN,<ENTLEN==.>	;FIND LARGEST ENTRY
BPNUM==BPNUM+1			;AND COUNT BREAKPOINTS
	DEPHASE

	RELOC	0		;DON'T WASTE THE PHASED SPACE
	SUBTTL	PARAMETER DEFINITIONS


OPDEF	RDTIME[DATAI 020,]

D==1			;DISK OUTPUT CHANNEL
PDLLEN==20		;LENGTH OF PDL
BUFLEN==1500*ENTLEN	;LENGTH OF BUFFER


;TABLE GIVING DESCRIPTIONS OF EACH BREAKPOINT

EVDSCP:	[ASCIZ/operation initiation at RNXGO/]
	[ASCIZ/asynchronous status detected by CHKATN/]
	[ASCIZ/interrupt exit in CALFIO/]
	[ASCIZ/CONECT calls to CMDWAT/]
	[ASCIZ/operation initiation errors at RNXDWN/]
	[ASCIZ/hung transfer timeouts at RNXSTP/]
IFN <.-EVDSCP-BPNUM>,<PRINTX ?EVDSCP table length wrong>


;DEFINE REFERENCED SYMBOLS AND BREAKPOINTS

MONREF	UNYPUN			;BYTE POINTER TO PHYSICAL UNIT
MONREF	UNIBLK			;OFFSET OF BLOCK NUMBER IN UDB
MONREF	.CPCPN			;CPU NUMBER ON WHICH WE'RE RUNNING
MONREF	KOYKNM			;KONTROLLER NUMBER OF THIS KONTROLLER

;********** DO NOT CHANGE THE ORDER OF THE FOLLOWING LINES **********

DEFINE	DEFNBP(N),<
  BRKPNT RNXBP'N,BP'N
>

.ZZ==1
REPEAT	BPNUM,<
  DEFNBP (\.ZZ)
  .ZZ==.ZZ+1
>
BRKPNT	RNXBPX,BPX

;********** END OF ORDER DEPENDENT CODE **********
	SUBTTL	MACRO DEFINITIONS


;MACRO TO DO ALL THE SETUP NECESSARY WHEN A SNOOP LEVEL BREAKPOINT
;IS ENTERED.  NOTE THAT BREAKPOINT NUMBER ^D99 IS THE SPECIAL SNOOP.
;LEVEL EXIT REQUEST BREAKPOINT.
;INVOCATION:	ENTRBP	(BREAKPOINT-NUMBER)
;LEAVES %T2 AT -1(%P) AND %T3 AT 0(%P) AND SETS UP %T2 TO POINT TO
;THE BASE OF THE BUFFER ENTRY TO USE.

	DEFINE	ENTRBP(NUMBER),<
	  PUSH	%P,%T2		;;SAVE T2
	  XLIST
	  PUSH	%P,%T3		;;  AND T3
	  MOVSI	%T2,NUMBER	;;TYPE IS INPUT ARGUMENT
	  IFN NUMBER-^D99,<
	  SKIPE	EVFLAG+NUMBER-1(%R) ;;WANT TO LOG THIS EVENT?
	  >
	  PUSHJ	%P,SETUP(%R)	;;DO INITIALIZATION
	   JRST	BPRET(%R)	;;DON'T LOG THIS EVENT
	  LIST
	>


;MACRO TO EXIT A SNOOP LEVEL BREAKPOINT.
;INVOCATION:	EXITBP

	DEFINE	EXITBP,<
	  JRST	BPEXIT(%R)
	>
	SUBTTL	PROGRAM SETUP


RNXTRC:	JFCL			;NO CCL ENTRY
	RESET			;RESET EVERYTHING
	MOVE	P,[IOWD PDLLEN,PDL] ;SETUP A PDL
	OPEN	D,[EXP .IOIMG,'RNXTRC',<OBUF,,0>] ;OPEN CHANNEL
	  JRST	NOOPEN		;FAILED
	ENTER	D,[EXP 'RNXTRC','BIN   ',0,0] ;ENTER OUTPUT FILE
	  JRST	NOENTR		;FAILED
	OUTBUF	D,4		;SETUP 4 OUTPUT BUFFERS
	MTREW.	D,		;REWIND POSSIBLE TAPE
	MTWAT.	D,		;WAIT FOR IT TO FINISH
	PUSHJ	P,STRTUP	;ASK STARTUP QUESTIONS
	MOVEI	T1,0		;GET ARG FOR TRPSET
	TRPSET	T1,		;GET USRIOT
	  JRST	NOTRPS		;FAILED
	MOVEI	T1,1		;SET FOR HPQ 1
	HPQ	T1,		;MAKE SURE WE RUN
	  JFCL			;SHOULDN'T HAPPEN
	PUSHJ	P,GETINF##	;DEFINE THE BREAKPOINTS
	SETZM	CNT		;ZERO THE SEQUENCE NUMBER
	MOVEI	T1,BUFLEN	;SETUP INITIAL BUFFER POINTER SO SNOOP
	MOVEM	T1,BUFPTR	;  ROUTINES START AT THE START
	CLRBFI			;DON'T ALLOW TYPEAHEAD TO ABORT US
	OUTSTR	[ASCIZ/
[Type an altmode to exit]
/]
	RDTIME	STIME		;READ BASE TIME
	PUSHJ	P,XWRSNP##	;INSERT THE BREAKPOINTS
	MOVEI	P1,0		;INITIALIZE BACKGROUND ENTRY COUNT
	MOVEI	P2,BUFLEN	;  AND BUFFER POINTER
	SKIPN	WINDOW		;WANT CONTINUOUS LOGGING?
	JRST	WATCH		;NO
;;	JRST	FOLLOW		;YES, FALL INTO FOLLOW
	SUBTTL	BACKGROUND TASK -- CONTINUOUS LOGGING


;HERE TO FOLLOW THE SNOOP LEVEL ROUTINE AROUND THE BUFFER, WRITING
;THE DATA TO THE OUTPUT FILE CONTINUOUSLY.

FOLLOW:	INCHSL	T1		;GET CHARACTER FROM TTY, SKIP IF GOT ONE
	JRST	FOLLO1		;NONE, CHECK BUFFER
	CAIE	T1,.CHESC	;ESCAPE?
	JRST	FOLLOW		;NO, TRY AGAIN
	CLOSE	D,		;CLOSE OUTPUT FILE
	REMBRK			;REMOVE BREAKPOINTS
	UNDBRK			;UNDEFINE THEM
	EXIT			;EXIT

;HERE TO CHECK THE BUFFER TO SEE IF WE SHOULD WRITE ANYTHING TO THE
;OUTPUT FILE.

FOLLO1:	CAMGE	P1,CNT		;DID WE CATCH UP TO THE MONITOR?
	JRST	FOLLO2		;NO, WRITE SOME DATA
	MOVEI	T1,1		;HIBER FOR
	HIBER	T1,		;  A TICK
	  JFCL			;SHOULDN'T HAPPEN
	JRST	FOLLOW		;AND CHECK CHARACTERS

;HERE WHEN THE MONITOR IS AHEAD OF US TO TRY TO CATCH UP BY WRITING
;DATA TO THE OUTPUT FILE.

FOLLO2:	MOVEI	T2,ENTLEN	;GET LENGTH OF ENTRY
FOLLO3:	PUSHJ	P,NXTWRD	;GET NEXT WORD FROM BUFFER
	PUSHJ	P,WRTWRD	;WRITE IT TO FILE
	SOJG	T2,FOLLO3	;LOOP FOR ALL
	AOJA	P1,FOLLO1	;INCREMENT COUNT AND GO FOR NEXT
	SUBTTL	BACKGROUND TASK -- TERMINATION LOGGING


;HERE TO LOG ONLY ON EXIT.  THIS MEANS THAT THE MONITOR CONTINUOUSLY
;FILLS THE BUFFER BUT WE DO NOTHING UNTIL THE USER TYPES A CRLF OR
;THE SNOOP. LEVEL EXIT REQUEST BREAKPOINT IS EXECUTED.  AT THAT POINT,
;WE WRITE THE CURRENT BUFFER TO THE OUTPUT FILE.

WATCH:	SKIPE	XITREQ		;HAVE SNOOP. LEVEL EXIT ENABLED?
	JRST	WATCH2		;YES, DO IT DIFFERENTLY
WATCH1:	INCHWL	T1		;WAIT FOR CHARACTER
	CAIE	T1,.CHESC	;ESCAPE?
	JRST	WATCH1		;NO, WAIT FOR IT
	JRST	WATCH4		;GO DO THE EXIT
WATCH2:	MOVEI	T1,100		;SLEEP FOR
	HIBER	T1,		;  100 TICKS
	  JFCL			;DON'T CARE IF IT FAILED
	INCHSL	T1		;CHARACTER AVAILABLE?
	SKIPL	T1,XITREQ	;NO, DID SNOOP. LEVEL REQUEST EXIT?
	CAIN	T1,.CHESC	;WAS CHARACTER AN ESCAPE?
	CAIA			;YES, TO ONE
	JRST	WATCH2		;NO, TRY AGAIN
	MOVE	T1,XITCNT	;GET ADDITIONAL ENTRIES TO BE SAVED
	MOVEM	T1,MAXCNT	;STORE FOR SNOOP. LEVEL
WATCH3:	SKIPG	MAXCNT		;DONE THEM ALL YET?
	JRST	WATCH4		;YES
	MOVEI	T1,5		;SLEEP FOR 5
	HIBER	T1,		;  TICKS TO LET SNOOP. LEVEL FILL THEM
	  JFCL			;DON'T CARE
	JRST	WATCH3		;CONTINUE WATCHING
WATCH4:	REMBRK			;REMOVE BREAKPOINTS
	UNDBRK			;UNDEFINE THEM
	MOVE	P1,CNT		;GET COUNT OF ENTRIES STORED IN BUFFER
	JUMPE	P1,WATCH6	;QUIT NOW IF NONE
	IMULI	P1,ENTLEN	;CONVERT TO WORD COUNT
	CAIL	P1,BUFLEN	;MORE THAN 1 BUFFER FULL?
	MOVEI	P1,BUFLEN	;YES, MAKE IT JUST 1 BUFFER
	MOVE	P2,BUFPTR	;GET MONITOR BUFFER POINTER
	SUBI	P2,1-ENTLEN(P1)	;BACKUP BY NUMBER OF WORDS WRITTEN
	SKIPGE	P2		;OFF THE BEGINNING OF THE BUFFER?
	ADDI	P2,BUFLEN	;YES, WRAP AROUND TO THE END

WATCH5:	PUSHJ	P,NXTWRD	;GET NEXT WORD
	PUSHJ	P,WRTWRD	;WRITE IT TO OUTPUT FILE
	SOJG	P1,WATCH5	;DO THEM ALL
WATCH6:	CLOSE	D,		;CLOSE FILE
	EXIT			;AND EXIT
	SUBTTL	INITIALIZATION ERROR PROCESSING CODE


NOOPEN:	OUTSTR	[ASCIZ/
?Can't OPEN output channel.  Have you assigned logical device RNXTRC?
/]
	EXIT
NOENTR:	OUTSTR	[ASCIZ/
?Can't ENTER output file RNXTRC.BIN[-]
/]
	EXIT
NOTRPS:	OUTSTR	[ASCIZ/
?TRPSET failed.  Are you privileged?
/]
	EXIT
OUTERR:	OUTSTR	[ASCIZ/
?Output error writing file
/]
	EXIT
	SUBTTL	SUPPORT SUBROUTINES


;ROUTINE TO UPDATE THE BUFFER TAKER POINTER TO THE NEXT WORD IN THE
;BUFFER AND RETURN THAT WORD TO THE CALLER.
;CALL:	P2/CURRENT BUFFER POINTER
;	PUSHJ	P,NXTWRD
;RETURN+1 ALWAYS WITH:
;	P2/UPDATED BUFFER POINTER
;	T1/CONTENTS OF BUFFER WORD

NXTWRD:	AOS	P2		;INCREMENT BUFFER POINTER
	CAIL	P2,BUFLEN	;OFF THE END?
	MOVEI	P2,0		;YES, RESET IT
	MOVE	T1,BUFFER(P2)	;GET CONTENTS OF THAT WORD
CPOPJ:	POPJ	P,		;RETURN


;ROUTINE TO WRITE ONE WORD TO THE OUTPUT FILE.
;CALL:	T1/WORD TO WRITE
;	PUSHJ	P,WRTWRD
;RETURN+1 ALWAYS

WRTWRD:	SOSGE	OBUF+.BFCTR	;ROOM IN THE BUFFER?
	JRST	WRTWR1		;NO, FLUSH IT
	IDPB	T1,OBUF+.BFPTR	;STORE THE WORD IN THE BUFFER
	POPJ	P,		;RETURN
WRTWR1:	OUT	D,		;FLUSH THE BUFFER
	JRST	WRTWRD		;SUCCESSFUL, WRITE THE WORD
	CLOSE	D,		;CLOSE THE FILE
	JRST 	OUTERR		;TELL OF ERROR
	SUBTTL	STARTUP OPTION SELECTION


;ROUTINE TO ASK THE USER FOR THE STARTUP OPTIONS FOR THE PROGRAM AND
;INITIALIZE THE VARIABLES USED BY THE SNOOP LEVEL ROUTINES.
;CALL:	PUSHJ	P,STRTUP
;RETURN+1 ALWAYS

STRTUP:	SETOM	BGNONE		;INITIALIZE FIRST VARIABLE
	MOVE	T1,[BGNONE,,BGNONE+1]  ;SETUP FOR BLT
	BLT	T1,ENDONE	;DEFAULT THEM ALL
	OUTSTR	[ASCIZ/
RP20 trace program
/]
STRTU1:	OUTSTR	[ASCIZ/
Select output mode (Termination,Continuous): /]
	MOVE	T1,[IOWD 2,[EXP 'TERMIN','CONTIN']] ;SETUP LEGAL VALUES
	PUSHJ	P,GETSIX	;GET HIS ANSWER
	  JRST	STRTU1		;IT WAS ILLEGAL
	MOVEM	T1,WINDOW	;STORE
STRTU2:	OUTSTR	[ASCIZ/Use defaults (Yes,No)? /]
	MOVE	T1,[IOWD 2,[EXP 'YES   ','NO    ']] ;SETUP LEGAL VALUES
	PUSHJ	P,GETSIX	;GET HIS ANSWER
	  JRST	STRTU2		;IT WAS ILLEGAL
	JUMPE	T1,STRTU6	;GO IF HE WANTS TO USE THE DEFAULTS
STRTU3:	OUTSTR	[ASCIZ/CPU number: /]
	PUSHJ	P,GETNUM	;GET AN OCTAL NUMBER
	  JRST	STRTU3		;IT WAS ILLEGAL
	MOVEM	T1,CPUNUM	;STORE IT
STRTU4:	OUTSTR	[ASCIZ/Kontroller number: /]
	PUSHJ	P,GETNUM	;GET AN OCTAL NUMBER
	  JRST	STRTU4		;IT WAS ILLEGAL
	MOVEM	T1,KONNUM	;STORE IT
	PUSH	P,P1		;SAVE P1
	MOVSI	P1,-BPNUM	;MAKE AOBJN POINTER TO BREAKPOINT TABLES
STRTU5:	OUTSTR	[ASCIZ/Log /]	;START OF QUESTION
	OUTSTR	@EVDSCP(P1)	;TELL WHAT THIS BREAKPOINT IS
	OUTSTR	[ASCIZ/ (Yes,No)? /] ;WELL?
	MOVE	T1,[IOWD 2,[EXP 'YES   ','NO    ']] ;SETUP LEGAL VALUES
	PUSHJ	P,GETSIX	;GET THE ANSWER
	  JRST	STRTU5		;GO IF ILLEGAL
	SKIPE	T1		;NO TO THIS ONE?
	SETZM	EVFLAG(P1)	;YES, DISALLOW LOGGING
	AOBJN	P1,STRTU5	;LOOP FOR ALL
	POP	P,P1		;RESTORE P1
STRTU6:	SKIPE	WINDOW		;TERMINATION LOGIGNG?
	JRST	CPOPJ		;NO, DON'T DO RNXBPX BREAKPOINT STUFF
STRTU7:	OUTSTR	[ASCIZ/Insert SNOOP. level exit breakpoint (No,Yes)? /]
	MOVE	T1,[IOWD 2,[EXP 'NO    ','YES   ']] ;SETUP LEGAL VALUES
	PUSHJ	P,GETSIX	;GET THE ANSWER
	  JRST	STRTU7		;ILLEGAL
	SKIPN	T1		;IF NO,
	SOS	BRKBEG		;  DON'T INSERT RNXBPX BREAKPOINT
	JUMPE	T1,CPOPJ	;IF YES,
	AOS	XITREQ		;SET XITREQ TO 1 AS A FLAG
STRTU8:	OUTSTR	[ASCIZ/Number of additionl entries to record after SNOOP.
    level exit request has been detected: /]
	PUSHJ	P,GETNUM	;GET THE VALUE
	  JRST	STRTU8		;ILLEGAL
	MOVEM	T1,XITCNT	;STORE FOR LATER
	POPJ	P,		;RETURN
;ROUTINE TO READ A SIXBIT ATOM FROM THE COMMAND STRING.
;CALL:	T1/IOWD N,ADDR OF VALID SIXBIT ARGS
;	PUSHJ	P,GETSIX
;RETURN+1 IF ERROR
;RETURN+2 IF VALID ARG TYPED WITH:
;	T1/OFFSET IN TABLE OF ANSWER

GETSIX:	PUSH	P,T1		;SAVE IOWD TO LEGAL ANSWERS
	SETZB	T1,T2		;CLEAR RESULT AND FLAGS
	MOVE	T4,[POINT 6,T2] ;SETUP BYTE POINTER TO RESULT
GETSI1:	PUSHJ	P,GETCHR	;GET CHARACTER
	  JRST	GETSI2		;SAW END OF LINE
	CAIL	T3," "		;MUST BE A LEGAL
	CAILE	T3,"_"		;  SIXBIT CHARACTER
	PJRST	GETSI5		;FLUSH TYPEAHEAD AND RETURN
	SUBI	T3,"A"-'A'	;CONVERT TO SIXBIT
	TLNE	T4,(77B5)	;ROOM IN WORD?
	IDPB	T3,T4		;YES, STORE IT
	SKIPN	T1		;SEEN ANY CHARACTERS YET?
	TLOA	T1,(77B5)	;NO, SETUP INITIAL MASK WORD
	ASH	T1,-6		;SHIFT MASK OVER 6
	JRST	GETSI1		;AND LOOP
GETSI2:	JUMPE	T1,GETSI4	;GO IF JUST END OF LINE SEEN
	MOVE	T4,0(P)		;PUT IOWD TO TABLE IN T4
GETSI3:	MOVE	T3,1(T4)	;GET NEXT LEGAL ARGUMENT
	AND	T3,T1		;MASK ONLY THOSE CHARACTERS TYPED
	CAME	T3,T2		;MATCH?
	AOBJN	T4,GETSI3	;NO, LOOP
	JUMPGE	T4,GETSI5	;GO IF NO MATCH FOUND
	SUB	T4,0(P)		;COMPUTE OFFSET IN TABLE OF MATCH
	MOVEI	T1,(T4)		;RETURN RESULT IN T1
GETSI4:	AOSA	-1(P)		;GIVE SKIP RETURN
GETSI5:	PUSHJ	P,FLSLIN	;CLEAR TYPE AHEAD
	POP	P,(P)		;FLUSH STACK
	POPJ	P,		;RETURN
;ROUTINE TO READ AN OCTAL NUMBER FROM THE TERMINAL.
;CALL:	PUSHJ	P,GETNUM
;RETURN+1 IF ERROR
;RETURN+2 WITH NUMBER WITH:
;	T1/NUMBER

GETNUM:	SETZB	T1,T2		;T1=RESULT, T2=FLAG
GETNU1:	PUSHJ	P,GETCHR	;GET NEXT CHARACTER
	  JRST	GETNU2		;SAW END OF LINE
	CAIL	T3,"0"		;INSURE THAT IT
	CAILE	T3,"7"		;  IS OCTAL
	PJRST	FLSLIN		;NOT, CLEAR TYPEAHEAD AND RETURN ERROR
	SETOM	T2		;FLAG A CHARACTER SEEN
	LSH	T1,3		;MAKE ROOM FOR DIGIT
	IORI	T1,-"0"(T3)	;INSERT THE NEW DIGIT
	JRST	GETNU1		;LOOP FOR MORE
GETNU2:	SKIPN	T2		;SEE ANY NUMBERS AT ALL?
	SETOM	T1		;NO, SET TO DEFAULT OF -1
CPOPJ1:	AOS	(P)		;GIVE SKIP RETURN
	POPJ	P,		;RETURN


;ROUTINE TO CLEAR TYPEAHEAD WHEN AN ERROR IS DETECTED.
;CALL:	PUSHJ	P,FLSLIN
;RETURN+1 ALWAYS

FLSLIN:	CLRBFI			;CLEAR TYPEAHEAD
	POPJ	P,		;RETURN
;ROUTINE TO READ ONE CHARACTER FROM THE COMMAND STRING.  IGNORES
;SPACES, TABS, NULLS, AND CARRIAGE RETURNS.  CONVERTS LOWER TO UPPER
;CASE.
;CALL:	PUSHJ	P,GETCHR
;RETURN+1 IF END OF LINE CHARACTER SEEN
;RETURN+2 WITH CHARACTER WITH:
;	T3/CHARACTER

GETCHR:	INCHWL	T3		;GET CHARACTER
	JUMPE	T3,GETCHR	;IGNORE NULLS,
	CAIE	T3,.CHCRT	;  CARRIAGE RETURNS,
	CAIN	T3," "		;  SPACES
	JRST	GETCHR
	CAIN	T3,.CHTAB	;  AND TABS
	JRST	GETCHR
	CAIL	T3,"a"		;LOWER CASE
	CAILE	T3,"z"		;  LETTER?
	CAIA			;NO
	SUBI	T3,"a"-"A"	;YES, CONVERT TO UPPER
	PUSH	P,T3		;SAVE THE CHARACTER
	MOVEI	T3,1		;GET A BIT TO SHIFT
	LSH	T3,@0(P)	;SHIFT BY VALUE OF CHARACTER
	TDNN	T3,BRKMSK	;IS IT A BREAK CHARACTER?
	AOS	-1(P)		;YES, SET FOR SKIP RETURN
	POP	P,T3		;RETORE CHARACTER TO T3
	POPJ	P,		;RETURN

BRKMSK:	1_.CHBEL!1_.CHLFD!1_.CHVTB!1_.CHFFD!1_.CHESC
	SUBTTL	SNOOP LEVEL ROUTINES


;HERE JUST BEFORE DOING THE DATAO TO START THINGS UP AT RNXGO.

BP1:	ENTRBP	(1)		;DO BREAKPOINT SETUP
	MOVEM	%T1,BUFFER+BP1DTO(%T2) ;STORE DATAO WORD IN BUFFER
	HRRZ	%T3,%U		;GET UDB ADDRESS
	ADD	%T3,UNIBLK(%R)	;ADD OFFSET TO UNIBLK
	MOVE	%T3,(%T3)	;GET BLOCK NUMBER
	MOVEM	%T3,BUFFER+BP1BLK(%T2) ;STORE IN BUFFER
	LDB	%T3,@UNYPUN(%R)	;GET PHYSICAL UNIT NUMBER FROM UDB
	MOVEM	%T3,BUFFER+BP1UNI(%T2) ;STORE IN BUFFER
	EXITBP			;EXIT THE BREAKPOINT


;HERE WHEN AN ASYNCHRONOUS EVENT WAS DETECTED IN CHKATN.

BP2:	ENTRBP	(2)		;DO BREAKPOINT SETUP
	MOVE	%T3,-1(%P)	;GET ASYNCHRONOUS STATUS REGISTER
	MOVEM	%T3,BUFFER+BP2ASY(%T2) ;STORE IN BUFFER
	MOVSM	%P2,BUFFER+BP2ERG(%T2) ;STORE ES,,ER IN BUFFER
	MOVEM	%P3,BUFFER+BP2CNI(%T2) ;STORE CS,,CI IN BUFFER
	MOVEM	%P1,BUFFER+BP2FLG(%T2) ;STORE FLAGS WORD IN BUFFER
	EXITBP			;EXIT THE BREAKPOINT


;HERE AT INTERRUPT EXIT JUST BEFORE DISPATCHING TO FILIO

BP3:	ENTRBP	(3)		;DO BREAKPOINT SETUP
	MOVEM	%T1,BUFFER+BP3COM(%T2) ;STORE COMMUNICATION WORD
	MOVEM	%P1,BUFFER+BP3FLG(%T2) ;PLUS FLAGS WORD
	MOVSM	%P2,BUFFER+BP3ERG(%T2) ;PLUS ERROR REGISTERS
	MOVEM	%P3,BUFFER+BP3CNI(%T2) ;PLUS CONI
	EXITBP			;EXIT THE BREAKPOINT


;HERE FROM CONECT WHEN AN OPERATION IS IN PROGRESS TO PROCESS IT
;BEFORE STARTING THE NEW ONE.

BP4:	ENTRBP	(4)		;DO BREAKPOINT SETUP
	MOVEM	%T1,BUFFER+BP4COP(%T2) ;STORE FUNCTION CODE IN BUFFER
	MOVEM	%T4,BUFFER+BP4PFL(%T2) ;STORE FLAGS FOR PREVIOUS OPERATION
	LDB	%T3,@UNYPUN(%R)	;GET UNIT NUMBER OF DRIVE
	MOVEM	%T3,BUFFER+BP4UNI(%T2) ;STORE IN BUFFER
	EXITBP			;EXIT THE BREAKPOINT
;HERE WHEN CONECT DECLARES THE UNIT DOWN FOR ONE REASON OR ANOTHER.

BP5:	ENTRBP	(5)		;DO BREAKPOINT SETUP
	MOVEM	%T1,BUFFER+BP5ERB(%T2) ;STORE ERROR BITS IN BUFFER
	MOVE	%T3,-1(%P)	;GET CONI FROM STACK
	MOVEM	%T3,BUFFER+BP5CNI(%T2) ;STORE IN BUFFER
	MOVE	%T3,0(%P)	;GET ENDING STATUS,,ERROR REGISTER FROM STACK
	MOVEM	%T3,BUFFER+BP5ERG(%T2) ;STORE IN BUFFER
	LDB	%T3,@UNYPUN(%R)	;GET PHYSICAL UNIT NUMBER
	MOVEM	%T3,BUFFER+BP5UNI(%T2) ;STORE IN BUFFER
	EXITBP			;EXIT THE BREAKPOINT


;HERE WHEN FILIO TIMES OUT A TRANSFER TO CAUSE AN INTERRUPT TO
;FORCE THE RH20 TO STOP.

BP6:	ENTRBP	(6)		;DO BREAKPOINT SETUP
	MOVE	%T3,-1(%P)	;GET CONI FROM STACK
	MOVEM	%T3,BUFFER+BP6CNI(%T2) ;STORE IN BUFFER
	EXITBP			;EXIT THE BREAKPOINT


;HERE FROM THE SPECIAL SNOOP. LEVEL EXIT REQUEST BREAKPOINT.  SET
;THE VARIABLE XITREQ TO -1 SO THAT THE BACKGROUND TASK WILL REMOVE
;THE BREAKPOINTS AND LOG THIS EVENT.  NO DATA IS DEFINED FOR THIS
;EVENT (BUT MAY BE INSERTED), SO JUST ZERO THE REST OF THE BUFFER.

	DEFINE ZROBUF(N),<
	SETZM	BUFFER+N(%T2)
	>

BPX:	SETOM	XITREQ(%R)	;FLAG THE EXIT REQUEST
	ENTRBP	(^D99)		;DO BREAKPOINT SETUP FOR SPECIAL BREAKPOINT
	.ZZ==BPNHLN
	REPEAT <ENTLEN-BPNHLN>,<
	ZROBUF	(\.ZZ)
	.ZZ=.ZZ+1
	>
	EXITBP			;EXIT THE BREAKPOINT


;HERE TO EXIT FROM ALL BREAKPOINTS (CALLED BY THE EXITBP MACRO)

BPEXIT:	AOS	%T3,CNT(%R)	;INCREMENT COUNT OF ENTRIES
	HRRM	%T3,BUFFER+BPNTYP(%T2) ;STORE IN RH OF 1ST WORD
BPRET:	POP	%P,%T3		;RESTORE T3
	POP	%P,%T2		;RESTORE T2
	POPJ	%P,		;RETURN
;ROUTINE TO PERFORM INITIALIZATION COMMON TO ALL BREAKPOINTS.
;CALL:	%T2/TYPE,,0
;	PUSHJ	%P,SETUP(%R)
;RETURN+1 IF THIS EVENT SHOULD NOT BE LOGGED
;RETURN+2 TO LOG THIS EVENT WITH:
;	%T2/RELOCATED BASE ADDRESS OF BUFFER ENTRY

SETUP:	SOSL	%T3,MAXCNT(%R)	;WANT TO CONTINUE LOGGING?
	SKIPL	%T3,CPUNUM(%R)	;USER SPECIFY A PARTICULAR CPU?
	CAMN	%T3,@.CPCPN(%R)	;YES, DOES IT MATCH THIS ONE?
	CAIA			;YES, CONTINUE
	POPJ	%P,		;NO, GIVE NON-SKIP RETURN
	LDB	%T3,@KOYKNM(%R)	;GET KONTROLLER NUMBER FROM KDB
	SKIPL	KONNUM(%R)	;USER SPECIFY A PARTICULAR KONTROLLER?
	CAMN	%T3,KONNUM(%R)	;YES, DOES IT MATCH THIS ONE?
	CAIA			;YES, CONTINUE
	POPJ	%P,		;NO, GIVE NON-SKIP RETURN
	PUSH	%P,%T2		;SAVE TYPE,,LENGTH
	RDTIME	%T2		;READ CURRENT TIMEBASE
	DSUB	%T2,STIME(%R)	;SUBTRACT BASE TIME
	ASHC	%T2,-^D12	;RIGHT JUSTIFY
	MOVEI	%T2,ENTLEN	;GET LENGTH OF ENTRY
	ADDB	%T2,BUFPTR(%R)	;UPDATE BUFFER POINTER
	CAIL	%T2,BUFLEN	;OFF THE END?
	SETZB	%T2,BUFPTR(%R)	;YES, RESET TO THE BEGINNING
	ADDI	%T2,(%R)	;RELOCATE THE OFFSET
	POP	%P,BUFFER+BPNTYP(%T2) ;STORE TYPE IN BUFFER
	MOVEM	%T3,BUFFER+BPNTIM(%T2) ;ALONG WITH TIME
	LDB	%T3,@KOYKNM(%R)	;GET KONTROLLER NUMBER
	HRL	%T3,@.CPCPN(%R)	;PUT CPU NUMBER IN LH
	MOVEM	%T3,BUFFER+BPNCKU(%T2) ;STORE IN BUFFER
	AOS	0(%P)		;GIVE SKIP RETURN
	POPJ	%P,		;RETURN
	SUBTTL	DATA LOCATIONS


	XLIST			;LITERALS UNDER XLIST
	LIT
	LIST

BGNONE:				;FIRST WORD TO SET TO -1 FOR DEFAULT
				;  STARTUP OPTIONS
CPUNUM:	BLOCK	1		;CPU NUMBER OF CPU FOR WHICH DATA IS
				;  DESIRED.  -1 IF NO PARTICULAR CPU
KONNUM:	BLOCK	1		;KONTROLLER NUMBER OF KONTROLLER FOR
				;  WHICH DATA IS DESIRED.  -1 IF NO
				;  PARTICULAR KONTROLLER
EVFLAG:	BLOCK	BPNUM		;BLOCK OF FLAGS INDICATING WHETHER OR
				;  NOT TO LOG EACH BREAKPOINT. -1 TO LOG
				;  IT, 0 TO IGNORE IT.
ENDONE==.-1			;LAST WORD TO SET TO -1 FOR DEFAULT
				;  STARTUP OPTIONS

WINDOW:	EXP	0		;SET TO ZERO TO NOT WRITE ANYTHING TO
				;THE OUTPUT FILE UNTIL THE CRLF IS
				;TYPED. THEN WRITE JUST THE CURRENT
				;BUFFER
MAXCNT:	XWD	377777,777777	;NUMBER OF ENTRIES TO RECORD IN BUFFER
XITREQ:	EXP	0		;0 IF RNXBPX BREAKPOINT NOT INSERTED
				;1 IF INSERTED BUT NOT YET REACHED
				;-1 IF INSERTED AND REACHED
XITCNT:	EXP	-1		;NUMBER OF ADDITIONALY ENTRIES TO LOG
				;AFTER RNXBPX EXIT REQUEST
PDL:	BLOCK	PDLLEN		;PUSH DOWN LIST
OBUF:	BLOCK	3		;OUTPUT FILE BUFFER HEADER
STIME:	BLOCK	2		;BASE FOR RDTIME
CNT:	BLOCK	1		;SEQUENCE NUMBER/COUNT OF BUFFER ENTRIES
BUFPTR:	BLOCK	1		;POINTER TO CURRENT BUFFER LOCATION
	BLOCK	20		;ABJECT PARANOIA
BUFFER:	BLOCK	BUFLEN		;THE BUFFER
	BLOCK	20		;MORE PARANOIA


	END	RNXTRC
