	TITLE	SNOOPY - GATHERS TIMING STATISTICS V2(26)
	SUBTTL	J LEONARD/C.D. OTOOLE

	SNPORG==200000		;ORIGIN OF SNOOPY HIGH SEGMENT

	SEARCH	SNUP,UUOSYM	;GET MACROS FROM SNOOP. PACKAGE
	.REQUIR	REL:SNUP	;AND LOAD THE REL FILE
	TWOSEG	SNPORG
SNPSEG:				;START OF SNOOPY HIGH SEG DATA SEGMENT

VWHO==0
VSNOOP==2
VMINOR==0
VEDIT==26

;COPYRIGHT (C) 1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982
;  DIGITAL EQUIPMENT CORP. MAYNARD, MASS.

	LOC	137
.JBVER:	BYTE	(3)VWHO(9)VSNOOP(6)VMINOR(18)VEDIT
	RELOC	0

;REGISTERS

W=0
B=1	;BASE REGISTER TO MAKE INTERRUPT CODE SELF-RELOCATING
PC=2	;USUALLY CONTAINS INTERRUPT PC OR .JBFF
T1=3	;MUST BE SAVED, BECAUSE OF DIVIDES OF PC
T2=4	;ANOTHER TEMP
T3=5	;ANOTHER TEMP
T4=6	;ANOTHER TEMP
CH=7	;A CHARACTER,NEG IF BREAK
N=10	;NAME/NUMBER TEMP
N1=11	;AUXILLIARY
P=17	;STACK POINTER


	SALL		;CLEAN UP LISTING SOME


;EDIT 20	6.03 KEEPS MOVING .UPJOB, USE GETTABS TO FIND IT
;EDIT 21	EPT ADDRESS MOVED, USE GETTABS TO FIND IT
;EDIT 22	UPMP MAPPING MOVED, MORE GETTABS
;EDIT 23	SUPPORT MULTIPLE CPUS & ASK FOR SEPARATE DK10 DEVICE CODES
;EDIT 24	USE THE SNUP PACKAGE TO INSERT BREAKPOINTS IN KL/KS MONITORS
;		THIS REMOVES THE REQUIREMENT FOR A DK10
;EDIT 25	SUPPORT KL PAGING. ALLOW XPCW INSTEAD OF JSR, AND CHANGE SOME
;		EFFECTIVE ADDRESS LOCATIONS
;EDIT 26	MAKE WORK ON KS10 USING XPCW INSTEAD OF JSR.
COMMENT !
 
			XXXX
		       X    XX
		      X  ***  X                 XXXXX
		     X  *****  X             XXX     XX
		 XXXXX ******* XXX      XXXX           XX
		XX   X ******  XXXXXXXXX                 XX XXX
	      XX      X ****  X                            X** X
	     X        XX    XX     X                       X***X
	    X         //XXXX       X     		   XXXX
	   X         //   X      			 XX
	  X         //    X          XXXXXXXXXXXXXXXXXXX/
	  X      XXX/    X          X
	  X    X   X     X         X
	  X    X    X    X        X
	   X   X    X    X        X                     XX
	   X    X   X    X        X                  XXX  XX
	    X    XXX      X        X                X  X X  X
            X             X         X               XX X  XXXX
             X             X         XXXXXXXX\      XX   XX  X     
              XX            XX              X      X    XXXXX
	        XX            XXXX   XXXXXX/      X     XXXX
		  XXX             XX***          X     X
		     XXXXXXXXXXXXX *   *        X     X
				  *---* X     XX     X
				 *-* *   XXX X      X
				 *- *       XXX    X
				*- *X          XXXX
				*- *X  X	   XXX
			       *- *X    X             XX
			       *- *XX    X              X
			      *  *X* X    X              X
			     *  * X**  X  XXXX           X
			     *  : X**  XX     X          X
			    *  ** X** X     XX          X
			    *  **  X*  XXX   X         X
			   *  **    XX   XXXX       XXX
			  *  * *      XXXX      X     X
			 *   * *	  X     X     X
	   =======*******   * *           X     X      XXXXXXXX\
		  *         * *      /XXXXX      XXXXXXXX\      )
	     =====**********  *     X                     )  \  )
	       ====*         *     X               \   \  )XXXXX
	 ==========**********       XXXXXXXXXXXXXXXXXXXXXX


			CURSE YOU , PAGE MAPS

!
;VARIOUS CODES

INTCOD==1	;INTERRUPT SERVICE WATCH
MONCOD==2	;MONITOR WATCH
CSPCOD==3	;CUSP WATCH
JOBCOD==4	;JOB # WATCH
OPCCOD==10	;OPCODE STATISTICS COLLECTED WITH ANY OF ABOVE
UUOCOD==20	;UUO STATISTICS ON ANY BUT INT WATCH

DSK==1		;OUTPUT CHANNEL FOR HISTOGRAM DATA

IOWLEN==2000	;BASIC AMOUNT OF I/O TO DO PER OUTPUT UUO

EXEC==1B5	;0 IN PC WORD IMPLIES EXEC MODE

CLKCLR==30	;CONO CLEAR
CLKRST==1000	;CONO RESET
CLKST==40	;CONO START
CLKDON==30	;CONI DONE


OPDEF	SPCFLG	[004000,,0]	;USED TO SET PC FLAG FOR EXECUTIVE XCT
OPDEF	XJRST	[JRST 15,]	;EXTENDED JRST

CLK==0			;REAL DEVICE CODE FILLED IN, DEFINE =0 SO "IORM" WILL WORK

SECTAB==540		;OFFSET IN EPT/UPT OF SECTION MAPS
MS.SNP==36,,0		;SECTION FOR SNOOPING ON EXTENDED MONITOR
	DEFINE ASK (Q) <
	OUTSTR	[ASCIZ \Q \]
>
	DEFINE INCH <
	PUSHJ	P,INCHR		;GET NEXT CHAR, SET NEG IF BREAK
>
	DEFINE	INSIX <
	PUSHJ	P,SIXBN
>
	DEFINE	INDEC <
	PUSHJ	P,DECN
>
	DEFINE	INOCT <
	PUSHJ	P,OCTN
>
	DEFINE IGNORE <
	PUSHJ	P,INCHR
	XLIST
	JUMPGE	CH,.-1		;LOOP TO FIND BREAK CHAR
	LIST
	SALL
>
	DEFINE 	ONECH (DFLT)<
	PUSHJ	P,INCHR		;GET DISPATCH CHAR
	XLIST
	JUMPL	CH,DFLT		;SPECIAL IF BREAK CHAR FIRST
	PUSH	P,CH
	PUSHJ	P,INCHR		;IGNORE THE REST
	JUMPGE	CH,.-1		;UNTIL A BREAK FOUND
	POP	P,CH
	LIST
	SALL
>
	DEFINE	IFEGO (C,A)<
	CAIN	CH,"C"
	XLIST
	JRST	A
	LIST
	SALL
>
	DEFINE	UNKCH (ERR)<
	OUTCHR	["?"]
	XLIST
	OUTCHR	CH
	OUTSTR	[ASCIZ	/ UNKNOWN
/]
	JRST	ERR
	LIST
	SALL
>
	DEFINE	BOMB (Q)<
	JRST	[OUTSTR [ASCIZ \?Q
\]
		EXIT]
>
	DEFINE	SIZER (STRNG,NAM,%A,%B,%C,%D) <
IFDIF <NAM><MON>,<
%D:	ASK	<STRNG' SIZE IN K?>
	XLIST
	PUSHJ	P,DECN		;COLLECT DECIMAL NUMBER
	PUSHJ	P,EOL		;CHECK FOR END OF LINE
	  JRST	%D		;TRY AGAIN, FELLA
	LSH	N,^D10		;MAKE WORDS
	CAMLE	N,[1,,0]	;TEST FOR REDICULOUS
	JRST	%D		;RETRY IF SO
	MOVEM	N,NAM'MAX	;SAVE MAX SIZE
	MOVE	T1,N		;HOLD FOR DIVISION BELOW
	JUMPE	N,%A		;ZERO IS SPECIAL CASE
>; END IFDIF
%B:	ASK	<STRNG' RESOLUTION? 2**>
	PUSHJ	P,DECN		;GET RESOLUTION
	PUSHJ	P,EOL		;CHECK FOR END OF LINE
	  JRST	%B
	JUMPL	N,%B		;DONT ALLOW NEG
	CAILE	N,^D10		;KEEP UNDER A K
	JRST	%B
	MOVEI	N1,1		;2**0
	LSH	N1,(N)		;RESOLUTION
	MOVEM	N1,RES'NAM	;SAVE FOR ANALYZER
	MOVNS	N		;GET SHIFT COUNTER
	HRRM	N,NAM'RES	;SAVE IN LSH INSTR
	LSH	T1,(N)		;GET TABLE SIZE
	AOJA	T1,%C		;ALLOW ONE FOR OUT-OF-RANGE
%A:	MOVE	T1,[JRST NAM'TAB(B)] ;SKIP IF NO BREAKDOWN WANTED
	MOVEM	T1,NAM'RES	;JUST COUNT ANY AS OTHER
	MOVSI	T1,(AOS)	;NO INDEXING NEEDED
	HLLM	T1,NAM'TAB
	MOVEI	T1,1
%C:	HRRM	T1,NAM'LIM	;STORE TABLE-SIZE LIMIT
	HRRM	T1,NAM'LIM+1	;AND OUT-OF-RANGE INDEX
	MOVEM	T1,LIM'NAM	;SAVE FOR ANALYZER
	HRRM	PC,NAM'TAB	;SET ADDRESS OF TABLE
	ADDI	PC,(T1)		;START + LENGTH GIVES
	MOVEM	PC,NXTFRE	;NEW AVAILABLE CORE LOC
	LIST
	SALL
>
	DEFINE	RELOCT (LOC) <
IRP	LOC,<
	HRRZ	W,LOC
	ADDI	W,(T1)
	HRRM	W,LOC
>>
	DEFINE	ENTDEF (TYP) <
	MOVEI	T1,TRP'TYP	;NAME OF ENTRY POINT
	XLIST
	HRRM	T1,RTBLK	;SAVE IN REAL TIME BLOCK
	HRRM	T1,IXIT		;SAVE FOR RETURN
	ADDI	T1,3		;ENTRY POINT IF APR CLOCK USED
	HRRM	T1,CHNJ
	MOVEI	T1,TYP'COD	;CODE TO PASS TO ANALYZER
	MOVEM	T1,USERF	;SAVE AS FLAG
	LIST
	SALL
>
	DEFINE	TRAP <
	0
	XLIST
	CONO	CLK,CLKCLR	;MUST INCLUDE PI, TOO
	MOVEM	PC,SVPC(B)	;SAVE A REGISTER
	MOVEM	T1,SVT1(B)	;AND ANOTHER
	LIST
	SALL
>
	SUBTTL	START THE RUN

READY:	ASK	<TYPE COMMENTS<CR> TO GO:>
	MOVE	N1,[XWD 440700,COMENT]
	MOVEI	T1,^D50		;COUNTER FOR 10*5 CHARS
COMLUP:	INCH
	JUMPL	CH,WSTART	;START WHEN EOL FOUND
	IDPB	CH,N1		;BUT TILL THEN, STORE CHARS
	SOJG	T1,COMLUP	;WHILE THE BUFFER HOLDS OUT
	IGNORE
WSTART:	SETZM	BUGS		;CLEAR COUNTERS
	MOVE	T1,[XWD BUGS,BUGS+1]
	BLT	T1,@NXTFRE	;CLEAR ALL TABLES
	MSTIME	T1,		;GET STARTING TIME
	MOVEM	T1,NOW		;SAVE FOR ANALYSIS

	SKIPN	CLKFLG		;ARE WE USING DK10?
	JRST	STDK10		;YES, START IT
	SKIPLE	CLKFLG		;USING SNOOP.
	JRST	[MOVSI T1,.SOIBP ;YES, INSERT BREAKPOINTS
		 SNOOP. T1,	;DO IT
		   BOMB <CANT INSERT BREAKPOINTS>
		 JRST WSTOP]	;WE'RE RUNNING
	HRRZ	T1,CHNRST	;APR CHANNEL INT LOC
	PEEK	T1,		;SET UP BEFORE STARTING TO AVOID CRASH
	MOVEM	T1,CHNSV	;SAVE THE OLD XPCW
	HRRM	T1,CHNST	;FOR STORING FLAGS WORD TO SIMULATE XPCW
	AOJ	T1,		;GIVES ADDR OF PC
	HRRM	T1,CHNST1	;FOR STORING PC WORD TO SIMULATE XPCW
	ADDI	T1,3		;GIVE ADDRESS OF FIRST INSTRUCTION
	HRRM	T1,CHNXJ	;TO JUMP TO
	HLRZS	T1		;OPCODE IN RIGHT HALF FOR COMPARE
	CAIE	T1,(JSR)	;MAKE SURE ITS A JSR
	CAIN	T1,(XPCW)	;OR AN XPCW
	SKIPA
	BOMB	<TRAP LOC NOT A JSR OR XPCW>
	CAIE	T1,(JSR)	;IS IT AN JSR?
	JRST	WSTAR1		;NO, CONTINUE
	MOVE	T1,[JSR CHN+3]	;CHANGE TRAP LOCATION INSTRUCTION
	MOVEM	T1,TRPXPC	;...
	MOVE	T1,[SKIPA]	;REMOVE STORE OF DOUBLE WORD PC
	MOVEM	T1,CHNX1	;...
	HRRZ	T1,CHNST	;GET ADDRESS WHERE PC STORED
	SUBI	T1,3		;WHERE PC OF JSR IS STORED
	HRRM	T1,CHNST	;...
WSTAR1:	HRLZ	T1,CHNRST	;PICK UP TRAP ADDR
	TLZ	T1,777700	;MUST BE RANGE OF 40-57 (ON CORRECT CPU ALREADY)
	HRRI	T1,TRPXPC	;AND XPCW INST FOR IT
	TRPSET	T1,		;INSTALL OUR XPCW/JSR
	  BOMB	<CANT DO TRPSET>
	CAME	T1,CHNSV	;HOPEFULLY ALWAYS SKIP
	BOMB	<TRAP LOC CHANGED!!>
	SETZ	T1,
	TRPSET	T1,		;RESTART TIME-SHARING
	  BOMB	<CANT RESTART TIMESHARING>
	JRST	WSTOP		;WE'RE RUNNING

STDK10:	CONSZ	CLK,CLKST	;IS THE CLOCK RUNNING?
	BOMB	<DK10 ALREADY IN USE>
DKX.1:	CONO	CLK,CLKRST	;RESET THE CLOCK
DKX.2:	DATAO	CLK,INTRVL	;SETUP RATE
DKX.3:	CONO	CLK,CLKST(T2)	;START ON CORRECT CHANNEL
DKX.4:	CONSO	CLK,CLKST	;DID IT START?
	BOMB	<CANT START DK10> ;NO, DIE
	SUBTTL	STOP THE RUN

WSTOP:	OUTSTR	[ASCIZ /TYPE <CR> TO STOP:
/]
	SKIPE	T2,CYCLE	;ARE WE REPEATING?
	JRST	WSLEEP		;YES, SLEEP IT OFF

	IGNORE
	SKIPN	CLKFLG		;IF USING DK10
DKX.5:	CONO	CLK,CLKRST	;STOP IT
	MOVSI	T1,(SKIPA)	;ELSE MAKE INT ROUTINE SHUT DOWN
	MOVEM	T1,CHNXJ-1	;BY RESTORING TRAP LOC
	SKIPLE	CLKFLG		;USING SNOOP.
	PUSHJ	P,[MOVSI T1,.SORBP ;YES, REMOVE BREAKPOINTS
		   SNOOP. T1,	;DO IT
		     BOMB <CANT REMOVE BREAKPOINTS>
		   PUSHJ P,CLRSSU ;CLEAR SNOOP SECTION MAP IN MONITOR
		   POPJ P,]	;RETURN IN-LINE

WRHIST:	INIT	DSK,17		;WRITE TO DISK IN DUMP MODE
	SIXBIT	/DSK/
	0
	  BOMB	<CANT INIT DISK>
	HLLZS	HIST+1
	SETZM	HIST+2
	SETZM	HIST+3
	ENTER	DSK,HIST
	  JRST	E.EHST		;DESCRIBE FAILURE
	SKIPN	EXTKLM		;NORMAL HISTOGRAM?
	OUTPUT	DSK,HISTP
	SKIPE	EXTKLM		;EXTENDED SECTION HISTOGRAM?
	PUSHJ	P,DOOUT		;YES, MORE COMPLICATED
	CLOSE	DSK,
	RELEAS	DSK,
	OUTSTR	[ASCIZ	/
HISTOGRAM FILE /]
	MOVE	N,HIST
	PUSHJ	P,SIXBP		;PRINT FILE NAME
	OUTCHR	["."]
	HLLZ	N,HIST+1
	PUSHJ	P,SIXBP		;PRINT EXT
	OUTSTR	[ASCIZ	/ WRITTEN
WITH /]
	MOVEI	T1,HISTOG	 ;START OF TABLES
	SUB	T1,TABEND	;MINUS END
	SKIPE	EXTKLM		;EXTENDED WATCH?
	ADDI	T1,IOWLEN	;YES, SUBTRACT I/O BUFFER FROM THIS COUNT
	HRLZI	T1,(T1)		;GIVES NEG LENGTH OF TABLES
	SETZ	N,		;INITIALIZE COUNTER
	ADD	N,HISTOG(T1)	;ADD EM UP
	AOBJN	T1,.-1
	MOVN	T1,ARSIZE	;SIZE OF HISTOGRAM ARRAY
	HRLZS	T1		;MAKE AN AOBJN WORD
	ADD	N,SNPSEG(T1)	;ADD EM UP
	AOBJN	T1,.-1
WRHST1:	PUSHJ	P,DECPR		;PRINT THE COUNT
	OUTCHR	["/"]
	MOVE	N,TOTAL		;TOTAL OF ALL TICKS
	PUSHJ	P,DECPR
	OUTSTR	[ASCIZ / SAMPLES.
/]
	SKIPN	T2,CYCLE	;IF NOT CYCLING,
	JRST	QUIT		;THAT'S ALL THERE IS TO IT
	MOVE	T1,[XWD -3,[	POINT 6,HIST+1,17
				POINT 6,HIST+1,11
				POINT 6,HIST+1,5	]]
UPDECL:	LDB	N,0(T1)		;PICK UP LOW ORDER SIXBIT CHAR
	CAIL	N,'0'		;CHECK THAT IT'S NUMERIC
	CAILE	N,'9'
	MOVEI	N,'0'-1		;IF NOT, MAKE IT SO
	AOJ	N,		;THEN INCREMENT
	DPB	N,0(T1)		;AND STORE BACK
	CAIG	N,'9'		;BUT IF THAT CAUSED A CARRY,
	JRST	CLRTAB		;NO, IT DIDN'T
	MOVEI	N,'0'		;IF A CARRY, RESTORE ZERO, AND
	DPB	N,0(T1)		;PUT IT IN, THEN
	AOBJN	T1,UPDECL	;GO TO NEXT HIGHER DIGIT AND CARRY
	JRST	E.STOP		;UNLESS, OF COURSE, IT WAS 999

CLRTAB:	SETZM	BUGS		;CLEAR THE TABLES
	MOVE	T1,[XWD	BUGS,BUGS+1]
	BLT	T1,@NXTFRE
	SKIPN	EXTKLM		;HAVE AN EXTENDED TABLE?
	JRST	CLRTB1		;NO
	MOVE	T1,[SNPSEG,,SNPSEG+1] ;SET UP TO CLEAR HIGH SEGMENT TABLE
	SETZM	SNPSEG		;CLEAR FIRST WORD
	PUSH	P,T2		;SAVE T2
	MOVE	T2,ARSIZE	;ARRAY SIZE
	ADDI	T2,SNPSEG	;END+1
	BLT	T1,-1(T2)	;CLEAR IT
	POP	P,T2		;RESTORE T2
CLRTB1:	MSTIME	T1,
	MOVEM	T1,NOW		;RESET TIME OF DAY
	SKIPE	CLKFLG		;IF RUNNING DK10
	JRST	WSLEEP
	MOVE	T1,WCHAN	;RETART IT WITH SAME CONDITIONS
DKX.6:	DATAO	CLK,INTRVL
DKX.7:	CONO	CLK,CLKST(T1)	;SAME TIME, SAME CHANNEL

WSLEEP:	MOVE	T1,[HB.RWJ+HB.RTL+^D60000]
	MOVEI	W,^D60		;SECS TO SLEEP IF HIBER FAILS
	HIBER	T1,		;TRY HIBERNATION
	  SLEEP	W,
	SKPINL			;WAS CR TYPED?
	SOJG	T2,WSLEEP	;COUNT OUT MINUTES TO COMPLETE CYCLE
	JUMPE	T2,NOSTOP	;IS THIS STOP OR END OF MINUTE?
	SETZM	CYCLE		;TIME TO STOP
	MOVSI	T1,(SKIPA)
	MOVEM	T1,CHNXJ-1	;MAKE TRAP ROUTINE DISABLE ITSELF
	SKIPLE	CLKFLG		;USING SNOOP.
	PUSHJ	P,[MOVSI T1,.SORBP ;YES, REMOVE BREAKPOINTS
		   SNOOP. T1,	;DO IT
		     BOMB <CANT REMOVE BREAKPOINTS>
		   PUSHJ P,CLRSSU ;CLEAR SNOOP SECTION MAP IN MONITOR
		   POPJ P,]	;RETURN IN-LINE
	IGNORE
NOSTOP:	SKIPN	CLKFLG		;IF USING DK10,
DKX.8:	CONO	CLK,CLKRST	;RESET IT
	JRST	WRHIST		;AND WRITE THE TABLES

E.EHST:	OUTSTR	[ASCIZ /? ENTER FAILURE ON /]
	MOVE	N,HIST		;PRINT NAME
	PUSHJ	P,SIXBP
	OUTCHR	["."]
	HLLZ	N,HIST+1		;AND EXT
	PUSHJ	P,SIXBP
	OUTSTR	[ASCIZ /
/]
E.STOP:	MOVSI	T1,(SKIPA)
	MOVEM	T1,CHNXJ-1	;SHUT DOWN TRAP ROUTINE
QUIT:	RESET			;STOP EVERYTHING
	EXIT			;AND GO HOME

CLRSSU:	SKIPN	T1,POKARG+2	;HAVE WE CLEANED UP YET?
	POPJ	P,		;YES
	MOVEM	T1,POKARG+1	;NO, STORE CURRENT CONTENTS
	SETZM	POKARG+2	;ZAP POINTER
	MOVE	T1,[3,,POKARG]	;POINT AT IT
	POKE.	T1,		;DO IT
	  JFCL			;WE TRIED
	POPJ	P,		;RETURN
DOOUT:	MOVEI	T1,IOWLEN-<HISTOG-DATA> ;# WORDS IN FIRST BLOCK
	MOVEI	T2,SNPSEG	;SOURCE ADDRESS
	MOVEI	T3,HISTOG	;DESTINATION ADDRESS
	MOVE	T4,ARSIZE	;GET ARRAY SIZE
	SUB	T4,T1		;SUBTRACT THIS PORTION
	PUSH	P,T1		;SAVE WORD COUNT
	EXTEND	T1,[XBLT]	;COPY THE DATA
	POP	P,T1		;RESTORE WORD COUNT
	MOVNS	T1		;MAKE AN IOWD
	HRLI	T1,DATA-1	;TO THIS BUFFER
	JRST	DOOUT2		;JOIN COMMON CODE

DOOUT1:	MOVEI	T1,IOWLEN	;ASSUME A FULL BLOCK
	CAIGE	T4,IOWLEN	;AT LEAST THAT MUCH LEFT?
	MOVE	T1,T4		;NO, USE THE LESSER
	SUB	T4,T1		;SUBTRACT THIS PORTION
	MOVEI	T3,HISTOG	;DESTINATION ADDRESS
	PUSH	P,T1		;SAVE WORD COUNT
	EXTEND	T1,[XBLT]	;COPY THE DATA
	POP	P,T1		;RESTORE WORD COUNT
	MOVNS	T1		;MAKE AN IOWD
	HRLI	T1,HISTOG-1	;TO THIS BUFFER
DOOUT2:	MOVSM	T1,HISTP	;SAVE IOWD
	OUTPUT	DSK,HISTP	;WRITE A CHUNK
	JUMPG	T4,DOOUT1	;LOOP IF MORE TO DO
	POPJ	P,		;RETURN
HIST:	SIXBIT	/HIST/
	SIXBIT	/HST/
	0
	0
	0
HISTP:	IOWD	1,DATA		;LENGTH SET UP
	0

ARSIZE:	0			;SIZE OF EXTENDED HISTOGRAM ARRAY

RTBLK:	0			;GETS CHANNEL AND TRAP ADDR
	XWD	1,APRTRP	;EXEC MODE TRAP, AND ERROR ADDR
DKX.9:	CONSO	CLK,CLKDON	;HOW TO TELL ITS US
	0

OKCHAN:	-6			;-(HIGHEST USABLE CHANNEL)
BASPNT:	POINT	4,(T2),17	;TO GET INDEX REG
TRPXPC:	XPCW	CHN		;INSTR STORED IN 40+2N BY TRPSET
CHNSV:	0			;OLD CONTENTS OF 40+2N
CLKFLG:	0			;0=DK10, -1=APR CLOCK, +1=SNOOP. BREAKPOINTS
PHYADR:	0			;PHYSICAL CORE ADDRESS FROM LOCK
TABEND:	0			;END OF TABLES TO BE SUMMED
NXTFRE:	HISTOG			;CORE ALLOCATED SO FAR
MYPRIV:	0			;THIS JOB'S PRIV BITS
POKARG:	BLOCK	3		;FOR POKE. UUO

APRTRP:	0			;COME HERE ON APR TRAP IN TRAP CODE
	AOS	BUGS		;BUMP COUNTER
	JRSTF	@APRTRP

INTBLK:	XWD	3,ERRTRP	;DEFINE CONTROL C INTERCEPT
	XWD	0,-1		;HERE ON ANY TRAP
	0
	0

ERRTRP:	SKIPN	CLKFLG		;RUNNING DK10?
DKX.10:	CONO	CLK,CLKRST	;YES, STOP IT
	MOVSI	T1,(SKIPA)
	MOVEM	T1,CHNXJ-1	;SHUT OFF APR CLOCK TOO
	SKIPLE	CLKFLG		;USING SNOOP.
	PUSHJ	P,[MOVSI T1,.SORBP ;YES, REMOVE BREAKPOINTS
		   SNOOP. T1,	;DO IT
		     BOMB <CANT REMOVE BREAKPOINTS>
		   PUSHJ P,CLRSSU ;CLEAR SNOOP SECTION MAP IN MONITOR
		   POPJ P,]	;RETURN IN-LINE
	OUTSTR	[ASCIZ /SHUT DOWN/]
	RESET
	EXIT

;HERE IS THE TABLE BUILT BY SNUP MACROS

	BRKPNT	TM0IN1,0	;BREAK AT TM0IN1 (CHANGED TO PER CPU LOCATION)
				;AND BREAKPOINT INSTRUCTION (XPCW TRPxxx)
	BRKPNT	BP$001,CLRSSE	;BREAK WHEN BREAKPOINTS BEING REMOVED
INCHR:	INCHWL	CH		;GET CHAR IN CH
	CAIN	CH,15		;IF CR,
	JRST	INCHR		;LINE FEED COMES NEXT
	CAIL	CH,140		;IF  LOWER CASE,
	TRZ	CH,40		;MAKE UPPER
	CAIL	CH,12		;IF BREAK
	CAILE	CH,15
	CAIN	CH,33		;INCLUDING ALTMODE
	SETO	CH,		;MAKE NEGATIVE
	POPJ	P,		;AND RETURN

EOLC:	INCH
EOL:	JUMPL	CH,CPOPJ1	;IF BREAK,ALL OK
	IGNORE
	POPJ	P,		;OTHERWISE, TAKE ERROR EXIT
CPOPJ1:	AOS	0(P)
	POPJ	P,

SIXBP:	MOVE	N1,[POINT 6,N]
SIXBP1:	ILDB	CH,N1		;GET SIXBIT CHAR
	JUMPE	CH,CPOPJ	;QUIT ON ZERO
	ADDI	CH,40		;MAKE ASCII
	OUTCHR	CH		;PRINT IT
	TLNE	N1,(77B5)	;TEST FOR ALL SIX DONE
	JRST	SIXBP1		;LOOP TILL THEN
CPOPJ:	POPJ	P,

DECPR:	IDIVI	N,^D10		;RIGHT OUT OF THE BOOK
	HRLM	N1,(P)
	JUMPE	N,.+2		;BETTER THAN THE BOOK
	PUSHJ	P,DECPR
	HLRZ	CH,(P)
	ADDI	CH,"0"
	OUTCHR	CH
	POPJ	P,

NOREST:	OUTSTR	[ASCIZ /?SORRY, CANNOT RESTART
/]
	EXIT
	SUBTTL	REAL-TIME INTERRUPT CODE

;NOTE:	REFERENCES TO REGISTER B ARE FOR FLAG PURPOSES ONLY.
;	ALL ARE DELETED BY RELOOP, AND THE ASSOCIATED ADDRESSES RELOCATED.

TRPBEG:				;BEGINNING OF RELOCATED CODE

CHN:	0			;COME HERE ON CHANNEL N INTERRUPT
	0			;...
	0			;...
	.+1(B)			;...
	MOVEM	PC,SVPC(B)	;SAVE REGISTER
	MOVE	PC,CHN(B)	;PICK UP INTERRUPT FLAGS
CHNST:	MOVEM	PC,.-.		;STORE TO SIMULATE XPCW
CHNX1:	MOVE	PC,CHN+1(B)	;PICK UP INTERRUPT PC
CHNST1:	MOVEM	PC,.-.		;STORE TO SIMULATE XPCW
	CONSZ	APR,1B26	;IS IT APR CLOCK?
CHNJ:	JRST	.-.(B)		;YES, ENTER AT SAVE T1
CHNX:	MOVE	PC,SVPC(B)	;RESTORE-- BECOMES SKIPA TO STOP
CHNXJ:	JRST	.-.		;SIMULATE XPCW
	MOVE	PC,CHNSV(B)	;COME HERE TO STOP
CHNRST:	MOVEM	PC,.-.		;RESTORE TRAP LOC
	MOVE	PC,SVPC(B)	;RESTORE REG
	JRST	CHNXJ(B)	;NOW EXIT

TRPJOB:	TRAP
	HRRZ	T1,@CURJOB(B)	;PICK UP CURRENT JOB NO
GOWN1:	SKIPA			;CHANGED TO "CAME" IF KI-10 6.01/6.02
	  JRST	NOTJOB(B)	;OWNER OF PAGE MAP IN NOT CURRENT JOB
JOBNO:	CAIN	T1,.-.		;DESIRED NO INSERTED
	JRST	GOTHIM(B)	;THAT'S THE ONE
	LDB	PC,JOBSTS(B)	;PICK UP WAIT STATE CODE
WSTAB:	AOS	.-.(PC)		;COUNT FOR THAT STATE
	JRST	NOTJOB(B)	;GO COUNT TOTAL

JOBSTS:	POINT	5,.-.,14	;FOR JOB WAIT STATE CODE
TRPCSP:	TRAP
	HRRZ	T1,@CURJOB(B)	;CURRENT JOB NUMBER
GOWN2:	SKIPA			;CHANGED TO "CAME" IF KI-10 6.01/6.02
	  JRST	NOTJOB(B)	;OWNER OF PAGE MAP IN NOT CURRENT JOB
PRGNM1:	MOVE	PC,.-.(T1)	;PROG NAME FROM JBTPRG
	CAME	PC,LOSNAM(B)	;DESIRED PROGRAM IN LOW SEG?
	JRST	NOTJOB(B)	;NO, IGNORE IT
SEGNO1:	SKIPG	PC,.-.(T1)	;GET HIGH SEG NO, SKIP IF ANY
	JRST	GOTHIM(B)	;ISNT ONE, CANT BE WRONG ONE
PRGNM2:	MOVE	PC,.-.(PC)	;GET HIGH SEG NAME
	CAME	PC,HISNAM(B)	;RIGHT ONE?
	JRST	NOTJOB(B)	;NOPE

GOTHIM:	MOVE	PC,.-.		;PICK UP SAVED PC WORD
	HLL	PC,.-.		;FLAGS
	TLNN	PC,(EXEC)	;WAS INTERUPT FROM EXEC?
	JRST	EMODE(B)	;YES, COUNT EXEC TIME
	ANDI	PC,-1		;DROP FLAGS
	TRZE	PC,400000	;IS IT HIGH SEGMENT?
GOTHIS:	JRST	SEGNO2(B)	;YES, GO COUNT THERE
LOSADR:	HRRZ	T1,.-.(T1)	;GET LO SEG ADDR
	HRLI	T1,(POINT 9,(PC),8)
	LDB	T1,T1		;PICK UP OPCODE
OPCTBL:	AOS	.-.(T1)		;COUNT ITS USE

LOSRES:	LSH	PC,.-.		;BREAKDOWN
LOSLIM:	CAIL	PC,.-.		;IN RANGE?
	HRRZI	PC,.-.		;NO, FORCE OUT-OF-RANGE
LOSTAB:	AOS	.-.(PC)		;COUNT THE TABLE
	JRST	RSTOR(B)

SEGNO2:	HRRZ	T1,.-.(T1)	;GET HIGH SEGMENT NO
HISADR:	HRRZ	T1,.-.(T1)	;GET HIGH SEGMENT ADDR
	HRLI	T1,(POINT 9,(PC),8)
	LDB	T1,T1		;PICK UP OPCODE
OPCTBH:	AOS	.-.(T1)		;COUNT IT
HISRES:	LSH	PC,.-.		;BREAKDOWN
HISLIM:	CAIL	PC,.-.		;TEST RANGE
	HRRZI	PC,.-.		;FORCE
HISTAB:	AOS	.-.(PC)		;COUNT TABLE
	JRST	RSTOR(B)
KIUOPH:	JRST	2,@.+1(B)	;ALLOW EXECUTIVE XCT TO WORK
	 SPCFLG	.+1(B)		;LITE THE BIT
	MOVEI	T1,400000(PC)	;RE-LIGHT HIGH SEG ADDRESS
KLJSR1:	JSR	KIMAP(B)	;CHECK ADDRESSABILITY
	  JRST	HISRES(B)	;NO GOOD, SKIP OPCODE STUFF
	MOVEI	T1,400000(PC)	;RE-LIGHT HIGH SEG ADDRESS
KLXCT1:	XCT	3,KIOPLB(B)	;LOAD BYTE FROM USER CORE
	LSH	T1,-^D27	;POSITION IT
	JRST	OPCTBH(B)	;ACCUMULATE THEM
KIUOPL:	CAIG	PC,17		;SKIP A GUY RUNNING IN HIS AC'S
	  JRST	LOSRES(B)	;FORGET IT
	JRST	2,@.+1(B)	;ALLOW EXECUTIVE XCT TO WORK
	 SPCFLG	.+1(B)		;LITE THE BIT
	MOVEI	T1,(PC)		;GET USER PC IN T1
KLJSR2:	JSR	KIMAP(B)	;CHECK ADDRESSABILITY
	  JRST	LOSRES(B)	;NO GOOD, SKIP OPCODE STUFF
	MOVEI	T1,(PC)		;GET USER PC IN T1
KLXCT2:	XCT	3,KIOPLB(B)	;LOAD THE BYTE
	LSH	T1,-^D27	;WANT ONLY THE OPCODE
	JRST	OPCTBL(B)	;ACCUMULATE IN TABLE

KIOPLB:	MOVE	T1,0(T1)	;GET WORD FROM USER ADDRESSING
KIOPMP:	MAP	T1,0(T1)	;FETCH USER PAGE MAP ENTRY

;HERE TO CHECK IF ADDRESS IN "T1" CAN BE TOUCHED ( AVOID "IME" )
;	THESE ROUTINES WERE STOLEN FROM "FLTST" IN "VMSER"

KIMAP:	0			;JSR TO HERE
	XCT	3,KIOPMP(B)	;DO THE MAP
	TRNE	T1,400000
	TRNN	T1,20000
	AOS	KIMAP(B)	;OK TO TOUCH
	JRSTF	@KIMAP(B)	;RETURN EITHER WAY

;GET HERE IF WE'RE ON A KL10

KLMAP:	0			;JSR HERE TOO
	XCT	4,KIOPMP(B)	;GET MAP ENTRY
	TLNN	T1,(1B8)
	JRST	KLMAP1(B)
	TLNN	T1,(1B1)
	TLNN	T1,(1B2)
	JRSTF	@KLMAP(B)	;NO CAN TOUCH
KLMAP1:	DATAI	APR,T1		;OK SO FAR, WORRY ABOUT ADDRESS BREAK
	TLNN	T1,000700	;ADDR BREAK ON ?
	  AOS	KLMAP(B)	;NO, OK TO GET OPCODE
	JRSTF	@KLMAP(B)	;RETURN ANYWAY
EMODE:	CONI	PI,T1		;CHECK PI IN PROGRESS
PIMSK2:	TRNE	T1,77400	;TEST FOR OTHER INTERRUPTS IN PROGRESS
	JRST	NOTJOB(B)	;THIS IS STATISTICALLY IRRELEVANT
GETUU1:	LDB	T1,UUOPNT(B)	;PICK UP UUO CODE
	TRNE	T1,37		;WATCHERS BITS LIT ?
	  JRST	NOTJOB(B)	;YES, IGNORE THIS UUO
	LSH	T1,-^D9		;ISOLATE UUO NUMBER (MOD 40)
	CAIE	T1,7		;IS IT CALLI?
	JRST	UUOTBJ(B)	;NO
GTCAL1:	HRRZ	T1,40		;GET CALLI NUMBER
	TRNE	T1,400000	;NEGATIVE
	  JRST	NOTJOB(B)	;YES, REALLY OUGHT TO CATCH THOSE
	ANDI	T1,777		;ISOLATE CALLI NUMBER
	CAILE	T1,237		;RANGE CHECK
	  MOVEI	T1,237		;SAY 'TOOBIG' IN TATTLE
	ADDI	T1,40		;SKIP OVER UUO PART
UUOTBJ:	AOS	.-.(T1)
GETUPC:	HRRZ	PC,@41		;GET JOB'S PC
	TRZE	PC,400000	;HIGH SEG?
	JRST	HISRES(B)	;YES
	JRST	LOSRES(B)	;NO

TRPINT:	TRAP			;HERE TO WATCH INTERRUPT SERVICE
	CONI	PI,PC		;GET PI IN PROGRESS
PIMSK3:	ANDI	PC,77400	;STRIP OUR LEVEL AND OTHER BITS
	JFFO	PC,CNTPI(B)	;IF ANY INT IN PROGRESS, COUNT THEM
	JRST	NOTJOB(B)	;OTHERWISE, IGNORE

CNTPI:	AOS	PITAB-^D21(T1)	;BIT MUST HAVE BEEN BETWEEN 21 AND 27
	CAIE	T1,.-.		;CHECK FOR WATCHED LEVEL (MAY BE JRST)
	JRST	NOTJOB(B)
GETIPC:	HRRZ	PC,.-.		;PICK UP SAVED PC
	JRST	MONADR(B)	;GO DIVIDE IT
TRPMON:	TRAP			;ENTER HERE TO WATCH MONITOR
	CONI	PI,PC		;GET INTERRUPTS IN PROGRESS
PIMSK1:	ANDI	PC,77400	;CLEAR UNWANTED BITS, INCLUDING OURS
	JFFO	PC,CNTPI(B)	;IF ANY OTHER PI IN PROGRESS, COUNT THAT
GETMPC:	MOVE	PC,.-.		;RELOCATED FOR RIGHT PI
	HLL	PC,.-.		;FLAGS
	TLNE	PC,(EXEC)	;WAS IT IN MONITOR?
	JRST	NOTJOB(B)	;NO, IGNORE IT

GETUU2:	LDB	T1,UUOPNT(B)	;GET UUO
	TRNE	T1,37		;WATCHERS BITS SET ?
	  JRST	MONADR(B)	;YES, A FINISHED UUO
	LSH	T1,-^D9		;ISOLATE UUO CODE (MOD 40)
	CAIE	T1,7		;IS IT CALLI?
	JRST	UUOTBM(B)	;NO
GTCAL2:	HRRZ	T1,40		;GET CALLI NUMBER
	TRNE	T1,400000	;NEGATIVE
	  JRST	MONADR(B)	;YES, REALLY OUGHT TO CATCH THOSE
	ANDI	T1,777		;ISOLATE CALLI NUMBER
	CAILE	T1,237		;RANGE CHECK
	  MOVEI	T1,237		;SAY 'TOOBIG' IN TATTLE
	ADDI	T1,40		;SKIP OVER UUO PART
UUOTBM:	AOS	.-.(T1)		;COUNT UUO

MONADR:	LDB	T1,MOPCP(B)	;PICK UP OPCODE
OPCTBM:	AOS	.-.(T1)		;COUNT USE

EMODE1:	ANDI	PC,-1		;CLEAR FLAGS/SECTION NUMBER
EMODE2:	HLRZ	T1,.-.		;GET PC SECTION
SECFOO:	HRRZ	T1,.-.(T1)	;PICK UP SECTION MAP PAGE NUMBER
	LSH	T1,11		;CONVERT TO ADDRESS
	HRRM	T1,MAPPTR(B)	;STORE FOR HLRZ
	LDB	T1,MAPPT1(B)	;GET PAGE NUMBER WITHIN SECTION
	DPB	T1,MAPPT2(B)	;SET TO FETCH THAT MAP ENTRY
MAPPTR:	MOVE	T1,.-.		;GET MAP ENTRY
	TLNE	T1,(6B2)	;DIRECT POINTER?
	TDZA	T1,T1		;NO, CLEAR T1 AND SKIP
EMODE3:	HLRZ	T1,.-.		;YES, PICK UP SECTION NUMBER FROM PC
	LSH	T1,-1		;MAKE S0/S1 INTO 0, S2 INTO 1
	HRLM	T1,PC		;OFFSET PC BY SECTION CODE*RESOLUTION
MONRES:	LSH	PC,.-.		;BREAKDOWN
MONLIM:	CAIL	PC,.-.		;CHECK RANGE
	HRRZI	PC,.-.		;BRING IN RANGE
XJRENT:	JRST	MONTAB(B)	;SKIP XJRST
	XJRST	.+1(B)		;ENTER SECTION 1
XJPC1:	Z	.+1(B)		;SECTION NUMBER FILLED IN LATER
	HRLI	PC,(MS.SNP)	;SET SECTION NUMBER
MONTAB:	AOS	.-.(PC)		;COUNT
	JRST	@.+1(B)		;LEAVE SECTION 1 IF THERE
	Z	RSTOR(B)	;GETS RELOCATED

RSTOR:				;HERE WHEN ANY COUNT TAKEN
NOTJOB:	AOS	TOTAL(B)	;RECORD ALL TICKS
	MOVE	T1,SVT1(B)	;RESTORE T1
IRET:	MOVE	PC,SVPC(B)	;RESTORE PC
IXIT:	JRSTF	@.-.(B)		;DISMIS INTERRUPT

CLRSSE:	SKIPE	%T1,EPTS36(B)	;SOMETHING TO ZERO?
	SETZM	(%T1)		;YES, DO SO
	POPJ	%P,		;RETURN

MAPPT1:	POINT	9,PC,26		;PAGE NUMBER FROM PC
MAPPT2:	POINT	9,MAPPTR(B),35	;STORE INTO PAGE MAP ADDRESS

EPTS36:	0			;ZERO OR ADDRESS OF EPT MAP SLOT TO ZAP

TRPEND:				;END OF RELOCATED CODE
SVPC:	BLOCK	1		;KEEPS AC'S WHILE WE WORK
SVT1:	BLOCK	1		;WHICH KEEPS MONITOR HAPPY
CURJOB:	EXP	20		;FILLED IN LOC FOR CURRENT JOB
CURMAP:	EXP	0		;FILLED IN LOC OF PAGE MAP OWNER

MOPCP:	POINT	9,(PC),8	;FOR GETTING OPCODES FROM
				; UNRELOCATED ADDRESSES
UUOPNT:	POINT	14,40,17	;TO GET UUO CODE (MOD 40) AND WATCHERS BITS

UPTADR:	BLOCK	1		;ADDRESS OF UPMP IN EXEC ADDRESSING
PDL:	XWD	-20,.+1		;STACK POINTER
	BLOCK	20		;STACK SPACE
	XLIST	;LIT
	LIT
	LIST
	SALL

DATA:	EXP	HEADLN	;LENGHT OF DATA HEADER
CONFIG:	BLOCK	7
TODAY:	BLOCK	1
NOW:	BLOCK	1
USERF:	BLOCK	1	;TELLS WHICH BREAKDOWN WE DID
INTRVL:	BLOCK	1	;CLOCK INTERVAL
INTLVL:	BLOCK	1	;PI LEVEL WE ARE WATCHING
COMENT:	BLOCK	^D10	;OPERATOR COMMENTS

MONSTR:	BLOCK	1	;MONITOR BOOTSTRAP STRUCTURE
MONFIL:	BLOCK	1	;MONITOR BOOTSTRAP FILE NAME
MONEXT:	BLOCK	1	;MONITOR BOOTSTRAP EXTENSION
MONDIR:	BLOCK	1	;MONITOR BOOTSTRAP DIRECTORY
MONSFD:	BLOCK	5	;MONITOR BOOTSTRAP SFD LIST
RESMON:	BLOCK	1	;MONITOR RESOLUTION
LIMMON:	BLOCK	1	;MONITOR TABLE SIZE
MONMAX:	BLOCK	1	;SIZE OF MONITOR EXAMINED

LOSSTR:	BLOCK	1	;LOW SEG STRUCTURE
LOSNAM:	BLOCK	1	;LOW SEG FILE NAME
LOSEXT:	BLOCK	1	;LOW SEG EXTENSION
LOSDIR:	BLOCK	1	;LOW SEG DIRECTORY
LOSSFD:	BLOCK	5	;LOW SEG SFD LIST
RESLOS:	BLOCK	1	;LOW SEG RESOLUTION
LIMLOS:	BLOCK	1	;LOW SEG TABLE SIZE
LOSMAX:	BLOCK	1	;SIZE OF LOW SEG EXAMINED

HISSTR:	BLOCK	1	;HIGH SEG STRUCTURE
HISNAM:	BLOCK	1	;HIGH SEG FILE NAME
HISEXT:	BLOCK	1	;HIGH SEG EXTENSION
HISDIR:	BLOCK	1	;HIGH SEG DIRECTORY
HISSFD:	BLOCK	5	;HIGH SEG SFD LIST
RESHIS:	BLOCK	1	;HIGH SEG RESOLUTION
LIMHIS:	BLOCK	1	;HIGH SEG TABLE SIZE
HISMAX:	BLOCK	1	;SIZE OF HIGH SEGMENT EXAMINED

JOBNUM:	BLOCK	1	;JOB NUMBER WATCHED
WCHAN:	BLOCK	1	;PI CHANNEL ON WHICH WE'RE RUNNING
CYCLE:	BLOCK	1	;WILL BE ZERO ON LAST HISTOGRAM
CPUN:	BLOCK	1	;THE CPU WE ARE WATCHING
EXTKLM:	BLOCK	1	;-1 IF EXTENDED KL MONITOR WATCH
BUGS:	BLOCK	1	;COUNT OF APR TRAPS
TOTAL:	BLOCK	1	;TOTAL NUMBER OF INTERRUPTS TAKEN
PITAB:	BLOCK	7	;TIME IN PI SERVICE
HISTOG:			;BEGINNING OF HISTOGRAM TABLES
HEADLN==.-DATA
	SUBTTL SETUP -- ALL WIPED WHEN RUN BEGINS

WATCH:	JFCL
	RESET
	MOVE	P,PDL		;SETUP STACK
	MOVEI	PC,HISTOG	;SETUP FREE-CORE POINTER
	MOVNI	T1,6
	MOVEM	T1,OKCHAN	;RESET TO ALLOW RESTART
	SETZM	CONFIG		;CLEAR HEADER BLOCK
	MOVE	T1,[XWD CONFIG,CONFIG+1]
	BLT	T1,BUGS		;TABLES WILL BE CLEARED LATER

	MOVE	T1,[%CCTYP]	;FIND OUT WHAT TYPE OF PROCESSOR
	GETTAB	T1,		;GET IT
	  BOMB	<CANT FIND OUT WHAT KIND OF CPU THIS IS>
	CAILE	T1,1		;DON'T UNDERSTAND PDP-6'S
	CAILE	T1,5		;UNDERSTAND KA/KI/KL/KS
	BOMB	<UNKNOWN CPU TYPE>
	SETOM	KA10-2(T1)	;FLAG WHAT KIND WE ARE
	HRROI	T1,.GTPRV	;GETTAB FOR THIS JOB
	GETTAB	T1,		;GET PRIVILEGE BITS
	  SETO	T1,		;ASSUME WE'VE GOT THEM
	MOVEM	T1,MYPRIV	;SAVE
	MOVSI	T2,(JP.RTT+JP.LCK)
	SKIPE	KS10		;THIS A KS10
	MOVSI	T2,(JP.TRP+JP.LCK) ;YES, NEED TRPSET AND LOCK
	AND	T1,T2		;NEED BOTH BITS
	CAME	T1,T2		;COME OUT RIGHT
	BOMB	<SORRY, NEED PRIVILEGES>
	SETOM	CPUN		;ASSUME PRE-7.00
	MOVE	T1,[%CNCPU]	;NUMBER OF CPU'S IN CONFIG
	GETTAB	T1,		;DO 7.00 GETTAB
	  JRST	ASKCP1		;6.03 OR BEFORE
	MOVEM	T1,CPUN		;STORE FOR RANGE CHECK
	SOSN	CPUN		;UNLESS SINGLE PROCESSOR 7.00
	JRST	ASKCP1		;IT IS, AVOID QUESTION
ASKCPU:	ASK	<WHICH CPU? >
	INDEC
	PUSHJ	P,EOL
	  JRST	ASKCPU
	CAMLE	N,CPUN		;RANGE CHECK ANSWER
	JRST	ASKCPU		;ASK AGAIN
	MOVEM	N,CPUN		;REMEMBER IT
	MOVE	N,[		;CHANGE BREAKPOINT LOCATION TO CPU SPECIFIC
		RADIX50 0,TM0IN1 ;FOR CPU0
		RADIX50 0,TM1IN1 ;FOR CPU1
		RADIX50 0,TM2IN1 ;FOR CPU2
		RADIX50 0,TM3IN1 ;FOR CPU3
		RADIX50 0,TM4IN1 ;FOR CPU4
		RADIX50 0,TM5IN1 ;FOR CPU5
		](N)		;4 IS ALL MONGEN WILL ALLOW, HOWEVER ...
	MOVEM	N,BRKLST	;FOR "SNUP" TO FIND
	MOVEI	T1,1B35		;BIT FOR ONLY CPU0
	LSH	T1,@CPUN	;POSITION FOR CPUN
	HRLI	T1,.STCPU	;SET CPU SPECIFICATION
	SETUUO	T1,		;SO RTTRP WILL WORK ON RIGHT CPU
	  BOMB	<CANT SET TO RUN ONLY ON THAT CPU>
ASKCP1:	SKIPGE	N,CPUN		;GET CPU REQUESTED
	SETZ	N,		;PRE-7.00, USE CPU 0
	LSH	N,^D19		;TO LH, *2
	MOVE	T1,[.GTC0V,,.GTSLF]	;FIND CPU0 CDB VARIABLES
	ADD	T1,N		;TO CORRECT CPU
	GETTAB	T1,		;GET TABLE BASE
	  BOMB	<CANT FIND CPU SPECIFIC GETTABS>
	ADDI	T1,%CVJOB&777777 ;LOCATION OF CURRENT JOB
	HRRM	T1,CURJOB	;SO PEOPLE CAN FIND IT
	MOVE	T1,[%VMUPM]	;PER PROCESS ADDRESS OF UPMP
	GETTAB	T1,		;GET BASE
	  MOVEI	T1,340000	;PRE 7.01 (OR IGNORE ON KA-10)
	MOVEM	T1,UPTADR	;STORE FOR LATER

WATCH2:	ASK	<SNOOP ON?(INTERRUPTS, MONITOR, JOB#, CUSP)>
	ONECH	WMON		;GET FIRST CHAR, IGNORE REST
	IFEGO	I,WINT		;INTERRUPTS
	IFEGO	M,WMON		;MONITOR
	IFEGO	J,WJOB		;JOB#
	IFEGO	C,WCUSP		;CUSP
	UNKCH	WATCH2		;CANT IDENTIFY THE RESPONSE
WCUSP:	ENTDEF	(CSP)		;SETUP FOR APPROPRIATE RTTRP
	MOVE	T1,[XWD	.GTPRG,.GTSLF]
	GETTAB	T1,		;PICK UP ADDR OF PROG NAME TABLE
	  BOMB	<CANT GET JBTPRG>
	HRRM	T1,PRGNM1
	HRRM	T1,PRGNM2	;SAVE FOR LOW AND HIGH SEG NAME COMPARE
	MOVE	T1,[XWD	.GTSGN,.GTSLF]
	GETTAB	T1,
	  BOMB	<CANT GET JBTSGN>
	HRRM	T1,SEGNO1
	ASK	<LOW SEG NAME?(* IF ANY)>
	INSIX			;GET NAME IN SIXBIT
	JUMPGE	CH,NOTLNM	;NOT VALID AS A NAME: * MAYBE?
	JUMPE	N,WCUSP		;GOTTA HAVE SOMETHING
	MOVEM	N,LOSNAM	;SAVE IT
	MOVEM	N,HIST		;SAVE DEFAULT HIST FILE NAME
NHNAM:	ASK	<HIGH SEG NAME?(CR IF SAME)>
	INSIX			;GET HIGH SEG NAME IN SIXBIT
	JUMPE	N,NOTHNM	;IF NO NAME SPECIFIED
	PUSHJ	P,EOL		;ENSURE END OF LINE
	  JRST	NHNAM		;TRY AGAIN
	MOVEM	N,HISNAM
	JRST	WSIZE		;GET SEGMENT SIZES

NOTHNM:	JUMPL	CH,SAMNAM	;USE SAME NAME AS LOW SEG
	MOVE	N1,CH		;SAVE A SEC
	PUSHJ	P,EOLC		;EAT IT AND CHECK EOL
	  JRST	NHNAM		;TRY AGAIN
	CAIE	N1,"*"		;WAS IT STAR?
	JRST	NHNAM		;NO, GIVE ANOTHER CHANCE
	MOVE	T1,[JRST GOTHIM(B)]
	MOVEM	T1,SEGNO1	;IGNORE HIGH SEG COMPARES
	SETOM	HISNAM		;AND NOTE "ANY"
	JRST	WSIZE

SAMNAM:	PUSHJ	P,EOL		;ENSURE END OF LINE
	  JRST	NHNAM
	MOVE	T1,LOSNAM
	MOVEM	T1,HISNAM	;COPY LOW INTO HIGH
	JRST	WSIZE
NOTLNM:	MOVE	N1,CH		;SAVE IT A SEC
	PUSHJ	P,EOLC		;EAT * AND CHECK FOR EOL
	  JRST	WCUSP		;START OVER
	JUMPN	N,WCUSP		;DISALLOW BOTH NAME AND *
	CAIE	N1,"*"
	JRST	WCUSP		;TRY AGAIN
	SETOM	LOSNAM		;FLAG ANY
	MOVE	T1,[JRST SEGNO1(B)]
	MOVEM	T1,PRGNM1	;DISABLE LOW SEG NAME CHECK
	MOVE	T1,[JRST NOTJOB(B)]
	MOVEM	T1,SEGNO1+1	;BUT REQUIRE HIGH SEGMENT
NLHNAM:	ASK	<HIGH SEG NAME?>
	INSIX
	PUSHJ	P,EOL		;ENSURE PROPER EOL
	  JRST	NLHNAM
	JUMPE	N,NLHNAM	;GOTTA HAVE THIS
	MOVEM	N,HISNAM	;SAVE
	MOVEM	N,HIST		;SAVE DEFAULT FILE NAME
	JRST	WSIZE

WJOB:	ENTDEF	(JOB)		;SET FOR JOB HANDLER
	ASK	<JOB #?>
	INDEC			;COLLECT JOB NO
	PUSHJ	P,EOL		;CHECK FOR PROPER LINE TERMINATION
	  JRST	WJOB
	HRRM	N,JOBNO		;SAVE IN CAI INSTR
	HRRZM	N,JOBNUM	;SAVE FOR ANALYSIS
JNAME:	ASK	<NAME OF CUSP?>
	INSIX			;CUSP NAME IN SIXBIT
	PUSHJ	P,EOL
	  JRST	JNAME
	JUMPE	N,JNAME		;TRY AGAIN IF NONE GIVEN
	MOVEM	N,LOSNAM	;PASS BACK TO ANALYZER
	MOVEM	N,HISNAM
	MOVEM	N,HIST		;SAVE DEFAULT HIST FILE NAME
	MOVE	T1,[XWD	.GTSTS,.GTSLF]
	GETTAB	T1,
	  JRST	WSIZE		;CANT GET STATUS POINTER
	ADD	T1,JOBNUM	;SAVE INDEXING TIME
	HRRM	T1,JOBSTS	;STORE IN BYTE POINTER

WSIZE:	MOVEI	T1,NOREST	;DISALLOW RESTARTS
	HRRM	T1,.JBSA##
	MOVE	T1,[XWD	.GTSGN,.GTSLF]
	GETTAB	T1,
	  BOMB	<CANT GET JBTSGN>
	HRRM	T1,SEGNO2	;SAVE FOR OPCODE ACCESS
	SETCM	T1,LOSNAM	;IF WILDCARD SEGMENT NAME,
	JUMPE	T1,NOLOS	;DONT ASK THE QUESTIONS
	SIZER	(<LOW SEG>,LOS,NOLOS) ;GET SIZE AND RESOLUTION FOR LOW SEG
	MOVE	T1,LOSMAX	;GET LOW SEG MAXIMUM
	CAIG	T1,400000	;FULL ADDRESSING REQUESTED
	  JRST	REGLOW		;NO, REGULAR LOW SEGMENT
	MOVSI	T1,(SKIPA)	;GET AN INSTRUCTION
	MOVEM	T1,GOTHIS-1	;REMOVE FUNKY HIGH/LOW SEGMENT TESTS
	MOVEM	T1,GETUPC+1	;AND ASSUME FULL VM TYPE PROGRAM
	JRST	NOHIS		;THERE IS NO HIGH SEGMENT
REGLOW:	SETCM	T1,HISNAM	;IF ANY HIGH SEG ACCEPTED,
	JUMPE	T1,NOHIS	;DONT ASK
	SIZER	(<HIGH SEG>,HIS,NOHIS)

WJUUO:	ASK	<FULL MONITOR BRKDWN, OR BY UUO?(U,M)>
	ONECH	WJUUO1		;GET FIRST CHAR, IGNORE OTHERS
	IFEGO	M,WJUUO2	;M--WATCH FULL MONITOR
	IFEGO	U,WJUUO1	;U--WATCH UUO TIMES
	UNKCH	WJUUO

WJUUO1:	MOVEI	T1,UUOCOD
	IORM	T1,USERF
	MOVEM	PC,TABEND	;SET END OF HISTOGRAMS
	HRRM	PC,UUOTBJ	;SETUP UUO TABLE POINTER
	ADDI	PC,300		;LEN OF UUO TABLE
	MOVEM	PC,NXTFRE	;SAVE UPDATED AVAILABLE CORE
	JRST	ACLK		;DO NOT ASK MONITOR QUESTIONS

WJUUO2:	MOVE	T1,[JRST EMODE1(B)]
	MOVEM	T1,GETUU1	;ENABLE MONITOR TIMING FOR JOB
	JRST	WMON2
	JRST	WMON2		;GO SETUP FOR MONITOR WATCH
WINT:	ENTDEF	(INT)
	MOVE	T1,[SIXBIT /INTRPT/]
	MOVEM	T1,HIST		;SAVE DEFAULT HIST FILE NAME
	ASK	<PI LEVEL TO WATCH?(2-7 OR *)>
	INDEC			;DESIRED LEVEL
	JUMPE	N,WALLIN	;* MEANS WATCH ALL INTS
	PUSHJ	P,EOL		;DID LINE TERMINATE OK?
	  JRST	WINT		;NO, TRY AGIAN
	CAILE	N,1		;CANT BE LEVEL 1, CAUSE WE MUST BE HIGHER
	CAILE	N,7		;MUST BE LESS OR EQUAL 7 BY DEFINITION
	JRST	WINT
	MOVEM	N,INTLVL	;SAVE LEVEL FOR ANALYSIS
	MOVSI	T1,(CAIE T1,)	;FOR TESTING OUR LEVEL
	HRRI	T1,^D20(N)	;INCLUDE JFFO OFFSET
	MOVEM	T1,CNTPI+1	;SAVE AS APPROPRIATE
	MOVNI	N,(N)		;GET NEGATIVE LEVEL
	AOJ	N,		;-(LEVEL-1) FOR RTTRP REQUESTS
	MOVEM	N,OKCHAN	;SAVE FOR HIGHEST CHANNEL LOWER THAN
				; THE ONE WE WANT TO WATCH
	JRST	WMON1

WALLIN:	MOVE	N1,CH		;HOLD CHAR A SEC
	PUSHJ	P,EOLC		;WHILE WE CHECK FOR EOL NEXT
	  JRST	WINT		;NOPE, RETRY
	CAIE	N1,"*"		;IS IT "ALL"?
	JRST	WINT		;NOPE, SOMETHING WRONG
	SETOM	INTLVL		;YES, FLAG ALL WATCHED
	MOVE	T1,[JRST GETIPC(B)]
	MOVEM	T1,CNTPI+1	;SET TO MONITOR ALL INT LEVELS
	JRST	WMON1		;GO GET MONITOR SIZE, ETC.
WMON:	ENTDEF	(MON)
	MOVE	T1,[SIXBIT /MONITR/]
	MOVEM	T1,HIST		;SAVE DEFAULT FILE NAME

	ASK	<INCLUDE PI TIME?(N,Y)>
	ONECH	WMNOPI		;DEFAULT NO
	IFEGO	Y,WMPI		;YES, WATCH PI TOO
	IFEGO	N,WMNOPI	;NO
	UNKCH	WMON

WMPI:	MOVE	T1,[JRST GETIPC(B)]
	MOVEM	T1,CNTPI+1	;WHERE TO GO WHEN PI ENCOUNTERED
	SETOM	INTLVL		;NOTE WHAT WE'RE DOING
	JRST	WMON1

WMNOPI:	MOVE	T1,[JRST RSTOR(B)]
	MOVEM	T1,CNTPI+1	;IGNORE WHEN PI COUNTED
	SETZM	INTLVL		;FLAG NO PI TIME INCLUDED

WMON1:	MOVEI	T1,NOREST	;CANT RESTART
	HRRM	T1,.JBSA	;BECAUSE OF RELOCATION TECHNIQUES
	MOVSI	T1,1		;ASSUME 256K
	SKIPE	KL10		;KL10?
	LSH	T1,1		;YES, EXTENDED MACHINE NEEDS 512K
	MOVEM	T1,MONMAX	;STORE MAXIMUM
	SKIPN	KL10		;KL10?
	JRST	WMON2		;NO
	SETOM	EXTKLM		;NOTE THIS FOR LATER
WMON2:	SIZER	(<MONITOR>,MON)
	SKIPE	EXTKLM		;EXTENDED KL MONITOR WATCH?
	SUBI	PC,-IOWLEN(T1)	;YES, HISTOGRAM TABLE IS ELSEWHERE
				; (BUT I/O BUFFER FOLLOWS IT)
	MOVEM	PC,NXTFRE	;THIS MAY HAVE CHANGED
	MOVEM	PC,TABEND	;SAVE TO COUNT TABLES

	MOVE	T1,MONMAX	;GET MAXIMUM SIZE
	IDIV	T1,RESMON	;WORDS NEEDED FOR ARRAY
	SKIPE	EXTKLM		;EXTENDED KL MONITOR WATCH?
	MOVEM	T1,ARSIZE	;YES, SAVE
	MOVE	T1,USERF
	ANDI	T1,7		;GET JUST BASIC SNOOP CODE
	CAIE	T1,MONCOD	;MONITOR WATCH?
	JRST	WMUUO3		;NO, DISABLE UUO TIMING

WMUUO:	ASK	<WATCH UUO TIMES?(N,Y)>
	ONECH	WMUUO3
	IFEGO	Y,WMUUO2		;YES, SETUP TABLES
	IFEGO	N,WMUUO3		;NO, DISABLE
	UNKCH	WMUUO

WMUUO2:	MOVEI	T1,UUOCOD
	IORM	T1,USERF	;INDICATE WHAT WE  DID
	HRRM	PC,UUOTBM	;SETUP UUO TABLE  POINTER
	ADDI	PC,300		;LEN OF UUO TABLE
	MOVEM	PC,NXTFRE
	JRST	ACLK

WMUUO3:	MOVE	T1,[JRST MONADR(B)]
	MOVEM	T1,GETUU2	;JUMP AROUND UUO CODE
ACLK:	SKIPE	KS10		;IS THIS A KS10
	JRST	APRCLK		;YES, MUST USE THE APR CLOCK
	SKIPL	CPUN		;PRE-7.00?
	JRST	CLKAGN		;NO, MAKE DK10 AN OPTION
	MOVSI	T1,(JP.TRP)	;CHECK FOR TRPSET PRIVILEGES
	TDZN	T1,MYPRIV	;CAN WE DO IT?
	JRST	TELDKX		;MUST TRY FOR THE DK10
	SKIPE	KL10		;THIS A KL10
	JRST	TELDKX		;YES, THERE IS NO APR CLOCK ON A KL

CLKAGN:	ASK	<USE DK10?(N,Y)>
	ONECH	APRCLK		;GET FIRST CHAR, DEFAULT TO NO
	IFEGO	Y,WDEVCD	;YES, GET DEVICE CODE TO USE
	IFEGO	N,APRCLK	;NO, USE APR CLOCK
	UNKCH	CLKAGN		;TRY AGAIN

APRCLK:	MOVSI	T1,(JP.TRP)	;CHECK FOR TRPSET PRIVS
	TDZN	T1,MYPRIV	;CAN WE DO IT
	BOMB	<SORRY, NEED PRIVILEGES>
	MOVE	T1,[%CNSTS]
	GETTAB	T1,		;PICK UP STATES WORD TO GET FREQ
	  SETZ	T1,		;UNLIKELY
	MOVEI	N,^D1667	;60 HZ IN 10'S OF USECS
	TLNE	T1,(1B6)	;IS IT 50 HZ?
	MOVEI	N,^D2000	;YES, SET 50 HZ RATE
	MOVEM	N,INTRVL	;SAVE FOR ANALYSIS
	SKIPE	KL10		;THIS A KL10
	JRST	USSNUP		;YES, NO APR CLOCK, USE BREAKPOINTS FOR INTERVAL TIMER
	SETOM	CLKFLG		;INDICATE APR CLOCK
	MOVE	T1,[JRST CHNX(B)]
	MOVEM	T1,IRET		;SETUP ALTERNATE RETURN
	SKIPN	KS10		;USING KS10
	JRST	WOPC		;READY FOR NEXT QUESTION
	MOVEI	T1,1B30		;INTERVAL TIMER INTERRUPT FLAG
	HRRM	T1,CHNJ-1	; BIT IN CONI APR,
	JRST	WOPC		;READY FOR NEXT QUESTION

USSNUP:	PUSH	P,PC		;SAVE CURRENT CORE REQUIREMENTS
	PUSHJ	P,GETINF##	;EXTRACT MONITOR SYMBOLS, FILL IN ARGUMENT BLOCK
	POP	P,PC		;GET IT BACK
	MOVSI	T1,(JSR)	;BREAK POINT INSTRUCTION IS A JSR
	HRR	T1,RTBLK	;TO CORRECT TRAP ROUTINE
	MOVEM	T1,BRKLST+1	;STORE A BREAKPOINT INSTRUCTION
	MOVSI	T2,(JFCL)	;FIRST LOCATION OF TRAP ROUTINE IS "CONO CLK,"
	MOVEM	T2,1(T1)	; GET RID OF IT
	MOVEI	T1,1		;INDICATE USING SNOOP.
	MOVEM	T1,CLKFLG	;...
	JRST	WOPC		;ASK MORE QUESTIONS
TELDKX:	OUTSTR	[ASCIZ/MUST USE THE DK-10
/]
WDEVCD:	ASK	<DK-10 DEVICE CODE (070 OR 074)? >
	INOCT
	PUSHJ	P,EOL		;ELIMINATE THE GARBAGE
	  JRST	WDEVCD		;WHOOPS!!
	CAIE	N,070		;FIRST DK-10
	CAIN	N,074		;OR SECOND DK-10
	SKIPA
	JRST	WDEVCD		;SORRY, THOSE ARE THE ONLY CHOICES
	LSH	N,^D24		;POSITION AS A DEVICE CODE
	IORM	N,STDK10	;FILL IN ALL THE INSTRUCTIONS
	IORM	N,TRPJOB+1	;...
	IORM	N,TRPCSP+1	;...
	IORM	N,TRPINT+1	;...
	IORM	N,TRPMON+1	;...
	IORM	N,DKX.1		;...
	IORM	N,DKX.2		;...
	IORM	N,DKX.3		;...
	IORM	N,DKX.4		;...
	IORM	N,DKX.5		;...
	IORM	N,DKX.6		;...
	IORM	N,DKX.7		;...
	IORM	N,DKX.8		;...
	IORM	N,DKX.9		;...
	IORM	N,DKX.10	;...
WINTRV:	ASK	<INTERVAL IN USEC'S?(200-1000000)>
	INDEC
	PUSHJ	P,EOL		;CHECK FOR PROPER LINE TERMINATION
	  JRST	WINTRV		;OOPS
	IDIVI	N,^D10		;IN CLOCK'S FORMAT
	CAIL	N,^D20		;CHECK RANGE
	CAILE	N,^D100000
	JRST	WINTRV		;BAD, TRY AGAIN
	MOVEM	N,INTRVL
	SETZM	CLKFLG		;INDICATE DK10 CLOCK
WOPC:	SKIPE	KA10		;THIS A KA10
	JRST	ONAKAX		;YES, JUST GET NEXT QUESTION
	SKIPE	KI10		;THIS A KI10
	JRST	ONAKIX		;YES, SKIP MAPPING DIFFERENCES

;HERE ON A KL OR KS

ONAKLX:	MOVE	T1,[XCT 4,KIOPLB(B)] ;DIFFERENT EXEC EXECUTE
	MOVEM	T1,KLXCT1	;OVER-RIDE KI-10 STYLE
	MOVEM	T1,KLXCT2	;GET THEM BOTH
	MOVE	T1,[JSR KLMAP(B)] ;PAG MAPS LOOK DIFFERENT
	MOVEM	T1,KLJSR1	;OVER-RIDE CALLS TO KI STYLE
	MOVEM	T1,KLJSR2	;...
	MOVE	T1,[CAIA]	;NO ADDRESS BREAK TO WORRY ABOUT ON THE KS
	SKIPE	KS10		;THIS A KS10
	MOVEM	T1,KLMAP1	;YES, SO SKIP THE TEST FOR ADDRESS BREAK

ONAKIX:	MOVEI	T1,424		;WHERE UUO IS STORED ON KI-10
	ADD	T1,UPTADR	;STORED IN UPT
	HRRM	T1,UUOPNT	;TELL BYTE POINTER WHICH WORD OPCODE IS IN
	MOVE	T2,[%CNST2]	;GET BITS INDICATING FEATURE TESTS
	GETTAB	T2,		;SO WE CAN TELL WHAT KIND OF uCODE
	 BOMB	<CANT GET FEATURE TEST BITS!> ;SHOULD HAVE DONE AN APRID
	TLNN	T2,(ST%KLP)	;IS THIS RUNNING WITH KL PAGING?
	 JRST	ONAKIY		;NOPE - THIS REALLY LOOKS LIKE A KI
	HRRI	T2,(POINT 14,,35);UNDER KL PAGING, OPCODE GOES IN RH.
	HRLM	T2,UUOPNT	;CHANGES ONLY BYTE WITHIN WORD (LH TO RH)
	ADDI	T1,2		;GET EFFECTIVE ADDRESS FROM WORD 426 OF UPMP
ONAKIY:	HRRM	T1,GTCAL1	;STORE
	HRRM	T1,GTCAL2	;AND THERE
	MOVE	T1,[HRRZ PC,425] ;HOW TO GET USERS PC
	ADD	T1,UPTADR	;IT'S IN THE UPMP
	MOVEM	T1,GETUPC	;OVERRIDE KA-10 STYLE @41
	MOVE	T1,[JRST KIUOPH(B)] ;HOW TO GET OPCODES ON A KI-10
	MOVEM	T1,GOTHIS	;STORE THAT
	MOVE	T1,[JRST KIUOPL(B)] ;HOW TO GET LOW SEG OPCODES
	MOVEM	T1,LOSADR+1	;STORE THAT
	MOVE	T1,[%VMUPJ]	;FIND .UPJOB IN PAGE MAP
	GETTAB	T1,		;ASK JIM
	  JRST	ONAKAX		;WHAT, NO VM
	ADD	T1,UPTADR	;ADD IN PAGE MAP OFFSET
	HRRZM	T1,CURMAP	;STORE FOR COMPARES
	MOVE	T1,[CAME T1,@CURMAP(B)]  ;HOW TO CHECK PAGE MAP OWNER
	MOVEM	T1,GOWN1	;OVERRIDE KA OR PRE 6.01 SKIPA
	MOVEM	T1,GOWN2	;GET BOTH PLACES

ONAKAX:	ASK	<WATCH OPCODE USAGE?(N,Y)>
	INCH			;GET HIS DESIRE
	JUMPL	CH,WOPCN	;DEFAULT NO
	PUSH	P,CH
	IGNORE
	POP	P,CH
	IFEGO	Y,WOPCY		;YES
	IFEGO	N,WOPCN		;NO
	UNKCH	ONAKAX		;RE-ASK
WOPCY:	MOVEI	T1,OPCCOD	;FLAG THAT OPCODES MONITORED
	IORM	T1,USERF
	HRRM	PC,OPCTBL
	HRRM	PC,OPCTBH
	HRRM	PC,OPCTBM
	ADDI	PC,1000		;TABLE LENGHT
	MOVEM	PC,NXTFRE
	MOVE	T1,[XWD	.GTADR,.GTSLF]
	GETTAB	T1,
	  BOMB	<CANT GET JBTADR>
	HRRM	T1,LOSADR
	HRRM	T1,HISADR	;SAVE FOR GETTING SEGMENT ADDRESSES
	JRST	WFILE		;CONTINUE

WOPCN:	MOVE	T1,[JRST LOSRES(B)]
	MOVEM	T1,LOSADR	;DISABLE UNWANTED CODE
	MOVE	T1,[JRST HISRES(B)]
	MOVEM	T1,GOTHIS
	MOVE	T1,[JRST EMODE1(B)]
	MOVEM	T1,MONADR

WFILE:	ASK	<OUTPUT FILE NAME? DSK:>
	INSIX			;COLLECT FILENAME
	JUMPE	N,.+2		;USE DEFAULT
	MOVEM	N,HIST		;SAVE FOR ENTER
	CAIE	CH,"."		;IS EXT COMMING?
	JRST	NOEXT		;NO, DON'T STORE NEW ONE
	INSIX			;GET EXTENSION
	TRZ	N,-1		;THREE CHARS ONLY
	MOVEM	N,HIST+1	;SAVE EXTENSION
NOEXT:	JUMPL	CH,WCYCLE	;IF EOL, LINE WAS CORRECT
	INCH			;OTHERWISE, WE'VE GOT A PROB
	JUMPGE	CH,.-1
	OUTSTR	[ASCIZ	/?WHAT?
/]
	JRST	WFILE		;GO TRY AGAIN

WCYCLE:	ASK	<CYCLE TIME?(MINUTES)>
	INDEC
	PUSHJ	P,EOL		;CHECK TERMINATOR
	  JRST	WCYCLE
	MOVEM	N,CYCLE		;ZERO = DO NOT CYCLE
	MOVNI	T2,6		;WORDS OF CONFIG INFO TO GET
CNFLUP:	MOVEI	T1,.GTCNF	;GETTAB TABLE CODE
	HRLI	T1,6(T2)
	GETTAB	T1,		;PICK UP NEXT CONFIG WORD
	  SETZ	T1,
	MOVEM	T1,CONFIG+6(T2)	;SAVE IT FOR ANALYZER
	AOJLE	T2,CNFLUP	;GET ALL 7
	DATE	T1,		;TODAY'S DATE
	MOVEM	T1,TODAY	;TIME WILL BE STORED WHEN WE START
	MOVSI	T1,-MONGTL	;LENGTH OF TABLES DRIVING MONITOR GETTAB STUFF
BTSLUP:	MOVE	T2,MONGTB(T1)	;GET A GETTAB POINTER
	GETTAB	T2,		;ASK
	  SETZ	T2,		;OLD MONITOR?
	MOVEM	T2,MONSTR(T1)	;STORE IT
	AOBJN	T1,BTSLUP	;LOOP FOR REMAINDER

	MOVE	T1,USERF	;GET OPERATION CODE
	ANDI	T1,7		;ONLY BASIC CODE
	CAIE	T1,JOBCOD	;IS IT A JOB NUMBER WATCH?
	JRST	GDATLN		;NO, DONT NEED MORE CORE
	HRRM	PC,WSTAB	;SET POINTER TO WAIT-STATE TABLE
	ADDI	PC,^D32		;ADD LENGTH OF TABLE
	MOVEM	PC,NXTFRE	;SAVE NEW FREE ADDRESS
GDATLN:	MOVEI	T1,DATA		;ADDR OF DATA BLOCK
	SUBI	T1,(PC)		;NEG LENGHT OF DATA
	HRLM	T1,HISTP	;SET FOR OUTPUT
	OUTSTR	[ASCIZ /DATA SIZE IS /]
	MOVN	N,T1		;GET POS OWRD COUNT
	PUSHJ	P,DECPR		;PRINT IN DECIMAL
	SKIPN	N,ARSIZE	;EXTENDED ARRAY?
	JRST	NOTEXT		;NOPE
	OUTCHR	["("]		;YES, INCLUDE THAT TOO
	PUSHJ	P,DECPR		;PRINT SIZE IN DECIMAL
	OUTCHR	[")"]		;CLOSE
NOTEXT:	OUTSTR	[ASCIZ / WORDS.
/]
GCORE:	CAIGE	PC,ENDSNP	;DONT REMOVE ANY CODE WITH CORE UUOS
	MOVEI	PC,ENDSNP	;...
	MOVEM	PC,.JBFF##
	CORE	PC,		;GET SOME CORE (OR GET RID OF SNUP PACKAGE)
	  BOMB	<CANT GET CORE>
	SKIPN	EXTKLM		;KL MONITOR WATCH?
	JRST	LOCKUS		;NO, PROCEED
	MOVE	T1,ARSIZE	;GET ARRAY SIZE
	CAILE	T1,<1,,0>-SNPSEG ;ROOM FOR EVERYTHING?
	BOMB	<RESOLUTION TOO SMALL>
	ADDI	T1,SNPSEG	;GET NEW HIGH-SEG END
	MOVSS	T1		;MOVE TO LH
	CORE	T1,		;EXPAND OUR HIGH SEG IF NEEDED
	  BOMB	<CANT GET HIGH SEG CORE>
	MOVEI	T1,0		;CLEAR WRITE-PROTECT FOR HIGH SEG
	SETUWP	T1,		;DO IT
	  BOMB	<CAN'T CLEAR HIGH SEG WRITE PROTECT>
	MOVE	T1,[SNPSEG,,SNPSEG+1] ;CLEAR DATA AREA (SHAREABLE HIGH SEG!)
	SETZM	SNPSEG		;...
	MOVEI	T2,SNPSEG	;CALCULATE END ADDRESS OF AREA
	ADD	T2,ARSIZE	;...
	BLT	T1,(T2)		;ZERO HIGH SEGMENT
LOCKUS:	MOVEI	T1,LK.LLS	;ASSUME JUST NEED TO LOCK LOW SEG
	SKIPE	EXTKLM		;EXTENDED HISTOGRAM ARRAY?
	HRLI	T1,(LK.HLS+LK.HNE) ;YES, LOCK HIGH SEG (NON-CONTIGUOUS)
	LOCK	T1,		;GET READY FOR THE THING
	  JRST	[OUTSTR [ASCIZ \?CANT LOCK. ERROR CODE \]
		 MOVE N,T1	;ERROR CODE TO N FOR PRINTING
		 PUSHJ P,DECPR	;REPORT IT
		 EXIT]		;AND NOW GO AWAY
	ANDI	T1,-1		;KEEP JUST LOWSEG PHYSICAL ADDRESS
	LSH	T1,^D9		;THIS IS OUR PHYSICAL ADDRESS
	MOVEM	T1,PHYADR	;SAVE IN CASE WE NEED IT
	RELOCT	<MONTAB,LOSTAB,HISTAB,CNTPI,WSTAB>
	RELOCT	<OPCTBL,OPCTBH,OPCTBM,UUOTBJ,UUOTBM>
	RELOCT	<BRKLST+1,BRKLST+3>
	MOVE	T2,[XWD TRPBEG-TRPEND,TRPBEG]	;AOBJN WORD FOR INT CODE
RELOOP:	LDB	W,BASPNT	;DOES THIS INSTR HAVE INDEX?
	CAIE	W,B		;AND IS IT REGISTER B?
	JRST	RELNXT		;IF NOT, LOOK AT NEXT
	SETZ	W,		;IF SO, CLEAR INDEX SPEC
	DPB	W,BASPNT	;BY STORING ZERO
	RELOCT	<0(T2)>		;AND MODIFY ADDR APPROPRIATELY
RELNXT:	AOBJN	T2,RELOOP	;LOOP FOR ALL INTERRUPT CODE
	SKIPN	CLKFLG		;USING APR CLOCK OR SNOOP. ?
	JRST	RTCLK		;NO, SETUP RTTRP
	SKIPG	CLKFLG		;USING SNOOP.
	JRST	GETIOT		;NO, JUST GO GET USRIOT
	MOVE	T1,[.SODBP,,BRKBEG] ;ARGS
	SNOOP.	T1,		;DEFINE THE BREAKPOINTS AFTER RELOCATION
	  BOMB	<CANT DEFINE SNOOP BREAKPOINTS>
GETIOT:	SETZ	T1,		;CLEAR
	TRPSET	T1,		;GET USRIOT
	  BOMB	<CANT GET USER IO MODE>
	CONI	APR,T2		;GET CLOCK PI ASSIGNMENT (SAME FOR ALL CPUS)
	ANDI	T2,7		;DISCARD OTHER BITS
	MOVM	T1,OKCHAN
	CAIGE	T1,(T2)		;IS THIS ENOUGH FOR DESIRED WATCH?
	BOMB	<APR PRIORITY TOO LOW>
	JUMPN	T2,RTCHAN	;OK IF ASSIGNED
	BOMB	<APR CLOCK UNASSIGNED>

RTCLK:	MOVEI	T2,1
	HRLM	T2,RTBLK+1	;SET FOR SUPER-FAST EXEC-MODE TRAPS
	HRL	T2,OKCHAN	;NO OF CHANNELS USABLE TO US
RTLOOP:	MOVE	T1,CPUN		;GET CPU NUMBER
	LSH	T1,^D9		;POSITION IT
	ADDI	T1,400000(T2)	;INSERT FLAG AND CHANNEL NUMBER
	SKIPGE	CPUN		;WAIT, IS THE PRE-7.00
	MOVEI	T1,(T2)		;YES, JUST WANT CHANNEL NUMBER
	HRLM	T1,RTBLK	;SET DESIRED CHANNEL
	MOVEI	T1,RTBLK
	RTTRP	T1,		;CAN WE GET IT?
	  AOBJN	T2,RTLOOP	;NO, TRY NEXT IF ANY LEFT
	TLZN	T2,-1		;DID WE GET ONE?
	  BOMB	<CANT GET A CHANNEL>
	MOVEI	T1,CLKCLR(T2)	;SETUP FOR CONO
	HRRM	T1,TRPJOB+1	;STORE IN PROPER CONO
	HRRM	T1,TRPCSP+1
	HRRM	T1,TRPINT+1
	HRRM	T1,TRPMON+1	;THAT SHOULD TAKE CARE OF THEM ALL
RTCHAN:	MOVEM	T2,WCHAN	;SAVE OUR CHANNEL NUMBER
	MOVEI	T1,20(T2)
	LSH	T1,1		;POINT TO ADDR OF SAVED PC FOR THIS CHAN
	SKIPGE	T2,CPUN		;GET THE CPU NUMBER
	SETZ	T2,		;PRE-7.00, GET CPU 0
	LSH	T2,1		;*2 FOR GETTAB
	ADD	T2,[%CCTOS]	;ADDRESS OF EPT
	GETTAB	T2,		;TO OFFSET 40+2*N
	  SETZ	T2,		;WHAT
	CAIL	T2,1000		;ON KA10?
	ADD	T1,T2		;OFFSET FOR .EPT MOVE
	HRRM	T1,CHNRST	;TO RESTORE CLOCK CHANNEL
	ADDI	T2,SECTAB	;OFFSET INTO SECTION MAP TABLE
	HRRM	T2,SECFOO	;STORE FOR MAP STUFF
	PEEK	T1,		;GET THE INTERRUPT INSTRUCTION
	HLRZ	T2,T1		;OPCODE
	CAIE	T2,(XPCW)	;XPCW?
	CAIN	T2,(JSR)	;NO, JSR?
	CAIA			;ONE OR THE OTHER
	  BOMB	<UNKNOWN INSTRUCTION IN INTERRUPT CHANNEL>
	CAIE	T2,(XPCW)	;WAS THE INSTRUCTION AN XPCW?
	SKIPA	T2,T1		;NO, 36 BIT PC'S
	HRRI	T2,1(T1)	;YES, 72 BIT PC'S AND THE PC IS IN THE 2ND WORD
	HRRM	T2,GOTHIM	;SAVE TO FETCH PC
	HRRM	T1,GOTHIM+1	;TO GET PC FLAGS
	HRRM	T2,GETMPC	;DEPENDING ON FUNCTION
	HRRM	T2,EMODE2	;FOR 72-BIT PC'S
	HRRM	T2,EMODE3
	HRRM	T1,GETMPC+1
	HRRM	T2,GETIPC
	MOVE	T2,WCHAN	;RESTORE T2 FOR "READY"
	MOVNI	T1,(T2)		;GET NEGATIVE CHANNEL NO
	MOVEI	W,1B20		;POSITION BIT FOR "CH 0"
	LSH	W,(T1)		;SHIFT INTO POSITION FOR THIS CHANNEL
	ANDCAM	W,PIMSK1	;CLEAR BIT FOR THIS CHANNEL
	ANDCAM	W,PIMSK2	;IN THE AND'S
	ANDCAM	W,PIMSK3

	MOVEI	T1,INTBLK	;ADDR OF CONTROL-C INTERCEPT ROUTINE
	MOVEM	T1,.JBINT##	;ENABLE IT
	SKIPN	ARSIZE		;EXTENDED ARRAY WATCH?
	JRST	READY		;NO, GO
	MOVE	T1,UPTADR	;GET UPT ADDRESS
	ADDI	T1,SECTAB	;OFFSET TO SECTION 0 MAP
	PEEK	T1,		;GET IT
	SKIPN	T1		;MAKE SURE IT'S REASONABLE
	BOMB	<CAN'T DETERMINE JOB'S SECTION 0 MAP>
	MOVEM	T1,POKARG+2	;NEW CONTENTS
	SKIPGE	T1,CPUN		;GET CPU NUMBER
	SETZ	T1,		;ASSUME ZERO
	LSH	T1,1		;FOR CDB GETTAB
	ADD	T1,[%CCTOS]	;EPT ADDRESS
	GETTAB	T1,		;ASK
	  MOVEI	T1,1000		;OLD MACHINE?
	ADDI	T1,SECTAB+<(MS.SNP)> ;OFFSET TO SECTION MAP TABLE S36 ENTRY
	MOVEM	T1,POKARG+0	;SAVE ADDRESS
	MOVEM	T1,EPTS36	;SAVE HERE FOR LATER RESTORE
	PEEK	T1,		;GET CURRENT CONTENTS
	SKIPE	T1		;REALLY SHOULD BE ZERO
	BOMB	<MONITOR S36 MAP ENTRY NON-ZERO>
	MOVE	T1,[3,,POKARG]	;POINT AT ARGUMENTS
	POKE.	T1,		;MAKE MY S36 MAP AVAILABLE IN EXEC MODE
	  BOMB	<CAN'T PATCH MONITOR S36 MAP ENTRY>
	MOVEI	T1,SNPSEG	;OFFSET INTO HIGH SEG
	HRRM	T1,MONTAB	;MAKE INTO AN AOS OF MY HIGH SEG IN MON S36
	MOVSI	T1,1		;SECTION NUMBER FOR XJRST
	HLLM	T1,XJPC1	;MAKE THIS A SECTION 1 PC
	MOVSI	T1,(JFCL)	;MAKE XJRST HAPPEN
	MOVEM	T1,XJRENT	;...
	JRST	READY		;GO
	SUBTTL	SUBROUTINES

SIXBN:	MOVE	N1,[POINT 6,N]	;BYTE POINTER FOR SIXBIT
	SETZ	N,		;CLEAR RESULT
SIXB1:	INCH			;GET A CHARACTER
	CAIL	CH,"0"		;CHECK FOR ALPHA-NUMERIC
	CAILE	CH,"Z"
	POPJ	P,
	CAILE	CH,"9"
	CAIL	CH,"A"
	JRST	.+2
	POPJ	P,
	SUBI	CH,40		;CONVERT TO SIXBIT
	TLNE	N1,(77B5)	;GOTTEN SIX CHARS?
	IDPB	CH,N1		;NO, STORE THIS ONE
	JRST	SIXB1		;AND LOOP

DECN:	SETZ	N,		;CLEAR RESULT
DEC1:	INCH
	CAIL	CH,"0"		;MAKE SURE ITS IN RANGE
	CAILE	CH,"9"
	POPJ	P,
	IMULI	N,^D10
	ADDI	N,-"0"(CH)
	JRST	DEC1		;GO FOR NEXT

OCTN:	SETZ	N,
OCT1:	INCH
	CAIL	CH,"0"
	CAILE	CH,"7"
	POPJ	P,
	LSH	N,3
	ADDI	N,-"0"(CH)
	JRST	OCT1
	XLIST			;LITS
	LIT
	LIST

KA10:	0			;-1 IF ON A KA10
KI10:	0			;DITTO FOR A KI10
KL10:	0			;DITTO
KS10:	0			;DOUBLE DITTO

MONGTB:	EXP	%CNMBS		;STRUCTURE
	EXP	%CNMBF		;FILE NAME
	EXP	%CNMBX		;EXTENSION
	EXP	%CNMBD		;DIRECTORY
	EXP	%CNSF1		;FIVE SFD'S
	EXP	%CNSF2
	EXP	%CNSF3
	EXP	%CNSF4
	EXP	%CNSF5
MONGTL==.-MONGTB		;LENGTH OF TABLE
ENDSNP:

	END	WATCH
