TITLE	BATLOG	- GALAXY-10 Batch controller log file handler
SUBTTL	C.D.O'Toole, D.P.Mastrovito /CDO/DPM 12-SEP-85


;
;
;	      COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
;     1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1986,1987.
;			ALL RIGHTS RESERVED.
;     
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.


	SEARCH	BATMAC			;BATCON SYMBOLS
	SEARCH	GLXMAC			;GALAXY SYMBOLS
	SEARCH	QSRMAC			;QUASAR SYMBOLS
	SEARCH	ORNMAC			;ORION SYMBOLS

	PROLOG	(BATLOG)		;SET UP

	%%.BAT==:%%.BAT			;FORCE VERSION INTO SYMBOL TABLE

TOPS10	<IF1,<PRINTX [Assembling GALAXY-10 BATLOG]>>
TOPS20	<IF1,<PRINTX [Assembling GALAXY-20 BATLOG]>>


	GLOB	<G$STRM,G$TIME,G$TMTX>
SUBTTL	Table of contents


;               TABLE OF CONTENTS FOR BATLOG
;
;
;                        SECTION                                   PAGE
;    1. Table of contents.........................................   2
;    2. L$HEAD - Log file header..................................   3
;    3. L$OUTC - Put a character in the log file..................   4
;    4. L$OPEN - Open a log file..................................   5
;    5. OPNERR - Log file open error routine......................   6
;    6. L$IOER - Log file I/O error routine.......................   7
;    7. Log file disposition......................................   8
;    8. NEWLOG - Generate a new log file name.....................   9
;    9. L$PLOG - Put a character in the log file with formatting..  10
;   10. L$CHKP - Checkpoint the log file..........................  11
;   11. Copy text into log file with special time stamps..........  12
;   12. Miscellaneous routines....................................  13
;   13. End.......................................................  14
SUBTTL	L$HEAD - Log file header


; Put a header at the top of the log file
;
L$HEAD::PUSHJ	P,HDRPAG		;SET UP THE HEADER PAGE
	GETLIM	S2,.JQLIM(R),UNIQ	;GET UNIQUE VALUE
	MOVEI	P1,[ASCIZ/No/]		;ASSUME NO
	CAIE	S2,%EQUNO		;IS IT UNIQUE
	   MOVEI P1,[ASCIZ/Yes/] 	;YES, SAY SO
	MOVEI	P2,[ASCIZ/No/]		;ASSUME NOT RESTARTABLE
	GETLIM	S2,.JQLIM(R),REST	;GET RESTART FIELD
	SKIPN	S1,.JBCRQ(R)		;ANY CHECKPOINT INFO
	   SKIPA			;NO..CHECK VALUE NOW
	 TXNN	S1,<BA.ORQ!BA.URQ!BA.CHK> ;WAS IT REQ OR CHKPNT
	   CAIE	S2,%EQRNO		;CHECK IF RESTARTABLE
	   MOVEI P2,[ASCIZ/Yes/] 	;RESTARTABLE.. SAY YES
	MOVEI	T4,[ASCIZ/Log/]		;DEFAULT TO LOG
	GETLIM	S1,.JQLIM(R),OUTP	;GET OUPUT VALUE
	CAIN	S1,%EQOLE		;/OUT:ERROR
	  MOVEI	T4,[ASCIZ/Error/]  	;YES
	CAIN	S1,%EQONL		;/OUT:Nolog
	  MOVEI	T4,[ASCIZ/Nolog/]  	;YES
	GETLIM	S1,.JQLIM(R),TIME	;GET TIME LIMIT
	PUSHJ	P,B$STIM##		;CONVERT TO READABLE TEXT
	GETLIM	S1,.JQLIM(R),BLOG	;GET LOG OPTIONS FOR WRITING
	MOVEI	S2,[ASCIZ/Append/]	;DEFAULT IS APPEND
	CAIN	S1,%BAPND		;APPEND..
	JRST	HEAD.1			;YES
	CAIN	S1,%BSCDE		;SUPERSEDE
	MOVEI	S2,[ASCIZ/Supersede/]	;SET TO SUPERSEDE
	CAIN	S1,%BSPOL		;OR CREATE IN SPOOL AREA
	MOVEI	S2,[ASCIZ/Spool /]	;SET SPOOL

HEAD.1:	GETLIM	S1,.JQLIM(R),OINT	;OPERATOR INTERVENTION FIELD
	MOVEI	P4,[ASCIZ/Yes/]		;ALLOWED..DEFAULT
	CAIE	S1,.OPINY		;YES
	MOVEI	P4,[ASCIZ/No/]		;NOT ALLOWED
	MOVEI	P3,[ITEXT (<Default>)]	;ASSUME NO CORE LIMIT
	SKIPE	G$CORE##		;CORE LIMITS ENFORCED ?
	MOVEI	P3,[ITEXT (<^D/.JQLIM+1(R),LHMASK/ pages>)] ;YES

	$TEXT	(L$PHDR,<			^H/[-1]/

BATCON Version	^V/[%%.BAT]/			GLXLIB Version	^V/[GLXVRS]/

	    ^R/.JQJBB(R)/ in stream ^D/G$STRM(S)/

	OUTPUT:	 ^T/(T4)/^T/TAB4/TIME-LIMIT: ^T/G$TMTX/
	UNIQUE:	 ^T/(P1)/^T/TAB4/BATCH-LOG:  ^T/(S2)/
	RESTART: ^T/(P2)/^T/TAB4/ASSISTANCE: ^T/(P4)/
	CORE:    ^I/(P3)/^T/TAB3/SEQUENCE:   ^D/.JQJBB+JIB.SQ(R),JB.SEQ/
>)

	MOVEI	T1,[ITEXT (<>)]		;ASSUME NOT /DISPOSE:RENAME FOR CTL
	MOVEI	T2,[ITEXT (<>)]		;ASSUME NOT /DISPOSE:RENAME FOR LOG

TOPS10	<				;TOPS-10 ONLY
	MOVX	S1,FP.REN		;GET RENAMED BIT
	TDNE	S1,.JQCFP+.FPINF(R)	;IS IT LIT FOR CTL ?
	MOVEI	T1,[ITEXT (< (^W/.JQCFP+.FPONM(R)/.^W/.JQCFP+.FPOXT(R)/)>)]
	TDNE	S1,.JQLFP+.FPINF(R)	;IS IT LIT FOR LOG ?
	MOVEI	T2,[ITEXT (< (^W/.JQLFP+.FPONM(R)/.^W/.JQLFP+.FPOXT(R)/)>)]
>					;END OF TOPS-10 CONDITIONAL

	TXNN	F,FL.KST		;KSYS STREAM?
	$TEXT	(L$PHDR,<
	Control file: ^F/.JQCFD(R)/^I/(T1)/^A>)
	$TEXT	(L$PHDR,<
	Log file:     ^F/.JQLFD(R)/^I/(T2)/
>)

	PUSHJ	P,U$LOGH##		;APPEND ANY SPECIAL CUSTOMER TEXT
	$RETT				;RETURN

TAB3:	ASCIZ/			/	;3 TABS
TAB4:	ASCIZ/				/ ;4 TABS


; Set up the log file header page
;
HDRPAG:	$CALL	M%GPAG			;GET A PAGE
	MOVEM	S1,.JLHDR(R)		;REMEMBER IT
	HRLI	S1,(POINT 7)		;MAKE A BYTE POINTER
	MOVEM	S1,G$TPTR##		;SAVE IT
	MOVEI	S1,<PAGSIZ*5>-1		;COMPUTE CHARACTER COUNT
	MOVEM	S1,G$TCTR##		;SAVE IT
	POPJ	P,			;RETURN


; Store a character in the log file header page
;
L$PHDR::SOSLE	G$TCTR##		;COUNT
	IDPB	S1,G$TPTR##		;SAVE CHARACTER
	$RETT				;Return
SUBTTL	L$OUTC - Put a character in the log file


L$OUTC::TXNN	R,RL.NLG		;LOG FILE AVAILABLE ?
	SKIPN	.JLIFN(R)		;IS LOG FILE OPENED ?
	$RETT				;NOPE
	PUSH	P,S1			;SAVE S1
	PUSH	P,S2			;SAVE S2
	MOVE	S2,S1			;COPY CHARACTER
	MOVE	S1,.JLIFN(R)		;GET THE IFN
	$CALL	F%OBYT			;OUTPUT CHARACTER
	SKIPT				;OUTPUT ERROR?
	MOVEM	S1,.JLECD(R)		;SAVE ERROR CODE
	POP	P,S2			;RESTORE S2
	POP	P,S1			;RESTORE S1
	SKIPF				;ANY ERRORS ?
	$RETT				;NO
	TXO	R,RL.NLG		;MARK LOG FILE UNAVAILABLE
	TXZ	R,RL.OPR!RL.DIA		;CLEAR SOME FLAGS
	$RETF				;RETURN FALSE
SUBTTL	L$OPEN - Open a log file


L$OPEN::MOVEI	S1,.JQLFD(R)		;GET LOG FILE DESCRIPTOR BLOCK
	MOVEM	S1,FOB.FD+.JLFOB(R)	;STORE IT
	MOVEI	S1,7			;7 BIT BYTES
	MOVEM	S1,FOB.CW+.JLFOB(R)	;STORE CONTROL WORD
	MOVE	S1,.JQLFP+.FPINF(R)	;GET FILE PARAMETERS
	TXNE	S1,FP.SPL		;IS THE SPOOL BIT ON ?
	JRST	OPEN.1			;YES - SKIP IN BEHALF STUFF

TOPS10	<				;TOPS-10 ONLY
	MOVEI	S1,.JLFAB(R)		;POINT TO FILE ATTRIBUTE BLOCK
	MOVEM	S1,FOB.AB+.JLFOB(R)	;SAVE
	MOVEI	S1,3			;THREE WORDS
	MOVEM	S1,.JLFAB+0(R)		;SAVE IN FAB
	MOVE	S1,[10,,.FIACT]		;10 WORDS,,ACCOUNT STRING
	MOVEI	S2,.JQACT(R)		;POINT TO STRING
	DMOVEM	S1,.JLFAB+1(R)		;SAVE
	MOVE	S1,.JQPPN(R)		;GET USER'S PPN IN BEHALF
	MOVEI	S2,0			;FOR CONSISTANCY
>					;END OF TOPS-10 CONDITIONAL

TOPS20	<				;TOPS-20 ONLY
	HRROI	S1,.JQNAM(R)		;GET POINTER TO USER'S NAME
	HRROI	S2,.JQCON(R)		;GET POINTER TO CONNECTED DIRECTORY
>					;END OF TOPS-20 CONDITIONAL

	MOVEM	S1,FOB.US+.JLFOB(R)	;SAVE PPN OR USER NAME POINTER
	MOVEM	S2,FOB.CD+.JLFOB(R)	;SAVE CONNECTED DIRECTORY (TOPS20 ONLY)
	MOVX	S1,FOB.SZ		;GET FILE OPEN BLOCK SIZE
	MOVX	T1,EQ.PRV		;LOAD PRIVILEGE FLAG
	TDNE	T1,.JQJBB+JIB.SQ(R)	;WAS IT SET ?

OPEN.1:	MOVX	S1,FOB.MZ		;USE MINIMUM SIZE BLOCK
	MOVEI	S2,.JLFOB(R)		;POINT TO THE FILE OPEN BLOCK
	MOVX	T1,<$CALL F%AOPN>	;ASSUME /BATLOG:APPEND
	SKIPE	T2,.JBCRQ(R)		;BATCH JOB RESTARTED ?
	JRST	OPEN.2			;YES - ALWAYS APPEND TO EXISTING FILE
	GETLIM	T2,.JQLIM(R),BLOG	;GET VALUE OF /BATLOG
	CAIN	T2,%BSCDE		;WAS IT SUPERCEDE ?
	MOVX	T1,<$CALL F%OOPN>	;YES - DO A SUPERCEDING OPEN

OPEN.2:	XCT	T1			;OPEN THE LOG FILE
	  JUMPF	OPNERR			;LOG FILE ERROR
	MOVEM	S1,.JLIFN(R)		;SAVE IFN

TOPS10	<				;TOPS-10 ONLY
	MOVX	S2,-1			;WE WANT THE EXACT FD
	$CALL	F%FD			;GET IT
	MOVE	S2,.FDSTR(S1)		;GET THE STRUCTURE NAME
	SKIPF				;SHOULD NEVER HAPPEN BUT...
	MOVEM	S2,.JQLFD+.FDSTR(R)	;SET IT
>					;END OF TOPS-10 CONDITIONAL

TOPS20	<				;TOPS-20 ONLY
	MOVX	S2,FI.CHN		;LOAD A FUNCTION CODE
	$CALL	F%INFO			;GET THE CHANNEL NUMBER
	HRROI	S2,.JQACT(R)		;POINT TO THE ACCOUNT STRING
	SACTF				;SET THE ACCOUNT FOR THE USER
	  JFCL				;IGNORE ERRORS
>					;END OF TOPS-20 CONDITIONAL

OPEN.3:	MOVE	S1,.JLIFN(R)		;GET THE IFN
	MOVX	S2,FI.SIZ		;LOAD FUNCTION CODE
	$CALL	F%INFO			;GET FILE SIZE
	MOVEI	T1,[ITEXT (<>)]		;ASSUME FILE IS EMPTY
	SKIPE	S1			;FILE ALREADY EXIST ?
	MOVEI	T1,[ITEXT (<^M^L^A>)]	;SEPARATE DATA FROM PREVIOUS STREAM
	$TEXT	(L$OUTC,<^I/(T1)/^T/@.JLHDR(R)/^A>) ;WRITE LOG FILE HEADER
	MOVE	S1,.JLHDR(R)		;GET HEADER PAGE ADDRESS
	$CALL	M%RPAG			;DESTROY THE PAGE

TOPS10	<				;TOPS-10 ONLY
	MOVE	T2,.JQLFD+.FDSTR(R)	;GET THE LOG FILE DEVICE
	CAMN	T2,[SIXBIT/NUL/]	;IS IT NUL: ?
>					;END OF TOPS-10 CONDITIONAL

TOPS20	<				;TOPS-20 ONLY
	MOVE	T2,.JQLFD+.FDFIL(R)	;GET THE LOG FILE DEVICE
	AND	T2,[-1,,777400]		;WAS IT NUL: ?
	CAMN	T2,[ASCII /NUL:/]	;IS IT "NUL"?
>					;END OF TOPS-20 CONDITIONAL

	TXO	F,FL.NUL		;YES - REMEMBER IT
	MOVE	S1,.JLIFN(R)		;GET THE IFN BACK
	$RETT				;AND RETURN
SUBTTL	OPNERR - Log file open error routine


OPNERR:	TXOE	F,FL.LFE		;BEEN HERE BEFORE ?
	JRST	OPNE.1			;YES - ONCE IS ENOUGH
	$WTO	(<Batch error>,<^R/.JQJBB(R)/^I/OPNTXT/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	$IDHDR	(BATLOE,<? Batch log file error - ^I/LOGERR/^A>)
	PUSHJ	P,L$GENL		;GENERATE A NEW LOG FILE NAME
	MOVX	S1,FP.DEL!FP.SPL	;GET DELETE AND SPOOL BITS
	IORM	S1,.JQLFP+.FPINF(R)	;STORE IN FLAG WORD
	PUSHJ	P,L$OPEN		;TRY TO OPEN THE TEMPORARY LOG FILE
	$IDENT	(BATTLF,<[A temporary log file ^F/.JQLFD(R)/ will be created printed and deleted]>)
	MOVX	S1,%EQOLG		;FORCE /OUTPUT:LOG
	STOLIM	S1,.JQLIM(R),OUTP	;STORE NEW VALUE
	JRST	OPNE.2			;GO TO COMMON ENDING

OPNE.1:	$WTO	(<Batch error>,<^R/.JQJBB(R)/^I/FNDLMS/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)

OPNE.2:	TXZ	R,RL.OPR!RL.DIA		;CLEAR SOME POSSIBLE FLAGS
	TXO	R,RL.JIE		;MARK JOB IN ERROR
	PJRST	CLOSJB##		;DISMISS THE JOB


OPNTXT:	ITEXT	(<^M^J^I/LOGERR/
A temporary log file will be created, printed and
deleted for this user. The job will be canceled.>)


FNDLMS:	ITEXT	(<
Log error recovery failed
^I/LOGERR/>)


LOGERR:: ITEXT	(<^E/[-1]/ for ^F/.JQLFD(R)/>)
SUBTTL	L$IOER - Log file I/O error routine


; This routine is called whenever log file error checking occurs
;
L$IOER::$WTO	(<Batch error>,<^R/.JQJBB(R)/^I/LOETXT/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	JRST	CLOSJB##		;DISMISS THE JOB

LOETXT:	ITEXT	(<
Log file output error for ^F/.JQLFD(R)/; ^E/.JLECD(R)/>)
SUBTTL	Log file disposition


; Delete an unopened log file
;
L$DLET::MOVEI	S1,FOB.SZ		;GET FOB SIZE
	MOVEI	S2,.JLFOB(R)		;GET FOB ADDRESS
	$CALL	F%DEL			;DELETE THE FILE
	JUMPT	.POPJ			;RETURN UNLESS AN ERROR OCCURED
	$WTO	(<Batch error>,<^R/.JQJBB(R)/^I/DELTXT/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	POPJ	P,			;RETURN

DELTXT:	ITEXT	(<^M^J
Cannot delete log file ^F/.JQLFD(R)/; ^E/[-1]/>)


; Reset and close log file
;
L$RREL::SKIPA	S2,[F%RREL]		;RESET/CLOSE ROUTINE


; Close log file
;
L$CLOS::MOVX	S2,F%REL		;CLOSE ROUTINE

CLOS.1:	SKIPN	S1,.JLIFN(R)		;WAS THE FILE OPENED ?
	$RETT				;NO - JUST RETURN
	$CALL	(S2)			;CLOSE THE FILE
	SETZM	.JLIFN(R)		;MARK IFN CLOSED
	SKIPT				;ERRORS CLOSING CHANNEL OR JFN ?
	$WTO	(<Batch error>,<^R/.JQJBB(R)/^I/CLSTXT/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	$RETT				;RETURN


CLSTXT:	ITEXT	(<
Errors closing ^F/.JQLFD(R)/>)
SUBTTL	L$GENL - Generate a new log file name


L$GENL::
TOPS10	<MSTIME	S1,>			;GET LOTS OF PRECISION
TOPS20	<$CALL	I%NOW>			;GET CURRENT UDT
	AND	S1,[000707,,070707]	;MAKE IT NUMERIC
	TDO	S1,[SIXBIT/B00000/]	;TURN ON SOME BITS

TOPS10	<				;TOPS-10 ONLY
	MOVEM	S1,.JQLFD+.FDNAM(R)	;SAVE FILE NAME
	MOVSI	S1,'LOG'		;GET EXTENSION
	MOVEM	S1,.JQLFD+.FDEXT(R)	;SAVE IT
	MOVE	S2,[%LDQUS]		;GET QUEUE STRUCTURE
	GETTAB	S2,			;FROM THE MONITOR
	  MOVSI	S2,'SSL'		;DEFAULT
	MOVEM	S2,.JQLFD+.FDSTR(R)	;STORE IT
	MOVE	S2,G$SPLD##		;GET PPN OF SPOOLED FILE AREA
	MOVEM	S2,.JQLFD+.FDPPN(R)	;STORE IT
	SETZM	.JQLFD+.FDPAT(R)	;TERMINATE PATH
	MOVX	S2,FDMSIZ		;GET FD LENGTH
	STORE	S2,.JQLFD+.FDLEN(R),FD.LEN ;SAVE IT
	POPJ	P,			;RETURN
>					;END OF TOPS-10 CONDITIONAL

TOPS20	<				;TOPS-20 ONLY
	HRLI	S2,(POINT 7,0)		;MAKE A BYTE POINTER
	HRRI	S2,.JQLFD+1(R)		;TO BUILD THE FILE SPEC
	MOVEM	S2,G$TPTR##		;SAVE IT
	$TEXT	(FILNAM,<PS:[SPOOL]^W/S1/.LOG^0>) ;STORE B?????
	HRRZ	S2,G$TPTR##		;GET LAST ADDRESS IN THE FILESPEC
	SUBI	S2,.JQLFD-1(R)		;ADJUST THE LENGTH OF THE BLOCK
	STORE	S2,.JQLFD(R),FD.LEN	;STORE IT
	POPJ	P,			;RETURN
>					;END OF TOPS-20 CONDITIONAL


; Character storage for TOPS-20 L$GENL
;
FILNAM:	IDPB	S1,G$TPTR##		;STORE THE BYTE
	$RETT				;RETURN
SUBTTL	L$PLOG - Put a character in the log file with formatting



; This routine will convert control characters to up-arrow format
; and handle overprinting
;
L$PLOG::CAIL	S1," "			;A CONTROL CHARACTER ?
	  JRST	PLOG.1			;NO - JUST OUTPUT IT NORMALLY
	CAXG	S1,.CHCRT		;CODES .CHTAB - .CHCRT ARE IMAGE OUTPUT
	CAXGE	S1,.CHTAB		;LINE PRINTERS KNOW ABOUT THOSE
	  SKIPA				;NOT ONE OF THOSE
	JRST	PLOG.1			;JUST OUTPUT THE CHARACTER
	HRLM	S1,(P)			;SAVE CHARACTER
	MOVEI	S1,"^"			;GET AN UP-ARROW
	PUSHJ	P,PLOG.1		;LOG IT
	HLRZ	S1,(P)			;GET THE CHARACTER
	MOVEI	S1,100(S1)		;MAKE IT READABLE ASCII
	PUSHJ	P,PLOG.1		;OUTPUT IT
	HLRZ	S1,(P)			;GET THE ORIGINAL AGAIN
	POPJ	P,			;RETURN

PLOG.1:	TXZN	F,FL.CFP		;WAS LAST CHARACTER A <CR> ?
	  JRST	PLOG.2			;NO - JUST LOG IT
	CAXG	S1,.CHFFD		;CHECK FOR <CR> NOT FOLLOWED BY EOL
	CAXGE	S1,.CHLFD		;SAME CHECK AS BELOW FOR TIME STAMP
	  SKIPA				;NOT VERTICAL MOTION
	JRST	PLOG.3			;OUTPUT THE MOTION CHARACTER
	PUSH	P,S1			;SAVE CHARACTER
	MOVX	S1,.CHTAB		;GET A <TAB>
	PUSHJ	P,L$OUTC		;LOG IT
	PUSHJ	P,L$OUTC		;AGAIN
	POP	P,S1			;RESTORE CHARACTER
	JRST	PLOG.3			;ONWARD

PLOG.2:	CAIG	S1,.CHFFD		;WAS IT A VERTICAL
	CAIGE	S1,.CHLFD		; MOTION CHARACTER ?
	  JRST	PLOG.3			;NOPE
	PUSH	P,S1			;SAVE CHARACTER
	MOVEI	S1,.CHCRT		;GET <CR>
	PUSHJ	P,L$OUTC		;LOG IT
	POP	P,S1			;RESTORE CHARACTER
	PUSHJ	P,L$OUTC		;OUTPUT THE CHARACTER
	$RETT				;AND RETURN

PLOG.3:	SKIPE	.JLTIM(R)		;NEED A TIME STAMP
	  PUSHJ	P,L$LSTP		;YES, DO IT
	CAIN	S1,.CHCRT		;IS THIS A CARRAIGE RETURN
	TXO	F,FL.CFP		;YES - MARK FOR OVERPRINTING
	PUSHJ	P,L$OUTC		;OUTPUT THE CHARACTER
	CAXG	S1,.CHFFD		;CHECK IF IT WAS VERTICAL PAPER MOTION
	CAXGE	S1,.CHLFD		;THOSE CAUSE A TIME STAMP
	  $RETT				;NO MOTION..RETURN
	SETOM	.JLTIM(R)		;NEXT LINE NEEDS A TIME STAMP
	$RETT				;RETURN
SUBTTL	L$CHKP - Checkpoint the log file


L$CHKP::SKIPN	S1,.JLIFN(R)		;IS LOG FILE OPEN ?
	  POPJ	P,			;NO - IGNORE REQUEST
	$CALL	F%CHKP			;CHECKPOINT THE FILE
	  SKIPF				;CAN'T
	$RETT				;RETURN
	MOVEM	S1,.JLECD(R)		;SAVE ERROR CODE
	$WTO	(<Batch error>,<^R/.JQJBB(R)/^I/CHKTXT/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	TXO	R,RL.NLG		;NO LOG FILE AVAILABLE
	$RETF				;RETURN FALSE

CHKTXT:	ITEXT	(<
Log file checkpoint failure.
^I/LOGERR/
Job canceled.>)
SUBTTL	Copy text into log file with special time stamps


; This routine will copy any text into the log file and stamp each line.
; Call:	MOVE	S1,$IDENT instruction to stamp line
;	MOVE	S2,byte pointer to or address of text
;	PUSHJ	P,L$COPY
;
L$COPY::$SAVE	<P1,P2>			;SAVE SOME ACS
	DMOVE	P1,S1			;COPY $IDENT AND BYTE POINTER
	HLRE	S1,P2			;GET LH
	CAIE	S1,0			;JUST ADDRESS OF TEXT ?
	CAMN	S1,[-1]			;OR TOPS-20 JUNK (-1,,ADDR) ?
	HRLI	P2,(POINT 7)		;MAKE IT A BYTE POINTER

COPY.1:	MOVE	S2,P2			;GET BYTE POINTER
	ILDB	S1,S2			;LOOK AT NEXT CHARACTER
	JUMPE	S1,.POPJ		;NO STAMP IF NO MORE CHARACTERS
	XCT	P1			;STAMP LINE

COPY.2:	ILDB	S1,P2			;GET A CHARACTER
	JUMPE	S1,.POPJ		;DONE ?
	CAIG	S1,.CHFFD		;CHECK FOR <LF>, <VT>
	CAIGE	S1,.CHLFD		; OR <FF>
	SKIPA				;NOT EOL
	JRST	COPY.1			;STAMP LINE
	CAIG	S1,"Z"+40		;ONLY ALLOW
	CAIGE	S1," "			; PRINTING CHARACTERS
	  JRST	COPY.2			;LOOP FOR MORE
	PUSHJ	P,L$OUTC		;LOG IT
	JRST	COPY.2			;LOOP FOR MORE
SUBTTL	Miscellaneous routines


; Add time stamp and line identifier
;
L$LSTP::SETZM	.JLTIM(R)		;CLEAR TIME STAMP NEEDED FLAG
	TXNE	J,JL.UML		;JOB AT MONITOR LEVEL ?
	$TEXT	(L$OUTC,<^T/G$TIME/ MONITR	^A>)
	TXNN	J,JL.UML		;JOB AT USER LEVEL ?
	$TEXT	(L$OUTC,<^T/G$TIME/ USER	^A>)
	POPJ	P,			;RETURN


; Add a CRLF
;
L$CRLF::MOVX	S1,.CHCRT		;THE CARRIAGE RETURN
	PUSHJ	P,L$PLOG		;OUTPUT IT
	MOVX	S1,.CHLFD		;AND THE LINE FEED
	PJRST	L$PLOG			;AND EXIT THROUGH PUTLOG


; Add a TAB
;
L$LTAB::MOVX	S1,.CHTAB		;AND ANOTHER ONE
	PJRST	L$PLOG			;OUTPUT THE PERIOD
SUBTTL	End


	END
