TITLE	QUOTAB - Application table for the DECsystem-10 Quota Manager
SUBTTL	R. Boardman/RCB		8-Apr-85

;
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1986,1987.  ALL RIGHTS RESERVED.
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.

	SEARCH	QUOPRM		;QUOTA DEFINITIONS
	QUODEF	(QUOTAB)	;DEFINE COMMON PARAMETERS

QUOTAB::EXP	2		;LENGTH
	EXP	INI010		;ADDRESS OF $INIT PDB
	EXP	KEY010		;ADDRESS OF TOP LEVEL $KEY PDB
QUOGVN:	EXP	GLXVRS		;GLXLIB VERSION WITH WHICH COMPILED
QUOVRN:	EXP	%%QUO		;QUOTA TABLES VERSION

FNCOPT:	BLOCK	1		;CURRENT FUNCTION BEING PARSED
PPNBLK:	BLOCK	2		;FOR PARSING WILD PPN'S

FIL.ZB:!			;START OF FILESPEC DEFAULT BLOCK
FILFOB:	BLOCK	FOB.SZ		;FOB
	EXTERN	GJFBLK		;OPRPAR'S OWN DEFAULTING FD BLOCK
FILTXT:	BLOCK	<^D68/5>+1	;ROOM FOR A FULL ASCIZ FILESPEC
FILERR:	BLOCK	^D24		;ROOM FOR A 120. CHARACTER ERROR MESSAGE
FIL.ZE:!			;END+1 OF FILESPEC DEFAULT BLOCK

ATMCPY:	BLOCK	^D24		;ROOM FOR A 120. CHARACTER ATOM BUFFER

; USER NAME BREAK MASK
NAMBRK:	777777,,777760		;BREAK ON ALL CONTROL
	777554,,001750		;ALLOW * - ? AND 0-9
	400000,,000760		;ALLOW UC A-Z
	400000,,000760		;ALLOW LC A-Z
INI010:	$INIT(KEY010)

KEY010:	$KEYDSP(KEY020,<$AHELP(<QUOTA command,>),$PREFIL(INIACT),$ACTION(FNCACT)>)
KEY020:	$STAB
	DSPTAB(NAM010,.QTADD,<ADD>)
	DSPTAB(NAM010,.QTDEL,<DELETE>)
	DSPTAB(HLP010,.QTHLP,<HELP>)
	DSPTAB(LIS010,.QTLIS,<LIST>)
	DSPTAB(NAM010,.QTMOD,<MODIFY>)
	DSPTAB(NAM010,.QTSHO,<SHOW>)
	$ETAB

INIACT:	SETZM	FNCOPT			;NO FUNCTION YET
	$RETT				;RETURN

FNCACT:	MOVE	S1,CR.RES(S2)		;GET ADDRESS OF RESULT
	HRRZ	S1,(S1)			;GET KEYWORD CODE POINTER
	HLRZ	S1,(S1)			;NOW GET THE CODE
	MOVEM	S1,FNCOPT		;SAVE FOR LATER
	$RETT				;RETURN
NAM010:	$NOISE	(NAM020,<user-id>)
NAM020:	$USER	(NAM050,<$PDATA (CM%WLA+PPNBLK),$FLAGS(CM%SDH),$ALTER(NAM030)>)
NAM030:	$QUOTE	(NAM050,,<$PREFI(P$8BIT##),$FLAGS(CM%SDH),$ALTER(NAM040)>)
NAM040:	$FIELD	(NAM050,,<$PREFI(P$8BIT##),$FLAGS(CM%SDH),$BREAK(NAMBRK)>)
NAM050:	$NOISE(,<structure>,$ACTION(NAMACT))

NAMACT:	LOAD	S1,CR.PDB(S2),RHMASK	;GET GIVEN PDB
	PUSHJ	P,P$GPDB##		;GET ADDRESS OF WORKING COPY
	MOVE	T1,FNCOPT		;GET COMMAND TYPE
	CAIN	T1,.QTADD		;ADDING?
	MOVEI	T2,ADD010		;YES
	CAIN	T1,.QTDEL		;DELETING?
	MOVEI	T2,DEL010		;YES
	CAIN	T1,.QTMOD		;MODIFYING?
	MOVEI	T2,MOD010		;YES
	CAIN	T1,.QTSHO		;OR SHOWING?
	MOVEI	T2,SHO010		;YES
	STORE	T2,PB%NXT(S1)		;POINT TO NEXT TABLE FOR PARSING
	$RETT				;RETURN
ADD010:	$DEV(ADD020,<$HELP(structure name),$FLAGS(CM%NSF!CM%PO)>)
ADD020:	$NOISE(ADD030,<Logged-in quota>)
ADD030:	$NUMBER(ADD050,^D10,,<$ACTION(SAVATM),$ALTER(ADD040)>)
ADD040:	$KEY(ADD050,ADD045,<$ACTION(SAVATM)>)
ADD045:	$STAB
	KEYTAB(.QTINF,<INFINITE>)
	$ETAB
ADD050:	$NOISE(ADD060,<Logged-out quota>)
ADD060:	$NUMBER(ADD200,^D10,,<$PDEFAUL(ATMCPY),$ALTER(ADD070)>)
ADD070:	$KEY(ADD200,ADD045)
ADD200:
IFN FTRESQ,<
	$SWITCH(ADD210,ADD205,$ALTER(ADD080))
ADD205:	$STAB
	KEYTAB(.QTRES,<RESERVED:>)
	$ETAB
ADD210:	$NUMBER(ADD080,^D10,,$DEFAULT(0))
>
ADD080:	$SWITCH(ADD090,ADD085,$ALTER(ADD100))
ADD085:	$STAB
	KEYTAB(.QTMNT,<MOUNT>)
	$ETAB
ADD090:	$SWITCH(NEXT,ADD095,<$ACTION(SHRSWT),$ALTER(ADD100)>)
ADD095:	$STAB
	KEYTAB(.QTNCR,<NOCREATE>)
	KEYTAB(.QTNWR,<NOWRITE>)
	$ETAB
ADD100:	$CRLF

SAVATM:	SETZM	ATMCPY			;NULL OUT DEFAULT STRING
	LOAD	S1,CR.COD(S2)		;GET FUNCTION TYPE
	CAIE	S1,.CMKEY		;KEYWORD?
	JRST	SAVAT1			;NO, TRY FOR NUMBER
	HLRZ	S1,@CR.RES(S2)		;YES, GET ADDRESS OF KEYWORD TEXT
	$TEXT	(<-1,,ATMCPY>,<^T/(S1)/^0>)	;COPY IT AWAY
	$RETT				;RETURN
SAVAT1:	CAIE	S1,.CMNUM		;ARE WE HERE FOR A NUMBER?
	JRST	SAVAT2			;NO, KEEP TRYING
	MOVE	S1,CR.RES(S2)		;YES, GET IT
	$TEXT	(<-1,,ATMCPY>,<^D/S1/^0>) ;ASSUME IT'S DECIMAL
	$RETT				;RETURN AFTER SAVING IT
SAVAT2:	SETZ	S2,			;CLEAR TEXT POINTER
	$RETF				;INTERNAL ERROR
DEL010:	$DEV(DEL020,<$HELP(structure name),$FLAGS(CM%NSF!CM%PO)>)
DEL020:	$CRLF

SHO010:	$DEV(SHO020,<$HELP(structure name),$FLAGS(CM%NSF!CM%PO),$ALTER(SHO030)>)
SHO020:	$CRLF
SHO030:
IFN FTRESQ,<
	$SWITCH(SHO020,SHO035,$ALTER(SHO040))
SHO035:	$STAB
	KEYTAB(.QTMNT,<MOUNT>)
	$ETAB
>
SHO040:	$CRLF($HELP(confirm to display all /MOUNT entries))
IFE FTRESQ,<
MOD010:	$DEV(MOD020,<$HELP(structure name),$FLAGS(CM%NSF!CM%PO)>)
>
IFN FTRESQ,<
MOD010:	$DEV(MOD020,<$HELP(structure name),$FLAGS(CM%NSF!CM%PO),$ALTER(MOD200)>)
MOD200:	$SWITCH(MOD100,MOD205)
MOD205:	$STAB
	KEYTAB(.QTDEF,<DEFAULT>)
	$ETAB
>
MOD020:	$NOISE(MOD030,<Logged-in quota>)
MOD030:	$NUMBER(MOD050,^D10,,<$DEFAULT(SAME),$ALTER(MOD040)>)
MOD040:	$KEY(MOD050,MOD045,<$ALTER(MOD080)>)
MOD045:	$STAB
	KEYTAB(.QTINF,<INFINITE>)
	KEYTAB(.QTSAM,<SAME>)
	$ETAB
MOD050:	$NOISE(MOD060,<Logged-out quota>)
MOD060:	$NUMBER(MOD210,^D10,,<$DEFAULT(SAME),$ALTER(MOD070)>)
MOD070:	$KEY(MOD210,MOD045)
MOD210:
IFN FTRESQ,<
	$SWITCH(MOD220,MOD215,$ALTER(MOD080))
MOD215:	$STAB
	KEYTAB(.QTDEF,<DEFAULT:>)
	$ETAB
MOD220:	$NUMBER(MOD080,^D10,,<$DEFAULT(SAME),$ALTER(MOD230)>)
MOD230:	$KEY(MOD080,MOD235)
MOD235:	$STAB
	KEYTAB(.QTSAM,<SAME>)
	$ETAB
>
MOD080:	$SWITCH(,MOD085,$ALTER(MOD090))
MOD085:	$STAB
	DSPTAB(MOD090,.QTMNT,<MOUNT>)
	DSPTAB(MOD100,.QTNMT,<NOMOUNT>)
	$ETAB
MOD090:	$SWITCH(NEXT,MOD095,<$ACTION(SHRSWT),$ALTER(MOD100)>)
MOD095:	$STAB
	KEYTAB(.QTCRE,<CREATE>)
	KEYTAB(.QTNCR,<NOCREATE>)
	KEYTAB(.QTNWR,<NOWRITE>)
	KEYTAB(.QTWRT,<WRITE>)
	$ETAB
MOD100:	$CRLF
HLP010:	$NOISE(HLP020,<with>)
HLP020:	$KEY(HLP030,KEY020,<$DEFAULT(HELP),$AHELP(<QUOTA command,>)>)
HLP030:	$CRLF($ACTION(HELPER))

HELPER:	MOVEI	S1,HELPFD		;POINT TO HELP FILE FD
	HLRO	S2,@CR.RES(S2)		;GET ADDRESS OF KEYWORD TEXT
	PUSHJ	P,P$HELP##		;READ AND TYPE HELP FILE
	PUSHJ	P,P$NPRO##		;NO PROCESSING NEEDED
	$RETT				;RETURN

HELPFD:	$BUILD	(FDMSIZ)		;SIZE OF BLOCK
	  $SET	(.FDLEN,FD.LEN,FDMSIZ)	;LENGTH OF FD
	  $SET	(.FDLEN,FD.TYP,.FDNAT)	;FILE SPEC TYPE (NATIVE)
	  $SET	(.FDSTR,,<'HLP   '>)	;ERSATZ DEVICE HLP:
	  $SET	(.FDNAM,,<'QUOTA '>)	;FILE NAME
	  $SET	(.FDEXT,,<'HLP   '>)	;EXTENSION
	$EOB				;END OF BLOCK
LIS010:	$NOISE	(LIS020,<entries for>)
LIS020:	$USER	(LIS050,<$PDATA (CM%WLA+PPNBLK),$FLAGS(CM%SDH),$ALTER(LIS030)>)
LIS030:	$QUOTE	(LIS050,,<$PREFI(P$8BIT##),$FLAGS(CM%SDH),$ALTER(LIS040)>)
LIS040:	$FIELD	(LIS050,,<$PREFI(P$8BIT##),$FLAGS(CM%SDH),$BREAK(NAMBRK)>)
LIS050:	$NOISE(LIS060,<for structure>)
LIS060:	$DEV(LIS070,<$HELP(structure name),$FLAGS(CM%NSF!CM%PO),$ALTER(LIS062)>)
LIS062:	$SWITCH(LIS070,LIS065)
LIS065:	$STAB
	KEYTAB(.QTMNT,<MOUNT>)
	$ETAB
LIS070:	$NOISE(LIS080,<on file>)
LIS080:	$OFILE(LIS090,<listing filespec>,<$PDEFAULT(FILTXT),$PREFIL(FILDEF),$ACTION(FILACT)>)
LIS090:	$CRLF

FILDEF:	MOVE	T1,[FIL.ZB,,FIL.ZB+1]	;SET UP BLT
	SETZM	FIL.ZB+0		;CLEAR FIRST WORD
	BLT	T1,FIL.ZE-1		;CLEAR ENTIRE BLOCK
	MOVSI	T1,'DSK'		;GENERIC DSK
	MOVEM	T1,GJFBLK+.FDSTR	;SAVE
	MOVE	T1,['QUOTA ']		;FILE NAME
	MOVEM	T1,GJFBLK+.FDNAM	;SAVE IT
	MOVSI	T2,'LST'		;EXTENSION
	MOVEM	T2,GJFBLK+.FDEXT	;SAVE
	$TEXT	(<-1,,FILTXT>,<^F/GJFBLK/^0>) ;CONVERT TO ASCIZ TEXT
	$RETT				;RETURN

FILACT:	PUSH	P,S1			;SAVE S1
	PUSH	P,S2			;SAVE S2
	MOVE	T1,CR.SAV(S2)		;GET FD ADDRESS
	MOVEM	T1,FILFOB+FOB.FD	;SAVE
	MOVE	T3,.FDLEN(T1)		;PRESERVE LENGTH WORD
	MOVEI	T2,.FDNAT		;NATIVE MODE FILE
	STORE	T2,.FDLEN(T1),FD.TYP	;SAVE
	MOVEI	T2,7			;7-BIT BYTES
	MOVEM	T2,FILFOB+FOB.CW	;SAVE IN CONTROL WORD
	MOVEI	S1,FOB.SZ		;FOB SIZE
	MOVEI	S2,FILFOB		;FOB ADDRESS
	$CALL	F%OOPN			;OPEN FILE FOR OUTPUT
	JUMPF	FILA.1			;CHECK FOR ERRORS
	PUSH	P,S1			;SAVE IFN
	MOVNI	S2,1			;WANT EXACT FD
	$CALL	F%FD			;GET ACTUAL FILESPEC
	MOVSI	T1,(S1)			;POINT TO STORAGE
	LOAD	T2,.FDLEN(S1),FD.LEN	;GET ACTUAL LENGTH
	MOVE	S2,-1(P)		;GET SAVED ADDRESS OF CMD BLOCK
	HRR	T1,CR.SAV(S2)		;GET COMMAND FILESPEC STORAGE
	ADD	T2,CR.SAV(S2)		;COMPUTE END BLT ADDRESS
	BLT	T1,-1(T2)		;COPY ACTUAL FILESPEC
	MOVE	S1,-1(P)		;GET SAVED CMD BLOCK ADDRESS AGAIN
	MOVE	S1,CR.SAV(S1)		;GET FD ADDRESS
	MOVEM	T3,.FDLEN(S1)		;RESTORE LENGTH WORD
	POP	P,S1			;GET IFN BACK
	$CALL	F%RREL			;RELEASE IFN
	POP	P,S2			;RESTORE S2
	POP	P,S1			;RESTORE S1
	$RETT				;AND RETURN

FILA.1:	$TEXT	(<-1,,FILERR>,<^E/S1/^0>) ;GET ERROR TEXT
	MOVEI	S2,FILERR		;POINT TO IT
	POP	P,(P)			;TRIM STACK
	POP	P,S1			;RESTORE S1
	$RETF				;AND RETURN
	END
