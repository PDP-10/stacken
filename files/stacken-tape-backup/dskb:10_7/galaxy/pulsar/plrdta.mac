TITLE	PLRDTA - DECtape Processing Module
SUBTTL	D. Mastrovito /DPM	16-Mar-85

;
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1985,1986,1987.
;ALL RIGHTS RESERVED.
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.

	SEARCH	GLXMAC			;GALAXY SYMBOLS
	SEARCH	PLRMAC			;PULSAR SYMBOLS
	SEARCH	QSRMAC			;QUASAR SYMBOLS
	SEARCH	ORNMAC			;OPERATOR INTERFACE SYMBOLS
	PROLOG	(PLRDTA)		;SEARCH OTHER NEEDED FILES

; This module is responsible for all of the DECtape handling done
; by the PULSAR for the MDA system.  It will initialize DECtape
; directories, read DECtape reelids, and unload DECtapes.
SUBTTL	D$IDTA - Initialize a DECtape directory


D$IDTA::PUSHJ	P,OPENDV		;OPEN THE DEVICE
	$RETIF				;RETURN ON FAILURES
	MOVE	S1,TCB.IV(B)		;GET REELID AND SET IT FOR
	PUSHJ	P,SETINF		; ACCOUNTING PUROSES, CLEAR COUNTS
	MOVEI	S1,.FOUTP		;FUNCTION CODE
	MOVX	S2,TV.ERA		;GET ERASE BIT
	TDNN	S2,TCB.IL(B)		;WANT TO ZERO THE DIRECTORY?
	JRST	IDTA.1			;NO
	PUSHJ	P,FILOP			;CLEAR THE DIRECTORY
	JUMPF	IDTA.2			;CHECK FOR ERRORS

IDTA.1:	PUSHJ	P,RDDIR			;NOW READ THE DIRECTORY INTO CORE
	JUMPF	IDTA.2			;CHECK FOR ERRORS
	MOVE	S1,TCB.HO(B)		;GET IOWD TO BUFFER
	MOVE	S2,TCB.IV(B)		;GET REELID
	MOVEM	S2,1+177(S1)		;SAVE IN THE BUFFER
	PUSHJ	P,WTDIR			;WRITE THE DIRECTORY BACK TO TAPE
	JUMPF	IDTA.2			;CHECK FOR ERRORS
	MOVX	S1,TV.HLD		;BIT TO TEST
	TDNN	TCB.IL(B)		;OPR WANT US TO UNLOAD THE DECTAPE?
	PUSHJ	P,UNLODV		;YES
	PUSHJ	P,CLOSDV		;CLOSE THE DEVICE
	MOVEI	S1,[ITEXT (<reelid ^W/TCB.IV(B)/>)]
	SKIPN	TCB.IV(B)		;PERHAPS A BLANK REELID?
	MOVEI	S1,[ITEXT (<a blank reelid>)] ;YES
	$WTO	(<Initialized with ^I/(S1)/>,,TCB.OB(B),$WTFLG(WT.SJI))
	PUSHJ	P,V$MDFI##		;REPORT TO QUASAR
	$RETT				;AND RETURN

IDTA.2:	PUSHJ	P,CLOSDV		;CLOSE THE DEVICE
	$RETF				;AND RETURN FAILURE
SUBTTL	D$MDTA - Process a mount


D$MDTA::MOVEI	S1,TCB.VL(B)		;POINT TO 8-BIT REELID
	PUSHJ	P,O$CN86##		;CONVERT TO SIXBIT
	MOVE	S1,S2			;COPY TO EXPECTED PLACE
	PUSHJ	P,SETINF		;SET REELID, CLEAR COUNTS
	$RETT				;AND RETURN

MDTA.T:	ITEXT	(<DECtape directory contains ^W/S1/
Operator is setting REELID ^W/S2/>)
SUBTTL	D$RDTA - Read a DECtape reelid


D$RDTA::PUSHJ	P,OPENDV		;OPEN THE DEVICE
	$RETIF				;RETURN ON FAILURES
	PUSHJ	P,RDDIR			;READ THE DIRECTORY INTO CORE
	JUMPF	RDTA.1			;CHECK FOR FAILURE
	MOVE	S1,TCB.HO(B)		;GET THE IOWD
	MOVE	S1,1+177(S1)		;AND FINALLY THE REELID
	PUSH	P,S1			;SAVE TEMPORARILY
	PUSHJ	P,SETINF		;SET FOR ACCOUNTING, CLEAR COUNTS
	PUSHJ	P,CLOSDV		;CLOSE THE DEVICE
	POP	P,T1			;GET THE REELID BACK
	PUSHJ	P,O$STAT##		;REPORT TO QUASAR
	$RETT				;AND RETURN

RDTA.1:	PUSHJ	P,CLOSDV		;CLOSE THE DEVICE
	$RETF				;RETURN FAILURE
SUBTTL	D$UDTA - Unload a DECtape


D$UDTA::PUSHJ	P,OPENDV		;OPEN THE DEVICE
	$RETIF				;RETURN ON FAILURES
	PUSHJ	P,UNLODV		;UNLOAD THE DEVICE
	SETZ	S1,			;CLEAR AN AC
	PUSHJ	P,SETINF		;CLEAR REELID, COUNTS
	PUSH	P,TF			;PRESERVE TRUE/FALSE FLAG
	PUSHJ	P,CLOSDV		;CLOSE THE DEVICE
	POP	P,TF			;RESTORE TRUE/FALSE FLAG
	POPJ	P,			;PROPAGATE BACK TO CALLER


UNLODV:	MOVEI	S1,<MTUNL.&777777>	;UNLOAD SUBFUNCTION CODE
	MOVEM	S1,TCB.FI(B)		;SAVE
	MOVEI	S1,.FOMTP		;FUNCTION CODE
	PUSHJ	P,FILOP			;UNLOAD THE DECTAPE
	JUMPF	UNLERR			;CHECK FOR ERRORS
	$RETT				;RETURN

UNLERR:	$WTO	(<Unloading error>,<>,TCB.OB(B),$WTFLG(WT.SJI))
	$RETF				;RETURN
SUBTTL	RDDIR/WTDIR - Read/Write a directory


RDDIR:	MOVEI	S1,144			;BLOCK NUMBER CONTAINING THE DIRECTORY
	MOVEM	S1,TCB.FI(B)		;SAVE
	MOVEI	S1,.FOUSI		;FUNCTION CODE
	PUSHJ	P,FILOP			;POSITION DEVICE
	JUMPF	POSERR			;CHECK FOR ERRORS
	MOVEI	S1,TCB.HO(B)		;POINT TO IOWD
	MOVEM	S1,TCB.FI(B)		;SAVE
	MOVEI	S1,.FOINP		;FUNCTION CODE
	PUSHJ	P,FILOP			;READ THE DIRECTORY BLOCK
	JUMPF	INPERR			;CHECK FOR ERRORS
	$RETT				;RETURN


WTDIR:	MOVEI	S1,144			;BLOCK NUMBER CONTAINING THE DIRECTORY
	MOVEM	S1,TCB.FI(B)		;SAVE
	MOVEI	S1,.FOUSO		;FUNCTION CODE
	PUSHJ	P,FILOP			;POSITION DEVICE
	JUMPF	POSERR			;CHECK FOR ERRORS
	MOVEI	S1,TCB.HO(B)		;POINT TO IOWD
	MOVEM	S1,TCB.FI(B)		;SAVE
	MOVEI	S1,.FOOUT		;FUNCTION CODE
	PUSHJ	P,FILOP			;WRITE THE DIRECTORY BLOCK
	JUMPF	OUTERR			;CHECK FOR ERRORS
	$RETT				;RETURN


POSERR:	$WTO	(<Positioning error>,<>,TCB.OB(B),$WTFLG(WT.SJI))
	$RETF				;RETURN

INPERR:	$WTO	(<Input error ^O6R0/S1/>,<>,TCB.OB(B),$WTFLG(WT.SJI))
	$RETF				;RETURN

OUTERR:	$WTO	(<Output error ^O6R0/S1/>,<>,TCB.OB(B),$WTFLG(WT.SJI))
	$RETF				;RETURN
SUBTTL	GETINF/SETINF - Get/set DECtape info


GETINF:	$SAVE	<P1,P2,P3>		;SAVE SOME ACS
	MOVE	S1,[3,,P1]		;SET UP UUO AC
	MOVEI	P1,.DFDTI		;FUNCTION CODE
	PUSHJ	P,INFDEV		;SET UP DEVICE/CHANNEL
	SETZ	P3,			;REELID WILL BE RETURNED HERE
	DEVOP.	S1,			;FETCH REELID
	  $RETF				;IF ANYONE CARES
	MOVE	S1,P3			;COPY TO EXPECTED PLACE
	$RETT				;AND RETURN

SETINF:	$SAVE	<P1,P2,P3>		;SAVE SOME ACS
	MOVE	P3,S1			;COPY REELID
	MOVE	S1,[3,,P1]		;SET UP UUO AC
	MOVEI	P1,.DFDTI+.DFSET	;FUNCTION CODE
	PUSHJ	P,INFDEV		;SET UP DEVICE/CHANNEL
	DEVOP.	S1,			;FETCH REELID
	  $RETF				;IF ANYONE CARES
	$RETT				;RETURN


INFDEV:	MOVX	P2,TI.OPN		;BIT TO TEST
	TDNN	P2,TCB.IO(B)		;ALREADY OPENED?
	SKIPA	P2,TCB.DV(B)		;GET THE DRIVE NAME
	LDB	P2,[POINTR (TCB.FU(B),FO.CHN)] ;ELSE USE CHANNEL NUMBER
	POPJ	P,			;RETURN
SUBTTL	OPENDV - Open a channel for I/O


OPENDV:	MOVX	S1,TI.OPN		;BIT TO TEST
	TDNE	S1,TCB.IO(B)		;ALREADY OPENED?
	$RETT				;YES
	MOVX	S1,FO.ASC		;EXTENDED CHANNEL BIT
	MOVEM	S1,TCB.FU(B)		;SAVE
	MOVEI	S1,IO.NSD!.IODMP	;NON-STANDARD DECTAPE + DUMP MODE I/O
	STORE	S1,TCB.FI(B),RHMASK	;SAVE
	MOVE	S1,TCB.DV(B)		;GET THE DRIVE NAME
	MOVEM	S1,TCB.DN(B)		;SAVE
	SETZM	TCB.DN+1(B)		;NO BUFFER RING HEADERS
	MOVEI	S1,.FOSIO		;FUNCTION CODE
	PUSHJ	P,FILOP			;OPEN A CHANNEL TO THE DEVICE
	JUMPF	OPNERR			;NOT AVAILABLE?
	MOVX	S1,FO.ASC		;EXTENDED CHANNEL BIT
	ANDCAM	S1,TCB.FU(B)		;CLEAR SO WE DON'T DO IT AGAIN
	MOVEI	S1,PS.RDO!PS.RDH	;TRAP OFF-LINE AND HUNG DEVICE
	PUSHJ	P,I$PICD##		;CONNECT DEVICE TO PSI SYSTEM
	JUMPT	OPEN.1			;PROCEED IF NO ERRORS
	PUSHJ	P,CLOS.1		;ELSE ZAP THE CHANNEL
	$RETF				;AND RETURN

OPEN.1:	MOVX	S1,TI.OPN		;GET A BIT
	IORM	S1,TCB.IO(B)		;INDICATE DEVICE OPENED
	MOVEI	S1,BLKLEN		;ONE BLOCK'S WORTH OF DATA
	$CALL	M%GMEM			;THE A BLOCK OF DATA
	MOVEI	S1,-1(S2)		;GET ADDRESS -1
	HRLI	S1,-BLKLEN		;MAKE AN IOWD
	MOVEM	S1,TCB.HO(B)		;SAVE
	$RETT				;DONE


OPNERR:	$WTO	(<Not available>,<>,TCB.OB(B),$WTFLG(WT.SJI))
	$RETF				;RETURN
SUBTTL	CLOSDV - Close a channel


CLOSDV:	PUSHJ	P,I$PIRD##		;REMOVE PSI CONDITIONS
CLOS.1:	LOAD	S1,TCB.FU(B),TF.DVH	;GET CHANNEL NUMBER
	RESDV.	S1,			;ZAP CHANNEL
	 JFCL				;IGNORE ERRORS
	HLRE	S1,TCB.HO(B)		;GET -NUMBER OF WORDS
	MOVNS	S1			;MAKE POSITIVE
	AOS	S2,TCB.HO(B)		;GET THE BUFFER ADDRESS
	HRRZS	S2			;KEEP JUST THE ADDRESS
	$CALL	M%RMEM			;RELEASE CORE
	SETZM	TCB.HO(B)		;CLEAR POINTER TO BUFFER
	MOVX	S1,TI.OPN		;GET THE 'DEVICE OPENED' BIT
	ANDCAM	S1,TCB.IO(B)		;CLEAR IT
	$RETT				;AND RETURN
SUBTTL	FILOP - Do a FILOP. UUO


FILOP:	STORE	S1,TCB.FU(B),RHMASK	;SAVE FUNCTION CODE
	MOVE	S2,S1			;MAKE A COPY
	HRRI	S1,TCB.FB(B)		;POINT TO THE FILOP BLOCK
	HRLI	S1,2			;ASSUME A SHORT FILOP BLOCK
	CAIN	S2,.FOSIO		;DOING AN OPEN?
	HRLI	S1,.FOBRH+1		;YES
	FILOP.	S1,			;DO SOMETHING
	  SKIPA				;FAILED
	$RETT				;RETURN
	MOVEI	TF,PS.RDO!PS.RDH	;BITS TO TEST
	TDZN	TF,TCB.PI(B)		;DEVICE OFF-LINE OR HUNG?
	$RETF				;NO--MUST BE A REAL I/O ERROR
	MOVEI	TF,PS.RDH		;GET HUNG DEVICE BIT
	TDNE	TF,TCB.PI(B)		;WAS IT A HUNG DEVICE?
	JRST	DTAHNG			;COMPLAIN ABOUT HUNG DEVICE
	MOVX	S1,TS.NTP		;BIT TO SET
	IORM	S1,TCB.ST(B)		;INDICATE NO DECTAPE ON DRIVE
	PUSHJ	P,O$STAT##		;TELL THE OPERATOR
	JRST	DTAKIL			;KILL OFF THE TCB

DTAHNG:	$WTO	(<Hung device>,,TCB.OB(B),$WTFLG(WT.SJI))
DTAKIL:	PUSHJ	P,CLOSDV		;CLEAN UP
	MOVX	S1,TS.KIL		;BIT TO SET
	IORM	S1,TCB.ST(B)		;MARK TCB FOR DELETION
	PUSHJ	P,G$NJOB##		;GO AWAY
	STOPCD	(RDT,HALT,,<Running a killed DECtape TCB>)
SUBTTL	End


	END
