TITLE	LPTLP5 - LP05 class printer driver for LPTSPL-10
SUBTTL	D. Mastrovito/DPM	12-SEP-85

;
;
;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984,1985,1986,1987.
;			ALL RIGHTS RESERVED.
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.
;

	SEARCH	GLXMAC			;SEARCH GALAXY PARAMETERS
	SEARCH	QSRMAC			;SEARCH QUASAR PARAMETERS
	SEARCH	ORNMAC			;SEARCH ORION/OPR PARAMETERS
	SEARCH	LPTMAC			;SEARCH LPTSPL PARAMETERS
	PROLOG	(LPTLP5)

IF2,<PRINTX Assembling GALAXY-10 LPTLP5>

	%%.LPT==:%%.LPT			;VERSION
IFDEF .MCRV.,<.VERSION %%.LPT>

	SALL				;FOR CLEAN LISTINGS
	.DIRECT	FLBLST			;FOR CLEANER LISTINGS

	ENTRY	LPTLP5			;LOAD IF LIBRARY SEARCH
SUBTTL	LPTLP5 - Dispatch table


; This module will drive any LP05 class printer.

LPTLP5::DEVDSP	(LP5,<LP05>)

LP5STS==LPTSTS##			;DEVICE STATUS TEXT


; Driver specific per-job data
	 .ORG	J$DWDS			;DEFINE WORDS STARTING AT J$DWDS
LP5SIZ:!				;END OF DRIVER SPECIFIC DATA
LP5LP2:! BLOCK	1			;VFU SIMULATION FLAG
	 .ORG

IF2,<
	IFL <DRVWDS-<LP5SIZ-J$DWDS>>,<
	PRINTX ? LP05 driver definitions overflow storage
	>
> ;END IF2
SUBTTL	LP5INX - Initialization


LP5INX:	JUMPE	M,.RETT			;RETURN IF LPTSPL INITIALIZATION
	MOVE	S1,STREAM##		;GET STREAM NUMBER
	MOVE	S1,JOBOBA##(S1)		;AND THE OBJECT BLOCK
	MOVE	S1,OBJ.ND(S1)		;GET STATION NUMBER
	PUSHJ	P,LPTANF##		;MUST BE ANF-10
	JUMPF	INIT.1			;ELSE RETURN
	SKIPN	S1,SUP.ST(M)		;GET DEVICE NAME IF ANY
	MOVSI	S1,'LPT'		;ELSE WANT A NORMAL LPT
	PUSHJ	P,LPTDVN##		;GENERATE DEVICE NAME
	MOVE	T1,J$LDEV(J)		;GET DEVICE NAME
	DEVCHR	T1,UU.PHY		;GET DEVICE CHARACTERISTICS
	TXNN	T1,DV.LPT		;PROPER DEVICE TYPE?
	JRST	INIT.1			;NOT FOR US
	MOVE	T1,[2,,T2]		;SET UP UUO AC
	MOVEI	T2,.DFHCW		;FUNCTION CODE
	MOVE	T3,J$LDEV(J)		;DEVICE NAME
	DEVOP.	T1,UU.PHY		;READ HARDWARE CHARACTERISTICS
	  JRST	INIT.1			;FAILED??
	LOAD	T1,T1,DF.CLU		;GET THE UNIT TYPE
	CAIE	T1,.DFUFG		;LP05 CLASS PRINTER?
	CAIN	T1,.DFUUK		;ASSUME UNKNOWN IS AN LP05 CLASS
	TRNA				;EITHER WINS, ELSE...
	JRST	INIT.1			;TRY ANOTHER DRIVER
	MOVE	T1,['LP05  ']		;UNIT TYPE IDENTIFIER
	MOVEM	T1,J$LTYP(J)		;SAVE PRINTER CLASS FOR QUASAR
	HRLZI	T1,LPTLP5		;POINT TO DISPATCH TABLE
	HRRI	T1,J$$DEV(J)		;MAKE A BLT POINTER
	BLT	T1,J$$DND(J)		;COPY INTO JOB STORAGE AREA
	SETOM	J$POSF(J)		;LP05 DOES POSITIONING
	SETOM	J$FFDF(J)		;LP05 DOES FORM FEEDS
	SETOM	J$DC3F(J)		;LP05 SUPPORTS DC3 IN BANNER
	SETOM	J$MNTF(J)		;LP05 SUPPORTS MOUNTABLE FORMS
	SKIPN	J$LREM(J)		;SEE IF LOCAL OR REMOTE PRINTER
	 SKIPA	S1,[.OFLNO]		;LOCAL, DON'T SIMULATE BY DEFAULT
	MOVX	S1,.OFLYE		;REMOTE, SIMULATE BY DEFAULT
	LOAD	S2,SUP.FL(M),SUFLP2	;GET OPR-SET SIMULATION
	CAIN	S2,.OFLDF		;DEFAULTED?
	 MOVE	S2,S1			;YES, USE DEFAULT
	SETZM	LP5LP2(J)		;ASSUME NO LP20-SIMULATION
	CAIE	S2,.OFLNO		;GUESS RIGHT?
	 SETOM	LP5LP2(J)		;NOPE, LP20-SIMULATION WANTED
	SKIPE	LP5LP2(J)		;SIMULATING LP20?
	 PUSHJ	P,VFUINX##		;YES, INITIALIZE THE SIMULATOR
	SETZ	TF,			;MAKE EXTRA ATTRIBUTE WORD
	STORE	S2,TF,OF.LP2
	MOVE	S2,TF
	MOVEI	S1,%RSUOK		;LOAD THE CODE
	$RETT				;RETURN

INIT.1:	MOVNI	S1,1			;-1 MEANS DEVICE NOT FOR US
	$RETF				;RETURN

INIT.2:	SKIPA	S1,[%RSUNA]		;UNIT NOT AVAILABLE
INIT.3:	MOVEI	S1,%RSUDE		;UNIT WILL NEVER BE AVAILABLE
	$RETF				;RETURN
SUBTTL	LP5IPC - Special IPCF message processing


LP5IPC:	MOVNI	S1,1			;WE HAVE NO SPECIAL MESSAGES
	$RETF				;RETURN
SUBTTL	LP5SCD - Scheduler call


LP5SCD:	$RETT				;RETURN
SUBTTL	LP5WAK - Wakeup time check


LP5WAK:	$RETT				;RETURN
SUBTTL	LP5OPX - OPEN device


LP5OPX:	MOVX	T1,IO.SFF+.IOASC	;ASCII MODE + SUPPRESS FORM FEED
	PUSHJ	P,LPTOPN##		;SETUP I/O, OPEN CHANNEL, ETC.
	JUMPF	OPEN.1			;CAN'T HAVE IT RIGHT NOW
	PUSHJ	P,LPTHDW##		;SETUP HARDWARE CHARACTERISTICS
	SKIPN	LP5LP2(J)		;IF NOT SIMULATING LP20,
	JRST	OPEN.0			;DON'T TRY TO SET UP SIMULATOR
	PUSHJ	P,VFUOPX##		;SET UP SIMULATOR (USES/SETS HW CHARS)
	MOVE	S1,J$DCHR(J)		;GET DEVCHR FOR DEVICE
	SKIPGE	J$LREM(J)		;AN ANF (REMOTE) DEVICE?
	TXNN	S1,DV.LPT		;YES, IS IT A REAL LPT?
	JRST	OPEN.0			;NO, DON'T CONFUSE MATTERS
	MOVE	S1,J$LCHN(J)		;ANF AND REAL, FETCH CHANNEL #
	LSH	S1,^D23			;POSITION CHANNEL NUMBER
	TDO	S1,[SETSTS IO.SFF!IO.SVF!.IOASC] ;TELL ANF NODE NOT TO SIMULATE
	XCT	S1			;VFU.  WE KNOW WHAT WE WANT.

OPEN.0:	PUSHJ	P,INTCNL##		;CONNECT TO INTERRUPT SYSTEM
	JUMPF	OPEN.2			;GIVE UP
	TXO	S,INTRPT		;INDICATE WE'RE CONNECTED
	MOVEI	S1,%RSUOK		;LOAD THE CODE
	$RETT				;RETURN

OPEN.1:	SKIPA	S1,[%RSUNA]		;UNIT NOT AVAILABLE
OPEN.2:	MOVEI	S1,%RSUDE		;UNIT WILL NEVER BE AVAILABLE
	$RETF				;RETURN
SUBTTL	LP5CLS - CLOSE device


LP5CLS:	TXZE	S,INTRPT		;ARE WE CONNECTED TO INTRPT SYSTEM?
	PUSHJ	P,INTDCL##		;YES,,RELEASE THE INTERRUPTS
	MOVE	S1,J$LCHN(J)		;GET THE CHANNEL
	SKIPE	J$LREM(J)		;ARE WE USING A REMOTE PRINTER?
	JRST	CLOS.1			;YES--ISSUE A CLOSE/RELEASE
	RESDV.	S1,			;RESET THE CHANNEL
	  JFCL				;IGNORE ANY ERRORS
	$RETT				;AND RETURN

CLOS.1:	LSH	S1,^D23			;POSITION THE CHANNEL NUMBER
	TLO	S1,(CLOSE 0,0)		;MAKE IT A CLOSE UUO
	XCT	S1			;CLOSE THE MAG TAPE
	MOVE	S1,J$LCHN(J)		;GET THE CHANNEL NUMBER AGAIN
	LSH	S1,^D23			;POSITION IT
	TLO	S1,(RELEASE 0,0)	;MAKE IT A RELEASE UUO
	XCT	S1			;RELEASE THE DEVICE
	$RETT				;AND RETURN
SUBTTL	LP5FLS - Flush a job


LP5FLS:	PJRST	LPTFLS##		;CALL COMMON FLUSH ROUTINE
SUBTTL	LP5FVU - Load VFU


LP5VFU:	SKIPE	LP5LP2(J)		;SIMULATING LP20?
	 JRST	VFUVFU##		;YES, LET SIMULATOR HANDLE IT
	JRST	@[IFIW	CHKVFU		;(0) CHECK VFU STATUS
		  IFIW	LODVFU		;(1) LOAD VFU
		  IFIW	VFUERR](S1)	;(2) OUTPUT ERROR DURING LOAD

CHKVFU:	PUSHJ	P,.SAVET		;SAVE SOME ACS
	MOVE	T1,[2,,T2]		;GET THE DEVOP. PARAMETERS
	MOVX	T2,.DFRDS		;READ EXTENDED STATUS
	MOVE	T3,J$LDEV(J)		;SIXBIT /DEVICE/
	DEVOP.	T1,			;ASK THE MONITOR
	 SETZ	T1,			;SHOULDN'T HAPPEN
	TXNE	T1,DF.LVE		;VFU PROBLEM?
	 $RETF				;YES, COMPLAIN
	$RETT				;NO, SAY SO
LODVFU:	LOAD	S1,J$LCLS(J)		;GET THE PRINTER CONTROLLER CLASS
	CAXN	S1,.DFS20		;FRONT END LPT ???
	JRST	VFU.7			;YES,,DO THINGS A LITTLE DIFFERENTLY

	MOVE	S1,J$FTAP(J)		;GET FILENAME
	STORE	S1,VFUFD+.FDNAM		;AND STORE IN THE FD
	MOVEI	S1,FOB.SZ		;GET THE FOB SIZE
	MOVEI	S2,FOB##		;AND FOB ADDRESS
	PUSHJ	P,.ZCHNK		;AND ZERO IT
	MOVEI	S1,VFUFD		;GET FD ADDRESS
	STORE	S1,FOB##+FOB.FD		;STORE
	MOVEI	S1,7			;GET 7 BIT BYTE SIZE
	STORE	S1,FOB##+FOB.CW,FB.BSZ	;AND STORE
	MOVEI	S1,FOB.SZ		;GET FOB SIZE
	MOVEI	S2,FOB##		;AND FOB ADDRESS
	PUSHJ	P,F%IOPN		;SETUP TO READ IT
	 JUMPF	HDWVFU			;FILE NOT FOUND, TRY HARDWARE VFU
	MOVEM	S1,J$FVIF(J)		;ELSE,,SAVE THE IFN
	MOVE	T1,[2,,T2]		;ARGS FOR DEVOP
	MOVX	T2,.DFENV		;ENABLE VFU LOAD
	MOVE	T3,J$LDEV(J)		;FOR I/O DEVICE
	DEVOP.	T1,			;DO IT
	  JRST	NODAVF			;ASSUME NO DAVFU

VFU.4:	SOSGE	J$FBYT(J)		;CHECK AND SEE IF DATA IS IN BUFFER.
	JRST	VFU.6			;IF NOT,,GET NEXT BUFFER.
	ILDB	C,J$FPTR(J)		;PICK UP A BYTE.
	PUSHJ	P,DEVOUT##		;WRITE IT OUT.
	JRST	VFU.4			;GO GET ANOTHER.

VFU.5:	PUSHJ	P,OUTDMP##		;FORCE OUT THE BUFFERS
	PUSHJ	P,DISVFU		;DISABLE VFU LOADING
	$RETT				;OK,,JUST RETURN

VFU.6:	MOVE	S1,J$FVIF(J)		;GET VFU IFN.
	PUSHJ	P,F%IBUF		;GET ANOTHER BUFFER.
	 JUMPF	VFU.5			;IF NO MORE,,RETURN
	MOVEM	S1,J$FBYT(J)		;SAVE THE BYTE COUNT
	MOVEM	S2,J$FPTR(J)		;SAVE THE BYTE POINTER.
	JRST	VFU.4			;CONTINUE PROCESSING.

VFUFD:	$BUILD	FDMSIZ
	 $SET(.FDLEN,FD.LEN,VFUFDL)	;FD LENGTH
	 $SET(.FDEXT,,<SIXBIT/VFU/>)	;FILENAME EXTENSION
	 $SET(.FDSTR,,<SIXBIT/SYS/>)	;FILE STRUCTURE
	$EOB

	VFUFDL==.-VFUFD			;FD LENGTH
	;HERE IF VFU FILE IS NOT AROUND, TRY TO RECOVER BY LOADING THE
	;HARDWARE VFU

HDWVFU:	MOVE	T1,J$FTAP(J)		;TYPE WE TRIED TO LOAD
	CAME	T1,D$TAPE##		;IS IT THE DEFAULT
	 JRST	VFUFAI			;VFU LOAD FAILED
	MOVE	T1,[2,,T2]		;ARGS FOR DEVOP
	MOVEI	T2,.DFLLV		;LOAD HARDWARE VFU
	MOVE	T3,J$LCHN(J)		;FOR CHANNEL
	DEVOP.	T1,			;DO IT
VFUFAI:	 SKIPA	S1,[1]			;VFU LOAD FAILED
VFUHVL:	SETZ	S1,			;HARDWARE VFU LOADED INSTEAD
	$RETF
VFUERR:	LOAD 	S1,J$LCLS(J)		;[2775] GET CONTROLLER CLASS
	CAXE	S1,.DFS20		;[2775] FRONT END LPT?
	  PUSHJ	P,DISVFU		;[2775] NO,,GO DIASBLE VFU LOADING
	$RET

DISVFU:	MOVE	T1,[2,,T2]		;LOAD ARG POINTER
	MOVX	T2,.DFDVL		;DISABLE VFU LOAD
	MOVE	T3,J$LCHN(J)		;AND CHANNEL NUMBER
	DEVOP.	T1,			;DO IT!
	  JRST	NODAVF			;LOSE
	MOVE	S1,J$FVIF(J)		;GET THE IFN
	PUSHJ	P,F%REL			;RELEASE IT
	MOVE	T1,J$FTAP(J)		;GET TAPE NAME
	MOVEM	T1,J$FLVT(J)		;SAVE AS TYPE LOADED
	POPJ	P,			;RETURN

;HERE WHEN DEVOP FAILS...GUESS THERE'S NO VFU AFTER ALL

NODAVF:	MOVE	S1,J$FVIF(J)		;GET IFN
	$CALL	F%REL			;RELEASE THE FILE
	MOVEI	S1,2			;NO VFU AFTER ALL
	$RETF
	;FOR FRONT END LINE PRINTERS, WE MUST DO THINGS A LITTLE DIFFERENTLY !!

VFU.7:	OPEN	17,VFUFOB		;OPEN THE STRUCTURE
	 JRST	HDWVFU			;CANT,,TRY SOMETHING ELSE
	MOVE	S1,J$FTAP(J)		;GET THE VFU WE WANT
	MOVEM	S1,VLKUP+0		;SAVE IN THE LOOKUP BLOCK
	MOVSI	S1,'VFU'		;GET THE EXTENSION
	MOVEM	S1,VLKUP+1		;SAVE IN THE LOOKUP BLOCK
	SETZM	VLKUP+2			;CLEAR 3'RD WORD OF LOOKUP BLOCK
	SETZM	VLKUP+3			;CLEAR 4'TH WORD OF LOOKUP BLOCK
	SETO	T1,			;FALG TO VFU.9 SAYING LOAD FAILED
	LOOKUP	17,VLKUP		;FIND THE FILE WE WANT
	 JRST	VFU.9			;NOT THERE,,TRY SOMETHING ELSE
	PUSHJ	P,M%GPAG		;GET A PAGE FOR A BUFFER
	MOVE	T4,S1			;SAVE THE ADDRESS FOR LATER
	MOVEI	T1,-1(S1)		;GET BUFFER ADDRESS-1
	HLL	T1,VLKUP+3		;GET -FILE LENGTH,,BUFFER ADDR-1
	SETZM	T2			;END CCW
	IN	17,T1			;READ THE VFU FILE
	SKIPA				;CONTINUE ON SUCCESSFUL RETURN
	 JRST	VFU.8			;AN ERROR,,TRY SOMETHING ELSE
	HLRO	T3,VLKUP+3		;GET -FILE LENGTH
	MOVMS	T3			;WANT POSITIVE LENGTH
	IMULI	T3,5			;CALC NUMBER OF VFU BYTES
	MOVEI	T1,.DFLV2		;WANT LOAD VFU FUNCTION
	MOVE	T2,J$LCHN(J)		;WANT LPT CHANNEL NUMBER
	MOVE	S1,[4,,T1]		;GET ARG COUNT,,BLOCK ADDRESS
	SETZM	S2			;FLAG S2 (IF 0 THEN VFU LOADED OK)
	DEVOP.	S1,			;LOAD THE VFU
VFU.8:	 SETOM	S2			;FLAG THAT VFU LOAD FAILED
	MOVE	T1,S2			;SAVE THE VFU LOAD FLAG
	MOVE	S1,T4			;GET THE BUFFER ADDRESS BACK
	PUSHJ	P,M%RPAG		;RELEASE THE PAGE

VFU.9:	MOVEI	S1,17			;GET THE CHANNEL NUMBER
	RESDV.	S1,			;WIPE IT OUT
	JFCL				;IGNORE ANY ERROR RELEASING THE DEVICE
	JUMPN	T1,HDWVFU		;LOAD FAILED,,TRY SOMETHING ELSE
	$RETT				;OK,,RETURN

VFUFOB:	.IODMP				;DUMP MODE I/O
	SIXBIT/SYS/			;FILE ON SYS:
	0,,0				;DUMP MODE (NO BUFFERS)

VLKUP:	BLOCK	4			;LOOKUP BLOCK


SUBTTL	LP5RAM - Load RAM


LP5RAM:	SKIPE	LP5LP2(J)		;SIMULATING LP20?
	 JRST	VFURAM##		;YES, LET THE SIMULATOR DO IT
	OPEN	17,RAMFOB		;OPEN THE STRUCTURE
	  JRST	NORAM			;CANT,,TRY SOMETHING ELSE
	MOVE	S1,J$FRAM(J)		;GET THE RAM WE WANT
	MOVEM	S1,RLKUP+0		;SAVE IN THE LOOKUP BLOCK
	MOVSI	S1,'RAM'		;GET THE EXTENSION
	MOVEM	S1,RLKUP+1		;SAVE IN THE LOOKUP BLOCK
	SETZM	RLKUP+2			;CLEAR 3'RD WORD OF LOOKUP BLOCK
	SETZM	RLKUP+3			;CLEAR 4'TH WORD OF LOOKUP BLOCK
	SETO	T1,			;FLAG FOR RAM.2 SAYING "FAILED"
	LOOKUP	17,RLKUP		;FIND THE FILE WE WANT
	  JRST	RAM.2			;NOT THERE,,TRY SOMETHING ELSE
	PUSHJ	P,M%GPAG		;GET A PAGE FOR A BUFFER
	MOVE	T4,S1			;SAVE THE ADDRESS FOR LATER
	MOVEI	T1,-1(S1)		;GET BUFFER ADDRESS-1
	HLL	T1,RLKUP+3		;GET -FILE LENGTH,,BUFFER ADDR-1
	SETZM	T2			;END CCW
	IN	17,T1			;READ THE RAM FILE
	SKIPA				;CONTINUE ON SUCCESSFUL RETURN
	  JRST	RAM.1			;AN ERROR,,TRY SOMETHING ELSE
	HLRO	T3,RLKUP+3		;GET -FILE LENGTH
	MOVMS	T3			;WANT POSITIVE LENGTH
	LSH	T3,2			;CONVERT TO 8 BIT BYTE COUNT
	MOVEI	T1,.DFLR2		;WANT LOAD RAM FUNCTION
	MOVE	T2,J$LCHN(J)		;WANT LPT CHANNEL NUMBER
	MOVE	S1,[4,,T1]		;GET ARG COUNT,,BLOCK ADDRESS
	SETZM	S2			;FLAG S2 (IF 0 THEN RAM LOADED OK)
	DEVOP.	S1,			;LOAD THE RAM

RAM.1:	  SETOM	S2			;INDICATE RAM LOAD ERROR
	MOVE	T1,S2			;SAVE THE RAM LOAD FLAG

	MOVE	S1,T4			;GET THE BUFFER ADDRESS BACK
	PUSHJ	P,M%RPAG		;RELEASE THE PAGE

RAM.2:	MOVEI	S1,17			;GET OUR CHANNEL NUMBER
	RESDV.	S1,			;WIPE IT OUT
	  JFCL				;IGNORE ANY ERROR RELEASING THE DEVICE
	JUMPN	T1,NORAM		;IF AN ERROR,,GO TRY SOMETHING ELSE
	$RETT				;AND RETURN

NORAM:	MOVEI	S1,1			;RAM LOAD FAILED, OPR ACTION
	$RETF

RAMFOB:	.IODMP				;DUMP MODE I/O
	SIXBIT/SYS/			;FILE ON SYS:
	0,,0				;DUMP MODE (NO BUFFERS)

RLKUP:	BLOCK	4			;LOOKUP BLOCK
SUBTTL	LP5LER - File LOOKUP error processing


LP5LER:	PJRST	LPTLER##		;CALL COMMON ERROR ROUTINE
SUBTTL	LP5IER - File input error processing


LP5IER:	PJRST	LPTIER##		;CALL COMMON ERROR ROUTINE
SUBTTL	LP5CHO - OUTPUT A CHARACTER

LP5CHO:	SKIPE	LP5LP2(J)		;IF LP20-SIMULATION,
	 PJRST	VFUCHO##		;LET SIMULATOR HAVE CHARACTER
	$RETT				;OTHERWISE LET DEVOUT DO IT
SUBTTL	LP5OUT - Output a buffer


LP5OUT:	PJRST	LPTOUT##		;CALL COMMON OUTPUT ROUTINE
SUBTTL	LP5OER - Output error processing


LP5OER:	SKIPE	LP5LP2(J)		;IF SIMULATING LP20,
	 PUSHJ	P,VFUOER##		;LET SIMULATOR SIGNAL ERRORS TOO
	PJRST	LPTOER##		;CALL COMMON ERROR ROUTINE
SUBTTL	LP5EOX - Output EOF processing


LP5EOX:	$RETT				;NOTHING TO DO
SUBTTL	LP5BJB - Begining of job


LP5BJB:	$RETT				;RETURN
SUBTTL	LP5EJB - End of job


LP5EJB:	$RETT				;RETURN
SUBTTL	LP5BFL - Begining of file


LP5BFL:	$RETT				;RETURN
SUBTTL	LP5EFL - End of file


LP5EFL:	$RETT				;RETURN
SUBTTL	LP5BAN - Banner initialization


LP5BAN:	$RETT				;RETURN
SUBTTL	LP5HDR - Header initialization


LP5HDR:	$RETT				;RETURN
SUBTTL	LP5WID - Header width initialization


LP5WID:	$RETT				;RETURN
SUBTTL	LP5RUL - Ruler processing

LP5RUL:	PJRST	LPTRUL##		;PRINT STANDARD RULER
SUBTTL	LP5SHT - Stream shutdown


LP5SHT:	SKIPE	LP5LP2(J)		;LP20-SIMULATION?
	 PJRST	VFUSHT##		;YES, LET SIMULATOR SHUT DOWN
	$RETT				;RETURN
SUBTTL	LP5CHR - Character translator


LP5CHR:	$RETT				;RETURN
SUBTTL	Literal pool


LP5LIT:	LIT

LP5END::!END
