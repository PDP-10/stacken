	TITLE	QSRALC

;
;
;         COPYRIGHT (c) 1978,1979,1980,1981,1982,1983,1984,1985,
;         			1986,1987
;                    DIGITAL EQUIPMENT CORPORATION
;			   ALL RIGHTS RESERVED.
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.


;   0001  0	MODULE QSRALC (	!
;   0002  0			IDENT = '6',
;   0003  0			LANGUAGE (BLISS36),
;   0004  0			ENVIRONMENT (TOPS10)
;   0005  0			) =
;   0006  1	BEGIN
;   0007  1	
;   0008  1	!
;   0009  1	!	COPYRIGHT (c) 1978,1979,1980,1981,1982,1983,1984,1985
;   0010  1	!	             DIGITAL EQUIPMENT CORPORATION
;   0011  1	!			 ALL RIGHTS RESERVED.
;   0012  1	!
;   0013  1	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;   0014  1	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;   0015  1	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;   0016  1	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;   0017  1	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;   0018  1	! TRANSFERRED.
;   0019  1	!
;   0020  1	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;   0021  1	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;   0022  1	! CORPORATION.
;   0023  1	!
;   0024  1	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;   0025  1	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;   0026  1	!
;   0027  1	
;   0028  1	!++
;   0029  1	! FACILITY:
;   0030  1	!	MDA-10
;   0031  1	
;   0032  1	! ABSTRACT:
;   0033  1	!	This module does the deadlock avoidance for the Mountable
;   0034  1	!	Device Allocator (MDA) on the DECsystem-10.
;   0035  1	!
;   0036  1	!	The basis for this algorithm is presented by A. N. Habermann
;   0037  1	!	of Carnegie-Mellon University, Pittsburgh, Pennsylvania
;   0038  1	!	in a paper entitled "Prevention of System Deadlocks"
;   0039  1	!	which appeared in Communications of the ACM Volume 12, Number 7
;   0040  1	!	July 1969.
;   0041  1	!
;   0042  1	! ENVIRONMENT:
;   0043  1	!	TOPS-10
;   0044  1	!
;   0045  1	! AUTHOR: Dave Cornelius/Alec Carlson, CREATION DATE: Dec 29,1979
;   0046  1	!
;   0047  1	! MODIFIED BY:
;   0048  1	!
;   0049  1	! 	, : VERSION
;   0050  1	! 01	- 
;   0051  1	! 02 Add code to support the concept of 'permanent' resources
;   0052  1	! 03 Fix sequence counter incrementing bug
;   0053  1	! 04 Return TRUE if the number of processes is 0
;   0054  1	! 05 Fix things so QSRALC will compile with BLISS V4 /LWS
;   0055  1	! 06 Search CATPRM
;   0056  1	!--
;   0057  1	!
;   0058  1	! TABLE OF CONTENTS:
;   0059  1	!
;   0060  1	
;   0061  1	!
;   0062  1	! INCLUDE FILES:
;   0063  1	!
;   0064  1		LIBRARY	'GLXMAC.L36';		!The converted GLXMAC.MAC
;   0065  1	
;   0066  1		UNDECLARE JIB$ID,JIB$JN,JIB$SQ,JIB$NM;	!Undeclare symbols in both
;   0067  1		UNDECLARE JIB$US,JIBSIZ;		!GLXMAC and QSRMAC.
;   0068  1		UNDECLARE MF$FAT,OBJ$SZ,$OTMAX,LSTIN$;
;   0069  1		UNDECLARE ZZ,RHMASK,FDXSIZ,MSHSIZ;
;   0070  1		UNDECLARE FTUUOS,FTJSYS;
;   0071  1		UNDECLARE SAB$SZ,FTFLBK;
;   0072  1		UNDECLARE PAGSIZ;
;   0073  1	
;   0074  1		LIBRARY	'QSRMAC.L36';		!The converted QSRMAC.MAC
;   0075  1	
;   0076  1		UNDECLARE JUMPF,JUMPT,PJRST,$OHDRS,FOB$SZ,$STLEN,ARG$SZ;
;   0077  1		UNDECLARE LSTIN$,$CVLST,ZZ,$$$MOD,E,M,$$$GLX,PAGSIZ,P;
;   0078  1		UNDECLARE NAMSIZ,LOCSIZ,VSNLEN,FDXSIZ,GLXPUR,FTJSYS;
;   0079  1		UNDECLARE FTUUOS,GLXVRS,VSNSIZ;
;   0080  1	
;   0081  1		LIBRARY	'CATPRM.L36';		!The converted CATPRM.MAC
;   0082  1	!
;   0083  1	! MACROS:
;   0084  1	!
;   0085  1		MACRO A$MAT = A$MAT$STR FIELD (A$MAT$FIELD) %;
;   0086  1	
;   0087  1		MACRO S$M$COL = S$M$COLUMN FIELD (S$M$FIELD) %;
;   0088  1	
;   0089  1		MACRO S$M$HDR = S$M$HEADER FIELD (S$M$FIELD) %;
;   0090  1	
; M 0091  1		MACRO MSK$EXP (MASK) = %NBITSU( MASK AND - MASK) - 1,
;   0092  1				%NBITSU (MASK) - %NBITSU (MASK AND - MASK) + 1 %;
;   0093  1	
;   0094  1	!
;   0095  1	! EQUATED SYMBOLS:
;   0096  1	!
;   0097  1		LITERAL	SHRHIGH = $HLR1,
;   0098  1			SHRLOW  = $LLR1,
;   0099  1			SHRNONE = $ZER1,
;   0100  1			QSRFOO  = QSRVRS;
;   0101  1	
;   0102  1		UNDECLARE QSRVRS;
;   0103  1	
;   0104  1		LITERAL	QSRVRS  = QSRFOO;
;   0105  1	!
;   0106  1	! OWN STORAGE:
;   0107  1	!
;   0108  1	
;   0109  1	!
;   0110  1	! REGISTER DEFINITIONS
;   0111  1	!
;   0112  1	
;   0113  1	!
;   0114  1	! LINKAGE DEFINITIONS
;   0115  1	!
;   0116  1	
;   0117  1	! CALL ARG IN S1, RETURN TF ONLY
;   0118  1	LINKAGE GLX$CS1$RTF = PUSHJ (REGISTER=S1):LINKAGE$REGS(P,14,TF)
;   0119  1					PRESERVE(T1,T2,T3,T4,P1,P2,P3,P4);
;   0120  1	
;   0121  1	! CALL ARG IN S1, RETURN TF, AND SOMETHING IN S2
;   0122  1	LINKAGE GLX$CS1$RTF$RS2 = PUSHJ (REGISTER=S1):LINKAGE$REGS(P,14,TF)
;   0123  1					GLOBAL (RETADR=S2)
;   0124  1					PRESERVE(T1,T2,T3,T4,P1,P2,P3,P4);
;   0125  1	
;   0126  1	! CALL ARG IN S1, RETUFN TF, AND SOMETHING IN S1
;   0127  1	!LINKAGE GLX$CS1$RTF$RS1 = PUSHJ (REGISTER = S1):LINKAGE$REGS(P,14,TF)
;   0128  1	!				GLOBAL (RETS1  = S1)
;   0129  1	!				PRESERVE(T1,T2,T3,T4,P1,P2,P3,P4);
;   0130  1	
;   0131  1	! CALL ARG IN S1, AND S2, RETURNS NOTHING
;   0132  1	LINKAGE GLX$CS1$CS2 = PUSHJ (REGISTER=S1, REGISTER=S2):LINKAGE$REGS(P,14,TF)
;   0133  1					PRESERVE(T1,T2,T3,T4,P1,P2,P3,P4);
;   0134  1	
;   0135  1	! CALL ARG IN S1, RETURNS VALUE IN S2
;   0136  1	LINKAGE GLX$CS1$RS2 = PUSHJ (REGISTER=S1):LINKAGE$REGS(P,14,S2)
;   0137  1					NOPRESERVE (TF)
;   0138  1					PRESERVE(T1,T2,T3,T4,P1,P2,P3,P4);
;   0139  1	
;   0140  1	! CALL ARGS ON STACK, RETURNS VALUE IN TF
;   0141  1	LINKAGE BLISS$GLX = PUSHJ : LINKAGE$REGS (P,14,TF)
;   0142  1					NOPRESERVE (S1,S2)
;   0143  1					PRESERVE(T1,T2,T3,T4,P1,P2,P3,P4,$A13,$A14,$A15);
;   0144  1	
;   0145  1	! NOTE WELL ::
;   0146  1	SWITCHES LINKAGE (BLISS$GLX);
;   0147  1	
;   0148  1	
;   0149  1	!
;   0150  1	! FORWARD ROUTINES
;   0151  1	!
;   0152  1		FORWARD ROUTINE
;   0153  1			GET$COLUMN : NOVALUE,
;   0154  1			GET$HEADER : NOVALUE,
;   0155  1			FNDROW,
;   0156  1			ALL$TRIED$OR$PLAYED,
;   0157  1			NEXT$CANDIDATE,
;   0158  1			NOTRY : NOVALUE,
;   0159  1			ALL$PLAYED,
;   0160  1			PLAYABLE,
;   0161  1			PLAY : NOVALUE,
;   0162  1			OTHR$USER,
;   0163  1			UNMAP : NOVALUE,
;   0164  1			STOP;
;   0165  1	
;   0166  1	!
;   0167  1	! EXTERNAL REFERENCES:
;   0168  1	!
;   0169  1	
;   0170  1	! L%FIRST
;   0171  1	EXTERNAL ROUTINE %NAME(L,%CHAR(37),FIRST);
;   0172  1	 BIND ROUTINE L$FIRST=%NAME(L,%CHAR(37),FIRST):GLX$CS1$RTF$RS2;
;   0173  1	
;   0174  1	! L%NEXT
;   0175  1	EXTERNAL ROUTINE %NAME(L,%CHAR(37),NEXT);
;   0176  1	 BIND ROUTINE L$NEXT=%NAME(L,%CHAR(37),NEXT):GLX$CS1$RTF$RS2;
;   0177  1	
;   0178  1	! M%GMEM
;   0179  1	EXTERNAL ROUTINE %NAME(M,%CHAR(37),GMEM);
;   0180  1	 BIND ROUTINE M$GMEM=%NAME(M,%CHAR(37),GMEM):GLX$CS1$RS2;
;   0181  1	
;   0182  1	! M%RMEM
;   0183  1	EXTERNAL ROUTINE %NAME(M,%CHAR(37),RMEM):NOVALUE;
;   0184  1	 BIND ROUTINE M$RMEM=%NAME(M,%CHAR(37),RMEM):GLX$CS1$CS2;
;   0185  1	
;   0186  1	! V$BCAT
;   0187  1	EXTERNAL ROUTINE V$BCAT : GLX$CS1$RTF$RS2;
;   0188  1	
;   0189  1	! The stopcode processor
;   0190  1	EXTERNAL ROUTINE D$STOP : GLX$CS1$RTF;
;   0191  1	
;   0192  1	EXTERNAL ROUTINE D$DEC : GLX$CS1$RTF;
;   0193  1	
;   0194  1	EXTERNAL ROUTINE D$TEXT : GLX$CS1$RTF;
;   0195  1	
;   0196  1	EXTERNAL ROUTINE D$CR;
;   0197  1	
;   0198  1		STRUCTURE A$MAT$STR [I,O,P,S,E] = (A$MAT$STR + I * AMALEN + O)<P,S,E>;
;   0199  1	
;   0200  1		STRUCTURE S$M$COLUMN [I,WD] =
;   0201  1			CASE WD FROM $SMJOB TO $SMRES + 1 OF
;   0202  1			SET
;   0203  1				[$SMJOB,$SMFLG,$SMDLK] :
;   0204  1					(S$M$COLUMN + WD);
;   0205  1				[$SMRES + 1] : (S$M$COLUMN + $SMRES + I);
;   0206  1			TES;
;   0207  1	
;   0208  1		STRUCTURE BLOCK1 [I,P,S,E] = (BLOCK1 + I - 1)<P,S,E>;
;   0209  1	
;   0210  1		STRUCTURE VECTOR1 [I] = (VECTOR1 + I - 1)<0,36>;
;   0211  1	
;   0212  1	!
;   0213  1	! FIELDS
;   0214  1	!
;   0215  1		FIELD	A$MAT$FIELD =
;   0216  1		SET
;   0217  1			A$M$NAME = [$AMNAM, MSK$EXP (AM$NAM), 0],
;;    [MSK$EXP]=  1 - 1 , 18 - 1 + 1
;   0218  1			A$M$PERMANENT = [$AMNAM, MSK$EXP (AM$PRR), 0],
;;    [MSK$EXP]=  34 - 1 , 34 - 34 + 1
;   0219  1			A$M$LEVEL = [$AMSTA, MSK$EXP (AM$DVT), 0],
;;    [MSK$EXP]=  23 - 1 , 26 - 23 + 1
;   0220  1			A$M$AVA = [$AMCNT, MSK$EXP (AM$AVA), 0],
;;    [MSK$EXP]=  25 - 1 , 36 - 25 + 1
;   0221  1			A$M$USE = [$AMCNT, MSK$EXP (AM$CLM), 0],
;;    [MSK$EXP]=  1 - 1 , 12 - 1 + 1
;   0222  1			A$M$DLOCK$COMP = [$AMDLK, MSK$EXP (FWMASK), 0]
;;    [MSK$EXP]=  1 - 1 , 36 - 1 + 1
;   0223  1		TES;
;   0224  1	
;   0225  1		FIELD	S$M$FIELD =
;   0226  1		SET
;   0227  1		    S$M$FLAGS =      [0,$SMFLG],
;   0228  1			S$M$IGNORED =    [MSK$EXP (SM$IGN),0],
;;    [MSK$EXP]=  36 - 1 , 36 - 36 + 1
;   0229  1			S$M$COUNT =      [MSK$EXP (SM$CNT),0],
;;    [MSK$EXP]=  1 - 1 , 18 - 1 + 1
;   0230  1		    S$M$DLOCK$COMP = [0,$SMDLK,MSK$EXP(FWMASK),0],
;;    [MSK$EXP]=  1 - 1 , 36 - 1 + 1
;   0231  1			S$M$PLAYED = [0,$SMDLK,MSK$EXP(SM$PLY),0],
;;    [MSK$EXP]=  36 - 1 , 36 - 36 + 1
;   0232  1			S$M$TRIED  = [0,$SMDLK,MSK$EXP(SM$DLK),0],
;;    [MSK$EXP]=  35 - 1 , 35 - 35 + 1
;   0233  1			S$M$SEQUENCE=[0,$SMDLK,MSK$EXP(SM$SEQ),0],
;;    [MSK$EXP]=  1 - 1 , 18 - 1 + 1
;   0234  1		    S$M$RESOURCE   = [  $SMRES+1]
;   0235  1		TES;
;   0236  1	
;   0237  1		STRUCTURE S$M$HEADER [I,J,WD,P,S,E] =
;   0238  2			BEGIN
;   0239  2				LOCAL T : REF S$M$COL;
;;    [S$M$COL]=  S$M$COLUMN FIELD ( S$M$FIELD )
;   0240  2				T = .(S$M$HEADER + I - 1);
;   0241  2				T [J,WD]
;   0242  1			END<P,S,E>;
;   0243  1	
;   0244  1	GLOBAL ROUTINE D$DEAD (A$MATRIX,B$MATRIX,C$MATRIX,NUM$RES,NUM$PRO) =
;   0245  1	
;   0246  1	!++
;   0247  1	! FUNCTIONAL DESCRIPTION:
;   0248  1	!
;   0249  1	!
;   0250  1	! FORMAL PARAMETERS:
;   0251  1	!
;   0252  1	!	A$MATRIX	The address of some A matrix in the Habermann algorithm
;   0253  1	!			This matrix is the resources available to the allocator,
;   0254  1	!			and is actually just a vector
;   0255  1	!	B$MATRIX	The address of some B matrix, the claim matrix.
;   0256  1	!	C$MATRIX	The address of some C matrix, the allocation matrix,
;   0257  1	!			which says which jobs actually own resources
;   0258  1	!	NUM$RES		The number of resources (size of the A$MATRIX, and
;   0259  1	!			number of rows in the B$ and C$MATRIX.
;   0260  1	!	NUM$PRO		The number of processes (Number of columns in the
;   0261  1	!			B$ and C$ MATRIX)
;   0262  1	! IMPLICIT INPUTS:
;   0263  1	!
;   0264  1	!	NONE
;   0265  1	!
;   0266  1	! IMPLICIT OUTPUTS:
;   0267  1	!
;   0268  1	!	NONE
;   0269  1	!
;   0270  1	! ROUTINE VALUE:
;   0271  1	!
;   0272  1	!	TRUE	If the presented allocation state is safe
;   0273  1	!	FALSE	If the presented allocation state presents a deadlock
;   0274  1	!
;   0275  1	! SIDE EFFECTS:
;   0276  1	!
;   0277  1	!	NONE
;   0278  1	!
;   0279  1	!--
;   0280  1	
;   0281  2	    BEGIN
;   0282  2		MAP	A$MATRIX : REF A$MAT;
;;    [A$MAT]=  A$MAT$STR FIELD ( A$MAT$FIELD )
;   0283  2	
;   0284  2		LOCAL	B$COL$HDR : REF S$M$HDR;!Holds the adrs of each column header
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0285  2						!   in the B matrix
;   0286  2		LOCAL	C$COL$HDR : REF S$M$HDR;!Holds the adrs of each column header
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0287  2						!   in the C matrix
;   0288  2		LOCAL	SCRATCH$VEC : REF VECTOR1;
;   0289  2		LOCAL	VAL;			!VALUE RETURNED
;   0290  2		LOCAL	B$COL : REF VECTOR1;	!Holds a column of the B matrix
;   0291  2		LOCAL	C$COL : REF VECTOR1;	!Holds a column of the C matrix
;   0292  2		LOCAL	SEQ$NUMBER;
;   0293  2	
;   0294  2	!No processes can never be deadlocked
;   0295  2		IF .NUM$PRO EQL 0 THEN RETURN TRUE;
;   0296  2	
;   0297  2	!Get the per-process areas
;   0298  2		B$COL$HDR = M$GMEM (.NUM$PRO);
;   0299  2		C$COL$HDR = M$GMEM (.NUM$PRO);
;   0300  2	
;   0301  2	!Get the per-resource areas
;   0302  2		SCRATCH$VEC = M$GMEM (.NUM$RES);
;   0303  2		B$COL = M$GMEM (.NUM$RES);
;   0304  2		C$COL = M$GMEM (.NUM$RES);
;   0305  2	
;   0306  2	! Start with the currently available resources
;   0307  2	! We do all our computations in A$M$DLOCK$COMP and
;   0308  2	! never disturb any other fields in the A matrix
;   0309  2		DECR I FROM .NUM$RES TO 1 DO
;   0310  2			A$MATRIX [.I, A$M$DLOCK$COMP] = .A$MATRIX [.I, A$M$AVA];
;   0311  2	
;   0312  2	! For efficiency, rip off a vector of addresses of the columns
;   0313  2	! in each of the B and C matricies
;   0314  2		GET$HEADER (.B$MATRIX, .B$COL$HDR, .NUM$PRO);
;   0315  2		GET$HEADER (.C$MATRIX, .C$COL$HDR, .NUM$PRO);
;   0316  2	
;   0317  2	! Clear the played and tried bits in the B matrix header for all processes
;   0318  2		DECR I FROM .NUM$PRO TO 1 DO
;   0319  2			B$COL$HDR [.I, S$M$DLOCK$COMP] = 0;
;   0320  2	! Initialize the safe-sequence play order counter
;   0321  2		SEQ$NUMBER = 0;
;   0322  2	
;   0323  2	! Until we win, or exhaust all the possible processes.....
;   0324  2		UNTIL ALL$TRIED$OR$PLAYED (.B$COL$HDR, .NUM$PRO) DO
;   0325  3		BEGIN
;   0326  3			LOCAL CUR$PRO;
;   0327  3	
;   0328  3			CUR$PRO = NEXT$CANDIDATE (.B$COL$HDR, .NUM$PRO);
;   0329  3	
;   0330  3	!		For speed read the columns for this process
;   0331  3			GET$COLUMN (.B$COL$HDR, .CUR$PRO, .B$COL, .NUM$RES);
;   0332  3			GET$COLUMN (.C$COL$HDR, .CUR$PRO, .C$COL, .NUM$RES);
;   0333  3	
;   0334  3			IF PLAYABLE (.CUR$PRO,
;   0335  3					.A$MATRIX,
;   0336  3					.B$COL$HDR,
;   0337  3					.C$COL$HDR,
;   0338  3					.B$COL,
;   0339  3					.C$COL,
;   0340  3					.NUM$RES,
;   0341  3					.NUM$PRO,
;   0342  3					.SCRATCH$VEC)
;   0343  3			THEN
;   0344  4				BEGIN
;   0345  4					PLAY (.CUR$PRO,
;   0346  4						.A$MATRIX,
;   0347  4						.B$COL$HDR,
;   0348  4						.C$COL$HDR,
;   0349  4						.C$COL,
;   0350  4						.NUM$RES,
;   0351  4						.NUM$PRO,
;   0352  4						.SCRATCH$VEC);
;   0353  4					NOTRY (.B$COL$HDR, .NUM$PRO);
;   0354  4					B$COL$HDR [.CUR$PRO, S$M$SEQUENCE] =
;   0355  4						(SEQ$NUMBER = .SEQ$NUMBER + 1);
;   0356  4					B$COL$HDR [.CUR$PRO, S$M$PLAYED] = TRUE;
;   0357  4					END
;   0358  3			ELSE B$COL$HDR [.CUR$PRO, S$M$TRIED] = TRUE;
;   0359  2		END;
;   0360  2	
;   0361  2		VAL = ALL$PLAYED (.B$COL$HDR, .NUM$PRO);
;   0362  2	
;   0363  2	! Give back the per-process storage
;   0364  2		M$RMEM (.NUM$PRO, .B$COL$HDR);
;   0365  2		M$RMEM (.NUM$PRO, .C$COL$HDR);
;   0366  2	
;   0367  2	! Give back the per-resource storage
;   0368  2		M$RMEM (.NUM$RES, .SCRATCH$VEC);
;   0369  2		M$RMEM (.NUM$RES, .B$COL);
;   0370  2		M$RMEM (.NUM$RES, .C$COL);
;   0371  2	
;   0372  2		.VAL
;   0373  1	END;			!End of D$DEAD






	EXTERN	L%FIRST, L%NEXT, M%GMEM, M%RMEM, V$BCAT, D$STOP, D$DEC, D$TEXT, D$CR


L$FIRST=	    L%FIRST			;						000000	000000*
L$NEXT=		    L%NEXT			;						000000	000000*
M$GMEM=		    M%GMEM			;						000000	000000*
M$RMEM=		    M%RMEM			;						000000	000000*


AC0=	0
AC1=	1
AC2=	2
AC3=	3
AC4=	4
AC5=	5
AC6=	6
AC7=	7
AC10=	10
AC11=	11
AC12=	12
AC13=	13
AC14=	14
AC15=	15
FP=	16
SP=	17


D$DEAD::PUSH	SP,AC5				; SP,AC5				400000' 261 17 0 00 000005		0244
	PUSH	SP,AC6				; SP,AC6				400001' 261 17 0 00 000006
	PUSH	SP,AC7				; SP,AC7				400002' 261 17 0 00 000007
	PUSH	SP,AC10				; SP,AC10				400003' 261 17 0 00 000010
	PUSH	SP,AC11				; SP,AC11				400004' 261 17 0 00 000011
	PUSH	SP,AC12				; SP,AC12				400005' 261 17 0 00 000012
	PUSH	SP,AC13				; SP,AC13				400006' 261 17 0 00 000013
	PUSH	SP,AC14				; SP,AC14				400007' 261 17 0 00 000014
	PUSH	SP,AC15				; SP,AC15				400010' 261 17 0 00 000015
	ADJSP	SP,1				; SP,1					400011' 105 17 0 00 000001
	MOVE	AC11,-13(SP)			; AC11,NUM$PRO				400012' 200 11 0 17 777765		0295
	JUMPN	AC11,L.1			; AC11,L.1				400013' 326 11 0 00 400016'
	SETO	AC0,				; AC0,					400014' 474 00 0 00 000000
	JRST	L.9				; L.9					400015' 254 00 0 00 400211'
L.1:	MOVE	AC1,AC11			; AC1,AC11				400016' 200 01 0 00 000011		0298
	PUSHJ	SP,M$GMEM			; SP,M$GMEM				400017' 260 17 0 00 000000*
	MOVE	AC14,AC2			; B$COL$HDR,AC2				400020' 200 14 0 00 000002
	MOVE	AC1,AC11			; AC1,AC11				400021' 200 01 0 00 000011		0299
	PUSHJ	SP,M$GMEM			; SP,M$GMEM				400022' 260 17 0 00 000000*
	MOVE	AC7,AC2				; C$COL$HDR,AC2				400023' 200 07 0 00 000002
	MOVE	AC12,-14(SP)			; AC12,NUM$RES				400024' 200 12 0 17 777764		0302
	MOVE	AC1,AC12			; AC1,AC12				400025' 200 01 0 00 000012
	PUSHJ	SP,M$GMEM			; SP,M$GMEM				400026' 260 17 0 00 000000*
	MOVE	AC5,AC2				; SCRATCH$VEC,AC2			400027' 200 05 0 00 000002
	MOVE	AC1,AC12			; AC1,AC12				400030' 200 01 0 00 000012		0303
	PUSHJ	SP,M$GMEM			; SP,M$GMEM				400031' 260 17 0 00 000000*
	MOVEM	AC2,0(SP)			; AC2,B$COL				400032' 202 02 0 17 000000
	MOVE	AC1,AC12			; AC1,AC12				400033' 200 01 0 00 000012		0304
	PUSHJ	SP,M$GMEM			; SP,M$GMEM				400034' 260 17 0 00 000000*
	MOVE	AC6,AC2				; C$COL,AC2				400035' 200 06 0 00 000002
	MOVE	AC1,AC12			; I,AC12				400036' 200 01 0 00 000012		0309
	AOJA	AC1,L.3				; I,L.3					400037' 344 01 0 00 400046'
L.2:	MOVE	AC2,-17(SP)			; AC2,A$MATRIX				400040' 200 02 0 17 777761		0310
	MOVE	AC0,AC1				; AC0,I					400041' 200 00 0 00 000001
	IMULI	AC0,4				; AC0,4					400042' 221 00 0 00 000004
	ADD	AC2,AC0				; AC2,AC0				400043' 270 02 0 00 000000
	LDB	AC0,C.1				; AC0,[POINT 12,2(AC2),11]  <24,12>	400044' 135 00 0 00 400224'
	MOVEM	AC0,3(AC2)			; AC0,3(AC2)				400045' 202 00 0 02 000003
L.3:	SOJG	AC1,L.2				; I,L.2					400046' 367 01 0 00 400040'		0309
	PUSH	SP,-16(SP)			; SP,B$MATRIX				400047' 261 17 0 17 777762		0314
	PUSH	SP,AC14				; SP,B$COL$HDR				400050' 261 17 0 00 000014
	PUSH	SP,AC11				; SP,AC11				400051' 261 17 0 00 000011
	PUSHJ	SP,GET$HEADER			; SP,GET$HEADER				400052' 260 17 0 00 000000V
	PUSH	SP,-20(SP)			; SP,C$MATRIX				400053' 261 17 0 17 777760		0315
	PUSH	SP,AC7				; SP,C$COL$HDR				400054' 261 17 0 00 000007
	PUSH	SP,AC11				; SP,AC11				400055' 261 17 0 00 000011
	PUSHJ	SP,GET$HEADER			; SP,GET$HEADER				400056' 260 17 0 00 000000V
	MOVE	AC1,AC11			; I,AC11				400057' 200 01 0 00 000011		0318
	AOJA	AC1,L.5				; I,L.5					400060' 344 01 0 00 400065'
L.4:	MOVE	AC2,AC14			; AC2,B$COL$HDR				400061' 200 02 0 00 000014		0319
	ADD	AC2,AC1				; AC2,I					400062' 270 02 0 00 000001
	MOVE	AC2,-1(AC2)			; T,-1(AC2)				400063' 200 02 0 02 777777
	SETZM	2(AC2)				; 2(T)					400064' 402 00 0 02 000002
L.5:	SOJG	AC1,L.4				; I,L.4					400065' 367 01 0 00 400061'		0318
	SETZ	AC10,				; SEQ$NUMBER,				400066' 400 10 0 00 000000		0321
L.6:	MOVEM	AC14,-1(SP)			; B$COL$HDR,-1(SP)			400067' 202 14 0 17 777777		0324
	MOVEM	AC11,0(SP)			; AC11,0(SP)				400070' 202 11 0 17 000000
	PUSHJ	SP,ALL$TRIED$OR$PLAYED		; SP,ALL$TRIED$OR$PLAYED		400071' 260 17 0 00 000000V
	TRNE	AC0,1				; AC0,1					400072' 602 00 0 00 000001
	JRST	L.8				; L.8					400073' 254 00 0 00 400164'
	MOVEM	AC14,-1(SP)			; B$COL$HDR,-1(SP)			400074' 202 14 0 17 777777		0328
	MOVEM	AC11,0(SP)			; AC11,0(SP)				400075' 202 11 0 17 000000
	PUSHJ	SP,NEXT$CANDIDATE		; SP,NEXT$CANDIDATE			400076' 260 17 0 00 000000V
	MOVE	AC15,AC0			; CUR$PRO,AC0				400077' 200 15 0 00 000000
	MOVEM	AC14,-3(SP)			; B$COL$HDR,-3(SP)			400100' 202 14 0 17 777775		0331
	MOVEM	AC15,-2(SP)			; CUR$PRO,-2(SP)			400101' 202 15 0 17 777776
	MOVE	AC0,-6(SP)			; AC0,B$COL				400102' 200 00 0 17 777772
	MOVEM	AC0,-1(SP)			; AC0,-1(SP)				400103' 202 00 0 17 777777
	MOVEM	AC12,0(SP)			; AC12,0(SP)				400104' 202 12 0 17 000000
	PUSHJ	SP,GET$COLUMN			; SP,GET$COLUMN				400105' 260 17 0 00 000000V
	MOVEM	AC7,-3(SP)			; C$COL$HDR,-3(SP)			400106' 202 07 0 17 777775		0332
	MOVEM	AC15,-2(SP)			; CUR$PRO,-2(SP)			400107' 202 15 0 17 777776
	MOVEM	AC6,-1(SP)			; C$COL,-1(SP)				400110' 202 06 0 17 777777
	MOVEM	AC12,0(SP)			; AC12,0(SP)				400111' 202 12 0 17 000000
	PUSHJ	SP,GET$COLUMN			; SP,GET$COLUMN				400112' 260 17 0 00 000000V
	MOVE	AC2,AC14			; AC2,B$COL$HDR				400113' 200 02 0 00 000014		0354
	ADD	AC2,AC15			; AC2,CUR$PRO				400114' 270 02 0 00 000015
	MOVE	AC13,AC2			; AC13,AC2				400115' 200 13 0 00 000002
	SUBI	AC13,1				; AC13,1				400116' 275 13 0 00 000001
	MOVEM	AC15,0(SP)			; CUR$PRO,0(SP)				400117' 202 15 0 17 000000		0334
	PUSH	SP,-25(SP)			; SP,A$MATRIX				400120' 261 17 0 17 777753
	PUSH	SP,AC14				; SP,B$COL$HDR				400121' 261 17 0 00 000014
	PUSH	SP,AC7				; SP,C$COL$HDR				400122' 261 17 0 00 000007
	PUSH	SP,-11(SP)			; SP,B$COL				400123' 261 17 0 17 777767
	PUSH	SP,AC6				; SP,C$COL				400124' 261 17 0 00 000006
	PUSH	SP,AC12				; SP,AC12				400125' 261 17 0 00 000012
	PUSH	SP,AC11				; SP,AC11				400126' 261 17 0 00 000011
	PUSH	SP,AC5				; SP,SCRATCH$VEC			400127' 261 17 0 00 000005
	PUSHJ	SP,PLAYABLE			; SP,PLAYABLE				400130' 260 17 0 00 000000V
	ADJSP	SP,-10				; SP,-10				400131' 105 17 0 00 777770
	TRNN	AC0,1				; AC0,1					400132' 606 00 0 00 000001
	JRST	L.7				; L.7					400133' 254 00 0 00 400160'
	MOVEM	AC15,0(SP)			; CUR$PRO,0(SP)				400134' 202 15 0 17 000000		0345
	PUSH	SP,-25(SP)			; SP,A$MATRIX				400135' 261 17 0 17 777753
	PUSH	SP,AC14				; SP,B$COL$HDR				400136' 261 17 0 00 000014
	PUSH	SP,AC7				; SP,C$COL$HDR				400137' 261 17 0 00 000007
	PUSH	SP,AC6				; SP,C$COL				400140' 261 17 0 00 000006
	PUSH	SP,AC12				; SP,AC12				400141' 261 17 0 00 000012
	PUSH	SP,AC11				; SP,AC11				400142' 261 17 0 00 000011
	PUSH	SP,AC5				; SP,SCRATCH$VEC			400143' 261 17 0 00 000005
	PUSHJ	SP,PLAY				; SP,PLAY				400144' 260 17 0 00 000000V
	MOVEM	AC14,-1(SP)			; B$COL$HDR,-1(SP)			400145' 202 14 0 17 777777		0353
	MOVEM	AC11,0(SP)			; AC11,0(SP)				400146' 202 11 0 17 000000
	PUSHJ	SP,NOTRY			; SP,NOTRY				400147' 260 17 0 00 000000V
	MOVE	AC1,0(AC13)			; T,0(AC13)				400150' 200 01 0 13 000000		0354
	ADDI	AC10,1				; SEQ$NUMBER,1				400151' 271 10 0 00 000001		0355
	HRRM	AC10,2(AC1)			; SEQ$NUMBER,2(T)			400152' 542 10 0 01 000002		0354
	MOVE	AC1,0(AC13)			; T,0(AC13)				400153' 200 01 0 13 000000		0356
	MOVSI	AC0,400000			; AC0,400000				400154' 205 00 0 00 400000
	IORM	AC0,2(AC1)			; AC0,2(T)				400155' 436 00 0 01 000002
	ADJSP	SP,-7				; SP,-7					400156' 105 17 0 00 777771		0344
	JRST	L.6				; L.6					400157' 254 00 0 00 400067'		0334
L.7:	MOVE	AC1,0(AC13)			; T,0(AC13)				400160' 200 01 0 13 000000		0358
	MOVSI	AC0,200000			; AC0,200000				400161' 205 00 0 00 200000
	IORM	AC0,2(AC1)			; AC0,2(T)				400162' 436 00 0 01 000002
	JRST	L.6				; L.6					400163' 254 00 0 00 400067'		0324
L.8:	MOVEM	AC14,-1(SP)			; B$COL$HDR,-1(SP)			400164' 202 14 0 17 777777		0361
	MOVEM	AC11,0(SP)			; AC11,0(SP)				400165' 202 11 0 17 000000
	PUSHJ	SP,ALL$PLAYED			; SP,ALL$PLAYED				400166' 260 17 0 00 000000V
	MOVE	AC13,AC0			; VAL,AC0				400167' 200 13 0 00 000000
	MOVE	AC1,AC11			; AC1,AC11				400170' 200 01 0 00 000011		0364
	MOVE	AC2,AC14			; AC2,B$COL$HDR				400171' 200 02 0 00 000014
	PUSHJ	SP,M$RMEM			; SP,M$RMEM				400172' 260 17 0 00 000000*
	MOVE	AC1,AC11			; AC1,AC11				400173' 200 01 0 00 000011		0365
	MOVE	AC2,AC7				; AC2,C$COL$HDR				400174' 200 02 0 00 000007
	PUSHJ	SP,M$RMEM			; SP,M$RMEM				400175' 260 17 0 00 000000*
	MOVE	AC1,AC12			; AC1,AC12				400176' 200 01 0 00 000012		0368
	MOVE	AC2,AC5				; AC2,SCRATCH$VEC			400177' 200 02 0 00 000005
	PUSHJ	SP,M$RMEM			; SP,M$RMEM				400200' 260 17 0 00 000000*
	MOVE	AC1,AC12			; AC1,AC12				400201' 200 01 0 00 000012		0369
	MOVE	AC2,-6(SP)			; AC2,B$COL				400202' 200 02 0 17 777772
	PUSHJ	SP,M$RMEM			; SP,M$RMEM				400203' 260 17 0 00 000000*
	MOVE	AC1,AC12			; AC1,AC12				400204' 200 01 0 00 000012		0370
	MOVE	AC2,AC6				; AC2,C$COL				400205' 200 02 0 00 000006
	PUSHJ	SP,M$RMEM			; SP,M$RMEM				400206' 260 17 0 00 000000*
	ADJSP	SP,-6				; SP,-6					400207' 105 17 0 00 777772		0281
	MOVE	AC0,AC13			; AC0,VAL				400210' 200 00 0 00 000013		0244
L.9:	ADJSP	SP,-1				; SP,-1					400211' 105 17 0 00 777777
	POP	SP,AC15				; SP,AC15				400212' 262 17 0 00 000015
	POP	SP,AC14				; SP,AC14				400213' 262 17 0 00 000014
	POP	SP,AC13				; SP,AC13				400214' 262 17 0 00 000013
	POP	SP,AC12				; SP,AC12				400215' 262 17 0 00 000012
	POP	SP,AC11				; SP,AC11				400216' 262 17 0 00 000011
	POP	SP,AC10				; SP,AC10				400217' 262 17 0 00 000010
	POP	SP,AC7				; SP,AC7				400220' 262 17 0 00 000007
	POP	SP,AC6				; SP,AC6				400221' 262 17 0 00 000006
	POP	SP,AC5				; SP,AC5				400222' 262 17 0 00 000005
	POPJ	SP,				; SP,					400223' 263 17 0 00 000000
C.1:	POINT	12,2(AC2),11			; 12,2(AC2),11				400224' 30 14 0 02 000002

; Routine Size:  149 words


;   0374  1	ROUTINE GET$COLUMN (COL$HDR, COLUMN, VEC, LENGTH) : NOVALUE =
;   0375  1	
;   0376  1	!++
;   0377  1	! FUNCTIONAL DESCRIPTION:
;   0378  1	!
;   0379  1	!	This routine reads a whole column of a sparse matrix
;   0380  1	!	into a vector.  It is primarily intended to be
;   0381  1	!	a performance improvement
;   0382  1	!
;   0383  1	! FORMAL PARAMETERS:
;   0384  1	!
;   0385  1	!	COL$HDR	The adrs of the column header vector of a sparse matrix
;   0386  1	!	COLUMN	The index of the desired column to rip out of the matrix
;   0387  1	!	VEC	The adrs of a vector into which to place the column
;   0388  1	!	LENGTH	The height of the sparse matrix (length of the vector)
;   0389  1	!
;   0390  1	! IMPLICIT INPUTS:
;   0391  1	!
;   0392  1	!	NONE
;   0393  1	!
;   0394  1	! IMPLICIT OUTPUTS:
;   0395  1	!
;   0396  1	!	The vector (VEC) will be written
;   0397  1	!
;   0398  1	! COMPLETION CODES:
;   0399  1	!
;   0400  1	!	NONE
;   0401  1	!
;   0402  1	! SIDE EFFECTS:
;   0403  1	!
;   0404  1	!	NONE
;   0405  1	!
;   0406  1	!--
;   0407  1	
;   0408  2	BEGIN
;   0409  2		MAP VEC : REF VECTOR1;
;   0410  2		MAP COL$HDR : REF VECTOR1;
;   0411  2	
;   0412  2		DECR I FROM .LENGTH TO 1 DO
;   0413  2			VEC [.I] = FNDROW (.COL$HDR [.COLUMN], .I);
;   0414  1	END;				!End of GET$COLUMN


GET$COLUMN:
	PUSH	SP,AC13				; SP,AC13				400225' 261 17 0 00 000013		0374
	PUSH	SP,AC14				; SP,AC14				400226' 261 17 0 00 000014
	PUSH	SP,AC15				; SP,AC15				400227' 261 17 0 00 000015
	MOVE	AC0,-7(SP)			; AC0,COL$HDR				400230' 200 00 0 17 777771		0413
	ADD	AC0,-6(SP)			; AC0,COLUMN				400231' 270 00 0 17 777772
	MOVE	AC13,AC0			; AC13,AC0				400232' 200 13 0 00 000000
	SUBI	AC13,1				; AC13,1				400233' 275 13 0 00 000001
	MOVE	AC14,-4(SP)			; I,LENGTH				400234' 200 14 0 17 777774		0412
	AOJA	AC14,L.11			; I,L.11				400235' 344 14 0 00 400245'
L.10:	MOVE	AC15,-5(SP)			; AC15,VEC				400236' 200 15 0 17 777773		0413
	ADD	AC15,AC14			; AC15,I				400237' 270 15 0 00 000014
	PUSH	SP,0(AC13)			; SP,0(AC13)				400240' 261 17 0 13 000000
	PUSH	SP,AC14				; SP,I					400241' 261 17 0 00 000014
	PUSHJ	SP,FNDROW			; SP,FNDROW				400242' 260 17 0 00 000000V
	MOVEM	AC0,-1(AC15)			; AC0,-1(AC15)				400243' 202 00 0 15 777777
	ADJSP	SP,-2				; SP,-2					400244' 105 17 0 00 777776
L.11:	SOJG	AC14,L.10			; I,L.10				400245' 367 14 0 00 400236'		0412
	POP	SP,AC15				; SP,AC15				400246' 262 17 0 00 000015		0374
	POP	SP,AC14				; SP,AC14				400247' 262 17 0 00 000014
	POP	SP,AC13				; SP,AC13				400250' 262 17 0 00 000013
	POPJ	SP,				; SP,					400251' 263 17 0 00 000000

; Routine Size:  21 words


;   0415  1	ROUTINE GET$HEADER (B$MATRIX, COL$HDR, NPRO) : NOVALUE =
;   0416  2	BEGIN
;   0417  2		MAP COL$HDR : REF VECTOR1;
;   0418  2		LOCAL COLADR : REF S$M$COL;
;;    [S$M$COL]=  S$M$COLUMN FIELD ( S$M$FIELD )
;   0419  2		LOCAL FSTFLG;
;   0420  2		GLOBAL REGISTER RETADR=S2;
;   0421  2		LABEL L;
;   0422  2	
;   0423  2		FSTFLG = TRUE;
;   0424  2	
;   0425  2		INCR I FROM 1 TO .NPRO DO
;   0426  3		    BEGIN
;   0427  3			UNTIL
;   0428  4			    BEGIN
;   0429  4				IF
;   0430  5				    (IF .FSTFLG THEN
;   0431  5					L$FIRST (.B$MATRIX) ELSE
;   0432  5					L$NEXT  (.B$MATRIX) )
;   0433  4				THEN COLADR = .RETADR
;   0434  4				ELSE STOP (UPLIT (%ASCIZ 'Can''t find column entry in sparse matrix'));
;   0435  4				FSTFLG = FALSE;
;   0436  4				NOT .COLADR [S$M$FLAGS]<%FIELDEXPAND(S$M$IGNORED)>
;   0437  3			    END DO ;
;   0438  3			COL$HDR [.I] = .COLADR;
;   0439  3			END
;   0440  1	END;				!End of GET$HEADER
; WARN#099
; Simultaneously allocated two quantities to Register 2


P.AAA:	BYTE	(7)"C","a","n","'","t"		; Can't					400252' 103 141 156 047 164
	BYTE	(7)" ","f","i","n","d"		;  find					400253' 040 146 151 156 144
	BYTE	(7)" ","c","o","l","u"		;  colu					400254' 040 143 157 154 165
	BYTE	(7)"m","n"," ","e","n"		; mn en					400255' 155 156 040 145 156
	BYTE	(7)"t","r","y"," ","i"		; try i					400256' 164 162 171 040 151
	BYTE	(7)"n"," ","s","p","a"		; n spa					400257' 156 040 163 160 141
	BYTE	(7)"r","s","e"," ","m"		; rse m					400260' 162 163 145 040 155
	BYTE	(7)"a","t","r","i","x"		; atrix					400261' 141 164 162 151 170
	BYTE	(7)000,000,000,000,000		;					400262' 000 000 000 000 000


GET$HEADER:
	PUSH	SP,AC13				; SP,AC13				400263' 261 17 0 00 000013		0415
	PUSH	SP,AC14				; SP,AC14				400264' 261 17 0 00 000014
	PUSH	SP,AC15				; SP,AC15				400265' 261 17 0 00 000015
	SETO	AC13,				; FSTFLG,				400266' 474 13 0 00 000000		0423
	SETZ	AC14,				; I,					400267' 400 14 0 00 000000		0425
	JRST	L.17				; L.17					400270' 254 00 0 00 400315'
L.12:	TRNN	AC13,1				; FSTFLG,1				400271' 606 13 0 00 000001		0430
	JRST	L.13				; L.13					400272' 254 00 0 00 400276'
	MOVE	AC1,-6(SP)			; AC1,B$MATRIX				400273' 200 01 0 17 777772		0431
	PUSHJ	SP,L$FIRST			; SP,L$FIRST				400274' 260 17 0 00 000000*
	JRST	L.14				; L.14					400275' 254 00 0 00 400300'
L.13:	MOVE	AC1,-6(SP)			; AC1,B$MATRIX				400276' 200 01 0 17 777772		0432
	PUSHJ	SP,L$NEXT			; SP,L$NEXT				400277' 260 17 0 00 000000*
L.14:	TRNN	AC0,1				; AC0,1					400300' 606 00 0 00 000001
	JRST	L.15				; L.15					400301' 254 00 0 00 400304'
	MOVE	AC15,AC2			; COLADR,RETADR				400302' 200 15 0 00 000002		0433
	JRST	L.16				; L.16					400303' 254 00 0 00 400307'		0429
L.15:	PUSH	SP,C.2				; SP,[0,,P.AAA]				400304' 261 17 0 00 400324'		0434
	PUSHJ	SP,STOP				; SP,STOP				400305' 260 17 0 00 000000V
	ADJSP	SP,-1				; SP,-1					400306' 105 17 0 00 777777
L.16:	SETZ	AC13,				; FSTFLG,				400307' 400 13 0 00 000000		0435
	SKIPGE	1(AC15)				; 1(COLADR)				400310' 335 00 0 15 000001		0436
	JRST	L.12				; L.12					400311' 254 00 0 00 400271'		0427
	MOVE	AC1,-5(SP)			; AC1,COL$HDR				400312' 200 01 0 17 777773		0438
	ADD	AC1,AC14			; AC1,I					400313' 270 01 0 00 000014
	MOVEM	AC15,-1(AC1)			; COLADR,-1(AC1)			400314' 202 15 0 01 777777
L.17:	ADDI	AC14,1				; I,1					400315' 271 14 0 00 000001		0425
	CAMG	AC14,-4(SP)			; I,NPRO				400316' 317 14 0 17 777774
	JRST	L.12				; L.12					400317' 254 00 0 00 400271'
	POP	SP,AC15				; SP,AC15				400320' 262 17 0 00 000015		0415
	POP	SP,AC14				; SP,AC14				400321' 262 17 0 00 000014
	POP	SP,AC13				; SP,AC13				400322' 262 17 0 00 000013
	POPJ	SP,				; SP,					400323' 263 17 0 00 000000
C.2:	XWD	0,P.AAA				; 0,P.AAA				400324' 000000	400252'

; Routine Size:  34 words


;   0441  1	ROUTINE FNDROW (COLADR, J) =
;   0442  1	
;   0443  1	!++
;   0444  1	! FUNCTIONAL DESCRIPTION:
;   0445  1	!
;   0446  1	! This routine will find the contents of the
;   0447  1	!  data word for a given row of a given sparse matrix column
;   0448  1	!
;   0449  1	!
;   0450  1	! FORMAL PARAMETERS:
;   0451  1	!
;   0452  1	!	COLADR	The address of the desired column in the sparse matrix
;   0453  1	!	J	The index of the desired row
;   0454  1	!
;   0455  1	! IMPLICIT INPUTS:
;   0456  1	!
;   0457  1	!	NONE
;   0458  1	!
;   0459  1	! IMPLICIT OUTPUTS:
;   0460  1	!
;   0461  1	!	NONE
;   0462  1	!
;   0463  1	! ROUTINE VALUE:
;   0464  1	!
;   0465  1	!	0 if the desired row does not exists down the given column
;   0466  1	!	otherwise, the data for the J'th row
;   0467  1	!
;   0468  1	! SIDE EFFECTS:
;   0469  1	!
;   0470  1	!	NONE
;   0471  1	!
;   0472  1	!--
;   0473  1	
;   0474  2	BEGIN
;   0475  2		MAP COLADR : REF S$M$COL;
;;    [S$M$COL]=  S$M$COLUMN FIELD ( S$M$FIELD )
;   0476  2	
;   0477  2		IF .J GTR .COLADR [S$M$FLAGS]<%FIELDEXPAND(S$M$COUNT)> THEN 0
;   0478  2		ELSE .COLADR [.J, S$M$RESOURCE]
;   0479  1	END;				!End of FNDROW


FNDROW: MOVE	AC2,-1(SP)			; AC2,J					400325' 200 02 0 17 777777		0477
	MOVE	AC1,-2(SP)			; AC1,COLADR				400326' 200 01 0 17 777776
	HRRZ	AC0,1(AC1)			; AC0,1(AC1)				400327' 550 00 0 01 000001
	CAMG	AC2,AC0				; AC2,AC0				400330' 317 02 0 00 000000
	JRST	L.18				; L.18					400331' 254 00 0 00 400334'
	SETZ	AC0,				; AC0,					400332' 400 00 0 00 000000		0474
	POPJ	SP,				; SP,					400333' 263 17 0 00 000000
L.18:	MOVE	AC0,AC1				; AC0,AC1				400334' 200 00 0 00 000001		0478
	ADD	AC0,AC2				; AC0,AC2				400335' 270 00 0 00 000002
	MOVE	AC1,AC0				; AC1,AC0				400336' 200 01 0 00 000000
	MOVE	AC0,2(AC1)			; AC0,2(AC1)				400337' 200 00 0 01 000002		0474
	POPJ	SP,				; SP,					400340' 263 17 0 00 000000		0441

; Routine Size:  12 words


;   0480  1	ROUTINE ALL$TRIED$OR$PLAYED (PBLK, NUMP) =
;   0481  1	
;   0482  1	!++
;   0483  1	! FUNCTIONAL DESCRIPTION:
;   0484  1	!
;   0485  1	!	This routine will determine if all the existing processes
;   0486  1	!	in some process block have either been tried for
;   0487  1	!	inclusion in the play sequence, or played in the sequence
;   0488  1	!
;   0489  1	! FORMAL PARAMETERS:
;   0490  1	!
;   0491  1	!	PBLK	The address of a sparse matrix column header vector
;   0492  1	!	NUMP	The length of that block
;   0493  1	!
;   0494  1	! IMPLICIT INPUTS:
;   0495  1	!
;   0496  1	!	NONE
;   0497  1	!
;   0498  1	! IMPLICIT OUTPUTS:
;   0499  1	!
;   0500  1	!	NONE
;   0501  1	!
;   0502  1	! ROUTINE VALUE:
;   0503  1	!
;   0504  1	!	TRUE	If all the existing processes have been tried, or played
;   0505  1	!	FALSE	If there are some to be looked at
;   0506  1	!
;   0507  1	! SIDE EFFECTS:
;   0508  1	!
;   0509  1	!	NONE
;   0510  1	!
;   0511  1	!--
;   0512  1	
;   0513  2	BEGIN
;   0514  2		MAP PBLK : REF S$M$HDR;
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0515  2	
;   0516  2		DECR I FROM .NUMP TO 1 DO
;   0517  3			IF  NOT (.PBLK [.I, S$M$TRIED] OR .PBLK [.I, S$M$PLAYED])
;   0518  2				THEN RETURN FALSE;
;   0519  2		TRUE
;   0520  1	END;				!End of ALL$TRIED$OR$PLAYED


ALL$TRIED$OR$PLAYED:
	PUSH	SP,AC15				; SP,AC15				400341' 261 17 0 00 000015		0480
	MOVE	AC0,-2(SP)			; I,NUMP				400342' 200 00 0 17 777776		0516
	AOJA	AC0,L.20			; I,L.20				400343' 344 00 0 00 400357'
L.19:	MOVE	AC1,-3(SP)			; AC1,PBLK				400344' 200 01 0 17 777775		0517
	ADD	AC1,AC0				; AC1,I					400345' 270 01 0 00 000000
	MOVE	AC2,-1(AC1)			; T,-1(AC1)				400346' 200 02 0 01 777777
	MOVSI	AC15,200000			; AC15,200000				400347' 205 15 0 00 200000
	TDNE	AC15,2(AC2)			; AC15,2(T)				400350' 612 15 0 02 000002
	JRST	L.20				; L.20					400351' 254 00 0 00 400357'
	MOVE	AC1,-1(AC1)			; T,-1(AC1)				400352' 200 01 0 01 777777
	SKIPGE	2(AC1)				; 2(T)					400353' 335 00 0 01 000002
	JRST	L.20				; L.20					400354' 254 00 0 00 400357'
	SETZ	AC0,				; AC0,					400355' 400 00 0 00 000000		0518
	JRST	L.21				; L.21					400356' 254 00 0 00 400361'
L.20:	SOJG	AC0,L.19			; I,L.19				400357' 367 00 0 00 400344'		0516
	SETO	AC0,				; AC0,					400360' 474 00 0 00 000000		0480
L.21:	POP	SP,AC15				; SP,AC15				400361' 262 17 0 00 000015
	POPJ	SP,				; SP,					400362' 263 17 0 00 000000

; Routine Size:  18 words


;   0521  1	ROUTINE NEXT$CANDIDATE (PBLK, NUMP) =
;   0522  1	
;   0523  1	!++
;   0524  1	! FUNCTIONAL DESCRIPTION:
;   0525  1	!
;   0526  1	!	This routine will choose a process to be played next in the
;   0527  1	!	construction of the safe sequence
;   0528  1	!	Only processes which exist and have not been tried
;   0529  1	!	or played are considered.
;   0530  1	!
;   0531  1	! FORMAL PARAMETERS:
;   0532  1	!
;   0533  1	!	PBLK	The address of a sparse matrix column header vector
;   0534  1	!	NUMP	The length of that block
;   0535  1	!
;   0536  1	! IMPLICIT INPUTS:
;   0537  1	!
;   0538  1	!	NONE
;   0539  1	!
;   0540  1	! IMPLICIT OUTPUTS:
;   0541  1	!
;   0542  1	!	NONE
;   0543  1	!
;   0544  1	! ROUTINE VALUE:
;   0545  1	!
;   0546  1	!	The number of the next process
;   0547  1	!	NOTE: if no 'next' process can be found, this routine STOPs
;   0548  1	!
;   0549  1	! SIDE EFFECTS:
;   0550  1	!
;   0551  1	!	NONE
;   0552  1	!
;   0553  1	!--
;   0554  1	
;   0555  2	BEGIN
;   0556  2		MAP PBLK : REF S$M$HDR;
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0557  2	
;   0558  2		INCR I FROM 1 TO .NUMP DO
;   0559  2			IF NOT .PBLK [.I, S$M$PLAYED] AND
;   0560  2				NOT .PBLK [.I, S$M$TRIED]
;   0561  2					THEN RETURN .I;
;   0562  2		STOP (UPLIT (%ASCIZ 'No next candidate during deadlock avoidance scan'))
;   0563  1	END;				!End of NEXT$CANDIDATE


P.AAB:	BYTE	(7)"N","o"," ","n","e"		; No ne					400363' 116 157 040 156 145
	BYTE	(7)"x","t"," ","c","a"		; xt ca					400364' 170 164 040 143 141
	BYTE	(7)"n","d","i","d","a"		; ndida					400365' 156 144 151 144 141
	BYTE	(7)"t","e"," ","d","u"		; te du					400366' 164 145 040 144 165
	BYTE	(7)"r","i","n","g"," "		; ring					400367' 162 151 156 147 040
	BYTE	(7)"d","e","a","d","l"		; deadl					400370' 144 145 141 144 154
	BYTE	(7)"o","c","k"," ","a"		; ock a					400371' 157 143 153 040 141
	BYTE	(7)"v","o","i","d","a"		; voida					400372' 166 157 151 144 141
	BYTE	(7)"n","c","e"," ","s"		; nce s					400373' 156 143 145 040 163
	BYTE	(7)"c","a","n",000,000		; can					400374' 143 141 156 000 000


NEXT$CANDIDATE:
	SETZ	AC0,				; I,					400375' 400 00 0 00 000000		0558
	JRST	L.23				; L.23					400376' 254 00 0 00 400410'
L.22:	MOVE	AC1,-2(SP)			; AC1,PBLK				400377' 200 01 0 17 777776		0559
	ADD	AC1,AC0				; AC1,I					400400' 270 01 0 00 000000
	MOVE	AC2,-1(AC1)			; T,-1(AC1)				400401' 200 02 0 01 777777
	SKIPGE	2(AC2)				; 2(T)					400402' 335 00 0 02 000002
	JRST	L.23				; L.23					400403' 254 00 0 00 400410'
	MOVE	AC1,-1(AC1)			; T,-1(AC1)				400404' 200 01 0 01 777777		0560
	MOVSI	AC2,200000			; AC2,200000				400405' 205 02 0 00 200000
	TDNN	AC2,2(AC1)			; AC2,2(T)				400406' 616 02 0 01 000002
	POPJ	SP,				; SP,					400407' 263 17 0 00 000000		0561
L.23:	ADDI	AC0,1				; I,1					400410' 271 00 0 00 000001		0558
	CAMG	AC0,-1(SP)			; I,NUMP				400411' 317 00 0 17 777777
	JRST	L.22				; L.22					400412' 254 00 0 00 400377'
	PUSH	SP,C.3				; SP,[0,,P.AAB]				400413' 261 17 0 00 400417'		0562
	PUSHJ	SP,STOP				; SP,STOP				400414' 260 17 0 00 000000V
	ADJSP	SP,-1				; SP,-1					400415' 105 17 0 00 777777		0555
	POPJ	SP,				; SP,					400416' 263 17 0 00 000000		0521
C.3:	XWD	0,P.AAB				; 0,P.AAB				400417' 000000	400363'

; Routine Size:  19 words


;   0564  1	ROUTINE NOTRY (PBLK, NUMP):NOVALUE=
;   0565  1	
;   0566  1	!++
;   0567  1	! FUNCTIONAL DESCRIPTION:
;   0568  1	!
;   0569  1	!	This routine marks all existing non-played processes
;   0570  1	!	as not tried.  This allows those processes tried (but rejected)
;   0571  1	!	during some next candidate scan to be included on the
;   0572  1	!	next candidate scan.
;   0573  1	!
;   0574  1	! FORMAL PARAMETERS:
;   0575  1	!
;   0576  1	!	PBLK	Ther address of a sparse matrix column header vector
;   0577  1	!	NUMP	The length of that block
;   0578  1	!
;   0579  1	! IMPLICIT INPUTS:
;   0580  1	!
;   0581  1	!	NONE
;   0582  1	!
;   0583  1	! IMPLICIT OUTPUTS:
;   0584  1	!
;   0585  1	!	The S$M$TRIED bit for all existing non-played processes
;   0586  1	!	is cleared
;   0587  1	!
;   0588  1	! ROUTINE VALUE:
;   0589  1	!
;   0590  1	!	NONE
;   0591  1	!
;   0592  1	! SIDE EFFECTS:
;   0593  1	!
;   0594  1	!	NONE
;   0595  1	!
;   0596  1	!--
;   0597  1	
;   0598  2	BEGIN
;   0599  2		MAP PBLK : REF S$M$HDR;
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0600  2	
;   0601  2		DECR I FROM .NUMP TO 1 DO PBLK [.I, S$M$TRIED] = FALSE;
;   0602  1	END;				!End of NOTRY


NOTRY:	MOVE	AC0,-1(SP)			; I,NUMP				400420' 200 00 0 17 777777		0601
	AOJA	AC0,L.25			; I,L.25				400421' 344 00 0 00 400427'
L.24:	MOVE	AC1,-2(SP)			; AC1,PBLK				400422' 200 01 0 17 777776
	ADD	AC1,AC0				; AC1,I					400423' 270 01 0 00 000000
	MOVE	AC1,-1(AC1)			; T,-1(AC1)				400424' 200 01 0 01 777777
	MOVSI	AC2,200000			; AC2,200000				400425' 205 02 0 00 200000
	ANDCAM	AC2,2(AC1)			; AC2,2(T)				400426' 412 02 0 01 000002
L.25:	SOJG	AC0,L.24			; I,L.24				400427' 367 00 0 00 400422'
	POPJ	SP,				; SP,					400430' 263 17 0 00 000000		0564

; Routine Size:  9 words


;   0603  1	ROUTINE ALL$PLAYED (PBLK, NUMP)=
;   0604  1	
;   0605  1	!++
;   0606  1	! FUNCTIONAL DESCRIPTION:
;   0607  1	!
;   0608  1	!	This routine will determine if all the existing processes have
;   0609  1	!	been played into the sequence
;   0610  1	!
;   0611  1	! FORMAL PARAMETERS:
;   0612  1	!
;   0613  1	!	PBLK	The address of a sparse matrix column header vector
;   0614  1	!	NUMP	The lingth of the block
;   0615  1	!
;   0616  1	! IMPLICIT INPUTS:
;   0617  1	!
;   0618  1	!	NONE
;   0619  1	!
;   0620  1	! IMPLICIT OUTPUTS:
;   0621  1	!
;   0622  1	!	NONE
;   0623  1	!
;   0624  1	! ROUTINE VALUE:
;   0625  1	!
;   0626  1	!	TRUE	If all the existing processes have been played
;   0627  1	!	FALSE	If any have not been played
;   0628  1	!
;   0629  1	! SIDE EFFECTS:
;   0630  1	!
;   0631  1	!	NONE
;   0632  1	!
;   0633  1	!--
;   0634  1	
;   0635  2	BEGIN
;   0636  2		MAP PBLK : REF S$M$HDR;
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0637  2	
;   0638  2		DECR I FROM .NUMP TO 1 DO
;   0639  2			IF NOT .PBLK [.I, S$M$PLAYED] THEN RETURN FALSE;
;   0640  2		TRUE
;   0641  1	END;				!End of ALL$PLAYED


ALL$PLAYED:
	MOVE	AC0,-1(SP)			; I,NUMP				400431' 200 00 0 17 777777		0638
	AOJA	AC0,L.27			; I,L.27				400432' 344 00 0 00 400442'
L.26:	MOVE	AC1,-2(SP)			; AC1,PBLK				400433' 200 01 0 17 777776		0639
	ADD	AC1,AC0				; AC1,I					400434' 270 01 0 00 000000
	MOVE	AC1,-1(AC1)			; T,-1(AC1)				400435' 200 01 0 01 777777
	SKIPGE	2(AC1)				; 2(T)					400436' 335 00 0 01 000002
	JRST	L.27				; L.27					400437' 254 00 0 00 400442'
	SETZ	AC0,				; AC0,					400440' 400 00 0 00 000000
	POPJ	SP,				; SP,					400441' 263 17 0 00 000000
L.27:	SOJG	AC0,L.26			; I,L.26				400442' 367 00 0 00 400433'		0638
	SETO	AC0,				; AC0,					400443' 474 00 0 00 000000		0603
	POPJ	SP,				; SP,					400444' 263 17 0 00 000000

; Routine Size:  12 words


;   0642  1	ROUTINE PLAYABLE (PROC, A, B$HDR, C$HDR, B$COL, C$COL, NRES, NPRO, RVEC) =
;   0643  1	
;   0644  1	!++
;   0645  1	! FUNCTIONAL DESCRIPTION:
;   0646  1	!
;   0647  1	!	This routine will determine if a given process is playable
;   0648  1	!	in the given allocation state.
;   0649  1	!	A process is playable if there are sufficient resources
;   0650  1	!	in the A matrix to cover the outstanding allocation
;   0651  1	!	(difference between allocated and owned) for all the
;   0652  1	!	resources the process is requesting.
;   0653  1	!	Before preforming the sufficiency check
;   0654  1	!	If the process is requesting sharable resources which
;   0655  1	!	require other resources a check is made to see
;   0656  1	!	if any other process currently owns those resources.
;   0657  1	!	If it does, then the requisite lower-level resources are
;   0658  1	!	removed from the processes outstanding allocation.
;   0659  1	!
;   0660  1	! FORMAL PARAMETERS:
;   0661  1	!
;   0662  1	!	PROC	The process to be checked for playability
;   0663  1	!	A	The address of some A (resource) matrix
;   0664  1	!	B$HDR	The address of the column header vector for the B (claim) matrix
;   0665  1	!	C$HDR	The address of the column header vector for the C (owned) matrix
;   0666  1	!	B$COL	The adrs of a vector of the B matrix column
;   0667  1	!		entries for this proccess (length NRES)
;   0668  1	!	C$COL	The adrs of a vector of the C matrix column
;   0669  1	!		entries for this proccess (length NRES)
;   0670  1	!	NRES	The largest resources number
;   0671  1	!	NPRO	The largest process number
;   0672  1	!	RVEC	The address of a scratch vector of length NRES
;   0673  1	!
;   0674  1	! IMPLICIT INPUTS:
;   0675  1	!
;   0676  1	!	The DLOC$COMP field of the A matrix is used to determine
;   0677  1	!	if there are sufficient resources to play the given process
;   0678  1	!
;   0679  1	! IMPLICIT OUTPUTS:
;   0680  1	!
;   0681  1	!	NONE
;   0682  1	!
;   0683  1	! ROUTINE VALUE:
;   0684  1	!
;   0685  1	!	TRUE	If the given process could play in this state
;   0686  1	!	FALSE	If there are insufficient resources to play this process
;   0687  1	!
;   0688  1	! SIDE EFFECTS:
;   0689  1	!
;   0690  1	!	The contents of the RVEC are clobbered
;   0691  1	!
;   0692  1	!--
;   0693  1	
;   0694  2	BEGIN
;   0695  2		MAP A : REF A$MAT;
;;    [A$MAT]=  A$MAT$STR FIELD ( A$MAT$FIELD )
;   0696  2		MAP B$HDR : REF S$M$HDR;
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0697  2		MAP C$HDR : REF S$M$HDR;
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0698  2		MAP B$COL : REF VECTOR1;
;   0699  2		MAP C$COL : REF VECTOR1;
;   0700  2		MAP RVEC : REF VECTOR1;
;   0701  2	
;   0702  2		LOCAL SHRREQ;
;   0703  2	
;   0704  2		SHRREQ = FALSE;
;   0705  2	
;   0706  2	!	First, see how many resources this process will need
;   0707  2	!	to complete in the standard sense of the algorithm.
;   0708  2	!	While we're at it, see if the process needs any high level
;   0709  2	!	resources which need to be mapped into low level resources.
;   0710  2	!	Also, if the process needs resources which couldn't be required
;   0711  2	!	as a result of such a high-to-low mapping,
;   0712  2	!	and there aren't enough of those resources in the A matrix,
;   0713  2	!	then quit now.
;   0714  2	
;   0715  2		DECR I FROM .NRES TO 1 DO
;   0716  3		BEGIN
;   0717  3			IF (RVEC [.I] = .B$COL [.I] - .C$COL [.I]) LSS 0
;   0718  3				THEN STOP (UPLIT (%ASCIZ 'Process owns more resources than it has allocated'));
;   0719  3	
;   0720  4			IF (.RVEC [.I] NEQ 0) AND (.A [.I, A$M$LEVEL] EQL SHRHIGH)
;   0721  3				THEN SHRREQ = TRUE;
;   0722  3	
;   0723  4			IF (.A [.I, A$M$LEVEL] NEQ SHRLOW) AND (.RVEC [.I] GTR .A[.I, A$M$DLOCK$COMP])
;   0724  3				 THEN RETURN FALSE;
;   0725  2		END;
;   0726  2	
;   0727  2	
;   0728  2	!	Now, if the process requires any non-permanent high level resources,
;   0729  2	!	and those high level resources are in
;   0730  2	!	use by some yet-to-be-played process, then reduce this process'
;   0731  2	!	requirement of mapped low level resoureces for each such sharable
;   0732  2	!	resource.
;   0733  2	
;   0734  2		IF .SHRREQ THEN
;   0735  2		DECR I FROM .NRES TO 1 DO
;   0736  3		IF      (.RVEC [.I] NEQ 0)
;   0737  3		    AND (.A [.I, A$M$LEVEL] EQL SHRHIGH)
;   0738  2		    AND NOT .A [.I, A$M$PERMANENT]
;   0739  2			THEN IF OTHR$USER (.I, .C$HDR, .PROC, .B$HDR, .NPRO)
;   0740  2				THEN UNMAP (.I, .RVEC);
;   0741  2	
;   0742  2	
;   0743  2	!	Now, after the arificial reduction of claim (if any),
;   0744  2	!	all we have to do is see if there are enough resources
;   0745  2	!	in the A matrix to satisfy this process.
;   0746  2	
;   0747  2		DECR I FROM .NRES TO 1 DO
;   0748  2			IF .RVEC [.I] GTR .A [.I, A$M$DLOCK$COMP] THEN RETURN FALSE;
;   0749  2	
;   0750  2		TRUE
;   0751  1	END;				!End of PLAYABLE


P.AAC:	BYTE	(7)"P","r","o","c","e"		; Proce					400445' 120 162 157 143 145
	BYTE	(7)"s","s"," ","o","w"		; ss ow					400446' 163 163 040 157 167
	BYTE	(7)"n","s"," ","m","o"		; ns mo					400447' 156 163 040 155 157
	BYTE	(7)"r","e"," ","r","e"		; re re					400450' 162 145 040 162 145
	BYTE	(7)"s","o","u","r","c"		; sourc					400451' 163 157 165 162 143
	BYTE	(7)"e","s"," ","t","h"		; es th					400452' 145 163 040 164 150
	BYTE	(7)"a","n"," ","i","t"		; an it					400453' 141 156 040 151 164
	BYTE	(7)" ","h","a","s"," "		;  has					400454' 040 150 141 163 040
	BYTE	(7)"a","l","l","o","c"		; alloc					400455' 141 154 154 157 143
	BYTE	(7)"a","t","e","d",000		; ated					400456' 141 164 145 144 000


PLAYABLE:
	PUSH	SP,AC11				; SP,AC11				400457' 261 17 0 00 000011		0642
	PUSH	SP,AC12				; SP,AC12				400460' 261 17 0 00 000012
	PUSH	SP,AC13				; SP,AC13				400461' 261 17 0 00 000013
	PUSH	SP,AC14				; SP,AC14				400462' 261 17 0 00 000014
	PUSH	SP,AC15				; SP,AC15				400463' 261 17 0 00 000015
	SETZ	AC13,				; SHRREQ,				400464' 400 13 0 00 000000		0704
	MOVE	AC12,-6(SP)			; AC12,RVEC				400465' 200 12 0 17 777772		0717
	MOVE	AC11,-15(SP)			; AC11,A				400466' 200 11 0 17 777763		0723
	MOVE	AC15,-10(SP)			; I,NRES				400467' 200 15 0 17 777770		0715
	AOJA	AC15,L.31			; I,L.31				400470' 344 15 0 00 400530'
L.28:	MOVE	AC14,AC12			; AC14,AC12				400471' 200 14 0 00 000012		0717
	ADD	AC14,AC15			; AC14,I				400472' 270 14 0 00 000015
	MOVE	AC2,-12(SP)			; AC2,B$COL				400473' 200 02 0 17 777766
	ADD	AC2,AC15			; AC2,I					400474' 270 02 0 00 000015
	MOVE	AC1,-11(SP)			; AC1,C$COL				400475' 200 01 0 17 777767
	ADD	AC1,AC15			; AC1,I					400476' 270 01 0 00 000015
	MOVE	AC0,-1(AC2)			; AC0,-1(AC2)				400477' 200 00 0 02 777777
	SUB	AC0,-1(AC1)			; AC0,-1(AC1)				400500' 274 00 0 01 777777
	MOVEM	AC0,-1(AC14)			; AC0,-1(AC14)				400501' 202 00 0 14 777777
	JUMPGE	AC0,L.29			; AC0,L.29				400502' 325 00 0 00 400506'
	PUSH	SP,C.5				; SP,[0,,P.AAC]				400503' 261 17 0 00 400623'		0718
	PUSHJ	SP,STOP				; SP,STOP				400504' 260 17 0 00 000000V
	ADJSP	SP,-1				; SP,-1					400505' 105 17 0 00 777777
L.29:	MOVE	AC2,-1(AC14)			; AC2,-1(AC14)				400506' 200 02 0 14 777777		0720
	JUMPE	AC2,L.30			; AC2,L.30				400507' 322 02 0 00 400517'
	MOVE	AC1,-15(SP)			; AC1,A					400510' 200 01 0 17 777763
	MOVE	AC0,AC15			; AC0,I					400511' 200 00 0 00 000015
	IMULI	AC0,4				; AC0,4					400512' 221 00 0 00 000004
	ADD	AC1,AC0				; AC1,AC0				400513' 270 01 0 00 000000
	LDB	AC0,C.4				; AC0,[POINT 4,1(AC1),13]  <22,4>	400514' 135 00 0 00 400622'
	CAIN	AC0,5				; AC0,5					400515' 306 00 0 00 000005
	SETO	AC13,				; SHRREQ,				400516' 474 13 0 00 000000		0721
L.30:	MOVE	AC0,AC15			; AC0,I					400517' 200 00 0 00 000015		0723
	IMULI	AC0,4				; AC0,4					400520' 221 00 0 00 000004
	MOVE	AC1,AC11			; AC1,AC11				400521' 200 01 0 00 000011
	ADD	AC1,AC0				; AC1,AC0				400522' 270 01 0 00 000000
	LDB	AC0,C.4				; AC0,[POINT 4,1(AC1),13]  <22,4>	400523' 135 00 0 00 400622'
	CAIE	AC0,2				; AC0,2					400524' 302 00 0 00 000002
	CAMG	AC2,3(AC1)			; AC2,3(AC1)				400525' 317 02 0 01 000003
	JRST	L.31				; L.31					400526' 254 00 0 00 400530'
	JRST	L.36				; L.36					400527' 254 00 0 00 400610'
L.31:	SOJG	AC15,L.28			; I,L.28				400530' 367 15 0 00 400471'		0715
	TRNN	AC13,1				; SHRREQ,1				400531' 606 13 0 00 000001		0734
	JRST	L.34				; L.34					400532' 254 00 0 00 400575'
	MOVE	AC15,-10(SP)			; I,NRES				400533' 200 15 0 17 777770		0735
	AOJA	AC15,L.33			; I,L.33				400534' 344 15 0 00 400574'
L.32:	MOVE	AC14,AC12			; AC14,AC12				400535' 200 14 0 00 000012		0736
	ADD	AC14,AC15			; AC14,I				400536' 270 14 0 00 000015
	SKIPN	-1(AC14)			; -1(AC14)				400537' 336 00 0 14 777777
	JRST	L.33				; L.33					400540' 254 00 0 00 400574'
	MOVE	AC0,AC15			; AC0,I					400541' 200 00 0 00 000015		0737
	IMULI	AC0,4				; AC0,4					400542' 221 00 0 00 000004
	MOVE	AC1,AC11			; AC1,AC11				400543' 200 01 0 00 000011
	ADD	AC1,AC0				; AC1,AC0				400544' 270 01 0 00 000000
	LDB	AC0,C.4				; AC0,[POINT 4,1(AC1),13]  <22,4>	400545' 135 00 0 00 400622'
	CAIE	AC0,5				; AC0,5					400546' 302 00 0 00 000005
	JRST	L.33				; L.33					400547' 254 00 0 00 400574'
	MOVE	AC0,AC15			; AC0,I					400550' 200 00 0 00 000015		0738
	IMULI	AC0,4				; AC0,4					400551' 221 00 0 00 000004
	MOVE	AC1,AC11			; AC1,AC11				400552' 200 01 0 00 000011
	ADD	AC1,AC0				; AC1,AC0				400553' 270 01 0 00 000000
	MOVSI	AC0,100000			; AC0,100000				400554' 205 00 0 00 100000
	TDNE	AC0,0(AC1)			; AC0,0(AC1)				400555' 612 00 0 01 000000
	JRST	L.33				; L.33					400556' 254 00 0 00 400574'
	PUSH	SP,AC15				; SP,I					400557' 261 17 0 00 000015		0739
	PUSH	SP,-14(SP)			; SP,C$HDR				400560' 261 17 0 17 777764
	PUSH	SP,-20(SP)			; SP,PROC				400561' 261 17 0 17 777760
	PUSH	SP,-17(SP)			; SP,B$HDR				400562' 261 17 0 17 777761
	PUSH	SP,-13(SP)			; SP,NPRO				400563' 261 17 0 17 777765
	PUSHJ	SP,OTHR$USER			; SP,OTHR$USER				400564' 260 17 0 00 000000V
	ADJSP	SP,-5				; SP,-5					400565' 105 17 0 00 777773
	TRNN	AC0,1				; AC0,1					400566' 606 00 0 00 000001
	JRST	L.33				; L.33					400567' 254 00 0 00 400574'
	PUSH	SP,AC15				; SP,I					400570' 261 17 0 00 000015		0740
	PUSH	SP,AC12				; SP,AC12				400571' 261 17 0 00 000012
	PUSHJ	SP,UNMAP			; SP,UNMAP				400572' 260 17 0 00 000000V
	ADJSP	SP,-2				; SP,-2					400573' 105 17 0 00 777776
L.33:	SOJG	AC15,L.32			; I,L.32				400574' 367 15 0 00 400535'		0735
L.34:	MOVE	AC0,-10(SP)			; I,NRES				400575' 200 00 0 17 777770		0747
	AOJA	AC0,L.37			; I,L.37				400576' 344 00 0 00 400612'
L.35:	MOVE	AC14,AC12			; AC14,AC12				400577' 200 14 0 00 000012		0748
	ADD	AC14,AC0			; AC14,I				400600' 270 14 0 00 000000
	MOVE	AC2,AC0				; AC2,I					400601' 200 02 0 00 000000
	IMULI	AC2,4				; AC2,4					400602' 221 02 0 00 000004
	MOVE	AC1,AC11			; AC1,AC11				400603' 200 01 0 00 000011
	ADD	AC1,AC2				; AC1,AC2				400604' 270 01 0 00 000002
	MOVE	AC2,-1(AC14)			; AC2,-1(AC14)				400605' 200 02 0 14 777777
	CAMG	AC2,3(AC1)			; AC2,3(AC1)				400606' 317 02 0 01 000003
	JRST	L.37				; L.37					400607' 254 00 0 00 400612'
L.36:	SETZ	AC0,				; AC0,					400610' 400 00 0 00 000000
	JRST	L.38				; L.38					400611' 254 00 0 00 400614'
L.37:	SOJG	AC0,L.35			; I,L.35				400612' 367 00 0 00 400577'		0747
	SETO	AC0,				; AC0,					400613' 474 00 0 00 000000		0642
L.38:	POP	SP,AC15				; SP,AC15				400614' 262 17 0 00 000015
	POP	SP,AC14				; SP,AC14				400615' 262 17 0 00 000014
	POP	SP,AC13				; SP,AC13				400616' 262 17 0 00 000013
	POP	SP,AC12				; SP,AC12				400617' 262 17 0 00 000012
	POP	SP,AC11				; SP,AC11				400620' 262 17 0 00 000011
	POPJ	SP,				; SP,					400621' 263 17 0 00 000000
C.4:	POINT	4,1(AC1),13			; 4,1(AC1),13				400622' 26 04 0 01 000001
C.5:	XWD	0,P.AAC				; 0,P.AAC				400623' 000000	400445'

; Routine Size:  101 words


;   0752  1	ROUTINE OTHR$USER (RESOURCE, C$HDR, PROC, PBLK, NPRO) =
;   0753  1	
;   0754  1	!++
;   0755  1	! FUNCTIONAL DESCRIPTION:
;   0756  1	!
;   0757  1	!	This routine will see if any other non-played process
;   0758  1	!	is requesting a particular resource
;   0759  1	!
;   0760  1	! FORMAL PARAMETERS:
;   0761  1	!
;   0762  1	!	RESOURCE The resource number
;   0763  1	!	C$HDR	The adrs of the column header vector for the C (owned) matrix
;   0764  1	!	PROC	The current process number
;   0765  1	!	PBLK	The adrs of the B matrix column header vector
;   0766  1	!	NPRO	The length of the process block
;   0767  1	!
;   0768  1	! IMPLICIT INPUTS:
;   0769  1	!
;   0770  1	!	NONE
;   0771  1	!
;   0772  1	! IMPLICIT OUTPUTS:
;   0773  1	!
;   0774  1	!	NONE
;   0775  1	!
;   0776  1	! ROUTINE VALUE:
;   0777  1	!
;   0778  1	!	TRUE 	If there are other owners of this resource (other
;   0779  1	!		than the current process) which have yet to be played
;   0780  1	!	FALSE	If this process is the last owner of this resource
;   0781  1	!
;   0782  1	! SIDE EFFECTS:
;   0783  1	!
;   0784  1	!	NONE
;   0785  1	!
;   0786  1	!--
;   0787  1	
;   0788  2	BEGIN
;   0789  2		MAP C$HDR : REF VECTOR1;
;   0790  2		MAP PBLK : REF S$M$HDR;
;;    [S$M$HDR]=  S$M$HEADER FIELD ( S$M$FIELD )
;   0791  2	
;   0792  2		DECR I FROM .NPRO TO 1 DO
;   0793  2		IF NOT .PBLK [.I, S$M$PLAYED]
;   0794  3			AND (.I NEQ .PROC)
;   0795  2			THEN
;   0796  2			IF FNDROW (.C$HDR [.I], .RESOURCE) NEQ 0
;   0797  2					THEN RETURN TRUE;
;   0798  2		FALSE
;   0799  1	END;				!End of OTHR$USER


OTHR$USER:
	PUSH	SP,AC15				; SP,AC15				400624' 261 17 0 00 000015		0752
	MOVE	AC15,-2(SP)			; I,NPRO				400625' 200 15 0 17 777776		0792
	AOJA	AC15,L.40			; I,L.40				400626' 344 15 0 00 400646'
L.39:	MOVE	AC1,-3(SP)			; AC1,PBLK				400627' 200 01 0 17 777775		0793
	ADD	AC1,AC15			; AC1,I					400630' 270 01 0 00 000015
	MOVE	AC1,-1(AC1)			; T,-1(AC1)				400631' 200 01 0 01 777777
	SKIPL	2(AC1)				; 2(T)					400632' 331 00 0 01 000002
	CAMN	AC15,-4(SP)			; I,PROC				400633' 316 15 0 17 777774		0794
	JRST	L.40				; L.40					400634' 254 00 0 00 400646'
	MOVE	AC1,-5(SP)			; AC1,C$HDR				400635' 200 01 0 17 777773		0796
	ADD	AC1,AC15			; AC1,I					400636' 270 01 0 00 000015
	PUSH	SP,-1(AC1)			; SP,-1(AC1)				400637' 261 17 0 01 777777
	PUSH	SP,-7(SP)			; SP,RESOURCE				400640' 261 17 0 17 777771
	PUSHJ	SP,FNDROW			; SP,FNDROW				400641' 260 17 0 00 400325'
	ADJSP	SP,-2				; SP,-2					400642' 105 17 0 00 777776
	JUMPE	AC0,L.40			; AC0,L.40				400643' 322 00 0 00 400646'
	SETO	AC0,				; AC0,					400644' 474 00 0 00 000000		0797
	JRST	L.41				; L.41					400645' 254 00 0 00 400650'
L.40:	SOJG	AC15,L.39			; I,L.39				400646' 367 15 0 00 400627'		0792
	SETZ	AC0,				; AC0,					400647' 400 00 0 00 000000		0752
L.41:	POP	SP,AC15				; SP,AC15				400650' 262 17 0 00 000015
	POPJ	SP,				; SP,					400651' 263 17 0 00 000000

; Routine Size:  22 words


;   0800  1	ROUTINE PLAY (PROC, A, B$HDR, C$HDR, C$COL, NRES, NPRO, RVEC) : NOVALUE =
;   0801  1	
;   0802  1	!++
;   0803  1	! FUNCTIONAL DESCRIPTION:
;   0804  1	!
;   0805  1	!	This routine will play a process from the current allocation state.
;   0806  1	!	It returns all the resources that the process currently
;   0807  1	!	owns to the resource pool.  If the process owns any high
;   0808  1	!	level resources and there exist non-played owners of
;   0809  1	!	those resources, then the low level-resources required
;   0810  1	!	by that high level resources are not returned to
;   0811  1	!	the allocation pool.
;   0812  1	!
;   0813  1	! FORMAL PARAMETERS:
;   0814  1	!
;   0815  1	!	PROC	The process number to be played
;   0816  1	!	A	The address of some A (resource) matrix
;   0817  1	!	B$HDR	The adrs of the column header vector for the B (claim) matrix
;   0818  1	!	C$HDR	The adrs of the column header vector for the C (owned) matrix
;   0819  1	!	C$COL	The adrs of a vector of the C matrix entries for
;   0820  1	!		the current PROCcess (length NRES)
;   0821  1	!	NRES	The highest resource number
;   0822  1	!	NPRO	The highest process number
;   0823  1	!	RVEC	A scratch vector of length NRES
;   0824  1	!
;   0825  1	! IMPLICIT INPUTS:
;   0826  1	!
;   0827  1	!	NONE
;   0828  1	!
;   0829  1	! IMPLICIT OUTPUTS:
;   0830  1	!
;   0831  1	!	The DLOCK$COMP field of the A matrix
;   0832  1	!	will be updated to reflect the process's giving
;   0833  1	!	up its currently owned resources
;   0834  1	!
;   0835  1	! ROUTINE VALUE:
;   0836  1	!
;   0837  1	!	NONE
;   0838  1	!
;   0839  1	! SIDE EFFECTS:
;   0840  1	!
;   0841  1	!	The contents of the RVEC are are clobbered
;   0842  1	!
;   0843  1	!--
;   0844  1	
;   0845  2	BEGIN
;   0846  2		MAP A : REF A$MAT;
;;    [A$MAT]=  A$MAT$STR FIELD ( A$MAT$FIELD )
;   0847  2		MAP B$HDR : REF S$M$HEADER;
;   0848  2		MAP C$HDR : REF S$M$HEADER;
;   0849  2		MAP C$COL : REF VECTOR1;
;   0850  2		MAP RVEC : REF VECTOR1;
;   0851  2	
;   0852  2	! Process is going to give back most of what it owns
;   0853  2		DECR I FROM .NRES TO 1 DO
;   0854  2			RVEC [.I] = .C$COL [.I];
;   0855  2	
;   0856  2	! The unmap lower level resources required by non-permanent higher lever
;   0857  2	!	resources that this process is going to give up, but which
;   0858  2	!	are shared by other users not yet played
;   0859  2		DECR I FROM .NRES TO 1 DO
;   0860  2		    IF .RVEC [.I] NEQ 0 THEN
;   0861  3			IF      (.A[.I, A$M$LEVEL] EQL SHRHIGH)
;   0862  2			    AND NOT .A [.I, A$M$PERMANENT] THEN
;   0863  2				IF OTHR$USER (.I, .C$HDR, .PROC, .B$HDR, .NPRO)
;   0864  2				    THEN UNMAP (.I, .RVEC);
;   0865  2	
;   0866  2	! After such adjustment, give back this process's resources
;   0867  2		DECR I FROM .NRES TO 1 DO
;   0868  2			A [.I, A$M$DLOCK$COMP] = .A [.I, A$M$DLOCK$COMP] + .RVEC [.I];
;   0869  1	END;				!End of PLAY


PLAY:	PUSH	SP,AC14				; SP,AC14				400652' 261 17 0 00 000014		0800
	PUSH	SP,AC15				; SP,AC15				400653' 261 17 0 00 000015
	MOVE	AC14,-3(SP)			; AC14,RVEC				400654' 200 14 0 17 777775		0854
	MOVE	AC0,-5(SP)			; I,NRES				400655' 200 00 0 17 777773		0853
	AOJA	AC0,L.43			; I,L.43				400656' 344 00 0 00 400665'
L.42:	MOVE	AC1,AC14			; AC1,AC14				400657' 200 01 0 00 000014		0854
	ADD	AC1,AC0				; AC1,I					400660' 270 01 0 00 000000
	MOVE	AC2,-6(SP)			; AC2,C$COL				400661' 200 02 0 17 777772
	ADD	AC2,AC0				; AC2,I					400662' 270 02 0 00 000000
	MOVE	AC15,-1(AC2)			; AC15,-1(AC2)				400663' 200 15 0 02 777777
	MOVEM	AC15,-1(AC1)			; AC15,-1(AC1)				400664' 202 15 0 01 777777
L.43:	SOJG	AC0,L.42			; I,L.42				400665' 367 00 0 00 400657'		0853
	MOVE	AC15,-5(SP)			; I,NRES				400666' 200 15 0 17 777773		0859
	AOJA	AC15,L.45			; I,L.45				400667' 344 15 0 00 400723'
L.44:	MOVE	AC1,AC14			; AC1,AC14				400670' 200 01 0 00 000014		0860
	ADD	AC1,AC15			; AC1,I					400671' 270 01 0 00 000015
	SKIPN	-1(AC1)				; -1(AC1)				400672' 336 00 0 01 777777
	JRST	L.45				; L.45					400673' 254 00 0 00 400723'
	MOVE	AC1,-11(SP)			; AC1,A					400674' 200 01 0 17 777767		0861
	MOVE	AC0,AC15			; AC0,I					400675' 200 00 0 00 000015
	IMULI	AC0,4				; AC0,4					400676' 221 00 0 00 000004
	ADD	AC1,AC0				; AC1,AC0				400677' 270 01 0 00 000000
	LDB	AC0,C.4				; AC0,[POINT 4,1(AC1),13]  <22,4>	400700' 135 00 0 00 400622'
	CAIE	AC0,5				; AC0,5					400701' 302 00 0 00 000005
	JRST	L.45				; L.45					400702' 254 00 0 00 400723'
	MOVSI	AC0,100000			; AC0,100000				400703' 205 00 0 00 100000		0862
	TDNE	AC0,0(AC1)			; AC0,0(AC1)				400704' 612 00 0 01 000000
	JRST	L.45				; L.45					400705' 254 00 0 00 400723'
	PUSH	SP,AC15				; SP,I					400706' 261 17 0 00 000015		0863
	PUSH	SP,-10(SP)			; SP,C$HDR				400707' 261 17 0 17 777770
	PUSH	SP,-14(SP)			; SP,PROC				400710' 261 17 0 17 777764
	PUSH	SP,-13(SP)			; SP,B$HDR				400711' 261 17 0 17 777765
	PUSH	SP,-10(SP)			; SP,NPRO				400712' 261 17 0 17 777770
	PUSHJ	SP,OTHR$USER			; SP,OTHR$USER				400713' 260 17 0 00 400624'
	ADJSP	SP,-5				; SP,-5					400714' 105 17 0 00 777773
	TRNN	AC0,1				; AC0,1					400715' 606 00 0 00 000001
	JRST	L.45				; L.45					400716' 254 00 0 00 400723'
	PUSH	SP,AC15				; SP,I					400717' 261 17 0 00 000015		0864
	PUSH	SP,AC14				; SP,AC14				400720' 261 17 0 00 000014
	PUSHJ	SP,UNMAP			; SP,UNMAP				400721' 260 17 0 00 000000V
	ADJSP	SP,-2				; SP,-2					400722' 105 17 0 00 777776
L.45:	SOJG	AC15,L.44			; I,L.44				400723' 367 15 0 00 400670'		0859
	MOVE	AC0,-5(SP)			; I,NRES				400724' 200 00 0 17 777773		0867
	AOJA	AC0,L.47			; I,L.47				400725' 344 00 0 00 400736'
L.46:	MOVE	AC1,-11(SP)			; AC1,A					400726' 200 01 0 17 777767		0868
	MOVE	AC2,AC0				; AC2,I					400727' 200 02 0 00 000000
	IMULI	AC2,4				; AC2,4					400730' 221 02 0 00 000004
	ADD	AC1,AC2				; AC1,AC2				400731' 270 01 0 00 000002
	MOVE	AC2,AC14			; AC2,AC14				400732' 200 02 0 00 000014
	ADD	AC2,AC0				; AC2,I					400733' 270 02 0 00 000000
	MOVE	AC15,-1(AC2)			; AC15,-1(AC2)				400734' 200 15 0 02 777777
	ADDM	AC15,3(AC1)			; AC15,3(AC1)				400735' 272 15 0 01 000003
L.47:	SOJG	AC0,L.46			; I,L.46				400736' 367 00 0 00 400726'		0867
	POP	SP,AC15				; SP,AC15				400737' 262 17 0 00 000015		0800
	POP	SP,AC14				; SP,AC14				400740' 262 17 0 00 000014
	POPJ	SP,				; SP,					400741' 263 17 0 00 000000

; Routine Size:  56 words


;   0870  1	ROUTINE UNMAP (RES, RVEC) : NOVALUE =
;   0871  1	
;   0872  1	!++
;   0873  1	! FUNCTIONAL DESCRIPTION:
;   0874  1	!
;   0875  1	!	This routine removes lower level resources required by
;   0876  1	!	a given high level resource from a resource vector
;   0877  1	!
;   0878  1	! FORMAL PARAMETERS:
;   0879  1	!
;   0880  1	!	RES	The high level resource number
;   0881  1	!	RVEC	The address of a resource vector
;   0882  1	!
;   0883  1	! IMPLICIT INPUTS:
;   0884  1	!
;   0885  1	!	The catalog (external) is used to map the high level
;   0886  1	!	resource number into its component low
;   0887  1	!	level resource number(s) and quantities therof.
;   0888  1	!
;   0889  1	! IMPLICIT OUTPUTS:
;   0890  1	!
;   0891  1	!	The RVEC is decreased by the amount of each lower level
;   0892  1	!	resource.
;   0893  1	!
;   0894  1	! ROUTINE VALUE:
;   0895  1	!
;   0896  1	!	NONE
;   0897  1	!
;   0898  1	! SIDE EFFECTS:
;   0899  1	!
;   0900  1	!	NONE
;   0901  1	!
;   0902  1	!--
;   0903  1	
;   0904  2	BEGIN
;   0905  2		MAP RVEC : REF VECTOR1;
;   0906  2		LOCAL CATADR : REF VECTOR;
;   0907  2		GLOBAL REGISTER RETADR=S2;
;   0908  2	
;   0909  2		IF V$BCAT (.RES)
;   0910  2			THEN CATADR = .RETADR
;   0911  2			ELSE STOP (UPLIT (%ASCIZ 'No catalog info for high level sharable resource'));
;   0912  2		INCR I FROM 1 TO .CATADR [$CQNVL] DO
;   0913  3			BEGIN
;   0914  3				LOCAL J;
;   0915  3				J = .CATADR [$CQVSL + $CQRSN + ((.I - 1) * $CQVLL)];
;   0916  3				RVEC [.J] = .RVEC [.J] -1
;   0917  2			END;
;   0918  1	END;				!End of UNMAP


P.AAD:	BYTE	(7)"N","o"," ","c","a"		; No ca					400742' 116 157 040 143 141
	BYTE	(7)"t","a","l","o","g"		; talog					400743' 164 141 154 157 147
	BYTE	(7)" ","i","n","f","o"		;  info					400744' 040 151 156 146 157
	BYTE	(7)" ","f","o","r"," "		;  for					400745' 040 146 157 162 040
	BYTE	(7)"h","i","g","h"," "		; high					400746' 150 151 147 150 040
	BYTE	(7)"l","e","v","e","l"		; level					400747' 154 145 166 145 154
	BYTE	(7)" ","s","h","a","r"		;  shar					400750' 040 163 150 141 162
	BYTE	(7)"a","b","l","e"," "		; able					400751' 141 142 154 145 040
	BYTE	(7)"r","e","s","o","u"		; resou					400752' 162 145 163 157 165
	BYTE	(7)"r","c","e",000,000		; rce					400753' 162 143 145 000 000


UNMAP:	PUSH	SP,AC15				; SP,AC15				400754' 261 17 0 00 000015		0870
	MOVE	AC1,-3(SP)			; AC1,RES				400755' 200 01 0 17 777775		0909
	PUSHJ	SP,V$BCAT			; SP,V$BCAT				400756' 260 17 0 00 000000*
	TRNN	AC0,1				; AC0,1					400757' 606 00 0 00 000001
	JRST	L.48				; L.48					400760' 254 00 0 00 400763'
	MOVE	AC15,AC2			; CATADR,RETADR				400761' 200 15 0 00 000002		0910
	JRST	L.49				; L.49					400762' 254 00 0 00 400766'		0909
L.48:	PUSH	SP,C.6				; SP,[0,,P.AAD]				400763' 261 17 0 00 401005'		0911
	PUSHJ	SP,STOP				; SP,STOP				400764' 260 17 0 00 000000V
	ADJSP	SP,-1				; SP,-1					400765' 105 17 0 00 777777
L.49:	SETZ	AC0,				; I,					400766' 400 00 0 00 000000		0912
	JRST	L.51				; L.51					400767' 254 00 0 00 401000'
L.50:	MOVE	AC2,AC0				; AC2,I					400770' 200 02 0 00 000000		0915
	IMULI	AC2,2				; AC2,2					400771' 221 02 0 00 000002
	MOVE	AC1,AC15			; AC1,CATADR				400772' 200 01 0 00 000015
	ADD	AC1,AC2				; AC1,AC2				400773' 270 01 0 00 000002
	MOVE	AC2,34(AC1)			; J,34(AC1)				400774' 200 02 0 01 000034
	MOVE	AC1,-2(SP)			; AC1,RVEC				400775' 200 01 0 17 777776		0916
	ADD	AC1,AC2				; AC1,J					400776' 270 01 0 00 000002
	SOS	-1(AC1)				; -1(AC1)				400777' 370 00 0 01 777777
L.51:	ADDI	AC0,1				; I,1					401000' 271 00 0 00 000001		0912
	CAMG	AC0,13(AC15)			; I,13(CATADR)				401001' 317 00 0 15 000013
	JRST	L.50				; L.50					401002' 254 00 0 00 400770'
	POP	SP,AC15				; SP,AC15				401003' 262 17 0 00 000015		0870
	POPJ	SP,				; SP,					401004' 263 17 0 00 000000
C.6:	XWD	0,P.AAD				; 0,P.AAD				401005' 000000	400742'

; Routine Size:  26 words


;   0919  1	ROUTINE STOP (STRING$ADRS) =
;   0920  1	
;   0921  1	!++
;   0922  1	! FUNCTIONAL DESCRIPTION:
;   0923  1	!
;   0924  1	!	This routine calls a GLXLIB $STOP routine externally
;   0925  1	!	And passes an explanative string to be printed out.
;   0926  1	!
;   0927  1	!	NOTE WELL::  THIS ROUTINE NEVER RETURNS
;   0928  1	!
;   0929  1	!	This routine is separate from other routine bodies
;   0930  1	!	to avoid conflicts with register allocation among
;   0931  1	!	other GLX linkages in the other routine bodies.
;   0932  1	!
;   0933  1	! FORMAL PARAMETERS:
;   0934  1	!
;   0935  1	!	STRING$ADRS	The adrs of an ASCIZ string
;   0936  1	!
;   0937  1	! IMPLICIT INPUTS:
;   0938  1	!
;   0939  1	!	NONE
;   0940  1	!
;   0941  1	! IMPLICIT OUTPUTS:
;   0942  1	!
;   0943  1	!	NONE
;   0944  1	!
;   0945  1	! ROUTINE VALUE:
;   0946  1	!
;   0947  1	!	NONE
;   0948  1	!
;   0949  1	! SIDE EFFECTS:
;   0950  1	!
;   0951  1	!	NONE
;   0952  1	!
;   0953  1	!--
;   0954  1	
;   0955  1	D$STOP (.STRING$ADRS);


STOP:	MOVE	AC1,-1(SP)			; AC1,STRING$ADRS			401006' 200 01 0 17 777777		0955
	JRST	D$STOP				; D$STOP				401007' 254 00 0 00 000000*

; Routine Size:  2 words


;   0956  1	GLOBAL ROUTINE D$DUMP (A, B, C, NR, NP) : NOVALUE=
;   0957  2	BEGIN
;   0958  2		MAP	A : REF A$MAT;
;;    [A$MAT]=  A$MAT$STR FIELD ( A$MAT$FIELD )
;   0959  2	
;   0960  2		LOCAL COUNT;
;   0961  2		LOCAL B$HDR : REF VECTOR1;
;   0962  2		LOCAL C$HDR : REF VECTOR1;
;   0963  2	
;   0964  2		IF .NP NEQ 0 THEN
;   0965  3		BEGIN
;   0966  3			B$HDR = M$GMEM (.NP);
;   0967  3			C$HDR = M$GMEM (.NP);
;   0968  3			GET$HEADER (.B, .B$HDR, .NP);
;   0969  3			GET$HEADER (.C, .C$HDR, .NP);
;   0970  2		END;
;   0971  2	
;   0972  2		COUNT  = 0;
;   0973  2		INCR I FROM 1 TO .NR DO
;   0974  2			IF .A [.I, A$M$NAME] NEQ 0 THEN
;   0975  3			BEGIN
;   0976  3				D$DEC (.I);
;   0977  3				D$TEXT (.A [.I, A$M$NAME]);
;   0978  3				IF (COUNT = .COUNT + 1) MOD 5 EQL 0 THEN D$CR();
;   0979  2			END;
;   0980  2		D$CR();
;   0981  2		D$CR();
;   0982  2	
;   0983  2		D$DEC(0);
;   0984  2		INCR I FROM 1 TO .NR DO
;   0985  2			D$DEC (.I);
;   0986  2		D$CR();
;   0987  2		D$DEC(0);
;   0988  2		INCR I FROM 1 TO .NR DO
;   0989  2			D$DEC (.A [.I, A$M$AVA]);
;   0990  2		D$CR();
;   0991  2		D$DEC(0);
;   0992  2		INCR I FROM 1 TO .NR DO
;   0993  2			D$DEC (.A [.I, A$M$USE]);
;   0994  2		D$CR();
;   0995  2		D$CR();
;   0996  2	
;   0997  2		INCR I FROM 1 TO .NP DO
;   0998  3			BEGIN
;   0999  3			D$DEC(.I);
;   1000  3			INCR J FROM 1 TO .NR DO
;   1001  3				D$DEC (FNDROW(.B$HDR[.I],.J));
;   1002  3			D$CR();
;   1003  3			D$DEC(.I);
;   1004  3			INCR J FROM 1 TO .NR DO
;   1005  3				D$DEC (FNDROW(.C$HDR[.I],.J));
;   1006  3			D$CR();
;   1007  3			D$CR();
;   1008  2			END;
;   1009  2		IF .NP NEQ 0 THEN
;   1010  3		BEGIN
;   1011  3			M$RMEM (.NP, .B$HDR);
;   1012  3			M$RMEM (.NP, .C$HDR);
;   1013  2		END;
;   1014  1	END;				!End of D$DUMP


D$DUMP::PUSH	SP,AC5				; SP,AC5				401010' 261 17 0 00 000005		0956
	PUSH	SP,AC6				; SP,AC6				401011' 261 17 0 00 000006
	PUSH	SP,AC7				; SP,AC7				401012' 261 17 0 00 000007
	PUSH	SP,AC10				; SP,AC10				401013' 261 17 0 00 000010
	PUSH	SP,AC11				; SP,AC11				401014' 261 17 0 00 000011
	PUSH	SP,AC12				; SP,AC12				401015' 261 17 0 00 000012
	PUSH	SP,AC13				; SP,AC13				401016' 261 17 0 00 000013
	PUSH	SP,AC14				; SP,AC14				401017' 261 17 0 00 000014
	PUSH	SP,AC15				; SP,AC15				401020' 261 17 0 00 000015
	MOVE	AC10,-12(SP)			; AC10,NP				401021' 200 10 0 17 777766		0964
	SETZ	AC5,				; AC5,					401022' 400 05 0 00 000000
	JUMPE	AC10,L.52			; AC10,L.52				401023' 322 10 0 00 401044'
	MOVEI	AC5,1				; AC5,1					401024' 201 05 0 00 000001
	MOVE	AC1,AC10			; AC1,AC10				401025' 200 01 0 00 000010		0966
	PUSHJ	SP,M$GMEM			; SP,M$GMEM				401026' 260 17 0 00 000000*
	MOVE	AC7,AC2				; B$HDR,AC2				401027' 200 07 0 00 000002
	MOVE	AC1,AC10			; AC1,AC10				401030' 200 01 0 00 000010		0967
	PUSHJ	SP,M$GMEM			; SP,M$GMEM				401031' 260 17 0 00 000000*
	MOVE	AC6,AC2				; C$HDR,AC2				401032' 200 06 0 00 000002
	PUSH	SP,-15(SP)			; SP,B					401033' 261 17 0 17 777763		0968
	PUSH	SP,AC7				; SP,B$HDR				401034' 261 17 0 00 000007
	PUSH	SP,AC10				; SP,AC10				401035' 261 17 0 00 000010
	PUSHJ	SP,GET$HEADER			; SP,GET$HEADER				401036' 260 17 0 00 400263'
	PUSH	SP,-17(SP)			; SP,C					401037' 261 17 0 17 777761		0969
	PUSH	SP,AC6				; SP,C$HDR				401040' 261 17 0 00 000006
	PUSH	SP,AC10				; SP,AC10				401041' 261 17 0 00 000010
	PUSHJ	SP,GET$HEADER			; SP,GET$HEADER				401042' 260 17 0 00 400263'
	ADJSP	SP,-6				; SP,-6					401043' 105 17 0 00 777772		0965
L.52:	SETZ	AC12,				; COUNT,				401044' 400 12 0 00 000000		0972
	MOVE	AC13,-13(SP)			; AC13,NR				401045' 200 13 0 17 777765		0973
	MOVE	AC11,-16(SP)			; AC11,A				401046' 200 11 0 17 777762		0974
	SETZ	AC14,				; I,					401047' 400 14 0 00 000000		0973
	JRST	L.54				; L.54					401050' 254 00 0 00 401070'
L.53:	MOVE	AC1,AC14			; AC1,I					401051' 200 01 0 00 000014		0974
	IMULI	AC1,4				; AC1,4					401052' 221 01 0 00 000004
	MOVE	AC15,AC11			; AC15,AC11				401053' 200 15 0 00 000011
	ADD	AC15,AC1			; AC15,AC1				401054' 270 15 0 00 000001
	HRRZ	AC0,0(AC15)			; AC0,0(AC15)				401055' 550 00 0 15 000000
	JUMPE	AC0,L.54			; AC0,L.54				401056' 322 00 0 00 401070'
	MOVE	AC1,AC14			; AC1,I					401057' 200 01 0 00 000014		0976
	PUSHJ	SP,D$DEC			; SP,D$DEC				401060' 260 17 0 00 000000*
	HRRZ	AC1,0(AC15)			; AC1,0(AC15)				401061' 550 01 0 15 000000		0977
	PUSHJ	SP,D$TEXT			; SP,D$TEXT				401062' 260 17 0 00 000000*
	AOS	AC1,AC12			; AC1,COUNT				401063' 350 01 0 00 000012		0978
	IDIVI	AC1,5				; AC1,5					401064' 231 01 0 00 000005
	MOVE	AC0,AC2				; AC0,AC2				401065' 200 00 0 00 000002
	JUMPN	AC0,L.54			; AC0,L.54				401066' 326 00 0 00 401070'
	PUSHJ	SP,D$CR				; SP,D$CR				401067' 260 17 0 00 000000*
L.54:	ADDI	AC14,1				; I,1					401070' 271 14 0 00 000001		0973
	CAMG	AC14,AC13			; I,AC13				401071' 317 14 0 00 000013
	JRST	L.53				; L.53					401072' 254 00 0 00 401051'
	PUSHJ	SP,D$CR				; SP,D$CR				401073' 260 17 0 00 000000*		0980
	PUSHJ	SP,D$CR				; SP,D$CR				401074' 260 17 0 00 000000*		0981
	SETZ	AC1,				; AC1,					401075' 400 01 0 00 000000		0983
	PUSHJ	SP,D$DEC			; SP,D$DEC				401076' 260 17 0 00 000000*
	SETZ	AC15,				; I,					401077' 400 15 0 00 000000		0984
	JRST	L.56				; L.56					401100' 254 00 0 00 401103'
L.55:	MOVE	AC1,AC15			; AC1,I					401101' 200 01 0 00 000015		0985
	PUSHJ	SP,D$DEC			; SP,D$DEC				401102' 260 17 0 00 000000*
L.56:	ADDI	AC15,1				; I,1					401103' 271 15 0 00 000001		0984
	CAMG	AC15,AC13			; I,AC13				401104' 317 15 0 00 000013
	JRST	L.55				; L.55					401105' 254 00 0 00 401101'
	PUSHJ	SP,D$CR				; SP,D$CR				401106' 260 17 0 00 000000*		0986
	SETZ	AC1,				; AC1,					401107' 400 01 0 00 000000		0987
	PUSHJ	SP,D$DEC			; SP,D$DEC				401110' 260 17 0 00 000000*
	SETZ	AC15,				; I,					401111' 400 15 0 00 000000		0988
	JRST	L.58				; L.58					401112' 254 00 0 00 401121'
L.57:	MOVE	AC0,AC15			; AC0,I					401113' 200 00 0 00 000015		0989
	IMULI	AC0,4				; AC0,4					401114' 221 00 0 00 000004
	MOVE	AC2,AC11			; AC2,AC11				401115' 200 02 0 00 000011
	ADD	AC2,AC0				; AC2,AC0				401116' 270 02 0 00 000000
	LDB	AC1,C.1				; AC1,[POINT 12,2(AC2),11]  <24,12>	401117' 135 01 0 00 400224'
	PUSHJ	SP,D$DEC			; SP,D$DEC				401120' 260 17 0 00 000000*
L.58:	ADDI	AC15,1				; I,1					401121' 271 15 0 00 000001		0988
	CAMG	AC15,AC13			; I,AC13				401122' 317 15 0 00 000013
	JRST	L.57				; L.57					401123' 254 00 0 00 401113'
	PUSHJ	SP,D$CR				; SP,D$CR				401124' 260 17 0 00 000000*		0990
	SETZ	AC1,				; AC1,					401125' 400 01 0 00 000000		0991
	PUSHJ	SP,D$DEC			; SP,D$DEC				401126' 260 17 0 00 000000*
	SETZ	AC15,				; I,					401127' 400 15 0 00 000000		0992
	JRST	L.60				; L.60					401130' 254 00 0 00 401137'
L.59:	MOVE	AC0,AC15			; AC0,I					401131' 200 00 0 00 000015		0993
	IMULI	AC0,4				; AC0,4					401132' 221 00 0 00 000004
	MOVE	AC2,AC11			; AC2,AC11				401133' 200 02 0 00 000011
	ADD	AC2,AC0				; AC2,AC0				401134' 270 02 0 00 000000
	LDB	AC1,C.7				; AC1,[POINT 12,2(AC2),35]  <0,12>	401135' 135 01 0 00 401240'
	PUSHJ	SP,D$DEC			; SP,D$DEC				401136' 260 17 0 00 000000*
L.60:	ADDI	AC15,1				; I,1					401137' 271 15 0 00 000001		0992
	CAMG	AC15,AC13			; I,AC13				401140' 317 15 0 00 000013
	JRST	L.59				; L.59					401141' 254 00 0 00 401131'
	PUSHJ	SP,D$CR				; SP,D$CR				401142' 260 17 0 00 000000*		0994
	PUSHJ	SP,D$CR				; SP,D$CR				401143' 260 17 0 00 000000*		0995
	SETZ	AC14,				; I,					401144' 400 14 0 00 000000		0997
	JRST	L.66				; L.66					401145' 254 00 0 00 401213'
L.61:	MOVE	AC1,AC14			; AC1,I					401146' 200 01 0 00 000014		0999
	PUSHJ	SP,D$DEC			; SP,D$DEC				401147' 260 17 0 00 000000*
	MOVE	AC2,AC7				; AC2,B$HDR				401150' 200 02 0 00 000007		1001
	ADD	AC2,AC14			; AC2,I					401151' 270 02 0 00 000014
	MOVE	AC12,AC2			; AC12,AC2				401152' 200 12 0 00 000002
	SUBI	AC12,1				; AC12,1				401153' 275 12 0 00 000001
	SETZ	AC15,				; J,					401154' 400 15 0 00 000000		1000
	JRST	L.63				; L.63					401155' 254 00 0 00 401164'
L.62:	PUSH	SP,0(AC12)			; SP,0(AC12)				401156' 261 17 0 12 000000		1001
	PUSH	SP,AC15				; SP,J					401157' 261 17 0 00 000015
	PUSHJ	SP,FNDROW			; SP,FNDROW				401160' 260 17 0 00 400325'
	MOVE	AC1,AC0				; AC1,AC0				401161' 200 01 0 00 000000
	PUSHJ	SP,D$DEC			; SP,D$DEC				401162' 260 17 0 00 000000*
	ADJSP	SP,-2				; SP,-2					401163' 105 17 0 00 777776
L.63:	ADDI	AC15,1				; J,1					401164' 271 15 0 00 000001		1000
	CAMG	AC15,AC13			; J,AC13				401165' 317 15 0 00 000013
	JRST	L.62				; L.62					401166' 254 00 0 00 401156'
	PUSHJ	SP,D$CR				; SP,D$CR				401167' 260 17 0 00 000000*		1002
	MOVE	AC1,AC14			; AC1,I					401170' 200 01 0 00 000014		1003
	PUSHJ	SP,D$DEC			; SP,D$DEC				401171' 260 17 0 00 000000*
	MOVE	AC2,AC6				; AC2,C$HDR				401172' 200 02 0 00 000006		1005
	ADD	AC2,AC14			; AC2,I					401173' 270 02 0 00 000014
	MOVE	AC12,AC2			; AC12,AC2				401174' 200 12 0 00 000002
	SUBI	AC12,1				; AC12,1				401175' 275 12 0 00 000001
	SETZ	AC15,				; J,					401176' 400 15 0 00 000000		1004
	JRST	L.65				; L.65					401177' 254 00 0 00 401206'
L.64:	PUSH	SP,0(AC12)			; SP,0(AC12)				401200' 261 17 0 12 000000		1005
	PUSH	SP,AC15				; SP,J					401201' 261 17 0 00 000015
	PUSHJ	SP,FNDROW			; SP,FNDROW				401202' 260 17 0 00 400325'
	MOVE	AC1,AC0				; AC1,AC0				401203' 200 01 0 00 000000
	PUSHJ	SP,D$DEC			; SP,D$DEC				401204' 260 17 0 00 000000*
	ADJSP	SP,-2				; SP,-2					401205' 105 17 0 00 777776
L.65:	ADDI	AC15,1				; J,1					401206' 271 15 0 00 000001		1004
	CAMG	AC15,AC13			; J,AC13				401207' 317 15 0 00 000013
	JRST	L.64				; L.64					401210' 254 00 0 00 401200'
	PUSHJ	SP,D$CR				; SP,D$CR				401211' 260 17 0 00 000000*		1006
	PUSHJ	SP,D$CR				; SP,D$CR				401212' 260 17 0 00 000000*		1007
L.66:	ADDI	AC14,1				; I,1					401213' 271 14 0 00 000001		0997
	CAMG	AC14,AC10			; I,AC10				401214' 317 14 0 00 000010
	JRST	L.61				; L.61					401215' 254 00 0 00 401146'
	TRNN	AC5,1				; AC5,1					401216' 606 05 0 00 000001		1009
	JRST	L.67				; L.67					401217' 254 00 0 00 401226'
	MOVE	AC1,AC10			; AC1,AC10				401220' 200 01 0 00 000010		1011
	MOVE	AC2,AC7				; AC2,B$HDR				401221' 200 02 0 00 000007
	PUSHJ	SP,M$RMEM			; SP,M$RMEM				401222' 260 17 0 00 000000*
	MOVE	AC1,AC10			; AC1,AC10				401223' 200 01 0 00 000010		1012
	MOVE	AC2,AC6				; AC2,C$HDR				401224' 200 02 0 00 000006
	PUSHJ	SP,M$RMEM			; SP,M$RMEM				401225' 260 17 0 00 000000*
L.67:	POP	SP,AC15				; SP,AC15				401226' 262 17 0 00 000015		0956
	POP	SP,AC14				; SP,AC14				401227' 262 17 0 00 000014
	POP	SP,AC13				; SP,AC13				401230' 262 17 0 00 000013
	POP	SP,AC12				; SP,AC12				401231' 262 17 0 00 000012
	POP	SP,AC11				; SP,AC11				401232' 262 17 0 00 000011
	POP	SP,AC10				; SP,AC10				401233' 262 17 0 00 000010
	POP	SP,AC7				; SP,AC7				401234' 262 17 0 00 000007
	POP	SP,AC6				; SP,AC6				401235' 262 17 0 00 000006
	POP	SP,AC5				; SP,AC5				401236' 262 17 0 00 000005
	POPJ	SP,				; SP,					401237' 263 17 0 00 000000
C.7:	POINT	12,2(AC2),35			; 12,2(AC2),35				401240' 00 14 0 02 000002

; Routine Size:  153 words


;   1015  1	END				!End of module
;   1016  0	ELUDOM



END
