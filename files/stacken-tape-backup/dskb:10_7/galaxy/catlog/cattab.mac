TITLE	CATTAB - Application table for the DECsystem-10 Catalog Daemon
SUBTTL	D. Mastrovito /DPM	26-Nov-85

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1986.
;ALL RIGHTS RESERVED.
;
	SEARCH	CATPRM			;CATALOG DEFINITIONS
	CATDEF	(CATTAB)		;DEFINE COMMON PARAMTERS

CATTAB::EXP	2		 ;LENGTH
	EXP	INI010		 ;ADDRESS OF $INIT PDB
	EXP	KEY010		 ;ADDR OF TOP LEVEL $KEY PDB
CATGVN:	EXP	GLXVRS		 ;GLXLIB VERSION
CATVRN:	EXP	%%CAT		 ;CATALOG VERSION
.BCOPY
COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1986. ALL RIGHTS RESERVED.
\;END OF COPYRIGHT MACRO
.ECOPY


SUBPMT:	ASCIZ	|CATALOG>>|		;SUB-COMMAND PROMPT

	DEVTBL==0		;SWITCH TABLE ADDRESS
	DEVHLP==1		;BYTE POINTER TO HELP TEXT
	DEVLST==2		;SIXBIT FILE NAME FOR LISTINGS

DEVPTR:	BLOCK	1		;ADDRESS OF DEVICE POINTERS
FNCCOD:	BLOCK	1		;CATALOG FUNCTION CODE
PPNBLK:	BLOCK	2		;WILDCARD PPN BLOCK

FIL.ZB:!			;START OF FILESPEC DEFAULT BLOCK
FILFOB:	BLOCK	FOB.SZ		;FOB
FILBLK:	BLOCK	FDXSIZ		;GALAXY FILE DESCRIPTOR BLOCK
FILTXT:	BLOCK	<^D68/5>+1	;ROOM FOR A FULL ASCIZ FILESPEC
FILERR:	BLOCK	^D24		;ROOM FOR A 120 CHARACTER ERROR MESSAGE
FIL.ZE:!			;END OF FILESPEC DEFAULT BLOCK
INI010:	$INIT(KEY010)

KEY010:	$KEYDSP	(KEY020,<$PREFI (INIACT),$ACTION (FNCACT)>)
KEY020:	$STAB
	DSPTAB	(DEL010,.CTDEL,<DELETE>)
	DSPTAB	(DIS010,.CTDIS,<DISABLE>)
	DSPTAB	(ENA010,.CTENA,<ENABLE>)
	DSPTAB	(HLP010,.CTHLP,<HELP>)
	DSPTAB	(INS010,.CTINS,<INSERT>)
	DSPTAB	(LIS010,.CTLIS,<LIST>)
	DSPTAB	(MOD010,.CTMOD,<MODIFY>)
	DSPTAB	(SHO010,.CTSHO,<SHOW>)
	$ETAB

DEL010:	$KEY	(DEL020,DEVTAB,<$ACTION (DEVACT)>)
DEL020:	$FIELD	(DEL030,<FOO>,<$PREFI (HLPACT)>)
DEL030:	$CRLF

DIS010:	$KEY	(DIS020,DEVTAB,<$ACTION (DEVACT)>)
DIS020:	$NOISE	(DIS030,<catalog updates by MDA>)
DIS030:	$CRLF

ENA010:	$KEY	(ENA020,DEVTAB,<$ACTION (DEVACT)>)
ENA020:	$NOISE	(ENA030,<catalog updates by MDA>)
ENA030:	$CRLF

HLP010:	$NOISE	(HLP020,<with>)
HLP020:	$KEY	(HLP030,KEY020,<$DEFAULT (<HELP>)>)
HLP030:	$CRLF	(<$ACTION (HELPER)>)

HELPER:	MOVEI	S1,HELPFD		;POINT TO HELP FILE FD
	HLRO	S2,@CR.RES(S2)		;GET ADDRESS OF KEYWORD TEXT
	PUSHJ	P,P$HELP##		;READ AND TYPE HELP FILE
	PUSHJ	P,P$NPRO##		;NO PROCESSING NEEDED
	$RETT				;RETURN

HELPFD:	$BUILD	(FDMSIZ)		;SIZE OF BLOCK
	  $SET	(.FDLEN,FD.LEN,FDMSIZ)	;LENGTH OF FD
	  $SET	(.FDLEN,FD.TYP,.FDNAT)	;FILE SPEC TYPE (NATIVE)
	  $SET	(.FDSTR,,<'HLP   '>)	;ERSATZ DEVICE HLP:
	  $SET	(.FDNAM,,<'CATLOG'>)	;FILE NAME
	  $SET	(.FDEXT,,<'HLP   '>)	;EXTENSION
	$EOB				;END OF BLOCK

INS010:	$KEY	(INS020,DEVTAB,<$ACTION (DEVACT)>)
INS020:	$FIELD	(INS030,<FOO>,<$PREFI (HLPACT)>)
INS030:	$TOKEN	(INS040,<=>,<$PREFI (COPACT)>)
INS040:	$FIELD	(,<FOO>,<$PREFI (HLPACT),$ACTION (TBLACT)>)


LIS010:	$KEY	(LIS020,DEVTAB,<$ACTION (DEVACT)>)
LIS020:	$NOISE	(LIS030,<entries>)
LIS030:	$OFILE	(LIS040,<listing filespec>,<$PDEFA (FILTXT),$PREFI (FILDEF),$ACTION (FILACT)>)
LIS040:	$CRLF


MOD010:	$KEY	(MOD020,DEVTAB,<$ACTION (DEVACT)>)
MOD020:	$FIELD	(,<FOO>,<$PREFI (HLPACT),$ACTION (TBLACT)>)


SHO010:	$KEY	(SHO020,DEVTAB,<$ACTION (DEVACT)>)
SHO020:	$FIELD	(SHO030,<FOO>,<$PREFI (HLPACT)>)
SHO030:	$CRLF


INIACT:	SETZM	FNCCOD			;INIT CATALOG FUNCTION CODE
	$RETT				;RETURN

FNCACT:	MOVE	S1,CR.RES(S2)		;GET ADDR OF RESULT
	HRRZ	S1,(S1)			;GET KEYWORD CODE POINTER
	HLRZ	S1,(S1)			;NOW GET THE CODE
	MOVEM	S1,FNCCOD		;SAVE FOR LATER
	$RETT				;RETURN


DEVACT:	MOVE	S1,CR.RES(S2)		;GET ADDR OF RESULT
	HRRZ	S1,(S1)			;GET KEYWORD CODE
	CAIN	S1,.CTDTA		;DECTAPE?
	MOVEI	T1,DTAPTR		;YES
	CAIN	S1,.CTMTA		;MAGTAPE?
	MOVEI	T1,MTAPTR		;YES
	CAIN	S1,.CTSTR		;STRUCTURE?
	MOVEI	T1,STRPTR		;YES
	MOVEM	T1,DEVPTR		;SAVE POINTERS
	$RETT				;RETURN

TBLACT:	LOAD	S1,CR.PDB(S2),LHMASK	;GET GIVEN PDB
	PUSHJ	P,P$GPDB##		;GET ADDR WORKING COPY
	MOVE	T1,DEVPTR		;GET ADDR OF POINTERS
	MOVE	T1,DEVTBL(T1)		;GET ADDR OF DEVICE SWITCH TABLE
	MOVEM	T1,PB%NXT(S1)		;POINT TO NEXT TABLE FOR PARSING
	$RETT				;RETURN

COPACT:	LOAD	S1,CR.PDB(S2),RHMASK	;GET CURRENT PDB
	MOVE	T1,DEVPTR		;GET ADDR OF POINTERS
	MOVE	T1,DEVTBL(T1)		;GET ADDR OF DEVICE SWITCH TABLE
	ADDI	T1,1			;ACCOUNT FOR PDB HEADER
	STORE	T1,.CMFNP(S1),CM%LST	;POINT TO ALTERNATE TABLE FOR PARSING
	$RETT				;RETURN

HLPACT:	LOAD	S1,CR.PDB(S2),RHMASK	;GET NEXT PDB
	MOVE	S2,DEVPTR		;GET ADDR OR POINTERS
	MOVE	S2,DEVHLP(S2)		;GET ADDR OF HELP TEXT
	MOVEM	S2,.CMHLP(S1)		;STORE IN TABLE
	$RETT				;RETURN

QUIACT:	MOVE	TF,FNCCOD		;GET FUNCTION CODE
	MOVEI	S2,[ASCIZ |INSERT aborted|] ;ASSUME INSERTING
	CAIE	TF,.CTINS		;IS IT?
	MOVEI	S2,[ASCIZ |MODIFY aborted|] ;NO--MUST BE A MODIFY
	PUSHJ	P,P$XSBC##		;EXIT SUB-COMMAND MODE
	$RETF				;CAUSE PARSE TO FAIL
SUBTTL	Parser tables -- DECtape


DTAPTR:	EXP	DTA010			;SWITCH TABLE ADDRESS
	POINT	7,DTAHLP		;BYTE POINTER TO HELP TEXT
	SIXBIT	/DTALST/		;SIXBIT FILE NAME FOR LISTINGS

DTAHLP:	ASCIZ	|volume-set name|

DTA010:	$SWITCH	(,DTA015,<$ACTION (SHRSWT),$ALTER (DTA020)>)
DTA015:	$STAB
	DSPTAB	(EXP010,.CTEXP,<EXPIRATION:>)
	DSPTAB	(LOC010,.CTLOC,<LOCATION:>)
	DSPTAB	(NAM010,.CTNAM,<NAME:>)
	DSPTAB	(RID010,.CTRID,<REELID:>)
	DSPTAB	(USR010,.CTUSR,<USER:>)
	$ETAB
DTA020:	$CRLF
SUBTTL	Parser tables -- Magtape


MTAPTR:	EXP	MTA010			;SWITCH TABLE ADDRESS
	POINT	7,MTAHLP		;BYTE POINTER TO HELP TEXT
	SIXBIT	/MTALST/		;SIXBIT FILE NAME FOR LISTINGS

MTAHLP:	ASCIZ	|volume-set name|

MTA010:	$SWITCH	(,MTA015,<$ACTION (SHRSWT),$ALTER (MTA020)>)
MTA015:	$STAB
	DSPTAB	(DEN010,.CTDEN,<DENSITY:>)
	DSPTAB	(EXP010,.CTEXP,<EXPIRATION:>)
	DSPTAB	(LAB010,.CTLAB,<LABEL-TYPE:>)
	DSPTAB	(LOC010,.CTLOC,<LOCATION:>)
	DSPTAB	(NAM010,.CTNAM,<NAME:>)
	DSPTAB	(TRK010,.CTTRK,<TRACKS:>)
	DSPTAB	(USR010,.CTUSR,<USER:>)
	$ETAB
MTA020:	$CRLF	(<$NEXT (REE010),$HELP (<return to add or remove reelids>)>)
SUBTTL	Parser tables -- Magtape reel


REE010:	$SUBCM	(REE020,SUBPMT,)
REE020:	$KEYDSP	(REE030,)
REE030:	$STAB
	DSPTAB	(REE040,.CTADD,<ADD>)
	DSPTAB	(REE080,.CTDON,<DONE>)
	DSPTAB	(REE070,.CTQUI,<QUIT>)
	DSPTAB	(REE040,.CTREM,<REMOVE>)
	$ETAB
REE040:	$NOISE	(REE050,<reel>)
REE050:	$FIELD	(REE060,<reelid>,)
REE060:	$CRLF	(<$NEXT (REE010),$HELP (<return to add or remove more reels>)>)
REE070:	$CRLF	(<$ACTION (QUIACT)>)
REE080:	$CRLF	(<$ACTION (P$XSBC##)>)
SUBTTL	Parser tables -- Structure


STRPTR:	EXP	STR010			;SWITCH TABLE ADDRESS
	POINT	7,STRHLP		;BYTE POINTER TO HELP TEXT
	SIXBIT	/STRLST/		;SIXBIT FILE NAME FOR LISTINGS

STRHLP:	ASCIZ	|structure name|

STR010:	$SWITCH	(,STR015,<$ACTION (SHRSWT),$ALTER (STR020)>)
STR015:	$STAB
	DSPTAB	(EXP010,.CTEXP,<EXPIRATION:>)
	DSPTAB	(LOC010,.CTLOC,<LOCATION:>)
	DSPTAB	(NAM010,.CTNAM,<NAME:>)
	DSPTAB	(USR010,.CTUSR,<USER:>)
	$ETAB
STR020:	$CRLF	(<$NEXT (UNI010),$HELP (<return to add or remove units>)>)
SUBTTL	Parser tables -- Disk unit


UNI010:	$SUBCM	(UNI020,SUBPMT,)
UNI020:	$KEYDSP	(UNI030,)
UNI030:	$STAB
	DSPTAB	(UNI040,.CTADD,<ADD>)
	DSPTAB	(UNI150,.CTDON,<DONE>)
	DSPTAB	(UNI140,.CTQUI,<QUIT>)
	DSPTAB	(UNI120,.CTREM,<REMOVE>)
	$ETAB
UNI040:	$NOISE	(UNI050,<unit-id>)
UNI050:	$FIELD	(UNI060,<unit-id>,)
UNI060:	$NOISE	(UNI070,<type>)
UNI070:	$KEY	(UNI090,UNI080)
DEFINE	X	(NAME,KONT,TYPE),<
	KEYTAB (<<KONT>B26+<TYPE>B35>,<NAME>)
>
UNI080:	$STAB
	DSKUNI
	$ETAB
UNI090:	$NOISE	(UNI100,<class>)
UNI100:	$NUMBER	(UNI110,^D8,<>,<$DEFAULT (<0>)>)
UNI110:	$CRLF	(<$NEXT (UNI010),$HELP (<return to enter additional units>)>)
UNI120:	$NOISE	(UNI130,<unit-id>)
UNI130:	$FIELD	(UNI110,<Unit-Id>,)
UNI140:	$CRLF	(<$ACTION (QUIACT)>)
UNI150:	$CRLF	(<$ACTION (P$XSBC##)>)
SUBTTL	Parser tables -- MISCELLANEOUS TABLES


; DEVICE TABLE
DEVTAB:	$STAB
	 KEYTAB	(.CTDTA,<DECTAPE>)
	 KEYTAB	(.CTMTA,<MAGTAPE>)
	 KEYTAB	(.CTSTR,<STRUCTURE>)
	$ETAB


; DENSITY
DEN010:	$KEY	(NEXT,DEN015)
DEN015:	$STAB
	KEYTAB	(.CT160,<1600>)
	KEYTAB	(.CT200,<200>)
	KEYTAB	(.CT556,<556>)
	KEYTAB	(.CT625,<6250>)
	KEYTAB	(.CT800,<800>)
	$ETAB


; EXPIRATION DATE
EXP010:	$KEY	(NEXT,EXP015,<$ALTER (EXP020)>)
EXP015:	$STAB
	KEYTAB	(0,<NONE>)
	$ETAB
EXP020:	$TAD	(NEXT,<$HELP (<expiration date>),$PDATA (CM%IDA!CM%FUT)>)


; LABEL-TYPE
LAB010:	$KEY	(NEXT,LAB015,<$DEFAULT (<DEFAULT>)>)
LAB015:	$STAB
	KEYTAB	(.TFLAL,<ANSI>)
;	KEYTAB	(.TFLAU,<ANSI-USER>)
	KEYTAB	(.TFLBP,<BYPASS>)
	KEYTAB	(-1,<DEFAULT>)
	KEYTAB	(.TFLIL,<IBM>)
;	KEYTAB	(.TFLIU,<IBM-USER>)
;	KEYTAB	(.TFLTM,<LEADING-TAPE-MARK>)
;	KEYTAB	(.TFLNS,<NON-STANDARD>)
	KEYTAB	(.TFLNL,<NOLABELS>)
;	KEYTAB	(.TFCBA,<COBOL-ASCII>)
;	KEYTAB	(.TFCBS,<COBOL-SIXBIT>)
	KEYTAB	(.TFLNV,<USER-EOT>)
	$ETAB



; LOCATION STRING
LOC010:	$QUOTE	(NEXT,<quoted or unquoted string>,<$PREFIL (P$8BIT##),$ALTER (LOC020)>)
LOC020:	$FIELD	(NEXT,,<$PREFIL (P$8BIT##),$BREAK (LOC025),$FLAGS (CM%SDH)>)
LOC025:	777777,,777760			;BREAK ON ALL CONTROL
	777754,,001760			;ALLOW - AND 0-9
	400000,,000760			;ALLOW UC A-Z
	400000,,000760			;ALLOW LC A-Z


; NAME
NAM010:	$QUOTE	(NEXT,<quoted or unquoted string>,<$PREFIL (P$8BIT##),$ALTER (NAM020)>)
NAM020:	$FIELD	(NEXT,,<$PREFIL (P$8BIT##),$BREAK (NAM025),$FLAGS (CM%SDH)>)
NAM025:	777777,,777760			;BREAK ON ALL CONTROL
	777754,,001760			;ALLOW - AND 0-9
	400000,,000760			;ALLOW UC A-Z
	400000,,000760			;ALLOW LC A-Z


; REELID
RID010:	$FIELD	(NEXT,<DECtape reelid>,)


; TRACKS
TRK010:	$KEY	(NEXT,TRK015)
TRK015:	$STAB
	KEYTAB	(.CT7TK,<7>)
	KEYTAB	(.CT9TK,<9>)
	$ETAB


; OWNER PPN
USR010:	$USER	(NEXT,<$HELP (<volume-set owner>),$PDATA (CM%WLD+PPNBLK)>)
FILDEF:	MOVE	T1,[FIL.ZB,,FIL.ZB+1]	;SET UP BLT
	SETZM	FIL.ZB+0		;CLEAR FIRST WORD
	BLT	T1,FIL.ZE-1		;CLEAR ENTIRE BLOCK
	MOVEI	T1,.FDNAT		;NATIVE FILESPEC
	STORE	T1,FILBLK+.FDLEN,FD.TYP	;STORE CODE
	MOVEI	T1,FDXSIZ		;MAXIMUM LENGTH FD
	STORE	T1,FILBLK+.FDLEN,FD.LEN	;SAVE
	MOVSI	T1,'DSK'		;GENERIC DSK
	MOVEM	T1,FILBLK+.FDSTR	;SAVE
	MOVE	T1,DEVPTR		;GET ADDR OF POINTERS
	MOVE	T1,DEVLST(T1)		;GET FILE NAME
	MOVEM	T1,FILBLK+.FDNAM	;SAVE IT
	MOVSI	T2,'LST'		;EXTENSION
	MOVEM	T2,FILBLK+.FDEXT	;SAVE
	$TEXT	(<-1,,FILTXT>,<^F/FILBLK/^0>) ;CONVERT TO ASCIZ TEXT
	$RETT				;RETURN

FILACT:	PUSH	P,S1			;SAVE S1
	PUSH	P,S2			;SAVE S2
	MOVE	T1,CR.SAV(S2)		;GET FD ADDRESS
	MOVEM	T1,FILFOB+FOB.FD	;SAVE
	MOVE	T3,.FDLEN(T1)		;PRESERVE LENGTH WORD
	MOVEI	T2,.FDNAT		;NATIVE MODE FILE
	STORE	T2,.FDLEN(T1),FD.TYP	;SAVE
	MOVEI	T2,7			;7-BIT BYTES
	MOVEM	T2,FILFOB+FOB.CW	;SAVE IN CONTROL WORD
	MOVEI	S1,FOB.SZ		;FOB SIZE
	MOVEI	S2,FILFOB		;FOB ADDRESS
	$CALL	F%OOPN			;OPEN FILE FOR OUTPUT
	JUMPF	FILA.1			;CHECK FOR ERRORS
	PUSH	P,S1			;SAVE IFN
	MOVNI	S2,1			;WANT EXACT FD
	$CALL	F%FD			;GET ACTUAL FILESPEC
	MOVSI	T1,(S1)			;POINT TO STORAGE
	LOAD	T2,.FDLEN(S1),FD.LEN	;GET ACTUAL LENGTH
	MOVE	S2,-1(P)		;GET SAVED ADDRESS OF CMD BLOCK
	HRR	T1,CR.SAV(S2)		;GET COMMAND FILESPEC STORAGE
	ADD	T2,CR.SAV(S2)		;COMPUTE END BLT ADDRESS
	BLT	T1,-1(T2)		;COPY ACTUAL FILESPEC
	MOVE	S1,-1(P)		;GET SAVED CMD BLOCK ADDRESS AGAIN
	MOVE	S1,CR.SAV(S1)		;GET FD ADDRESS
	MOVEM	T3,.FDLEN(S1)		;RESTORE LENGTH WORD
	POP	P,S1			;GET IFN BACK
	$CALL	F%RREL			;RELEASE IFN
	POP	P,S2			;RESTORE S2
	POP	P,S1			;RESTORE S1
	$RETT				;AND RETURN

FILA.1:	$TEXT	(<-1,,FILERR>,<^E/S1/^0>) ;GET ERROR TEXT
	MOVEI	S2,FILERR		;POINT TO IT
	POP	P,(P)			;TRIM STACK
	POP	P,S1			;RESTORE S1
	$RETF				;AND RETURN
	END
