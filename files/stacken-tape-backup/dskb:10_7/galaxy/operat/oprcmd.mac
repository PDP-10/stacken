	TITLE	OPRCMD - command tables for ORION
	SUBTTL	Murry Berkowitz/BH/DC/AWC/PJT/CTK/LWS	12-SEP-85

;
;
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1975,1976,1977,1978,1979
;1980,1981,1982,1983,1984,1986,1987.  ALL RIGHTS RESERVED.
;          
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.


        SALL
	SEARCH	GLXMAC
	SEARCH	ORNMAC
	PROLOG(OPRCMD)


	OPRVRS==:OPRVRS		;REFERENCE BOTH OPR/ORION'S
	%%.OPR==:%%.OPR		;AND ORNMAC'S VERSIONS

	.DIRECTIVE FLBLST



	INTERN	OPRCMD	;MAKE VECTOR ADDRESS AVAILABLE
OPRCMD:	EXP	2	;SIZE
	EXP	INITCM	;POINTER TO THE INI FUNCTION
	EXP	CMDFDB	;TOP LEVEL DISPATCH
SUBTTL	Table of Contents

;               TABLE OF CONTENTS FOR OPRCMD
;
;
;                        SECTION                                   PAGE
;    1. Table of Contents.........................................   2
;    2. Revision History..........................................   3
;    3. Special Macro Definitions.................................   4
;    4. $UNIT Macro...............................................   4
;    5. $STNUM Macro..............................................   4
;    6. $STREAM Macro.............................................   4
;    7. $EXPL Macro Definition....................................   5
;    8. $JOBSWI Macro Definition..................................   5
;    9. $URANGE Macro Definition..................................   6
;   10. $SRANGE Macro Definition..................................   6
;   11. Subroutine macros.........................................   7
;   12. Command Dispatch..........................................   8
;   13. Argument Subroutines......................................   9
;   14. START command tables......................................  10
;   15. CONTINUE command tables...................................  11
;   16. SHUTDOWN command tables...................................  11
;   17. STOP command tables.......................................  12
;   18. ABORT command tables......................................  13
;   19. HOLD command tables.......................................  14
;   20. RELEASE command tables....................................  14
;   21. DEFINE command tables.....................................  15
;   22. CANCEL command tables.....................................  16
;   23. MODIFY command tables.....................................  17
;   24. SHOW command tables.......................................  18
;   25. SHOW STATUS command tables................................  19
;   26. SHOW SYSTEM-LIST command tables...........................  20
;   27. LOCK/UNLOCK command tables................................  21
;   28. SHWNOD  SHOW STATUS/PARAMETERS FOR NODE...................  22
;   29. RESPOND command tables....................................  23
;   30. REQUEUE command tables....................................  24
;   31. BACKSPACE command tables..................................  25
;   32. FORWARDSPACE command tables...............................  25
;   33. ALIGN command table.......................................  26
;   34. SUPPRESS command tables...................................  27
;   35. ROUTE command tables......................................  28
;   36. SEND command tables.......................................  29
;   37. SET command tables........................................  30
;   38. SET TAPE and DISK command tables (TOPS20).................  31
;   39. SET ONLINE command tables.................................  32
;   40. SET USAGE command tables..................................  33
;   41. SET TAPE INITIALIZE command tables........................  34
;   42. SET NODE command tables...................................  35
;   43. SET SCHEDULER command tables (TOPS20).....................  36
;   44. ENABLE command tables.....................................  37
;   45. DISABLE command tables....................................  37
;   46. ENACLS  ENABLE CLASS SCHEDULER command tables.............  38
;   47. CLOSE command tables......................................  39
;   48. DEFINE command tables.....................................  39
;   49. REPORT command tables.....................................  40
;   50. MOUNT command tables (TOPS10).............................  41
;   51. IDENTIFY command tables...................................  42
;   52. SWITCH  command tables (TOPS20)...........................  43
;   53. DISMOUNT command tables...................................  44
;   54. UNLOAD  command tables (removed)..........................  44
;   55. RECOGNIZE command tables..................................  44
;   56. PUSH command tables.......................................  45
;   57. HELP command tables.......................................  46
;   58. SHOW ALLOCATION command tables............................  47
SUBTTL	Special Macro Definitions
SUBTTL	$UNIT Macro
SUBTTL	$STNUM Macro
SUBTTL	$STREAM Macro


;	!=======================================================!
;	!                   $UNIT (NEXT_PDB)                    !
;	!-------------------------------------------------------!
;	!               PARSE A UNIT NUMBER ONLY                !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE UNIT NUMBER
DEFINE	$UNIT(NEXT,%UNI01,%UNI02),<
	.XCREF	%UNI01,%UNI02
	SUPPRESS %UNI01,%UNI02
	$NOISE	(%UNI01,<unit number>)
%UNI01:	$NUMBER	(%UNI02,^D10,<unit number (/NODE:)>,<$ACTION(CHKVAL)>)
%UNI02:	$NODE(NEXT)
>	;END $UNIT DEFINITION




;	!=======================================================!
;	!                   $STNUM (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!              PARSE A STREAM NUMBER ONLY               !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE STREAM NUMBER
;WITHOUT AN OPTIONAL NODE SPECIFICATION
DEFINE	$STNUM(NEXT,%STN01),<
	.XCREF	%STN01
	SUPPRESS %STN01
	$NOISE	(%STN01,<stream number>)
%STN01:	$NUMBER	(NEXT,^D10,<stream number>,$ACTION(CHKVAL))
>	;END $STNUM DEFINITION




;	!=======================================================!
;	!                  $STREAM (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!           PARSE A STREAM WITH OPTIONAL NODE           !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A SINGLE STREAM NUMBER
DEFINE	$STREAM(NEXT,%STR01,%STR02),<
	.XCREF	%STR01,%STR02
	SUPPRESS %STR01,%STR02
	$NOISE	(%STR01,<stream number>)
%STR01:	$NUMBER	(%STR02,^D10,<stream number (/NODE:)>,$ACTION(CHKVAL))
%STR02:	$NODE(NEXT)
>	;END $STREAM DEFINITION
SUBTTL	$EXPL Macro Definition


;	!=======================================================!
;	!            $EXPL (NEXT_PDB,<KEYWORD-LIST>)            !
;	!-------------------------------------------------------!
;	!                     /REASON:TEXT                      !
;	!=======================================================!

;DEFINE A <EXPL> DEFINITION MACRO
DEFINE $EXPL (NXTLNK,ALTADR,%A,%B,%C)<
	.XCREF	%A,%B,%C
	SUPPRESS %A,%B,%C
	$SWITCH(%B,%A,ALTADR)
%A:	$STAB
	ORNSWI	(<REASON:>,RSN)
	$ETAB
%B:	$CRLF	(<$ALTER(%C),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

%C:	$CTEXT	(CONFRM,<single line response>)
>
SUBTTL	$URANGE Macro Definition
SUBTTL	$SRANGE Macro Definition

;	!=======================================================!
;	!                  $URANGE (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!         PARSE A UNIT RANGE WITH OPTIONAL NODE         !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A RANGE OF UNIT NUMBERS
DEFINE	$URANGE(NEXT,%URG01,%URG02),<
	.XCREF	%URG01,%URG02
	SUPPRESS %URG01,%URG02
	$NOISE	(%URG01,<unit number>)
%URG01:	$RANGE(%URG02,<number or range (n:m)(/NODE:)>)
%URG02:	$NODE(NEXT)
>	;END $URANGE DEFINITION

;	!=======================================================!
;	!                  $SRANGE (NEXT_PDB)                   !
;	!-------------------------------------------------------!
;	!        PARSE A STREAM RANGE WITH OPTIONAL NODE        !
;	!=======================================================!

;DEFINE A MACRO TO DO THE PARSING FOR A RANGE OF STREAM NUMBERS
DEFINE	$SRANGE(NEXT,%SRG01,%SRG02),<
	.XCREF	%SRG01,%SRG02
	SUPPRESS %SRG01,%SRG02
	$NOISE	(%SRG01,<stream number>)
%SRG01:	$RANGE(%SRG02,<number or range (n:m)(/NODE:)>)
%SRG02:	$NODE(NEXT)

>	;END $SRANGE DEFINITION
SUBTTL	Subroutine macros


;DEFINE A MACRO TO ACTUALLY PARSE A RANGE OF OCTAL NUMBERS SPECIFIED AS
;   NUMBER:NUMBER (OR JUST NUMBER) WITH AN OPTIONAL NODE SWITCH

	DEFINE	$RANGE(NEXT,HLPT,ARGLST,%RNG01,%RNG02),<
	.XCREF	%RNG01,%RNG02
	SUPPRESS %RNG01,%RNG02
	$NUMBER	(%RNG01,^D10,HLPT,<$ACTION(STOBTH),ARGLST>)

%RNG01:	$TOKEN	(%RNG02,<:>,<$HELP(<colon to specify a range>),$ALTERNATE(NEXT)>)

%RNG02:	$NUMBER	(NEXT,^D10,,<$ACTION(STOHGH)>)


>	;END DEFINITION OF $RANGE



;DEFINE A MACRO FOR CORRECT PARSING OF THE OPTIONAL /NODE SWITCH

DEFINE	$NODE(NEXT,%NOD01,%NOD02),<
	.XCREF	%NOD01,%NOD02
	SUPPRESS %NOD01,%NOD02

	$SWITCH (%NOD02,%NOD01,<$ALTERNATE(NEXT)>)

%NOD01:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB

%NOD02:	$NODNM	(NEXT,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

>	;END $NODE DEFINITION


SUBTTL	Command Dispatch

INITCM:: $INIT(CMDFDB)
CMDFDB:: $KEYDSP(CMDTAB,<$ACTION(CMDACT##),$ERROR(BADCOM)>)

CMDTAB:	$STAB
TOPS10<	ORNDSP(,\"32,CTZ,CM%INV) >
	ORNDSP(ABOFDB,ABORT,CNC)
	ORNDSP(ALIFDB,ALIGN,ALI)
	ORNDSP(BKSFDB,BACKSPACE,BKS)
	ORNDSP(CANFDB,CANCEL,DEL)
	ORNDSP(CLOFDB,CLOSE,CLO)
	ORNDSP(UNVFDB,CONTINUE,CNT)
IFN FTDN60,<
	ORNDSP(DEFFDB,DEFINE,DEF) >
IFE FTDN60,<
TOPS10<	ORNDSP(DEFFDB,DEFINE,DEF) > >
	ORNDSP(ENAFDB,DISABLE,DIS)
	ORNDSP(DSMFDB,DISMOUNT,DSM)
	ORNDSP(ENAFDB,ENABLE,ENA)
IFN	NUMAPL,<			;CHECK IS ANY APPLICATION TABLES
	ORNDSP(ENTFDB##,ENTER,ENT)
>;END NUMAPL
	ORNDSP(EXTFDB##,EXIT,EXT)
	ORNDSP(BKSFDB,FORWARDSPACE,FWS)
	ORNDSP(HLPFDB,HELP,HLP)
	ORNDSP(HLDFDB,HOLD,HLD)
	ORNDSP(IDNFDB,IDENTIFY,IDN)
TOPS10<	ORNDSP(LOCFDB,LOCK,LOC)>
	ORNDSP(MODFDB,MODIFY,MOD)
TOPS10<	ORNDSP(MTNFDB,MOUNT,MTN) >
	ORNDSP(NXTFDB,NEXT,NXT)		;[NXT] Operator NEXT command
	ORNDSP(PUSFDB,PUSH,PUS)
TOPS10<	ORNDSP(RECFDB,RECOGNIZE,REC)>
	ORNDSP(HLDFDB,RELEASE,REL)
	ORNDSP(RPTFDB,REPORT,RPT)
	ORNDSP(REQFDB,REQUEUE,REQ)
	ORNDSP(RSPFDB,RESPOND,RSP)
TOPS10<	ORNDSP(RSTFDB,RESTRICT,RST)>
	ORNDSP(RTEFDB,ROUTE,RTE)
	ORNDSP(SNDFDB,SEND,SND)
	ORNDSP(SETFDB,SET,SET)
	ORNDSP(SHWFDB,SHOW,SHW)
	ORNDSP(SHDFDB,SHUTDOWN,SHD)
	ORNDSP(STAFDB,START,STA)
	ORNDSP(STPFDB,STOP,PAU)
	ORNDSP(SUPFDB,SUPPRESS,SUP)
TOPS20<	ORNDSP(SWIFDB,SWITCH,SWI)>
	ORNDSP(TAKOPR##,TAKE,TAK)
TOPS10<	ORNDSP(ULCFDB,UNLOCK,ULC)>
;	ORNDSP(UNLFDB,UNLOAD,UNL)
TOPS10<	ORNDSP(RSTFDB,UNRESTRICT,URS)>
	ORNDSP(WAIOPR##,WAIT,WAI)
	$ETAB

BADCOM::MOVEI	S2,[ASCIZ/Invalid OPR command specified/]
	$RETF				;BAD COMMAND
SUBTTL	Argument Subroutines

;ACTION ROUTINE CALLED ON $UNIT MACRO TO BARF ON NEGATIVE UNIT
;NUMBER ARGUMENTS.
CHKVAL:	SKIPL	CR.RES(S2)	;CHECK THAT NUMBER
	$RETT			;IT'S GOOD
	PUSHJ	P,P$FIXP##
	MOVEI	S2,[ASCIZ/Negative number improper/]
	$RETF

CHKPOS:	SKIPLE	CR.RES(S2)	;CHECK THE NUMBER
	$RETT			;O.K..RETURN
	PUSHJ	P,P$FIXP##	;FIXUP COMMAND
	MOVEI	S2,[ASCIZ/Number must be positive/]
	$RETF			;RETURN FALSE

; ACTION ROUTINE TO CHECK PRIORITY RANGES
CHKPRI:	SKIPLE	T1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	T1,^D63
	SKIPA
	$RETT			;IT'S GOOD
	PUSHJ	P,P$FIXP##
	MOVEI	S2,[ASCIZ/Priority not in range/]
	$RETF

;TEMPORARY STORAGE FOR RANGE ARGUMENT
	$DATA	LSTARG,1		;LAST PARSED ARGUMENT ADDRESS
	$GDATA	CMDCOD,1		;COMMAND FUNCTION CODE

STOBTH:	SKIPGE	T1,CR.RES(S2)
	PJRST	CHKVAL		;ABORT COMMAND
	MOVEM	T1,LSTARG
	$RETT

STOHGH:	SKIPGE	T1,CR.RES(S2)
	PJRST	CHKVAL		;ABORT COMMAND
	CAMGE	T1,LSTARG
	SKIPA			;SKIP AND LOAD ERROR
	$RETT
	PUSHJ	P,P$FIXP##
	MOVEI	S2,[ASCIZ /Improper range specification/]
	$RETF
SUBTTL	START command tables

STAFDB:	$NOISE (STAF01,<object>)

STAF01:	$KEYDSP(STAF02)

STAF02:	$STAB
	ORNDSP(STAF03,BATCH-STREAM,BAT)
	ORNDSP(STAF04,<CARD-PUNCH>,CDP)
	ORNDSP(STAF05,<FAL-STREAM>,FAL)
IFN FTFTS,<
	ORNDSP(STAF03,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP(SHD030,<NODE>,NOD)
IFN FTDQS,<ORNDSP(STAF03,<NQC-STREAM>,NQC)>
	ORNDSP(STAF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(STAF04,<PLOTTER>,PLT)
	ORNDSP(STAF11,PRINTER,LPT)
	ORNDSP(STAF04,READER,RDR)
	$ETAB

STAF03:	$SRANGE(CONFRM)

STAF04:	$URANGE	(CONFRM)

STAF05:	$RANGE(CONFRM,<stream number or range (n:m)>)

STAF11:	$URANGE(STAF12)

STAF12:	$SWITCH	(STAF14,STAF13,<$ALTERNATE(<CONFRM>)>)

STAF13:	$STAB
	ORNSWI	(<DEVICE:>,DEV)
	$ETAB

STAF14:	$DEV(CONFRM,<$HELP(<device name>),$FLAGS(CM%NSF)>)
SUBTTL	CONTINUE command tables
SUBTTL	SHUTDOWN command tables

COMMENT	\
NOTE: SHOULD IT BECOME DESIRABLE FOR THE SHUTDOWN AND
CONTINUE COMMANDS TO BE NO LONGER SYNTACTICALLY IDENTICAL THEN THE
COMMON USE OF THIS PDB CHAIN DEFINITION IS NO LONGER VALID.
\

SHDFDB:	$NOISE	(SHD010,<scheduling for>)

UNVFDB:	$NOISE (UNVF01,<object>)

UNVF01:	$KEYDSP(UNVF02)

UNVF02:	$STAB
	ORNDSP(UNVF03,BATCH-STREAM,BAT)
	ORNDSP(UNVF04,<CARD-PUNCH>,CDP)
	ORNDSP(STAF05,<FAL-STREAM>,FAL)
IFN FTFTS,<
	ORNDSP(UNVF03,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN FTDQS,<ORNDSP(UNVF03,<NQC-STREAM>,NQC)>
	ORNDSP(UNVF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(UNVF04,<PLOTTER>,PLT)
	ORNDSP(UNVF04,PRINTER,LPT)
	ORNDSP(UNVF04,READER,RDR)
	$ETAB

UNVF03:	$SRANGE(CONFRM)

UNVF04:	$URANGE(CONFRM)

CONFRM::$CRLF

SHD010:	$KEYDSP(SHD020)

SHD020:	$STAB
	ORNDSP(UNVF03,BATCH-STREAM,BAT)
	ORNDSP(UNVF04,<CARD-PUNCH>,CDP)
	ORNDSP(STAF05,<FAL-STREAM>,FAL)
	ORNDSP(SHD030,NODE,NOD)
IFN FTDQS,<ORNDSP(UNVF03,<NQC-STREAM>,NQC)>
	ORNDSP(UNVF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(UNVF04,<PLOTTER>,PLT)
	ORNDSP(UNVF04,PRINTER,LPT)
	ORNDSP(UNVF04,READER,RDR)
	$ETAB

SHD030:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SUBTTL	STOP command tables

STPFDB:	$NOISE (STPF01,<object>)

STPF01:	$KEYDSP(STPF02)

STPF02:	$STAB
	ORNDSP(STPS01,BATCH-STREAM,BAT)
	ORNDSP(STPU01,<CARD-PUNCH>,CDP)
	ORNDSP(STPS05,<FAL-STREAM>,FAL)
IFN FTFTS,<
	ORNDSP(STPU01,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN FTDQS,<ORNDSP(STPS01,<NQC-STREAM>,NQC)>
	ORNDSP(STPU01,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(STPU01,<PLOTTER>,PLT)
	ORNDSP(STPU01,PRINTER,LPT)
	ORNDSP(STPU01,READER,RDR)
	$ETAB

STPS01:	$NOISE	(STPN01,<stream number>)

STPU01:	$NOISE	(STPN01,<unit number>)

STPS05:	$RANGE	(STP010,<stream number or range (n:m)>)

STPN01:	$NUMBER	(STPN02,^D10,<number or range (n:m)(/NODE:)>,<$ACTION(STOBTH)>)
STPN02:	$TOKEN	(STPN03,<:>,<$HELP(<colon to specify a range>),$DEFAULT(IMMEDIATELY),$ALTERNATE(STPN04)>)
STPN03:	$NUMBER	(STPN04,^D10,,<$ACTION(STOHGH)>)
STPN04:	$SWITCH (STPN06,STPN05,<$ALTERNATE(STP010)>)
STPN05:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB
STPN06:	$NODNM	(STP010,<node name>,<$FLAGS(CM%PO!CM%NSF)>)


STP010:	$KEYDSP	(STP020,<$DEFAULT(<IMMEDIATELY>),$ALTERNATE(CONFRM)>)

STP020:	$STAB
	ORNDSP(STP030,<AFTER>,AFT)
	ORNDSP(CONFRM,<IMMEDIATELY>,IMM)
	$ETAB

STP030:	$KEY(CONFRM,STP040)

STP040:	$STAB
	ORNKEY(<CURRENT-REQUEST>,ACR)
	ORNKEY(<EVERY-REQUEST>,AER)
	$ETAB


SUBTTL	ABORT command tables


ABOFDB:	$NOISE	(ABO010,<current job on>)

ABO010:	$KEYDSP	(ABO020)
ABO020:	$STAB
	ORNDSP	(ABO060,<BATCH-STREAM>,BAT)
	ORNDSP	(ABO030,<CARD-PUNCH>,CDP)
	ORNDSP	(ABO200,<FAL-STREAM>,FAL)
IFN FTFTS,<
	ORNDSP	(ABO060,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
IFN FTDQS,<ORNDSP	(ABO030,<NQC-STREAM>,NQC)>
	ORNDSP	(ABO030,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(ABO030,<PLOTTER>,PLT)
	ORNDSP	(ABO030,<PRINTER>,LPT)
	ORNDSP	(ABO090,<READER>,RDR)
	$ETAB


; Output device tables
;
ABO030:	$UNIT	(ABO040)
ABO040:	$SWITCH	(ABO100,ABO050,<$ALTERNATE(ABO100)>)
ABO050:	$STAB
	ORNSWI	(<PURGE>,PUR)
	$ETAB


; Batch tables
;
ABO060:	$STREAM	(ABO070)
ABO070:	$SWITCH	(ABO100,ABO080,<$ALTERNATE(ABO100),$DEFAULT(</ERROR-PROCESSING>)>)
ABO080:	$STAB
	ORNSWI	(<ERROR-PROCESSING>,ERR)
	ORNSWI	(<NOERROR-PROCESSING>,NER)
	ORNSWI	(<PURGE>,PUR)
	$ETAB


; Card reader tables
;
ABO090:	$UNIT	(ABO100)

; FAL stream tables
;
ABO200:	$NOISE	(ABO210,<stream number>)
ABO210:	$NUMBER	(ABO070,^D10,<stream number>,$ACTION(CHKVAL))

ABO100:	$EXPL	(CONFRM,<$ALTER(CONFRM)>)
SUBTTL	HOLD command tables
SUBTTL	RELEASE command tables

HLDFDB:	$KEY	(HLD030,HLD010)

HLD010:	$STAB
	ORNKEY	(<BATCH-JOBS>,BAT)
	ORNKEY	(<CARD-PUNCH-JOBS>,CDP)
IFN FTFTS,<
	ORNKEY	(<FTS-JOBS>,FTS)
> ;End FTFTS conditional
	ORNKEY	(<PAPER-TAPE-PUNCH-JOBS>,PTP)
	ORNKEY	(<PLOTTER-JOBS>,PLT)
	ORNKEY	(<PRINTER-JOBS>,LPT)
	$ETAB

HLD030:	$NUMBER(CONFRM,^D10,<request-id>,<$ACTION(CHKPOS),$ALTERNATE(HLD035)>)

HLD035:	$USER(CONFRM,<$ALTERNATE(HLD040)>)

HLD040:	$TOKEN(HLD050,<*>,<$HELP(<* to specify all requests>)>)

HLD050:	$NODE(CONFRM)
SUBTTL	DEFINE command tables

TOPS20<
IFN FTDN60,<
DEFFDB:	$KEY(DEF020,DEF010,<$DEFAULT(<NODE>)>)

DEF010:	$STAB
	ORNKEY(<NODE>,NOD)
	$ETAB
> > ;END IFN FTDN60, TOPS20

TOPS10<
DEFFDB:	$KEYDSP(DEF010)

DEF010:	$STAB
	ORNDSP(DEF200,<FILE-ACCESS>,FAL)
IFN FTDQS,<ORNDSP(DEF400,<NETWORK-QUEUE>,QNM)>
	ORNDSP(DEF020,<NODE>,NOD) >
	$ETAB

DEF020:	$NOISE(DEF030,<name>)

DEF030:	$NODNM(DEF040,<node name>,<$FLAGS(CM%NSF!CM%PO)>)

DEF040:	$NOISE(DEF050,<type>)

IFN FTDN60,<
DEF050:	$KEYDSP(DEF060,<$DEFAULT(<HASP>)>) >
IFE FTDN60,<
DEF050:	$KEYDSP(DEF060,<$DEFAULT(<SERVER>)>) >

DEF060:	$STAB
IFN FTDN60,<
	ORNDSP(DEF063,<2780>,278)
	ORNDSP(DEF063,<3780>,378)
	ORNDSP(DEF063,<HASP>,HSP)
>; END IFN FTDN60
	ORNDSP(DEFL00,<LAT-SERVER>,LAT)
IFN FTDQS,<ORNDSP(CONFRM,<SERVER>,SRV) >
	$ETAB

IFN FTDN60,<
DEF063:	$SWITCH	(DEF070,DEF065,<$ALTERNATE(DEF080),$DEFAULT(</SIGNON-REQUIRED>)>)
DEF065:	$STAB
	ORNSWI(<NO-SIGNON-REQUIRED>,NSN)
	ORNSWI(<SIGNON-REQUIRED>,SON)
	$ETAB

DEF070:	$NOISE(DEF080,<mode>)

DEF080:	$KEY(DEF100,DEF090,<$DEFAULT(<TERMINATION>)>)

DEF090:	$STAB
	ORNKEY(EMULATION,EMU)
	ORNKEY(TERMINATION,TRM)
	$ETAB

DEF100:	$KEYDSP(DEF101,<$ALTER(DEF110)>)

DEF101:	$STAB
	ORNDSP(DEF140,<CPU>,CPU)
	$ETAB

DEF109:	$NOISE(DEF110,<port>)

DEF110:	$NUMBER(DEF120,^D8,<port number for DN60>)

DEF120:	$NOISE(DEF130,<line>)

DEF130:	$NUMBER(CONFRM,^D8,<line number for DN60>)

DEF140:	$NUMBER(DEF150,^D8,<cpu number>)

DEF150:	$KEY(DEF160,DEF155,$DEFAULT(<DTE>))

DEF155:	$STAB
	ORNKEY(<DL10-PORT>,D10)
	ORNKEY(<DTE>,D20)
	$ETAB

DEF160:	$NUMBER(DEF170,^D8,<port number for DL10 or DTE>)

DEF170:	$KEY(DEF130,DEF175,$DEFAULT(<LINE>))

DEF175:	$STAB
	ORNKEY(LINE,LIN)
	$ETAB
>;END FTDN60

DEFL00:	$SWITCH	(,DEFL20,<$ALTERNATE(DEFL60),$PREFI(LATINI)>) ;
DEFL10:	$SWITCH	(,DEFL20,<$ALTERNATE(DEFL60)>)	;
DEFL20:	$STAB					;
	ORNSDP	(DEFL30,<NODE-NAME:>,SVR)	;
	ORNSDP	(DEFL40,<PORT-NAME:>,POR)	;
	ORNSDP	(DEFL50,<SERVICE-NAME:>,SVC)	;
	$ETAB					;

DEFL30:	$FIELD	(DEFL10,<Server name>,<$BREAK(LATBRK),$ACTION(CHKSVR)>) ;
DEFL40:	$FIELD	(DEFL10,<Port name>,<$BREAK(LATBRK),$ACTION(CHKPOR)>) ;
DEFL50:	$FIELD	(DEFL10,<Service name>,<$BREAK(LATBRK),$ACTION(CHKSVC)>) ;
DEFL60:	$CRLF	(<$ACTION(CHKLAT)>)		;

LATBRK:	777777,,777760		;BREAK ON ALL CONTROL
	757744,,000760		;ALLOW $ - . : AND 0-9
	400000,,000740		;ALLOW UC A-Z AND _
	400000,,000760		;ALLOW LC A-Z

	$DATA	LATSVR,1	;Flags
	$DATA	LATPOR,1	;
	$DATA	LATSVC,1	;

LATINI:	SETZM	LATSVR		;Initialize 
	SETZM	LATPOR		; the
	SETZM	LATSVC		;  flags
	$RETT			;

CHKSVR:	SETOM	LATSVR		;
	$CALL	CHKLNM		;Check the name
	$RETIT			;No errors: return
	JUMPL	S1,.RETF	;Wrong type: error return
	SKIPE	S1		;Is it a null string?
	SKIPA	S2,[[ASCIZ |Value for /NODE-NAME is too long|]] ;
	MOVEI	S2,[ASCIZ |Value for /NODE-NAME is too short|] ;
	$RETF			;

CHKPOR:	SETOM	LATPOR		;
	$CALL	CHKLNM		;Check the name
	$RETIT			;No errors: return
	JUMPL	S1,.RETF	;Wrong type: error return
	SKIPE	S1		;Is it a null string?
	SKIPA	S2,[[ASCIZ |Value for /PORT-NAME is too long|]] ;
	MOVEI	S2,[ASCIZ |Value for /PORT-NAME is too short|] ;
	$RETF			;

CHKSVC:	SETOM	LATSVC		;
	$CALL	CHKLNM		;Check the name
	$RETIT			;No errors: return
	JUMPL	S1,.RETF	;Wrong type: error return
	SKIPE	S1		;Is it a null string?
	SKIPA	S2,[[ASCIZ |Value for /SERVICE-NAME is too long|]] ;
	MOVEI	S2,[ASCIZ |Value for /SERVICE-NAME is too short|] ;
	$RETF			;

CHKLNM:	$SAVE	<T1,T2>		;
	MOVE	S1,CR.COD(S2)	;Get the function type
	CAIE	S1,.CMFLD	;Is it an unquoted string?
	JRST	CHKLN3		;No, error return
	MOVE	T1,CR.FLG(S2)	;Get byte pointer
	MOVE	T1,.CMABP(T1)	; to ASCII text
	SETZ	T2,		;Initialize character count
CHKLN1:	ILDB	S1,T1		;Get the next character
	SKIPE	S1		;Is this the end of the string?
	AOJA	T2,CHKLN1	;No, keep looking
	JUMPE	T2,CHKLN2	;Null string: illegal
	CAIG	T2,^D16		;Is it more than 16 bytes long?
	$RETT			;No, normal return
CHKLN2:	$CALL	P$FIXP##	;Fix up the command buffer
	MOVE	S1,T2		;Return with the length in bytes
	$RETF			;Error return
CHKLN3:	SETO	S1,		;
	MOVEI	S2,[ASCIZ |Invalid field type|]
	$RETF			;

CHKLAT:	SKIPE	LATSVR		;Was /NODE-NAME given?
	JRST	CHKLA1		;Yes, keep checking
	$CALL	P$FIXP		;
	MOVEI	S2,[ASCIZ |Value for /NODE-NAME is required|] ;
	$RETF			;
CHKLA1:	SKIPN	LATSVC		;Was /SERVICE-NAME
	SKIPE	LATPOR		; or /PORT_NAME given?
	$RETT			;Yes, normal return
	$CALL	P$FIXP		;
	MOVEI	S2,[ASCIZ |Value for /SERVICE-NAME or /PORT-NAME or both is required|] ;
	$RETF			;

TOPS10<
DEF200:	$KEYDSP(DEF210)

DEF210:	$STAB
	ORNDSP(DEF220,<DEFAULT-PPN>,DPP)
	ORNDSP(DEF300,<REJECTION-LIST>,REJ)
	$ETAB

DEF220:	$USER(CONFRM)

DEF300:	$NODNM(DEF310,<node name to be rejected>,<$ALTER(DEF320),$FLAGS(CM%PO!CM%NSF)>)

DEF310:	$USER(DEF330,<$PDATA(<CM%WLD!WLDPPN>),$ALTER(DEF330)>)

DEF320:	$USER(DEF330,$PDATA(<CM%WLD!WLDPPN>))

DEF330:	$COMMA(DEF300,$ALTER(<CONFRM>))
	$DATA	WLDPPN,2

DEF400:	$NOISE	(DEF410,<name>)

DEF410:	$FIELD	(DEF420,<queue name>,<$BREAK(QNMBRK),$PREFILL(P$8BIT##)>)

DEF420:	$CRLF	(<$HELP (<return to delete queue name>),$ALTER (DEF430)>)

DEF430:	$KEY	(DEF450,DEF440)

DEF440:	$STAB
	ORNKEY	(<LOCAL>,LCL)
	ORNKEY	(<REMOTE>,RMT)
	$ETAB

DEF450:	$NOISE	(DEF460,<node>)

DEF460:	$NODNM	(DEF470,<node name>,<$FLAGS(CM%NSF!CM%PO)>)

DEF470:	$KEY	(DEF490,DEF480)

DEF480:	$STAB
	ORNKEY	(<CARD-PUNCH>,CDP)
	ORNKEY	(<PAPER-TAPE-PUNCH>,PTP)
	ORNKEY	(PLOTTER,PLT)
	ORNKEY	(PRINTER,LPT)
	$ETAB

DEF490:	$CRLF	(<$HELP(<return for any unit>),$ALTER(DEF500)>)

DEF500:	$NUMBER	(CONFRM,^D10,<unit number>,<$ALTER(DEF510),$ACTION(CHKVAL)>)

DEF510:	$FIELD	(CONFRM,<unit type or attribute>,)

QNMBRK:	777777,,777760		;BREAK ON ALL CONTROL
	757744,,000760		;ALLOW $ - . : AND 0-9
	400000,,000740		;ALLOW UC A-Z AND _
	400000,,000760		;ALLOW LC A-Z
> ;END TOPS10
SUBTTL	CANCEL command tables

CANFDB:	$KEYDSP(CAN010)

CAN010:	$STAB
	ORNDSP	(CAN020,<BATCH-REQUEST>,BAT)
	ORNDSP	(CAN020,<CARD-PUNCH-REQUEST>,CDP)
	ORNDSP	(CAN020,<EVENT-REQUEST>,EVT)
IFN FTFTS,<
	ORNDSP	(CAN020,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
	ORNDSP	(CAN040,<MOUNT-REQUEST>,MNT)
	ORNDSP	(CAN020,<PAPER-TAPE-PUNCH-REQUEST>,PTP)
	ORNDSP	(CAN020,<PLOTTER-REQUEST>,PLT)
	ORNDSP	(CAN020,<PRINTER-REQUEST>,LPT)
	$ETAB

CAN020:	$NUMBER(CONFRM,^D10,<request number to cancel in queue or if active>,<$ACTION(CHKPOS),$ALTERNATE(CAN030)>)

TOPS20 <
CAN030:	$USER(CONFRM,<$HELP(<user name whose jobs will be canceled>),$ALTERNATE(HLD040)>)
>;END TOPS20

TOPS10 <
CAN030:	$USER(CONFRM,<$HELP(<[project,programmer] whose jobs will be canceled>),$ALTERNATE(HLD040)>)
>;END TOPS10

CAN050:	$DEV(CAN060,<$HELP(<structure name to cancel all mount requests for>),$FLAGS(CM%PO!CM%NSF),$ALTERNATE(CAN055)>)

TOPS10<
CAN040:	$NUMBER(CAN060,^D10,<mount request number to cancel>,<$ACTION(CHKPOS),$ALTERNATE(CAN050)>)
CAN055:	$TOKEN(CAN060,<*>,<$HELP(<* to specify all pending requests>)>)
>
TOPS20<
CAN050:	$NUMBER(CAN060,^D10,<mount request number to cancel>,<$ACTION(CHKPOS)>)
>

CAN060:	$EXPL(CONFRM,<$ALTERNATE(CONFRM)>)

SUBTTL	MODIFY command tables

MODFDB:
	$KEYDSP	(MOD010)

MOD010:	$STAB
TOPS10<	ORNDSP	(MOD300,<ACTIVE-SWAPPING-LIST>,ASL) >
	ORNDSP	(MOD020,<BATCH-REQUEST>,BAT)
	ORNDSP	(MOD020,<CARD-PUNCH-REQUEST>,CDP)
TOPS10<	ORNDSP	(MOD200,<CRASH-DUMP-LIST>,CDL) >
IFN FTFTS,<
	ORNDSP	(MOD020,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
	ORNDSP	(MOD020,<PAPER-TAPE-PUNCH-REQUEST>,PTP)
	ORNDSP	(MOD020,<PLOTTER-REQUEST>,PLT)
	ORNDSP	(MOD020,<PRINTER-REQUEST>,LPT)
TOPS10<	ORNDSP	(MOD200,<SYSTEM-SEARCH-LIST>,SSL) >
	$ETAB

MOD020:	$NUMBER(MOD030,^D10,<request number to modify in queue>,<$ACTION(CHKPOS),$ALTERNATE(MOD070)>)

MOD030:	$KEYDSP(MOD040)

MOD040:	$STAB
	ORNDSP(MOD050,<PRIORITY>,PRI)
	$ETAB

MOD050:	$NOISE(MOD060,<to be>)

MOD060:	$NUMBER(CONFRM,^D10,<priority for request in range 1 to 63>,<$ACTION(CHKPRI)>)

MOD070:	$USER(MOD030,<$ALTERNATE(MOD080)>)
MOD080:	$TOKEN(MOD090,<*>,<$HELP(<* to specify all requests>)>)

MOD090:	$NODE(MOD030)

TOPS10<

;More of the MODIFY command tables

;Here if MODIFYing lists pertaining to file structures
MOD200:	$NOISE	(MOD210,<to>)

MOD210:	$KEY	(MOD230,MOD220)

MOD220:	$STAB
	ORNKEY	(EXCLUDE,EXC)
	ORNKEY	(INCLUDE,INC)
	$ETAB

MOD230:	$DEV	(CONFRM,<$HELP(<file structure name>),$FLAGS(CM%NSF)>)

;Here if MODIFYing lists pertaining to disk drives (units)
MOD300:	$NOISE	(MOD310,<to>)

MOD310:	$KEY	(MOD320,MOD220)

MOD320:	$DEV	(CONFRM,<$HELP(<disk unit name>),$FLAGS(CM%NSF)>)

>;END TOPS10
SUBTTL	SHOW command tables


SHWFDB:	$KEYDSP(SHW010)

SHW010:	$STAB
TOPS10<	ORNDSP(ALC000,ALLOCATION,ALC) >
	ORNDSP(SHW110,<CONTROL-FILE>,CTL)
	ORNDSP(SHW020,MESSAGES,MSG)
	ORNDSP(CONFRM,<NETWORK-QUEUE-NAMES>,QNM)
	ORNDSP(SHW030,OPERATORS,OPR)
	ORNDSP(SHW210,PARAMETERS,PRM)
	ORNDSP(SHW400,QUEUES,QUE)
	ORNDSP(CONFRM,<ROUTE-TABLE>,RTE)
TOPS20<	ORNDSP(CONFRM,SCHEDULER,SCH)>
	ORNDSP(STS000,STATUS,STS)
TOPS10<	ORNDSP(SYS000,<SYSTEM>,SLS) >
	ORNDSP(SHW060,TIME,DAY)	;DAYTIME CHANGES TO TIME
	$ETAB

SHW020:	$NUMBER(CONFRM,^D10,<message number>,<$ALTER(SHW030),$ACTION(CHKVAL)>)

SHW030:	$NODE(CONFRM)

SHW060:	$CRLF(<$ACTION(SHWDAY##)>)

SHW110:	$NOISE	(SHW120,<for>)
SHW120:	$KEY (SHW140,SHW130,<$DEFAULT(<BATCH-STREAM>)>)

SHW130:	$STAB
	ORNKEY(<BATCH-STREAM>,BAT)
	$ETAB

SHW140:	$NOISE	(SHW145,<stream number>)
SHW145:	$NUMBER	(SHW150,^D10,<stream number>,$ACTION(CHKVAL))

SHW150:	$SWITCHES(,SHW160,<$ALTER(CONFRM)>)
SHW160:	$STAB
	ORNSDP	(SHW170,<LINES:>,LNS)
	$ETAB
SHW170:	$NUMBER	(CONFRM,^D10,<number of lines>,$ACTION(CHKVAL))

SHW210:	$KEYDSP(SHW220,<$ALTER(SHW320)>)

SHW220:	$STAB
	ORNDSP	(SHW230,<BATCH-STREAM>,BAT)
	ORNDSP	(SHW230,<CARD-PUNCH>,CDP)
	ORNDSP	(SHW350,<FAL-STREAM>,FAL)
IFN FTFTS,<
	ORNDSP	(SHW230,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP	(SHWNOD,<NETWORK-NODE>,NOD)
IFN FTDQS,<ORNDSP	(SHW230,<NQC-STREAM>,NQC)>
	ORNDSP	(SHW230,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(SHW230,<PLOTTER>,PLT)
	ORNDSP	(SHW230,<PRINTER>,LPT)
	$ETAB


SHW230:	$SWITCH(SHW260,SHW250,<$ALTERNATE(SHW270)>)

SHW250:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

SHW260:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SHW270:	$RANGE(SHW280,<number or range (n:m)(/NODE:)>,<$ALTERNATE(CONFRM)>)

SHW280:	$NODE(CONFRM)

SHW320:	$SWITCH(SHW340,SHW330,<$ALTERNATE(CONFRM)>)

SHW330:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

SHW340:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SHW350:	$RANGE(CONFRM,<stream number or range (n:m)>,$ALTER(CONFRM))

;  Continued on next page
;Continued from previous page

;  SHOW QUEUE command

SHW400:	$KEYDSP(SHW420,<$DEFAULT(ALL),$ALTER(SHW430)>);NODE OR CONFIRM

SHW420:	$STAB
	ORNDSP	(SHW430,<ALL-JOBS>,ALL)
	ORNDSP	(SHW430,<BATCH-JOBS>,BAT)
	ORNDSP	(SHW430,<CARD-PUNCH-JOBS>,CDP)
	ORNDSP	(SHW430,<EVENTS>,EVT)
IFN FTFTS,<
	ORNDSP	(SHW430,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
	ORNDSP	(SHW470,<MOUNT-REQUESTS>,MNT)
	ORNDSP	(SHW430,<PAPER-TAPE-PUNCH-JOBS>,PTP)
	ORNDSP	(SHW430,<PLOTTER-JOBS>,PLT)
	ORNDSP	(SHW430,<PRINTER-JOBS>,LPT)
TOPS20<	ORNDSP	(SHW470,<RETRIEVAL-REQUESTS>,RET)>
	$ETAB

SHW430:	$SWITCH	(,SHW440,<$ALTER(CONFRM),$ACTION(SHRSWT)>) ;Switch or confirm

SHW440:	$STAB
	ORNSDP	(NEXT,<ALL>,ALL)
	ORNSDP	(SHW450,<NODE:>,NOD)
IFN FTDQS,<ORNSDP	(NEXT,<REMOTE>,RMT)>; END IFN FTDQS
	ORNSDP	(NEXT,<SHORT>,SHT)
	ORNSDP	(NEXT,<SUMMARY>,SUM)
	ORNSDP	(SHW460,<USER:>,USR)
	$ETAB

SHW450:	$NODNM	(NEXT,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SHW460:	$USER	(NEXT)

SHW470:	$SWITCH	(,SHW480,<$ALTER(CONFRM),$ACTION(SHRSWT)>) ;Switch or confirm

SHW480:	$STAB					;  But no node allowed!
	ORNSDP	(NEXT,<ALL>,ALL)
	ORNSDP	(NEXT,<SHORT>,SHT)
	ORNSDP	(SHW490,<USER:>,USR)
	$ETAB

SHW490:	$USER	(NEXT)
SUBTTL	SHOW STATUS command tables

STS000:	$KEYDSP(STS010,<$ALTER(STS100)>)

STS010:	$STAB
	ORNDSP	(STS020,<BATCH-STREAM>,BAT)
	ORNDSP	(STS020,<CARD-PUNCH>,CDP)
	ORNDSP	(STS190,<DISK-DRIVE>,DSK)
	ORNDSP	(STS300,<FAL-STREAM>,FAL)
IFN FTFTS,<
	ORNDSP	(STS020,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP	(SHWNOD,<NETWORK-NODE>,NOD)
IFN FTDQS,<ORNDSP	(STS020,<NQC-STREAM>,NQC)>
	ORNDSP	(STS020,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(STS020,<PLOTTER>,PLT)
	ORNDSP	(STS020,<PRINTER>,LPT)
	ORNDSP	(STS020,<READER>,RDR)
TOPS10<	ORNDSP	(STS250,<STRUCTURE>,STR)>
	ORNDSP	(STS160,<TAPE-DRIVE>,TAP)
	$ETAB

STS020:	$SWITCH(STS040,STS030,<$ALTERNATE(STS050)>)

STS030:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

STS040:	$NODNM(STS130,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

STS050:	$RANGE(STS060,<number or range (n:m)(/NODE:)>,<$ALTERNATE(STS130)>)

STS060:	$NODE(STS130)

STS100:	$SWITCH(STS120,STS110,<$ALTERNATE(STS130)>)

STS110:	$STAB
	ORNSWI(<NODE:>,NOD)
	$ETAB

STS120:	$NODNM(STS130,<node name>,<$FLAGS(CM%PO!CM%NSF)>)
STS130:	$SWITCH(CONFRM,STS140,<$ALTERNATE(CONFRM)>)

STS140:	$STAB
	ORNSWI(SHORT,SHT)
	$ETAB

STS150:	$DEV(STS170,<$HELP(<tape drive name>),$ALTERNATE(STS170),$FLAGS(CM%NSF)>)

STS160:	$CRLF(<$ALTERNATE(STS150)>)

STS170:	$SWITCH(CONFRM,STS180,<$ALTERNATE(CONFRM)>)

STS180:	$STAB
	ORNSWI(ALL,ALL)
TOPS20<	ORNSWI(CHARACTERISTICS,CHR) >	;TOPS20 ONLY
	ORNSWI(FREE,FRE)
	$ETAB

STS190:	$SWITCH(CONFRM,STS200,<$ALTERNATE(STS210)>)

STS200:	$STAB
	ORNSWI(ALL,ALL)
	ORNSWI(FREE,AVA)
	ORNSWI(MOUNTED,MNT)
	$ETAB

TOPS20<
STS210:	$CRLF
>;END TOPS20
TOPS10<
STS210:	$CRLF(<$ALTERNATE(STS220)>)

STS220:	$DEV(CONFRM,<$HELP(<disk drive name>),$FLAGS(CM%PO!CM%NSF)>)
>;END TOPS10
TOPS10<
STS250:	$DEV(STS260,<$HELP(<structure name>),$ALTERNATE(STS260),$FLAGS(CM%PO!CM%NSF)>)
STS260:	$SWITCH(CONFRM,STS270,<$ALTERNATE(CONFRM)>)
STS270:	$STAB
	ORNSWI(USERS,USR)
	$ETAB
>;END TOPS10

STS300:	$RANGE(CONFRM,<stream number or range (n:m)>,$ALTER(CONFRM))

SUBTTL	SHOW SYSTEM-LIST command tables

TOPS10<
SYS000:	$KEY	(CONFRM,SYS010,$DEFAULT(<LISTS>))

SYS010:	$STAB
	ORNKEY	(<LISTS>,LST)
	ORNKEY	(<PARAMETERS>,PRM)
	$ETAB
REPEAT 0,<
SYS000:	$CRLF	($ALTERNATE(SYS010))

SYS010:	$KEY	(CONFRM,SYS020)

SYS020:	$STAB
	ORNKEY	(<ACTIVE-SWAPPING-LIST>,ASL)
	ORNKEY	(<CRASH-DUMP-LIST>,CDL)
	ORNKEY	(<SYSTEM-SEARCH-LIST>,SSL)
	$ETAB
>;END REPEAT 0
>;END TOPS10
SUBTTL	LOCK/UNLOCK command tables

TOPS10 <

	;LOCK COMMAND

LOCFDB:	$NOISE(LOC010,<structure>)

LOC010:	$DEV(LOC015,<$FLAGS(CM%PO!CM%NSF),$HELP(<structure name>)>)

LOC015:	$NOISE(LOC020,<at>)

LOC020:	$FTAD(LOC030,<$ALTERNATE(LOC030)>)

LOC030:	$SWITCH (CONFRM,LOC040,<$ALTERNATE(CONFRM)>)
LOC040:	$STAB
	ORNSWI(NOUNLOAD,NUL)
	$ETAB

	;UNLOCK COMMAND

ULCFDB:	$NOISE(ULC010,<structure>)

ULC010:	$DEV(ULC015,<$FLAGS(CM%PO!CM%NSF),$HELP(<structure name>)>)

ULC015:	$NOISE(ULC020,<at>)

ULC020:	$FTAD(CONFRM,<$ALTERNATE(CONFRM)>)


>;END TOPS10
SUBTTL	SHWNOD	SHOW STATUS/PARAMETERS FOR NODE

SHWNOD:	$CRLF	(<$ALTERNATE(SHWN01)>)

SHWN01:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SUBTTL	RESPOND command tables

RSPFDB:	$NOISE	(RSP001,<to message number>)

RSP001:	$NUMBER	(RSP005,^D10,<message number>,$ACTION(CHKVAL))

RSP005:	$CRLF	(<$ALTER(RSP010),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

RSP010:	$CTEXT	(CONFRM,<single line response>)
SUBTTL	RESTRICT and UNRESTRICT command tables

TOPS10	<
RSTFDB:	$NOISE	(RST001,<device>)

RST001:	$DEV	(CONFRM,<$FLAGS(CM%NSF),$HELP(<device name>)>)
> ;END TOPS10
SUBTTL	REQUEUE command tables


REQFDB:	$NOISE	(REQ010,<current job on>)

REQ010:	$KEYDSP	(REQ020)
REQ020:	$STAB
	ORNDSP	(REQ030,<BATCH-STREAM>,BAT)
	ORNDSP	(REQ040,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP	(REQ030,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP	(REQ040,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(REQ040,<PLOTTER>,PLT)
	ORNDSP	(REQ040,<PRINTER>,LPT)
	$ETAB


; Batch tables
;
REQ030:	$STREAM	(REQ100)


; Output device tables
;
REQ040:	$UNIT	(REQ050)
REQ050:	$KEYDSP	(REQ060,<$DEFAULT(CURRENT-POSITION),$ALTER(REQ100)>)
REQ060:	$STAB
	ORNDSP	(REQ070,<BEGINNING-OF>,BEG)
	ORNDSP	(REQ100,<CURRENT-POSITION>,CUR)
	$ETAB
REQ070:	$KEY	(REQ100,REQ080)
REQ080:	$STAB
	ORNKEY	(<COPY>,CPY)
	ORNKEY	(<FILE>,FIL)
	ORNKEY	(<JOB>,JOB)
	$ETAB

REQ100:	$EXPL	(CONFRM,<$ALTER(CONFRM)>)
SUBTTL	BACKSPACE command tables
SUBTTL	FORWARDSPACE command tables

BKSFDB:	$KEY (BKS002,BKS001,<$DEFAULT(<PRINTER>)>)

BKS001:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

BKS002:	$UNIT(BKS003)

BKS003:	$SWITCH(,BKS004)

BKS004:	$STAB
	ORNSDP(BKS005,<COPIES:>,CPY)
	ORNSDP(CONFRM,<FILE>,FIL)
	ORNSDP(BKS007,<PAGES:>,PAG)
	$ETAB

BKS005:	$NUMBER	(CONFRM,^D10,<number of copies>,$ACTION(CHKVAL))
REPEAT 0,<
BKS006:	$NUMBER	(CONFRM,^D10,<number of files>,<$ACTION(CHKFIL),$DEFAULT(<1>)>)
>
BKS007:	$NUMBER	(CONFRM,^D10,<number of pages>,$ACTION(CHKVAL))

REPEAT 0,<
CHKFIL:	SKIPG	T1,CR.RES(S2)	;CHECK THAT NUMBER
	JRST	CHKF.1		;GENERTE AN ERROR
	CAIN	T1,1		;WAS IT A 1
	$RETT			;O.K..RETURN
CHKF.1:	PUSHJ	P,P$FIXP##
	MOVEI	S2,[ASCIZ/only one file allowed/]
	$RETF
>
SUBTTL	ALIGN command table

ALIFDB:	$NOISE (ALI001,<forms on>)

ALI001:	$KEY (ALI003,ALI002,<$DEFAULT(<PRINTER>)>)

ALI002:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

ALI003:	$UNIT(ALI010)

ALI004:	$IFILE	(ALI005,<alignment file>,<$ALTER(ALI005)>)

ALI005:	$SWITCH(,ALI006,<$ALTER(CONFRM),$ACTION(SHRSWT)>)

ALI006:	$STAB
	ORNSDP(ALI007,<PAUSE:>,PAU)
	ORNSDP(ALI008,<REPEAT-COUNT:>,RPT)
	$ETAB

ALI007:	$NUMBER (NEXT,^D10,<seconds to pause>,$ACTION(CHKVAL))

ALI008:	$NUMBER (NEXT,^D10,<times to print>,$ACTION(CHKVAL))

ALI009:	$STAB
	ORNSWI(STOP,STP)
	$ETAB

ALI010:	$SWITCH(CONFRM,ALI009,<$ALTER(ALI004)>)
SUBTTL	SUPPRESS command tables

SUPFDB:	$NOISE (SUP001,<carriage control on>)

SUP001:	$KEY (SUP010,SUP005,<$DEFAULT(<PRINTER>)>)


SUP005:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

SUP010:	$UNIT(SUP015)

SUP015:	$SWITCH(CONFRM,SUP020,<$DEFAULT(</JOB>),$ALTER(CONFRM)>)

SUP020:	$STAB
	ORNSWI(FILE,FIL)
	ORNSWI(JOB,JOB)
	ORNSWI(STOP,STP)
	$ETAB
SUBTTL	ROUTE command tables

RTEFDB:	$NOISE	(RTEF05,device)

RTEF05:	$KEYDSP(RTEF10)

RTEF10:	$STAB
	ORNDSP(RTEF50,<ALL-DEVICES>,ALL)
	ORNDSP(RTEF15,<CARD-PUNCH>,CDP)
	ORNDSP(RTEF15,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(RTEF15,<PLOTTER>,PLT)
	ORNDSP(RTEF15,<PRINTER>,LPT)
	$ETAB

RTEF15:	$NOISE	(RTEF20,<unit number>)
RTEF20:	$NUMBER	(RTEF35,^D10,<source device unit number>,$ALTERN(RTEF25))
RTEF25:	$KEYDSP	(RTEF30)
RTEF30:	$STAB
	ORNDSP	(RTEF35,<ALL-UNITS>,ALL)
	$ETAB

;To explain the following magical line...
;The default '(' is to allow an ESC to go to the next field and display noise.
;The ERRPDB is used to only get to the next field on switch error or ESC.
;The alternate is to permit entering the destination or crlf
RTEF35:	$SWITCH	(RTEF39,RTEF36,<$DEFAULT(<(>),$ERRPDB(RTEF40),$ALTER(RTEF45)>)
RTEF36:	$STAB
	ORNSWI(NODE:,NOD)
	$ETAB
RTEF39:	$NODNM	(RTEF40,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

RTEF40:	$NOISE	(RTEF45,<to unit number>)
RTEF45:	$NUMBER	(RTEF48,^D10,<destination unit number>,<$ALTERNATE(RTEF46)>)
RTEF46:	$KEYDSP	(RTEF47,<$ALTERNATE(RTEF80)>)
RTEF47:	$STAB
	ORNDSP	(RTEF48,<ALL-UNITS>,ALL)
	$ETAB
RTEF48:	$NODE	(CONFRM)

;For parsing all devices

RTEF50:	$NOISE	(RTEF55,<on node>)
RTEF55:	$KEYDSP	(RTEF60,<$HELP(<ALL-NODES>),$ALTERNATE(RTEF65)>)
RTEF60:	$STAB
	ORNDSP	(RTEF70,<ALL-NODES>,ALL)
	$ETAB

RTEF65:	$NODNM	(RTEF70,<source node name>,<$FLAGS(CM%PO!CM%NSF)>)

RTEF70:	$NOISE	(RTEF75,<to node>)
RTEF75:	$NODNM	(CONFRM,,<$ALTERNATE(RTEF80),$FLAGS(CM%PO!CM%NSF)>)

RTEF80:	$CRLF	($HELP(<confirm to delete routing>))
SUBTTL	SEND command tables

SNDFDB:	$NOISE	(SND001,<to>)

SND001:	$KEYDSP	(SND005)

SND005:	$STAB
	ORNDSP(SND040,<ALL>,ALL)
	ORNDSP(SND015,<BATCH-STREAM>,BAT)
	ORNDSP(SND010,<JOB>,JOB)
	ORNDSP(SND025,<OPERATOR>,OPR)
	ORNDSP(SND020,<TERMINAL>,TRM)
	$ETAB

SND010:	$NUMBER(SND030,^D10,<job number>,$ACTION(CHKVAL))
SND015:	$STNUM(SND025)
SND020:	$NUMBER(SND030,^D8,<terminal number>,$ACTION(CHKVAL))
SND025:	$NODE(SND030)

SND030:	$CRLF	(<$ALTER(SND035),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)

SND035:	$CTEXT	(CONFRM,<single line response>)
SND040:	$NODE(SND035)
SUBTTL	SET command tables

SETFDB:	$KEYDSP(SET010)

SET010:	$STAB
	ORNDSP(SET170,BATCH-STREAM,BAT)
	ORNDSP(SET490,<CARD-PUNCH>,CDP)
TOPS20<	ORNDSP(SET700,<DISK-DRIVE>,DSK)>
	ORNDSP(SETFAL,<FAL-STREAM>,FAL)
	ORNDSP(SET070,JOB,JOB)
TOPS10<	ORNDSP(SETKSY,KSYS,KSY)>
IFN	FTDN60,<
	ORNDSP(SETNOD,<NODE>,NOD)
>;END FTDN60
IFN FTDQS,<ORNDSP(SETNQC,<NQC-STREAM>,NQC)>
TOPS20<	ORNDSP(SET800,<ONLINE>,ONL)>
	ORNDSP(SET430,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(SET370,PLOTTER,PLT)
	ORNDSP(SET200,PRINTER,LPT)
TOPS20<	ORNDSP(SETSCH,<SCHEDULER>,SCH)>
TOPS20<	ORNDSP(SET600,<STRUCTURE>,STR)>
TOPS10<	ORNDSP(SETSYS,<SYSTEM>,SYS)>
	ORNDSP(SET630,<TAPE-DRIVE>,TAP)
	ORNDSP(SET020,TERMINAL,TRM)
TOPS10<	ORNDSP(SET900,USAGE,USG)>
	$ETAB

;SET FAL-STREAM command

SETFAL:	$RANGE	(SETF00,<stream number or range (n:m)>)

SETF00:	$KEYDSP	(SETF05,<$DEFAULT(NETWORK)>)

SETF05:	$STAB
	ORNDSP	(SETF10,<NETWORK>,NET)
	$ETAB

SETF10:	$KEY	(CONFRM,SETF15)

SETF15:	$STAB
	ORNKEY(<ANF-10>,ANF)
	ORNKEY(DECNET,DCN)
	$ETAB

;SET TERMINAL command

SET020:	$KEYDSP(SET030,<$ACTION(SETRTN##)>)

SET030:	$STAB

TOPS10<	ORNDSP(SET350,KEYPAD,KPD)
	ORNDSP(SET350,NOKEYPAD,NKP)>
	ORNDSP(SET040,<TYPE>,TYP)
	$ETAB

SET040:	$NOISE (SET050,<to be>)
SET050:	$KEY(SET350,SET060,<$ACTION(SETRTN##)>)

SET060:	$STAB
DEFINE X(PARNAM,SIXNAM,SUF,EOLSEQ),<
	KEYTAB(.TT'SUF,<PARNAM>)
>;END DEFINE X
	TRMTYP				;Generate the options
	$ETAB

SET070:	$NOISE(SET080,<job number>)
SET080:	$NUMBER(SET090,^D10,<job number>,$ACTION(CHKVAL))

SET090:	$KEYDSP(SET100)

SET100:	$STAB
	ORNDSP(CONFRM,<NOOPR-INTERVENTION>,NOI)
	ORNDSP(CONFRM,<OPR-INTERVENTION>,OIA)
TOPS20<	ORNDSP(SET110,SCHEDULER-CLASS,CLS)>
	$ETAB

TOPS20 <
SET110:	$NOISE(SET120,<to be>)

SET120:	$NUMBER(CONFRM,^D10,<scheduler class to put the job in>)

>;END TOPS20

SET170:	$SRANGE(SET180)
SET180:	$KEYDSP(SET250)

SET200:	$URANGE(SET210)
SET210:	$KEYDSP(SET300)


SET250:	$STAB
	ORNDSP(SET295,ATTRIBUTE,ATR)
TOPS10<	ORNDSP(SET290,<MEMORY-LIMITS>,MEM)>
	ORNDSP(CONFRM,NOOPR-INTERVENTION,NOI)
	ORNDSP(CONFRM,OPR-INTERVENTION,OIA)
	ORNDSP(SET260,PRIORITY-LIMITS,PRL)
	ORNDSP(CONFRM,SYSTEM-OPR-INTERVENTION,SOI)
	ORNDSP(SET270,TIME-LIMITS,TIM)
	$ETAB

SET260:	$RANGE(CONFRM,<maximum priority limit or a range (1-63)>)
SET270:	$RANGE(CONFRM,<maximum time limits in minutes or a range>)
SET280:	$NUMBER(CONFRM,^D10,<line number>,$ACTION(CHKVAL))
;GET MEMORY LIMITS

TOPS10 <
SET290:	$RANGE(CONFRM,<maximum number of pages or a range>)
> ;End TOPS10

SET295:	$KEYDSP(SET297)
SET297:	$STAB
	ORNDSP(CONFRM,BATCON,BAT)
	ORNDSP(CONFRM,SITGO,SIT)
	$ETAB

SET300:	$STAB
	ORNDSP(SET330,FORMS-TYPE,FOT)
	ORNDSP(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP(CONFRM,LP20-SIMULATION,LP2)
	ORNDSP(MTAFDB,MAGTAPE,MTA)
	ORNDSP(SET301,NO,NO)
	ORNDSP(SET310,PAGE-LIMITS,PGL)
	ORNDSP(SET260,PRIORITY-LIMITS,PRL)
	ORNDSP(SET305,<UNIT-TYPE>,UTY)
	$ETAB

SET301:	$KEYDSP	(SET302)
SET302:	$STAB
	ORNDSP	(CONFRM,LP20-SIMULATION,LP2)
	$ETAB

SET305:	$FIELD	(CONFRM,<unit type>)

SET310:	$RANGE(CONFRM,<maximum number of pages or a range>)

SET320:	$STAB
	ORNKEY(ABORT,CNC)
	ORNKEY(ASK,ASK)
	ORNKEY(PROCEED,IGN)
	$ETAB

SET330:	$FIELD(CONFRM,<forms name>)
SET340:	$KEY(CONFRM,SET320)
SET350:	$CRLF(<$ACTION(SETTRM##)>)

SET370:	$URANGE	(SET380)

SET380:	$KEYDSP	(SET390)

SET390:	$STAB
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP	(MTAFDB,MAGTAPE,MTA)
	ORNDSP	(SET480,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
;	ORNDSP	(SET395,<UNIT-TYPE>,UTY)
	$ETAB

SET395:	$FIELD	(CONFRM,<unit type>)

SET430:	$URANGE	(SET440)

SET440:	$KEYDSP	(SET450)

SET450:	$STAB
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP	(MTAFDB,MAGTAPE,MTA)
	ORNDSP	(SET470,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
	ORNDSP	(SET460,<UNIT-TYPE>,UTY)
	$ETAB

SET460:	$FIELD	(CONFRM,<unit type>)

SET470:	$RANGE(CONFRM,<maximum limit in feet or a range>)
SET480:	$RANGE(CONFRM,<maximum limit in minutes or a range>)
SET490:	$URANGE(SET500)

SET500:	$KEYDSP	(SET510)

SET510:	$STAB
	ORNDSP	(SET330,<FORMS-TYPE>,FOT)
	ORNDSP	(SET340,LIMIT-EXCEEDED-ACTION,LEA)
	ORNDSP	(MTAFDB,MAGTAPE,MTA)
	ORNDSP	(SET530,<OUTPUT-LIMIT>,OPL)
	ORNDSP	(SET260,PRIORITY-LIMITS,PRL)
;	ORNDSP	(SET520,<UNIT-TYPE>,UTY)
	$ETAB

SET520:	$FIELD	(CONFRM,<unit type>)

SET530:	$RANGE(CONFRM,<maximum limit in cards or a range>)
;SPECIAL COMMAND TABLES FOR MAGTAPE SPOOLING PARAMETERS
MTAFDB:	$SWITCH(,MTA010,<$ACTION(SHRSWT),$ALTERN(CONFRM)>)
MTA010:	$STAB
	ORNSDP	(MTA020,<DENSITY:>,MDN)
	ORNSDP	(MTA990,<DIRECTORY-FILE:>,MDI)
	ORNSDP	(MTA030,<LABEL-TYPE:>,MLT)
	ORNSDP	(MTA990,<MULTI-REEL:>,MRL)
	ORNSDP	(MTA040,<PARITY:>,MPR)
	ORNSDP	(MTA050,<TRACKS:>,MTK)
	ORNSDP	(MTA060,<VOLUME-SET:>,MVS)
	$ETAB


;SET DENSITY
MTA020:	$KEYDSP	(MTA021,<$DEFAULT(<DEFAULT>)>)
MTA021:	$STAB
	ORNDSP	(NEXT(MTAFDB),<1600>,160)
	ORNDSP	(NEXT(MTAFDB),<200>,200)
	ORNDSP	(NEXT(MTAFDB),<556>,556)
	ORNDSP	(NEXT(MTAFDB),<6250>,625)
	ORNDSP	(NEXT(MTAFDB),<800>,800)
	ORNDSP	(NEXT(MTAFDB),<DEFAULT>,DFL)
	$ETAB


;SET LABEL-TYPE
MTA030:	$KEYDSP	(MTA031)
MTA031:	$STAB
	ORNDSP	(NEXT(MTAFDB),<ANSI>,ANS)
	ORNDSP	(NEXT(MTAFDB),<DEFAULT>,DFL)
	ORNDSP	(NEXT(MTAFDB),<EBCDIC>,EBC)
	ORNDSP	(NEXT(MTAFDB),<IBM>,EBC)
	ORNDSP	(NEXT(MTAFDB),<UNLABELED>,UNL)
	$ETAB


;SET PARITY
MTA040:	$KEYDSP	(MTA041,<$DEFAULT(<DEFAULT>)>)
MTA041:	$STAB
	ORNDSP	(NEXT(MTAFDB),<DEFAULT>,DFL)
	ORNDSP	(NEXT(MTAFDB),<EVEN>,EVN)
	ORNDSP	(NEXT(MTAFDB),<ODD>,ODD)
	$ETAB


;SET TRACKS
MTA050:	$KEYDSP	(MTA051,<$DEFAULT(<DEFAULT>)>)
MTA051:	$STAB
	ORNDSP	(NEXT(MTAFDB),<7>,7TK)
	ORNDSP	(NEXT(MTAFDB),<9>,9TK)
	ORNDSP	(CONFRM,<DEFAULT>,DFL)
	$ETAB


;SET VOLUME-SET-NAME
MTA060:	$QUOTE	(NEXT(MTAFDB),<quoted or unquoted string>,<$ALTER (MTA061)>)
MTA061:	$FIELD	(NEXT(MTAFDB),,<$BREAK (MTA062),$FLAGS (CM%SDH)>)
MTA062:	777777,,777760			;BREAK ON ALL CONTROL
	777754,,001760			;ALLOW - AND 0-9
	400000,,000760			;ALLOW UC A-Z
	400000,,000760			;ALLOW LC A-Z


;SET MULTI-REEL
;SET DIRECTORY-FILE
MTA990:	$KEYDSP	(MTA991,<$DEFAULT(<DEFAULT>)>)
MTA991:	$STAB
	ORNDSP	(NEXT(MTAFDB),<DEFAULT>,DFL)
	ORNDSP	(NEXT(MTAFDB),<NO>,NO)
	ORNDSP	(NEXT(MTAFDB),<YES>,YES)
	$ETAB
SUBTTL	SET TAPE and DISK command tables (TOPS20)

TOPS20 <

SET600:	$DEV	(SET610,<$HELP(<structure name>),$FLAGS(CM%PO!CM%NSF)>)

SET610:	$KEYDSP(SET620)

SET620:	$STAB
	ORNDSP(SET622,<ACKNOWLEDGED>,ACK)
	ORNDSP(SET624,<AVAILABLE>,AVA)
	ORNDSP(CONFRM,<DOMESTIC>,DOM)
	ORNDSP(CONFRM,<FOREIGN>,FOR)
	ORNDSP(SET622,<IGNORED>,IGN)
	ORNDSP(CONFRM,<REGULATED>,REG)
	ORNDSP(SET624,<UNAVAILABLE>,UAV)
	ORNDSP(CONFRM,<UNREGULATED>,URG)
	$ETAB

SET622:	$NOISE(CONFRM,<as a new mountable structure>)

SET624:	$NOISE(CONFRM,<to new users>)

>;END TOPS20
SET630:	$DEV(SET640,<$HELP(<tape drive name>),$FLAGS(CM%NSF)>)

SET640:	$KEYDSP(SET650,<$ACTION(SET655)>)

SET650:	$STAB
	ORNDSP(SET660,<AVAILABLE>,AVA)
	ORNDSP(SETINI,<INITIALIZE>,INI)
	ORNDSP(SET670,<UNAVAILABLE>,UAV)
	$ETAB

	$DATA	VOLIDF,1		;Volume id flag (used for INITIALIZE)
					;if 0 then switch not used
					;if -1 then switch used
					;if 1 then switch needed (ANSI labels)

SET655:	SETZM	VOLIDF			;Initialize volid flag
	$RETT

SET660:	$NOISE(CONFRM,<for use by system>)

SET670:	$CRLF	(<$ALTER(SET680),$ACTION(TXTLIN##),$HELP(<confirm for multiple line explanation for drive unavailable>)>)

SET680:	$CTEXT	(CONFRM,<single line response>)

TOPS20 <

SET700:	$NOISE(SET705,<on>)

SET705:	$KEY(SET720,SET710,<$DEFAULT(<CHANNEL>)>)

SET710:	$STAB
	ORNKEY(<CHANNEL>,CHN)
	$ETAB

SET720:	$NUMBER(SET730,^D8,<channel number>,<$ACTION(CHKCHN)>)

SET730:	$KEY(SET750,SET740,<$DEFAULT(<DRIVE>)>)

SET740:	$STAB
	ORNKEY(<DRIVE>,DRV)
	$ETAB

SET750:$NUMBER(SET760,^D8,<drive number>,<$ACTION(CHKVAL)>)

SET760:	$KEYDSP(SET770)

SET770:	$STAB
	ORNDSP(SET660,<AVAILABLE>,AVA)
	ORNDSP(SET670,<UNAVAILABLE>,UAV)
	$ETAB
>;END TOPS20
SUBTTL	SET ONLINE command tables

TOPS20 <
SET800:	$NOISE(SET810,<device address>)

SET810:	$NUMBER(SET820,<^D8>,<channel number>,<$ACTION(CHKCHN)>)

SET820:	$COMMA(SET830)

SET830:	$NUMBER(SET840,<^D8>,<device unit number>,<$ACTION(CHKVAL)>)

SET840:	$COMMA(SET850,<$ALTERNATE(<CONFRM>)>)

SET850:	$NUMBER(SET860,<^D8>,<controller number or -1>,<$DEFAULT(<-1>)>)

SET860:	$NOISE(SET865,<alternate address>)

SET865:	$NUMBER(SET870,<^D8>,<alternate channel>,<$ACTION(CHKCHN),$ALTERNATE(CONFRM)>)

SET870:	$COMMA(SET875)

SET875:	$NUMBER(SET880,<^D8>,<alternate device unit number>,<$ACTION(CHKVAL)>)

SET880:	$COMMA(SET885,<$ALTERNATE(<CONFRM>)>)

SET885:	$NUMBER(CONFRM,<^D8>,<alternate controller number or -1>,<$DEFAULT(<-1>)>)

CHKCHN:	SKIPL	S1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	S1,7		;IN BOUNDS
	SKIPA			;BAD NUMBER
	$RETT			;IT'S GOOD
	PUSHJ	P,P$FIXP##
	MOVEI	S2,[ASCIZ/channel number not in range 0:7/]
	$RETF

>;END TOPS20
SUBTTL	SET USAGE command tables

TOPS10<

SET900:	$KEYDSP(SET901)
SET901:	$STAB
	ORNDSP(SET902,BILLING-CLOSURE,UBC)
	ORNDSP(SET920,FILE-CLOSURE,UFC)
	$ETAB

SET902:	$KEYDSP(SET903,<$ALTER(SET910)>)
SET903:	$STAB
	ORNDSP(SET904,DAILY,DLY)
	ORNDSP(SET906,EVERY,WKY)
	ORNDSP(EVTSWT,NOW,NOW)
	$ETAB

SET904:	$NOISE(SET905,<at>)
SET905:	$TIME(EVTSWT)

SET906:	$KEY(SET904,SET942)

SET910:	$FTAD(EVTSWT)

SET920:	$KEYDSP(SET925,<$ALTER(SET950)>)

SET925:	$STAB
	ORNDSP(SET930,DAILY,DLY)
	ORNDSP(SET940,EVERY,WKY)
	ORNDSP(SET960,NOW,NOW)
	$ETAB

SET930:	$NOISE(SET932,<at>)
SET932:	$TIME(SET960)

SET940:	$KEY(SET945,SET942)
SET942:	$STAB
	KEYTAB(2,FRIDAY)
	KEYTAB(5,MONDAY)
	KEYTAB(3,SATURDAY)
	KEYTAB(4,SUNDAY)
	KEYTAB(1,THURSDAY)
	KEYTAB(6,TUESDAY)
	KEYTAB(0,WEDNESDAY)
	$ETAB

SET945:	$NOISE(SET946,<at>)
SET946:	$TIME(SET960)

SET950:	$TAD(SET960)

SET960:	$SWITCH(EVTSWT,SET965,<$ALTERNATE(EVTSWT)>)
SET965:	$STAB
	ORNSWI(<NO-SESSION-ENTRIES>,NOS)
	$ETAB
SUBTTL	SET KSYS command tables

SETKSY:	$NOISE(SETK00,<to stop timesharing>)

SETK00:	$KEYDSP(SETK01,<$ALTER(SETK02)>)

SETK01:	$STAB
	ORNDSP(SETK04,DAILY,DLY)
	ORNDSP(SETK03,EVERY,WKY)
	ORNDSP(SETK09,NOW,NOW)
	$ETAB

SETK02:	$FTAD(SETK09)

SETK03:	$KEY(SETK04,SET942)

SETK04:	$NOISE(SETK05,<at>)

SETK05:	$TIME(SETK09)

SETK09:	$SWITCH(EVTSWT,SETK10,<$ALTER(EVTSWT)>)

SETK10:	$STAB
	ORNSWI(CM,CM)
	ORNSWI(NEW,NEW)
	ORNSWI(PM,PM)
	ORNSWI(SA,SA)
	ORNSWI(SCHED,SCH)
	$ETAB
SUBTTL	EVTSWT	- Common Event Switches

;Switches that should be common to all commands that queue an EVENT.
;EVTMSG in OPRQSR parses these switches for free and creates .QBESW block.
;These switches are parsed LAST in a command. Event specific switches
;should be before the common event switches. /REASON: is the last switch
;parsed because we only allow single line reason followed by <CR><LF>.

EVTSWT:	$SWITCH(,EVTS00,<$ACTION(SHRSWT),$ALTER(CONFRM)>)

EVTS00:	$STAB
	ORNSDP(NEXT(EVTSWT),<FAILSOFT>,FSF)
	ORNSDP(EVTS10,<FILE:>,FIL)
	ORNSDP(EVTS20,<REASON:>,RSN)
	$ETAB

EVTS10:	$IFILE(NEXT(EVTSWT),<file to TAKE at KSYS time>)

EVTS20:	$CTEXT(CONFRM,<reason text (same line) followed by confirm>)

;;***************************************************
;;SETK11:	$SWITCH(SETK13,SETK12,<$ALTER(SETK14)>)
;;
;;SETK12:	$STAB
;;	ORNSWI(FILE:,FIL)
;;	$ETAB
;;
;;SETK13:	$IFILE(SETK14,<file to TAKE at KSYS time>)
;;
;;SETK14:	$SWITCH(SETK16,SETK15,<$ALTER(CONFRM)>)
;;
;;SETK15:	$STAB
;;	ORNSWI(<REASON:>,RSN)
;;	$ETAB
;;
;;SETK16:	$CTEXT(CONFRM,<reason text (same line) followed by confirm>)
;;
;;******************************************************
> ;End TOPS10 conditional

SUBTTL	SET SYSTEM BATMAX, BATMIN, and LOGMAX command tables

TOPS10<

SETSYS:	$KEYDSP(SETSTB)

SETSTB:	$STAB
	ORNDSP(SETBMX,<BATMAX>,BMX)
	ORNDSP(SETBMN,<BATMIN>,BMN)
	ORNDSP(SETCMX,<CORMAX>,CMX)
	ORNDSP(SETCMN,<CORMIN>,CMN)
	ORNDSP(SETDAT,<DATE>,DAT)
	ORNDSP(SETDAY,<DAYTIME>,DAY)
	ORNDSP(SETCSZ,<DISK-CACHE-SIZE>,CSZ)
	ORNDSP(SETLMX,<LOGMAX>,LMX)
	ORNDSP(SETSCD,<SCHEDULE>,SCD)
	$ETAB

SETBMX:	$NUMBER(CONFRM,^D10,<maximum number of logged-in batch jobs>)

SETBMN:	$NUMBER(CONFRM,^D10,<number of jobs reserved for batch>)

SETCMX:	$FIELD(CONFRM,<maximum core size in K or P for a job>,$BREAK(SETBRK))

SETCMN:	$FIELD(CONFRM,<minimum guaranteed contiguous core in K or P>,$BREAK(SETBRK))

SETDAT:	$DATE(CONFRM,$HELP(<enter date as dd-mmm-yy>))

SETDAY:	$TIME(CONFRM,$HELP(<enter time as hh:mm:ss>))

SETCSZ:	$NUMBER(CONFRM,^D10,<number of blocks in monitor disk cache>,$ALTER(SETCS1))
SETCS1:	$CRLF($HELP(<carriage return to reset to configured size>))

SETLMX:	$NUMBER(CONFRM,^D10,<maximum number of logged-in jobs>)

SETSCD:	$NUMBER(CONFRM,^D8,<schedule bits in octal>)

SETBRK:	777777,,777777			;BREAK ON ALL CONTROL
	777774,,001777			;ALLOW 0 THRU 9
	777675,,777777			;ALLOW UC K OR P
	777675,,777777			;ALLOW LC K OR P

> ;End TOPS10 conditional
SUBTTL	SET TAPE INITIALIZE command tables
SETINI:	$SWITCH(,INI010,<$ACTION(SHRSWT),$ALTERNATE(INI250)>)

INI010:	$STAB
TOPS10<	ORNDSP(INI300,<ABORT>,CNC) >
	ORNSDP(INI140,<COUNT:>,CNT)
	ORNSDP(INI020,<DENSITY:>,DEN)
	ORNSDP(INI240,<INCREMENT:>,INC)
	ORNSDP(INI040,<LABEL-TYPE:>,LBT)
	ORNSDP(INI060,<OVERRIDE-EXPIRATION:>,OVR)
	ORNSDP(INI080,<OWNER:>,OWN)
	ORNSDP(INI100,<PROTECTION:>,PRO)
	ORNSDP(INI120,<TAPE-DISPOSITION:>,TDP)
	ORNSDP(INI170,<VOLUME-ID:>,VID)
	$ETAB


INI020:	$KEY(NEXT(SETINI),INI030,<$DEFAULT(<1600>)>)

INI030:	$STAB
	ORNKEY(1600,160)
	ORNKEY(200,200)
	ORNKEY(556,556)
	ORNKEY(6250,625)
	ORNKEY(800,800)
	$ETAB

INI040:	$KEY(NEXT(SETINI),INI050,<$ACTION(INI057),$DEFAULT(<ANSI>)>)

INI050:	$STAB
	ORNKEY(ANSI,ANS)
	ORNKEY(EBCDIC,EBC)
TOPS20<	ORNKEY(TOPS-20,T20)>
INI055:	ORNKEY(UNLABELED,UNL)
	$ETAB

INI057:	MOVE	S1,CR.RES(S2)		;Get the result from the key table
	CAIE	S1,INI055		;Was the label type unlabeled?
	SKIPE	VOLIDF			;No - skip if still need volume id
	$RETT				;No further action needed
	MOVEI	S1,1
	MOVEM	S1,VOLIDF		;Set that we need volid to be specified
	$RETT

;**;[147]CHANGE 1 LINE AT INI060:+0L	6-MAR-84/CTK
INI060:	$KEY(NEXT(SETINI),INI070,<$DEFAULT(<YES>)>)	;[147]DEFAULT YES

INI070:	$STAB
	ORNKEY(NO,NO)
	ORNKEY(YES,YES)
	$ETAB

TOPS20 <
INI080:	$USER(NEXT(SETINI),<$HELP(<user who owns the tape>)>)
>;END -20

TOPS10 <
INI080:	$USER(NEXT(SETINI),<$HELP(<user PPN who owns the tape>)>)
>;END -10

INI100:	$NUMBER(NEXT(SETINI),^D8,<protection for the tape as an octal number>)

INI120:	$KEY(NEXT(SETINI),INI130,<$DEFAULT(<UNLOAD>)>)

INI130:	$STAB
	ORNKEY(HOLD,HLD)
	ORNKEY(UNLOAD,UNL)
	$ETAB

INI140:	$NUMBER(NEXT(SETINI),^D10,<number of volumes to be initialized>,<$ACTION(CHKPOS),$DEFAULT(<10>)>)

INI170:	$FIELD(NEXT(SETINI),<volume-id without quotes>,<$PREFILL(INI175)>)

INI175:	SETOM	VOLIDF				;Say we saw volume id
	$RETT

INI240:	$NUMBER(NEXT(INI200),^D10,<increment value for assigning next volume-id>,<$ACTION(CHKPOS),$DEFAULT(<1>)>)

INI250:	$CRLF ($ACTION(INI260))

INI260:	SKIPG	VOLIDF				;Is it not needed or not used?
	$RETT					;Yes
	MOVEI	S2,[ASCIZ/Volid must be specified/]
	$RETF

INI300:	$CRLF	(<$HELP(<confirm to abort tape initialization>)>)
SUBTTL	SET NETWORK-QUEUE-CONTROLLER command tables


SETNQC:	$SRANGE	(NQC010)

NQC010:	$KEYDSP	(NQC020,<$DEFAULT(<ATTRIBUTE>)>)
NQC020:	$STAB
	ORNDSP	(NQC030,<ATTRIBUTE>,ATR)
	$ETAB

NQC030:	$KEYDSP	(NQC040)
NQC040:	$STAB
	ORNDSP	(CONFRM,<INPUT-STREAM>,NQI)
	ORNDSP	(CONFRM,<OUTPUT-STREAM>,NQO)
	$ETAB
SUBTTL	SET NODE command tables

IFN	FTDN60,<

SETNOD:	$NODNM(SETN10,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SETN10:	$KEYDSP(SETN20)

SETN20:	$STAB
	ORNDSP(SETN95,<BYTES-PER-MESSAGE>,BPM)
	ORNDSP(SETN40,<CLEAR-SEND-DELAY>,CSD)
	ORNDSP(SETN60,<RECORDS-PER-MESSAGE>,RPM)
	ORNDSP(SETN80,<TIMEOUT-CATEGORY>,TOU)
	ORNDSP(SETN90,<TRANSPARENCY>,TRA)
	$ETAB

SETN40:	$NUMBER(CONFRM,^D10,<time in jiffies>,<$ACTION(CHKVAL)>)

SETN50:	$KEY(CONFRM,SETN55,<$DEFAULT(<ON>)>)

SETN55:	$STAB
	ORNKEY(<OFF>,OFF)
	ORNKEY(<ON>,ON)
	$ETAB

SETN60:	$NUMBER(CONFRM,^D10,<records per message for 2780>,<$ACTION(CHKVAL)>)

SETN80:	$KEY(CONFRM,SETN85)

SETN85:	$STAB
	ORNKEY(<PRIMARY>,PRI)
	ORNKEY(<SECONDARY>,SEC)
	$ETAB

SETN90:	$KEY(CONFRM,SETN55)
SETN95:	$NUMBER(CONFRM,^D10,<bytes per message size for the front end>)
>;END FTDN60
SUBTTL	SET SCHEDULER command tables (TOPS20)


TOPS20	<
SETSCH:	$KEYDSP(SETS10,<$DEFAULT(<BIAS-CONTROL>)>)

SETS10:	$STAB
	ORNDSP(SETS50,<BATCH-CLASS>,BAT)
	ORNDSP(SETS20,<BIAS-CONTROL>,BIA)
	ORNDSP(SETS40,<CLASS>,CLS)
	$ETAB
SETS20:	$NOISE(SETS30,<to>)

SETS30:	$NUMBER(CONFRM,^D10,<<decimal number, a small number to favor interactive processes, larger number for compute-bound>>,<$ACTION(CHKVAL)>)

SETS40:	$NOISE(SETS42,<number>)

SETS42:	$NUMBER(SETS44,^D10,<scheduler class number>,<$ACTION(CHKVAL)>)

SETS44:	$NOISE(SETS46,<to percent>)

SETS46:	$NUMBER(CONFRM,^D10,<percent for this scheduler class (0-99)>,<$ACTION(CHKPER)>)

SETS50:	$KEY(CONFRM,SETS52,<$ALTERNATE(SETS54)>)

SETS52:	$STAB
	ORNKEY(<BACKGROUND>,BCK)
	ORNKEY(<NONE>,NON)
	$ETAB

SETS54:	$NUMBER(CONFRM,^D10,<scheduler class for batch>,<$ACTION(CHKVAL)>)


CHKPER:	SKIPL	T1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	T1,^D100	;TOO LARGE
	SKIPA
	$RETT			;RETURN
	PUSHJ	P,P$FIXP##
	MOVEI	S2,[ASCIZ/scheduler percent out of range/]
	$RETF
>;END TOPS20
SUBTTL	ENABLE/DISABLE command tables


ENAFDB:	$KEYDSP	(ENA001,<$DEFAULT(OUTPUT-DISPLAY)>)

ENA001:	$STAB
TOPS20<	ORNDSP(ENA050,<AUTOMATIC-VOLUME-RECOGNITION>,AVR)>
TOPS20<	ORNDSP(ENACLS,<CLASS-SCHEDULER>,CLS)>
TOPS20<	ORNDSP(CONFRM,<FILE-RETRIEVAL-WAITS>,RET)>
TOPS10<	ORNDSP(ENAS00,<JOB-SCHEDULING>,JSC)>
	ORNDSP(CONFRM,<LOGGING>,LGG)
	ORNDSP(ENA100,<OUTPUT-DISPLAY>,OPD)
    	ORNDSP(ENA115,<QUEUES>,QUE)
TOPS10<	ORNDSP(CONFRM,<STRUCTURE-RECOGNITION>,ASR)>
TOPS10<	ORNDSP(CONFRM,<TIMESHARING>,TSR)>
TOPS10< ORNDSP(ENA050,<VOLUME-RECOGNITION>,AVR)>
	$ETAB

ENA050:	$NOISE(ENA065,<for>)

ENA065:	$KEY(CONFRM,ENA070,<$ALTERNATE(ENA075)>)

ENA070:	$STAB
TOPS10< ORNKEY(<DISK-DRIVES>,DSK)>
	ORNKEY(<TAPE-DRIVES>,TAP)
	$ETAB
TOPS20<
ENA075:	$DEV(CONFRM,<$HELP(tape drive name),$FLAGS(CM%NSF)>)
>;END TOPS20
TOPS10<
ENA075:	$DEV(CONFRM,<$HELP(<tape or disk drive name>),$FLAGS(CM%NSF)>)
>;END TOPS10

ENA100:	$NOISE	(ENA105,<of>)
ENA105:	IFLE NUMAPL,<$KEY(ENA160,ENA110)>
	IFG  NUMAPL,<$KEY(ENA160,ENA110,<$ALTERNATE(ENA140)>)>

ENA110:	$STAB
	ORNKEY	(<ALL-MESSAGES>,ALM)
	ORNKEY	(<BATCH-MESSAGES>,BAT)
	ORNKEY	(<CARD-PUNCH-MESSAGES>,CDP)
	ORNKEY	(<CARD-READER-INTERPRETER-MESSAGES>,BIN)
	ORNKEY	(<FAL-MESSAGES>,FAL)
	ORNKEY	(<MOUNT-MESSAGES>,MNT)
IFN FTDQS,<ORNKEY	(<NQC-MESSAGES>,NQC)>
	ORNKEY	(<PAPER-TAPE-PUNCH-MESSAGES>,PTP)
	ORNKEY	(<PLOTTER-MESSAGES>,PLT)
	ORNKEY	(<PRINTER-MESSAGES>,LPT)
	ORNKEY	(<READER-MESSAGES>,RDR)
	ORNKEY	(<USER-MESSAGES>,USR)
	$ETAB

ENA115:	$KEYDSP	(ENA120,<$DEFAULT(<ALL-INPUT-OUTPUT>)>)
ENA120:	$STAB
	ORNDSP(CONFRM,<ALL-INPUT-OUTPUT>,ALL)
 	ORNDSP(CONFRM,<BATCH>,BAT)
	ORNDSP(CONFRM,<CARD-PUNCH>,RDR)
	ORNDSP(CONFRM,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(CONFRM,<PLOTTER>,PLT)
	ORNDSP(CONFRM,<PRINTER>,LPT)
	$ETAB

IFG	NUMAPL,<
ENA140:	$KEY(CONFRM,ENA150)

	DEFINE	X(A,B,C,D),<ORNKEY(<A'-MESSAGES>,<B>)>

ENA150:	$STAB
	TABAPL
	$ETAB
>;END NUMAPL

ENA160:	$SWITCH(NEXT(ENA160),ENA170,<$ACTION(SHRSWT),$ALTERNATE(CONFRM)>)

ENA170:	$STAB
	ORNSWI(<INFORMATION-MESSAGES>,OTH)
	ORNSWI(<JOB-MESSAGES>,JOB)
	ORNSWI(<OPR-ACTION-MESSAGES>,OAM)
	$ETAB
SUBTTL	ENACLS	ENABLE CLASS SCHEDULER command tables

TOPS20 <

ENACLS:	$SWITCH(,ENAC10,<$ALTERNATE(CONFRM),$ACTION(SHRSWT),$PREFILL(ENAACT)>)

ENAC10:	$STAB
	ORNSDP(ENAC30,<CLASS-ASSIGNMENTS:>,CAS)
	ORNSDP(ENAC20,<WINDFALL:>,WFL)
	$ETAB

ENAC20:	$KEY(NEXT(ENAC10),ENAC25,<$DEFAULT(<ALLOCATED>)>)

ENAC25:	$STAB
	ORNKEY(<ALLOCATED>,ALO)
	ORNKEY(<WITHHELD>,WHD)
	$ETAB

ENAC30:	$KEY(NEXT(ENAC10),ENAC35,<$DEFAULT(<ACCOUNT>)>)

ENAC35:	$STAB
	ORNKEY(ACCOUNT,ACT)
	ORNKEY(<POLICY-PROGRAM>,PPR)
	$ETAB

ENAACT:	MOVE	S1,CMDCOD			;GET THE COMMAND CODE
	CAIE	S1,.KYDIS			;WAS IT DISABLE?
	$RETT					;NO..RETURN O.K.
	MOVEI	S1,CONFRM			;GET CONFRM ADDRESS
	AOS	S1				;BUMP TO NEXT PDB
	STORE	S1,CR.PDB(S2),RHMASK		;RESET NEXT PDB
	$RETT					;RETURN
>;END TOPS20
TOPS10 <
ENAS00:	$NOISE(ENAS10,<on>)

ENAS10:	$KEYDSP(ENAS20,<$ALTER(ENAS30)>)

ENAS20:	$STAB
	ORNDSP	(CONFRM,<ALL-CPUs>,ACP)
	ORNDSP	(ENAS30,<ONLY>,NLY)
	$ETAB

ENAS30:	$FIELD	(CONFRM,<cpu name>)
> ;END TOPS10
SUBTTL	CLOSE command tables
SUBTTL	DEFINE command tables


CLOFDB:	$KEYDSP	(CLO001,<$DEFAULT(<LOG>)>)
CLO001:	$STAB
	ORNDSP	(SET902,LOG,LOG)
	$ETAB
SUBTTL	REPORT command tables


RPTFDB:	$NOISE	(RPT005,<by>)

RPT005:	$FIELD (RPT015,<user name>)

RPT015:	$DEV	(RPT020,<$HELP(<device being reported>),$FLAGS(CM%PO!CM%NSF)>)

RPT020:	$CRLF	(<$ALTER(RPT025),$ACTION(TXTLIN##),$HELP(<confirm for multiple line response>)>)


RPT025:	$CTEXT	(CONFRM,<single line response>)
SUBTTL	MOUNT command tables (TOPS10)


TOPS10<

MTNFDB:	$KEY	(MTN020,MTN010,<$DEFAULT(<STRUCTURE>)>)
MTN010:	$STAB
	ORNKEY	(<STRUCTURE>,STR)
	$ETAB
MTN020:	$DEV	(MTN030,<$HELP(<structure name>),$FLAGS(CM%PO!CM%NSF)>)
MTN030:	$NOISE	(MTN040,<as>)
MTN040:	$DEV	(MTN050,<$HELP(<alias name>),$ALTERNATE(MTN050),$FLAGS(CM%NSF!CM%PO)>)
MTN050:	$SWITCH	(,MTN060,<$ALTERNATE(<CONFRM>),$ACTION(SHRSWT)>)
MTN060:	$STAB
	ORNSDP	(NEXT,<OVERRIDE-SET-NUMBER>,OSN)
	ORNSDP	(NEXT,<WRITE-LOCKED>,WLK)
	$ETAB

>;END TOPS10
	SUBTTL	NEXT - NEXT COMMAND

NXTFDB:	$NOISE	(NXT010,<job on>)		;[NXT]

NXT010:	$KEYDSP(NXT020)				;[NXT]

NXT020:	$STAB					;[NXT]
	ORNDSP(NXT040,BATCH-STREAM,BAT)		;[NXT]
	ORNDSP(NXT030,CARD-PUNCH,CDP)		;[NXT]
	ORNDSP(NXT030,PAPER-TAPE-PUNCH,PTP)	;[NXT]
	ORNDSP(NXT030,PLOTTER,PLT)		;[NXT]
	ORNDSP(NXT030,PRINTER,LPT)		;[NXT]
	$ETAB					;[NXT]

NXT030:	$NOISE	(NXT050,<unit number>)		;[NXT]
NXT040:	$NOISE	(NXT050,<stream number>)	;[NXT]

NXT050:	$NUMBER	(NXT080,^D10,<number (/NODE:)>,<$ACTION(STOBTH),>) ;[NXT]
NXT080:	$SWITCH (NXT090,NXT085,<$DEFAULT(<REQUEST-ID>),$ALTER(NXT100)>) ;[NXT]
NXT085:	$STAB					;[NXT]
	ORNSWI(NODE:,NOD)			;[NXT]
	$ETAB					;[NXT]
NXT090:	$NODNM	(NXT100,<node name>,<$FLAGS(CM%PO!CM%NSF)>) ;[NXT]

NXT100:	$KEYDSP	(NXT110,<$DEFAULT(<REQUEST-ID>)>) ;[NXT]

NXT110:	$STAB					;[NXT]
	ORNDSP(NXT120,<REQUEST-ID>,RQN)		;[NXT]
	$ETAB					;[NXT]

NXT120:	$NUMBER(CONFRM,^D10,<request number of the next job to schedule>,<$ACTION(CHKPOS)>) ;[NXT]

SUBTTL	IDENTIFY command tables

TOPS20 <
IDNFDB:	$NOISE(IDN010,<tape on drive>)>

TOPS10 <
IDNFDB:	$NOISE(IDN010,<device>)>

TOPS20 <
IDN010:	$DEV(IDN020,<$HELP(<tape drive name>),$FLAGS(CM%NSF)>)>

TOPS10 <
IDN010:	$DEV(IDN020,<$HELP(<device name>),$FLAGS(CM%NSF)>)>

IDN020:	$NOISE(IDN030,<with>)

IDN030:	$KEYDSP(IDN040,<$DEFAULT(<REQUEST-ID>)>)

IDN040:	$STAB
	ORNDSP(IDN050,<REQUEST-ID>,RQN)
TOPS20<	ORNDSP(CONFRM,<SCRATCH>,SCR) >	;ONLY VALID ON TOPS20
	ORNDSP(IDN060,<VOLUME-ID>,VID)
	$ETAB

IDN050:	$NUMBER(CONFRM,^D10,<request number of the mount request>,<$ACTION(CHKPOS)>)

IDN060:	$QUOTE(CONFRM,<volume-id in quotes if has non-alphanumeric characters>,<$ALTERNATE(IDN070)>)

IDN070:	$FIELD(CONFRM,<volume-id without quotes>)


SUBTTL	SWITCH	command tables (TOPS20)


TOPS20 <
SWIFDB:	$NOISE(SWI010,<request number>)

SWI010:	$NUMBER(SWI020,^D10,<request number of the mount request to switch>)

SWI020:	$NOISE(SWI030,<to new volume>)

SWI030:	$QUOTE(SWI050,<volume-id in quotes if has non-alphanumeric characters>,<$ALTERNATE(SWI040)>)

SWI040:	$FIELD(SWI050,<volume-id without quotes>)

SWI050:	$NOISE(SWI060,<on drive>)

SWI060:	$DEV(CONFRM,<$HELP(<tape drive to switch request to>),$ALTERNATE(CONFRM),$FLAGS(CM%NSF)>)

>;END TOPS20
SUBTTL	DISMOUNT command tables


DSMFDB:$KEYDSP(DSM010)

DSM010:	$STAB
	ORNDSP(DSM020,<STRUCTURE>,STR)
	ORNDSP(DSM030,<TAPE-DRIVE>,TAP)
	$ETAB

TOPS10 <

DSM020:	$DEV	(DSM040,<$HELP(<structure name to dismount>),$FLAGS(CM%NSF!CM%PO)>)

> ;End TOPS10

TOPS20 <

DSM020:	$DEV	(CONFRM,<$HELP(<structure name to dismount>),$FLAGS(CM%NSF)>)

> ;End TOPS20

DSM030:	$DEV	(CONFRM,<$HELP(<tape drive from which to dismount tape>),$FLAGS(CM%NSF)>)

TOPS10 <

DSM040:	$SWITCH(,DSM050,<$ACTION(SHRSWT),$ALTERNATE(CONFRM)>)

DSM050:	$STAB
	ORNSDP(NEXT(DSM040),<NOCHECK>,NCK)
	ORNSDP(NEXT(DSM040),<REMOVE>,REM)
	$ETAB

> ;End TOPS10

	comment \
	;removed on July 11,1979
SUBTTL	UNLOAD	command tables (removed)

UNLFDB:	$NOISE(UNL010,<tape drive>)

UNL010:	$DEV	(CONFRM,<$HELP(<tape drive to unload>),$FLAGS(CM%NSF)>)

;	UNDEFINED FOR NOW
	\;end of comment


SUBTTL	RECOGNIZE command tables


TOPS10 <
RECFDB:	$NOISE(REC010,<labels on>)

REC010:	$DEV (CONFRM,<$HELP(<tape or disk drive to recognize>),$FLAGS(CM%NSF!CM%PO)>)
>;END TOPS10

SUBTTL	PUSH command tables


PUSFDB::TOPS10	<$NOISE	(PUS100,<to monitor level>)>
	TOPS20	<$NOISE	(PUS100,<to EXEC level>)>

PUS100:	$CRLF	(<$ACTION(PUSHRT##)>)
SUBTTL	HELP command tables

	ND	CR.ADR,4		;Address of current argument

HLPFDB:: $NOISE	(HLPFD1,<with>)

HLPFD1:	$CTEXT(,<command>,<$ACTION(HLPACT),$DEFAULT(HELP)>)

HLPACT:	MOVE	T1,CR.ADR(S2)		;Get the data
	HRROI	T1,ARG.DA(T1)		;Point to the string
	$CALL	SETOUT##		;Setup proper $TEXT defaults
	MOVEI	S1,HLPFD		;Point to help file
	MOVE	S2,T1			;Point to string
	$CALL	P$HELP##
	$CALL	SNDOUT##		;Send the output
	$CALL	P$NPRO##		;Mark no processing
	$RETT				;Return

;File descriptor for help file for OPR

TOPS20	<
HLPFD:	XWD	HSIZ,0
	ASCIZ /HLP:OPR.HLP/
HSIZ==.-HLPFD
>

TOPS10	<
HLPFD:	$BUILD	FDMSIZ
	$SET(.FDLEN,FD.LEN,FDMSIZ)
	$SET(.FDSTR,,<SIXBIT/HLP/>)
	$SET(.FDNAM,,<SIXBIT/OPR/>)
	$SET(.FDEXT,,<SIXBIT/HLP/>)
	$EOB
>

SUBTTL	SHOW ALLOCATION command tables

TOPS10<
ALC000:	$KEYDSP	(ALC010)

ALC010:	$STAB
	ORNDSP	(CONFRM,<ALL-REQUESTS>,ALL)
	ORNDSP	(ALC020,<BATCH-REQUEST>,BRQ)
	ORNDSP	(ALC030,JOB,JOB)
	$ETAB

ALC020:	$NUMBER	(CONFRM,^D10,<request-id for batch job>,<$ALTERNATE(ALC040)>)

ALC030:	$NUMBER	(CONFRM,^D10,<job number>)

ALC040:	$CRLF	($HELP(<confirm for all batch requests>))
>;END TOPS10
	END
