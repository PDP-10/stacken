TITLE	GLXUTL  --  Utility routines that reside in GLXLIB.REL
SUBTTL	D. Mastrovito /DPM	4-Dec-85
;
;
;        		  COPYRIGHT (c) 1986
;                    DIGITAL EQUIPMENT CORPORATION
;			 ALL RIGHTS RESERVED.
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.


	SEARCH	GLXMAC		;PARAMETER FILE
	PROLOG	(GLXUTL,UTL)	;GENERATE PROLOG CODE

	UTLEDT==2		;MODULE EDIT LEVEL

IFN GLXPUR,<			;ONLY ASSEMBLE FOR GLXLIB.REL
	.POPJ==0
	.RETF==0
	.RETT==0
	PASS2
	END
>
SUBTTL	Revision history


COMMENT	|

Edit	GCO
----	---
0001	10335	Creation.
		4-Dec-85  /DPM

0002	10335	Add .HELPF help file processor.
		 4-Dec-85  /DPM


| ;END REVISION HISTORY

	PRGEND
TITLE	.HELPF	- HELP FILE PROCESSOR

	SEARCH	GLXMAC
	PROLOG	(.HELPF)

	TWOSEG
	RELOC	400000

	ENTRY	.HELPF		;LOAD IF LIBRARY SEARCH

	BUFSIZ==20		;LINE BUFFER SIZE
	BUFCNT==<BUFSIZ/5>-1	;LINE BUFFER BYTE COUNT


; GALAXY HELP FILE PROCESSOR
; CALL:	MOVE	S1, FD ADDRESS
;	MOVE	S2, OPTIONAL SEARCH STRING ADDRESS
;	$CALL	.HELPF
;
; TRUE RETURN:	DESIRED HELP TEXT DISPLAYED
; FALSE RETURN: POINTER TO ERROR TEXT IN S1

.HELPF::PUSHJ	P,.SAVE4		;SAVE P1 - P4
	MOVE	P1,[FOB,,FOB+1]		;SET UP BLT
	SETZM	FOB			;CLEAR FIRST WORD
	BLT	P1,FOB+FOB.SZ-1		;CLEAR OUT ENTIRE FOB
	MOVEM	S1,FOB+FOB.FD		;STUFF FD ADDRESS IN FOB
	MOVEM	S2,TARGET		;SAVE TARGET SEARCH STRING ADDRESS
	MOVX	S1,<FB.LSN!<INSVL.(7,FB.BSZ)>>
	MOVEM	S1,FOB+FOB.CW		;SAVE FLAGS AND BYTE SIZE
	MOVEI	S1,FOB.SZ		;FOB SIZE
	MOVEI	S2,FOB			;FOB ADDR
	PUSHJ	P,F%IOPN##		;OPEN FOR INPUT
	$RETIF				;RETURN ON ERRORS
	MOVEM	S1,IFN			;SAVE THE IFN
	SETZM	IOERR			;CLEAR STALE I/O ERROR FLAG
	SETOM	SAVCHR			;INIT SAVED CHARACTER FLAG
	SETZM	DISFLG			;INIT DISPLAY FLAG
	SKIPN	TARGET			;HAVE A TARGET SEARCH STRING?
	AOSA	DISFLG			;NO--DISPLAY WHOLE FILE
	JRST	HELP.2			;MUST SEARCH FOR A STRING

HELP.1:	PUSHJ	P,HLPLIN		;COPY LINE TO TTY
	JUMPF	HELP.4			;GIVE UP ON ERRORS
	JRST	HELP.1			;DISPLAY WHOLE FILE

HELP.2:	PUSHJ	P,HLPSTR		;CHECK FOR A MATCH
	JUMPF	HELP.4			;GIVE UP ON ERRORS
	JUMPL	S1,HELP.3		;GO OUTPUT SUBJECT TEXT
	PUSHJ	P,HLPLIN		;FLUSH LINE
	JUMPF	HELP.4			;CHECK FOR EOL
	JRST	HELP.2			;LOOP BACK AND SEARCH AGAIN

HELP.3:	AOS	DISFLG			;TURN ON DISPLAY
	PUSHJ	P,HLPLIN		;COPY LINE TO TTY
	JUMPF	HELP.4			;GIVE UP ON ERRORS
	PUSHJ	P,HLPSTR		;CHECK FOR START OF A NEW SUBJECT LINE
	JUMPF	HELP.4			;STOP ON ERRORS
	JUMPE	S1,HELP.3		;DISPLAY LINE
	MOVEI	S1,EREOF$		;FAKE EOF

HELP.4:	PUSH	P,S1			;SAVE ERROR CODE
	SKIPLE	S1,IFN			;GET IFN
	PUSHJ	P,F%REL##		;RELEASE IT
	POP	P,S1			;GET ERROR CODE BACK
	CAIN	S1,EREOF$		;EOF?
	$RETT				;RETURN GOODNESS
	SKIPE	IOERR			;I/O ERROR OCCUR?
	MOVEI	S1,ERNHA$		;NO--SAY NO HELP AVAILABLE
	$RETF				;NO--RETURN ERROR
; CHECK FOR TARGET STRING
HLPSTR:	PUSHJ	P,HLPCHR		;GET A CHARACTER IN S2
	$RETIF				;RETURN ON ERRORS
	MOVEI	S1,0			;ASSUME RANDOM LINE
	MOVEM	S2,SAVCHR		;SAVE
	CAIE	S2,"*"			;MAGIC FIRST CHARACTER?
	$RETT				;NO--LEAVE THINGS ALONE
	SETOM	SAVCHR			;SAVED CHARACTER IS NOW INVALID
	MOVE	S1,TARGET		;GET TARGET STRING ADDRESS
	HRLI	S1,(POINT 7,)		;MAKE A BYTE POINTER
	MOVEM	S1,BYTPTR		;SAVE

HLPS.1:	PUSHJ	P,HLPCHR		;GET A CHARACTER IN S2
	$RETIF				;RETURN ON ERRORS
	ILDB	S1,BYTPTR		;GET A CHARACTER FROM TARGET STRING
	JUMPE	S1,HLPS.2		;DONE?
	CAIL	S1,"A"+40		;RANGE
	CAILE	S1,"Z"+40		; CHECK
	CAIA				;NO CONVERSION NEEDED
	SUBI	S1,40			;CONVERT TO UPPER CASE
	CAIL	S2,"A"+40		;RANGE
	CAILE	S2,"Z"+40		; CHECK
	CAIA				;NO CONVERSION NEEDED
	SUBI	S2,40			;CONVERT TO UPPER CASE
	CAIN	S1,(S2)			;MATCH?
	JRST	HLPS.1			;YES
	MOVEI	S1,1			;NO MATCH, START OF A NEW SUBJECT LINE
	$RETT				;GIVE UP ON THIS LINE

HLPS.2:	CAIN	S2,.CHCRT		;CARRIAGE RETURN?
	PUSHJ	P,HLPCHR		;EAT IT
	$RETIF				;CHECK FOR ERRORS
	CAIE	S2,.CHLFD		;EOL?
	SKIPA	S1,[EXP 1]		;START OF A NEW SUBJECT LINE
	MOVNI	S1,1			;FILE STRING MATCHES TARGET
	$RETT				;NO MATCH
; COPY A LINE FROM THE FILE TO THE TERMINAL
HLPLIN:	PUSHJ	P,HLPSET		;SET UP INITIAL BUFFER POINTERS
	MOVNI	S2,1			;INVALID FLAG
	EXCH	S2,SAVCHR		;GET SAVED CHARACTER (IF ANY)
	JUMPG	S2,HLPL.2		;GO DISPLAY

HLPL.1:	PUSHJ	P,HLPCHR		;GET A CHARACTER IN S2
	$RETIF				;RETURN ON ERRORS

HLPL.2:	SOSG	BYTCNT			;COUNT CHARACTERS
	PUSHJ	P,HLPTTY		;DUMP LINE BUFFER TO TTY
	IDPB	S2,BYTPTR		;STUFF CHARACTER AWAY
	CAIE	S2,.CHLFD		;EOL?
	JRST	HLPL.1			;NO--LOOP BACK

HLPTTY:	SKIPG	DISFLG			;DISPLAY?
	JRST	HLPSET			;NO
	PUSH	P,S2			;SAVE FROM DESTRUCTION
	HRROI	S1,BUFFER		;POINT TO LINE BUFFER
	PUSHJ	P,K%SOUT##		;OUTPUT TO TTY
	POP	P,S2			;GET CHARACTER BACK

HLPSET:	MOVE	S1,[BUFFER,,BUFFER+1]	;SET UP BLT
	SETZM	BUFFER			;CLEAR FIRST WORD
	BLT	S1,BUFFER+BUFSIZ-1	;CLEAR OUT ENTIRE BUFFER
	MOVE	S1,[POINT 7,BUFFER]	;BYTE POINTER
	MOVEM	S1,BYTPTR		;SAVE
	MOVEI	S1,^D80			;BYTE COUNT
	MOVEM	S1,BYTCNT		;SAVE
	POPJ	P,			;RETURN


; READ A SINGLE CHARACTER
HLPCHR:	MOVE	S1,IFN			;GET IFN
	PUSHJ	P,F%IBYT##		;AND A CHARACTER
	$RETIT				;RETURN IF NO ERRORS
	CAIE	S1,EREOF$		;EOF?
	SETOM	IOERR			;NO--FLAG AN I/O ERROR
	$RETF				;RETURN
	LIT

	RELOC	0

FOB:	BLOCK	FOB.SZ			;FOB FOR INPUT
IFN:	BLOCK	1			;IFN FOR INPUT
DISFLG:	BLOCK	1			;DISPLAY FLAG
					;-1 IF EOF, 0 IF NO, 1 IF YES
TARGET:	BLOCK	1			;TARGET SEARCH STRING
BUFFER:	BLOCK	BUFSIZ			;LINE BUFFER
BYTPTR:	BLOCK	1			;BYTE POINTER
BYTCNT:	BLOCK	1			;CHARACTER COUNT
SAVCHR:	BLOCK	1			;SAVED FIRST CHARACTER OF LINE
IOERR:	BLOCK	1			;NON-ZERO IF AN I/O ERROR OCCURED


	END
