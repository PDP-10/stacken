TITLE	NEBANF - ANF-10 I/O driver for the Network Queue Controller
SUBTTL	D. P. Mastrovito & Joseph A. Dziedzic /DPM/JAD


;
;
;	      COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
;                               1986.
;			ALL RIGHTS RESERVED.
;
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.

	SEARCH	NEBPRM
	MODULE	(NEBANF)

	IOVEC	(ANF,<ANF-10>)
SUBTTL	ANF-10 I/O driver -- Definitions and parameters


	ANFLVL==0		;INTERRUPT PRIORITY LEVEL
	NPDLEN==10		;LENGTH OF AN NPD
SUBTTL	ANF-10 I/O driver -- ANFINI - Initialization


ANFINI:	JRST	.POPJ1		;RETURN
SUBTTL	ANF-10 I/O driver -- ANFINF - Return information about a node


ANFINF:	MOVEI	S2,2		;TWO WORD ARGUMENT BLOCK
	EXCH	S1,S2		;SWAP
	MOVE	TF,[.NDRNN,,S1]	;SET UP UUO AC
	NODE.	TF,		;SEE IF NODE IS ONLINE
	  POPJ	P,		;NON-EXISTANT OR OFFLINE
	JRST	.POPJ1		;RETURN
SUBTTL	ANF-10 I/O driver -- ANFOPN - Open connection


ANFOPN:	MOVE	S1,[FO.ASC+.FOSIO] ;ASSIGN CHANNEL, OPEN FOR I/O
	MOVEM	S1,.JNARG+.FOFNC(R)
	MOVE	S1,[UU.PHS!UU.AIO+.IOBYT] ;PHYSICAL, ASYNCH + BYTE MODE
	MOVEM	S1,.JNARG+.FOIOS(R)
	MOVSI	S1,'TSK'	;DEVICE NAME
	MOVEM	S1,.JNARG+.FODEV(R)
	MOVSI	S1,.JIOBR(R)	;RING HEADER FOR OUTPUT
	HRRI	S1,.JIIBR(R)	;RING HEADER FOR INPUT
	MOVEM	S1,.JNARG+.FOBRH(R)
	SETZM	.JNARG+.FONBF(R) ;WILL BUILD OUR OWN BUFFERS
	MOVSI	S1,.FONBF+1	;WORD COUNT
	HRRI	S1,.JNARG(R)	;ARG BLOCK
	FILOP.	S1,		;OPEN DEVICE
	  HALT	.
	LDB	S1,[POINTR (.JNARG+.FOFNC(R),FO.CHN)] ;GET CHANNEL NUMBER
	MOVEM	S1,.JNIOC(R)	;SAVE
	MOVEM	S1,.JNARG+.PSECN(R) ;SAVE AS PSI CONDITION
	PUSHJ	P,PSIAVJ##	;ALLOCATE PSI VECTOR
	  JSP	S2,VECERR	;NONE AVAILABLE
	MOVEM	S1,.JBPSI(R)	;SAVE ADDRESS
	PUSH	P,S2		;SAVE OFFSET
	MOVEI	S2,ANFINT	;INTERRUPTS WILL GO HERE
	HRRM	S2,.JBPSR+2(R)
	MOVEM	S2,.PSVNP(S1)	;POINT MONITOR IN RIGHT DIRECTION
	POP	P,S2		;RESTORE OFFSET
	HRRI	S2,PS.RID!PS.ROD!PS.RIE!PS.ROE!PS.ROL ;LOTS OF GOOD BITS
	MOVEM	S2,.JNARG+.PSEOR(R) ;SAVE OFFSET,,REASON BITS
	MOVSI	S1,ANFLVL	;INTERRUPT PRIORITY LEVEL
	MOVEM	S1,.JNARG+.PSEPR(R) ;SAVE
	MOVX	S1,PS.FAC	;BIT TO ADD CONDITION
	HRRI	S1,.JNARG(R)	;ADDRESS OF ARGUMENT BLOCK
	PISYS.	S1,		;PUT CHANNEL ON PSI SYSTEM
	  JSP	S2,ANFOPE	;FAILED
	MOVEI	S1,ANFOPA	;ASSUME ACTIVE TASK
	MOVE	S2,.JBNOD(R)	;GET NODE NAME/NUMBER
	CAMN	S2,[SIXBIT/*/]	;PASSIVE CONNECT?
	MOVEI	S1,ANFOPP	;YES
	PUSHJ	P,(S1)		;DO SPECIFIC SETUP
	MOVEI	S1,.TKFEA	;FUNCTION CODE
	MOVEM	S1,.JNARG+.TKAFN(R)
	MOVE	S1,.JNIOC(R)	;I/O CHANNEL
	MOVEM	S1,.JNARG+.TKACH(R)
	MOVE	S1,[NPDLEN,,NPDLCL] ;LOCAL NPD
	MOVEM	S1,.JNARG+.TKAA1(R)
	MOVE	S1,[NPDLEN,,NPDRMT] ;REMOTE NPD
	MOVEM	S1,.JNARG+.TKAA2(R)
	MOVSI	S1,4		;ARGUMENT BLOCK LENGTH
	HRRI	S1,.JNARG(R)	;ARGUMENT BLOCK ADDRESS
	TSK.	S1,		;SEND/WAIT FOR CONNECT INITIATE
	  JSP	S2,.+2		;FAILED
	JRST	.POPJ1		;RETURN
	PUSHJ	P,TSKERR	;REPORT ERROR
	PJRST	ANFZAP		;CLEAN UP AND RETURN
;SETUP ACTIVE TASK
ANFOPA:	MOVEI	S1,NPDLCL	;SELECT LOCAL NPD
	PUSHJ	P,NPDINI	;INIT STORAGE
	$TEXT	(NPDBYT,<^W/G$PGM/-^D/.JQOBJ+OBJ.UN(R)/^A>)
	MOVEI	S1,NPDRMT	;SELECT REMOTE NPD
	PUSHJ	P,NPDINI	;INIT STORAGE
	$TEXT	(NPDBYT,<^T/G$NAM/^A>)
	MOVE	S1,.JBNOD(R)	;REMOTE NODE NAME/NUMBER
	MOVEM	S1,NPDRMT+.TKNND
	POPJ	P,		;RETURN


;SETUP PASSIVE TASK
ANFOPP:	MOVEI	NPDLCL		;SELECT LOCAL NPD
	PUSHJ	P,NPDINI	;INIT STORAGE
	SETZM	NPDLCL+.TKNND	;IGNORE LOCAL NPD
	MOVEI	S1,NPDRMT	;SELECT REMOTE NPD
	PUSHJ	P,NPDINI	;INIT STORAGE
	$TEXT	(NPDBYT,<^T/G$NAM/^A>)
	POPJ	P,		;RETURN


ANFOPE:	PUSHJ	P,UUOERR##	;REPORT UUO ERROR
ANFZAP:	MOVE	S1,.JNIOC(R)	;CHANNEL NUMBER
	RESDV.	S1,		;RESET IT (REALLY SAME AS RELEASE)
	  JFCL			;IGNORE ERRORS
	SETZB	S1,.JNIOC(R)	;ZERO OUT CHANNEL
	EXCH	S1,.JBPSI(R)	;FETCH AND CLEAR OUT PSI VECTOR ADDRESS
	SKIPN	S1		;HAVE A VECTOR?
	SETZM	(S1)		;RECYCLE
	POPJ	P,		;RETURN
SUBTTL	ANF-10 I/O driver -- ANFCLS - Close connection


ANFCLS:	HALT	.
SUBTTL	ANF-10 I/O driver -- ANFINP - Input a buffer


ANFINP:	MOVEI	S1,.TKFIN	;FUNCTION CODE
	MOVEM	S1,.JNARG+.TKAFN(R)
	MOVE	S1,.JNIOC(R)	;CHANNEL NUMBER
	MOVEM	S1,.JNARG+.TKACH(R)
	SETZM	.JNARG+.TKAA1(R) ;INCASE OF ERROR RETURN
	MOVSI	S1,3		;WORD COUNT
	HRRI	S1,.JNARG(R)	;ARG BLOCK
	SETZ	S2,		;ASSUME NO ERRORS WILL HAPPEN
	SCDSET	(.WSINP,0)	;SET SCHEDULER PARAMETERS
	TSK.	S1,		;INPUT DATA
	  MOVEI	S2,.+1		;SETUP FOR ERROR REPORTING
	PUSHJ	P,RDSTAT	;READ STATUS
	JUMPE	S2,ANFIN2	;CHECK FOR ERRORS
	CAIN	S1,TKUDW%	;I/O ERROR?
	JRST	ANFIN1		;YES
	PUSHJ	P,TSKERR	;REPORT UUO ERROR
	PJRST	ANFABO		;GO ABORT THE LINK

ANFIN1:	MOVE	S1,.JNIOS(R)	;GET I/O STATUS
	TRNE	S1,IO.EOF	;UNEXPECTED EOF?
	HALT	.
	TRNE	S1,IO.ERR	;ANY ERROR BITS ON?
	JRST	ANFIN3		;YES
	PUSHJ	P,WSCHED##	;WAIT FOR OUTPUT TO COMPLETE

ANFIN2:	AOS	(P)		;SET FOR SKIP RETURN
	PJRST	INIOBF##	;RE-INITIALIZE OUTPUT BUFFER

ANFIN3:	SCDSET	(.WSRUN,0)	;UNDO THE DAMAGE
	TRC	S1,IO.ERR	;REAL I/O ERROR
	TRCN	S1,IO.ERR	;ALL ERROR BITS LIT?
	PJRST	ANFABO		;YES--GO ABORT THE LINK
	MOVEI	S1,IO.ERR	;MASK OF ALL ERROR BITS
	ANDCAM	S1,.JNIOS(R)	;CLEAR THEM
	PUSHJ	P,WTSTAT	;WRITE NEW CHANNEL STATUS
	JRST	ANFINP		;GO RETRY THE INPUT
SUBTTL	ANF-10 I/O driver -- ANFOUT - Output a buffer


ANFOUT:	MOVEI	S1,.TKFOT	;FUNCTION CODE
	MOVEM	S1,.JNARG+.TKAFN(R)
	MOVE	S1,.JNIOC(R)	;CHANNEL NUMBER
	MOVEM	S1,.JNARG+.TKACH(R)
	SETZM	.JNARG+.TKAA1(R) ;INCASE OF ERROR RETURN
	MOVSI	S1,3		;WORD COUNT
	HRRI	S1,.JNARG(R)	;ARG BLOCK
	SETZ	S2,		;ASSUME NO ERRORS WILL HAPPEN
	SCDSET	(.WSOUT,0)	;SET SCHEDULER PARAMETERS
	TSK.	S1,		;OUTPUT DATA
	  MOVEI	S2,.+1		;SETUP FOR ERROR REPORTING
	PUSHJ	P,RDSTAT	;READ STATUS
	JUMPE	S2,ANFOU2	;CHECK FOR ERRORS
	CAIN	S1,TKUDW%	;I/O ERROR?
	JRST	ANFOU1		;YES
	PUSHJ	P,TSKERR	;REPORT UUO ERROR
	PJRST	ANFABO		;GO ABORT THE LINK

ANFOU1:	MOVE	S1,.JNIOS(R)	;GET I/O STATUS
	TRNN	S1,IO.EOF	;OUTPUT BUFFERS FULL?
	JRST	ANFOU3		;NO
	PUSHJ	P,WSCHED##	;WAIT FOR OUTPUT TO COMPLETE

ANFOU2:	AOS	(P)		;SET FOR SKIP RETURN
	PJRST	INIOBF##	;RE-INITIALIZE OUTPUT BUFFER

ANFOU3:	SCDSET	(.WSRUN,0)	;UNDO THE DAMAGE
	TRC	S1,IO.ERR	;REAL I/O ERROR
	TRCN	S1,IO.ERR	;ALL ERROR BITS LIT?
	PJRST	ANFABO		;YES--GO ABORT THE LINK
	MOVEI	S1,IO.ERR	;MASK OF ALL ERROR BITS
	ANDCAM	S1,.JNIOS(R)	;CLEAR THEM
	PUSHJ	P,WTSTAT	;WRITE NEW CHANNEL STATUS
	JRST	ANFOUT		;GO RETRY THE OUTPUT
SUBTTL	ANF-10 I/O driver -- Abort a link


ANFABO:	PUSHJ	P,RDSTAT	;READ LINK STATUS
	HLRZS	S1		;WAIT ONLY LINK STATUS
	CAIN	S1,.TKSID	;IDLE?
	POPJ	P,		;DONE
	CAIE	S1,.TKSCC	;WAITING FOR CONNECT CONFIRM?
	CAIN	S1,.TKSDC	;WAITING FOR DISCONNECT CONFIRM?
	HALT	.
	CAIE	S1,.TKSCI	;WAITING FOR CONNECT INITIATE?
	CAIN	S1,.TKSOK	;LINK RUNNING?
	SKIPA
	HALT	.
	MOVEI	S1,.TKFEI	;FUNCTION CODE
	MOVEM	S1,.JNARG+.TKAFN(R)
	MOVE	S1,.JNIOC(R)	;CHANNEL NUMBER
	MOVEM	S1,.JNARG+.TKACH(R)
	MOVSI	S1,2		;WORD COUNT
	HRRI	S1,.JNARG(R)	;ARG BLOCK
	TSK.	S1,		;FORCE LINK INTO IDLE STATE
	  JSP	S2,TSKERR	;FAILED
	POPJ	P,		;RETURN
SUBTTL	ANF-10 I/O driver -- ANFSIA - Skip if input data available


ANFSIA:	HALT	.		;NOT YET
SUBTTL	ANF-10 I/O driver -- ANFUUE - UUO error translation table


ANFUUE:	UUO	(<TSK.>,TSKL,TSKT)
	EXP	0		;TERMINATE TABLE


TSKT:	TKTNL%,,[ASCIZ /task to task not supported/]
	TKATS%,,[ASCIZ /Argument list too short/]
	TKUNP%,,[ASCIZ /User is not privileged/]
	TKILF%,,[ASCIZ /Illegal function/]
	TKILC%,,[ASCIZ /Illegal channel/]
	TKILN%,,[ASCIZ /Illegal NPD/]
	TKNTS%,,[ASCIZ /NPD too short/]
	TKILS%,,[ASCIZ /Function is illegal in this state/]
	TKNFC%,,[ASCIZ /Not enough monitor free-core/]
	TKNFL%,,[ASCIZ /No free links/]
	TKNXN%,,[ASCIZ / non-existant node/]
	TKUDW%,,[ASCIZ /IN or OUT UUO (.TKFOT OR .TKFIN) didn't skip/]
TSKL==.-TSKT
SUBTTL	Subroutines -- ANF-10 software interrupt


ANFINT:	MOVE	P1,.JBPSI(R)	;POINT TO VECTOR
	MOVE	S1,.PSVIS(P1)	;GET INTERRUPT STATUS WORD
	HRRM	S1,.JNIOS(R)	;SAVE FOR POSTERITY
	PUSHJ	P,RDLINK	;READ LINK STATUS
	MOVE	S1,.JNIOS(R)	;GET STATUS
	MOVE	S2,.JBWSC(R)	;GET STREAM WAIT STATE CODE
	PUSHJ	P,@WSCHK(S2)	;DO SOMETHING
	MOVEM	S2,.JBWSC(R)	;UPDATE WAIT STATE
	$DEBRK			;DISMISS INTERRUPT


DEFINE	X	(NAM,TXT),<IFIW	NAM'CHK>
WSCHK:	WSTATE
;WAITING FOR CONNECT CONFIRM
WCCCHK:	PUSHJ	P,RUNCHK	;CHECK FOR LINK GOING DOWN
	CAIN	S1,.TKSOK	;LINK CONNECTED?
	PJRST	RUNJOB		;MAKE RUNNABLE
	POPJ	P,		;RETURN

;WAITING FOR REMOTE CONNECT
WRCCHK:	PUSHJ	P,RUNCHK	;CHECK FOR LINK GOING DOWN
	CAIN	S1,.TKSOK	;LINK CONNECTED?
	PJRST	RUNJOB		;MAKE RUNNABLE
	POPJ	P,		;RETURN

;WAITING FOR DISCONNECT CONFIRM
WDCCHK:	CAIN	S1,.TKSID	;IDLE?
	PJRST	RUNJOB		;MAKE RUNNABLE
	POPJ	P,		;RETURN

;WAITING FOR OUTPUT DONE
OUTCHK:	TRNN	S1,PS.ROD	;OUTPUT DONE?

;WAITING FOR INPUT DONE
INPCHK:	TRNE	S1,PS.RID	;INPUT DONE?
	MOVEI	S2,.WSRUN	;MAKE RUNNABLE

;STREAM RUNNING
RUNCHK:	HLRZ	S1,.JNIOS(R)	;GET LINK STATUS
	CAIN	S1,.TKSID	;LINK IDLE?
	PJRST	RUNABO		;NO, ERROR
	POPJ	P,		;NO PROBLEMS

;STREAM IDLE
IDLCHK:				;FALL INTO RUNABO

RUNABO:	PUSHJ	P,ABORTJ##	;QUEUE UP ABORT
RUNJOB:	MOVEI	S2,.WSRUN	;MAKE RUNNABLE
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- RDSTAT - Read link status


RDSTAT:	PUSH	P,S1		;SAVE S1
	PUSH	P,S2		;SAVE S2
	MOVE	S1,[1,,S2]	;SET UP UUO AC
	HRLZ	S2,.JNIOC(R)	;CHANNEL NUMBER
	HRRI	S2,.FOGET	;FUNCTION CODE
	FILOP.	S1,		;READ CHANNEL STATUS
	  HALT	.
	HRRM	S1,.JNIOS(R)	;SAVE
	PUSHJ	P,RDLINK	;READ LINK STATUS
	POP	P,S2		;RESTORE S2
	POP	P,S1		;RESTORE S1
	POPJ	P,		;RETURN


RDLINK:	MOVEI	S1,.TKFRS	;FUNCTION CODE
	MOVEM	S1,.JNARG+.TKAFN(R)
	MOVE	S1,.JNIOC(R)	;CHANNEL NUMBER
	MOVEM	S1,.JNARG+.TKACH(R)
	SETOM	.JNARG+.TKAA1(R) ;NO MEANINGFUL DATA YET
	MOVSI	S1,3		;WORD COUNT
	HRRI	S1,.JNARG(R)	;ARG BLOCK
	MOVEI	S2,.+2		;INCASE OF ERROR
	TSK.	S1,		;READ LINK STATUS
	  PUSHJ	P,TSKERR	;REPORT ERROR
	MOVE	S1,.JNARG+.TKAA1(R) ;GET LINK STATUS
	HRLM	S1,.JNIOS(R)	;SAVE
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- WTSTAT - Write channel status


WTSTAT:	PUSH	P,S1		;SAVE S1
	HRLZ	S1,.JNIOC(R)	;CHANNEL NUMBER
	HRRI	S1,.FOSET	;FUNCTION CODE
	MOVEM	S1,.JNARG+.FOFNC(R)
	MOVEI	S1,IO.ERR	;MASK OF ALL ERROR BITS
	ANDCAM	S1,.JNIOS(R)	;CLEAR ERRORS, FETCH ALL BITS
	HRRZM	S1,.JNARG+.FOIOS(R)
	MOVSI	S1,2		;WORD COUNT
	HRRI	S1,.JNARG(R)	;ARG BLOCK
	FILOP.	S1,		;SET CHANNEL STATUS
	  HALT	.
	POP	P,S1		;RESTORE S1
	POPJ	P,		;RETURN
SUBTTL	ANF-10 I/O driver -- Error processing


VECERR:	SUBI	S2,2		;POINT TO ACTUAL UUO
	HRRZS	S2		;STRIP OFF PC FLAGS
	PUSHJ	P,JOBIDN##	;GENERATE IDENTIFYING TEXT
	MOVE	S1,.JNIOC(R)	;GET CHANNEL NUMBER
	$WTO	(<^T/G$NAM/ error>,<^T/.JBIDN(R)/^I/VECETX/>,.JQOBJ(R))
	PJRST	ANFZAP		;GO CLEANUP

VECETX:	ITEXT	(<No free PSI vectors for channel ^O/S1/ at PC ^O6R0/S2/>)


;TSK. UUO ERROS
TSKERR:	PUSHJ	P,UUOERR##	;GENERATE UUO ERROR TEXT
	MOVE	S2,.JNARG+.TKAFN(R) ;GET FUNCTION WORD
	$WTO	(<^T/G$NAM/ error>,<^T/.JBIDN(R)/^T/(S1)/^I/TSKETX/>,.JQOBJ(R))
	POPJ	P,		;RETURN

TSKETX:	ITEXT	(<UUO function word: ^O6R0/S2,LHMASK/,,^O6R0/S2,RHMASK/>)
NPDINI:	MOVSI	S2,0(S1)	;START ADDRESS
	HRRI	S2,1(S1)	;MAKE A BLT POINTER
	SETZM	(S1)		;CLEAR FIRST WORD
	BLT	S2,NPDLEN-1(S1)	;CLEAR ENTIRE NPD
	SETOM	.TKNND(S1)	;SET TO -1 SO CAN CONNECT TO ANY NODE
	MOVEI	S2,.TKNLN(S1)	;OFFSET OF BYTE COUNT
	MOVEM	S2,NPDCTR	;SAVE
	ADDI	S1,.TKNPN	;OFFSET TO START OF PROCESS NAME
	HRLI	S1,(POINT 7,)	;7-BIT BYTES
	MOVEM	S1,NPDPTR	;SAVE
	POPJ	P,		;RETURN


NPDBYT:	IDPB	S1,NPDPTR	;STORE THE BYTE
	AOS	@NPDCTR		;COUNT THE BYTE
	$RETT			;RETURN
NPDPTR:	BLOCK	1		;BYTE POINTER TO PROCESS NAME STORAGE
NPDCTR:	BLOCK	1		;ADDR OF BYTE COUNT
NPDLCL:	BLOCK	NPDLEN		;LOCAL NPD
NPDRMT:	BLOCK	NPDLEN		;REMOTE NPD

	END
