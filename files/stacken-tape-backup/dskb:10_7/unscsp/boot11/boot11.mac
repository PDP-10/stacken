TITLE	BOOT11 TO BOOTSTRAP/DUMP PDP-11 CONNECTED VIA DL10  %4A(46)
SUBTTL	S.POLEVITSKY/PFC/TWE/DAL/EAR/AMW	27 JUL 79

;COPYRIGHT (C) 1972,1979 BY
;DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

.EDTR==0	;DEC DEVELOPMENT
.MAJV==4	;MAJOR VERSION
.MINV==1	;MINOR VERSION
.EDIT==46	;EDIT NUMBER

%%BT11==.EDTR*1B2+.MAJV*1B11+.MINV*1B17+.EDIT

	SEARCH	UUOSYM
	.REQUIRE REL:HELPER

;PROGRAM WHICH BOOTSTRAPS AND DUMPS PDP-11S CONNECTED VIA DL10.
;WHEN RUN, BOOT11 TYPES "FILE: " AND WAITS FOR A FILE SPEC AND
;ONE OR TWO SWITCHES.  /DUMP:M AND /END:N ASK FOR DUMP OF PDP-11
;ACS AND LOC. FROM M-N.
;/LOAD:N AND /START:N SPECIFY BOOTSTRAP FROM FILE AND SET START ADDRESS
;AT N.  IF N IS ODD, OR IF /LOAD, THEN THE 11 WILL HALT BEFORE STARTING.
;/CLEAR:N SPECIFIES TO CLEAR -11 CORE FROM 0 TO N-1.
;IF ALONE, PROGRAM WILL RESTART; IF WITH /L OR /S, WILL THEN LOAD.
;/IMAGE CAUSES LOAD TO READ IMAGE RATHER THAN PACKED FORMAT.
;/PORTNO:P HANDLES PORT NUMBER P (0-3 ARE -11S ON DL-10#0, 4-7 ON #1)

;LOAD INSTRUCTIONS:
;	.LOAD %H BOOT11.MAC, HELPER.REL[10,7]

IFNDEF V.CLR,<V.CLR==100000>	;END OF CLEAR AREA+1
IFNDEF V.DUMP,<V.DUMP==0>	;START OF DUMP
IFNDEF V.END,<V.END==100000>	;END OF DUMP+1
	SUBTTL	REVISION HISTORY

;%2(17)	DELIVERED WITH FIRST DC75 SOFTWARE

;THE FOLLOWING IMPROVEMENTS WERE THEN MADE:
;	HANDLE -11 NXM (BUS TRAP)
;	HANDLE ALL FORMS OF BINARY FORMAT (ABS)
;	HANDLE SFD
;	SUPPRESS 0 LINES FROM DUMP
;	CLEAN UP SOURCE FORMAT
;	RELOCATE THE -11 COMMUNICATIONS AREA TO RELAX THE LOAD
;		TIME REQUIREMENTS
;	PRESERVE THE DL-10 PI-CHANNEL ASSIGNMENT
;	CONVERT MESSAGES TO LOWER CASE
;	CHECK FOR JUNK IN INPUT FORMAT
;	MAKE SIZE OF WINDOW BETWEEN -10 AND -11 BE AUTOMATIC
;	ADD BOOT'S VERSION TO DUMP HEADER LINE
;	ADD /PORTNO:P AND MAKE PORT NUMBER AN OPTION



;DEFICIENCIES:
;	THE AC'S ARE NOT PRESERVED DURING DUMPS. THUS REPEATED DUMPS
;		HAVE JUNK IN THE AC'S.
;	THE AC'S ARE NOT PRESET TO 0 AFTER /LOAD OR /START
;	THERE IS A SLIGHT RACE CONDITION IN THE PRESERVATION OF
;		THE PI-CHANNEL.  THEREFORE THE MONITOR SHOULD
;		ESTABLISH IT AS A CONSTANT AT ONCE TIME AND
;		VERIFY/RESTORE IT OCCASIONALLY (ONCE/SECOND?)


;EDIT 35:  EXECUTES A SET CPU UUO TO LET BOOT11 RUN ON CPU 0 ONLY.
;	   [AREA AFFECTED: STRTUP]

;EDIT 36:  INCREASES THE TIMEOUT OF THE PDP-11 BY A FACTOR OF 10
;	   SINCE NEWER DL10 INTERFACES NEED A LONGER DELAY.
;	   [AREA AFFECTED: STPLP]

;EDIT 37:  LOCKS BOOT11 AT A 1K BOUNDARY TO INSURE PROPER OPERATION
;	   ON A KI WITH THE 8K DL10 OPTION.
;	   [AREA AFFECTED: STRTUP]	   

;EDIT 40:  ADDS TYPE OF FAILURE TO LOCK ERROR MESSAGE
;	   [AREAS AFFECTED: MACRO DEFINITIONS, STRTUP]

;EDIT 41:  DETERMINES PHYSICAL LOCATION THAT BOOT11 IS LOCKED IN
;	   CORE EVEN WHEN LOCKED ABOVE 112K ON A KI.
;	   [AREA AFFECTED: STRTUP]

;EDIT 42:  CAUSES BOOT11 TO REQUIRE A PORT SWITCH IF THERE
;	   IS MORE THAN ONE PDP-11 ON THE DL10'S.
; 	   [AREAS AFFECTED: MACRO DEFINITIONS, SETCOD, STRTUP, SWTWIN, STORAGE]

;EDIT 43:  ALLOWS PRINTING OF CPU SERIAL NUMBERS GREATER
;          THAN 999 IN DUMP ROUTINE HEADING FORMAT.
;          [AREA AFFECTED: DMHDV3]

;EDIT 44:  INCREASES TIMEOUTS OF PDP-11 WHEN STARTING AND CLEARING.
;	   [AREAS AFFECTED: STPLP, WAITIN]

;EDIT 45:  ADDS CODE TO LOG RELOADS VIA THE DAEMON. UUO
;	   [AREAS AFFECTED: ? ]

;EDIT 46:  INCREASE THE PDL LEN TO HANDLE DAEMON UUO ERRORS.
;	   [AREAS AFFECTED: ? ]

    	SUBTTL	DEFINITIONS

	;DEVICE CODES
DLB==60		;FIRST DL-10
DLC==64
DLB2==160	;SECOND DL-10
DLC2==164

	;VARIOUS DL-10 BITS
GETPIC==7				;MASK FOR PI CHANNEL

	;DEFINE THE VARIOUS I/O OP CODES
	DEFINE	MAKE11(ARG),<IRP ARG,<
	DEFINE	ARG'11(USER),<XLIST
	IFB	<USER>,<XCT ARG'.>
	IFNB	<USER>,<MOVE T1,ARG'.
		      IOR  T1,[USER]
		      XCT  T1>
	LIST>	>>

	MAKE11	<GTPI,ENBL,DSAB,CLRA,CLRB,BASE,STRT,STOP,GSTS>

	DEFINE	WAITON	<
	XLIST
	PUSHJ	P,WAITIN
	LIST
	>
	DEFINE	TELL	(STRING)<
	XLIST
	PUSHJ	P,[OUTSTR	[ASCIZ	\" STRING\]
		   RETURN]
	LIST	>

	DEFINE	TELLCR	(STRING)<
	XLIST
	PUSHJ	P,[OUTSTR	[ASCIZ	\" STRING
\]
		   RETURN]
	LIST	>


	DEFINE	WARN	(STRING)<
	XLIST
	PUSHJ	P,[OUTSTR	[ASCIZ	\% STRING\]
		   RETURN]
	LIST	>

	DEFINE	WARNCR	(STRING)<
	XLIST
	PUSHJ	P,[OUTSTR	[ASCIZ	\% STRING
\]
		   RETURN]
	LIST	>

	DEFINE	ERROR	(STRING)<
	XLIST
	JRST	[OUTSTR	[ASCIZ \? STRING
\]
		JRST	EXITX]
	LIST>
	DEFINE	ERRORC	(STRING,AC)<	;[40] DISPLAYS UUO FAILURE, INCLUDING CODE
	XLIST
	JRST	[OUTSTR [ASCIZ \? STRING \]
		ADDI	AC,60
		OUTCHR	AC
		OUTSTR	[ASCIZ\
\]
		JRST	EXITX]
	LIST>

	DEFINE	ERRCH	(NUM)<		;[42] DISPLAYS A CHARACTER & TWO SPACES
	XLIST
	PUSHJ	P,[ADDI	NUM,60
		OUTCHR	NUM
		OUTCHR	["  "]
		RETURN]
	LIST>

	DEFINE	USEROR	(STRING)<
	XLIST
	JRST	[OUTSTR	[ASCIZ \? STRING
\]
		JRST	STARTE]
	LIST>

	DEFINE	RETURN <
	XLIST
	POPJ	P,
	LIST>
	LOC	137
	%%BT11
	RELOC
;PARAMETERS
	INDEV==1	;INPUT CHANNEL
	IIMODE==10	;IMAGE MODE INPUT FROM INDEV
	INMODE==14	;INPUT FROM INDEV
	OUTDEV==2	;OUTPUT FOR DUMP
	OUMODE==0	;OUTPUT FROM OUTDEV

	PDSIZ==50	;SIZE OF PUSH DOWN LIST

	ONES11==177777	;=ALL ONES AS FAR AS THE 11 CAN SEE

;DEFINITIONS FOR DAEMON ERROR-LOGGING CALLS

;FILE SPEC BLOCK FOR ERROR LOGGING (USED TO REPORT LOAD/DUMP FILES)
	ERFSFN==0		;FILE NAME
	ERFSEX==1		;EXTENSION
	ERFSDV==2		;DEVICE
	ERFSXX==3		;PATH. BITS
	ERFSPN==4		;PPN
	ERFSSF==5		;SFD #1
	ERFSLN==ERFSSF+6	;LENGTH OF A FILE-SPEC BLOCK

;DEVCHR BIT DEFINITIONS
	DEVPTR==200,,0	;PAPER TAPE READER

;AC'S

	T1=1		;SCRATCHED IN SUBROUTINES
	T2=T1+1
	T3=T2+1
	T4=T3+1
	T5=T4+1		;[42]
	P1=T5+1		;PRESERVED IN SUBROUTINES
	P2=P1+1
	P3=P2+1
	P4=P3+1

	BC=P4+1		;BYTE COUNT OF DATA IN GROUP
	BA=BC+1		;OUTPUT BYTE ADDRESS
	BYTE=BA+1	;LAST -11 BYTE READ FROM FILE
	FB=BYTE+1	;MOD 4 POSITION IN INPUT WORD
	RB=FB+1		;RELOCATION FOR -11 BUFFER

	P=17		;CALL STACK
	;DESCRIPTION OF OUTPUT FROM MACX11/P GENERATED ASSEMBLY
	;THAT IS, WHAT INPUT SHOULD LOOK LIKE
	;APPROXIMATELY
;-----------------------------------------------------------------------
;[(0-1)/8-BIT BYTE#2/8-BIT BYTE #1,,(18-19)/8-BIT BYTE #4/8-BIT BYTE #3]
;-----------------------------------------------------------------------

;THE ABOVE IS SO-CALLED PACKED MODE.  IN IMAGE MODE, THEY APPEAR
;ONE BYTE PER WORD IN ASCENDING BYTE ORDER.

;	THE BYTES IN -11 ORDERING (IE, AFTER ABOVE UNTANGLING) ARE:
;		ANY NUMBER OF 0 BYTES (DISCARD)
;		CONSTANT 1
;		CONSTANT 0
;		BCL
;		BCU
;		AL
;		AU
;		BC-6 BYTES OF DATA IN ORDER STARTING WITH THE BYTE FOR A
;		C
;			WHERE BC=BCU*400+BCL	THE BYTE COUNT
;			      A =AU *400+AL	THE FIRST BYTE ADDRESS
;			      C =          	THE CHECKSUM
;	THE ABOVE CAN BE REPEATED INDEFINITELY.
;	THE LAST SUCH GROUP HAS BC=6 AND THE STARTING ADDRESS IS A.

;THE CHECKSUM IS A SIMPLE ADD OF THE BYTES STARTING WITH CONSTANT 1 AND
;INCLUDING THE CHECKSUM--THE RESULT IS 0 IN 8 BITS.
	SUBTTL	LOAD PROGRAM

STARTE:	CLRBFI			;CLEAR TTY INPUT IF ERROR
START:	RESET
	SETZM	FWAZER		;CLEAR STORAGE
	MOVE	T1,[FWAZER,,FWAZER+1]
	BLT	T1,LWAZER
	SETOM	FWAONE		;PRESET SWITCH ANSWERS TO -1
	MOVE	T1,[FWAONE,,FWAONE+1]
	BLT	T1,LWAONE
START2:	MOVE	P,[IOWD	PDSIZ,PDLST]

	PUSHJ	P,GETCOM	;GO GET COMMAND

START6:	RESET			;RECLAIM SPACE IF RE-STARTING
	XCT	START2		;SET UP PUSH DOWN LIST
	PUSHJ	P,SETCOD	;SETUP I/O CODES

	SKIPGE	A.DUMP		;SEE IF /DUMP
	SKIPL	A.END		;OR IF /END
	JRST	DODUMP		;GO DO DUMP
	SKIPL	A.STRT		;SEE IF /START
	SKIPGE	A.LOAD		;AND /LOAD
	JRST	.+2		;NO--OK
	USEROR	Can't do both /LOAD and /START
	SKIPL	A.CLR		;SEE IF /CLEAR
	JRST	[SKIPGE	A.LOAD	;YES--SEE IF /LOAD
		 SKIPL	A.STRT	; OR /START
		 JRST	.+1	;YES--DO BOTH
		 JRST	STRTLD]	;NO--GO START 11
	SKIPN	T2,DEV		;IS DEVICE NULL?
	MOVSI	T2,'DSK'	;YES, DEFAULT IS DSK
	DEVCHR	T2,		;GET INPUT DEVICE CHARACTERISTICS
	TLNE	T2,(DEVPTR)	;IS INPUT DEVICE PTR?
	SETZM	A.IMAG		;YES, THEN /IMAGE IS A DEFAULT SWITCH
	MOVEI	T1,INMODE	;SET INPUT MODE
	SKIPL	A.IMAG		;IS /IMAGE SWITCH SET?
	MOVEI	T1,IIMODE	;YES, THEN IMAGE MODE INPUT
	SKIPN	T2,DEV		;GET DEVICE
	MOVSI	T2,'DSK'	;DEFAULT TO DISK
	MOVEI	T3,INHDR	;POINT TO BUFFER HEADER
	OPEN	INDEV,T1	;OPEN FILE
	  USEROR	Can't OPEN the input device

	SKIPE	T1,NAME		;GET FILE NAME
	JRST	.+3
	MOVE	T1,['PDPXI0']	;DEFAULT
	ADD	T1,A.PORT	;MAKE DEFAULT NAME INCLUDE PORT#
	SKIPN	T2,EXT		;GET EXTENSION
	HRLZI	T2,'BIN'	;DEFAULT
	TRZ	T2,-1		;CLEAR NULL FLAG
RELOOK:	MOVEI	T3,0		;CLEAR WORD
	MOVE	T4,DIRECT	;GET DIRECTORY
	LOOKUP	INDEV,T1	;LOOKUP FILE
	  JRST	[SKIPE	EXT	;CHECK ARGUMENT
		 TLZ	T2,-1	;ALL DONE IF NON-ZERO
		 TLZE	T2,-1	;SEE IF DEFAULT EXT AND NO DOT
		 JUMPE	T2,RELOOK  ;YES--IF NOT FOUND TRY NULL EXT.
		 USEROR	LOOKUP failed
		]
	MOVEM	T1,LODFIL+ERFSFN;SAVE THE FILE NAME
	HLLZM	T2,LODFIL+ERFSEX;  AND THE EXTENSION
	MOVEI	T1,INDEV	;GET THE CHANNEL NUMBER
	MOVEM	T1,LODFIL+ERFSDV;  AND PUT IT WHERE "PATH." CAN FIND IT
	MOVE	T1,[XWD ERFSLN-ERFSDV,LODFIL+ERFSDV] ;SET UP AND
	PATH.	T1,		;  DO THE UUO TO READ THE PATH
	  WARNCR PATH. UUO to read input file failed.
	INBUF	INDEV,0		;SET UP SOME BUFFERS
STRTLD:	PUSHJ	P,STRTUP	;GO START UP -11

	SKIPL	A.CLR		;SEE IF /CLEAR
	JRST	[PUSHJ	P,CLEAR	;YES--GO DO IT
		 SKIPGE	A.LOAD	;SEE IF /LOAD
		 SKIPL	A.STRT	; OR IF /START
		 JRST	.+1	;YES--GO DO IT
		 PUSHJ	P,HALTIT  ;STOP -11 PORT
		 JRST	START]	;NO--GO ASK ABOUT FILE
	TELL	<PDP-11 loading from file:  >
	MOVEI	T1,LODFIL	;GET THE ADDRESS OF THE FILE SPEC
	PUSHJ	P,TYPFIL	;  AND APPEND IT TO THE MESSAGE
	PUSHJ	P,TYPCRL	;CLOSE THE MESSAGE WITH A CRLF

	SETOM	FB		;PRESET FILE BYTE POSITION
;BACK HERE FOR EACH GROUP OF DATA
LDGRPL:	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF at start of file group
	JUMPE	BYTE,LDGRPL	;LOOP THROUGH NULLS
	CAIN	BYTE,377	;DISCARD DELETES
	JRST	LDGRPL		; ..
	CAIE	BYTE,1		;VERIFY CONSTANT 1
	ERROR	File group has junk instead of constant 1
	MOVEM	BYTE,CHKSUM	;INITIALIZE CHECKSUM
	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF after file constant 1
	SKIPE	BYTE		;VERIFY CONSTANT 0
	ERROR	file group has junk instead of constant 0
	PUSHJ	P,GETWRD	;GET WORD
	SKIPGE	A.IMAG		;SEE IF IMAGE MODE
	SKIPE	T1		;NO--SEE IF 0
	JRST	LDGRP2		;OK
	WARNCR	File zero byte count--trying again in /IMAGE mode
	PUSHJ	P,HALTIT	;STOP -11
	SETZM	A.IMAG		;SET /IMAGE SWITCH
	JRST	START6		;START AGAIN BUT NO COMMAND SCANNING

LDGRP2:	MOVEI	BC,-6(T1)	;GET DATA BYTE COUNT
	SKIPGE	BC		;SEE IF ACCEPTABLE
	ERROR	File group byte count less than 6
	PUSHJ	P,GETWRD	;GET WORD
	MOVEM	T1,ADDRES	;SAVE AS STARTING ADDRESS
	JUMPE	BC,THATAL	;JUMP IF THIS IS THE START BLOCK
;LOOP GETTING DATA AND TRANSFERRING IT TO THE -11

LDDATL:	MOVEI	P1,20		;DO 20 BYTES (10 WORDS)
	CAIGE	BC,20		;MAKE SURE FILE HAS THAT MANY
	MOVE	P1,BC		;NO--USE WHAT IS IN FILE
	MOVE	P2,P1		;SET COUNT FOR FETCH

	MOVE	T1,ADDRES	;GET STARTING ADDRESS
	MOVEM	T1,BLOADR(RB)	;TELL -11 PROGRAM
	MOVEM	P1,BLOCNT(RB)	;TELL -11 NUMBER OF BYTES
	MOVE	BA,[POINT 8,BLODAT(RB),35]	;POINT TO DATA AREA
	PUSHJ	P,CLRTRA	;CLEAR TRANSFER AREA

;LOOP FILLING BUFFER FOR ONE TRANSFER TO THE -11
LDDATM:	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF during data in file group
	DPB	BYTE,BA		;STUFF INTO BUFFER
	TLCE	BA,(POINT 0,0,27)	;SWITCH BYTES
	AOS	BA		;ADVANCE WORD EVERY TWO
	SOJG	P2,LDDATM	;LOOP FILLING BUFFER

	MOVE	T1,ADDRES	;GET STARTING ADDRESS
	CAIL	T1,10		;SEE IF BELOW 4/6 AREA
	JRST	LDDOIT		;NO--OK TO PROCEED
	ADDI	T1,-4(P1)	;SEE IF END IS BELOW 4/6 AREA
	JUMPL	T1,LDDOIT	;JUMP IF YES

;HERE WHEN LOAD OVERLAPS 4/6 AREA--MUST PROTECT AND SAVE THIS
;AND CLEAN UP 4 AND 6 AT THE END
	MOVN	T1,T1		;COMPLEMENT OVERLAP
	ADDB	T1,BLOCNT(RB)	;COMPUTE OK LENGTH BELOW 4
	JUMPLE	T1,SAVE46	;NONE--GO SAVE 4/6
	WAITON			;YES--TRANSFER THAT MUCH
SAVE46:	MOVE	BA,[POINT 8,BLODAT(RB),35]
	MOVE	T1,ADDRES	;GET ADDRESS OF FIRST BYTE IN AREA
	HRRZI	T2,(P1)		;GET COUNT OF BUFFER
SAVELP:	LDB	T3,BA		;GET THIS BYTE
	CAIN	T1,4		;SEE IF 4
	DPB	T3,[POINT 8,CORE.4,35]
	CAIN	T1,5		;SEE IF 5
	DPB	T3,[POINT 8,CORE.4,27]
	CAIN	T1,6		;SEE IF 6
	DPB	T3,[POINT 8,CORE.6,35]
	CAIN	T1,7		;SEE IF 7
	DPB	T3,[POINT 8,CORE.6,27]
	TLCE	BA,(POINT 0,0,27)	;SWITCH BYTES
	AOS	BA		;ADVANCE WORD EVERY TWO
	AOS	T1		;ADVANCE ADDRESS
	SOJG	T2,SAVELP	;LOOP UNTIL DONE
			;NOTE THAT 7 CAN BE CLOBERRED BY 0
			;SINCE LOAD LOOP HAS 0 THERE
	MOVEI	T1,10		;FIRST GOOD ADDRESS IS 10
	SUB	T1,ADDRES	;LENGTH OF PROBLEM
	LSH	T1,-1		;DITTO IN -10 WORDS
	MOVEI	T2,(P1)		;GET OLD BYTE COUNT
	SUB	T2,T1		;DECREASE
	SUB	T2,T1		; TO NEW VALUE
	JUMPLE	T2,LDIDIT	;JUMP IF NONE ABOVE 7
	MOVEM	T2,BLOCNT(RB)	;TELL -11 HOW FAR TO GO
	JUMPE	T1,LDNOBL	;IF STARTED AT 7, THEN NO BLT
	MOVEI	T2,BLODAT(RB)	;GET TARGET OF BLT
	ADD	T2,T1		;GET START
	MOVSS	T2		;SETUP BLT
	HRRI	T2,BLODAT(RB)	;SET TARGET
	BLT	T2,BLODAT+6(RB)	;TRANSFER DATA
LDNOBL:	MOVE	T2,ADDRES	;GET ORIGINAL ADDRESS
	ADD	T2,T1		;ADVANCE TO
	ADD	T2,T1		;  NEW ONE
	MOVEM	T2,BLOADR(RB)	;TELL -11
	MOVEI	T3,0		;GET A ZERO
	CAIN	T2,7		;IF STARTS AT 7,
	DPB	T3,[POINT 8,BLODAT(RB),27]  ; CLEAR OUT 7

LDDOIT:	WAITON			;HAVE -11 TRANSFER IT
	SKIPE	NXMADR(RB)	;SEE IF NXM IN -11
	ERROR	NXM in -11 memory

LDIDIT:	MOVEI	T1,20		;ADVANCE ADDRESS
	ADDM	T1,ADDRES	; ..
	SUBI	BC,20		;DECREMENT COUNT TO GO
	JUMPG	BC,LDDATL	;LOOP UNTIL DONE

	PUSHJ	P,GETCHK	;VERIFY CHECKSUM
	JRST	LDGRPL		;GO LOOK FOR NEXT GROUP
THATAL:	PUSHJ	P,GETCHK	;VERIFY CHECKSUM
	MOVEI	T1,^D10		;TAPE SHOULD HAVE AT LEAST 10 TRAILING NULLS
SKPEND:	SOJL	T1,LDDONE	;IF 10 NULLS THERE, TAPE END IS OK
	PUSHJ	P,GETBYT	;GET NEXT BYTE
	  JRST	LDDONE		;EOF IS OK
	JUMPE	BYTE,SKPEND	;SKIP TRAILING NULLS
	ERROR	Junk after start group

LDDONE:	MOVE	T1,CORE.4	;GET NEW CONTENTS OF 4
	MOVEM	T1,BLODAT(RB)	;GIVE TO -11
	MOVE	T1,CORE.6	;GET NEW CONTENTS OF 6
	MOVEM	T1,BLODAT+1(RB)	;GIVE TO -11
	MOVEI	T1,4		;GET CONSTANT
	MOVEM	T1,BLOADR(RB)	;SET START ADDRESS
	MOVEM	T1,BLOCNT(RB)	;SET DISTANCE
	WAITON

	SKIPGE	T2,A.STRT	;SEE IF /START
	MOVE	T2,A.LOAD	;NO--TRY /LOAD
	SKIPG	T2		;UNLESS NON-ZERO ARG
	MOVE	T2,ADDRES	; USE FILE ADDRESS
	GSTS11	T1		;GET MEMORY STATUS
	TDNE	T1,OK...	;SEE IF OK
	TRO	T2,1		;NO--SET TO HALT
	MOVEI	T1,137		;SET JUMP @(PC)+
	TRZN	T2,1		;MAKE IT EVEN
	SKIPL	A.LOAD		;SEE IF /LOAD
	MOVEI	T1,0		;OR IF WAS ODD, FORCE HALT
	MOVEM	T2,BLOADR(RB)	;STORE START ADDRESS
	MOVE	P1,T1		;SAVE FLAG
	PUSHJ	P,STOPIT	;GO STOP OR STARTUP -11 PROGRAM
	SKIPN	P1		;SEE IF HALT
	TELLCR	PDP-11 loaded
	SKIPE	P1		;OR IF JMP
	TELLCR	PDP-11 started
	CLOSE	INDEV,		;CLOSE INPUT FILE
	RELEAS	INDEV,		;RELEASE IT
	PUSHJ	P,ERRLOA	;DO DAEMON. TO LOG THE RELOAD
	JRST	GOHOME		;GO BACK TO MONITOR
	SUBTTL	LOADER SUBROUTINES

;ROUTINE TO GET AND VERIFY CHECKSUM

GETCHK:	PUSHJ	P,GETBYT	;GET CHECKSUM
	  ERROR	EOF found when looking for checksum
	MOVE	T1,CHKSUM	;GET RESULT
	TRNN	T1,377		;SEE IF OK
	RETURN			;YES
	ERROR	Checksum failure

;ROUTINE TO GET ONE -11 WORD INTO T1

GETWRD:	PUSHJ	P,GETBYT	;GET RH BYTE
	  ERROR	EOF during first byte of a word
	PUSH	P,BYTE		;SAVE AWAY
	PUSHJ	P,GETBYT	;GET LH BYTE
	  ERROR	EOF during second byte of a word
	MOVE	T1,BYTE		;MOVE TO ANSWER
	LSH	T1,8		;POSITION LH BYTE
	IOR	T1,(P)		;INCLUDE RH BYTE
	POP	P,(P)		;DISCARD SAVED BYTE
	RETURN
;ROUTINE TO GET ONE -11 BYTE FROM FILE INTO BYTE

GETBYT:	SKIPL	A.IMAG		;SEE IF /IMAGE MODE
	JRST	GETBYW		;YES--GET NEXT WORD
	AOS	FB		;ADVANCE FILE BYTE
	ANDI	FB,3		; (MOD 4)
	JUMPN	FB,GETBYC	;IF NOT NEW WORD, JUST FETCH BYTE
GETBYW:	SOSL	INHDR+2		;COUNT DOWN WORDS
	JRST	GETBYA		;STILL SOME THERE SO PROCEED
	IN	INDEV,		;NO--GET NEXT BUFFER
	  JRST	GETBYW		;OK--GO TRY AGAIN
	STATZ	INDEV,740000	;SEE IF ERROR
	  ERROR	Input file read error
	RETURN

GETBYA:	AOS	INHDR+1		;ADVANCE TO NEXT WORD
	MOVE	BYTE,@INHDR+1	;GET WORD
	SKIPL	A.IMAG		;SEE IF /IMAGE
	JRST	GETBYI		;YES--GO GET IMAGE WORD
	TLNN	BYTE,(6B2)	;NO--TEST FOR NO JUNK
	TRNE	BYTE,6B20	; IN EITHER HALF
	ERROR	Junk bits in input file
GETBYC:	LDB	BYTE,PTRTAB(FB)	;GET BYTE
	JRST	GETBYR		;GO RETURN DATA
GETBYI:	TDNE	BYTE,[-1-377]	;SEE IF ANY JUNK
	ERROR	Junk in input file--may not be /IMAGE mode
GETBYR:	ADDM	BYTE,CHKSUM	;ACCUMULATE IN CHECKSUM
	AOS	(P)		;SKIP RETURN
RETRET:	RETURN

PTRTAB:	POINT	8,@INHDR+1,17
	POINT	8,@INHDR+1,9
	POINT	8,@INHDR+1,35
	POINT	8,@INHDR+1,27
	SUBTTL	DUMP ROUTINE

DODUMP:	SKIPGE	A.LOAD		;SEE IF /LOAD
	SKIPL	A.STRT		;OR IF /START
	USEROR	Can't /LOAD and /DUMP at the same time
	SKIPL	A.CLR		;SEE IF /CLEAR
	USEROR	Can't /CLEAR and /DUMP at the same time

	MOVEI	T1,OUMODE	;SET OUTPUT MODE
	SKIPN	T2,DEV		;GET DEVICE
	MOVSI	T2,'DSK'	;DEFAULT TO DISK
	MOVSI	T3,OUTHDR	;POINT TO BUFFER HEADER
	OPEN	OUTDEV,T1	;OPEN FILE
	  USEROR	Can't OPEN the output device

	SKIPE	T1,NAME		;GET FILE NAME
	JRST	.+3
	MOVE	T1,['PDPXI0']	;DEFAULT
	ADD	T1,A.PORT	;MAKE DEFAULT NAME INCLUDE PORT#
	SKIPN	T2,EXT		;GET EXTENSION
	HRLZI	T2,'LSD'	;DEFAULT
	TRZ	T2,-1		;CLEAR NULL FLAG
	MOVEI	T3,0		;CLEAR PROTECTION, ETC.
	MOVE	T4,DIRECT	;GET DIRECTORY
	ENTER	OUTDEV,T1	;ENTER FILE
	  USEROR	ENTER failed
	MOVEM	T1,DMPFIL+ERFSFN;SAVE THE FILE NAME
	HLLZM	T2,DMPFIL+ERFSEX;  AND THE EXTENSION
	MOVEI	T1,OUTDEV	;GET THE CHANNEL NUMBER
	MOVEM	T1,DMPFIL+ERFSDV;  AND PUT IT WHERE "PATH." CAN FIND IT
	MOVE	T1,[XWD ERFSLN-ERFSDV,DMPFIL+ERFSDV] ;SET UP AND
	PATH.	T1,		;  DO THE PATH. TO READ THE FILESPEC
	  WARNCR PATH. UUO to read dump file-spec failed.
	OUTBUF	OUTDEV,0	;SET DEFAULT BUFFERS
;ACCUMULATE HEADING DATA

STRTDM:	MOVE	T1,[POINT 7,HEADER]
	MOVEM	T1,HEDPNT		;INIT POINTER FOR HEADER MSG
	PUSHJ	P,HEDTXT
	 ASCIZ /PDP-11 #/
	MOVE	T1,A.PORT		;GET PORT NUMBER
	PUSHJ	P,HEDDIG		; AND PRINT
	PUSHJ	P,HEDTXT
	 ASCIZ / dump by BOOT11 /
	LDB	T1,[POINT 9,.JBVER##,11]
	PUSHJ	P,HEDOCT		;PRINT VERSION  NUMBER
	LDB	T1,[POINT 6,.JBVER,17]	;GET MINOR VERSION #
	JUMPE	T1,DMHDV1		;JUMP IF NONE
	SUBI	T1,1			;FAKE OUT DIVIDE
	IDIVI	T1,^D26			;GET LAST LETTER
	JUMPE	T1,DMHDV0		;JUMP IF ONLY 1 LETTER
	ADDI	T1,"A"-1		;CONVERT 1ST LETTER
	PUSHJ	P,HEDCHR
DMHDV0:	MOVEI	T1,"A"(T2)
	PUSHJ	P,HEDCHR		;OUTPUT LAST LETTER

DMHDV1:	HRRZ	T1,.JBVER		;GET EDIT NUMBER
	JUMPE	T1,DMHDV2		;JUMP IF ZERO
	MOVEI	T1,"("
	PUSHJ	P,HEDCHR
	HRRZ	T1,.JBVER
	PUSHJ	P,HEDOCT
	MOVEI	T1,")"
	PUSHJ	P,HEDCHR		;FINISH "(EDIT NUMBER)"

DMHDV2:	LDB	T1,[POINT 3,.JBVER,2]	;GET "WHO MADE EDIT"
	JUMPE	T1,DMHDV3		;JUMP IF DIGITAL DID
	MOVEI	T1,"-"
	PUSHJ	P,HEDCHR
	XCT	DMHDV2			;GET "WHO" BACK
	PUSHJ	P,HEDDIG		; AND PRINT

DMHDV3:	MOVEI	T1,11			;HORIZONTAL TAB
	PUSHJ	P,HEDCHR
	MSTIME	T1,		;GET TIME OF DAY (MILLESECONDS)
	IDIVI	T1,^D60000	;GET MINUTES
	IDIVI	T1,^D60		;GET HOURS
	PUSH	P,T2		;SAVE REMAINDER AS MINUTES
	PUSHJ	P,HEDDEC	;PRINT QUOTIENT AS HOURS
	MOVEI	T1,":"
	PUSHJ	P,HEDCHR	;PRINT COLON
	POP	P,T1		;GET MINUTES BACK
	PUSHJ	P,HEDDEC	; AND PRINT
	MOVEI	T1,11
	PUSHJ	P,HEDCHR	;PRINT TAB

	DATE	T1,
	IDIVI	T1,^D31*^D12	;YEAR GOES TO T1
	ADDI	T1,^D64		;ADD IN BASE YEAR
	IDIVI	T2,^D31		;T2 GETS MONTH, T3 GETS DAY
	PUSH	P,T1		;SAVE YEAR
	PUSH	P,[ASCII /JAN/
		ASCII /FEB/
		ASCII /MARCH/
		ASCII /APRIL/
		ASCII /MAY/
		ASCII /JUNE/
		ASCII /JULY/
		ASCII /AUG/
		ASCII /SEPT/
		ASCII /OCT/
		ASCII /NOV/
		ASCII /DEC/](T2)
	MOVEI	T1,1(T3)	;GET DAY
	PUSHJ	P,HEDDEC	; AND PRINT
	MOVEI	T1,"-"
	PUSHJ	P,HEDCHR
	POP	P,T1		;GET MONTH
	PUSHJ P,HED7	; AND PRINT
	MOVEI	T1,"-"
	PUSHJ	P,HEDCHR
	POP	P,T1
	PUSHJ	P,HEDDEC	;PRINT YEAR
	MOVE	T1,[20,,11]	;GET SYSTEM
	GETTAB	T1,		; SERIAL NUMBER
	  MOVEI	T1,0		;UNKNOWN
	SKIPLE	T1		;SEE IF OK
	CAILE	T1,^D9999	;[43] MAXIMUM PRINTABLE SERIAL NUMBER IN HEADING
	JRST	DMHDV5		;SYSTEM NUMBER BAD
	PUSH	P,T1		;SAVE NUMBER
	PUSHJ	P,HEDTXT
	 ASCIZ /     System /	;[43]
	POP	P,T1
	PUSHJ	P,HEDDEC	;PRINT SYSTEM NUMBER

DMHDV5:	MOVSI	T1,(ASCII /  /)
	PUSHJ	P,HED7		;PRINT SPACES

	MOVSI	T4,-5		;SET HEADER COUNT
DMHDV6:	MOVEI	T1,11	;POINT TO TABLE
	HRL	T1,T4		;POINT TO ENTRY
	GETTAB	T1,		;GET SYSTEM HEADER LINE
	 MOVEI	T1,0		;UNKNOWN
	PUSHJ	P,HED7		;PRINT TEXT
	AOBJN	T4,DMHDV6	;LOOP UNTIL DONE

	MOVEI	T1,0
	PUSHJ	P,HEDCHR	;STUFF NULL IN AT END OF HEADER
	PUSHJ	P,LHEAD		;GO LIST HEADER
	PUSHJ	P,STRTUP	;GO START UP -11
	TELL	<PDP-11 dumping to file:  >
	MOVEI	T1,DMPFIL	;GET THE FILESPEC
	PUSHJ	P,TYPFIL	;  AND PRINT IT OUT
	PUSHJ	P,TYPCRL	;CLOSE OFF WITH A CRLF

;DUMP AC'S 4 PER LINE
	MOVSI	P3,-7		;DUMP SEVEN AC'S
DMLPAC:	PUSHJ	P,LTAB		;SPACE OVER
	MOVEI	T1,"R"		;LABEL AS
	PUSHJ	P,LCHAR		; REGISTER
	MOVEI	T1,"0"(P3)	;NUMBER REGISTER
	PUSHJ	P,LCHAR		; IN LISTING
	MOVEI	T1,[ASCIZ /:  /]
	PUSHJ	P,LSTRG		;LIST PREFIX
	MOVEI	T1,BLODAT(RB)	;GET START OF TRANSFER AREA
	ADDI	T1,(P3)		;ADD AC NUMBER
	MOVE	T1,(T1)		;GET AC CONTENTS
	PUSHJ	P,L6OCT		;LIST IT
	MOVEI	T1,-3(P3)	;SEE IF DONE WITH FIRST 4
	JUMPN	T1,.+2		;NO--PROCEED
	PUSHJ	P,LCRLF2	;YES--NEW LINE
	AOBJN	P3,DMLPAC	;LOOP FOR ALL AC'S WHICH WORK

	PUSHJ	P,LCRLF2	;BLANK LINES
	PUSHJ	P,LCRLF2	;AND MORE

	MOVE	T1,BLOCNT(RB)	;GET CORE 4
	MOVEM	T1,CORE.4	;SAVE FOR LATER
	MOVE	T1,BLOADR(RB)	;GET CORE 6
	MOVEM	T1,CORE.6	;SAVE FOR LATER
;DUMP CORE 10-WORDS PER LINE
	SKIPGE	P1,A.DUMP	;GET STARTING ADDRESS
	MOVEI	P1,V.DUMP	;DEFAULT
	TRZ	P1,17		;ROUND DOWN TO EVEN 10-WORDS
	SKIPGE	P2,A.END	;GET ENDING ADDRESS
	MOVEI	P2,V.END	;DEFAULT
	SUBI	P2,1		;STOP BEFORE GETTING THERE
	TRO	P2,17		; BUT ROUND UP THE EVEN 10-WORDS

	MOVEI	P4,0		;SET INITIAL LINE POSITION

;BACK HERE FOR LOOP BY 10-WORD HUNKS
DMLOOP:	CAML	P1,P2		;SEE IF DONE YET
	JRST	DMDONE		;YES--GO BIND OFF OUTPUT
	SKIPN	LASZER		;SKIP LINE COUNT IF 0 LINES
	AOS	P4		;ADVANCE LINE
	CAIG	P4,^D22		;SEE IF DONE WITH THIS PAGE
	JRST	DMNOHD		;NO NEED FOR HEADER
	MOVEI	T1,14		;ISSUE FORM FEED
	PUSHJ	P,LCHAR		; TO LISTING
	PUSHJ	P,LHEAD		;ISSUE HEADER
	MOVEI	P4,0		;CLEAR LINE COUNT
DMNOHD:	MOVNI	T1,20		;TRANSFER 20 BYTES (10 WORDS)
	MOVEM	T1,BLOCNT(RB)	;FROM THE -11 CORE
	MOVEM	P1,BLOADR(RB)	;STARTING AT START ADDRESS
	PUSHJ	P,CLRTRA	;CLEAR TRANSFER AREA
	WAITON			;WAIT FOR -11 TO READ ITS CORE
	SKIPE	NXMADR(RB)	;SEE IF END OF CORE
	JRST	DMNXM		;YES--GO HANDLE IT
	JUMPN	P1,DMSEEZ	;SEE IF FIRST GROUP
	MOVE	T1,CORE.4	;YES--GET REAL 4/5
	MOVEM	T1,BLODAT+2(RB)	;SET WHERE -11 WOULD HAVE
	MOVE	T1,CORE.6	;GET REAL 6/7
	MOVEM	T1,BLODAT+3(RB)	;SET WHERE -11 WOULD HAVE

DMSEEZ:	MOVSI	P3,-10		;SEE IF ALL 0
	HRR	P3,RB		;RELOCATE
	SKIPN	BLODAT(P3)	;CHECK DATA
	AOBJN	P3,.-1		;LOOP FOR AREA
	JUMPGE	P3,DMZERO	;JUMP IF ALL ZERO
	PUSHJ	P,DMZRLN	;NO--CLEAN OFF PREVIOUS ONE
	SETZM	LASZER		;CLEAR ZERO'S BEING SKIPPED
	MOVEI	T1,20(P1)	;GET START OF NEXT LINE
	MOVEM	T1,FIRZER	;SET AS FIRST POSSIBLE ZERO

	MOVE	T1,P1		;GET STARTING ADDRESS
	PUSHJ	P,L6OCT		;LIST IT
	MOVEI	T1,":"		;FLAG AS ADDRESS
	PUSHJ	P,LCHAR		;IN LISTING

	MOVSI	P3,-10		;SET FOR 10-WORDS
DMLP1:	PUSHJ	P,LTAB		;SPACE OVER
	MOVEI	T1,BLODAT(RB)	;GET LOCATION OF TRANSFER AREA
	ADDI	T1,(P3)		;POINT TO CORRECT WORD
	MOVE	T1,(T1)		;GET WORD
	PUSHJ	P,L6OCT		;LIST IT
	MOVEI	T1,-3(P3)	;SEE IF DONE WITH 4 WORDS YET
	JUMPN	T1,.+2		;NO--PROCEED
	PUSHJ	P,LTAB		;YES--ONE EXTRA TAB
	AOBJN	P3,DMLP1	;LOOP FOR THIS LINE
	PUSHJ	P,LCRLF2	;END 2 LINES
	JRST	DMGOLP		;GO AROUND LOOP

DMZERO:	MOVEI	T1,16(P1)	;SET POSSIBLE END OF ZERO BLOCK
	MOVEM	T1,LASZER	;FOR DUMP
DMGOLP:	ADDI	P1,20		;ADVANCE 20 BYTES (10 WORDS)
	JRST	DMLOOP		;LOOP UNTIL DONE
;HERE WHEN NXM IN -11 MEMORY
DMNXM:	PUSHJ	P,DMZRLN	;ISSUE FINAL ZERO LINE
	SETZM	LASZER		;CLEAR FINAL ZERO
	MOVEI	T1,[ASCIZ /			NXM at /]
	PUSHJ	P,LSTRG		;LIST HEADER
	SOS	T1,NXMADR(RB)	;GET BAD ADDRESS
	PUSHJ	P,L6OCT		;LIST IT
	PUSHJ	P,LCRLF2	;END LINE
DMDONE:	PUSHJ	P,DMZRLN	;CLEAR OUT FINAL ZEROS
	PUSHJ	P,HALTIT	;STOP -11
	TELLCR	PDP-11 dumped

	CLOSE	OUTDEV,		;CLOSE FILE
	RELEAS	OUTDEV,		;RELEASE IT
	PUSHJ	P,ERRDMP	;CALL DAEMON TO LOG THE DUMP.
	JRST	GOHOME		;AND FINISH WORK
	SUBTTL	DUMP SUBROUTINES

;LIST ZERO LINE IF ANY
DMZRLN:	SKIPN	LASZER		;SEE IF ANYTHING
	RETURN			;NO--GIVE UP
	PUSHJ	P,LTAB		;YES--SPACE OVER
	PUSHJ	P,LTAB
	MOVE	T1,LASZER	;GET END
	SUB	T1,FIRZER	;GET LENGTH-2
	ADDI	T1,2		;GET LENGTH IN BYTES
	LSH	T1,-1		;CONVERT TO WORDS
	PUSHJ	P,L6OCT		;LIST THAT
	MOVEI	T1,[ASCIZ / words from /]
	PUSHJ	P,LSTRG		;LIST TITLE
	MOVE	T1,FIRZER	;GET START
	PUSHJ	P,L6OCT		;LIST
	MOVEI	T1,[ASCIZ / to /]
	PUSHJ	P,LSTRG		;LIST TITLE
	MOVE	T1,LASZER	;GET END POINT
	PUSHJ	P,L6OCT		;LIST
	MOVEI	T1,[ASCIZ / are all zero

/]
	JRST	LSTRG		;LIST AND RETURN
;LIST 6 DIGITS IN OCTAL
L6OCT:	LSHC	T1,-^D18	;POSITION NUMBER
	MOVEI	T3,6		;SET DIGIT COUNTER
L6OCTL:	MOVEI	T1,0		;CLEAR ACCUMULATOR
	LSHC	T1,3		;GET DIGIT
	ADDI	T1,"0"		;CONVERT TO ASCII
	PUSHJ	P,LCHAR		;LIST IT
	SOJG	T3,L6OCTL	;LOOP UNTIL DONE
	RETURN

;LIST HEADING
LHEAD:	MOVEI	T1,HEADER	;GET HEADER
	PUSHJ	P,LSTRG		;LIST IT
				;FALL INTO LCRLF2

;LIST END OF LINE AND A BLANK LINE
LCRLF2:	MOVEI	T1,[ASCIZ /

/]
				;FALL INTO LSTRG

;LIST ASCIZ STRING
LSTRG:	MOVE	T2,T1		;GET POINTER
	HRLI	T2,(POINT 7)	;SET ASCII POINTER
LSTRGL:	ILDB	T1,T2		;GET CHARACTER
	JUMPE	T1,RETRET	;RETURN IF DONE
	PUSHJ	P,LCHAR		;ELSE LIST IT
	JRST	LSTRGL		;LOOP UNTIL DONE

;LIST TAB
LTAB:	MOVEI	T1,11		;GET TAB
				;FALL INTO LCHAR

;LIST CHARACTER
LCHAR:	SOSG	OUTHDR+2	;COUNT CHARACTER IN BUFFER
	JRST	LCHARB		;NO ROOM--GO MAKE SOME
LCHARL:	IDPB	T1,OUTHDR+1	;OK--STORE CHARACTER
	RETURN

LCHARB:	OUT	OUTDEV,		;OUTPUT DATA BUFFER
	  JRST	LCHARL		;AND NOW GO DO CHARACTER
	ERROR	Output device error
	SUBTTL	-11 HANDLER SUBROUTINES

;ROUTINE TO COMPUTE I/O CODES AS FUNCTION OF /PORTNO:P
SETCOD:	MOVE	P2,A.PORT	;GET /PORTNO
	CAILE	P2,7		;KEEP IN RANGE
	USEROR	Port number must be 0-7
	IDIVI	P2,4		;SPLIT INTO -11 AND DL NUMBERS
	MOVE	P1,[CONO DLB,
		    CONO DLB2,](P2)
	MOVE	P2,[CONI DLC,
		    CONI DLC2,](P2)
	MOVE	P4,P3		;GET PORT
	IMULI	P4,3		;  *3

			;IN THIS ROUTINE:
			;	P1=I/O INSTR  ON DLB
			;	P2=I/O INSTR  ON DLC
			;	P3=-11 NUMBER
			;	P4=3*-11 NUMBER (FOR LSH)

	MOVEM	P2,GTPI.	;GET PI ASSIGNMENT

	SUB	P2,[<CONI>-<CONO>]	;SWITCH TO CONO

	MOVEI	T1,1B31		;ENABLE
	LSH	T1,(P4)		;SELECT -11
	IOR	T1,P2		;DLC
	MOVEM	T1,DSAB.	;DISABLE -11
	TRO	T1,1B20		;TURN ON
	MOVEM	T1,ENBL.	;ENABLE -11

	MOVEI	T1,7B32		;INTERRUPTS AND ENABLE
	LSH	T1,(P4)		;SELECT -11
	IOR	T1,P2		;DLC
	MOVEM	T1,CLRA.	;CLEAR CONO

	MOVEI	T1,<WINDOW/1K>B33(P3)  ;WINDOW SIZE AND WHICH -11
	IOR	T1,P1		;DLB
	MOVEM	T1,BASE.	;SET BASE ADDRESS
	SUB	P2,[<CONO>-<DATAO>]	;SWITCH TO DATAO

	MOVEI	T1,CLRB..	;POINT TO DATUM
	IOR	T1,P2		;DLC
	MOVEM	T1,CLRB.	;CLEAR DATAO
	MOVEI	T1,STRT..	;POINT TO DATUM
	IOR	T1,P2		;DLC
	MOVEM	T1,STRT.	;START -11
	MOVEI	T1,STOP..	;POINT TO DATUM
	IOR	T1,P2		;DLC
	MOVEM	T1,STOP.	;STOP -11

	MOVSI	T1,(7B14)	;CLEAR ERRORS
	LSH	T1,(P4)		;SELECT -11
	MOVEM	T1,OK...	;SAVE FOR TESTS
	TLO	T1,(1B0)	;ACTIVATE THE CLEAR
	MOVEM	T1,CLRB..	;SAVE DATUM
	MOVEI	T1,1B31		;START BIT
	LSH	T1,(P4)		;SELECT -11
	MOVEM	T1,RN...	;SAVE FOR TESTS
	MOVEM	T1,STRT..	;SAVE DATUM
	LSH	T1,1		;STOP BIT (SELECTED)
	MOVEM	T1,STOP..	;SAVE DATUM

	SUB	P2,[<DATAO>-<DATAI>]	;SWITCH TO DATAI
	MOVEM	P2,GSTS.	;SAVE AS GET STATUS

	MOVEI	T1,5B32		;EXIST AND POWER BITS
	LSH	T1,(P4)		;SELECT CORRECT -11
	MOVEM	T1,UP...	;SAVE FOR TESTS

	RETURN
;ROUTINE TO START -11


SP.CR0==1			;[35] SPECIFY CPU 0
.STCPU==14			;[35] SET CPU


STRTUP:	MOVE	T1,[.STCPU,,SP.CR0]	;[35] RUN ON CPU0
	SETUUO	T1,		;[35] ASK FOR IT
	JFCL			;[35] AND IGNORE A FAILURE
	HRRZ	RB,.JBFF##	;GET FREE CORE FOR -11 BUFFER
	ADDI	RB,WINDOW	;ROUND UP TO
	TRZ	RB,WINDOW	; MULT OF 512 IN CASE 8K OPTION IN -11
	MOVEI	T1,WINDOW+1000(RB)	;[37]GET END OF SMALLEST 8K AREA
				;[37] SO WE CAN GET PHYSICAL 1024
				;[37] WORD BOUNDARY ON A KI
	MOVEI	T4,1(T1)	;GET NEW .JBFF
	HRRM	T4,.JBFF	;STORE AWAY
	CORE	T1,		;GET SPACE FROM MONITOR
	  ERROR	Insufficient core
; [37] DELETED 7 INSRTUCTIONS
;**;	HRLZ	T1,RB		;CLEAR AREA
;**;	HRRI	T1,1(RB)	; TO PROTECT
;**;	SETZM	(RB)		; AGAINST SICK
;**;	BLT	T1,777(RB)	; -11. (0 IS IMMEDIATE)
;**;	MOVSI	T1,BASEAD	;COPY CLEAN
;**;	HRR	T1,RB		; -11 CODE
;**;	BLT	T1,LEN11-1(RB)	; TO AREA

	MOVEI	T1,CCINT	;SET FOR
	HRRM	T1,.JBINT##	;  ^C TRAP
	SETZB	T4,CCINTP	;KEEP TIMESHARING ON
	TRPSET	T4,		; BUT GIVE SELF IOT
	  ERROR	TRPSET failed

	MOVEI	T4,3		;[41] AVOID SOME FAILURES (EVM NOT REQUESTED)
	LOCK	T4,		;[41] NOW LOCK THAT LOW SEGMENT
	  ERRORC	LOCK failure, T4	;[40] DISPLAY LOCK FAILURE CODE

	HRLOI	T1,-2		;[41] TEST FOR KA
	AOBJP	T1,STRTU1	;[41] JUMP IF KA
	HRROI	T1,100		;[41] SET T1 FOR GETTAB TO FIND UPMP LOCATION
	GETTAB	T1,		;[41] DETERMINE UPMP LOCATION
	  ERROR	GETTAB 100 to find UPMP  failed

	HRRZI	T4,1(T1)	;[41] NOW DETERMINE JOB'S FIRST PAGE

; [37] INSERTED 9 INSTRUCTIONS
STRTU1:	TRNE	T4,1		;[37] IF ON AN ODD PAGE
	ADDI	RB,1000		;[37] THEN ADJUST TO EVEN
	HRLZ	T1,RB		;[37] CLEAR AREA
	HRRI	T1,1(RB)	;[37]  TO PROTECT
	SETZM	(RB)		;[37]  AGAINST SICK
	BLT	T1,777(RB)	;[37]  -11. (0 IS IMMEDIATE)
	MOVSI	T1,BASEAD	;[37] COPY CLEAN
	HRR	T1,RB		;[37]  -11 CODE
	BLT	T1,LEN11-1(RB)	;[37]  TO AREA
	LSH	T4,9
	MOVEI	T4,(T4)		;GET 9 BITS OF ADDRESS
	ADDI	T4,(RB)		;INCLUDE OFFSET IN THIS PROGRAM

STRPRT:	MOVE	T1,F.PORT	;[42] CHECK IF DEFAULT PORTNO SPECIFIED
	JUMPE	T1,STRTU2	;[42] JUMP IF PORT SPECIFIED (I.E.,F.PORT=0)

				;[42] ROUTINE TO CHECK EXISTENCE OF MULTIPLE PDP-11'S
	SETZM	F0.DL10		;[42] INITIALIZE EXIST FLAG FOR FIRST DL10
	SETZM	F1.DL10		;[42] INITIALIZE EXIST FLAG FOR SECOND DL10
	SETZM	N.DL10		;[42] INITIALIZE CURRENT DL10 BEING TESTED
	SETZM	N.PORT		;[42] INITIALIZE COUNT OF EXISTING -11'S
	MOVEM	T4,PAGADR	;[42] SAVE T4 FOR CLEAR ROUTINE LATER

STRPR1:	MOVEI	T3,4B35		;[42] INITIAL EXIST MASK-OFFSET 3 BITS FROM ORIGIN
	SETZ	T2,		;[42] NUMBER OF CURRENT PORT BEING TESTED
	GSTS11	T4		;[42] GET DL10 STATUS BITS
	JUMPE	T4,NODL10	;[42] JUMP IF DL10 DOES NOT EXIST

STRPR2:	LSH	T3,3		;[42] SET MASK TO APPROPRIATE -11 EXIST BIT
	TRNE	T4,(T3)		;[42] TEST FOR EXIST & SKIP IF DOESN'T
	PUSHJ	P,EXST11	;[42] -11 EXISTS
	CAIL	T2,3		;[42] SKIP IF NOT LAST PORT ON DL10
	JRST	DL2CHK		;[42] LAST PORT - GO ON TO CHECK IF SECOND DL10
	ADDI	T2,1		;[42] INCREMENT COUNT OF PORTS TESTED
	JRST	STRPR2		;[42] CONTINUE TESTING PORTS

EXST11:	AOS	N.PORT		;[42] INCREMENT COUNT OF EXISTING PORTS
	MOVE	T1,N.DL10	;[42] DETERMINE ACTUAL PORTNO (0-7)
	IMULI	T1,4		;[42] ADJUST TO ACTUAL PORTNO
	ADD	T1,T2		;[42] PUT ACTUAL PORTNO IN T1
	MOVE	T5,N.PORT	;[42] STORE ACTUAL PORTNO
	SUBI	T5,1		;[42] ADJUST T5 SO TABLE OFFSET CORRECT
	MOVEM	T1,NAMPOR(T5)	;[42] 	IN TABLE
	POPJ	P,		;[42] RETURN TO PORT CHECKING

DL2CHK:	SKIPE	T1,N.DL10	;[42] CHECK IF THIS IS SECOND DL10
	JRST	STRPR3		;[42] YES, ALREADY SECOND
SAVSTS:	MOVE	T1,GSTS.	;[42] NO, STILL FIRST
	MOVEM	T1,TSTS.	;[42] SAVE GSTS. WHILE USING LOCATION
	MOVE	T1,[DATAI DLC2,] ;[42] SET UP FOR SECOND DL10
	MOVEM	T1,GSTS.	;[42]		AND SAVE
	AOS	N.DL10		;[42] INCREMENT COUNT OF CURRENT DL10 TO 2
	JRST	STRPR1		;[42] GO ON TO SECOND DL10 CHECK

NODL10:	SKIPN	T1,N.DL10	;[42] SKIP IF NOT ZERO (I.E.,SECOND DL10)
	JRST	[SETOM	F0.DL10 ;[42] HERE IF FIRST DL10
		 JRST	SAVSTS]	 ;[42] SET NO DL10 FLAG & CONTINUE
	SETOM	F1.DL10		;[42] HERE IF ALREADY SECOND DL10 SO
				;[42] 	SET NODL10 FLAG HERE

STRPR3:	MOVE	T1,TSTS.	;[42] RESTORE ORGINAL STATUS INFO
	MOVEM	T1,GSTS.	;[42]

	SKIPE	T1,N.PORT	;[42] SKIP IF NO PDP-11'S EXIST
	JRST	STRPR4		;[42] -11S EXIST ON SOME DL10
	SETZ	T1,		;[42] INITIALIZE AC FOR COMPARE
	SKIPE	T1,F0.DL10	;[42] NO -11S EXIST ON FIRST DL10
	TELLCR	DL10 No. 1 non-existent	;[42] NO, DL NO. 1 DOESN'T
	CAIN	T1,0		;[42] NO. 1 DOESN'T EXIST, SO SKIP
	TELLCR	No PDP-11s exist on DL10 No. 1	;[42] EXISTS BUT NO -11S ON DL10 NO. 1
	SETZ	T1,		;[42] INITIALIZE AC FOR COMPARE
	SKIPE	T1,F1.DL10	;[42] CHECK IF DL10 NO. 2 DOES
	TELLCR DL10 No. 2 non-existent	;[42] NO, DL NO. 2 DOESN't
	CAIN	T1,0		;[42] NO. 2 DOESN'T EXIST, SO SKIP
	TELLCR	No PDP-11s exist on dl10 no.  2	;[42] EXISTS BUT NO -11S ON DL10 NO. 2
	JRST	EXITX		;[42]

STRPR4:	MOVEI	T1,1		;[42] SEE IF JUST ONE -11 EXISTS
	CAMN	T1,N.PORT	;[42]
	JRST	STRPR6		;[42] YES, JUST ONE -11

	MOVEI	T1,0		;[42] NO, MORE THAN ONE -11
	TELLCR	PDP-11s exist on ports:	;[42]
STRPR5:	MOVE	T5,NAMPOR(T1)	;[42] OUTPUT PORTNO'S
	ERRCH	T5		;[42]
	ADDI	T1,1		;[42] 
	SOSE	N.PORT		;[42] DECREMENT COUNT
	JRST	STRPR5		;[42]
	OUTSTR	[ASCIZ\
\]				;[42] DONE: NOW PUT OUT CR-LF
	USEROR	PORT SWITCH REQUIRED	;[42] HERE WHEN ALL PORT NO'S OUTPUT

STRPR6:	MOVE	T1,A.PORT	;[42] THE ONE PDP-11 CASE
	CAME	T1,NAMPOR	;[42] CONTINUE IF DEFAULT IS ONLY EXIST
	ERRORC	PDP-11 only exists on port, T1	;[42]
	MOVE	T4,PAGADR	;[42] RESTORE T4
STRTU2:	STOP11			;STOP THE PDP-11
	MOVEI	T3,^D100000	;SET DEFENSIVE LOOP
STPLP:	GSTS11	T2		;GET -11 STATUS
	TDNE	T2,RN...	;SEE IF STOPPED YET
	SOJGE	T3,STPLP	;NO--TRY AGAIN
	JUMPGE	T3,.+2		;SEE IF OK
	ERROR	PDP-11 won't stop
	GTPI11	T3		;GET PI-CHANNEL
	ANDI	T3,GETPIC	;MASK TO IT ALONE
	CLRA11	((T3))		;CLEAR CONO
	CLRB11			;CLEAR DATAO
	BASE11	((T4))		;SET BASE ADDRESS (INC. LOCKED LOCTN)
	GSTS11	T1		;GET DEVICE STATUS
	TDC	T1,UP...	;TEST FOR EXIST
	TDCE	T1,UP...	;  AND RUN
	ERROR	PDP-11 absent or power off
	GTPI11			;GET PI-CHANNEL
	ANDI	T3,GETPIC	;MASK TO IT ALONE
	ENBL11	((T3))		;ENABLE -11 PORT
	STRT11			;START -11

	MOVE	T1,[^D10000000]	;[36],[44] SET LOOP COUNT FOR PROTECTION
	SKIPE	WATFLG(RB)	;IF THE PDP-11 HAS WOKEN UP,
				;IT WILL HAVE RESET THIS SWITCH
				;OTHERWISE, WAIT FOR IT .... PRIMARILY
	SOJGE	T1,.-1		;LOOP UNTIL OK OR DEAD
	JUMPGE	T1,.+2		;OK
	ERROR	PDP-11 won't start--check HALT switch
	RETURN
;ROUTINE TO CLEAR 11 UP TO C(A.CLR)-1
CLEAR:	TELLCR	Clearing PDP-11
	PUSHJ	P,CLRTRA	;CLEAR TRANSFER AREA
	MOVEI	P1,20		;INITIALIZE STORE COUNTER
CLEARL:	CAML	P1,A.CLR	;SEE IF DONE YET
	JRST	CLEARD		;DONE--GO CLEAN UP
	MOVEM	P1,BLOADR(RB)	;TELL -11 WHAT TO CLEAR
	MOVE	T1,A.CLR	;GET END OF CLEAR
	SUB	T1,P1		;COMPUTE DISTANCE TO GO
	CAIL	T1,20		;SEE IF MORE THAN 10 WORDS
	MOVEI	T1,20		;YES--JUST DO 10
	ADD	P1,T1		;ADVANCE DISTANCE DONE
	MOVEM	T1,BLOCNT(RB)	;TELL -11 HOW MUCH
	WAITON			;WAIT TO COMPLETE
	SKIPN	NXMADR(RB)	;SEE IF OUT OF CORE YET
	JRST	CLEARL		;LOOP FOR NEXT ONE

CLEARD:	SETZM	BLOADR(RB)	;AT END GO DO 0-17
	MOVE	T1,A.CLR	;GET END POINT
	CAIL	T1,20		;SEE IF GT 17
	MOVEI	T1,20		;YES--SET TO 17
	MOVEM	T1,BLOCNT(RB)	;TELL -11
	WAITON			;DO IT
	RETURN

;CLEAR DATA AREA IN TRANSFER BLOCK
CLRTRA:	SETZM	BLODAT(RB)	;CLEAR FIRST WORD
	MOVSI	T1,BLODAT(RB)	;POINT TO IT
	HRRI	T1,BLODAT+1(RB)	; AND NEXT ONE
	BLT	T1,BLODAT+7(RB)	;GO TO END
	RETURN

;WAIT HERE FOR 11 TO ANSWER THAT IT HAS COMPLETED
WAITIN:	MOVEI	T1,ONES11
	MOVEM	T1,WATFLG(RB)
	MOVE	T1,[^D10000000]	;[44] PROTECT AGAINST DEAD 11
	SKIPE	WATFLG(RB)
	SOJGE	T1,.-1		;LOOP UNTIL AWAKE
	JUMPGE	T1,.+2		;OK
	ERROR	PDP-11 took too long in transfer loop
	SETZM	BLOCNT(RB)	;CLEAR COUNTER
	SETZM	BLOADR(RB)	;CLEAR ADDRESS
	RETURN
;HERE WHEN ERROR AND TIME TO GIVE UP
EXITX:	JSP	T1,.+1		;GET PC BITS
	TLNE	T1,(1B6)	;SEE IF I/O MODE
	PUSHJ	P,HALTIT	;YES--STOP -11

;HERE TO RETURN TO MONITOR
GOHOME:	RESET			;GO RETURN TO MONITOR
	HLLZM	.JBINT##	;DEACTIVATE ^C INTERCEPT
	EXIT	1,
	EXIT

;ROUTINES TO STOP -11 AND CHECK FINAL STATUS
HALTIT:	MOVEI	T1,0		;SET FOR HALT
STOPIT:	MOVEM	T1,BLOCNT(RB)	;PLANT HALT OR JMP IN LOADER LISTEN LOOP
	AOS	WATFLG(RB)	;TELL -11 ABOUT STARTING
	ROT	T1,^D71		;WAIT ABOUT 20-30 US
	ROT	T1,^D71
	ROT	T1,^D71
	GTPI11	T2		;GET PI-CHANNEL
	ANDI	T2,GETPIC	;MASK TO IT ALONE
	DSAB11	((T2))		;DISABLE -11
	GSTS11	T1		;GET FINAL STATUS
	TDNE	T1,OK...	;SEE IF OK
	OUTSTR	[ASCIZ \? NXM or parity error in -10 memory
\]
	RETURN
	SUBTTL	COMMAND SCANNER

GETCOM:	OUTSTR	[ASCIZ /File: /]	;TELL USER WE ARE WAITING
COMLP:	PUSHJ	P,GETNAM	;GET A SIXBIT NAME
	JRST	.+2
COMFND:	MOVEI	T2,0		;CLEAR NAME
	MOVSI	T4,-BRKLEN	;LOOK FOR BREAK
	HLRZ	T3,BRKTAB(T4)	;TRY NEXT BREAK
	CAME	T1,T3		;SEE IF MATCH
	AOBJN	T4,.-2		;LOOP UNTIL MATCH
	HRRZ	T3,BRKTAB(T4)	;GET DISPATCH ADDRESS
	JRST	(T3)		;JUMP TO HANDLE BREAK

BRKTAB:	" ",,COMNOP		;SPACE IS A NO-OP
	".",,COMEXT		;DOT IS EXTENSION
	":",,COMDEV		;COLON IS DEVICE
	"[",,COMDIR		;BRAKET IS DIRECTORY
	"/",,COMSWT		;SLASH IS SWITCH
	12,,SAVNAM		;RETURN AT END OF LINE, AFTER SAVING FILE NAME
	32,,GOHOME		;IF ^Z
	3,,GOHOME		;IF ^C
BRKLEN==.-BRKTAB
	0,,COMERR		;ELSE, MUST BE ERROR

COMERR:	USEROR	Command error--type /H for help
COMNOP:	PUSHJ	P,SAVNAM	;STORE FILE NAME
	JRST	COMLP		;AND GO AROUND AGAIN

COMEXT:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETNAM	;GET SIXBIT NAME
	HLLOM	T2,EXT		;SAVE EXT WITH FLAG FOR DOT
	JRST	COMFND		;AND GO AROUND AGAIN

COMDEV:	MOVEM	T2,DEV		;SAVE DEVICE
	JRST	COMLP		;GO AROUND AGAIN

COMDIR:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETOCT	;GET OCTAL NOW
	CAIN	T1,"-"		;SEE IF DEFAULT
	JUMPE	T2,[PUSHJ P,GETCHR
		    JRST  COMDIX]
	HRLZ	T2,T2		;POSITION IT
	SKIPN	T2		;SKIP IF SOMETHING THERE
	GETPPN	T2,		;NO--GET FROM SYSTEM
	  JFCL
	HLLZM	T2,DIRECT	;SAVE FOR LATER
	CAIE	T1,","		;VERIFY COMMA
	JRST	COMERR		;NO--GIVE UP IN DISGUST
	PUSHJ	P,GETOCT	;GET PROGRAMMER
	SKIPN	T2		;SKIP IF SOMETHING THERE
	GETPPN	T2,		;ELSE ASK MONITOR
	  JFCL
	HRRM	T2,DIRECT	;STORE FOR LOOKUP
	CAIE	T1,","		;SEE IF SFD COMING
	JRST	COMDIX		;NO--GO FINISH UP
	MOVEI	T2,DIRPTH	;YES--SHIFT TO SFD
	EXCH	T2,DIRECT	; FORMAT
	MOVEM	T2,DIRPTH+2	; ..
	MOVSI	T4,-5		;MAX SFD COUNT
COMDIL:	PUSHJ	P,GETNAM	;GET SFD NAME
	JUMPE	T2,COMERR	;ERROR IF BLANK
	MOVEM	T2,DIRPTH+3(T4)	;STORE
	CAIN	T1,","		;SEE IF MORE
	AOBJN	T4,COMDIL	;YES--GO GET UNLESS TOO MANY
COMDIX:	CAIN	T1,"]"
	JRST	COMLP
	CAIN	T1,12
	JRST	COMFND
	JRST	COMERR

SAVNAM:	SKIPE	T2		;IF NAME,
	MOVEM	T2,NAME		; SAVE FOR LOOKUP
	POPJ	P,		;RETURN
;HERE WHEN SWITCH TO BE PROCESSED

COMSWT:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETNAM	;GET SIXBIT WORD
	MOVEI	T3,0		;PRESET MASK
	MOVSI	T4,770000	;PRESET CHARACTER
	TDNE	T2,T4		;IF CHARACTER,
	IOR	T3,T4		; INCLUDE IN MASK
	LSH	T4,-6		;MOVE OVER ONE
	JUMPN	T4,.-3		;LOOP FOR WORD
	SETO	T4,		;PRESET SUCCESS COUNTER
	MOVSI	P1,-SWTLEN	;PRESET LOOP
SWTLOP:	CAMN	T2,SWTTAB(P1)	;SEE IF EXACT MATCH
	JRST	SWTWIN		;YES--WIN
	MOVE	P2,SWTTAB(P1)	;NO--GET WORD
	XOR	P2,T2		;COMPARE WITH INPUT
	TDNE	P2,T3		;LOOK THROUGH MASK
	JRST	.+3		;NO--KEEP TRYING
	AOS	T4		;COUNT MATCH
	MOVE	P3,P1		;SAVE POINTER
	AOBJN	P1,SWTLOP	;SEE IF DONE YET
	MOVE	P1,P3		;RESTORE WINNER
	JUMPE	T4,SWTWIN	;SEE IF JUST ONE MATCH
	SKIPGE	T4
	USEROR	Unknown switch--type /H for help
	USEROR	Ambiguous switch--type /H for help
SWTWIN:	HLRZ	T2,SWTVAL(P1)	;GET DEFAULT VALUE
	PUSHJ	P,SWTPRT	;[42] GO SEE IF WE ARE DEFAULTING PORTNO
	CAIN	T1,":"		;SEE IF VALUE TYPED IN
	PUSHJ	P,GETOCT	;YES--GET OCTAL NUMBER
	HRRZ	T3,SWTVAL(P1)	;GET ADDRESS OF SWITCH
	JUMPE	T3,HELP		;NONE--MUST BE /H
	MOVEM	T2,(T3)		;STORE ANSWER
	JRST	COMFND		;GO HANDLE BREAK

SWTPRT:	MOVE	T5,[SIXBIT/PORTNO/]	;[42] CHECK IF PORT SWITCH DEFAULT
	CAME	T5,SWTTAB(P1)		;[42]	BEING PROCESSED
	RETURN			;[42] NO, NOT PORTNO: CONTINUE
	CAIN	T1,":"		;[42] YES, PORTNO- NOW CHECK IF VALUE SUPPLIED
	SETZM	F.PORT		;[42] VALUE SUPPLIED SO TURN OFF DEFAULT FLAG
	RETURN			;[42] CONTIUE PROCESSING SWITCH
SWTTAB:	SIXBIT	/CLEAR/
	SIXBIT	/DUMP/
	SIXBIT	/END/
	SIXBIT	/HELP/
	SIXBIT	/IMAGE/
	SIXBIT	/LOAD/
	SIXBIT	/PORTNO/
	SIXBIT	/START/
	SIXBIT	/NOLOG/
SWTLEN==.-SWTTAB
SWTVAL:	V.CLR,,A.CLR		;DEFAULT,,LOCATION
	V.DUMP,,A.DUMP
	V.END,,A.END
	0
	0,,A.IMAG
	0,,A.LOAD
	0,,A.PORT
	0,,A.STRT
	0,,A.NLOG


;HERE IF /HELP
HELP:	CAIN	T1,12		;SEE IF AT END OF LINE YET
	JRST	HELP1		;YES--GO DO THE HELP
	PUSHJ	P,GETCHR	;NO--GET ANOTHER CHAR
	JRST	HELP		;AND LOOP
HELP1:	MOVE	1,['BOOT11']
	PUSHJ	P,.HELPR##
	JRST	START
GETNAM:	MOVE	T3,[POINT 6,T2]
	MOVEI	T2,0		;CLEAR NAME
GETNM1:	PUSHJ	P,GETCHR	;GET NEXT CHAR
	CAIL	T1,"A"+40	;SEE IF LC
	CAILE	T1,"Z"+40
	JRST	.+2
	SUBI	T1,40		;YES--MAKE UC
	CAIL	T1,"0"		;SEE IF BREAK
	CAILE	T1,"Z"		; ..
	RETURN
	CAILE	T1,"9"		;OR OK
	CAIL	T1,"A"
	JRST	.+2
	RETURN
	SUBI	T1,40		;CONVERT TO SIXBIT
	TLNE	T3,770000	;SEE IF OVERFLOW
	IDPB	T1,T3		;STORE RESULT
	JRST	GETNM1		;LOOP FOR MORE

GETOCT:	MOVEI	T2,0		;CLEAR RESULT
GETOC1:	PUSHJ	P,GETCHR	;GET NEXT ODGIT
	CAIL	T1,"0"		;SEE IF
	CAILE	T1,"7"		; BREAK
	RETURN
	LSH	T2,3		;MULT BY 8
	ADDI	T2,-"0"(T1)	;INCLUDE ODGIT
	JRST	GETOC1		;LOOP

GETCHR:	INCHWL	T1		;GET NEXT CHARACTER
	JUMPE	T1,GETCHR	;LOOP IF NULL
	CAIE	T1,177		;IF RUB
	CAIN	T1,15		;OR CR
	JRST	GETCHR		;LOOP
	CAIL	T1,175		;IF ALTERNATE ALT MODE
	MOVEI	T1,33		; STANDARDIZE
	CAIN	T1,33		;IF ESCAPE
	MOVEI	T1,12		; MAKE INTO EOL
	CAIE	T1,13		;IF VTAB
	CAIN	T1,14		; OR FORM
	MOVEI	T1,12		; MAKE INTO LF
	CAIN	T1,11		;SEE IF TAB
	MOVEI	T1," "		;YES, CHANGE TO SPACE
	RETURN
SUBTTL	HEADER CONSTRUCTION SUBROUTINES

HEDTXT:	POP	P,T2		;PRINT STRING, CALLED WITH PUSHJ
	HRLI	T2,440700	;CHANGE PC TO BYTE POINTER
HEDTX2:	ILDB	T1,T2		;GET NEXT BYTE
	JUMPE	T1,1(T2)	;RETURN ON 0 CHARACTER
	PUSHJ	P,HEDCHR	;PRINT CHARACTER
	JRST	HEDTX2		;LOOP FOR MORE

HEDOCT:	TDZA	T3,T3		;PRINT OCTAL NUMBER, CALLED BY PUSHJ
HEDDEC:	MOVEI	T3,2		;PRINT DECIMAL NUM, CALLED BY PUSHJ
	MOVE	T4,T3		;FOR DECIMAL NUMS, FORCE 2 DIGITS
HEDNUM:	IDIVI	T1,10(T3)
	HRLM	T1+1,(P)
	SOSG	T4		;FORCE DIGITS
	SKIPE	T1
	PUSHJ	P,HEDNUM
	HLRZ	T1,(P)
HEDDIG:	ADDI	T1,"0"		;PRINT DIGIT
HEDCHR:	IDPB	T1,HEDPNT	;PRINT CHARACTER
	POPJ	P,

HED7:	MOVEI	T2,5		;PRINT 5 ASCII CHARS, CALLED BY PUSHJ
HED7A:	ROT	T1,7		;GET NEXT CHARACTER
	TRNE	T1,177		;SKIP IF NULL
	PUSHJ	P,HEDCHR
	SOJG	T2,HED7A	;LOOP UNTIL 5 PRINTED
	POPJ	P,
	SUBTTL	DAEMON -- INTERFACE TO THE DAEMON ERROR-REPORTING ROUTINES

;SYSERR FUNCTIONS 202/203 (DUMP & LOAD)
;THE FORMAT OF THE SYSERR BLOCK IS:
; -2	.DMERR			;DAEMON ERROR REPORT FUNCTION CODE
; -1	"CODE"			;EITHER 202(LOAD) OR 203(DUMP)
;  0	TARGET			;POINTER TO THE NAME OF THE NODE LOADED/DUMPED
; +1	SERVER			;NAME OF THE NODE THAT LOADED/DUMPED THE OTHER
; +2	LINE			;NAME OF THE LINE LOADED/DUMPED
; +3	FILE			;POINTER TO THE FILE LOADED/DUMPED
; +4	RTN-CODE		;VALUE IS THE "NSP" RETURN CODE
; +5	PRG-NAME		;THE NAME OF THE PROGRAM DOING THE LOAD/DUMP
; +6	VALUE			;36 BITS OF "VALUE" RETURNED BY THE PROGRAM

ERRLOA:	SKIPA	T1,[XWD .ESNDL,LODFIL] ;HERE TO REPORT A DOWN LINE LOAD
ERRDMP:	MOVE	T1,[XWD .ESNUD,DMPFIL] ;HERE TO REPORT AN UP LINE DUMP
	SKIPL	A.NLOG		;IF "NOLOG" WAS REQUESTED
	RETURN			;  THEN DON'T LOG ANYTHING
	PUSH	P,T1		;SAVE "XWD DAEMON-CODE,FILE-SPEC-ADDRESS"

;CLEAR THE ERROR BLOCK
	SETZM	ERRFZR		;CLEAR THE FIRST WORD OF THE ERROR REPORT BLOCK
	MOVE	T2,[XWD ERRFZR,ERRFZR+1] ;GET A BLT POINTER TO THE BLOCK
	BLT	T2,ERRLZR	;  AND PROPAGATE THE CLEAR

;SET UP A BYTE POINTER TO THE "FREE SPACE" IN THE BLOCK
	MOVE	P1,[POINT 7,ERRFRE] ;P1 WILL ALWAYS HAVE A 7 BIT BYTE POINTER
	HRROI	T1,-ERRBLK(P1)	;T1 STARTS WITH A "SYSERR" POINTER.

;DAEMON FUNCTION CODE
	MOVEI	T2,.DMERR	;DAEMON ERROR REPORT
	MOVEM	T2,ERRFCN	;STORE THE FUNCTION CODE

;SYSERR FUNCTION CODE
	HLRZ	T2,(P)		;GET THE CODE OFF THE STACK
	MOVEM	T2,ERRCOD	;  AND STORE IT IN THE BLOCK

;TARGET NODE NAME (WE DON'T KNOW WHAT IT IS...)
	MOVEM	T1,ERRTRG	;SAVE A POINTER TO THE TARGET NAME
	MOVEI	T1,[ASCIZ /Not Applicable/]
	PUSHJ	P,ERRASC	;WRITE THE "NAME"
	PUSHJ	P,ERRNPT	;  AND CLOSE OFF THE FIELD.

;SERVER NODE (TRY SEVERAL WAYS TO GET OUR NAME AND RETURN THAT)
	MOVEM	T1,ERRSER	;SAVE A POINTER TO WHERE WE WILL PUT THE NAME
	MOVSI	T1,'CTY'	;ASK WHERE OUR "CTY" IS
	WHERE	T1,		;  AND THAT SHOULD GIVE US OUR NODE NUMBER
	  JRST	ERRLD1		;IF NO NETWORKS, GO RETURN "SYSNAM" INSTEAD
	PUSH	P,T1		;SAVE OUR NODE NUMBER FOR A BIT
	MOVE	T3,T1		;COPY THE NODE NUMBER FOR THE NEXT CALL
	MOVE	T1,[XWD .NDRNN,T2] ;SET UP FOR A NODE. UUO
	MOVEI	T2,2		;  THAT WILL TRANSLATE THE
	NODE.	T1,		;  NODE NUMBER INTO A SIXBIT NAME
	  JRST	[POP P,(P)	;??? SHOULDN'T HAPPEN.  MUST BE A DN60 ONLY SYS.
		 JRST ERRLD1]	;??? FIXUP STACK AND USE "SYSNAM" INSTEAD.
	PUSHJ	P,ERRSIX	;WRITE OUT THE SIXBIT NAME
	MOVEI	T1,"("		;GET THE OPEN PARENTHESIS
	PUSHJ	P,ERRCHR	;  AND WRITE THAT OUT.
	POP	P,T1		;GET OUR NODE NUMBER BACK
	PUSHJ	P,ERROCT	;  AND WRITE THAT
	MOVEI	T1,")"		;GET THE CLOSING PARENTHESIS
	PUSHJ	P,ERRCHR	;  AND CLOSE OFF THE NODE(NUM) SPEC
	JRST	ERRLD4		;GO TO COMMON CODE TO CLOSE OFF THE FIELD.

;HERE IF WE CAN'T GET OUR NODE NAME IN THE "NAME(NNM)" FORM.  USE SYSNAM INSTEAD
ERRLD1:	MOVEI	T1,0		;START WITH THE FIRST WORD OF "SYSNAM"
ERRLD2:	MOVEI	T2,.GTCNF	;THE NAME IS IN THE "CONFIGURATION TABLE"
	HRLI	T2,(T1)		;  STARTING AT "%CNFG0"
	GETTAB	T2,		;GET THE NEXT WORD OF THE NAME
	  JRST	[MOVEI T1,[ASCIZ /Couldn't read system's name./]
		 JRST ERRLD3]	;WE TRIED. WRITE THIS ERROR MSG INSTEAD.
	MOVEM	T2,SYSNAM(T1)	;STORE THE NEXT CHAR OF THE NAME
	CAIE	T1,4		;IF WE HAVEN'T READ ALL OF THE NAMES YET,
	AOJA	T1,ERRLD2	;  THEN GO BACK AND GET THE NEXT ONE
	MOVEI	T1,SYSNAM	;GET THE ADDRESS OF THE SYSTEM NAME
ERRLD3:	PUSHJ	P,ERRASC	;WRITE THE SYSTEM NAME INTO THE DAEMON MSG
ERRLD4:	PUSHJ	P,ERRNPT	;GET A "NEW POINTER" FOR THE NEXT FIELD.

;LINE DESIGNATOR (CPU:N, DTE:M)
	MOVEM	T1,ERRSLD	;SAVE THE POINTER TO THE LINE SPEC
	MOVEI	T1,[ASCIZ /DL-10 Port:/]
	PUSHJ	P,ERRASC	;WRITE OUT THE NOISE PART
	MOVE	T1,A.PORT	;GET THE PORT NUMBER
	PUSHJ	P,ERRDEC	;  AND WRITE OUT THE LAST FIELD.
	PUSHJ	P,ERRNPT	;GET A "NEW POINTER" TO THE NEXT FIELD

;FILE SPEC LOADED FROM OR DUMPED TO.
	MOVEM	T1,ERRFIL	;SAVE THE POINTER TO THE ASCII FILE SPEC
	POP	P,T3		;GET THE ADDRESS OF THE FILE SPEC BLOCK
	HRRZ	T1,T3		;COPY IT FOR ERRFSP
	PUSHJ	P,ERRFSP	;WRITE THE FILE SPEC INTO THE BLOCK
	PUSHJ	P,ERRNPT	;  AND CLOSE OFF THIS FIELD.

;NSP "RETURN CODE"
	MOVEI	T2,1		;"SUCCESS"
	MOVEM	T2,ERRRTN	;STORE THE CODE

;PROGRAM NAME (AND WHO RAN IT)
	MOVEM	T1,ERRPRG	;STORE A POINTER TO THE NAME STRING
	PUSHJ	P,ERRPGM	;GO WRITE OUT THE PROGRAM NAME
	MOVEI	T1,[ASCIZ /  By:/] ;GET A "DELIMETER"
	PUSHJ	P,ERRASC	;  AND WRITE THAT
	PUSHJ	P,ERRUNM	;NOW WRITE OUT THE USER'S NAME & PPN
	PUSHJ	P,ERRNPT	;  AND CLOSE OFF THIS FIELD

;NOW THE 36 BITS OF "VALUE" FOR SYSERR TO TYPE OUT
	MOVEI	T2,0		;JUST USE A
	MOVEM	T2,ERRVAL	;  ZERO.

;NOW DO THE DAEMON UUO (RH(T1) HAS THE LENGTH OF THE BLOCK)
	MOVSI	T1,2(T1)	;GET THE LENGTH (PLUS 2) IN THE LH
	HRRI	T1,ERRFCN	;GET THE ADDRESS OF THE FUNCTION BLOCK
	DAEMON	T1,		;DO THE DAEMON UUO
	  JRST	ERRDUF		;THE DAEMON UUO FAILED. GO PRINT AN ERROR
	RETURN			;ALL DONE WITH THE REPORT.
;SUBROUTINES TO WRITE VARIOUS ITEMS INTO THE DAEMON ERROR-REPORT BLOCK

;ROUTINE TO FORCE THE BYTE POINTER IN P1 TO START ON THE NEXT WORD
ERRNPT:	SETZ	T1,		;GET A ZERO,
	PUSHJ	P,ERRCHR	;  AND CLOSE OFF THIS FIELD
	MOVEI	P1,1(P1)	;GET THE ADDRESS OF THE NEXT WORD
	HRLI	P1,(POINT 7,0)	;  AND COMPLETE THE BYTE POINTER
	HRROI	T1,-ERRBLK(P1)	;MAKE T1 BE A "SYSERR" POINTER TO THE STRING
	SETZ	P2,		;CLEAR THE COUNT
	RETURN			;  AND WE'RE DONE

;ROUTINE TO COPY AN ASCIZ STRING INTO THE BLOCK
ERRASC:	PUSH	P,T2		;PRESERVE T2
	HRLI	T1,(POINT 7,0)	;MAKE THE ADDRESS A BYTE POINTER
	ILDB	T2,T1		;GET THE FIRST BYTE
	JUMPN	T2,[IDPB T2,P1	;STORE THE BYTE IN THE BLOCK
		    ILDB T2,T1	;GET THE NEXT BYTE
		    AOJA P2,.]	;COUNT THE BYTE AND LOOP.
	POP	P,T2		;RESTORE THE TEMP
	RETURN			;  AND WE'RE DONE

;ROUTINE TO OUTPUT THE SIXBIT STRING IN T1
ERRSIX:	PUSH	P,T2		;SAVE A TEMP
	PUSH	P,T3		; ..
	MOVE	T3,T1		;COPY THE NAME INTO T3
	MOVE	T2,[POINT 6,T3]	;GET A BYTE POINTER TO THE SIXBIT STRING
ERRSI1:	ILDB	T1,T2		;GET THE NEXT BYTE
	JUMPE	T1,RTN32	;IF WE'RE DONE, FIXUP THE STACK AND RETURN
	ADDI	T1,"0"-'0'	;MAKE THE CHAR ASCII
	PUSHJ	P,ERRCHR	;WRITE THE CHAR
	TLNE	T2,770000	;SEE IF WE'VE GOT ALL 6 BYTES
	JRST	ERRSI1		;LOOP OVER ALL 6 BYTES
	JRST	RTN32		;FIXUP THE STACK AND RETURN

;ROUTINE TO PUT THE CHAR IN "T1" INTO THE OUTPUT STRING
ERRCHR:	IDPB	T1,P1		;STORE THE CHAR
	AOS	P2		;COUNT THE CHAR
	RETURN
;ROUTINES TO WRITE NUMBERS INTO THE FILE

;ROUTINE TO WRITE AN OCTAL NUMBER INTO THE OUTPUT BLOCK
ERROCT:	PUSH	P,T2		;GET A TEMP
	PUSH	P,T3		; ..
	MOVEI	T3,^D8		;GET THE "BASE"
	PUSHJ	P,ERRPNT	;GO PRINT THE NUMBER
	JRST	RTN32		;CLEAN UP AND RETURN

;ROUTINE TO WRITE A DECIMAL NUMBER INTO THE OUTPUT BLOCK
ERRDEC:	PUSH	P,T2		;GET A TEMP
	PUSH	P,T2		; ..
	MOVEI	T3,^D10		;GET THE "BASE"
	PUSHJ	P,ERRPNT	;GO PRINT THE NUMBER
RTN32:	POP	P,T3		;RESTORE T3
	POP	P,T2		;  AND T2
	RETURN			;ALL DONE

;ROUTINE TO WRITE AN ARBITRARY NUMBER TO THE OUTPUT BLOCK
;T1 := NUMBER, T3 := THE BASE, T2 := SCRATCH
ERRPNT:	IDIV	T1,T3		;GET THE NEXT DIGIT
	HRLM	T2,(P)		;SAVE THE REMAINDER
	SKIPE	T1		;IF THERE IS MORE TO DO,
	PUSHJ	P,ERRPNT	;  THEN GO DO IT
	HLRZ	T1,(P)		;GET THE DIGIT
	ADDI	T1,"0"		;MAKE IT ASCII
	PUSHJ	P,ERRCHR	;WRITE THE CHARACTER
	RETURN			;  AND WE'RE DONE.
;ROUTINE TO OUTPUT A PPN IN THE FORM "[P,PN]"
ERRPPN:	PUSH	P,T1		;SAVE THE PPN
	MOVEI	T1,"["		;GET THE OPEN SQUARE
	PUSHJ	P,ERRCHR	;  AND PUT THAT IN THE MESSAGE
	HLRZ	T1,(P)		;GET THE "P"
	PUSHJ	P,ERROCT	;  AND PRINT THAT IN OCTAL
	MOVEI	T1,","		;GET THE SEPARATOR
	PUSHJ	P,ERRCHR	;  OUT IT GOES
	POP	P,T1		;GET THE PPN BACK
	HRRZ	T1,T1		;GET JUST THE "PN"
	PUSHJ	P,ERROCT	;  AND PRINT THAT
	MOVEI	T1,"]"		;GET THE CLOSING SQUARE
	JRST	ERRCHR		;  PRINT THAT AND RETURN
;ROUTINE TO PRINT THE USER'S NAME AND PPN.
ERRUNM:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;  T3
	PUSH	P,T1		;  AND T1
	PJOB	T1,		;GET OUR JOB NUMBER
	MOVSI	T2,(T1)		;PUT IT IN THE "LH"
	HRRI	T2,.GTNM1	;TABLE TO GET FIRST HALF OF THE USER'S NAME
	GETTAB	T2,		;GET THE FIRST HALF OF THE USERS NAME
	  SETZ	T2,		;ZERO IF NOT AVAILABLE
	MOVSI	T3,(T1)		;GET THE JOB NUMBER AGAIN
	HRRI	T3,.GTNM2	;TABLE WITH THE SECOND HALF OF THE USER'S NAME
	GETTAB	T3,		;GET THE SECOND HALF
	  SETZ	T3,		;ZERO IF STILL NOT AVAILABLE
	SKIPN	T2		;IF BOTH THE FIRST
	JUMPE	T3,ERRNU2	;  AND LAST ARE ZERO, DON'T HACK THE NAME

	TLNN	T2,770000	;STRIP LEADING SPACES OFF OF THE NAME
	JRST	[LSHC T2,6	;IF FIRST CHAR IS A SPACE, THROW IT AWAY
		 JRST .-1]	;  AND GO CHECK THE NEXT ONE.

ERRNU1:	LDB	T1,[POINT 6,T2,5] ;GET THE FIRST CHARACTER
	ADDI	T1,"0"-'0'	;ASCII-IZE THE CHARACTER
	PUSHJ	P,ERRCHR	;OUTPUT THE CHARACTER
	LSHC	T2,6		;SHIFT TO THE NEXT CHARACTER
	JUMPN	T2,ERRNU1	;  AND IF THERE ARE ANY MORE
	JUMPN	T3,ERRNU1	;  THEN OUTPUT THEM TOO.

ERRNU2:	PJOB	T1,		;GET OUR JOB NUMBER BACK
	MOVSI	T1,(T1)		;  AND PUT IT IN THE LH
	HRRI	T1,.GTPPN	;WE WANT OUR PPN
	GETTAB	T1,		;GET OUR PPN
	  SETZ	T1,		;???
	PUSHJ	P,ERRPPN	;OUTPUT THE PPN
	POP	P,T1		;RESTORE T1
	JRST	RTN32		;RESTORE T3 & T2 AND RETURN
;ROUTINE TO OUTPUT THE NAME OF THE PROGRAM.
ERRPGM:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;  AND T3
	PJOB	T3,		;GET OUR JOB NUMBER IN "T3"
	MOVEI	T1,.GTPRG	;GET THE PROGRAM
	HRLI	T1,(T3)		;  FIRST
	GETTAB	T1,		;GETTAB THE PROGRAM NAME
	  JRST	ERRPGX		;JUST RETURN 'BOOT11' IF WE FAIL
	PUSHJ	P,ERRSIX	;OUTPUT THE NAME IN SIXBIT
	MOVEI	T1,[ASCIZ /  From:  /]
	PUSHJ	P,ERRASC	;OUTPUT A "DELIMITER"
	MOVEI	T1,.GTRDV	;FIRST GET THE DEVICE THE JOB WAS
	HRLI	T1,(T3)		;  RUN FROM.
	GETTAB	T1,		;GETTAB THE DEVICE.
	  JRST	ERRPGX		;IF NO LUCK RETURN 'BOOT11'
	PUSHJ	P,ERRSIX	;OUTPUT THE NAME AS SIXBIT
	MOVEI	T1,":"		;GET THE COLON
	PUSHJ	P,ERRCHR	;  AND OUTPUT THE DEVICE SEPARATOR
	MOVEI	T1,.GTRFN	;GET THE FILE NAME
	HRLI	T1,(T3)		;  INDEXED BY OUR JOB NUMBER
	GETTAB	T1,		;GETTAB THE FILE NAME WE WERE RUN FROM
	  JRST	ERRPGX		;.. RETURN 'BOOT11'
	PUSHJ	P,ERRSIX	;OUTPUT THE NAME AS SIXBIT
;? OUTPUT .EXT
	MOVEI	T1,"["		;GET THE OPEN SQUARE
	PUSHJ	P,ERRCHR	;  AND OUTPUT IT
	MOVEI	T1,.GTRDI	;GET THE DIRECTORY WE WERE RUN FROM
	HRLI	T1,(T3)		;  INDEXED BY OUR
	GETTAB	T1,		;  JOB NUMBER
	  JRST	ERRPGX		;IF FAIL... RETURN 'BOOT11'
	HRRZ	T2,T1		;SAVE THE "PN"
	HLRZ	T1,T1		;GET THE "P"
	PUSHJ	P,ERROCT	;WRITE THE PROJECT
	MOVEI	T1,","		;GET THE DELIMITER
	PUSHJ	P,ERRCHR	;  AND WRITE IT
	MOVE	T1,T2		;GET THE "PN"
	PUSHJ	P,ERROCT	;WRITE THE PROGRAMMER NUMBER.

;NOW READ THE SFD CHAIN
	SETZ	T2,		;START WITH A ZERO
ERRPG1:	MOVEI	T1,.GTRS0(T2)	;GET THE NEXT SFD TO LOOK FOR
	HRLI	T1,(T3)		;  AND INDEX IT BY OUR JOB NUMBER
	GETTAB	T1,		;FETCH THE SFD
	  JRST	ERRPG2		;IF WE FAIL, SAY WE'RE "DONE" WITH THE SFD;S
	JUMPE	T1,ERRPG2	;  A ZERO ALSO TERMINATES THE LIST
	PUSH	P,T1		;SAVE THE NAME FOR A BIT
	MOVEI	T1,","		;GET THE COMMA
	PUSHJ	P,ERRCHR	;  OUTPUT THE DELIMITER
	POP	P,T1		;GET THE NAME BACK
	PUSHJ	P,ERRSIX	;  AND OUTPUT IT IN SIXBIT
	CAIG	T2,4		;QUIT IF WE'VE READ ALL 5
	AOJA	T2,ERRPG1	;LOOP OVER ALL SFD'S
ERRPG2:	MOVEI	T1,"]"		;GET THE CLOSE SQUARE
	PUSHJ	P,ERRCHR	;  AND WRITE IT OUT
	JRST	RTN32		;CLEAN UP THE STACK AND EXIT

ERRPGX:	MOVE	T1,[SIXBIT /BOOT11/] ;IF ALL ELSE FAILS,
	PUSHJ	P,ERRSIX	;  THEN OUTPUT 'BOOT11'
	JRST	RTN32		;CLEAN UP THE STACK AND RETURN
;ROUTINE TO OUTPUT A FILE SPEC TO THE ERROR BLOCK
;CALL	T1 := POINTER TO A FILE SPEC OF THE FORM
; +0	FILE NAME
; +1	EXT
; +2	DEVICE
; +3	RANDOM BITS (PATH.)
; +4	PPN
; +5	SFD #1
; +6	SFD #2
;   ...
;	0
ERRFSP:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;  AND T3
	MOVEI	T3,(T1)		;GET THE POINTER INTO T3 (FOR SEMI PERMANENCE)
	MOVE	T1,ERFSDV(T3)	;GET THE DEVICE
	PUSHJ	P,ERRSIX	;  AND WRITE THAT OUT IN SIXBUT
	MOVEI	T1,":"		;GET A COLON
	PUSHJ	P,ERRCHR	;  AND WRITE THE SEPARATOR
	MOVE	T1,ERFSFN(T3)	;GET THE FILE NAME
	PUSHJ	P,ERRSIX	;  AND WRITE IT IN SIXBIT
	MOVEI	T1,"."		;GET A DOT
	PUSHJ	P,ERRCHR	;WRITE THE SEPARATOR
	MOVE	T1,ERFSEX(T3)	;GET THE EXTENSION
	PUSHJ	P,ERRSIX	;  AND WRITE THAT.
	MOVEI	T1,"["		;GET THE OPEN SQUARE
	PUSHJ	P,ERRCHR	;  WRITE THE START OF THE PATH SPEC
	HLRZ	T1,ERFSPN(T3)	;GET THE "P"
	PUSHJ	P,ERROCT	;  WRITE THE PROJECT NUMBER IN OCTAL
	MOVEI	T1,","		;GET A COMMA
	PUSHJ	P,ERRCHR	;  AND USE IT TO SEPARATE THE P,PN
	HRRZ	T1,ERFSPN(T3)	;GET THE "PN"
	PUSHJ	P,ERROCT	;  WRITE THE PROGRAMMER NUMBER IN OCTAL
	MOVEI	T2,ERFSSF(T3)	;GET THE ADDRESS OF THE SFD SPEC
	SKIPE	(T2)		;  IF WE'RE NOT PAST THE END OF THE SPEC
	JRST	[MOVEI T1,","	;GET AND OUTPUT
		 PUSHJ P,ERRCHR	;  A SEPARATOR
		 MOVE T1,(T2)	;GET THE SFD NAME
		 PUSHJ P,ERRSIX	;  AND OUTPUT IT IN SIXBIT
		 AOJA T2,.-1]	;LOOP OVER ALL SFD NAMES.

	MOVEI	T1,"]"		;GET THE CLOSING SQUARE
	PUSHJ	P,ERRCHR	;  AND WRITE THAT
	JRST	RTN32		;RESTORE THE AC'S AND RETURN
;ROUTINE TO TYPE OUT INFORMATION REGARDING A DAEMON UUO ERROR
ERRDUF:	WARNCR	DAEMON UUO error while trying to append to ERROR.SYS.
	CAILE	T1,0		;NOW RANGE CHECK THE ERROR CODE
	CAILE	T1,DAEMLN-1	;  AND IF IT IS ONE WE DON'T KNOW ABOUT
	JRST	[WARN <Unknown error =  >
		 PUSHJ P,TYPOCT
		 JRST TYPCRL]	;END THE LINE AND RETURN
	WARN	<Reason: >
	OUTSTR	@DAEERM(T1)	;PRINT THE ERROR
	PUSHJ	P,TYPCRL	;MAKE THINGS NEAT WITH A CLOSING CRLF
	RETURN			;  AND RETURN


DAEERM:	[ASCIZ	/Unknown DAEMON UUO error code = /]
	[ASCIZ	/Illegal function code was specified./]
	[ASCIZ	/Adderss check occured during UUO process./]
	[ASCIZ	/Incorrect number of arguments for UUO./]
	[ASCIZ	/Impossible error number 4./]
	[ASCIZ	/File cannot be written./]
	[ASCIZ	/Program does not have privileges required./]
	[ASCIZ	/Invalid FACT entry format./]
	[ASCIZ	/Invalid PATH specification for UUO./]
DAEMLN=	.-DAEERM
;STANDARD ROUTINE TO PRINT STANDARD OCTAL NUMBERS WITH STANDARD AC USAGE
TYPOCT:	IDIVI	T1,^D8		;EXTRACT LEADING OCTIT
	JUMPE	T1,TYPOC1	;IF LAST ONE, LEAVE RECURSIVE LOOP
	HRLM	T2,(P)		;SAVE IT FOR LATER PRINTING
	PUSHJ	P,TYPOCT	;DO PRECEDING
	HLRZ	T2,(P)		;GET IT BACK
TYPOC1:	ADDI	T2,"0"		;ASCIIIZE
	OUTCHR	T2		;REALLY WISH WE HAD BUFFERED IO...
	RETURN


;ROUTINE TO PRINT SIXBIT NAMES
TYPSIX:	PUSH	P,T2		;SAVE A TEMP
	PUSH	P,T3		; ..
	MOVE	T3,T1		;COPY THE NAME INTO T3
	MOVE	T2,[POINT 6,T3]	;GET A BYTE POINTER TO THE SIXBIT STRING
TYPSI1:	ILDB	T1,T2		;GET THE NEXT BYTE
	JUMPE	T1,RTN32	;IF WE'RE DONE, FIXUP THE STACK AND RETURN
	ADDI	T1,"0"-'0'	;MAKE THE CHAR ASCII
	OUTCHR	T1		;TYPE THE CHARACTER
	TLNE	T2,770000	;SEE IF WE'VE GOT ALL 6 BYTES
	JRST	TYPSI1		;LOOP OVER ALL 6 BYTES
	JRST	RTN32		;FIXUP THE STACK AND RETURN

;ROUTINE TO TYPE A CRLF
TYPCRL:	OUTSTR	[ASCIZ /
/]
	RETURN
;ROUTINE TO TYPE OUT A FILE SPEC
TYPFIL:	PUSH	P,T2		;SAVE A TEMP
	PUSH	P,T3		;  AND ANOTHER
	MOVE	T3,T1		;PUT THE FILESPEC ADDR IN T3
	MOVE	T1,ERFSDV(T3)	;GET THE DEVICE
	PUSHJ	P,TYPSIX	;  AND OUTPUT IT IN SIXBIT
	OUTCHR	[":"]		;TYPE A SEPARATING COLON
	MOVE	T1,ERFSFN(T3)	;GET THE FILENAME
	PUSHJ	P,TYPSIX	;  AND OUTPUT IT IN SIXBIT
	OUTCHR	["."]		;TYPE A SEPARATING PERIOD
	MOVE	T1,ERFSEX(T3)	;GET THE EXTENSION
	PUSHJ	P,TYPSIX	;  AND OUTPUT THAT IN SIXBIT
	OUTCHR	["["]		;OUTPUT THE OPEN SQUARE
	HLRZ	T1,ERFSPN(T3)	;GET THE "P"
	PUSHJ	P,TYPOCT	;  AND PRINT THAT IN OCTAL
	OUTCHR	[","]		;SEPARATE THE P & PN WITH A COMMA
	HRRZ	T1,ERFSPN(T3)	;GET THE "PN"
	PUSHJ	P,TYPOCT	;  AND PRINT THAT IN OCTAL
	MOVEI	T2,ERFSSF(T3)	;GET THE ADDRESS OF THE FIRST SFD
	SKIPE	(T2)		;HAVE WE DONE ALL THE SFD'S YET?
	JRST	[OUTCHR [","]	;OUTPUT THE SEPARATOR FOR THE NEXT SFD
		 MOVE T1,(T2)	;GET THE SFD NAME
		 PUSHJ P,TYPSIX	;  AND TYPE IT IN SIXBIT
		 AOJA T2,.-1]	;LOOP OVER ALL SFD'S
	OUTCHR	["]"]		;OUTPUT THE CLOSING SQUARE
	JRST	RTN32		;CLEAN UP THE STACK AND WE'RE DONE
SUBTTL STORAGE
	XLIST	;LITERALS
	LIT
	LIST

HEDPNT:	BLOCK	1		;POINTER FOR CONSTRUCTING HEADER
HEADER:	BLOCK	^D20		;BLOCK FOR HEADER
HEDEND:

CCINT:	EXITX		;^C INTERCEPT BLOCK
	1B34
CCINTP:	Z
	Z


FWAZER:!		;START OF AREA TO CLEAR

PDLST:	BLOCK	PDSIZ+1
DEV:	BLOCK	1		;DEVICE
NAME:	BLOCK	1		;FILE NAME
EXT:	BLOCK	1		;FILE EXTENSION,,-1 IF . SEEN
DIRECT:	BLOCK	1		;DIRECTORY
DIRPTH:	BLOCK	9		;SFD PATH

INHDR:	BLOCK	3		;INPUT HEADER
OUTHDR:	BLOCK	3		;OUTPUT HEADER
ADDRES:	BLOCK	1
CHKSUM:	BLOCK	1		;RUNNING CHECKSUM
FIRZER:	BLOCK	1		;FIRST LOCATION OF ZEROS
LASZER:	BLOCK	1		;LAST ..
CORE.4:	BLOCK	1		;REAL CONTENTS OF 4/5
CORE.6:	BLOCK	1		;REAL CONTENTS OF 6/7

A.PORT:	BLOCK	1		;/PORTNO:P
N.PORT:	BLOCK	1		;[42] COUNTER OF EXISTING -11'S
N.DL10:	BLOCK	1		;[42] CURRENT DL10 BEING CHECKED
F0.DL10: BLOCK	1		;[42] SET TO -1 IF NO DL10 NO. 1
F1.DL10: BLOCK 	1		;[42] SET TO -1 IF NO DL10 NO. 2
NAMPOR:	BLOCK	8		;[42] LIST OF EXISTING PORTS
PAGADR:	BLOCK	1		;[42] STORE INFO IN T4 WHILE CHECKING PORTS
GTPI.:	BLOCK	1		;READ PI CHANNEL
ENBL.:	BLOCK	1		;ENABLE PORT
DSAB.:	BLOCK	1		;DISABLE PORT
CLRA.:	BLOCK	1		;CLEAR -11
CLRB.:	BLOCK	1		;CLEAR -11
BASE.:	BLOCK	1		;SET BASE ADDRESS
STRT.:	BLOCK	1		;START -11
STOP.:	BLOCK	1		;STOP -11
GSTS.:	BLOCK	1		;GET STATUS
TSTS.:	BLOCK	1		;[42] STORE STATUS WHILE CHECKING PORTS
CLRB..:	BLOCK	1		;DATUM FOR CLEAR
STRT..:	BLOCK	1		;DATUM FOR START
STOP..:	BLOCK	1		;DATUM FOR STOP
UP...:	BLOCK	1		;EXIST AND POWER BITS
RN...:	BLOCK	1		;RUN BIT
OK...:	BLOCK	1		;ERROR BITS

;IMPURE AREA FOR DAEMON ERROR REPORTING
ERRWRD:	BLOCK	1		;LIST OF BITS DESCRIBING VARIOUS ERRORS
ERRFZR:				;FIRST WORD TO CLEAR WHEN STARTING TO
				;  LOG A LOAD/DUMP
ERRFCN:	BLOCK	1		;DAEMON FUNCTION CODE
ERRCOD:	BLOCK	1		;SYSERR ERROR TYPE CODE
ERRBLK:				;BLOCK OF DATA FOR SYSERR
ERRTRG:	BLOCK	1		;TARGET NODE
ERRSER:	BLOCK	1		;SERVER NODE
ERRSLD:	BLOCK	1		;SERVER LINE DESIGNATOR
ERRFIL:	BLOCK	1		;POINTER TO THE FILE SPEC
ERRRTN:	BLOCK	1		;NSP STYLE RETURN CODE
ERRPRG:	BLOCK	1		;POINTER TO THE PROG NAME AND USER
ERRVAL:	BLOCK	1		;36 BIT VALUE TO BE PRINTED BY SYSERR
ERRFRE:	BLOCK	100		;LOTS MORE ROOM FOR THE DATA.
SYSNAM:	BLOCK	10		;AREA TO STORE THE SYSTEM'S NAME INTO
ERRLZR==.-1			;LAST WORD TO ZERO IN THE ERROR BLOCK
LODFIL:	BLOCK	ERFSLN		;FILESPEC FOR FILE THAT WAS LOADED
DMPFIL:	BLOCK	ERFSLN		;FILESPEC FOR FILE THAT WAS DUMPED
LWAZER==.-1		;END OF AREA TO CLEAR

FWAONE:!		;START OF AREA TO PRESET TO -1
A.CLR:	BLOCK	1		;/CLEAR:N
A.DUMP:	BLOCK	1		;/DUMP:N
A.END:	BLOCK	1		;/END:N
A.IMAG:	BLOCK	1		;/IMAGE
A.LOAD:	BLOCK	1		;/LOAD:N
A.STRT:	BLOCK	1		;/START:N
A.NLOG:	BLOCK	1		;/NOLOG
F.PORT:	BLOCK	1		;[42] /PORTNO DEFAULT CHECK
LWAONE==.-1		;END OF AREA TO PRESET TO -1
BASEAD:	PHASE	0		;CLEAN COPY OF -11 CODE
	HALT			;HALT FOR THE KI10 TRAP IN THE DL10
			;THIS CODE MADE AS FOLLOWS:
			;  (1)  TAKE PAGE AFTER NEXT AS FILE "LOAD.P11"
			;  (2)  TAKE THREE PAGES AFTER THAT AS "HACK11.CBL"
			;  (3)  COMPILE WITH MACY11:
			;		.R MACY11
			;		*,LOAD=LOAD
			;		*^C
			;  (4)  REMOVE TABS FROM LOAD.LST
			;		.R PIP
			;		*LOAD.LNT/W=LOAD.LST
			;		*^C
			;  (5)  CONVERT TO MACRO-10:
			;		.EXECUTE HACK11
			;  (6)  REMOVE TRAILING SPACES:
			;		.R PIP
			;		*LOAD.MAT/C=LOAD.MAC
			;		*^C
			;  (7)  FILE "LOAD.MAT" IS THE NEXT PAGE.
        EXP 010067,000170       ;MOV     %0,BLODAT+0     ;SAVE AC'S IN CASE OF DUMP
        EXP 010167,000166       ;MOV     %1,BLODAT+2
        EXP 010267,000164       ;MOV     %2,BLODAT+4
        EXP 010367,000162       ;MOV     %3,BLODAT+6
        EXP 010467,000160       ;MOV     %4,BLODAT+10
        EXP 010567,000156       ;MOV     %5,BLODAT+12
        EXP 010667,000154       ;MOV     %6,BLODAT+14
        EXP 013767,000004,000126;MOV     @#4,BLOCNT      ;SAVE CORE 4 FOR BUS TRAP
        EXP 013767,000006,000122;MOV     @#6,BLOADR      ; ALSO CORE 6
        EXP 010704              ;MOV     %7,%4           ;GET THIS LOCATION
        EXP 062704,000076       ;ADD     #BUSS-THIS,%4   ;GET ABSOLUTE ADDRESS
        EXP 010437,000004       ;MOV     %4,@#4          ;STORE FOR BUSS TRAP
        EXP 005067,000076       ;CLR     WATFLG          ;TELL -10 WE ARE DONE
        EXP 005767,000072       ;TST     WATFLG          ;0 MEANS WAIT
        EXP 001775              ;BEQ     WAIT1           ;- MEANS DATA, + START
        EXP 003035              ;BGT     BLOCNT          ;GO EXECUTE JMP OR HALT
        EXP 016703,000070       ;MOV     BLOADR,%3       ;GET CORE ADDRESS
        EXP 010704              ;MOV     %7,%4           ;GET THIS LOCATION
        EXP 062704,000070       ;ADD     #BLODAT-HERE,%4 ;GET ABSOLUTE ADDRESS
        EXP 010406              ;MOV     %4,%6           ;SET STACK FOR BUS TRAP
        EXP 005037,000006       ;CLR     @#6             ;CLEAR NEW FLAGS
        EXP 016705,000046       ;MOV     BLOCNT,%5       ;GET BYTE COUNT
        EXP 003006              ;BGT     COPY            ;IF .GT., LOAD 11
        EXP 005405              ;NEG     %5              ;IF .LT., DUMP 11
        EXP 010403              ;MOV     %4,%3           ;INTERCHANGE SOURCE
        EXP 016704,000036       ;MOV     BLOADR,%4       ;  AND DEST ADRS
        EXP 005237,000006       ;INC     @#6             ;FLAG INTERCHAGE FOR BUS TRAP
        EXP 005305              ;DEC     %5              ;LOOP MOVING BYTES ONE
        EXP 002747              ;BLT     WAITX           ;  AT A TIME
        EXP 112423              ;MOVB    (%4)+,(%3)+     ;COPY ONE BYTE
        EXP 000774              ;BR      COPY            ;LOOP UNTIL DONE
        EXP 010367,000012       ;MOV     %3,NXMADR       ;SAVE ADDRESS IN ERROR
        EXP 103342              ;BCC     WAITX           ;TELL -10 WE ARE DONE
        EXP 010467,000004       ;MOV     %4,NXMADR       ;IF DUMP, SAVE ADDRESS
        EXP 000737              ;BR      WAITX           ;THEN TELL -10
 
WATFLG: EXP 177777              ;.WORD   177777          ;0=WAIT, -=XFER, +=START
NXMADR: BLOCK   01              ;.BLKW   1               ;ADDRESS OF ERROR IF ANY
BLOCNT: BLOCK   01              ;.BLKW   1               ;BYTE COUNT
BLOADR: BLOCK   01              ;.BLKW   1               ;11 STARTING ADDRESS
BLODAT: BLOCK   10              ;.BLKW   10              ;DATA .....
	DEPHASE		;END OF -11 AREA
LEN11==.-BASEAD
WINDOW==<<LEN11+77>/100>*1K-1		;ALLOW FOR BOTH 1K AND 8K OPTIONS

REPEAT	0,<	;FILE LOAD.P11
.TITLE LOAD
.ABS
.=2

				;**** START OF RESULTING CODE
BEGIN:	MOV	%0,BLODAT+0	;SAVE AC'S IN CASE OF DUMP
	MOV	%1,BLODAT+2
	MOV	%2,BLODAT+4
	MOV	%3,BLODAT+6
	MOV	%4,BLODAT+10
	MOV	%5,BLODAT+12
	MOV	%6,BLODAT+14
	MOV	@#4,BLOCNT	;SAVE CORE 4 FOR BUS TRAP
	MOV	@#6,BLOADR	; ALSO CORE 6
	MOV	%7,%4		;GET THIS LOCATION
THIS:	ADD	#BUSS-THIS,%4	;GET ABSOLUTE ADDRESS
	MOV	%4,@#4		;STORE FOR BUSS TRAP
WAITX:	CLR	WATFLG		;TELL -10 WE ARE DONE
WAIT1:	TST	WATFLG		;0 MEANS WAIT
	BEQ	WAIT1		;- MEANS DATA, + START
	BGT	BLOCNT		;GO EXECUTE JMP OR HALT
	MOV	BLOADR,%3	;GET CORE ADDRESS
	MOV	%7,%4		;GET THIS LOCATION
HERE:	ADD	#BLODAT-HERE,%4	;GET ABSOLUTE ADDRESS
	MOV	%4,%6		;SET STACK FOR BUS TRAP
	CLR	@#6		;CLEAR NEW FLAGS
	MOV	BLOCNT,%5	;GET BYTE COUNT
	BGT	COPY		;IF .GT., LOAD 11
	NEG	%5		;IF .LT., DUMP 11
	MOV	%4,%3		;INTERCHANGE SOURCE
	MOV	BLOADR,%4	;  AND DEST ADRS
	INC	@#6		;FLAG INTERCHAGE FOR BUS TRAP
COPY:	DEC	%5		;LOOP MOVING BYTES ONE
	BLT	WAITX		;  AT A TIME
	MOVB	(%4)+,(%3)+	;COPY ONE BYTE
	BR	COPY		;LOOP UNTIL DONE
BUSS:	MOV	%3,NXMADR	;SAVE ADDRESS IN ERROR
	BCC	WAITX		;TELL -10 WE ARE DONE
	MOV	%4,NXMADR	;IF DUMP, SAVE ADDRESS
	BR	WAITX		;THEN TELL -10

WATFLG:	.WORD	177777		;0=WAIT, -=XFER, +=START
NXMADR:	.BLKW	1		;ADDRESS OF ERROR IF ANY
BLOCNT:	.BLKW	1		;BYTE COUNT
BLOADR:	.BLKW	1		;11 STARTING ADDRESS
BLODAT:	.BLKW	10		;DATA .....
				;**** END OF RESULTING CODE

	.END	BEGIN
>		;END OF FILE LOAD.P11
	SUBTTL	FILE HACK11.CBL

REPEAT	0,<	;FILE HACK11.CBL
IDENTIFICATION DIVISION.
PROGRAM-ID.  HACK11 TO CONVERT MACY11 LISTING TO MACRO10 INPUT.
	ADDRESS MUST BE SIX CHARS TO APPEAR IN -10.
ENVIRONMENT DIVISION.
INPUT-OUTPUT SECTION.
FILE-CONTROL.
	SELECT IN-ELEVEN,	ASSIGN TO DSK, RECORDING MODE ASCII.
	SELECT OUT-TEN,		ASSIGN TO DSK, RECORDING MODE ASCII.
DATA DIVISION.
FILE SECTION.
FD IN-ELEVEN, VALUE IDENTIFICATION "LOAD  LNT".
01	DATA-IN.
	02  FILLER PIC X(16).
	02  DATA-1 PIC X(6).
	02  FILLER PIC XX.
	02  DATA-2 PIC X(6).
	02  FILLER PIC XX.
	02  DATA-3 PIC X(6).
	02  FILLER PIC XX.
	02  ADDR PIC X(6).
	02  TEN-ADDR-FLAG PIC X.
	02  FILLER PIC X.
	02  REST-OF-LINE PIC X(53).
	02  TEST-LINE REDEFINES REST-OF-LINE.
		03  OP-CODE PIC X(5).
		03  FILLER PIC X(3).
		03  WIDTH PIC X(8).
		03  REST-OF-FILL PIC X(37).
	02  OVERFLOW-AREA PIC X(20).
FD OUT-TEN, VALUE IDENTIFICATION "LOAD  MAC".
01	DATA-OUT.
	02  ADDR PIC X(6).
	02  FIL-1 PIC XX.
	02  FIL-2 PIC XXX.
	02  FILLER PIC X.
	02  DATA-1 PIC X(6).
	02  FIL-3 PIC X.
	02  DATA-2 PIC X(6).
	02  FIL-4 PIC X.
	02  DATA-3 PIC X(6).
	02  FIL-5 PIC X.
	02  REST-OF-LINE PIC X(53).

01	BLOCK-OUT.
	02  ADDR PIC X(6).
	02  FIL-D1 PIC XX.
	02  FIL-D2 PIC X(8).
	02  WIDTH-OUT PIC X(8).
	02  FILLER PIC X(8).
	02  FIL-5  PIC X.
	02  REST-OF-LINE PIC X(53).

WORKING-STORAGE SECTION.
01	SKIP-REC.
	02  FILLER PIC X(72).
	02  SKIP-FIELD PIC X(5).
	02  FILLER PIC X(44).
01	DATA-TO-FILL-WITH.
	02  FIL-2 PIC X(3) VALUE "EXP".
	02  FIL-5 PIC X VALUE ";".
PROCEDURE DIVISION.
START-RUN.
	OPEN INPUT IN-ELEVEN.  OPEN OUTPUT OUT-TEN.
FIND-DATA.
	READ IN-ELEVEN RECORD INTO SKIP-REC AT END GO TO NOT-FOUND.
	IF SKIP-FIELD NOT= ";****" GO TO FIND-DATA.
	IF OP-CODE = ".BLKW" GO TO BLOCK.
GOT-DATA.
	READ IN-ELEVEN RECORD INTO SKIP-REC AT END GO TO NOT-FOUND.
	IF SKIP-FIELD = ";****" GO TO ALL-DONE.
	IF OVERFLOW-AREA NOT = SPACES DISPLAY "% COMMENTS TRUNCATED: "
		OVERFLOW-AREA.
	IF OP-CODE = ".BLKW" GO TO BLOCK.
	MOVE SPACES TO DATA-OUT.
	IF OP-CODE = SPACES GO TO WRITE-DATA.
	MOVE CORRESPONDING DATA-TO-FILL-WITH TO DATA-OUT.
	MOVE CORRESPONDING DATA-IN TO DATA-OUT.
	IF TEN-ADDR-FLAG = ":" MOVE ": " TO FIL-1
		ELSE MOVE SPACES TO ADDR IN DATA-OUT.
	IF DATA-2 IN DATA-IN NOT= SPACES MOVE "," TO FIL-3.
	IF DATA-3 IN DATA-IN NOT= SPACES MOVE "," TO FIL-4.
WRITE-DATA.
	WRITE DATA-OUT.
	GO TO GOT-DATA.
BLOCK.
	MOVE SPACES TO BLOCK-OUT.
	MOVE CORRESPONDING DATA-TO-FILL-WITH TO DATA-OUT.
	MOVE CORRESPONDING DATA-IN TO DATA-OUT.
	MOVE "BLOCK" TO FIL-D2.
	IF ADDR IN DATA-IN NOT= SPACES MOVE ": " TO FIL-D1.
	WRITE BLOCK-OUT.
	GO TO GOT-DATA.
NOT-FOUND.
	DISPLAY "? Error--;**** not found".
	
ALL-DONE.
	CLOSE IN-ELEVEN.  CLOSE OUT-TEN.
	STOP RUN.
>		;END OF HACK11.CBL

	END	START
