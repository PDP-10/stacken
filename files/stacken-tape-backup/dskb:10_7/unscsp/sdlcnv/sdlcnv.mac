	TITLE	SDLCNV - CONVERSION UTILITY FOR MONBTS
	SUBTTL	G.M. UHLER/GMU


;COPYRIGHT (C) 1979 BY
;DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
	SEARCH	JOBDAT,MACTEN,UUOSYM

;	AC DEFINITIONS

	T1==1			;FIRST OF 4 TEMPORARIES
	T2==2
	T3==3
	T4==4
	T5==5
	P1==6			;FIRST OF 4 PRESERVED
	P2==7
	P3==10
	P4==11
	P==17			;PDL POINTER

;	MISCELANEOUS DEFINITIONS

	PDLLEN==10		;LENGTH OF PDL
	DSK==1			;DISK CHANNEL
	APN==2			;CHANNEL TO APPEND TO CRASH.EXE
	RIBPPN==1		;PPN WORD IN RIB
	RIBNAM==2		;FILENAME WORD IN RIB
	RIBEXT==3		;EXTENSION WORD IN RIB
	RIBSTS==17		;STATUS WORD IN RIB
	RIPNDL=200000		;NO DELETE BIT IN RIBSTS
	RIBCOD==176		;UNLIKELY CODE WORD IN RIB
	CODRIB==777777		;UNLIKELY CODE
	RIBSLF==177		;SELF POINTER IN RIB

	SDSVER==1		;MAJOR VERSION
	SDSMIN==0		;MINOR VERSION
	SDSEDT==0		;EDIT NUMBER
	SDSWHO==0		;WHO LAST EDITED

	LOC	.JBVER
	VRSN.	(SDS)
	RELOC
	DEFINE	ERROR	(MSG),<
	OUTSTR	[ASCIZ\
?'MSG
\]
	JRST	KILL
	>


	DEFINE	WARNJ	(MSG,ADDR),<
	OUTSTR	[ASCIZ\
%'MSG\]
	JRST	ADDR
	>


	SALL
	TWOSEG
	RELOC	400000
SDLCNV:	JFCL			;IGNORE CCL ENTRY
	RESET			;STOP THE WORLD
	MOVE	P,[IOWD PDLLEN,PDL] ;SETUP A PDL
	GETPPN	T1,		;GET OUR PPN
	  JFCL			;AVOID STUPID SKIP
	CAME	T1,[1,,2]	;PRIVILEGED?
	JRST	NOTPRV		;NO
	OUTSTR	[ASCIZ/Structure on which to extend CRASH.EXE[1,4] by 4 blocks: /]
	PUSHJ	P,GETNAM	;GET THE STRUCTURE NAME
	  JRST	NOTSTR		;NOT A STRUCTURE
	PUSHJ	P,XTNCRS	;EXTEND THE FILE
	JRST	KILL
;ROUTINE TO EXTEND CRASH.EXE[1,4] ON A STRUCTURE BY 4 BLOCKS.
;CALL WITH:
;	P1/STRUCTURE NAME
;RETURN+1 ALWAYS

XTNCRS:	MOVX	T1,UU.PHS!.IODMP ;NEED A PHYSICAL DEVICE IN DUMP MODE
	MOVE	T2,P1		;COPY DEVICE NAME
	MOVX	T3,0		;NO BUFFERS
	MOVE	T4,[T1,,FLPBLK+.FOIOS] ;SETUP TO MOVE TO FILOP. BLOCK
	BLT	T4,FLPBLK+.FOBRH ;NEED THIS FOR LATER
	OPEN	DSK,T1		;OPEN THE CHANNEL
	  JRST	OPNERR		;CAN'T
	MOVE	T1,[SIXBIT/CRASH/] ;FILENAME IS CRASH
	MOVSI	T2,'EXE'	;EXTENSION IS EXE
	MOVEI	T3,0		;NO PROT
	MOVE	T4,[1,,4]	;PPN IS 1,4
	MOVE	T5,[T1,,LKPBLK]	;SETUP TO MOVE IT TO THE LOOKUP BLOCK
	BLT	T5,LKPBLK+3	;NEED THIS LATER
	LOOKUP	DSK,T1		;LOOKUP THE FILE
	  JRST	LKPERR		;FAILED
	PUSHJ	P,REDRIB	;READ AND CHECK RIB
	  JRST	RRDERR		;FAILED
	PUSHJ	P,WTFRIB	;REWRITE RIB AFTER CLEARING RIPNDL
	  JRST	RWTERR		;FAILED
	MOVX	T1,FO.PRV!<APN>B17!.FOAPP ;GET FILOP. FUNCTION TO APPEND
	MOVEM	T1,FLPBLK+.FOFNC ;STORE IN BLOCK
	SETZM	FLPBLK+.FONBF	;NO BUFFERS
	MOVEI	T1,LKPBLK	;POINT AT LOOKUP BLOCK
	MOVEM	T1,FLPBLK+.FOLEB ;STORE IN FILOP. BLOCKS
	MOVE	T1,[.FOLEB+1,,FLPBLK] ;POINT AT FILOP. BLOCK
	FILOP.	T1,		;DO IT
	  JRST	FLPERR		;FAILED
	MOVEI	T1,4		;WANT TO WRITE 4 MORE BLOCKS
	OUTPUT	APN,DSKIOW	;WRITE A BLOCK
	SOJG	T1,.-1		;LOOP FOR FOUR
	CLOSE	APN,		;CLOSE CHANNEL
	RELEAS	APN,		;RELEASE IT
	MOVE	T1,BUF+RIBSLF	;GET BLOCK CONTAINING RIB
	PUSHJ	P,REDBLK	;REREAD IT
	  JRST	RR1ERR		;FAILED
	PUSHJ	P,CHKRIB	;MAKE SURE IT'S OK
	  JRST	WRGBLK		;WRONG BLOCK???
	PUSHJ	P,WTNRIB	;REWRITE RIB, SETTING RIPNDL
	  JRST	RWTERR		;FAILED
	RELEAS	DSK,		;RELEAS CHANNEL
	POPJ	P,		;RETURN
NOTSTR:	ERROR	<Not a structure>
LKPERR:	ERROR	<LOOKUP of CRASH.EXE[1,4] failed>
RRDERR:	ERROR	<Unable to read the RIB for CRASH.EXE[1,4]>
WRGBLK:	ERROR	<Reread of RIB of CRASH.EXE[1,4] read the wrong block>
FLPERR:	ERROR	<FILOP. append of CRASH.EXE[1,4] failed>
NOTPRV:	ERROR	<Job not privileged, must be run as [1,2]>
OPNERR:	WARNJ	<Can't OPEN unit>,DEVPRT
RWTERR:	WARNJ	<Write error on RIB>,IOEPRT
RR1ERR:	WARNJ	<Read error on RIB, unable to set RIBNDL>,IOEPRT
IOEPRT:	OUTSTR	[ASCIZ/, Block = /]
	MOVE	T1,LSTBLK	;GET BLOCK NUMBER
	PUSHJ	P,PRTOCT	;PRINT IT
	OUTSTR	[ASCIZ/, Status = /]
	MOVE	T1,ERRSTS	;GET STATUS
	PUSHJ	P,PRTOCT	;PRINT IT
DEVPRT:	OUTSTR	[ASCIZ/, Unit = /]
	MOVE	T1,P1		;GET UNIT NAME
	PUSHJ	P,PRTNAM	;PRINT IT
	OUTSTR	[ASCIZ/
/]
	POPJ	P,		;RETURN


KILL:	RESET			;INSURE ALL IS STOPPED
	EXIT			;  AND GIVE UP
;ROUTINE TO PRINT A SIXBIT NAME ON THE TTY.  STOPS ON THE FIRST
;SPACE.  CALL WITH:
;	T1/SIXBIT WORD
;RETURN+1 ALWAYS

PRTNAM:	LSHC	T1,-<5*6>	;RIGHT JUSTIFY CHAR IN T1
	JUMPE	T1,CPOPJ	;RETURN ON FIRST NULL
	MOVEI	T1,"0"-'0'(T1)	;CONVERT TO ASCII
	OUTCHR	T1		;OUTPUT IT
	LSHC	T1,^D36		;SETUP FOR RECURSIVE CALL
	PJRST	PRTNAM		;LOOP FOR ALL CHARS


;STANDARD ROUTINE TO PRINT AN OCTAL NUMBER.  CALL WITH:
;	T1/NUMBER
;RETURN+1 ALWAYS

PRTOCT:	IDIVI	T1,^D8		;DIVIDE BY RADIX, REMAINDER IN T2
	HRLM	T2,0(P)		;STORE REMAINDER ON STACK
	SKIPE	T1		;DONE YET?
	PUSHJ	P,PRTOCT	;NO, DO NEXT DIGIT
	HLRZ	T1,0(P)		;GET NEXT DIGIT BACK FROM STACK
	ADDI	T1,"0"		;CONVERT TO ASCII
	OUTCHR	T1		;OUTPUT IT
	POPJ	P,		;RETURN TO CALLER
;ROUTINE TO READ A COMMAND FROM THE TERMINAL.  STORE THE COMMAND
;IN CMDBUF AND A BYTE POINTER IN CMDB.
;RETURN+1 ALWAYS

REDCMD:	MOVE	T2,[POINT 7,CMDBUF] ;GET POINTER TO BUFFER
	MOVEM	T2,CMDB		;SAVE FOR CALLER
	MOVX	T3,^D80		;ALLOW ONLY 80 CHARS
REDCM1:	PUSHJ	P,GETCHR	;GET NEXT CHARACTER
	PUSHJ	P,CHKBRK	;BREAK?
	  SKIPA			;NO
	JRST	REDCM2		;YES, FINISH UP
	SOJL	T3,REDCM1	;LOOP IF TOO MANY
	IDPB	T1,T2		;STORE IN BUFFER
	JRST	REDCM1		;  AND LOOP
REDCM2:	MOVEI	T1,0		;TERMINATE BUFFER
	IDPB	T1,T2		;  WITH TWO
	IDPB	T1,T2		;  ZEROS
	POPJ	P,		;  AND RETURN


;ROUTINE TO READ ONE CHARACTER FROM THE TTY.  IGNORES NULLS AND
;CARRIAGE RETURNS, MAPS LOWER TO UPPER CASE.
;RETURN+1 ALWAYS WITH
;	T1/CHARACTER

GETCHR:	INCHWL	T1		;GET CHARACTER
	JUMPE	T1,GETCHR	;LOOP IF NULL
	CAXN	T1,.CHCRT	; OR IF CR
	  JRST	GETCHR		;...
	CAIL	T1,"a"		;LOWER CASE CHARACTER?
	 CAILE	T1,"z"		;...
	  POPJ	P,		;NO, JUST RETURN IT
	SUBI	T1,"a"-"A"	;FOLD TO UPPER CASE
	POPJ	P,		;  AND RETURN


;ROUTINE TO CHECK FOR BREAK CHARACTER. CALL WITH:
;	T1/CHARACTER
;RETURN+1 IF NOT A BREAK CHARACTER
;RETURN+2 IF A BREAK CHARACTER

CHKBRK:	PUSH	P,T2		;DESTROY NO ACS
	MOVX	T2,1		;GET A BIT TO SHIFT
	LSH	T2,(T1)		;SHIFT BY VALUE OF CHARACTER
	TDNE	T2,BRKTBL	;THIS A BREAK CHARACTER?
	  AOS	-1(P)		;YES, BUMP RETURN POINT
	POP	P,T2		;RESTORE T2
	POPJ	P,		;  AND RETURN

BRKTBL:	1_.CHBEL!1_.CHVTB!1_.CHFFD!1_.CHCNZ!1_.CHESC!1_.CHLFD
;ROUTINE TO GET A SIXBIT NAME FROM THE TERMINAL.
;RETURN+1 IF BAD NAME TYPED
;RETURN+2 WITH SIXBIT NAME IN P1

GETNAM:	PUSHJ	P,REDCMD	;READ IN THE COMMAND
	MOVX	P1,0		;INIT NAME
	MOVE	T2,[POINT 6,P1]	;BUILD BYTE POINTER TO P1
GETNA1:	ILDB	T1,CMDB		;GET NEXT CHARACTER
	JUMPE	T1,CPOPJ1	;RETURN AT END OF LINE
	CAIN	T1,":"		;SPECIFY A COLON?
	  JRST	GETNA2		;YES
	SUBI	T1,"A"-'A'	;CONVERT TO SIXBIT
	TLNE	T2,770000	;DONE MORE THAN 6?
	  IDPB	T1,T2		;STORE IN NEXT SLOT IN P1
	JRST	GETNA1		;LOOP FOR MORE
GETNA2:	ILDB	T1,CMDB		;GET NEXT CHAR
	SKIPN	T1		;MUST BE A BREAK HERE
CPOPJ1:	AOS	(P)		;GIVE SKIP RETURN
CPOPJ:	POPJ	P,		;  AND RETURN


;ROUTINE TO CHECK FOR A YES/NO RESPONSE.
;RETURN+1 IF NO
;RETURN+2 IF YES

YESNO:	PUSHJ	P,REDCMD	;READ IN A LINE
	ILDB	T1,CMDB		;GET CHARACTER
	CAIE	T1,"Y"		;MUST BE A YES
	 CAIN	T1,"N"		;  OR A NO
	  JRST	YESNO1		;IT IS
	OUTSTR	[ASCIZ/
%Please respond with a Y or N: /]
	JRST	YESNO		;  AND LOOP
YESNO1:	CAIN	T1,"Y"		;IF A Y,
	  AOS	(P)		;  WE MUST GIVE A SKIP RETURN
	POPJ	P,		;RETURN
;ROUTINES TO REWRITE A RIB AFTER EITHER SETTING OR CLEARING RIPNDL
;IN RIBSTS.  WTNRIB TURNS ON THE BIT, WTFRIB TURNS OFF THE BIT.
;CALL WITH:
;	PUSHJ	P,WT?RIB
;RETURN+1 IF ERROR
;RETURN+2 IF SUCCESSFUL

WTNRIB:	MOVEI	T1,RIPNDL	;GET NO DELETE BIT
	IORM	T1,BUF+RIBSTS	;SET IN RIBSTS
	JRST	WTXRIB		;JOIN COMMON CODE

WTFRIB:	MOVEI	T1,RIPNDL	;GET NO DELETE BIT
	ANDCAM	T1,BUF+RIBSTS	;CLEAR IN RIBSTS
;;	JRST	WTXRIB		;FALL INTO WTXRIB

WTXRIB:	MOVE	T1,BUF+RIBSLF	;GET SELF BLOCK NUMBER
	PJRST	WRTBLK		;WRITE BLOCK AND RETURN
;ROUTINE TO READ THE RIB OF A FILE INTO BUF.
;CALL WITH THE FILE LOOKED UP ON CHANNEL DSK.  RETURNS WITH
;THE PHYSICAL UNIT CONTAINING THE RIB OPENED IN SUPER I/O MODE
;ON CHANNEL DISK AND THE RIB IN BUF.  THE CALL IS:
;	PUSHJ	P,REDRIB
;RETURN+1 IF ERRORS
;RETURN+2 IF SUCCESSFUL

REDRIB:	USETI	DSK,0		;SET TO READ RIB
	STATZ	DSK,IO.ERR!IO.EOF ;ERRORS?
	POPJ	P,		;YES
	INPUT	DSK,DSKIOW	;READ RIB INTO CORE
	STATZ	DSK,IO.ERR!IO.EOF ;ERRORS?
	POPJ	P,		;YES
	MOVEI	T1,DSK		;GET CHANNEL
	MOVEM	T1,DSCBLK+.DCNAM ;STORE IN DSKCHR BLOCK
	MOVE	T1,[.DCUPN+1,,DSCBLK] ;POINT TO IT
	DSKCHR	T1,		;ASK THE MONITOR WHAT PHYSICAL UNIT
	  POPJ	P,		;FAILED
	CLOSE	DSK,CL.DAT	;CLOSE, RETURNING CORE BLOCKS
	MOVX	T1,UU.PHS!.IODMP ;PHYSICAL DEVICE IN DUMP MODE
	MOVE	T2,DSCBLK+.DCUPN ;GET PHYSICAL UNIT NAME
	MOVX	T3,0		;NO BUFFERS
	OPEN	DSK,T1		;OPEN CHANNEL
	  POPJ	P,		;FAILED
;;	PJRST	CHKRIB		;CHECK RIB AND RETURN


;ROUTINE TO CHECK THE RIB FOR CRASH.EXE[1,4] IN BUF TO MAKE SURE IT'S
;OK.
;THE CALL IS:
;	PUSHJ	P,CHKRIB
;RETURN+1 IF ERRORS
;RETURN+2 IF SUCCESSFUL

CHKRIB:	MOVE	T1,BUF+RIBNAM	;GET FILENAME
	HLRZ	T2,BUF+RIBEXT	;  AND EXTENSION
	CAMN	T1,[SIXBIT/CRASH/] ;FILENAME MUST BE CRASH
	CAIE	T2,'EXE'	;EXTENSION MUST BE EXE
	POPJ	P,		;FAILED
	MOVE	T1,BUF+RIBPPN	;GET PPN
	MOVE	T2,BUF+RIBCOD	;AND UNLIKELY CODE
	CAMN	T1,[1,,4]	;PPN MUST BE 1,2
	CAIE	T2,CODRIB	;AND UNLIKELY CODE MUST BE CODRIB
	POPJ	P,		;FAILED
	JRST	CPOPJ1		;RETURN
;ROUTINE TO READ A BLOCK FROM THE DISK INTO BUF.  CALL WITH
;	T1/BLOCK NUMBER TO READ
;RETURN+1 IF ERRORS DETECTED
;RETURN+2 IF NO ERRORS AND BLOCK IN BUF

REDBLK:	MOVEM	T1,LSTBLK	;SAVE FOR ERROR MESSAGES
	USETI	DSK,T1		;SETUP TO READ THAT BLOCK
	STATZ	DSK,IO.ERR	;ANY ERRORS?
	  JRST	IOERR		;YES
	INPUT	DSK,DSKIOW	;READ THE BLOCK
	STATO	DSK,IO.ERR	;ANY ERRORS?
	JRST	CPOPJ1		;NO
	JRST	IOERR		;GET STATUS AND RETURN NON-SKIP


;ROUTINE TO WRITE A BLOCK FROM BUF TO THE DISK.  CALL WITH:
;	T1/BLOCK NUMBER TO WRITE
;RETURN+1 IF ERRORS DETECTED
;RETURN+2 IF NO ERRORS AND BLOCK WRITTEN

WRTBLK:	MOVEM	T1,LSTBLK	;SAVE FOR MESSAGES
	USETO	DSK,T1		;SETUP TO WRITE SPECIFIED BLOCK
	STATZ	DSK,IO.ERR	;ANY ERRORS?
	  JRST	IOERR		;YES
	OUTPUT	DSK,DSKIOW	;DO THE OUTPUT
	STATO	DSK,IO.ERR	;ANY ERRORS?
	  JRST	CPOPJ1		;NO, GIVE SKIP RETURN
IOERR:	GETSTS	DSK,ERRSTS	;GET STATUS FOR MESSAGE
	POPJ	P,		;GIVE NON-SKIP RETURN
	RELOC
CMDB:	BLOCK	1		;COMMAND BUFFER BYTE POINTER
CMDBUF:	BLOCK	<^D80/5>+2	;COMMAND BUFFER
LSTBLK:	BLOCK	1		;LAST BLOCK READ/WRITTEN
ERRSTS:	BLOCK	1		;STATUS ON LAST ERROR
PDL:	BLOCK	PDLLEN		;PDL
DSCBLK:	BLOCK	.DCUPN+1	;DSKCHR BLOCK
FLPBLK:	BLOCK	.FOLEB+1	;FILOP. BLOCK
LKPBLK:	BLOCK	4		;LOOKUP BLOCK
DSKIOW:	IOWD	200,BUF		;IOWD TO BUF
	EXP	0
BUF:	BLOCK	200		;BUFFER


	END	SDLCNV
