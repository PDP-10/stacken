TITLE WTBOOT - WRITE BOOTS ON ALL DISK PACKS BLOCKS 4-7 IN STRS - V007
SUBTTL T. HASTINGS/TW/JMF/DBD	16 OCT 78
	VWBOOT==7
	VWHO==0
	VMINOR==0
	VEDIT==12

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1978,1979 BY DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

	LOC 137
.JBVER:	BYTE	(3)VWHO(9)VWBOOT(6)VMINOR(18)VEDIT
	RELOC

IFNDEF TEST,<TEST=0>	;DEFINE TEST TO BE 1 TO READ INSTEAD OF WRITE
IFNDEF STDWTB,<STDWTB==1>;DEFINE STDWTB TO BE 0 IF NON-STANDARD WTBOOT
IFNDEF FTKL10,<FTKL10==0> ;DEFINE FTKL10 TO BE 1 IF RH10 OR RH20 BOOTS
IFNDEF FTKS10,<FTKS10==0> ;DEFINE FTKS10 TO BE 1 IF RH11 BOOTS

	EXTERN MBOOTL
IFN STDWTB,<EXTERN BOOTSA>
T=1	;TEMP AC
T1=2	;ANOTHER AC
T2=3	;SOME ACS FOR THE BOOT READER (LIFTED FROM COMMON)
T3=4
T4=5
P2=6
D=7
CH=10
CH2=11
KL=12
P=17

AP.NXM==1B23
IP.NXM==1B29
C=0	;CHANNEL

BOOTLB==4	;FIRST LOGICAL BLOCK FOR BOOTS
IFN FTKS10,<
OPDEF	APRID	[700000,,0]	;READ MICROCODE VERSION AND CPU SERIAL NU
OPDEF	WRAPR	[700200,,0]	;WRITE APR
OPDEF	RDAPR	[700240,,0]	;READ APR
OPDEF	WRPI	[700600,,0]	;WRITE PI
	OPDEF	PIOFF	[700600,,400]
	OPDEF	PION	[700600,,200]
OPDEF	RDPI	[700640,,0]	;READ PI
OPDEF	WRUBR	[701140,,0]	;WRITE USER BASE REGISTER
OPDEF	CLRPT	[701100,,0]	;CLEAR PAGE TABLE
OPDEF	RDUBR	[701040,,0]	;READ USER BASE REGISTER
OPDEF	WREBR	[701200,,0]	;WRITE
OPDEF	RDEBR	[701240,,0]	;READ
OPDEF	TIOE	[710000,,0]	;TEST UNIBUS, SKIP EQUAL
OPDEF	TIOEB	[720000,,0]	;TEST UNIBUS, SKIP EQUAL
OPDEF	TION	[711000,,0]	;TEST UNIBUS, SKIP NOT EQUAL
OPDEF	TIONB	[721000,,0]	;TEST UNIBUS, SKIP NOT EQUAL
OPDEF	RDIO	[712000,,0]	;READ UNIBUS
OPDEF	RDIOB	[722000,,0]	;READ UNIBUS BYTE
OPDEF	WRIO	[713000,,0]	;WRITE UNIBUS
OPDEF	WRIOB	[723000,,0]	;WRITE UNIBUS BYTE
OPDEF	BSIO	[714000,,0]	;BIT SET TO UNIBUS
OPDEF	BSIOB	[724000,,0]	;BIT SET TO UNIBUS BYTE
OPDEF	BCIO	[715000,,0]	;BIT CLEAR TO UNIBUS
OPDEF	BCIOB	[725000,,0]	;BIT CLEAR TO UNIBUS BYTE
OPDEF	WRSPB	[702400,,0]	;WRITE SPT BASE REGISTER
OPDEF	RDSPB	[702000,,0]	;READ SPT BASE REGISTER
OPDEF	WRCSB	[702440,,0]	;WRITE CORE STATUS TABLE BASE REGISTER
OPDEF	RDCSB	[702040,,0]	;READ CORE STATUS TABLE BASE REGISTER
OPDEF	WRPUR	[702500,,0]	;WRITE PROCESS USE REGISTER
OPDEF	RDPUR	[702100,,0]	;READ PROCESS USE REGISTER
OPDEF	WRCSTM	[702540,,0]	;WRITE CST MASK REGISTER
OPDEF	RDCSTM	[702140,,0]	;READ CST MASK REGISTER
OPDEF	WRTIME	[702600,,0]	;WRITE TIME BASE
OPDEF	RDTIME	[702200,,0]	;READ TIME BASE
OPDEF	WRINT	[702640,,0]	;WRITE INTERVAL TIMER
OPDEF	RDINT	[702240,,0]	;READ THE INTERVAL REGISTER
OPDEF	UMOVE	[704000,,0]	;MOVE FROM PREVIOUS CONTEXT
OPDEF	UMOVEM	[705000,,0]	;MOVE TO PREVIOUS CONTEXT
OPDEF	RDHSB	[702300,,0]	;READ HALT STATUS BLOCK
OPDEF	WRHSB	[702700,,0]	;WRITE HALT STATUS BLOCK
;UNIBUS ADAPTER
	UBAMAP=763000	;MAPPING REGISTERS
	UBA.SR=763100	;STATUS REGISTER
	UBA.IR=763200	;VECTOR REGISTER
	UBA.MR=763300	;MAINTENANCE REGISTER

;PHYSICAL CORE DEFINITIONS FOR KS10 CTY AND KLINIK SERVICE
; AND PHYSICAL CORE LOCATIONS FOR OTHER FRONT-END FUNCTIONS

RLWORD==:31			;RELOAD WORD
	KSRLD==1B4		;RELOAD REQUEST
	KPACT==1B5		;KEEP ALIVE ACTIVE
	KLACT==1B6		;KLINIK ACTIVE
	PAREN==1B7		;PARITY ERROR DETECT ENABLED
	CRMPAR==1B8	;CRAM PAR ERR DETECT ENABLED
	DRMPAR==1B9	;DRAM PAR ERR DETECT ENABLED
	CASHEN==1B10	;CACHE ENABLED
	MILSEN==1B11	;1MSEC ENABLED
	KPALIV==377B28	;KEEP ALIVE WORD
	PWRFAL==1B33	;POWER FAIL
	FORREL==1B34	;FORCED RELOAD
	KEPFAL==1B35	;KEEP ALIVE FAILURE


CTYIWD==:32			;CTY INPUT WORD
	CTYICH==377B35	;CTY INPUT CHARACTER
	CTYIVL==1B27	;INPUT VALID BIT

CTYOWD=33			;CTY OUTPUT WORD
	CTYOCH==377B35	;CTY OUTPUT CHARACTER
	CTYOVL==1B27	;OUTPUT VALID FLAG

KLIIWD==:34			;KLINIK INPUT WORD
	KLIICH==377B35	;KLINIK INPUT CHARACTER
	KLIIVL==1B27	;KLINIK INPUT VALID
KLICHR==:1B27			;KLINIK CHARACTER
KLIINI==:2B27			;KLINIK INITED
KLICAR==:3B27			;CARRIER LOST


KLIOWD==:35			;KLINIK OUTPUT WORD
	KLIOCH==377B35	;KLINIK OUTPUT CHARACTER
	KLIOVL==1B27	;KLINIK OUTPUT VALID
KLOCHR==:1B27			;KLINIK CHARACTER AVAILABLE
KLIHUP==:2B27			;KLINIK HANGUP REQUEST
;RJP04
	RPCS1==776700
	RPWC==776702
	RPBA==776704
	RPDA==776706
	RPCS2==776710
	RPDS==776712
	RPER1==776714
	RPAS==776716
	RPLA==776720
	RPDB==776722
	RPMR==776724
	RPDT==776726
	RPSN==776730
	RPOF==776732
	RPDC==776734
	RPCC==776736
	RPER2==776740
	RPER3==776742
	RPEC1==776744
	RPEC2==776746

>;IFN FTKS10
	MLON		;MULTI LINE LITERALS

BEG:	RESET
	MOVE	P,[-10,,PDL]
	MOVE	T,[XWD 17,11]	;GETTAB FOR STATES WORD
	GETTAB	T,		;GET STATES WORD
	  JRST	NOTFIV		;ERROR RETURN, MUST BE OLD MONITOR
	TLNN	T,3400		;IS THIS 5.01 OR LATER?
	JRST	NOTFIV		;NO, MUST BE OLD MONITOR
	MOVEI	D,0		;START AT FIRST DISK UNIT IN SYSTEM
	MOVEI	KL,0		;SET KL=0 IF NOT A KL10 OR KS10
	BLT	KL,0		; NON-0 IF A KL10 OR KS10
IFE STDWTB,<
	SETOM	SHUTUP		;ASSUME NO DIALOGUE
	OUTSTR	[ASCIZ /TYPE "HELP" FOR HELP
/]
	JRST	GO
HELP:	OUTSTR	HELPTX
IFN FTKL10,<
	OUTSTR	HELPT2
>
	OUTSTR	HELPT3
	OUTSTR	HELPT4
	OUTSTR	HELPT5
GO:	OUTSTR	[ASCIZ /SELECT UNITS? /]
	PUSHJ	P,GETCHR	;GET AN ANSWER
	CAIE	CH,"N"		;DEFAULT?
	CAIN	CH,12		;OR JUST DOESN'T CARE
	JRST	LOOP		;YES, DO THE DEFAULT THING
	CAIE	CH,"Y"		;AFFIRMITAVE?
	JRST	HELP		;NO OTHER ANSWER IMPLEMENTED
	SETZM	SHUTUP		;DO IT QUITELY
	JUMPN	D,LOOP0		;DON'T START OVER JUST BECAUSE OF A MISTAKE
>
LOOP:	SYSPHY	D,
	  JRST	ESYSPH		;ERROR RETURN FOR SYSPHY UUO
	JUMPE	D,FINISH	;0 VALUE MEANS DONE ALL UNITS IN SYSTEM
	MOVEM	D,DSKTAB	;SAVE FOR DSKCHR UUO
	MOVEM	D,DSKNM		;SAVE FOR OPEN UUO
LOOP0:	MOVE	T,[XWD .DSLEN,DSKTAB]
	DSKCHR	T,		;GET CHARACTERISTICS FOR THIS DISK UNIT
	  JRST	EDSKCH		;ERROR RETURN, PRINT MESSAGE
	TLNN	T,200000	;OFFLINE?
	TLNE	T,3000		;NO, NOT MOUNTED, OR BEING MOUNTED?
	JRST	LOOP		;YES, GO LOOK AT NEXT UNIT IN SYSTEM
	LDB	T,[POINT 6,T,26];NO, GET CONTROLLER TYPE
IFE FTKS10,<
	CAIN	T,4		;RS04?
	JRST	LOOP0A		;YES, OPEN IT (TO WRITE READ-IN LOADER)
>;END IFE FTKS10
IFN FTKS10,<
	CAIN	T,4		;RS04?
	JRST	LOOP		;YES, IGNORE IT
>;END IFN FTKS10
	CAIE	T,5		;IS THIS AN RP04
	CAIN	T,2		; OR THIS AN RP03
	SKIPN	DSKTAB+.DCSNM	;YES, IS IT IN A FILE STR?
	JRST	LOOP		;NO, GO LOOK AT NEXT UNIT IN SYSTEM
	MOVE	T3,T		;SAVE DEFAULTS
	CAIE	T3,5		;RP04?
	JRST	LOOP0A		;NO
	SOS	T3		;YES. T3=DEFAULT BOOTS FOR RP04
IFN FTKL10,<
	PUSHJ	P,WHATRH	;SET T1=0 IF RH10, =2 IF RH20
IFE STDWTB,<
	ADD	T3,T1		;T3=6 IF RH20/RP0X
>
IFN STDWTB,<
	MOVE	T3,T1		;T3=0 OR 2 IF RH10 OR RH20
>
>
LOOP0A:
IFE STDWTB,<
IFN FTKS10,<
	MOVEI	T3,2		;DEFAULT IS RH11 BOOTS
>;END IFN FTKS10
	SKIPE	SHUTUP		;VERBOSITY?
	JRST	LOOP1		;NO
	OUTSTR	[ASCIZ /UNIT /]	;TELL HIM WHAT WE'RE ASKING
	PUSHJ	P,OUTSIX	; AND THE UNIT NAME
	OUTSTR	[ASCIZ /(/]
	MOVE	T2,DSKTAB+.DCULN ;LOGICAL NAME
	PUSHJ	P,OUTSX1	; TELL HIM
	CAIN	T,4		;AN RS04?
	JRST	[OUTSTR [ASCIZ /):
/]
		JRST LOOP1]	;YES, ONLY ASK ABOUT THE READIN LOADER
	OUTSTR	[ASCIZ /): /]
	PUSHJ	P,GETCHR	;GET HIS RESPONSE
	CAIN	CH,"S"		;SKIP?
	JRST	LOOP		;YES, WRITE NOTHING
	CAIN	CH,12		;<CR>?
	JRST	LOOP1		;YES, WRITE DEFAULT
	SETO	T3,		;ASSUME SYNTAX ERROR
IFE FTKS10,<
	CAIN	CH,"D"		;DPC BOOTS?
	MOVEI	T3,2		;YES, REMEMBER THAT
	CAIE	CH,"R"		;RP0X BOOTS?
	JRST	LOOP0B		;NO
	MOVEI	T3,4		;YES, REMEMBER THAT
IFN FTKL10,<
	CAIN	CH2,"2"		;RH20?
	MOVEI	T3,6		;YES, REMEMBER THAT
>
>
IFN FTKS10,<
	CAIN	CH,"R"		;RH11 BOOTS?
	MOVEI	T3,2		;YES; REMEMBER THAT
>
LOOP0B:	CAIN	CH,"Z"		;WRITE ZEROES?
	MOVEI	T3,0		;YEAH, REMEMBER THAT
	JUMPL	T3,HELP		;IF NONE OF THE ABOVE, COACH THE GUY
>
LOOP1:	OPEN	C,OPENDT	;YES, OPEN THIS UNIT FOR BUSINESS
	  JRST	EOPEN		;ERROR RETURN FROM OPEN
IFE TEST,<
	CAIN	T,4		;RS04?
	JRST	WRTLDR		;YES, ONLY WRITE READ-IN LOADER
	MOVEI	T1,BOOTLB	;START AT FIRST LOGICAL BLOCK FOR BOOTS
	PUSHJ	P,UUSET		;POSITION THE DEVICE
	STATZ	C,760000	;SUPER USETO SUCCESSFUL?
	JRST	NOT12		;NO, PROBABLY NOT UNDER [1,2]
IFN STDWTB,<
IFE FTKL10,<
	OUT	C,BOOTCL	;YES, WRITE OUT BOOTS
>
IFN FTKL10,<
	OUT	BOOTCL(T3)	;YES, WRITE OUT BOOTS
>
>
IFE STDWTB,<
	OUT	C,BOOTCL(T3)	;YES, WRITE OUT BOOTS
>
	SKIPA
	  JRST	ERRWRT		;ERROR WRITING
	CAIE	T,5		;WROTE OK. RP04?
	JRST	LOOP		;NO, TRY NEXT UNIT
WRTLDR:
IFN STDWTB,<
	JUMPN	KL,LOOP		;IF ON A KL10 DONT WRITE IN BLOCK 0
				; (FRONT END MIGHT NEED IT)
>
IFN FTKS10,<
	JRST	LOOP		;WE DON'T USE BLOCK 0 ON KS10
>
	MOVEI	T1,0		;YES, SET TO WRITE READIN LOADER
	PUSHJ	P,UUSET		;POSITION THE DEVICE
	STATZ	C,760000	;OK?
	JRST	NORDIN		;LOSE, TELL USER AND LOOP
	MOVSI	T,-REDLEN+3	;SET LH OF IOWD TO -200 IN 18-BIT MODE
IFE STDWTB,<
	SKIPE	SHUTUP		;VERBOSITY?
	JRST	LOOP2		;NO, SKIP QUESTIONS
	OUTSTR	[ASCIZ /READ-IN LOADER FOR 18 OR 22 BIT CHANNEL OR NONE?/]
	PUSHJ	P,GETCHR	;GET THE RESPONSE
	CAIN	CH,12		;CR TYPED?
	JRST	LOOP2		;YES, DO THE DEFAULT THING
	CAIN	CH,"N"		;NO LOADER?
	JRST	LOOP		;NO, PROBABLY A KL10
	CAIE	CH,"1"		;18?
	CAIN	CH,"2"		;OR 22?
	CAIA			;YES
	JRST	HELP		;NO, GIVE HIM SOME HELP
	CAIE	CH,"2"		;22 BIT MODE LOADER?
	JRST	LOOP3		;NO, 18 BIT
	JRST	LOOP2A
LOOP2:>
	JUMPN	KL,LOOP		;NO LOADER IF A KL10 (RSX20F USES BLOCK 0)
	TRNE	D,10000		; -200_4 (FOR DF10C) ON ALTERNATE UNITS
LOOP2A:	LSH	T,4		;READIN FROM AN EVEN UNIT IF 18-BIT DF10
LOOP3:	HLLM	T,REDATA	;READIN FROM AN ODD UNIT IF 22-BIT DF10
	OUT	C,REDCL		;OK, WRITE IT
>;END IFE TEST
IFN TEST,<
	MOVE	T,[C_5,,BOOTLB]
	SUSET.	T,		;POSITION THE DEVICE
	  JRST [CAME T,[C_5,,BOOTLB]
		JRST NOT12
		USETI C,[BOOTLB] ;START AT FIRST LOGICAL BLOCK FOR BOOTS
		JRST	.+1]	;AND CONTINUE
	STATZ	C,760000	;SUPER USETI SUCCESSFUL?
	JRST	NOT12		;NO, PROBABLY NOT UNDER [1,2]
	IN	C,BOOTCL	;YES, READ BOOTS BLOCKS - ANY ERRORS?
>
	JRST	LOOP		;NO, GO LOOK AT NEXT UNIT IN SYSTEM
ERRWRT:	TTCALL	3,[ASCIZ /DEVICE OR DATA ERROR - CONTINUING ON NEXT UNIT
/]
	JRST	LOOP

FINISH:	EXIT			;DONE ALL UNITS IN SYSTEM, EXIT TO MONITOR
IFE STDWTB,<
OUTSIX:	MOVE	T2,D		;SIXBIT TO BE TYPED
OUTSX1:	MOVEI	T1,0		;ZERO RESULT
	LSHC	T1,6		;SHIFT NUMBER INTO T1
	JUMPE	T1,CPOPJ	;DONE IF NO CHARACTERS LEFT
	ADDI	T1,40		;CONVERT TO ASCII
	OUTCHR	T1		;PRINT THE RESULT
	JRST	OUTSX1		;GET THE NEXT CHARACTER

GETCHR:	INCHWL	CH
	CAIN	CH,32
	EXIT
	CAIN	CH,15
	JRST	GETCHR
	CAIN	CH,33
	MOVEI	CH,12
	CAIN	CH,12
	POPJ	P,
	INCHWL	T1		;GET 2ND CHAR
	SKIPA	CH2,T1		;SAVE IT IN CH2
GETCH1:	INCHWL	T1
	CAIN	T1,32
	EXIT
	CAIE	T1,12
	CAIN	T1,33
CPOPJ:	POPJ	P,
	JRST	GETCH1
>

UUSET:	PUSH	P,T1
	HRLI	T1,<4000+C>_5	;OUTPUT ON CHANNEL C
	PUSH	P,T1
	SUSET.	T1,		;POSITION THE DEVICE
	  JRST	[CAME T1,(P)
		JRST NOT12	;IF IMPLIMENTED, MUST NOT BE PRIVILEDGED
		USETO C,-1(P)	;SUSET LOST, IT MUST NOT BE IMPLIMENTED
		JRST .+1]
	POP	P,(P)
	POP	P,T1
	POPJ	P,
IFN FTKL10,<
;SUBROUTINE TO DETERMINE IF AN RP0X PACK IS ON AN RH10 OR RH20
OPDEF DIAG. [CALLI 163]
WHATRH:	MOVE	T4,[2,,T1]
	MOVEI	T1,7		;DIAG FUNCTION TO GET KONTROLLER
	MOVE	T2,DSKNM
	DIAG.	T4,
	  JRST	NODIAG		;DIAG. NOT IMPL'D
	CAMGE	T4,[540,,]	;RH20?
GUESS:	TDZA	T1,T1		;NO, T1=0
	MOVEI	T1,2		;YES, T1=2
	POPJ	P,

NODIAG:	MOVE	T1,[7,,16]	;SYSUNI
	GETTAB	T1,
	  JRST	GUESS		;CANT  FIND START OF CHAIN
WHATR1:	HLRZS	T2,T1
	JUMPE	T2,GUESS	;LOSE IF END OF CHAIN
	PEEK	T1,		;UNINAM
	CAME	T1,DSKNM
	JRST	WHATR2		;NOT THIS ONE
	MOVEI	T1,6(T2)	;POINT AT UNIKON
	PEEK	T1,
	MOVEI	T1,113(T1)	;RPXDI2
	PEEK	T1,
	TDZ	T1,[DATAI 7]
	TDNE	T1,[700077,,-1]	;DATAI T2, OR DATAO T1, ?
	JRST	GUESS		;NO, WHO KNOWS?
	CAMGE	T1,[54000,,]
	TDZA	T1,T1		;RH10
	MOVEI	T1,2		;RH20
	POPJ	P,
WHATR2:	MOVEI	T1,3(T2)	;POINT TO NEXT UNIT
	PEEK	T1,
	JRST	WHATR1		;TRY IT

>
ESYSPH:	TTCALL 	3,[ASCIZ /SYSPHY UUO ERROR RETURN - TRY LATER MONITOR
/]
	EXIT

EDSKCH:	TTCALL	3,[ASCIZ /DSKCHR UUO ERROR RETURN - TRY LATER MONITOR
/]
	EXIT

EOPEN:	TTCALL	3,[ASCIZ /OPEN UUO ERROR RETURN
/]
	EXIT

NOT12:	TTCALL	3,[ASCIZ /SUPER USETO FAILURE - LOGIN UNDER 1,2
/]
	EXIT

NOTFIV:	TTCALL	3,[ASCIZ /NOT A 5 SERIES MONITOR OR LATER
/]
	EXIT

NORDIN:	TTCALL	3,[ASCIZ /CANT WRITE READIN BLOCK - CONTINUING
/]
	JRST	LOOP
IFE STDWTB,<
HELPTX:ASCII \WTBOOT WILL ASK THE QUESTIONS "SELECT UNITS?"
IF THE ANSWER IS YES, WTBOOT WILL ASK YOU WHICH TYPE OF BOOTS TO
WRITE ON EACH UNIT IN THE SYSTEM BY TYPING "UNIT" FOLLOWED BY THE
UNIT NAME (NOTE THAT "RP0X" MEANS RP04, RP05, OR RP06). RESPOND WITH
\
IFE FTKS10,<
ASCIZ \	"DP" IF YOU WANT WTBOOT TO WRITE RP02/RP03 BOOTS ON THE
		PACK MOUNTED ON THAT UNIT
	"RP" IF YOU WANT WTBOOT TO WRITE RH10/RP0X BOOTS ON THE PACK
		MOUNTED ON THAT UNIT
\
>
IFN FTKS10,<
ASCIZ \	"RH" IF YOU WANT WTBOOT TO WRITE RH11/RP06/RM03 BOOTS ON THE
		PACK MOUNTED ON THAT UNIT
\
>
IFN FTKL10,<
HELPT2:ASCIZ \	"R2" IF YOU WANT WTBOOT TO WRITE RH20/RP0X BOOTS ON THE PACK
		MOUNTED ON THAT UNIT
\
>
HELPT3:ASCIZ \	"ZERO" IF YOU WANT THE MONITOR NEVER TO READ BOOTS FROM THAT
		PACK
	"SKIP" IF YOU DON'T WANT WTBOOT TO CHANGE THAT PACK
OR CARRIAGE RETURN IF YOU WANT WTBOOT TO WRITE THE DEFAULT BOOTS
\
HELPT4:IFE FTKL10!FTKS10,<
ASCIZ \(RP02/RP03 BOOTS ON RP02/RP03 PACKS, RP0X BOOTS ON RP0X PACKS).
\
>
IFN FTKL10,<
ASCIZ \(RP02/RP03 BOOTS ON RP02/RP03 PACKS, RH10/RP0X BOOTS ON RP0X PACKS
WHICH ARE ON RH10'S, RH20/RP0X BOOTS ON PACKS WHICH ARE ON RH20'S).
\
>
IFN FTKS10,<
ASCIZ \(RH11/RP06/RM03 BOOTS ON RP06/RM03 PACKS).
\
>
HELPT5:
IFE FTKS10,<
ASCII \FOR EACH RS04 OR RP0X, WTBOOT WILL ASK IF THE READIN LOADER SHOULD
BE WRITTEN IN 18 OR 22 BIT MODE FORMAT.  RESPOND WITH
	"NONE" IF NO READIN LOADER SHOULD BE WRITTEN ON BLOCK 0 (KL10)
	"18" IF THE UNIT IS NOT ON A CONTROLLER CONNECTED TO A DF10C,
		OR IF THE DF10C IS NORMALLY IN 18 BIT MODE.
	"22" IF THE DF10C IS NORMALLY IN 22 BIT MODE
OR CARRIAGE RETURN FOR THE DEFAULT (18 BIT ON EVEN UNITS, 22 ON ODD).
\
ASCIZ \
IF THE ANSWER TO "SELECT UNITS" IS NO, WTBOOT WILL WRITE THE
DEFAULT BOOTS ON ALL PACKS. IF WTBOOT IS BEING RUN ON A KL10
IT WILL NOT WRITE READIN LOADERS, IF NOT BEING RUN ON A KL10
WTBOOT WILL WRITE THE DEFAULT READIN LOADER ON ALL RS04'S AND RP0X'S.
\
>
IFN FTKS10,<
ASCIZ \
IF THE ANSWER TO "SELECT UNITS" IS NO, WTBOOT WILL WRITE THE
DEFAULT BOOTS ON ALL PACKS.
\
>
>
BOOTCL:
IFN STDWTB,<
	XWD	MBOOTL,BOOTSA-1	;IO LIST FOR BOOTS CORE IMAGE
IFN FTKL10,<
	0
	XWD	MBOOTL,BOOTS2##-1
>
	0
>
IFE STDWTB,<
IFE FTKS10,<
	XWD	MBOOTL,NULL-1
	0
	XWD	MBOOTL,BTDPSA##-1
	0
	XWD	MBOOTL,BTDHSA##-1
	0
IFN FTKL10,<
	XWD	MBOOTL,BTD2SA##-1
	0
>;END IFN FTKL10
>;END IFE FTKS10
IFN FTKS10,<
	XWD	MBOOTL,NULL-1
	0
	XWD	MBOOTL,BTRHSA##-1
	0
>;END IFN FTKS10

SHUTUP:	0

>;END IFE STDWTB

OPENDT:	XWD	0,17		;DUMP MODE
DSKNM:	0			;DEVICE NAME
	0			;BUFER HEADERS
.DCSNM==4			;STR NAME FOR DSKCHR UUO
.DCULN==14			;UNIT LOGICAL NAME
.DSLEN==24			;NO. OF VALUES FOR DSKCHR
DSKTAB:	BLOCK	.DSLEN		;DSKCHR VALUES
IFE STDWTB,<
NULL:	BLOCK	1000
>
PDL:	BLOCK	10
	LIT
REDCL:	XWD	-REDLEN,REDATA-1
	0

REDATA:
	PHASE	175600		;READ INTO TOP OF 63K
				;(LAST WORD EXECUTED, NOT STORED IN CORE)
RDSTRT:
BOOTWD==22	;LOW CORE IOWD ADDRESS
DHX==270	;FIRST RH10 DEVICE CODE
DHX2==274	;SECOND RH10
DHX3==360	;3RD RH10

	XWD	-REDLEN+3,.	;IOWD FOR THE HARDWARE TO USE

RDBOOT:	MOVSI	T1,-BTBLEN	;BEFORE A CONO 2000 IS DONE WE MUST
GETUNI:	MOVE	T4,BTABLE(T1)	; DO DATAI'S ON ALL RH10'S TO FIND
	XCT	2(T4)		; WHICH UNIT THE RH10 IS CURRENTLY TALKING TO
	TLZ	T3,777770	;UNIT
	HLLM	T3,BTABLE(T1)	;SAVE UNIT NUMBER IN TABLE
	AOBJN	T1,GETUNI
	HRLOI	T,010500
	IBP	T
	TLNE	T,77		;KA OR KI?
	TROA	T,AP.NXM	;KA
	MOVEI	T,IP.NXM	;KI
	MOVEI	P2,776777	;FIND HIGHEST CORE IN MACHINE
NXMLUP:	CONO	APR,200000(T)
	MOVS	(P2)		;REFERENCE  2 PAGES
	MOVS	1(P2)		; FOR BOOTS CODE AND DATA
	CONSO	APR,(T)		;NXM?
	JRST	INHERE		;THIS MUST BE THE PLACE
	SUBI	P2,1000		;NXM, TRY NEXT LOWER PAGE
	JRST	NXMLUP

INHERE:	HRRM	P2,BOOTWD	;ADDRESS TO READ BOOTS
	MOVSI	T1,-BTBLEN
KONLUP:	HLRZ	T2,BTABLE(T1)	;START WITH UNIT LOADER WAS READ FROM
UNILUP:	CONO	APR,200000	;CLEAR THE WORLD
	MOVE	T4,BTABLE(T1)
	MOVEI	T,MBOOTL
	XCT	4(T4)		;CONI T3
	TLNE	T3,4000		;DF10C?
	LSH	T,4		;YES, 22 BITS OF ADDRESS
	HRLM	T,BOOTWD	;SAVE LH(IOWD)
	SETZM	BOOTWD+1	;SO WE WILL TERMINATE RIGHT
	TRNN	T2,10		;AN ARTIFACT IN CASE LOADER WAS READ FROM DRIVE 7
	JSR	RPREAD		;START THE READ
	  JRST	UNINXT		;NOT AN RP04
	MOVEI	T3,40000
	XCT	(T4)		;WAIT TILL DONE
	SOJG	T3,.-1
	MOVE	T,UNILUP
	CAMN	T,1(P2)		;READ BOOTS?
	JUMPG	T3,UNICHK	;YES, IF DIDN'T TIME OUT
UNINXT:	AOBJN	T2,UNILUP	;NO, TRY NEXT UNIT
	CAIN	T2,11		;IF DONE AOBJN LOOP,
	JRST	KONNXT		; TRY NEXT CONTROLLER
	MOVSI	T2,-11		;ONLY TRIED UNIT LOADER WAS READ FROM,
	JRST	UNINXT		;GO TRY ALL UNITS ON CONTROLLER
KONNXT:	AOBJN	T1,KONLUP	;TRY NEXT KONTROLLER
	HALT	10		;COULDNT FIND BOOTS
UNICHK:	JSR	RPCHEK		;BOOTS WAS READ, ANY ERRORS?
	  JRST	UNINXT		;YES, TRY NEXT UNIT

	MOVE	T1,[POINT 8,BOOTXT] ;TYPE "BOOTS" ON CTY
TYPLUP:	ILDB	T2,T1
	JUMPE	T2,1(P2)	;START BOOTS IF DONE
	DATAO	TTY,T2
	CONSZ	TTY,20
	JRST	.-1
	JRST	TYPLUP

;"BOOTS <CR><LF> " IN EVEN PARITY
BOOTXT: BYTE (8)102,317,317,324,123,215,12
RPREAD:	0
	MOVSI	T3,4000(T2)	;DATAO DRIVE CONTROL REGISTER
	HRRI	T3,21
	XCT	1(T4)		;READIN PRESET
	MOVSI	T3,60000(T2)
	XCT	1(T4)		;DATAO DRIVE-TYPE
	IMULI	1
	XCT	2(T4)		;READ STATUS
	TLNN	T3,2000		;CBTO?
	ANDI	T3,777		;NO, GET TYPE
	CAIL	T3,20		;IS IT AN RP04?
	CAILE	T3,22		; OR AN RP06?
	JRST	@RPREAD		;NO
	AOS	RPREAD		;YES, SET FOR SKIP-RETURN
	MOVSI	T3,54000(T2)
	HRRI	T3,4
	XCT	1(T4)		;DESIRED SECTOR = 4
	TDC	T3,[450000,,200075!BOOTWD_6]
	XCT	1(T4)		;READ, DXES
	JRST	@RPREAD		;AND RETURN
RPCHEK:	0
	MOVSI	T3,10000(T2)
	XCT	1(T4)		;DATAO STATUS
	IMULI	1
	XCT	2(T4)		;DATAI STATUS
	XCT	3(T4)		;CONSO
	TRNE	T3,40000	;ERROR?
	JRST	@RPCHEK		;YES, RETURN
	AOS	RPCHEK		;NO, SKIP
	JRST	@RPCHEK

BTABLE:	EXP	RPINST
	EXP	R2INST
	EXP	R3INST
BTBLEN==.-BTABLE

RPINST:	CONSO	DHX,10
	DATAO	DHX,T3
	DATAI	DHX,T3
	CONSO	DHX,736320
	CONI	DHX,T3
R2INST:	CONSO	DHX2,10
	DATAO	DHX2,T3
	DATAI	DHX2,T3
	CONSO	DHX2,736320
	CONI	DHX2,T3
R3INST:	CONSO	DHX3,10
	DATAO	DHX3,T3
	DATAI	DHX3,T3
	CONSO	DHX3,736320
	CONI	DHX3,T3
LIT

	XWD	-1,.		;FUNNY IOWD FOR READIN TO USE
	JRST	RDBOOT		;THIS INSTR EXECUTED AT END OF READIN
REDLEN==.-RDSTRT
DEPHASE
	END BEG
