TITLE UMOUNT - USER HALF OF MOUNT, DISMOUNT, & FILE COMMAND V.26
;COPYRIGHT 1972,1973,1974 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
SUBTTL D BLACK 30-OCT-72 /JHT
VWHO==0		;WHO LAST PATCH'D
VMAJOR==26	;MAJOR VERSION NO.
VMINOR==1	;MINOR VERSION NO.
VEDIT==103	;EDIT LEVEL
VUMOUN==BYTE(3) VWHO (9) VMAJOR (6) VMINOR (18) VEDIT

;REVISION HISTORY STARTED 10/74 BY J. TALMADGE
;
;	1	GET STARTED
;
;	2	FIX INCONSISTENCY IN MSG112: NONE PENDING FOR /CHECK
;		SER
;
;	3	CHKACC FOR FILE COMMANDS FAILS FOR PROTECTION <055>:
;		MOVE SHOULD BE MOVEI
;
;	4	DEVICE NUL: REQUIRES /REELID!
;		 AREA AFFECTED: MOUNT
;
;	5	PUT FILE CODE UNDER CONDITIONAL
;
;	6	ADD /SHOVE & /NOSHOVE SWITCHES
;		 AREA AFFECTED: ERR911
;
;	7	FIX PROBLEM WITH ^Z.
;		 AREA: R.TTY
;
;	10	CORRECT FACT FILE PROCESSING TO CALL DAEMON ONLY IF
;		OMOUNT WAS NEVER INVOLVED.
;
;	11	ADD ^C INTERCEPT AND THEREBY TYPE-AHEAD.
;
;	12	DISALLOW /WAIT WITH OTHER STUFF; DELETE /NOWRITE;
;		IMPLEMENT /NOWAIT
;		 AREA AFFECTED: UMSLST,UMSWAI,UMSNOW,OPREQ2...
;
;	13	DELETE SOME CODE NOT NEEDED WITH ^C INTERCEPT
;		 AREA AFFECTED: OPREQ2
;
;	14	CHANGE %SS002 FEATURE TEST TO FTSPTB
;		 AREA AFFECTED: RCOML, FCOML
;
;	15	MOUNT/CHECK WON'T WORK IF USER NOT LOGGED IN
;		 AREA AFFECTED: MOUNT
;
;	16	IF RIDSW = 0, A MOUNT TO A NON-MTA DEVICE WITHOUT A 
;		REELID WILL GET ERR105
;		 AREA AFFECTED: MOUNT0
;
;	17	CHANGE AROUND OLD VIDSW AND CURRENT %SS006 TO DO CORRECT
;		THING. NO NEED TO HAVE BOTH FEATURE TESTS
;
;	20	FIX UMOUNT'S FACT FILE STUFF FOR DISMOUNT
;
;	21	DISALLOW /WRITE W NO ARGUMENT SINCE /NOWRITE WAS DELETED 
;		IN EDIT 12
;
;	22	GOVERN R.NJAC BY [1,2] AS WELL AS JACCT FOR DEBUGGING
;
;	23	DATE75 BUG IN SET UP FOR EXTENDED LOOKUP/ENTER/RENAME
;		AREA AFFECTED: SETEXL
;
;	24	FIX GETQUO ROUTINE TO HANDLE (777777,,777777) ENTRY IN 
;		QUOTA.SYS.  NOW UMOUNT GETS CONFUSED OVER WHERE IT IS IN
;		THE FILE AND THE RESULT WAS THAT IF -1 EXISTED, THE DEFAULT
;		QUOTAS WERE USED EVEN IF THE USER HAD AN ENTRY IN QUOTA.SYS.
;		SPR 14783
;		 AREA AFFECTED: GETQUO
;
;	25	CHANGE %SS015 TO LOGSW; DELETE %SS021: MAKE IT THE ONLY WAY
;
;	26	ALLOW ALL OPTIONS FOR WRITE-LOCK AND WRITE-ENABLE FOR
;		FILE STRUCTURES AND NON-FILE STRUCTURES
;		 AREA AFFECTED: CONDITIONALS,MOUNT,MOOP2,MOFS
;
;	27	IMPLEMENT /NOWAIT FOR BATCH'S SAKE
;
;EDIT 27 WENT TO FIELD TEST 1/15/75
;
;	30	COMPLETE /NOWAIT AND /WAIT IMPLEMENTATION
;		AREA AFFECTED: REMREQ, DMSWAI, UMSWAI
;
;	31	IN FINDING DEVICE WHERE FILE CMD DIRECTORY SHOULD GO,
;		VERIFY THERE'S A UFD.  IF NONE, PASS DSK: TO OMOUNT, WHICH
;		HAS TO BE CHANGED TOO.  ALSO, CATCH FILE R WITHOUT FILE
;		SPEC IF DSK: HAS NO UFD
;		QAR 3303
;		 AREA AFFECTED: NXTST, RCOML, COMSET
;
;	32	CHANGE FACT FILE BLOCK: COMBINE F.ELPD AND F.UNIT INTO
;		F.UNIT WITH FLAGS IN LH AND UPTIME IN RH. ALSO CHANGE
;		CODE TO 271 FROM 251.
;
;	33	IF /REASSIGN GIVES INVALID JOB NO., IT WILL LOOP
;		ISSUING MSG '.../RELEASE ASSUMED'. SETZM TOJOB NEEDED.
;		QAR 3313
;		 AREA AFFECTED: DISMN4
;
;	34	DEV: NOT ASSIGNED' MESSAGE FROM DISMOUNT DOESN'T EXIT
;		BUT IN FACT WILL LEAD TO AN EXTRA DISMOUNT ENTRY IN THE
;		FACT FILE. HAVE IT TERMINATE IMMEDIATELY.
;		QAR 3304
;		 AREA AFFECTED: MSG105, DISMN1
;
;	35	CLOSE HOLES IN FACT LOGIC THAT ALLOWED BOTH UMOUNT AND
;		AND OMOUNT TO WRITE FACT RECORDS ON DISMOUNT. SET
;		IDIDIT IN COMBEG NOT MSG110 WHICH IS ONLY CALLED IF USER
;		CHOSE TO WAIT ON DISMOUNT.
;		QAR 3315,3338,3387,3391,3392
;		 AREA AFFECTED: COMBEG, MSG110
;
;	36	HAVE CKEOL EAT TRAILING BLANKS AND TABS SO GOOD COMMAND
;		WITH OR WITHOUT COMMENT WILL NOT GET ?SYNTAX ERROR. ADD
;		PUSHJ P,SST...
;		QAR 3361,3382
;		 AREA: CKEOL
;
;	37	CHANGE VUMOUN TO STANDARD FIELDS
;		QAR 3332
;
;	40	CORRECT CHECK FOR LEVEL-C IN INITIALIZATION
;		QAR 3345
;		 AREA AFFECTED: REGO
;
;	41	SET REELID IF WE DO THE MOUNT!
;		QAR 3363
;		 AREA: MOUNT3
;
;	42	CLEAR SOME BITS IN MOUNT CODE FOR NON-F/S SO F/S SWITCHES
;		ARE NOT SENT TO OMOUNT.
;		QAR 3370
;		AREA: MOUNT1
;
;	43	MOVE GETTAB FOR EFFICIENCY
;		QAR 3333
;		 AREA: CCOM3
;
;	44	FIX CODE THAT INTERCEPTS TAPE ALREADY UNLOADED ON UNLOAD
;		UMOUNT WAS LEAVING INTBLK POINTING TO DISM0A WHICH WOULD
;		LEAVE THE POSSIBILITY OF A DISMOUNT MESSAGE, REQUEST, AND
;		FACT ENTRY BEING DONE TWICE IF USER HIT 2 ^C'S AFTER 
;		SETTING UP INTBLK FOR THE UNLOAD TRAP.  INTBLK SHOULD BE
;		RESET TO WHAT IT LOOKED LIKE BEFORE THE UNLOAD CODE ENTERED.
;		QAR 3334,3389
;		 AREA: DISM0A
;
;	45	ADD ? TO 'STRUCTURE NOT MOUNTED' MESSAGE
;		QAR 3347
;		 AREA: ERR6
;
;	46	IN VERIFYING CMDSTR, DO PHYSICAL ONLY DSKCHR TO AVOID
;		NEEDLESS ERROR IF IT'S ASSIGNED AS LOGICAL NAME FOR
;		ANOTHER NON-DISK DEVICE
;		QAR 3352
;		 AREA: STR12
;
;	47	ALLOW "!" AS COMMENT CHARACTER
;		QAR 3388
;		 AREA: CKEOL
;
;	50	RELEASE A NON FILE STRUCTURE DEVICE AFTER REASSIGNING
;		IT SO OMOUNT DOESN'T THINK WE STILL HAVE IT.
;		QAR 3314
;		 AREA DISM0B
;
;	51	GENERAL ERRORS TRYING TO CREATE CMD FILE YIELDED
;		"SYSTEM ERROR AT LOC..."  CHANGE TO "?UNABLE TO CREATE
;		QUEUE REQUEST, ENTER CODE = ..."
;		 AREA: FILENF
;
;	52	DON'T CHECK QUOTAS, ETC. ON F/S BEING DISMOUNTED IF USER
;		HAS NO UFD.
;		QAR 3356
;		 AREA: DISMN3
;
;	53	DON'T TYPE "%SPECIFIED LOGICAL NAME IN USE" IF USER MOUNTS
;		A DEVICE USING LOGICAL NAME THAT IS ALREADY ASSIGNED.
;		QAR 3337
;		 AREA:CKLOG3
;
;	54	DON'T GIVE "UFD RENAME ERROR 26" IF USER DISMOUNTS A F/S
;		WITH /NOWRITE SET
;		QAR 3351
;		 AREA: UFDCCB
;
;	55	DO PHYSICAL ONLY OPEN ON TTY SO IF ITS ASSIGNED AS LOGICAL
;		NAME FOR ANOTHER DEVICE, UMOUNT WILL NOT GET CONFUSED.
;		QAR 3357
;		 AREA: REGO
;
;	56	HAVE UMOUNT BE ABLE TO ALWAYS WRITE FACT ENTRIES DEPEND
;		ON 'FTFCT1' WHICH WILL BE TURNED OFF.
;		QAR 3365,3393
;
;	57	ALLOW TABS IN VID
;		QAR 3335
;		 AREA: VIDIN3
;
;	60	CLEAR L.SIN IF /MULTI USED (ELSE: MOU STR/SINGLE/MULTI
;		WILL REQUEST SINGLE ACCESS.
;		QAR 3379
;		 AREA: UMSMUL
;
;	61	CHANGE PAGE PSEUDO-OPS TO FORM FEEDS
;		QAR 3330
;
;	62	EDIT 54 TRIED VERY HARD TO FIX THE RENAME ERROR, BUT
;		DIDN'T REALIZE THAT THE MONITOR HAD REGISTERED THE /RONLY
;		STATE OF THE STR. ON THE LOOKUP AND STILL TREATED IT AS
;		THOUGH IT WERE IN THAT STATE EVEN AFTER THE STRUUO TO
;		CLEAR THE /RONLY STATUS.  TO KEEP THE MONITOR ADVISED
;		OF WHAT WE'RE DOING WE MUST CLOSE THE STR (CHNL USR) 
;		BEFORE THE RENAME
;		 AREA: UFDCLF
;
;	63	EDIT 46 DID NOT ALLOW FOR CHANNEL CMU, WHICH MUST BE
;		OPENED PHYSICAL ONLY.
;		 AREA: STAR12
;
;	64	PUT IN VIDRID CONDITIONAL WHICH WILL CAUSE A VID TO BE
;		IF A REELID IS NOT SUPPLIED FOR A MAGTAPE. 
;		QAR 3307,3368
;		 AREA: MOUNT
;
;	65	ADD -1 SETTING TO RIDSW WHICH WILL NOT FORCE USER TO 
;		GIVE REELID FOR MAGTAPE MOUNT IF THE REQUEST IS GOING
;		TO THE OPERATOR. CONTINUE TO REQUIRE IT IF UMOUNT WILL
;		DO THE ENTIRE MOUNT
;		QAR 3339
;
;	66	RELEASED AS VERSION 26(66) IN APRIL, 1975
;
;	MAKE EDIT 100 THE FIRST EDIT OF 26A
;
;	100	MAKE UMOUNT SMARTER ABOUT ERSATZ DEVICES (EG. SYSA,HLPB)
;		THESE NAMES NOW GIVE VERY CONFUSING SET OF MESSAGES
;		SPR 15615
;		 AREA:MOUNT
;
;	101	REELID DOESN'T GET SET IF USER OWNS DRIVE BUT OMOUNT IS
;		NEEDED
;		SPR 16466
;		 AREA: MOOP1
;
;	102	UMOUNT DOES NOT CHECK PHYSICAL DEVICE WHEN IT SHOULD
;		IN GENERATING LOGICAL NAME
;		SPR 16467
;		 AREA: NAMPHY
;
;	103	UMOUNT GIVES 'LOGICAL NAME IN USE' MESSAGE AND GENERATES
;		NEW LOGICAL NAME WHEN IT SHOULDN'T, NAMELY IF USER
;		MOUNTS A DEVICE BY A LOGICAL NAME HE IS ALREADY USING
;		SPR 16468
;		 AREA: ASLOG
;
;[END OF REVISION HISTORY]

IFNDEF PURESW,<PURESW==1>	;NON-ZERO MAKES REENTRANT SHARABLE
IFNDEF MNTSW,<MNTSW==1>		;NON-ZERO INCLUDES MOUNT STUFF
IFNDEF VIDSW,<VIDSW==1>		;NON-ZERO REQUIRES /VID  SWITCH FOR MOUNTING
				;  NON-STRUCTURE DEVICES

IFNDEF RIDSW, <RIDSW==1>	;NON-ZERO REQUIRES /REELID FOR MOUNTING MAGTAPES
				; IF +1, USER MUST ALWAYS GIVE REELID
				; IF -1, USER MUST GIVE REELID ONLY IF
				;	 HE IS DOING THE MOUNT (I.E.,
				;	 WHEN OMOUNT NOT CALLED)

IFNDEF VIDRID, <VIDRID==0>	;NON-ZERO ALLOWS VID TO BE USED AS REELID
				;  FOR MAGTAPE


IFNDEF WLSW,	<WLSW==0>	;NON-ZERO MAKES WRITE-LOCK DEFAULT FOR ALL
IFNDEF WESW,	<WESW==0>	;NON-ZERO MAKES WRITE-ENABLE DEFAULT FOR ALL
IFNDEF WLFS,	<WLFS==0>	;NON-ZERO MAKES W/L DEFAULT FOR F/S'S
IFNDEF WLNOFS,	<WLNOFS==1>	;NON-ZERO MAKES W/L DEFAULT FOR NON-F/S'S
IFNDEF WEFS,	<WEFS==1>	;NON-ZERO MAKES W/E DEFAULT FOR F/S'S
IFNDEF WENOFS,	<WENOFS==0>	;NON-ZERO MAKES W/E DEFAULT FOR NON-F/S'S

IFN WLSW,	<WLFS==1	;NON-ZERO MAKES WRITE LOCK DEFAULT CONDITION
		WLNOFS==1>	;  FOR ALL MOUNT REQUEST

IFN WESW,	<WEFS==1	;NON-ZERO MAKES WRITE ENABLE DEFAULT CONDITION
		WENOFS==1>	;  FOR ALL MOUNT REQUESTS

IFN WLSW,	<IFN WESW,<PRINTX<Conditional inconsistency: WLSW&WESW = 1>
END>
	IFN WEFS,	<PRINTX<Conditional inconsistency: WLSW&WEFS - WEFS==0>
	WEFS==0>

	IFN WENOFS,	<PRINTX<Conditional inconsistency: WLSW&WENOFS - WENOFS==0>
	WENOFS==0>>

IFN WESW,	<IFN WLFS,<PRINTX<Conditional inconsistency: WESW&WLFS=1 - WLFS==0>
	WLFS==0>

	IFN WLNOFS,<PRINTX<Conditional inconsistency: WESW&WLNOFS=1 - WLNOFS==0>
	WLNOFS==0>>

IFN WLNOFS,	<IFN WENOFS,<PRINTX<Conditional inconsistency: WENOSW&WLNOFS=1>
	END>>

IFN WLFS,	<IFN WEFS,<PRINTX<Conditional inconsistency: WEfs&WLFS=1>
	END>>

IFE WLFS,	<IFE WEFS,<PRINTX<Conditional inconsistency: WEfs&WLFS=0>
	END>>

IFE WLNOFS,	<IFE WENOFS,<PRINTX<Conditional inconsistency: WENOSW&WLNOFS=0>
	END>>

IFNDEF ACTSW,<ACTSW==1>		;NON-ZERO PUTS STRUCTURE INTO ACTIVE
				;SEARCH LIST; 0 PUTS IT IN PASSIVE LIST
IFNDEF DBUGSW,<DBUGSW==0>	;NON-ZERO FOR DEBUGGING
IFNDEF JACTSW,<JACTSW==1>	;NON-ZERO TO REQUIRE SENSITIVE PARTS TO
				;RUN UNDER JACCT (SHOULD=0 ONLY FOR DEBUGGING

IFNDEF MPBWAI,<MPBWAI==1>	;NON-ZERO HAS MPB JOB DO AUTOMATIC /WAIT
				;AFTER FILE COMMAND

IFNDEF FILESW,<FILESW==1>	;IF NON-ZERO, INCLUDE FILE CODE

IFNDEF FTSPTB,<FTSPTB==0>	;TREAT SPACE, TAB (AS WELL AS COMMA) AS FILENAME DELIMITERS

IFNDEF UNLOSW, <UNLOSW==1> ;+1 = /UNLOAD, 0 = /REWIND, -1 = /STAY
			     ;AS DEFAULT FOR TAPE POSITIONING

IFNDEF LOGSW,<LOGSW==1>	;FIXES VARIOUS DEVICE ALLOCATION PROBLEMS
		; GENERATE A LOGICAL NAME IF NONE SPECIFIED
		; ALWAYS PRINT PHYSICAL NAME ASSIGNED
		; IF THE USER-SPECIFIED LOGICAL NAME IS IN USE,
		;   DELETE IT FROM THE PREVIOUS DEVICE

IFNDEF PTHLEN, <PTHLEN==4+^D5> ;MAX LTH OF SFD PATHS

IFNDEF SPONUL,<SPONUL==1>	;SUPPORT MOUNT OF SPOOLED DEVICES & DEVICE NUL:

IFNDEF MTA0SW,<MTA0SW==0>	; TREAT MTA0 AS A SPECIAL 7-TRACK DRIVE 
				;THIS CAN BE USED IF MTA0(OR ANY OTHER 
				;SINGLE DRIVE) IS THE ONLY 7- OR 9- TRACK
				;DRIVE IN THE SYSTEM: SEE REFERENCE TO MTA0SW
				;WARNING** THIS CODE SHOULD ONLY BE USED
				;AS A GUIDE FOR EACH INSTALLATION'S
				;IMPLEMENTATION OF SEPARATING 7- AND 9-
				;TRACK DRIVES**

IFNDEF FTFACT, <FTFACT==1	;ADD DEC-STYLE FACT ACCOUNTING FOR MOUNT & DISMOUNT
				;FILE COMMAND FACT CODE IS ALL IN OMOUNT
	IFN FTFACT,<
		IFNDEF FTFCT1,<FTFCT1==0>>>	;NON-ZERO MEANS FOR UMOUT
				;TO ALWAYS WRITE FACT ENTRIES WHETHER OR
				;NOT OMOUNT CALLED



EXTERN .JBFF,.JBREL,.JBSA,.JBDDT,.JBINT

MLON

.JBVER==137

LOC .JBVER
EXP VUMOUN

;-------STORAGE ZZCROS
IFN PURESW,<
TWOSEG
RELOC	0
RELOC	400000

DEFINE	UU(A,B)<
RELOC
A:	BLOCK	B
RELOC
>

> ;IFN PURESW

IFE PURESW,<
RELOC

DEFINE UU(A,B)<
A:	BLOCK	B
>

> ;IFE PURESW

DEFINE	U(A)<UU(A,1)>
;AC'S
F=0
A=1
B=2
C=3
D=4
E=5

NUM=7
IO=10
M=11
N=12
N1=13
BP=14
CH=15
WD=16
P=17

;I/O CHANNELS

CMD==1		;WRITE COMMAND FILE TO OPR
USR==2		;TEMP
CMU==3		;READ DIRECTORY OF COMMAND AREA
TTY==4		;USER'S TTY
US1==5		;TEMP

;SPECIAL CHARACTERS

CHRLIN=="-"	;FOR LINE CONTINUE

VIDMAX==^D50	;MAX # CHAR.S IN /VID SWITCH

;DELIMITERS FOR /VID SWITCH TEXT
VIDCH1=="'"	;SINGLE QUOTES
VIDCH2==42	;DOUBLE QUOTES
CMDSTX==SIXBIT/DSK/	;DEFAULT 3,3 AREA
CMDPPX==3,,3
STLSTX==SIXBIT/SYS/	;WHERE TO FIND STRLST?SYS
STLPPX==0

;SPECIAL NAMES

SYSFIL==SIXBIT/OPRFIL/	;PROG.NAME OF OMOUNT DOING FILE COMMANDS
SYSMOU==SIXBIT/OPRMNT/	;... DOING MOUNT/DISMOUNT COMMANDS
SYSOMO==SIXBIT/OPROMO/	;... DOING BOTH

;MISC VALUES AND BITS

FILSLP==^D15	;SEC'S TO SLEEP ON 'FILE W' (IF NO HIBER)
MOUSLP==^D15	;SEC'S TO SLEEP ON MOUNT/DISMOUNT (IF NO HIBER)
DTDNFI==^D22		;MAX NUMBER OF FILES ON A DECTAPE
CNTRLC==3		;ASCII FOR CONTROL C
ALTMO==33		;ASCII FOR ALTMODE
;GETTAB ARGUMENTS

	CNFTBL==11	;CONFIGURATION TABLE
	SEGPTR==15	;INDEX FOR SEGS, JOBS
	PRJPRG==2	;PRJPRG TABLE
	JBTPRG==3	;JBTPRG TABLE
	JBTSTS==0	;JBTSTS TABLE
	JACCT==1	;JACCT BIT
	STATAB==11	;GETTAB TABLE FOR STATES WORD
	STAIND==17	;INDEX IN TABLE FOR STATES WORD
	OPQPTB==16	;GETTAB TABLE FOR PPN FOR COMMANDS
	OPQPIN==4	;INDEX IN TABLE FOR PPN FOR COMMANDS
	OPQSTB==16	;GETTAB TABLE FOR STR FOR COMMANDS
	OPQSIN==15	;INDEX IN TABLE FOR STR FOR COMMANDS
	.GTNSW==12	;NON-SWAPPING TABLE
	.GTLVD==16
	%LDFFA==2	;FAILSA PPN (1,2)
	%NSHJB==20	;HIGHEST CURRENTLY ASSIGNED JOB NUMBER

STAOMO==100	;0--ALL MOUNTS MUST GO TO OPR
			;1--UMOUNT MAY MOUNT IF POSSIBLE
STAOPR==400		;0--OPERATOR PRESENT
			;1--NO OPERATOR
STAVER==POINT 3,0,9	;VERSION BYTE
VER503==2		;...VALUE FOR 5.03 MONITORS

IFN FTFACT, <
  .GTLOC==26		;GETTAB TABLE # FOR REMOTE STATION
 SERIAL==20,,CNFTBL	;CPU0 SERIAL # GETTAB ITEM & TABLE #
>;	END OF	IFN FTFACT
 CNOPR==13,,CNFTBL	;'OPR' TTY GETTAB ITEM & TABLE #
IFN RIDSW, <
%CNVER==34,,CNFTBL	;GETTAB PARMS FOR MONITOR VERSION #
>;	END OF	IFN RIDSW

	OPDEF	HIBER [CALLI 72]
HIBNOJ==4	;(LH) ONLY PRIV.JOBS CAN WAKE
HIBTTL==20	;(LH) WAKE ON TTY LINE
HIBSWP==400000	;(LH) SWAP IMMEDIATELY

	OPDEF	WAKE	[CALLI 73]


;FLAGS

L.TYO==1		;CHARACTERS IN TTY OUTPUT BUFFER NOT YET OUTPUT
L.ARGD==2		;DIALOGUE FOR ARGS
L.REGO==4		;REENTER TYPED
L.BRAK==10		;BRACKED ([) DETECTED
L.CMA==20		;COMMA DETECTED
L.DOT==40		;PERIOD DETECTED
L.WLD==100		;WILD * DETECTED
L.VID==200		;VID SWITCH
L.FRE2==400		;USED BY UFDSET AND UFDCLR
L.PEND==400
L.BRK==1000		;BREAK CHAR DETECTED
L.SPC==2000		;SPACE DETECTED
L.PWA==4000		;SET IF PAUSE BEFORE WAITING REQUESTED
L.SIN==10000		;SET IF FILE STRUCTURE REQUESTED SINGLE
L.REM==L.SIN		;SET IF USER REQUESTED REMOVE (DISMOUNT)
L.WRTL==20000		;SET IF USER REQUESTED WRITE-LOCK
L.FRE1==40000		;USED BY UFDSET AND UFDCLR
L.DIS==40000		;SET IF DISMOUNT INSTEAD OF ADDSTR
L.RID==100000		;SET IF /REELID SPECIFIED
L.EOL==200000		;SET IF END OF LINE SEEN
L.WEN==400000	;/WENABLE

R.NJAC==400000	;SET IF JACCT BIT NOT ON (NOT ENTERED BY COMMAND)
R.ASCO==100000	;DEV IS ASSIGNED BY CONSOLE
R.Z==200000	;USED ON FILE Z
R.VIDT==10000

R.PAS==400	;ON=MOUNT STR IN PASSIVE S/L
		;OFF=MOUNT STR IN ACTIVE S/L

R.NOC==200	;ON=SET NOCREATE FOR F/S
		;OFF=SET CREATE FOR F/S

R.ARGD==L.ARGD		;SAVED VALUE OF 'L.ARGD' FOR PROMPT TESTING

R.SHOV==100		;ON = SHOVE REQUEST TO OPR IF SCHED = 400
			;OFF = HONOR SCHED 400

R.NOWA==10		;DETECTED /NOWAIT

R.WAIT==20		;DETECTED /WAIT

R.CLR==R.PAS!R.NOC!R.SHOV!R.NOWA!R.WAIT
;TTCALL FUNCTIONS

CLRINB==11		;CLEAR INPUT BUFFER
SKPINL==14		;SKIP IF A LINE WAS TYPED


;LOOKUP/ENTER/RENAME ERROR CODES

NUFERR==1		;NO UFD
FBMERR==3		;FILE BEING MODIFIED
NRMERR==14		;NO ROOM

UFDQEE==1		;QUOTA EXCEEDED

	OPDEF	PJRST [JRST]
	OPDEF	PJUMPE [JUMPE]
	OPDEF	PJSP [JSP]

PHONLY==200000	;BIT TO FORCE UUOS TO CONSIDER ONLY PHYS. NAMES
PHOPEN==1B0	;BIT TO FORCE OPEN TO USE PHYSICAL-ONLY
;DEVCHR BITS

DC.FS==200000	;(LH)FILE STRUCT.
DC.DTA==100	;(LH)DECTAPE
DC.MTA==20	;(LH)MAGTAPE
DC.AVA==40	;(LH)AVAILABLE
DC.ASC==400000	;(RH)ASSIGN.BY CONSOL
DC.ASP==200000	;(RH)ASSIGN.BY PROG.
IFN VIDSW, <
DC.OUT==1	;(LH) DEVICE CAN DO OUTPUT
>;	END OF	IFN VIDSW
DC.DIS==2000	;(LH) DEVICE IS A DISPLAY
DC.TTY==10	;(LH) DEVICE IS A TTY

	OPDEF	DSKCHR [CALLI 45]
CHRUFB==1	;UFBTAL WORD
CHRNAM==4	;ARGUMENT FOR STR NAME
CHRSMT==7	;STR MOUNT COUNT
CHRSAJ==13	;ARGUMENT FOR SINGLE ACCESS JOB NUMBER
CHRLEN==14	;NUMBER OF ARGS
.UPHWP==100000	;HARDWARE WRITE PROT.
.UPSWP==40000		;SOFTWARE WRITE PROT.
.UPNNA==200		;LOCKED BY OPER.
;DEVTYPE UUO PARAMETERS

	OPDEF	DEVTYP	[CALLI 53]

.TYAVL==40	;(LH)AVAILABLE
.TYJOB==POINT 9,0,26	;JOB #
.TYTYP==POINT 6,0,35	;DEVICE TYPE
  .TYDSK==0	;DISK
IFN SPONUL, <
 .TYSPL==(1B13)	;SPOOLED DEVICE 
>;	END OF	IFN SPONUL
.TYRAS==1B29	;RESTRICTED DEVICE


	OPDEF	JOBSTR [CALLI 47]	;RETURNS USER'S NEXT FILE STRUCTURE

	J.NOCR==200000
	J.NOWR==400000

	OPDEF	STRUUO [CALLI 50]

SRCFST==0
SRCDSL==1		;STRUUO FCN TO SET NEW SEARCH LIST
RDFFST==3
ULKSTR==6
UCLSTR==7

S.SWL==400000		;WRITE-LOCK - SCRFST (.FSSRC)
S.NOC==200000		;NO-CREATE  -   "        "
S.SIN==200000		;SINGLE-ACCESS - RDFFST (.FSDRF)

	OPDEF	SYSPHY [CALLI 51]

	OPDEF	DEVNAM [CALLI 64]
	OPDEF	DEVLNM [CALLI 107]
	OPDEF	GOBSTR [CALLI 66]

	GOBJOB==0		;INDEX FOR JOB NUMBER
	GOBPPN==1		;INDEX FOR PPN
	GOBNAM==2		;INDEX FOR STR NAME IN ARG LIST
	DEFINE	ERRMES (TEX) <
	XLIST
	MOVEI	M,[ASCIZ \TEX\]
	JRST	ERRMSB
	LIST>


	DEFINE	TEXT (TEX)<
	XLIST
	MOVEI	M,[ASCIZ\TEX\]
	LIST>

	DEFINE	TYPE (TEX)<
	XLIST
	MOVEI	M,[ASCIZ\TEX\]
	PUSHJ	P,MSGTTY
	LIST>

	DEFINE	PTYPE (TEX)<
	XLIST
	MOVEI	M,[ASCIZ\TEX
\]
	PJRST	MSGTTY
	LIST>

	DEFINE	XTYPE (TEX)<
	XLIST
	MOVEI	M,[ASCIZ\TEX\]
	JRST	MSGRET
	LIST>

	DEFINE	UFDSEM(TEXT)<
	XLIST
	MOVEI	N1,[ASCIZ\TEXT\]
	JRST	UFDSMP
	LIST>

;-------CHANGE SOME DEFINITIONS IF DEBUGGING

IFN DBUGSW,<

CMDSTX==SIXBIT/DSKB/	;USE SEPERATE 3,3 AREA	
CMDPPX==30,,2614					
STLSTX==SIXBIT/SYS/	;ALLOW SPECIAL STRLST.SYS
STLPPX==0
SYSFIL==SIXBIT/XXXFIL/	;USE SEPERATE PROGRAM NAMES
SYSMOU==SIXBIT/XXXMNT/
SYSOMO==SIXBIT/XXXOMO/

> ;IFN DBUGSW
;VALUES FOR ARGUMENT TYPE RETURN FROM DSKCHR UUO

A.FS==2		;FILE STRUCTURE NAME (DSKA)
A.PUN==6	;PHYSICAL UNIT (DPA0)

;BITS SET IN AC RETURN FROM DSKCHR UUO

D.RDHM==400000		;MONITOR MUST REREAD HOME BLOCK BEFORE NEXT I/O
D.OFFL==200000		;DRIVE IS OFF-LINE
D.HWL==100000		;DRIVE IS HARDWARE WRITE PROTECTED
D.SWL==40000		;FILE STRUCTURE IS SOFTWARE WRITE PROTECTED
D.SIN==20000		;SINGLE ACCESS ONLY FOR THIS FILE STRUCTURE
D.MC==10000		;MOUNT COUNT = 0
D.PRV==4000		;FILE STRUCTURE IS A PRIVATE FILE STRUCTURE
D.INFS==2000		;IN A FILE STRUCTURE (IF 0)
D.DNBM==1000		;DOWN OR BEING MOUNTED
D.LOK==200		;NO FURTHER LOOKUPS, ENTERS, OR INITS ALLOWED


;BYTE POINTERS

;FOR VALUES RETURNED FROM DSKCHR UUO

IFN MNTSW,<
D.KONT:	POINT	6,A,26	;CONTROLLER TYPE
D.KONN:	POINT	3,A,29	;KONTROLLER NUMBER
D.UNIT:	POINT	3,A,32	;UNIT TYPE (DEPENDS ON CONTROLLER TYPE)
D.UNIN:	POINT	3,A,35	;UNIT NUMBER
D.ARGT:	POINT	3,A,17	;ARGUMENT TYPE
D.UST:	POINT	2,A,8	;UNIT STATUS
   B.UST==3000	;THE BITS

CLSBYT:	POINT	3,PKCLAS(C),35	;CLASS OF THIS UNIT
UTPBYT:	POINT	3,PKCLAS(C),32	;TYPE OF THIS UNIT (RP01 OR RP02)
KTPBYT:	POINT	6,PKCLAS(C),26	;TYPE OF THIS CONTROLLER (FH, DP)

>	;END CONDITIONAL ON MNTSW
STRFOR==0		;FORMAT VERSION NUMBER FOR CURRENT FORMAT OF STRLST.SYS
QUOFOR==0		;FORMAT VERSION NUMBER FOR QUOTA.SYS

;ARGUMENTS FOR EXTENDED LOOKUP, ENTER, RENAME

EXLLEN==26	;LENGTH OF ARGUMENT LIST
EXLPPN==1	;DIRECTORY NAME
EXLNAM==2	;FILE NAME
EXLEXT==3	;EXT
EXLPRV==4	;PRIV BITS, ET AL.
EXLSIZ==5	;WORDS WRITTEN IN UFD
EXLALC==11	;BLOCKS ALLOCATED FOR FILE
EXLDEV==16	;DEVICE ON WHICH FILE LOOKED UP IS
EXLSTS==17	;STATUS BITS
.RBSTS==17
  .RBNDL==1B19
  RIPLOG==400000	;LH BIT IS LOGGED IN BIT
  RIPDIR==400000	;RH BIT IS DIRECTORY BIT
EXLQTF==22	;FIRST COME, FIRST SERVED QUOTA
EXLQTO==23	;LOGGED-OUT QUOTA
EXLQTR==24	;RESERVED QUOTA
EXLUSD==25	;BLOCKS USED

HOMHID==1	;WORD IN HOME BLOCK CONTAINING UNIT ID
HOMLOG==7	;WORD IN HOME BLOCK CONTAINING SIXBIT LOG UNIT IN STR
MAXKON==8	;MAXIMUM NUMBER OF CONTROLLERS
SUBTTL	INITIALIZATION
;START OF PROGRAM

UMOUNT:	JFCL			;IN CASE OF CCL
	TDZA	F,F		;NO FLAGS ON
REGO:	MOVSI	F,L.REGO		;ONLY ONE FLAG ON. REENTER HERE
	MOVE	P,PDP
	RESET			;CLEAR OUT EVERYTHING
IFN PURESW, <
	SETZM	LOWBEG		;CLEAR 1ST WORD OF IMPURE STORAGE
	MOVE	A,[LOWBEG,,LOWBEG+1] ;GET BLT POINTER IN AN AC
	BLT	A,LOWEND-1	;CLEAR *ALL* OF IMPURE STORAGE
UU(LOWBEG,0)			;DEFINE 1ST WORD OF IMPURE STORAGE
>;	END OF	IFN PURESW
	MOVSI	A,(PHOPEN)	;OPEN TTY PHYSICAL ONLY
	GETLIN	B,		;WHO AM I?
	MOVE	C,[WH.TTY,,RH.TTY]	;BUFFERS
	TLNE	B,-1		;I COULDN'T BE DETACHED??!!
	OPEN	TTY,A
	 JRST	GOEXIT
	MOVEI	A,B.TTY
	MOVEM	A,.JBFF
	INBUF	TTY,1
	OUTBUF	TTY,1
	MOVE	A,[XWD 4,INTLOC]	;SET UP INTERCEPT BLOCK
	MOVEM	A,INTBLK
	MOVEI	A,1B34			;AND ENABLE FOR ^C-INTERCEPT
	IORM	A,INTBLK+1
	SETZM	INTBLK+2
	MOVEI	A,INTBLK		;ARM .JBINT
	MOVEM	A,.JBINT
	MOVE	A,[XWD STAIND,STATAB]
	GETTAB	A,
	  SETZ	A,
	MOVEM	A,STATES	;SAVE STATES WORD
	LDB	B,LVDBTS	;GET MONITOR VERSION
	MOVEM	B,MONVER
	JUMPE	B,NEVERR	;LEVEL-C NOT SUPPORTED
	MOVE	B,SYSPPD	;LEVEL D DEFAULT SYS PPN
	MOVE	A,[XWD 1,16]	;SET UP FOR GETTAB OF SYS PPN
	GETTAB	A,		;RETRIEVE PPN FOR SYS
	  MOVE	A,B		;DEFAULT
	MOVEM	A,SYSPPN

IFE DBUGSW,<
	MOVE	A,[XWD OPQPIN,OPQPTB]
STR11:	GETTAB	A,		;GETTAB TO GET PPN FOR COMMANDS TO OMOUNT
	  MOVE	A,[CMDPPX]
	MOVEM	A,CMDPPN
	MOVE	A,[XWD OPQSIN,OPQSTB]
STR12:	GETTAB	A,		;GETTAB TO GET STR FOR COMMANDS
	  MOVE	A,[CMDSTX]
	MOVEM	A,CMDSTR
	MOVEM	A,SRCBUF
	MOVE	B,[XWD CHRNAM+1,SRCBUF]
	DSKCHR	B,PHONLY	;GET DSKCHR
	  JRST	NOLOGP		;NOT EVEN A DSK?
	CAME	A,SRCBUF+CHRNAM	;SKIP IF REAL STR NAME IS SAME AS GETTAB
	JRST	NOLOGP		;NO, MUST BE A LOGICAL NAME
	TLNE	B,.UPHWP!.UPSWP!.UPNNA ;PROTECTED OR LOCKED?
	JRST	NOWRTP		;YES
> ;IFE DBUGSW

IFN DBUGSW,<
	MOVE	A,[CMDPPX]
	MOVEM	A,CMDPPN
	MOVE	A,[CMDSTX]
	MOVEM	A,CMDSTR
> ;IFN DBUGSW
START1:	PJOB	A,		;GET	STUFF FOR ID
	MOVEM	A,JOBNO		;JOB NUMBER
	WAKE	A,		;ISSUE A WAKE FOR SELF
	  JFCL			;(IGNORE ERRORS)
	HRLI	A,HIBNOJ!HIBTTL	;GET HIBER MASK BITS
IFN DBUGSW, <
	TLZ	A,HIBNOJ	;CLEAR JOB-MASK IF DEBUGGING
>;	END OF	IFN DBUGSW
	HIBER	A,		;SET MASK BITS NOW
	  JFCL			;(IGNORE ERRORS)
	SETZM	CHKFLG		;SET 0 TO SHOW NOT /CHECK
	SETZM	NOTLOG		;SET 0 TO SHOW LOGGED IN
	MOVN	A,JOBNO		;GET -JOB # FOR THE UUO
	JOBSTS	A,		;FIND OUT STATUS OF MYSELF
	  SETO	A,		;  NOT IMPL., SET AC -1
	TLNN	A,(1B1)		;TEST FOR LOGGED IN
	SETOM	NOTLOG		;  NO, SET -1 TO SHOW NOT LOGGED IN
	GETLIN	A,
	MOVEM	A,TTYLIN		;TTY NAME

	MOVSI	B,%LDFFA	;FAILSA PPN
	HRRI	B,.GTLVD	;LEVEL D TABLE FOR PPNS
	GETTAB	B,		;GET OPR'S PPN(1,2)
	 MOVE	B,FSFPPN	;USE [1,2] FOR DEFAULT
	MOVEM	B,FS1PPN	;SAFE FOR LATER
	HRROI	A,PRJPRG	;GET MY PPN
	GETTAB	A,
	 JFCL
	HLRZ	B,A		;FORM IOR'D PROJ # WITH PROG #
	IORI	B,(A)
	HRRZM	B,IORPPN		;AND SAVE IT FOR LATER ID USE
	MOVEM	A,USRPPN		;JOB'S PROJECT,PROGRAMMER NUMBER
IFN FTFACT, <
	MOVEM	A,F.PPN		;STORE FOR ACCOUNTING. ALSO
>;	END OF	IFN FTFACT
;CK FOR JACCT BIT (ONLY VALID FOR 5.03 SINCE IT WAS MOVED IN 5.02)
	MOVE	B,MONVER
	CAIGE	B,VER503
	JRST	STAR12
	HRLZ	B,JOBNO	;GET JBTSTS WITH GETTAB
	GETTAB	B,
	 JRST	STAR12
	CAME	A,FS1PPN	;AM I [1,2]?
	TLNE	B,JACCT		; OR, IS JACCT ON?
	 JRST	STAR12		;YES, DON'T SET FLAG
	TRO	F,R.NJAC	;NOS-SET R.NJAC

STAR12:	SETOM	PTHPRM		;SET -1 TO READ DEFAULT PATH
	MOVE	A,[PTHLEN,,PTHPRM] ;POINT AT PATH. UUO PARM LIST
	PATH.	A,		;READ USER'S DEFAULT DIR PATH
	  SKIPA	A,USRPPN	;  FAILED, ASSUME HIS PPN AS DEFAULT
	MOVE	A,PTHPRM+2	;GET THE PPN FOR HIS DEFAULT PATH
	MOVEM	A,DEFPPN	;STORE AS DEFAULT PPN (INITIAL)
	MOVEM	A,DIRPPN	;STORE AS DIRECTORY PPN
	MOVEI	IO,R.TTY
	MOVE	A,[XWD PHONLY,10]
	MOVE	B,CMDSTR	;STR FOR COMMAND QUEUE
	MOVEI	C,RH.CMU	;THIS CHANNEL WILL BE USED TO READ THE
	OPEN	CMU,A		; DIRECTORY OF THE COMMAND AREA
	  JSP	N,CMUERR
	MOVEI	A,B.CMU
	MOVEM	A,.JBFF
	INBUF	CMU,1
	PUSHJ	P,REWCMU	;LOOKUP	QUEUE UFD
	 JRST	NOCMU		; IF NOT, OPR IS NOT RUNNING OPFILE

;SET STANDARD AND DEFAULT F.S.
	MOVSI	A,'DSK'		;USE DSK FOR DEFAULT
	MOVEM	A,DEFDEV
	SETZM	STDDEV		;START STANDARD DEVICE AT 0
	SETO	A,
NXTST1:	MOVE	D,[XWD 3,A]	;RE-INIT AC D
NXTST:	JOBSTR	D,		;GET NEXT STR IN JOB'S SEARCH LIST
	  JRST	START2		;GIVE UP
	JUMPE	A,START2	;QUIT IF REACH FENCE
	AOJE	A,START2	;OR END OF SEARCH LIST
	SUBI	A,1		;KEEP LAST STR GIVEN
	TLNE	C,J.NOCR!J.NOWR	;OK IF NO CREATE OR NO WRITE NOT ON
	JRST	NXTST		;TRY FOR ANOTHER IF IT IS
	MOVSI	B,(PHOPEN)	;OPEN PHYSICAL ONLY
	SETZ	D,		;SET UP TO OPEN THIS DEVICE
	MOVE	C,A		;GET DEVICE NAME
	OPEN	USR,B
	 JRST	NXTST1		;??TRY NEXT DEVICE
	MOVE	B,USRPPN	;SET UP TO LOOKUP UFD
	MOVSI	C,(SIXBIT/UFD/)
	SETZ	D,
	MOVE	E,MFDPPN	;GET 1,,1
	LOOKUP	USR,B		;DO SO
	 JRST	NXTST1		;NO UFD, CAN'T USE FOR STDDEV
	MOVEM	A,STDDEV	;SAVE THIS DEVICE. ***NOTE: IF NONE
				;FOUND TO BE ELIGIBLE, STDDEV=0
	RELEASE	USR,

START2:	MOVEI	CH,33		;
	TTCALL	10,0		;BACK UP TO COMMAND
START6:	MOVE	E,[XWD -TYPL,TYPCOM]
	JRST	UDSWIT		;DISPATCH TO PROPER ROUTINE
;SUBROT. TO LOOKUP (REWIND) QUEUE UFD
REWCMU:	MOVE	A,CMDPPN	;QUEUE AREA
	MOVSI	B,(SIXBIT /UFD/)
	MOVEI	C,0
	MOVE	D,MFDPPN
	LOOKUP	CMU,A		;SEE IF UFD FOR COMMAND AREA EXISTS
	  POPJ	P,
	JRST	CPOPJ1

;DISPATCH TABLE FOR COMMANDS TYPED IN

IFE MNTSW,<EXP 	START4
	EXP 	START4>
IFN MNTSW,<EXP	START7
	EXP	START7>
TYPCOM:	XWD	SIXBIT .   FIL.,START3
	XWD	SIXBIT .   MOU.,MOUNT
	XWD	SIXBIT .   DIS.,DISMNT
TYPL==.-TYPCOM

IFN MNTSW,<
START7:	PUSHJ	P,CLRLIN
	MOVEI	M,FMDM		;NO--TELL USER ONLY 'FILE' ALLOWED
	PUSHJ	P,MSGTTY	;ASK FOR PROPER COMMAND  
	TLZ	F,L.ARGD	;CLEAR DIALOG MODE BEFORE STARTING NEW LINE
	JRST	START6>


NOLOGP:	MOVEI	B,NOLOGM	;TELL USER QUEUE F.S. CANT BE LOG.NAME
	JRST	NOQFS
NOWRTP:	MOVEI	B,NOWRTM	;TELL USER I CANT ACCESS QUEUE F.S.
NOQFS:	MOVEI	M,[ASCIZ/?Can't access Queue--/]
	PUSHJ	P,MSGTTY
	MOVE	M,CMDSTR
	PUSHJ	P,SIXMSG
	MOVE	M,B
	JRST	ERREXI
SUBTTL	FILE COMMAND
START3:
IFE FILESW,<
	MOVEI	M,[ASCIZ /? Unable to do FILE commands/]
	JRST	ERRRET
>;	END OF IFE FILESW

IFN FILESW,<
	;USER HALF OF DTA FILE-RECALL SYSTEM STARTS HERE

	SETZM	FILBLK		;CLEAR OUT FILE BLOCK
	MOVE	A,[XWD FILBLK,FILBLK+1]
	BLT	A,FILBKE
	SETZM	DVVNAM		;CLEAR DVC NAME IN CASE OF 'NEVERR' CALLS
	TLNE	F,L.BRK
	JRST	START4		;IF BREAK CHAR NEED DIALOGUE
	PUSHJ	P,GETARG	;GET CLASS OF COMMAND
	JUMPN	A,START5	;JUMP IF IT'S THERE
	CAIN	CH,"?"		;TEST FOR ALTERNATE /HELP RQST
	JRST	HELPQ2		;  YES, JUMP
START4:	TLO	F,L.ARGD	;NO. WILL NEED DIALOGUE
	PUSHJ	P,CLRLIN	;IGNORE THE REST OF THIS LINE
	MOVEI	M,CLSMSG
	TLNE	F,L.ARGD	;NEED TO ASK FOR CLASS OF CMD?
	PUSHJ	P,MSGTTY	;YES. DO
	PUSHJ	P,GETARG	;GET ANSWER, CHECK FOR END OF CMD
	JUMPE	A,HELPQ		;NO COMMAND CLASS?
START5:	ROT	A,6
	ANDI	A,77		;JUST FIRST CHAR
	ADDI	A,40		;BACK TO ASCII
	MOVEM	A,CMDCHR	;SAVE FOR LATER
DISPAT:	CAIN	A,"C"
	JRST	CCOM		;C FOR CHECK
	CAIN	A,"H"		;TEST FOR "H"
	JRST	HELPQ2		;  YES, GO GIVE HELP MESSAGE
	SKIPE	NOTLOG		;TEST FOR LOGGED IN
	JRST	LOGERR		;  NO, THAT'S ALL THERE IS
	CAIN	A,"R"
	 JRST	RCOM		;R FOR RECALL
	CAIN	A,"F"
	 JRST	FCOM		;F FOR FILE
	CAIN	A,"Z"
	 JRST	ZCOM		;Z FOR ZERO DIRECTORY AND FILE
	CAIN	A,"D"
	 JRST	DCOM		;D FOR DELETING DECTAPE FILES
	CAIN	A,"L"
	 JRST	LCOM		;L FOR DIRECTORY LISTING
	CAIN	A,"W"
	 JRST	WCOM
	JRST	START4		;NONE OF THE ABOVE -TRYAGAIN

HELPQ:	CAIE	CH,"?"		;? - HE'S ASKING FOR THE STRAIGHT SCOOP
	JRST	START4
HELPQ2:	MOVE	A,[SIXBIT /FILE/] ;GET NAME OF HELP FILE
	JRST	GOHELP		;GO TYPE IT & EXIT
;LIST DECTAPE DIRECTORY

LCOM:	PUSHJ	P,GETTAP		;PUTS TAPE NUMBER IN TAPEID
	PUSHJ	P,COMSET	;SET DEVICE FOR DIRECTORY
	JRST	FILCOM		; AND OUTPUT COMMAND FILE

;DELETE FILES FROM DECTAPE

DCOM:
	PUSHJ	P,GETTAP	;READ DECTAPE ID FIELD
	SETZM	DEFPPN		;CLEAR DEFAULT PPN FOR 'FILE D'
	SETZM	DIRPPN		;  DITTO
	JRST	RCOM0		;JUMP TO COMMON ROUTINE

;RECALL FILES FROM TAPE

RCOM:	PUSHJ	P,GETTAP		;GET TAPE NUMBER FROM USER
	MOVE	A,USRPPN	;CHANGE DEFAULTS BACK TO [SELF]
	MOVEM	A,DEFPPN	;  DITTO
	MOVEM	A,DIRPPN	;  DITTO
RCOM0:	MOVEI	M,FILMSG
	TLNE	F,L.ARGD
	PUSHJ	P,MSGTTY
	PUSHJ	P,COMSET	;SET DEVICE FOR DIRECTORY AND SET UP D
RCOML:	PUSHJ	P,GETFIL		;GET NEXT FILE NAME FROM USER
	JRST	RCOMEQ		;NOT THERE
	PUSHJ	P,GETDEV	;GET F.S. FILE IS ON
	  JFCL			;   (IF ANY)
	MOVS	A,FILDEV(D)	;GET F/S FOR THIS DEVICE
	MOVE	B,STDDEV	;GET STANDARD F/S FOR THIS USER
	CAIN	A,'DSK'		;TEST FOR USING 'DSK'
	 MOVEM	B,FILDEV(D)	;  YES, REPLACE BY STD F/S
	SKIPN	FILDEV(D)	;IF NO DEVICE AFTER ALL THIS, CLUNK
	 JRST	ERR110		;  THE REQUEST
	TLNN	F,L.CMA!IFN FTSPTB,<L.SPC> ;TEST FOR COMMA, SPACE, OR TAB
	 JRST	RCOME		;ALL DONE IF NO COMMA FOLLOWING
	AOBJN	D,RCOML
	JRST	RFCOMX

RCOMEQ:	TRNE	D,-2		;TEST FOR ANY FILES SPECIFIED
	JRST	RCOME		;  YES, GO QUEUE TO RQST
	SETZM	RH.TTY+2	;THROW AWAY REST OF INPUT
	TLO	F,L.ARGD	;ENTER DIALOG MODE
	JRST	RCOM0		; & GO GET FILES NOW
ZCOM:	TRO	F,R.Z	;Z TELLS OPFILE WHAT TO DO
			;ZERO DIRECTOR BEFORE FILE COMMAND
	TLNE	F,L.ARGD	;TEST FOR DIALOG MODE NOW
	TRO	F,R.ARGD	;  YES, REMEMBER THAT FOR LATER

;PUT FILES ON TAPE

FCOM:	PUSHJ	P,GETTAP
FCOM0:	PUSHJ	P,COMSET
	MOVEI	M,FILMSG
	TLNN	F,L.ARGD
	JRST	FCOML
	TRZN	F,R.ARGD	;TEST FOR PREVIOUS DIALOG MODE
	TRNN	F,R.Z		;TEST FOR 'FILE Z'
	SKIPA			;  SKIP IF PREVIOUS DIALOG OR NOT FILE Z
	JRST	FCOME		;  OTHERWISE, DON'T ASK FOR FILE-Z FILES
	PUSHJ	P,MSGTTY
FCOML:	PUSHJ	P,GETFIL		;GET NEXT FILE
	JRST	FCOMEQ		;ALLDONE
	PUSHJ	P,GETDEV	;GET F.S. FILE IS ON
	  JRST	FCOMNO		;   & COMPLAIN IF NOT ANYWHERE
	TLNN	F,L.CMA!IFN FTSPTB, <L.SPC> ;TEST FOR COMMA, SPACE, OR TAB
	JRST	FCOME		;DONE IF NO COMMA
	AOBJN	D,FCOML
RFCOMX:	MOVEI	M,MNYMSG
	PUSHJ	P,MSGTTY
	SKIPN	M,FILDEV-1(D)	;GET DEVICE & TEST IT
	MOVSI	M,'DSK'		;  NONE, ASSUME 'DSK'
	PUSHJ	P,SIXMSG	;TYPE THE DEVICE NAME
	PUSHJ	P,COLON		; & A COLON FOLLOWING
	MOVE	M,FILBLK-1(D)
	PUSHJ	P,SIXMSG
	PUSHJ	P,DOT
	HLLZ	M,FILBEX-1(D)
	PUSHJ	P,SIXMSG
	SKIPN	FILPPN-1(D)	;TEST USER'S PPN
	JRST	RCOMFX		;  NONE, JUMP AROUND
	PUSHJ	P,LBRKET	;TYPE A "["
	HLRZ	N,FILPPN-1(D)	;GET THE PROJECT #
	PUSHJ	P,OCTPRT	; & TYPE IT
	PUSHJ	P,COMMA		;TYPE A COMMA
	HRRZ	N,FILPPN-1(D)	;GET THE USER #
	PUSHJ	P,OCTPRT	; & TYPE IT
	PUSHJ	P,RBRKET	;TYPE A "]"
RCOMFX:				;HERE IF NO PPN
	PUSHJ	P,CRLF
RCOME:	JRST	FILCOM

	
PROTFL:	SKIPA	M,[PROTMS]	;GET ADDR OF 'PROTECTION FAILURE' MSG

FCOMNO:	MOVEI	M,MISMSG	;GET ADDR OF 'FILE MISSING' MSG
FCOMFL:	MOVE	D,SAVED		;RESTORE SAVED AOBJN POINTER
	PUSHJ	P,MSGTTY
	SKIPN	M,FILDEV(D)	;GET DEVICE & TEST IT
	MOVSI	M,'DSK'		;  NONE, ASSUME 'DSK'
	PUSHJ	P,SIXMSG	;TYPE THE DEVICE NAME
	PUSHJ	P,COLON		; & A COLON FOLLOWING
	MOVE	M,FILBLK(D)
	PUSHJ	P,SIXMSG
	PUSHJ	P,DOT
	HLLZ	M,FILBEX(D)
	PUSHJ	P,SIXMSG
	SKIPN	FILPPN(D)	;TEST USER'S PPN
	JRST	FCOMFX		;  NONE, JUMP AROUND
	PUSHJ	P,LBRKET	;TYPE A "["
	HLRZ	N,FILPPN(D)	;GET THE PROJECT #
	PUSHJ	P,OCTPRT	; & TYPE IT
	PUSHJ	P,COMMA		;TYPE A COMMA
	HRRZ	N,FILPPN(D)	;GET THE USER #
	PUSHJ	P,OCTPRT	; & TYPE IT
	PUSHJ	P,RBRKET	;TYPE A "]"
FCOMFX:				;HERE IF NO PPN
	PUSHJ	P,CRLF
	JRST	MONRET
FCOMEQ:	TRNN	F,R.Z		;TEST FOR FILE Z
	TRNE	D,-2		;TEST FOR FILE SPECIFIED
	JRST	FCOME		;  EITHER, CONTINUE ON
	SETZM	RH.TTY+2	;THROW AWAY REST OF LINE
	TLO	F,L.ARGD	;ENTER DIALOG MODE
	JRST	FCOM0		; & GO GET FILE NAMES
FCOME:
FILCOM:				;HERE WHEN FILE CMD SCANNED
	PUSHJ	P,CKEOL		;CALL TO CHECK FOR END-OF-LINE
	MOVE	M,STATES	;GET SYSTEM STATES WORD
	TRNE	M,STAOPR	;TEST FOR OPR PRESENT
	PUSHJ	P,ERR911		;  NO, TYPE MSG & ABORT REQUEST
	HRLI	NUM,(SIXBIT .F.)	;FILE TYPE COMMAND
	PUSHJ	P,COMBEG		;START IT UP
	PUSHJ	P,CRLF		;END WITH CRLF
	CLOSE	CMD,0		;IN THIS CASE THAT'S ALL
	MOVE	A,NAMFIL	;WAKE SOME OMOUNTS
	PUSHJ	P,WAKE1
	  JFCL			;NO OMOUNTS TO WAKE
	MOVEI	M,RQSMSG	;REQUEST STORED
	PUSHJ	P,MSGTTY

;COUNT NUM.COMMANDS IN QUEUE

	MOVE	A,CMDNAM	;GET THE CMD NAME WE FINALLY USED
	MOVEM	A,MYCMD		; & SAVE IT FOR LATER
	MOVEI	NUM,(SIXBIT/F/)	;INIT CMGET
	MOVE	A,NAMFIL
	PUSHJ	P,CMGET1
	  JRST	CCOM3
	JRST	CCOM2		;GO PROCESS THE 1ST QUEUED RQST

>;	END OF IFN FILESW
;HERE TO WAIT FOR ALL FILE REQUESTS TO GO AWAY

WCOM:	MOVEI	NUM,'F  '
	MOVE	A,NAMFIL
WCOM1:				;HERE ON MOUNT/WAIT, DISMOUNT/WAIT
	PUSHJ	P,CMGET1
	  JRST	WCOM2		;NO PENDING COMMANDS
WCOM1A:				;HERE AFTER MPB-JOB FILE C
	PUSHJ	P,MSG111	;'WAITIN...'
WCOM0:	MOVEI	A,FILSLP	;HIBERNATE
	PUSHJ	P,WAIT0		;WONT RETURN IF ^C
	PUSHJ	P,CMGETI	;ANY MORE FILES?
	PUSHJ	P,CMGET
	  JRST	MONRET		;NO-RETURN TO USER
	JRST	WCOM0

WCOM2:	PUSHJ	P,MSG112	;"NONE PENDING"
	JRST	MONRET
;HERE TO CHECK FOR PENDING REQUESTS
;NUM=SIXBIT CHAR FOR TYPE OF REQUEST TO CHECK FOR

CCOM:	MOVEI	NUM,(SIXBIT .F.) ;TYPE OF REQUEST CHECKING
	MOVE	A,NAMFIL
CCOMSB:			;HERE FROM MOUNT-DISMOUNT/C
	SETZM	MYCMD		;CLEAR CMD NAME TO SHOW GENERAL /CHECK
	MOVE	A,USRPPN	;GET USER'S PPN
	CAME	A,FS1PPN	;TEST FOR [1,2]
	SKIPE	NOTLOG		;TEST FOR LOGGED IN
	SETOM	CHKFLG		;  YES, SET FLAG TO SHOW FULL LISTING
	PUSHJ	P,CMGET1	;INIT CMGET
	  JRST	CCOME
	JRST	CCOM2
CCOM0:	PUSHJ	P,CMGET		;GET NEXT FILE REQUEST
	  JRST	CCOM3		;THATS ALL
CCOM2:				;HERE WITH NEXT QUEUE ENTRY OF CORRECT TYPE
	SKIPE	N,MYCMD		;GET DESIRED FILE NAME & TEST IT
	CAMN	N,CMDNAM	;TEST FOR SAME AS FOUND F.N.
	SKIPA			;  SKIP IF A MATCH
	 JRST	CCOM0		;  ELSE GO GET NEXT FILE
	MOVEI	IO,W.TTY
	MOVE	N,COMCNT
	PUSHJ	P,DECPRT		;PRINT INDEX IN QUEUE
	PUSHJ	P,DOT
	PUSHJ	P,SPACE
CCYESL:	PUSHJ	P,R.CMD		;NOW READ THE COMMAND
	PUSHJ	P,W.TTY		; AND TYPE IT
	CAIE	CH,12		;AND LOOP FOR ONE LINE
	JRST	CCYESL
	CLOSE	CMD,0		;FINISHED
	JRST	CCOM0

	
CCOME:				;HERE IF NO RQSTS FOUND
	SKIPE	COMCNT		;TEST FOR EMPTY QUEUE
				;  YES, SKIP THE 'NONE PENDING' MSG
	PUSHJ	P,MSG112		;TELL USER NONE PENDING
CCOM3:				;HERE FROM FCOME
	MOVEI	IO,W.TTY
	TTCALL	13,0		;CLEAR ^O IF ON
	  JFCL			;(JUST IN CASE)
	SKIPE	N,COMCNT	;GET # OF QUEUE ENTRIES & TEST
	PUSHJ	P,DECPRT	;  .NE.0, TYPE DECIMAL NUMBER
	MOVEI	M,[ASCIZ /No/]	;ASSUME EMPTY QUEUE
	SKIPN	COMCNT		;TEST FOR NUMBER TYPED
	PUSHJ	P,MSGTTY	;  NO,TYPE 'NO'
	MOVEI	M,[ASCIZ / Command/] ;ASSUME THE SINGULAR
	PUSHJ	P,MSGTTY	; & TYPE IT
	MOVEI	CH,"s"		;GET THE PLURAL
	SOSE	COMCNT		;TEST FOR .NE. 1 QUEUE ENTRY
	PUSHJ	P,(IO)		;  YES, TYPE THE PLURAL
	AOS	COMCNT		;RESTORE COMMAND COUNT FOR LATER
	MOVEI	M,[ASCIZ / in Queue/] ;POINT AT REST OF MSG
IFE MPBWAI, <
	JRST	MSGRET		;ALL DONE
>;	END IFE MBPWAI
IFN MPBWAI, <
	HRROI	A,40		;GET .GTLIM GETTAB TABLE INDEX FOR SELF
	GETTAB	A,		;GET MY .GTLIM ENTRY
	  SETZ	A,		;  FAILED, SET TO ZERO
	TLNN	A,(1B10)	;TEST FOR MPB JOB
	JRST	MSGRET		;  NO, DONE NOW
	SKIPE	MYCMD		;TEST FOR FILE C FOLLOWING FILE <ANYTHING>
	SKIPN	COMCNT		;TEST FOR COMMANDS IN THE QUEUE
				; EXIT IF USER'S FILE C OR EMPTY QUEUE
	JRST	MSGRET
	PUSHJ	P,MSGTTY	;OUTPUT THE MESSAGE
	PUSHJ	P,CRLF		; & END IT
	SETZM	CHKFLG		;CLEAR THE SPECIAL-CHECK FLAG
	JRST	WCOM1A		;GO DO FILE W AFTER FILE C AFTER FILE ???
>;	END IFN MPBWAI
;SUBROUTINE TO SEE IF THERES AN OMOUNT AND INIT CMGET
;CALL	A=OMOUNT NAME TO WAKE
;	NUM=REQUEST TYPE (F,M,OR D)
;RET+1	IF NO PENDING FILES
;RET+2	WITH 1ST PENDING FILE OPENED ON CMD (SEE CMGETI)

CMGET1:	PUSHJ	P,WAKE0		;SEE IF THERES AN OMOUNT
	  PUSHJ	P,MSG113	;NO-TELL USER
	PUSHJ	P,CMGETI	;INIT CMGET
	PJRST	CMGET		;  AND LOOK FOR 1ST PENDING FILE


;SUBROUTINE TO INITILIZE CMGET
CMGETI:	PUSHJ	P,REWCMU	;REWIND UFD
	  JSP	N,NEVERR
	SETZM	COMCNT
	MOVSI	A,(PHOPEN)	;SET PHYSICAL-ONLY OPEN
	MOVE	B,CMDSTR
	MOVEI	C,RH.CMD
	OPEN	CMD,A
	  JSP	N,CMDERR
	MOVEI	A,B.CMD
	MOVEM	A,.JBFF
	INBUF	CMD,1
	POPJ	P,
;SUBROUTINE TO LOOK FOR NEXT FILE REQ. FOR THIS USER IN QUEUE
;INIT	CALL CMGETI
;CALL	QUEUE UFD OPEN ON CMU
;	NUM=TYPE OF REQUEST (LETTER=F,M,D)
;RET+1	NO MORE
;RET+2	NEXT ONE OPENED ON CMD
CMGET:
CCOML:	PUSHJ	P,R.CMU		;READ NAME OF NEXT FILE IN COMMAND AREA
	  POPJ	P,		;NO MORE FILES
	MOVE	A,WD
	MOVEM	A,CMDNAM		;SAVE IT
	PUSHJ	P,R.CMU		;NOW EXTENSION
	  POPJ	P,		;?
	HLLZ	B,WD
	MOVEI	C,0
	MOVE	D,CMDPPN
	HLRZ	N,A
	HLRZ	N1,B
	TRZ	N,7777		;SAVE ONLY HIGH ORD CHAR ON RIGHT
	CAIE	N1,(SIXBIT /CMD/)
	JRST	CCOML
	CAME	N,NUM		;SKIP IF OUR TYPE OF REQUEST
	JRST	CCOML		;NO, FORGET IT
	AOS	COMCNT		;COUNT ACTUAL ENTRIES IN QUEUE
	HRRZ	N1,A		;GET RIGHT 1/2 OF NAME
	SKIPE	CHKFLG		;TEST FOR SPECIAL /CHECK
	MOVE	N1,IORPPN	;  YES, FUDGE 'OR'D PPN FOR NEXT TEST
	CAME	N1,IORPPN		;COULD BE FOR THIS PPN?
	JRST	CCOML		;NO - TRY NEXT
	LOOKUP	CMD,A
	 JRST	CCOML		;SOMETHING WRONG WITH THIS FILE
	MOVEI	IO,R.CMD		;OK, LET'S HAVE A LOOK AT THAT FILE
	SKIPE	CHKFLG		;TEST FOR SPECIAL /CHECK
	JRST	CPOPJ1		;  YES, RETURN EVERYTHING
IFE LOGSW, <
	MOVEI	N,3		;LOOK FOR 4TH FIELD (3 SPACES)
CCOMF:	PUSHJ	P,R.CMD		;READ CMD FILE
	CAIE	CH," "		;IS IT A SPACE
	JRST	CCOMF		;NO - TRY AGAIN
	SOJG	N,CCOMF		;COUNT DOWN SPACES
>;	END OF	IFE LOGSW
IFN LOGSW, <
	MOVEI	N,1		;SET TO SKIP ONE FIELD
	PUSHJ	P,SKPFLD	;CALL TO SKIP IT
	  JRST	CCOML		;  EOF, GET NEXT CMD FILE
	MOVEI	N,3		;SET TO SKIP THREE CHARACTERS ('JOB')
CCOMF:	PUSHJ	P,R.CMD		;READ A CHARACTER
	CAIG	CH,14		;TEST FOR END OF LINE
	JRST	CCOML		;  YES, DONE
	SOJG	N,CCOMF		;COUNT DOWN & REPEAT
	PUSHJ	P,SDECIN	;READ THE JOB NUMBER
	CAME	N,JOBNO		;TEST FOR SAME JOB #
	CAIN	NUM,(SIXBIT .F.);TEST FOR 'FILE' CMD
	SKIPA	N,[1]		; IF SAME JOB -OR- FILE CMD, PUT 1 IN 'N' & SKIP
	JRST	CCOML		; JUMP IF DIFFERENT JOB ON MOUNT/DISMOUNT
	PUSHJ	P,SKPFLD	;SKIP TO PPN FIELD
	  JRST	CCOML		;  EOF, GO GET NEXT CMD FILE
>;	END OF	IFN LOGSW
	PUSHJ	P,HPACK		;GET PROJ # AND PACK IT
	HRL	WD,N		;SAVE IT
	PUSHJ	P,HPACK		;GET PROG # AND PACK IT
	HRR	WD,N		;SAVE IT
	CAME	WD,USRPPN		;IS IT FOR THIS USER PPN?
	JRST	CCOML		;NO
CCMYES:	MOVE	A,CMDNAM		;YES!
	MOVSI	B,(SIXBIT /CMD/)
	MOVEI	C,0
	MOVE	D,CMDPPN
	LOOKUP	CMD,A		;GET IT AGAIN
	 JRST	CCOML		;PROBABLY JUST HANDLED
	JRST	CPOPJ1

IFN LOGSW, <
SKPFLD:	PUSHJ	P,R.CMD		;READ NEXT CHAR OF CMD FILE
	CAIG	CH,14		;TEST FOR END OF LINE
	POPJ	P,		;  YES, RETURN
	CAIE	CH," "		;TEST FOR BLANK (END OF FIELD)
	JRST	SKPFLD		;  NO, KEEP ON READING
	SOJG	N,SKPFLD	;DECR FIELD COUNT & REPEAT
	JRST	CPOPJ1		; FOUND IT, RETURN +1


IORJOB:	MOVE	A,JOBNO		;GET USER'S JOB #
	LSH	A,^D35-^D24	;SHIFT INTO BITS 18-24
	IORM	A,IORPPN	;COMBINE WITH PPN FOR MOUNT/DISMOUNT USE
	POPJ	P,		;RETURN TO CALLER
>;	END OF	IFN LOGSW
IFN FILESW,<

GETTAP:	MOVEI	M,TAPMSG
	TLNE	F,L.ARGD
	PUSHJ	P,MSGTTY		;ASK FOR TAPE NUMBER IF DOING THAT SORT OF THING
	PUSHJ	P,GETARG
	TLNE	F,L.SPC+L.BRK+L.CMA  ;TAPE NUMBER ENDS WITH SPACE,BREAK, OR COMMA
	TLNE	F,L.WLD+L.DOT		; AND NOT * OR PERIODS
	JRST	COMERR
	JUMPE	A,COMERR	;ERR IF NULL TAPEID
	MOVEM	A,TAPEID
	POPJ	P,0		;ALL RIGHT ALREADY!
COMSET:	MOVSI	A,'DSK'		;ASSUME FILE ANYWHERE IN S/L
	MOVEM	A,FILDEV	;STORE AWAY AS STR FOR DIRECTORY
	MOVE	A,TAPEID	;GET PROSPECTIVE DIR NAME
	MOVEM	A,FILBLK	;STORE AS PARAMETER
	MOVSI	A,'DIR'		;GET EXTENSION
	MOVEM	A,FILBEX	;STORE AS PARAMETER
	MOVE	A,USRPPN	;GET USER'S PPN
	MOVEM	A,FILPPN	;STORE AS PARAMETER
	SETZ	D,		;CLEAR AOBJN AC TO SHOW DIRECTORY
	PUSHJ	P,GETDEV	;GO LOOK UP THE DIRECTORY
	  JRST	COMST1		;  NOT THERE, SKIP
	MOVE	A,FILDEV	;GET RETURNED DEVICE
	CAMN	A,[SIXBIT /DSK/] ;TEST FOR STILL 'DSK'
COMST1:	MOVE	A,STDDEV	;  YES, DEFAULT STR FOR THE DIR FILE
	MOVEM	A,FILDEV	;STORE AS STR FOR THE DIR FILE
	SKIPE	FILDEV		;HAVE WE FOUND A DEV: FOR DIRECTORY?
	 JRST	COMST2		;YES, GO ON
	MOVEI	M,NDFD		;NO, TELL USER NO DIRECTORY CAN BE MADE
	PUSHJ	P,MSGTTY
	PUSHJ	P,CRLF
	MOVSI	A,'DSK'		;USE 'DSK' AS DEV: AS SIGNAL TO OMOUNT
	MOVEM	A,FILDEV	;THAT THERE'S NO DEV: FOR DIRECTORY
COMST2:	SETZM	FILBEX		;CLEAR THE EXTENSION FIELD NOW
	SETZM	FILPPN		;  DITTO, FOR THE PPN
	MOVEI	A,1		;MAKE 1ST FILE NAME NON-0
	MOVEM	A,FILBLK	;TO FORCE OUT DEVICE NAME IN COMMAND FILE
	MOVSI	D,-DTDNFI
	AOBJN	D,CPOPJ

;THIS ROUTINE READ A FILE NAME FROM TTY

GETFIL:	TLZ	F,L.WLD		;SHOW NO WILD-CARD FILE
GETFL0:	PUSHJ	P,GEFARG	;READ NEXT PART OF THE FILE NAME
	TLNE	F,L.BRAK	;TEST FOR "[" BEGINNING PPN
	JUMPE	A,GETPPD	;  YES, JUMP IF PRECEDING A FILE NAME
	JUMPE	A,CPOPJ		;RETURN +0 IF NULL FILE NAME
	CAIN	CH,":"		;TEST FOR ":" TERMINATING DVC NAME
	JRST	GETFLD		;  YES, GO STORE DEVICE NAME
	MOVEM	A,FILBLK(D)	;STORE FILE NAME
	MOVE	A,DEFPPN	;GET DEFAULT PPN
	MOVEM	A,FILPPN(D)	; & STORE IT
	MOVE	A,DEFDEV	;GET DEFAULT DEVICE
	MOVEM	A,FILDEV(D)	; & STORE IT
	SETZM	FILBEX(D)	;CLEAR THE EXTENSION FIELD
	TLNE	F,L.BRAK	;TEST FOR "[" BEGINNING PPN
	JRST	GETFL1		;  YES, NO EXTENSION, SO JUMP
	TLNN	F,L.DOT		;TEST FOR EXTENSION COMING (".")
	JRST	GETFL2		;  NO, GO INSPECT PPN
	PUSHJ	P,GEFARG	;READ THE EXTENSION
	HLLZM	A,FILBEX(D)	; & STORE IT
	TLNN	F,L.BRAK	;TEST FOR PPN COMING NOW
	JRST	GETFL2		;  NO, SO INSPECT DEFAULT PPN
GETFL1:	PUSHJ	P,REDPPN	;READ THE PPN
	MOVEM	A,FILPPN(D)	; & STORE IT
	TLNE	F,L.EOL		;TEST FOR END OF LINE
	JRST	GETFL2		;  YES, JUMP
	PUSHJ	P,GETARG	;READ NEXT INPUT DELIMITER
	JUMPN	A,COMERR	;ERROR IF SIXBIT RETURNED
GETFL2:	SKIPE	A,FILPPN(D)	;GET CURRENT FILE PPN & TEST FOR ZERO
	CAMN	A,USRPPN	;TEST FOR [SELF]
	JRST	CPOPJ1		;  EITHER, RETURN (PPN IS OK)
	MOVE	A,CMDCHR	;GET TYPE OF FILE RQST
	CAIE	A,"F"		;TEST FOR 'FILE F'
	CAIN	A,"Z"		;TEST FOR 'FILE Z'
	JRST	CPOPJ1		;  EITHER, RETURN (PPN IS OK)
	JRST	PPNERR		;  ELSE GIVE 'BAD-PPN' ERROR

GETFLD:	TLNE	F,L.WLD		;TEST FOR WILD DEVICE NAME
	JRST	COMERR		;  YES, SYNTAX ERROR
	MOVE	B,CMDCHR	;GET TYPE OF FILE CMD
	CAIN	B,"D"		;TEST FOR 'FILE D'
	JRST	PPNERR		;  YES, GIVE ERROR MSG
	MOVEM	A,DEFDEV	;STORE DEFAULT DEVICE NAME
	MOVE	B,A		;COPY DEVICE NAME FOR ERROR MSG
	DEVCHR	A,		;FIND OUT ABOUT THE DEVICE
	TLNN	A,DC.FS		;TEST FOR A DISK
	JRST	ILDERR		;  NO, ILLEGAL DEVICE
	DEVNAM	B,		;CALL FOR PHYSICAL DEVICE NAME
	  MOVE	B,DEFDEV	;  FAILED, USE ORIGINAL NAME
	MOVS	A,B		;PUT SWAPPED DEVICE NAME IN 'A'
	DEVPPN	B,		;FIND OUT PPN ASSOC. WITH THE DEVICE
	  SKIPA	B,DIRPPN	;  NO UUO, GET DEFAULT PPN & SKIP
	JRST	GETFD1		;  UUO WORKED, JUMP (PPN IN 'B')
	CAIN	A,'SYS'		;TEST FOR 'SYS'
	MOVE	B,SYSPPN	;  YES, GET SYS'S PPN
GETFD1:	SKIPN	B		;TEST FOR NULL PPN
	MOVE	B,DIRPPN	;  YES, GET DEFAULT PPN
	MOVEM	B,DEFPPN	;STORE AS PPN DEFAULTING FOR THIS DEVICE
	CAIE	A,'D  '		;TEST FOR 'D' DEVICE
	CAIN	A,'DS '		;TEST FOR 'DS' DEVICE
	MOVEI	A,'DSK'		;  EITHER, CONVERT TO 'DSK'
	CAIN	A,'LIB'		;TEST FOR JOB-SPECIFIC 'LIB'
	MOVEI	A,'DSK'		;  YES, CONVERT TO 'DSK' ALSO
	MOVSM	A,DEFDEV	;STORE JOB-INDEPENDENT DEVICE NAME NOW
	JRST	GETFL0		;CONTINUE READING

GETPPD:	PUSHJ	P,REDPPN	;READ THE PPN FIELD
	MOVEM	A,DEFPPN	; & STORE AS DEFAULT PPN
	JRST	GETFL0		;CONTINUE READING

	
;SUBROUTINE TO FIND F.S. A FILE IS ON IN THE CASE OF 'DSK'
;RET+0	IF CANT FIND IT OR DIDNT PICK A DEFAULT
;RET+1	FILDEV(D) FILLED WITH F.S. NAME

GETDEV:	MOVEM	D,SAVED		;SEE IF THE FILE EXISTS
	MOVEI	A,17
	MOVE	B,FILDEV(D)
	SETZ	C,
	OPEN	USR,A
	  JRST	ILDERR		;'ILLEGAL F.S.' ERROR
	MOVE	C,FILPPN(D)	;GET INPUT PPN IN AC (JUST IN CASE)
	JUMPE	D,LVDLUK	;JUMP IF PROCESSING DIR FILE
	MOVE	A,CMDCHR	;GET FILE COMMAND TYPE (LETTER)
	CAIE	A,"D"		;TEST FOR "FILE D"
	TLNE	F,L.WLD		;TEST FOR WILD-CARD FILE
				;  NO LOOKUP IF WILD-CARD OR "FILE D"
	 JRST	GETDE7
	JRST	LVDLUK		;OTHERWISE, DO LOOKUP
GETDE6:	MOVE	C,USRPPN	;  EITHER, MUST BE SAME AREA
GETDE7:	MOVE	D,SAVED		;RESTORE AOBJN POINTER
	MOVEM	C,FILPPN(D)	;STORE FILE'S PPN
	JRST	CPOPJ1		;TAKE NORMAL RETURN TO CALLER

LVDLUK:	MOVEI	A,EXLLEN-1
	MOVEM	A,SRCBUF
	MOVE	A,FILBLK(D)
	MOVEM	A,SRCBUF+EXLNAM
	HLLZ	A,FILBEX(D)
	MOVEM	A,SRCBUF+EXLEXT
	MOVE	A,FILPPN(D)	;GET SPECIFIED PPN
	MOVEM	A,SRCBUF+EXLPPN	;STORE FOR LOOKUP
	LOOKUP	USR,SRCBUF
	  JRST	GETDE8
	LDB	B,[POINT 9,SRCBUF+EXLPRV,8] ;GET FILE'S PROTECT CODE
	HRLI	B,5		;ASSUME READ ACCESS (FILE F OR FILE Z)
	MOVE	D,CMDCHR	;GET RQST TYPE (LETTER)
	SKIPN	SAVED		;TEST FOR DIRECTORY FILE
	 MOVEI	D,"R"		;  YES, TREAT AS 'FILE R'
	CAIN	D,"R"		;TEST FOR 'FILE R'
	 HRLI	B,3		;  YES, WRITE ACCESS REQ'D
	MOVE	C,SRCBUF+EXLPPN	;GET FILE'S DISK AREA PPN
	CAME	C,USRPPN	;TEST FOR SAME AS [SELF]
	CAIE	D,"R"		;TEST FOR 'FILE R'
	SKIPA	D,USRPPN	;  GET USER'S PPN & SKIP IF [SELF] OR NOT 'FILE R'
	 JRST	GETDE6		;GO GET USER'S PPN FOR FILE R
	MOVEI	A,B		;POINT AT PARM LIST (AC'S B-C-D)
	CHKACC	A,		;CHECK FILE ACCESS
	  SKIPA			;  NOT IMPL., ASSUME OK
	AOJE	A,PROTFL	;JUMP IF -1 RET'D, PROT FAILURE
	MOVE	C,SRCBUF+EXLPPN	;RESTORE FILE'S PPN
	MOVE	D,SAVED		;RESTORE AOBJN POINTER
	MOVE	A,SRCBUF+EXLDEV
	MOVEM	A,FILDEV(D)
	JRST	GETDE7

GETDE9:	TLZA	B,-1		;CLEAR L.H. LEAVING ERROR CODE & SKIP
GETDE8:				;HERE ON EXTENDED LOOKUP ERROR
	HRRZ	B,SRCBUF+EXLEXT	;GET LOOKUP ERROR CODE
	CAIN	B,2		;TEST FOR PROTECTION FAILURE
	 JRST	PROTFL		;  YES, JUMP
	POPJ	P,		;GIVE ERROR RETURN TO CALLER
>;	END OF IFN FILESW
SUBTTL	DUMMY MOUNT/DISMOUNT CODE
IFE MNTSW,<
DISMNT:	MOVEI	M,NODISM
	JRST	.+2

MOUNT:	MOVEI	M,NOMNTM
	JRST	ERRRET		;GO TYPE THE MSG & EXIT
>	;END CONDITIONAL ON MNTSW
SUBTTL	DISMOUNT COMMAND
IFE MNTSW,<XLIST>
IFN MNTSW,<

	;DISMOUNT CUSP STARTS HERE

DISMNT:	MOVEI	A,"D"
	MOVEM	A,CMDCHR
IFN LOGSW, <
	PUSHJ	P,IORJOB	;SET UP FILE NAME FOR DISMOUNT CMD
>;	END OF	IFN LOGSW
	TLZ	F,L.VID!L.REM!L.PWA
	SETZM	PHYNAM
	SETOM	DMSPOS		;SHOW NO POSITION RQST ENTERED
	SETOM	TOJOB		;SHOW NO DISPOSITION RQST ENTERED
	PUSHJ	P,DISMN6	;LOOK FO SWITCHES
	PUSHJ	P,REDEV		;GET FILE STRUCTURE NAME
	JUMPE	A,ERR101	;NO F/S NAME
	MOVEM	A,CMDFSN	;COMMAND'S FILE STR NAME
	DEVNAM	A,		;GET PHYSICAL NAME
	  MOVE	A,CMDFSN	;
	CAMN	A,[SIXBIT /DSK/];USE ORIGINAL FS NAME IF "DSK"
	MOVE	A,CMDFSN	;  WAS RETURNED
	MOVEM	A,DVVNAM
	PUSHJ	P,DISMN6	;SWITCHES AGAIN
	PUSHJ	P,CKEOL		;GO CHECK FOR END OF LINE
	SKIPE	NOTLOG		;TEST FOR LOGGED IN
	JRST	LOGERR		;  NO, THEN CAN'T DISMOUNT

;WHAT KIND OF DEVICE IS IT?

	MOVE	A,DVVNAM	;DO A DEVCHR
	DEVCHR	A,
	MOVEM	A,DEVMOD	;STORE DEVCHR RESULT FOR LATER
	JUMPE	A,ERR6		;ASSUME IT WAS A F.S. THAT WENT AWAY
IFN SPONUL, <
	MOVS	B,DVVNAM	;GET SWAPPED PHYSICAL DVC NAME
	CAIN	B,'NUL'		;TEST FOR DEVICE NUL:
	JRST	DISMNN		;  YES, JUMP
>;	END OF	IFN SPONUL
	TLNE	A,DC.FS		;F.S.?
	JRST	DISMN3		;YES-NEEDS SPECIAL ATTENTION

;HERE IF NOT A F.S. -- MUST 5.03 OR LATER(FOR COMPAT. WITHE MOUNT SIDE)

IFN SPONUL, <
DISMNN:				;HERE IF DEVICE NUL:
>;	END OF	IFN SPONUL
	MOVE	B,MONVER	;CK. MONITOR VERSION
	CAIGE	B,VER503
	JRST	ERR503

	MOVE	A,DVVNAM	;IS IT ASSIGNED?
	DEVTYP	A,
	  JSP	N,NEVERR
IFN SPONUL, <
	MOVS	B,DVVNAM	;GET SWAPPED PHYSICAL DEVICE NAME
	CAIN	B,'NUL'		;TEST FOR DEVICE NUL:
	TLO	A,.TYSPL	;  YES, TREAT AS IF SPOOLED
	MOVEM	A,DVVTYP	;SAVE DEVTYP BITS FOR LATER
	TLNE	A,.TYSPL	;TEST FOR SPOOLED DEVICE
	SKIPA	A,JOBNO		;  YES, GET JOB # & SKIP
>;	END OF	IFN SPONUL
	LDB	A,[.TYJOB+A]
	CAME	A,JOBNO
	JRST	DISMN1		;NO
IFE SPONUL, <
	MOVE	A,DVVNAM	;GET DEVICE NAME
	DEVTYP	A,		;FIND OUT ABOUT DEVICE TYPE
	  JSP	N,NEVERR	;  FAILED, STRANGE ERROR
>;	END OF	IFE SPONUL
	MOVE	A,DVVTYP	;GET DEVTYP BITS
	TLNE	A,.TYSPL	;TEST FOR SPOOLED/NUL:
	JRST	NORSTS		;  YES, JUMP
	MOVE	B,USRPPN	;GET USER'S PPN
	CAME	B,FS1PPN	;TEST FOR [1,2]
	TRNN	A,.TYRAS	;TEST FOR UNRESTRICTED DEVICE
	JRST	NORSTD		;  EITHER, JUMP
	MOVE	B,STATES	;GET STATES WORD
	TRNE	B,STAOPR	;TEST FOR OPR WANTING TO SEE THINGS
	JRST	NORSTD		;  NO, THEN NO NEED TO FORCE THE USER
NORSTS:	SKIPLE	B,TOJOB		;GET DESTINATION JOB # & TEST IT
	CAMN	B,JOBNO		;TEST FOR /KEEP
	JRST	NORSTD		;  JUMP IF NOT /REASSIGN
	TLNE	A,.TYSPL	;TEST FOR SPOOLED/NUL:
	JRST	NORSTT		;  YES, SKIP MESSAGE
	TYPE	<% /REASSIGN illegal for restricted device - /RELEASE assumed
>;				;TELL THE USER OF HIS ERROR
NORSTT:	SETZM	TOJOB		;FORCE /RELEASE FOR DEVICE
NORSTD:	MOVE	B,DVVNAM	;GET USER'S DEVICE NAME
	DEVNAM	B,		;CALL TO GET ASSOC PHYSICAL NAME
	  JSP	N,NEVERR	;  ERROR, FATAL & UNEXPECTED
	MOVEM	B,PHYNAM	;STORE PHYSICAL NAME FOR LATER
	MOVE	A,DEVMOD	;GET DEVCHR BITS
	TLNE	A,DC.DTA!DC.MTA	;TEST FOR SOME KIND OF TAPE
	TLNN	A,DC.AVA	;TEST FOR AVAILABLE DEVICE
	JRST	DISM0B		;  JUMP IF NOT TAPE OR NOT AVAIL
	SKIPLE	TOJOB		;SKIP IF /RELEASE TO FORCE DEFAULT POSITIONING
	SKIPGE	A,DMSPOS	;GET RQSTED POSITION IF ANY
IFG UNLOSW, <	PUSHJ	P,DMSUNL> ;  NONE, SET UP /UNLOAD
IFE UNLOSW, <	PUSHJ	P,DMSREW> ;  NONE, SET UP /REWIND
IFL UNLOSW, <	PUSHJ	P,DMSSTA> ;  NONE, SET UP /STAY
	JUMPE	A,DISM0B	;SKIP CODE IF /STAY
	PUSHJ	P,MOPEN		;OPEN THE DEVICE
	  JRST	DISM0B		;  FAILED, SKIP THE CODE
	PUSH	P,INTBLK	;SAVE THIS TO PRESERVE ^C INTERCEPT
	MOVE	A,[4,,DISM0A]	;SET UP 4-WD INTERRUPT BLOCK
	MOVEM	A,INTBLK	;  DITTO
	MOVE	A,[EXP PHOPEN!1B35];  DITTO
	IORM	A,INTBLK+1	;  DITTO
	MTAPE	US1,@DMSPOS	;REPOSITION THE TAPE
DISM0A:	RELEAS	US1,		;RELEASE THE DEVICE
	POP	P,INTBLK	;RESTORE PREV VALUE OF INTBLK
	ANDCAM	A,INTBLK+1	;TURN OFF THE TAPE-ERROR INTERCEPT
DISM0B:				;HERE NOT TO REPOSITION
	MOVE	B,TOJOB		;GET DESTINATION JOB #
	CAMN	B,JOBNO		;TEST FOR /KEEP
	JRST	DISM0C		;  YES, THEN JUMP
	MOVE	B,DVVNAM	;GET DEVICE NAME
	PUSHJ	P,MOPEN		;OPEN THE DEVICE
	  SKIPA	C,DVVNAM	;  FAILED, GET DEVICE NAME & SKIP
	MOVEI	C,US1		;GET CHANNEL # OF OPEN DEVICE
	MOVE	A,C		;COPY PARAMETER INTO CORRECT AC
	SETZ	B,		;CLEAR AC FOR LOGICAL NAME
	DEVLNM	A,		;DEASSIGN THE LOGICAL NAME
	  JSP	N,NEVERR	;  FAILED, A FATAL ERROR
	MOVE	B,C		;COPY PARAMETER INTO CORRECT AC
	SKIPGE	A,TOJOB		;GET DESTINATION JOB & TEST IT
	SETZB	A,TOJOB		;  UNDEFINED, ASSUME /RELEASE
	REASSI	A,		;REASSIGN IT SOMEPLACE
	SKIPE	TOJOB		;TEST FOR /RELEASE
	JUMPE	A,DISMN4	;  NO, 0 RET'D MEANS ILLEGAL JOB #
	SKIPN	B		;TEST FOR REASSIGNED
	JSP	N,NEVERR	;  NO, FATAL ERROR
	RELEAS	US1,		;RELEASE IT
DISM0C:				;HERE WHEN DEVICE DISPOSED OF
IFN SPONUL, <
	MOVE	A,DVVTYP	;GET DEVTYP BITS FOR THE DEVICE
	TLNE	A,.TYSPL	;TEST FOR SPOOLED/NUL:
	JRST	DISMN2		;  YES, THEN DONE NOW
>;	END OF	IFN SPONUL
	MOVE	A,DEVMOD	;GET DEVCHR BITS
	TLNE	A,DC.DIS!DC.TTY	;TEST FOR DISPLAY OR TTY
	JRST	DISMN2		;  EITHER, NO NEED TO TELL OPR
	MOVE	A,TOJOB		;GET DESTINATION JOB
	CAMN	A,JOBNO		;TEST FOR DEVICE /KEEP SWITCH
	TLNE	A,L.REM		;TEST FOR NOT /UNLOAD
	SKIPA			; SKIP IF OWNERSHIP CHANGED OR DVC UNLOADED
	JRST	DISMN2		; DONE IF NO NEED TO CONCERN OPR
	MOVE	A,STATES	;GET THE STATES WORD
	TRNN	A,STAOPR	;TEST FOR OPR WANTING TO KNOW ANYTHING
	JRST	DISMN0		;  YES, THEN GO TELL HIM
	JRST	DISMN2		;  NO, THEN DONE NOW
;  HERE IF OPR NEEDS TO SEE THE REQUEST

DISMN0:	PUSHJ	P,REMREQ	;GO GENERATE A /REMOVE RQST
	JRST	DISMN2		;GO RETURN NOW


;  HERE IF USER DOESN'T OWN THE DEVICE

DISMN1:	JRST	MSG105		;TELL HIM OF HIS ERROR

;  HERE IF REQUEST SERVICED BY UMOUNT

DISMN2:	MOVE	A,PHYNAM	;GET PHYSICAL NAME
	MOVEM	A,CMDFSN	;STORE FOR DISMOUNT MSG
	JRST	DISFIN		;MERELY RETURN


;  HERE IF /REASSIGN FAILED

DISMN4:	TYPE	<% /REASSIGN job # not assigned - /RELEASE assumed
>
	SETZM	TOJOB		;AVOID LOOP - FORCE RELEASE
	JRST	DISM0B		;GO TRY AGAIN
;HERE IF WERE DEALING WITH A F.S.

DISMN3:
IFN JACTSW,<	;FONT WANT THIS FOR SOME DEBUGGING
	TRNE	F,R.NJAC	;MUST BE PRIVILEGED FOR F.S.S
	JRST	ERR103
>
	MOVE	B,FSNAME	;B=STR NAME
	MOVEI	A,B
	DSKCHR	A,
	  JRST	ERR6
	LDB	B,D.ARGT	;IS THIS A SINGLE F.S.?
	CAIE	B,A.FS
	JRST	ILFERR			;NO
	MOVEI	A,"D"
	MOVEM	A,CMDCHR
	MOVE	A,[PHOPEN!17]	;SET UP TO OPEN THE FILE STRUCTURE
	MOVE	B,FSNAME	; TO SEE IF A UFD EXISTS
	MOVEM	B,UFDFSN	;SET THIS FOR DISSTR
	SETZ	C,
	OPEN	USR,A
	 JRST	DISM3B
	MOVE	A,USRPPN	;SET UP TO LOOK UP UFD ON THIS F/S
	MOVEM	A,SRCBUF
	MOVSI	A,(SIXBIT /UFD/)
	MOVEM	A,SRCBUF+1	;'UFD' (EXTENSION)
	SETZM	SRCBUF+2	;PRIVS WORD
	MOVE	A,MFDPPN
	MOVEM	A,SRCBUF+3	;1,,1
	LOOKUP	USR,SRCBUF	;LOOK UP THE UFD
	 SKIPA	A,SRCBUF+1	;NO UFD, KEEP ERROR CODE
	JRST	DISM3A		;IT'S THERE , PROCEED NORMALLY
	TRNE	A,-1		;NOT FOUND ERROR
	 JRST	DISM3A		; NO, DIG DEEPER
	PUSHJ	P,DISSTR	; YES, REMOVE F/S FROM S/L
	JRST	DISM3C		; AND AVOID QUOTA... STUFF
DISM3A:	RELEASE	USR,
DISM3B:	MOVE	A,USRPPN	;GET QUOTA.SYS LOG.OUT
	MOVE	B,FSNAME
	PUSHJ	P,GETQUO
	  SETO	D,
	MOVE	A,USRPPN
	MOVE	B,JOBNO
	MOVE	N,SYSPPN
	MOVE	N1,MFDPPN
	MOVE	M,FSNAME
	MOVEI	IO,W.TTY
	PUSHJ	P,UFDCLR	;CLEAR UFD
	  JRST	DISFI1
DISM3C:	PUSHJ	P,CKMNC		;CALL TO CHECK THE MOUNT COUNT
	TLNN	F,L.REM		;REMOVE STR?
	JRST	DISFIN		;NO, ALL DONE
	MOVE	A,STATES	;GET STATES WORD
	TRNE	A,STAOPR	;TEST FOR OPR PRESENT
	JRST	DISMN5		;  NO, THEN CAN'T REMOVE F/S
	PUSHJ	P,REMREQ
	JRST	DISFIN

DISMN5:	TYPE	<Operator not on duty - /REMOVE ignored
>;				;TELL THE USER
	JRST	DISFIN		; & GO EXIT

;	HERE TO READ SWITCHES

DISMN6:	PUSHJ	P,SST		;INGORE SPACE TABS
	CAIE	CH,"/"
	POPJ	P,		;NO MORE SWITCHES
	MOVE	E,[XWD -DMSLEN,DMSLST]
	PUSHJ	P,UDSWIT
	JRST	DISMN6		;LOOP UNTIL NO MORE SWITCHES
DISFIN:
IFN FTFACT,<
IFE FTFCT1,<
	SKIPE	IDIDIT		;IF DIDN'T GO TO OMOUNT, WRITE FACT
	 JRST	DISFN2		; ELSE, BYPASS: OMOUNT DID IT
>;	END IFE FTFCT1
	HRLI	NUM,'UD '	;SHOW USER DISMOUNT 'QUEUE' CODE
	MOVE	A,DEVMOD	;GET OLD DEVCHR WORD
	TLNE	A,DC.FS		;UMOUNT USES DIFFERENT FIELDS TO STORE 
	 JRST	DISFN1		; THE NAME WE WANT TO USE HERE FROM
	MOVE	A,TOJOB		;F/S TO NON-F/S. GET DESTINATION JOB #
	CAMN	A,JOBNO		;TEST FOR CHANGING JOBS
	 JRST	DISFN2		;  NO, JUMP: NO NEED TO REGISTER DISMOUNT
	SKIPA	A,PHYNAM	;DEVICE NAME FOR SPOOLED ENTRY
DISFN1:	MOVE	A,FSNAME	;DEVICE NAME FOR F/S
	PUSHJ	P,WRFACT	;WRITE FACT FILE ENTRY
DISFN2:
>;	END OF IFN FTFACT
	MOVEI	IO,W.TTY
	MOVE	M,CMDFSN
	PUSHJ	P,SIXMSG
	MOVEI	M,DISDON
	JRST	ALLFIN

;SUBROUTINE TO QUEUE REQUEST TO OPR AND WAIT FOR IT
REMREQ:	SETZM	TAPEID
	SETZM	FILBLK
	HRLI	NUM,(SIXBIT .D.)
	PUSHJ	P,COMBEG
	MOVEI	M,[ASCIZ . DISMOUNT .]
	PUSHJ	P,MSG
	SKIPN	M,PHYNAM
	MOVE	M,FSNAME
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ . /R.]
	TLNE	F,L.REM
	PUSHJ	P,MSG
	PUSHJ	P,VIDOUT	;CK FOR /VID
	PUSHJ	P,CRLF
	HRROI	A,40		;GET .GTLIM GETTAB PARMS FOR [SELF]
	GETTAB	A,		;GET .GTLIM WORD FOR MY JOB
	  SETZ	A,		;  FAILED, SET TO ZERO
	TLNE	A,(1B10)	;TEST FOR MPB JOB
	TRNE	F,R.NOWA	;DO NOT WAIT IF T/S OR /NOWAIT
	TRNE	F,R.WAIT	;WAIT IF NOT BATCH OR USER TYPED /WAIT
	JRST	REMRQ1		;  YES, GO WAIT FOR COMPLETION
	CLOSE	CMD,		;CLOSE THE CMD FILE NOW
	MOVE	A,NAMMNT	;GET THE OMOUNT NAME
	PUSHJ	P,WAKE1		;WAKE ALL OMOUNTS
	  PUSHJ	P,MSG113	;  NONE RUNNING, TELL THE USER
	POPJ	P,		;RETURN TO CALLER
REMRQ1:				;HERE TO WAIT ON COMPLETION
	PUSHJ	P,MSG110
	PJRST	TMWAIT		;GO WAIT FOR COMPLETION
	

;  CKMNC - SUBROUTINE TO CHECK FOR BUSY F/S
;
;	EXITS IMMEDIATELY IF USER IS NOT [1,2] OR DID NOT SAY /REMOVE
;	CLEARS /REMOVE SWITCH IF NOT [1,2] *AND*
;	  MOUNT COUNT NOT ZERO, OR
;	  STR IN SYSTEM S/L, OR
;	  F/S IS QUEUE STRUCTURE, OR
;	  F/S CONTAINS STRLST.SYS, OR
;	  F/S HAS SWAPPING SPACE
;

CKMNC:	MOVE	A,USRPPN	;GET USER'S PPN
	CAME	A,FS1PPN	;TEST FOR [1,2]
	TLNN	F,L.REM		;TEST FOR /REMOVE
	POPJ	P,		;  RETURN IF [1,2] OR NOT /REMOVE
	MOVE	B,FSNAME	;GET STR NAME
	MOVEI	A,B		;POINT AT STR NAME
	DSKCHR	A,		;FIND OUT ABOUT IT
	  JRST	ERR6		;  FAILED, GIVE AN ERROR
	TLNN	A,D.MC		;TEST FOR MOUNT COUNT = 0
	JRST	CKMNC5		;  NO, GO GIVE ERROR MSG
	MOVE	A,MONVER	;GET MONITOR VERSION
	CAIGE	A,VER503	;TEST FOR 5.03 OR LATER
	JRST	CKMNC2		;  NO, JUMP
	MOVEI	N,A		;POINT AT PARM LIST
	SETZ	A,		;CLEAR JOB #
	MOVE	B,SYSPPN	;GET SYS PPN
	MOVE	C,FSNAME	;GET STR NAME
	GOBSTR	N,		;SEARCH SYSTEM S/L
	  JRST	CKMNC1		;  ERROR, GO LOOK AT ERROR CODE
	JRST	CKMNC5		;  WORKED, STR IN SYS S/L
CKMNC1:	CAIE	N,3		;TEST FOR NOT IN S/L ERROR CDE
	PUSHJ	P,NEVMSG	;  NO, STRANGE ERROR
CKMNC2:	MOVE	A,FSNAME	;TEST FOR QUEUE STR
	CAMN	A,CMDSTR	;TEST FOR QUEUE STR
	JRST	CKMNC5		;  YES, CAN'T REMOVE IT
;  LOOK FOR STRLST.SYS ON THIS STR
	MOVE	A,[EXP PHOPEN!17];SET PHYSICAL-ONLY OPEN IN DUMP MODE
	MOVE	B,FSNAME	;GET STR NAME
	SETZ	C,		;SET NO BUFFER HEADERS
	OPEN	US1,A		;OPEN THE STR
	  JRST	CKMNC3		;  FAILED, JUMP
	MOVE	A,[SIXBIT .STRLST.] ;GET FILENAME
	MOVSI	B,(SIXBIT .SYS.)    ; & EXTENSION
	SETZ	C,		;CLEAR 3RD ARG
	MOVE	D,SYSPPN	;GET SYS PPN
	LOOKUP	US1,A		;LOOK UP STRLST.SYS
	  JRST	CKMNC3		;  FAILED, CONTINUE ON
	RELEAS	US1,		;GIVE UP THE CHANNEL
	JRST	CKMNC5		; & GO GIVE THE ERROR MSG
CKMNC3:	RELEAS	US1,		;GIVE UP THE CHANNEL
;  CHECK FOR SWAPPING UNIT
	MOVEI	C,0		;CLEAR THE UNIT COUNTER
CKMNC4:	MOVE	A,C		;COPY THE UNIT NUMBER
	MOVE	B,FSNAME	;GET THE STR NAME
	PUSHJ	P,LOGUNI	;ASSEMBLE A LOGICAL UNIT NAME
	MOVEM	B,CHRBUF	; & STORE IT FOR DSKCHR
	MOVE	A,[XWD CHRLEN,CHRBUF] ;GET DSKCHR PARM PTR
	DSKCHR	A,PHONLY	;FIND OUT ABOUT THIS UNIT
	  POPJ	P,		;  NO SUCH UNIT, RETURN
	SKIPN	CHRBUF+12	;TEST # OF K OF SWAPPING SPACE
	AOJA	C,CKMNC4	;  ZERO, GO TRY NEXT UNIT
;  HERE IF F/S BUSY
CKMNC5:	TYPE	<% >;		;BEGIN THE MESSAGE
	MOVE	M,FSNAME	;GET THE STR NAME
	PUSHJ	P,SIXTTY	; & TYPE IT
	TYPE	< has other users - /REMOVE ignored
>;				;TELL THE USER WHAT HAPPENED
	TLZ	F,L.REM		;CLEAR /REMOVE SWITCH
	POPJ	P,		;RETURN NOW

;  S/R TO CREATE LOGICAL UNIT NAMES
;	CALL -	A = LOGICAL UNIT NUMBER
;		B = F/S NAME
;	RETURN -B = LOGICAL UNIT NAME

LOGUNI:	MOVE	N,[POINT 6,B]	;GET F/S BYTE POINTER
LOGUN1:	ILDB	M,N		;GET NEXT CHAR OF F/S NAME
	TLNE	N,770000	;TEST FOR SIXTH CHAR
	JUMPN	M,LOGUN1	;LOOP IF NOT END OF NAME
	MOVEI	M,'0'(A)	;CREATE AN SIXBIT DIGIT
	DPB	M,N		;STORE TO REPLACE 1ST NULL
	POPJ	P,		;RETURN TO CALLER
;
;	DISMOUNT DISPATCH TABLE AND ROUTINES
;
	DEFINE SWTAB (A)<
	IRP A,<XWD SIXBIT \   A\,DMS'A>>

DMSPAU==UMSPAU
DMSVID==VIDIN

	SWERR2
	SWERR
DMSLST:	SWTAB <HEL,R,REM,PAU,CHE,VID,WAI,NOW,KEE,REA,REL,REW,UNL,STA>
DMSLEN=.-DMSLST

DMSHEL:	MOVE	A,[<SIXBIT /DISMOUNT/>] ;GET NAME OF HELP FILE
	JRST	GOHELP		;GO TYPE IT OUT

DMSR:				;MERELY /R
DMSUNL:				;/UNLOAD
DMSREM:	TLO	F,L.REM
	MOVEI	A,11		;GET CODE FOR UNLOAD (MUST BE AC 'A')
	MOVEM	A,DMSPOS	;STORE AS POSITION RQST CODE
	POPJ	P,

DMSCHE:	MOVEI	NUM,(SIXBIT .D.)
	MOVE	A,NAMMNT
	JRST	CCOMSB


DMSSTA:	TDZA	A,A		;GET CODE FOR /STAY & SKIP (MUST BE AC 'A')
DMSREW:	MOVEI	A,1		;GET CODE FOR /REWIND (MUST BE AC 'A')
	MOVEM	A,DMSPOS	;STORE AS POSITION RQST CODE
	TLZ	F,L.REM		;SET FLAG FOR NO REMOVAL
	POPJ	P,		;RETURN

DMSKEE:	MOVE	A,JOBNO		;GET CURRENT JOB # FOR /KEEP
	MOVEM	A,TOJOB		;STORE AS DVC DISPOSITION
	POPJ	P,		;RETURN

DMSREL:	SETZM	TOJOB		;CLEAR DVC DISPOSITION FOR /RELEASE
	POPJ	P,		;RETURN

DMSREA:	CAIE	CH,":"		;TEST FOR ARGUMENT FOLLOWING
	JRST	COMERR		;  NO, ERROR
	PUSHJ	P,SDECIN	;READ DESIRED JOB # FOR /REASSIGN
	JUMPLE	N,COMERR	; ERROR IF .LE. 0
	MOVE	A,[15,,CNFTBL]	;GET GETTAB PARMS FOR HIGHEST JOB #
	GETTAB	A,		;GET HIGHEST JOB #
	  MOVEI	A,^D64+1	;  FAILED, ASSUME LEVEL-C
	CAILE	N,-1(A)		;TEST FOR LEGAL JOB #
	JRST	COMERR		;  NO, ERROR
	MOVEM	N,TOJOB		;STORE AS DVC DISPOSITION
	POPJ	P,		;RETURN

;SUBROUTINE TO READ A /VID SWITCH
VIDIN:	TLO	F,L.VID	;SET A BIT
	SETZM	VIDK
	CAIE	CH,":"		;FOLLOWED BY TEXT?
	JRST	COMERR		; NO - SYNTAX ERROR
;	POPJ	P,		;NO-THATS ALL
	MOVNI	A,VIDMAX
	MOVE	B,[POINT 7,VID]
	TRZ	F,R.VIDT
	PUSHJ	P,(IO)
	CAIE	CH,VIDCH1
	CAIN	CH,VIDCH2
	SKIPA	C,CH		;IF EITHER ' OR ", SAVE IT IN C
	 JRST	VIDIN4
	TRO	F,R.VIDT
	JRST	VIDIN3
VIDIN2:	PUSHJ	P,(IO)
VIDIN4:	CAIL	CH,"0"		;DIGITS ARE LEGAL
	CAILE	CH,"9"
	CAIN	CH,"-"		;HYPHEN IS LEGAL
	JRST	VIDIN3
	CAIL	CH,"A"		;LETTERS ARE LEGAL
	CAILE	CH,"Z"
	CAIN	CH,"."		;PERIOD IS LEGAL
	JRST	VIDIN3
	CAIE	CH,11		;ALLOW TABS
	CAILE	CH,15
	TRNN	F,R.VIDT
	JRST	VIDIN5
	CAME	CH,C
	JRST	VIDIN3
	AOSLE	A
	TDZA	A,A
	IBP	B
	DPB	CH,B
	PUSHJ	P,(IO)
VIDIN5:	ADDI	A,VIDMAX	;FINISHED-COUNT CHARACTERS
	MOVEM	A,VIDK
	TRZE	F,R.VIDT	;TEST FOR QUOTED VID
	SUBI	A,2		;  YES, SUBTRACT OFF SIZE OF QUOTES
	SKIPG	A		;TEST FOR POSITIVE VID SIZE
	TLZ	F,L.VID		;  NO, THEN SHOW NO VID
	POPJ	P,
VIDIN3:	JUMPGE	A,VIDIN2	;DONT OVERUN BUFFER
	IDPB	CH,B
	AOJA	A,VIDIN2

;SUBROUTINE TO OUTPUT /VID SWITCH
VIDOUT:	TLNN	F,L.VID	;WAS THERE ONE?
	POPJ	P,		;NO
	TEXT	< /V:>
	PUSHJ	P,MSG
	MOVE	A,VIDK
	MOVE	B,[POINT 7,VID]
VIDOU2:	SOJL	A,CPOPJ
	ILDB	CH,B
	PUSHJ	P,(IO)
	JRST	VIDOU2

;SUBROUTINE TO READ A REELID SWITCH
RIDIN:	TLO	F,L.RID		;SHOW WE'VE SEEN A /REELID
	CAIE	CH,":"		;IS THERE A VALUE
	 JRST	COMERR		;NO-ERROR
	PUSHJ	P,(IO)		;READ VALUE
	PUSHJ	P,SIXBRD	;..
	JUMPE	A,COMERR	;NULL-ERROR
	MOVEM	A,REELID	;SAVE IT
	POPJ	P,

;SUBROUTINE TO OUTPUT A /REELID SWITCH TO CMD FILE
RIDOUT:	TLNN	F,L.RID		;IS THERE A SWITCH
	 POPJ	P,		;NOTHING TO OUTPUT
	TEXT	< /REELID: >
	PUSHJ	P,MSG
	MOVE	M,REELID
	PJRST	SIXMSG
SUBTTL	MOUNT COMMANDS
;HERE ON MOUNT COMMANDS

MOUNT:
	MOVEI	A,"M"
	MOVEM	A,CMDCHR
IFN LOGSW, <
	PUSHJ	P,IORJOB	;SET UP FILE NAME FOR MOUNT CMD
>;	END OF	IFN LOGSW
	MOVEI	A,3		;SET LOOP CATCHERS
	MOVEM	A,LOOPX1

;SCAN FOR DEVICE & LOGICAL NAMES

	SETZM	PHYNAM
IFN LOGSW, <
	SETZM	GENLOG		;CLEAR FLAG FOR GENERATED LOGICAL NAME
>;	END OF	IFN LOGSW
	TLZ	F,L.SIN!L.WRTL!L.VID!L.PWA!L.RID!L.WEN
				;CLEAR /ACTIVE /NOCREATE FLAGS
	TRZ	F,R.CLR		;CLEAR MORE SWITCH FLAGS
IFE ACTSW, <
	TRO	F,R.PAS		;/PASSIVE IS DEFAULT IF ACTSW=0
>;	END OF IFE ACTSW
	PUSHJ	P,UMSPRC	;SWITCHES
	SKIPE	NOTLOG		;TEST FOR LOGGED IN
	JRST	LOGERR		;  NO, AN ERROR IF HERE
	PUSHJ	P,REDEV
	JUMPE	A,ERR101	;MUST BE ONE
	MOVEM	A,CMDFSN	;
	MOVEM	A,DVVNAM
	PUSHJ	P,UMSPRC	;SWITCHES
	PUSHJ	P,REDEV		;GET 2ND NAME (OPTIONALL LOGICAL NAME)
	MOVEM	A,LOGNAM
	PUSHJ	P,UMSPRC

;IS THIS A DISK OR F.S.?

	MOVE	A,DVVNAM
	DEVCHR	A,
	JUMPE	A,MOFS2		;IF IT FAILS TRY STRLST.SYS
	MOVEM	A,DEVMOD	;SAVE DEVCHR BITS
	TLNN	F,L.WRTL!L.WEN	;CHECK FOR USER SETTING WRITE-STATUS
	TLNN	A,DC.MTA!DC.DTA	;CHECK FOR ANY KIND OF TAPE
	SKIPA			;IF USER DID NOT SPECIFY WRITE STATUS,
				; AND IT IS A TAPE, SET DEFAULT
IFN WENOFS,<
	TLO	F,L.WEN		;SET WRITE-ENABLE
>;	END IFN WENOFS
IFN WLNOFS,<
	TLO	F,L.WRTL	;SET WRITE-LOCK
>;	END IFN WLNOFS
IFN SPONUL, <
	MOVE	B,DVVNAM	;GET INPUT DEVICE NAME
	DEVNAM	B,		;FIND OUT PHYSICAL NAME
	  MOVE	B,DVVNAM	;  ERROR, RESTORE ORIGINAL
	MOVSS	B		;SWAP PHYSICAL DEVICE NAME
	CAIN	B,'NUL'		;TEST FOR DEVICE NUL:
	 JRST	MOUN02		; YES, JUMP
>;	END OF	IFN SPONUL
;[100] MOUNT 42 1/2
	MOVE	B,DVVNAM	;GET INPUT DEVICE
	DEVPPN	B,		;DOES PPN OF DEV: MATCH USER'S
	  MOVE	B,USRPPN	;ERROR, USE HIS AS DEFAULT
	CAME	B,USRPPN	;DOES USER'S MATCH DEV:'S
	  JRST	ERR130		; NO, CAN'T ALLOW ERSATZ (SYSA)
	TLNE	A,DC.FS		;FILE STRUCTURE?
	 JRST	MOFS		;YES--NEEDS SPECIAL ATTENTION

;HERE FOR NON-F/S KHOWN TO SYSTEM BY DEVCHR

IFN VIDRID, <
	TLNN	F,L.VID		;TEST FOR /VID
	JRST	MOUN1B		;  NO, JUMP
	TLNE	F,L.RID		;TEST FOR /REELID
	JRST	MOUN1B		;  YES, JUMP
;  ATTEMPT TO DERIVE A REELID FROM THE GIVEN VID
	SETZM	REELID		;START WITH NULL REELID
	SKIPLE	A,VIDK		;GET VID COUNT & TEST IT
	CAILE	A,6		;TEST FOR VID TOO BIG
	JRST	MOUN1B		;  EITHER, JUMP
	MOVE	B,[POINT 7,VID]	;GET VID BYTE POINTER
	MOVE	C,[POINT 6,REELID] ;GET REELID BYTE POINTER
MOUN1A:	ILDB	D,B		;GET NEXT CHAR OF VID
	CAIL	D,"0"		;TEST FOR TOO SMALL
	CAILE	D,"Z"		;TEST FOR TOO LARGE
	JRST	MOUN1B		;  EITHER, JUMP (VID NOT ALPHAMERIC)
	CAILE	D,"9"		;TEST FOR NUMERIC VID
	CAIL	D,"A"		;TEST FOR ALPHABETIC VID
	TRCA	D,40		;  EITHER, CONVERT TO SIXBIT & SKIP
	JRST	MOUN1B		;  OTHERWISE, JUMP (VID NOT ALPHAMERIC)
	IDPB	D,C		;STORE REELID CHARACTER
	SOJG	A,MOUN1A	;DECR COUNT & REPEAT
	TLO	F,L.RID		;  DONE, SHOW /REELID DEFINED
MOUN1B:				;HERE AFTER /VID-/REELID WORK DONE
>;	END IFN	VIDRID
IFLE RIDSW, <
	MOVE	A,DEVMOD	;GET DEVCHR BITS
	TLNN	A,DC.MTA	;TEST FOR A MAGTAPE
	TLZ	F,L.RID		;  NO, THEN FORGET THE REELID
>;	END OF	IFLE RIDSW
IFG RIDSW, <
	PUSHJ	P,CKRID		;GO CHECK FOR A PROPER REELID
>;	END OF	IFG RIDSW

MOUN02:	PUSHJ	P,CKEOL		;/REELID OK; SO GO CHECK FOR END OF LINE
;HERE IF NOT A F.S. - UUOS REQUIRE 5.03 MONITOR OR LATER

	MOVE	A,MONVER
	CAIGE	A,VER503
	JRST	ERR503

;GET A PHYSICAL NAME FOR DVVNAM (IN CASE ITS GENERIC OR LOGICAL)

MOUNT1:	TDZ	F,[L.SIN,,R.ASCO!R.PAS!R.NOC]	;CLEAR F/S BITS
	SOSGE	LOOPX1		;CK FOR PATHALOGICALOOP
	JSP	N,NEVERR
	MOVE	A,DVVNAM	;ASSUME ITS PHYSICAL ALREADY
	MOVEM	A,PHYNAM
	DEVNAM	A,PHONLY	;YES-AND ALSO PHYSICAL?
	  JRST	MOUN15		;NO
	JUMPE	A,MOUN15	;NO
	MOVE	A,DVVNAM	;YES-GENERIC?
	TRNE	A,-1
	JRST	MOUN16		;NO
IFN SPONUL, <
	MOVE	B,A		;COPY THE DEVICE NAME
	DEVTYP	B,PHONLY	;FIND OUT ABOUT THE GENERIC DEVICE
	  JSP	N,NEVERR	;  ERROR, FATAL & UNKNOWN
	MOVS	C,A		;GET SWAPPED PHYSICAL DEVICE NAME
	CAIE	C,'NUL'		;TEST FOR DEVICE NUL:
	TLNE	B,.TYSPL	;TEST FOR SPOOLED GENERIC DEVICE
	JRST	MOUNT2		;  EITHER, JUST USE GENERIC NAME
>;	END OF	IFN SPONUL
IFE LOGSW, <
	SKIPN	LOGNAM		;LOGICAL NAME SPECIFIED?
	JRST	ERR104		;  NO - SO REQUEST ONE
>;	END OF	IFE LOGSW

	HRRI	A,'0  '		;YES-FIND A FREE UNIT STARTING WITH DEV0
IFN MTA0SW, <
	CAMN	A,[SIXBIT /MTA0/] ;TEST FOR MTA0
	HRRI	A,'1  '		  ;  YES, START WITH MTA1 INSTEAD
>;	END OF	IFN MTA0SW
MOUN12:	MOVE	B,A
	DEVTYP	B,PHONLY
	  JRST	MONAV
	JUMPE	B,MONAV		;NO FREE ONE -- TELL USER
	LDB	C,[.TYJOB+B]	;ASSIGNED TO A JOB?
	JUMPE	C,MOUNT2	;NO--USE THIS ONE
	ADDI	A,10000		;YES-TRY NEXT ONE
	JRST	MOUN12

;HERE IF DVVNAM IS SPECIFIC (LOGICAL OR PHYSICAL)

MOUN15:	MOVE	A,DVVNAM	;HET PHYS. NAME
IFN LOGSW, <
	SKIPN	LOGNAM		;TEST FOR LOGICAL NAME SPECIFIED
	MOVEM	A,LOGNAM	;  NO, MAKE THIS A LOGICAL NAME
>;	END OF	IFN LOGSW
	DEVNAM	A,
	  JSP	N,NEVERR
	SKIPN	A
	JSP	N,NEVERR	;??DEVCHR WORKED??
	MOVEM	A,PHYNAM
MOUN16:	MOVE	B,A
	DEVTYP	B,PHONLY	;GET DEVTYP BITS
	  JSP	N,NEVERR
	TLNE	B,.TYAVL	;AVAILABLE?
	JRST	MOUNT2		;YES
	JRST	MONAV
;HERE IF POSSIBLE TO DO IT OURSELF
;   A=PHYS.NAME  B=DEVTYP BITS FOR IT

IFE SPONUL, <
MOUNT2:	LDB	B,[.TYJOB+B]	;ASSIGNED TO THIS JOB?
	CAMN	B,JOBNO
	TRO	F,R.ASCO	;YES-REMEMBER THE FACT
>;	END OF	IFE SPONUL
IFN SPONUL, <
MOUNT2:	LDB	C,[.TYJOB+B]	;GET CURRENT OWNER'S JOB #
	CAMN	C,JOBNO		;TEST FOR [SELF]
	TRO	F,R.ASCO	;  YES, REMEMBER THAT
	MOVS	C,A		;GET SWAPPED PHYSICAL DEVICE NAME
	CAIE	C,'NUL'		;TEST FOR DEVICE NUL:
	TLNE	B,.TYSPL	;TEST FOR SPOOLED DEVICE
	JRST	MOUNT3		;  EITHER, GO MOUNT IT OURSELVES
>;	END OF	IFN SPONUL
IFN VIDSW, <
	MOVE	B,DEVMOD	;GET DEVCHR BITS
	TLNE	B,DC.OUT	;TEST FOR DEVICE CAPABLE OF OUTPUT
	TLNE	B,DC.DTA	;TEST FOR DTA (TAPE DRIVE)
	TLNE	F,L.VID		;TEST FOR VID GIVEN
	JRST	MOUNT4		;  JUMP IF (A) /VID SPECIFIED, OR
				;   (B) THE DVC CAN DO OUTPUT AND
				;   IS NOT DECTAPE
	MOVEI	M,[ASCIZ \? Requires /VID switch\] ;POINT AT MSG
	JRST	ERREXI		; & GO EXIT
MOUNT4:				;HERE IF /VID GIVEN OR NOT REQUIRED
>;	END OF	IFN VIDSW
	MOVE	C,STATES	;TEST FOR OPERATOR CONSTRAINTS
	TRNE	C,STAOMO	;TEST FOR OPR WANTS TO SEE ALL
	TLNE	F,L.VID!L.WRTL!L.WEN!L.RID ;TEST FOR OPR REQ'D
	SKIPA			;  SKIP IF OPR WANTS ALL OR OPR REQ'D
	JRST	MOUNT3		;  ELSE GO DO IT OURSELVES
	TRNN	C,STAOPR	;TEST FOR OPR ON DUTY
	JRST	MOOP		;  YES, SEND IT TO HIM
	TLNN	F,L.VID!L.WRTL!L.WEN!L.RID ;TEST FOR OPR-REQD DATA GIVEN
	JRST	MOUNT3		     ;  NO, THEN DO IT OURSELVES
	PUSHJ	P,ERR911	;GO CHECK SHOVE
	JRST	MOOP		;IF SHOVE, GO ON

;HERE TO DO IT OURSELF A=PHYS.NAME

MOUNT3:				;HERE TO DO THE 'MOUNT' OURSELVES
IFN LOGSW, <
	MOVEM	A,PHYNAM	;REMEMBER THE PHYSICAL NAME
	SKIPE	LOGNAM		;TEST FOR LOGICAL NAME GIVEN
	PUSHJ	P,CKLOG		;  YES, CHECK FOR DUPLICATE
	  SETZM	LOGNAM		;CLEAR LOGICAL NAME IF ERROR RETURN
	MOVE	A,PHYNAM	;RESTORE PHYSICAL NAME
>;	END OF	IFN LOGSW

	PUSHJ	P,ASLOG		;OPEN ON US1 AND ASSIG.LOG.NAME IF NECESSARY
	  JRST	MOUNT1		;TRY AGAIN INCASE SOMEONE JUST ASSIGNED IT
IFL RIDSW, <
	PUSHJ	P,CKRID		;GO CHECK FOR /REELID IF MTA
>;	END OF	IFL RIDSW
	MOVEI	A,US1		;IF WE DO NOT GO TO OMOUNT, SET REELID
	MOVE	B,REELID
	TLNE	F,L.RID		;OF COURSE, DON'T BOTHER IF NONE
	MTAID.	A,
	 JFCL
	TRNE	F,R.ASCO	;ALREADY ASSIGNED?
	JRST	MOOK	;YES
	MOVEI	B,US1		;NO-TRY TO ASSIGN DEVICE (REASSIGN TO MYSELF)
	MOVE	A,JOBNO
	REASSI	A,
	SKIPE	A		;SUCCESS?
	JUMPN	B,MOOK		;YES
	MOVE	B,DVVNAM	;NO-TELL USER
	PUSHJ	P,MSG104
	RELEAS	US1,
;HERE TO SEE HOW IT ALL CAME OUT

MOCK:	SKIPN	B,LOGNAM	;LOGICAL NAME?
	MOVE	B,DVVNAM	;NO--USE DVVNAM
IFN LOGSW, <
	DEVNAM	B,		;GET PHYSICAL DEVICE NAME
	  JRST	ERR912		;  FAILED, TELL USER OF MOUNT FAILURE
>;	END OF	IFN LOGSW
	PUSHJ	P,MOPEN
	  JRST	ERR912		;CANT--TELL LOOSER USER

;HERE IF SUCCESSFUL  WITH DEVICE OPENED ON US1

IFE SPONUL, <
MOOK:	MOVEI	A,US1		;CK THAT OPENED DEV. IS ASSIGNED TO ME
	DEVCHR	A,
	TRNN	A,400000	;  ASSIGNED?
	JRST	ERR912
	MOVEI	A,US1
	DEVTYP	A,
	  JRST	ERR912
	LDB	A,[.TYJOB+A]	;  TO ME?
	CAME	A,JOBNO
	JRST	ERR912
>;	END OF	IFE SPONUL
IFN SPONUL, <
MOOK:	MOVEI	A,US1		;GET CHANNEL NUMBER
	DEVTYP	A,		;FIND OUT ABOUT THE DEVICE
	  JRST	ERR912		;  ERROR, GIVE 'MOUNT INCOMPLETE' MSG
	MOVEM	A,DVVTYP	;STORE DEVTYP BITS
	TLNE	A,.TYSPL	;TEST FOR SPOOLED
	JRST	MOOK1		;  YES, JUMP
	MOVEI	B,US1		;GET CHANNEL # AGAIN
	DEVCHR	B,		;GET DEVICE CHAR
	TRNN	B,DC.ASC	;TEST FOR ASSIGNED
	JRST	ERR912		;  NO, GIVE 'MOUNT INCOMPLETE' MSG
	LDB	C,[.TYJOB+A]	;GET OWNER'S JOB #
	CAME	C,JOBNO		;TEST FOR [SELF]
	JRST	ERR912		;  ERROR IF NOT ASSIGNED
MOOK1:				;HERE IF I OWN THE DEVICE
>;	END OF IFN SPONUL
IFN FTFACT, <
	SKIPE	IDIDIT		;IF OMOUNT USED, NO NEED TO WORRY HERE
	 JRST	MOOK1A
IFN SPONUL, <
	MOVE	A,DVVTYP	;GET DEVTYP BITS
	TLNE	A,.TYSPL	;TEST FOR SPOOLED DEVICE
	JRST	MOOK1A		;  YES, JUMP
>;	END OF	IFN SPONUL
	MOVEI	A,US1		;GET CHANNEL #
	DEVNAM	A,		;GET DEVICE ASSOC WITH CHANNEL
	  MOVSI	A,'???'		;  FAILED, SHOW STRANGE
IFN SPONUL, <
	MOVS	C,A		;GET SWAPPED PHYSICAL DEVICE NAME
	CAIN	C,'NUL'		;TEST FOR DEVICE NUL:
	JRST	MOOK1A		;  YES, JUMP
>;	END OF	IFN SPONUL
	HRLI	NUM,'UM '	;GET CODE FOR USER MOUNT
	PUSHJ	P,WRFACT	;CALL TO WRITE ACCT'G RECORD
MOOK1A:				;HERE NOT TO WRITE ACCT'G
>;	END OF	IFN FTFACT
IFE LOGSW, <
	SKIPN	M,LOGNAM	;LOGICAL NAME?
	MOVE	M,DVVNAM	;NO-USE DVVNAME
	PUSHJ	P,SIXTTY
	SKIPN	LOGNAM		;IF WAS LOGICAL NAME
	JRST	MOOK1
	PUSHJ	P,LPAR		;TYPE PHYS.NAME IN PARENS
	MOVEI	M,US1
	DEVNAM	M,
	  SETZM	M
	PUSHJ	P,SIXTTY
	PUSHJ	P,RPAR

MOOK2:	XTYPE	< Mounted
>;	;THATS ALL
>;	END OF	IFE LOGSW
IFN LOGSW, <
	MOVEI	A,US1		;GET CHANNEL # AGAIN
	SETZ	B,		;GET NULL LOGICAL NAME
	SKIPGE	GENLOG		;TEST FOR GENERATED LOGICAL NAME
	DEVLNM	A,		;  YES, ERASE IT NOW
	  JFCL			;       ( & IGNORE ERRORS)
	SKIPN	GENLOG		;TEST FOR GENERATED LOGICAL NAME
	SKIPN	M,LOGNAM	;GET USER-SPEEC LOG NAME & SKIP
	HLLZ	M,DVVNAM	; NO USER-SPEC L.N., USE GENERIC PHYSICAL
	PUSHJ	P,SIXTTY	;TYPE THE DEVICE NAME
	TYPE	< mounted, >;	;TYPE 'MOUNTED'
IFN SPONUL, <
	MOVE	A,DVVTYP	;GET DEVTYP BITS
	MOVEI	M,[ASCIZ /Spooled /] ;ASSUME SPOOLED
	TLNE	A,.TYSPL	;TEST FOR SPOOLED
	PUSHJ	P,MSGTTY	;  YES, TELL THE USER
>;	END OF	IFN SPONUL
	MOVEI	M,US1		;GET CHANNEL # AGAIN
	DEVNAM	M,		;FIND OUT PHYSICAL DEVICE NAME
	  MOVSI	M,'???'		;  FAILED, TELL THE USER THAT
	PUSHJ	P,SIXTTY	;TYPE THE DEVICE NAME
	XTYPE	< used
>;				;FINISH THE MSG & EXIT
>;	END OF	IFN LOGSW
;HERE IF DEVICE NOT AVAILABLE

MONAV:	MOVE	C,STATES	;GET STATES WORD
	TRNN	C,STAOPR	;TEST FOR OPR PRESENT
	JRST	MOOP		;  YES, GO LET HIM DECIDE
	MOVE	M,DVVNAM	;GET DEVICE NAME
	PUSHJ	P,MSG100	;TELL THE USER NOT AVAILABLE
	PUSHJ	P,ERR911		;& TELL HIM WE FAILED, CHECK SHOVE

;HERE IF NEED OPERATORS HELP (OMOUNT)

IFE LOGSW, <
MOOP:	SKIPN	A,LOGNAM	;LOGICAL NAME?
	JRST	MOOP1		;NO
	DEVTYP	A,		;YES-ALREADY USED?
	  JRST	MOOP0
	LDB	A,[.TYJOB+A]
	CAME	A,JOBNO
	JRST	MOOP1		;NO
	PUSHJ	P,MSG101	;YES-TELL USER
MOOP0:	SETZM	LOGNAM		;    AND IGNORE IT
>;	END OF	IFE LOGSW
IFN LOGSW, <
MOOP:	SKIPE	LOGNAM		;TEST FOR LOGICAL NAME
	PUSHJ	P,CKLOG		;  YES, CHECK FOR DUPLICATE
	  PUSHJ	P,NAMGEN	;GENERATE A LOGICAL NAME IF ZERO OR DUPL.
>;	END OF	IFN LOGSW

MOOP1:	TRNN	F,R.ASCO	;ALREADY ASSIGNED?
	JRST	MOOP2		;NO
	MOVE	A,PHYNAM	;YES-ASSIGN LOG.NAME IF ANY
	PUSHJ	P,ASLOG
	  PUSHJ	P,MSG900
;[101] MOOP1 4 1/2
IFL	RIDSW,<
	PUSHJ	P,CKRID		;CHECK REELID
>;	END IFL RIDSW
	MOVEI	A,US1		;GIVE DEVICE A REELID
	MOVE	B,REELID
	TLNE	F,L.RID		;IF SPECIFIED
	MTAID.	A,
	 JFCL
	RELEAS	US1,

MOOP2:				;HERE TO QUEUE MOUNT RQST FOR THE OPR
	PUSHJ	P,MOQU		;QUEUE REQUEST TO OPERATOR
	JRST	MOCK		;GO SEE WHAT HAPPENED


;SUBROUTINE TO QUEUE REQUEST TO OMOUNT AND WAIT FOR IT

MOQU:	PUSHJ	P,QUEREQ
	PUSHJ	P,MSG110	;TELL USER OPERATOR NOTIFIED
	PJRST	TMWAIT		;RETURN WHEN PROCESSED


;SUBROUTINE TO ASSIGN LOGICAL NAME TO DEVICE
;CALL	A=NAME
;RET+1	CANT OPEN DEVICE
;RET+2	OPENED SUCCESSFULY-MAY OR MAYNOT HAVE ASSIGNED LOG.NAME

ASLOG:	MOVE	B,A	;OPEN ON US1
	PUSHJ	P,MOPEN
	  POPJ	P,	;CANT

IFN LOGSW, <
ASLOG1:				;HERE TO ATTEMPT LOGICAL NAME ASSIGNMENT
>;	END OF	IFN LOGSW
	SKIPN	B,LOGNAM	;IS THER A LOG.NAME?
	JRST	CPOPJ1		;NO-RETURN
	MOVEI	A,US1		;YES-ASSIGN LOG.NAME
	DEVLNM	A,
	  AOSA	A
	JRST	CPOPJ1		;SUCCESSS
	AOJN	A,ASLOG2	;FAILURE--WHAT?
IFE LOGSW, <
	PUSHJ	P,MSG101	;  NAME IN USE
	SKIPA
ASLO2:	PUSHJ	P,MSG900	;  ?SOMETHING ELSE
>;	END OF	IFE LOGSW
IFN LOGSW, <
;[103] ASLOG + 6 1/2
	MOVEI	A,US1		;GET PHYNAM OF DEVICE
	DEVNAM	A,
	JRST	ASLOG3
	MOVE	B,LOGNAM	;GET IT FOR LOGICAL NAME
	DEVNAM	B,
	JRST	ASLOG1
	CAMN	A,B		;IF THEY ARE THE SAME, GOOD
	JRST	CPOPJ1		;SUCCESS RETURN
ASLOG3:	SKIPN	GENLOG		;TEST FOR GENERATED LOGICAL NAME
	PUSHJ	P,MSG101	;  NO, TELL THE USER OF HIS ERROR
	PUSHJ	P,NAMGEN	;GENERATE A NEW LOGICAL NAME
	JRST	ASLOG1		; & TRY AGAIN
>;	END OF	IFN LOGSW
ASLOG2:	SETZM	LOGNAM		;IGNORE LOGNAME
	JRST	CPOPJ1

	
IFN LOGSW, <

;
;	SUBROUTINE TO GENERATE A LOGICAL NAME FOR A MOUNT COMMAND
;
;	THE PHYSICAL NAME (IF NOT GENERIC) IS TRIED AS THE LOGICAL.
;	IF THAT CANNOT BE USED, THEN A RANDOM NAME OF THE FORM
;	'MNNNNN' IS GENERATED, WHERE 'NNNNN' REPRESENTS A FIVE-DIGIT
;	NUMBER CREATED FROM THE UPTIME.
;

NAMGEN:	PUSH	P,A		;SAVE REGISTERS
	PUSH	P,B		;  DITTO
	PUSH	P,C		;  DITTO
	PUSH	P,D		;  DITTO
	SKIPN	GENLOG		;TEST FOR PREVIOUS ATTEMPT
	JRST	NAMPHY		;  NO, GO TRY PHYSICAL NAME
NAMNXT:	MOVE	A,[15,,12]	;GET GETTAB PARMS FOR UPTIME
	GETTAB	A,		;GET UPTIME FROM SYSTEM
	  TIMER	A,		;  FAILED, GET TIME-OF-DAY
	MOVE	C,[POINT 6,D,5]	;POINT AT 1ST CHAR OF AC 'D'
	MOVSI	D,'M  '		; & DEFINE 1ST CHAR AS 'M'
NAMLOP:	IDIVI	A,^D10		;GET LOW-ORDER DIGIT OF UPTIME
	ADDI	B,'0'		;CONVERT IT TO SIXBIT
	IDPB	B,C		;STORE INTO RESULT
	TLNE	C,770000	;TEST FOR 6TH CHAR YET
	JRST	NAMLOP		;  NO, REPEAT
	CAMN	D,LOGNAM	;TEST FOR SAME NAME AS PREVIOUS
	JRST	NAMSLP		;  YES, GO DELAY & REPEAT
	MOVEM	D,LOGNAM	;REMEMBER THE NAME
	SETOM	GENLOG		;SHOW LOGICAL NAME GENERATED
NAMXIT:	PUSHJ	P,CKLOG		;CHECK FOR DUPLICATE LOGICAL NAME
	  JRST	NAMNXT		;  YES, GO GENERATE ANOTHER ONE
	POP	P,D		;RESTORE REGISTERS
	POP	P,C		;  DITTO
	POP	P,B		;  DITTO
	PJRST	APOPJ		;RESTORE 'A' & RETURN TO CALLER
;  HERE TO SLEEP 'TIL NEXT CLOCK TICK
NAMSLP:	SETZ	A,		;REQUEST MINIMUM TIME DELAY
	SLEEP	A,		;SLEEP THAT LONG
	JRST	NAMNXT		;GO GENERATE A NEW LOGICAL NAME
;  HERE TO SEE IF PHYSICAL NAME CAN BE LOGICAL AS WELL
NAMPHY:	MOVE	A,PHYNAM	;[102] GET DEVICE NAME - MUST BE PHYSICAL BECAUSE 
				; OF CODE AT 'MOUN15'
	TRNE	A,-1		;TEST FOR GENERIC NAME
	SKIPE	LOGNAM		;TEST FOR PREVIOUS LOGICAL NAME
	JRST	NAMNXT		; GO GENERATE IF GENERIC OR PREV. LOGICAL
	MOVEM	A,LOGNAM	;STORE PHYSICAL NAME AS LOGICAL
	AOS	GENLOG		;SET FLAG +1 TO SHOW PHYSICAL NAME USED
	JRST	NAMXIT		;GO CHECK FOR DUPL & RETURN


;
;	SUBROUTINE TO CHECK FOR DUPLICATE LOGICAL NAMES
;
;	ASSUMES LOGNAM & PHYNAM SET UP
;
;	RETURN +0 IF LOGNAM DUPLICATED FOR THIS JOB
;	       +1 IF LOGNAM UNIQUE FOR THIS JOB
;

CKLOG:	MOVEI	NUM,(SIXBIT .M.);GET CODE FOR MOUNT RQST
	PUSHJ	P,CMGETI	;INITIALIZE THE QUEUE UFD
CKLOG1:	PUSHJ	P,CMGET		;GET NEXT MOUNT CMD FOR THIS JOB
	  JRST	CKLOG2		;  NO MORE, JUMP
	MOVEI	N,7		;GET COUNTER TO SKIP 7 FIELDS
	PUSHJ	P,SKPFLD	;CALL TO SKIP 7 FIELDS
	  JRST	CKLOG1		;  EOF, GET NEXT CMD
	PUSHJ	P,SSIXBR	;READ 8TH FFIELD (LOGICAL NAME)
	JUMPE	A,CKLOG1	;  NOT THERE, GET NEXT CMD FILE
	CAME	A,LOGNAM	;TEST FOR SAME NAME
	JRST	CKLOG1		;  NO, GET NEXT CMD FILE
	CLOSE	CMD,		;CLOSE THE CMD FILE
	JRST	CKLOG5		;GO DELETE THE LOGICAL NAME
CKLOG2:	MOVE	A,LOGNAM	;GET THE LOGICAL NAME
	DEVCHR	A,		;FIND OUT IF DEVICE EXISTS
	JUMPE	A,CPOPJ1	;  NO, RETURN+1 (A WINNER)
	MOVE	A,LOGNAM	;GET THE LOGICAL NAME AGAIN
	DEVTYP	A,		;FIND OUT OWNING JOB #
	  JRST	CKLOG3		;  UUO NOT IMPL., SKIP THIS TEST
	TLNE	A,.TYSPL	;TEST FOR SPOOLED
	JRST	CKLOG3		;  YES, SKIP NEXT TEST
	LDB	A,[.TYJOB+A]	;GET OWNER'S JOB #
	CAME	A,JOBNO		;TEST FOR [SELF]
	JRST	CPOPJ1		;  NO, RETURN +1 (A WINNER)
CKLOG3:	SKIPGE	GENLOG		;TEST FOR GENERATED LOGICAL NAME
	POPJ	P,		;  YES, RETURN+0 TO THROW IT AWAY
	MOVE	A,LOGNAM	;LOG. NAME
	DEVNAM	A,
	 JRST	CPOPJ1		;OK
	CAMN	A,PHYNAM	;IS THE LOGICAL NAME SAME AS PHYS.
	 JRST	CPOPJ1		;YES, OK
	MOVE	A,LOGNAM	;GET CURRENT DEVICE NAME
	SETZ	B,		;GET NULL NEW LOGICAL NAME FOR DUPL DVC
	DEVLNM	A,		;CLEAR ORIG DVC WITH OUR LOGICAL NAME
	  AOJA	A,CKLOG4	;  ERROR, ADD 1 TO ERROR CODE & JUMP
	TYPE	<% Specified Logical Name was in use
>;				;TELL THE USER WHAT WE DID
	JRST	CPOPJ1		;RETURN SUCCESSFULLY
CKLOG4:	JUMPE	A,CPOPJ1	;RETURN+1 IF 0 (-1 RET'D), NO SUCH DEVICE
CKLOG5:	SKIPN	GENLOG		;TEST FOR GENERATED LOGICAL NAME
	PUSHJ	P,MSG101	;  NO, TELL THE USER OF HIS ERROR
	POPJ	P,		;TAKE ERROR RETURN TO CALLER
>;	END OF	IFN LOGSW
;SUBROUTINE TO OPEN DEVICE ON US1
;CALL	B=DEVICE NAME
;	DSKCHR BITS IN DEVMOD
;RET+1	ERROR (MSG TYPED) OR NO SUCH DEVICE
;RET+2	OK
;USES	A,B,C,D

MOPEN:	HRLZ	C,DEVMOD	;GET READY FOR JFFO
	TLZ	C,DC.ASC!DC.ASP	;LEAVE ONLY MODE BITS IN LH.
	JFFO	C,MOPEN1	;CONVERT BIT POSIT. TO NUMBER
	PJSP	N,NEVMSG	;SHOULDNT HAPPEN
MOPEN1:	MOVEI	A,^D17
	SUB	A,C+1
IFN LOGSW, <
	TLO	A,(PHOPEN)	;REQUEST PHYSICAL-ONLY OPEN
>;	END OF	IFN LOGSW
	SETZM	C		;NO OPEN
IFN LOGSW, <
	OPEN	US1,A		;ATTEMPT AN OPEN
	  TLZA	A,(PHOPEN)		;  FAILED, CLEAR PHYSICAL-ONLY & SKIP
	JRST	CPOPJ1		;  SUCCEEDED, RETURN +1
>;	END OF	IFN LOGSW
	OPEN	US1,A
	  POPJ	P,		;CANT DO
	JRST	CPOPJ1		;GOOD RETURN

IFN RIDSW, <
;ROUTINE TO CHECK FOR A REELID AND ISSUE APPROPRIATE MESSAGE

CKRID:	MOVE	A,DEVMOD	;GET DEVCHR BITS
	TLNE	A,DC.MTA	;TEST FOR A MAGTAPE
	JRST	CKRID1		;  YES, JUMP
	TLZ	F,L.RID		;  NO, CLEAR /REELID BITS
	POPJ	P,		;RETURN TO CALLER
CKRID1:	TLNE	F,L.RID		;TEST FOR /REELID
	POPJ	P,		;  YES, RETURN TO CALLER
	MOVE	A,[%CNVER]	;GET GETTAB PARMS FOR MONTIRO VERSION
	GETTAB	A,		;GET THE MONITOR VERSION
	  POPJ	P,		;  PRE-5.03, RETURN
	TLZ	A,-1		;CLEAR L.H.
	CAIGE	A,50700		;TEST FOR 5.07 & LATER
	POPJ	P,		;  NO, RETURN
	MOVEI	M,[ASCIZ \?Requires /REELID switch\] ;POINT AT MSG
	JRST	ERREXI		; & GIVE THE ERROR
>;	END OF	IFN RIDSW
	;USER HALF OF MOUNT CUSP STARTS HERE

MOFS:				;HERE: A KNOWN F/S
MOFS2:				;HERE: DEVCHR FAILED-?? UNMOUNTED F/S??
IFN JACTSW,<	;DONT WANT THIS FOR SOME DEBUGGING
	TRNE	F,R.NJAC	;MUST BE PRIVILEGED
	JRST	ERR103
>
	TLNN	F,L.WRTL!L.WEN	;TEST FOR WRITE-STATUS GIVEN
IFN WLFS, <
	TLO	F,L.WRTL	;NO, SET WRITE-LOCK
>;	END IFN WLFS
IFN WEFS,<
	TLO	F,L.WEN		;NO, SET WRITE-ENABLE
>;	END OF	IFN WLSW
	MOVE	A,CMDFSN	;COMMAND'S FS NAME
	DEVNAM	A,		;GET PHYSISCAL NAME
	  MOVE	A,CMDFSN	;
	CAMN	A,[SIXBIT /DSK/];USE ORIGINAL FS NAME IF "DSK"
	MOVE	A,CMDFSN	;  WAS RETURNED
	MOVEM	A,FSNAME	;
	SETZM	UDREQ		;CLEAR USER UNIT REQUESTS FLAG
	SETZM	USRDRV
	MOVE	A,[XWD USRDRV,USRDRV+1]
	BLT	A,USRDRV+8*MAXKON-1	;CLEAR USER DRIVE REQUEST TABLE
	PUSHJ	P,UMSPRC	;SWITCHES AGAIN
	TLNE	F,L.EOL		;IF END OF LINE
	JRST	UMOUN5		;   START PROCESSING

	CAIE	CH,"("		;SKIP IF BEGINNING OF LIST OF UNITS
	JRST	COMERR		;DONT UNDERSTAND
	SETOM	UDREQ		;SET FLAG NOTING USER UNIT REQUESTS
	SETZM	D		;INDEX UNIT TABLES WITH D
UMOUN3:	PUSHJ	P,SSIXBR	;READ A UNIT NAME
	CAIGE	D,MAXKON*8	;DONT STORE IF REACHED MAX. NUM.
	MOVEM	A,USRDRV(D)
	PUSHJ	P,SST		;COMMA?
	CAIN	CH,","
	AOJA	D,UMOUN3	;YES-GET ANOTHER UNIT
	CAIE	CH,")"		;NO--BETTER BE )
	JRST	COMERR
	AOS	D
	MOVEM	D,NUMREQ	;REMEMBER NUM. OF UNITS TYPED
	MOVEI	CH," "		;SO UMSPRC WONT HANG ON ")
	PUSHJ	P,UMSPRC	;CK FOR SWITCHES A LAST TIME
	JRST	UMOUN5		;GO START ACTUAL PROCESSING


UMSPRC:	PUSHJ	P,SST		;SKIP SPACE TABS
	CAIE	CH,"/"		;PRECEEDING / ?
	POPJ	P,		;NO--NOT A SWITCH
	MOVE	E,[XWD -UMSLEN,UMSLST]
	PUSHJ	P,UDSWIT
	JRST	UMSPRC		;LOOP FOR MULTIPLE SWITCHES

;
;		MOUNT DISPATCH TABLE AND ROUTINES
;
	DEFINE	SWTAB(A),<
	IRP A,<XWD SIXBIT \   A\,UMS'A
>>

UMSREE==RIDIN
UMSVID==VIDIN

	SWERR2
	SWERR
UMSLST:	SWTAB <HEL,WEN,WLO,RON,MUL,SIN,C,CHE,PAU,VID,REE,WRI,ACT,PAS,W,WAI,NOW,NOC,CRE,SHO,NOS>
UMSLEN==.-UMSLST	;LENGTH OF TABLE OF MOUNT SWITCHES

UMSHEL:	MOVE	A,[SIXBIT /MOUNT/] ;GET NAME OF HELP FILE
	JRST	GOHELP		;GO TYPE IT

UMSNO:				;/WRITE:NO
UMSRON:
UMSWLO:	TLZ	F,L.WEN
	TLOA	F,L.WRTL
UMSSIN:	TLO	F,L.SIN
	POPJ	P,

UMSMUL:	TLZ	F,L.SIN		;CLEAR SINGLE IN CASE/SINGLE/MULTI TYPED
	POPJ	P,

UMSC:				;/C MEANS /CHECK
UMSCHE:	MOVEI	NUM,(SIXBIT .M.)
	MOVE	A,NAMMNT
	JRST	CCOMSB

UMSYES:				;/WRITE:YES
UMSWEN:	TLZ	F,L.WRTL
	TLOA	F,L.WEN
UMSPAU:	TLO	F,L.PWA
	POPJ	P,

UMSWRI:	CAIE	CH,":"		;TEST FOR NO ARGUMENT
	JRST	UMSWR1		;  YES,ERROR
	MOVE	E,[XWD -WRILEN,WRILST] ;POINT AT LEGAL KEYWORD LIST
	PJRST	UDSWIT		; & GO DECODE THE KEYWORD
UMSWR1:	MOVEI	M,[ASCIZ \? Incorrect value for /WRITE switch: \]
	JRST	SWERR3		;TYPE THE ERROR MESSAGE

	UMSWR1			;ADDR OF 'NON-UNIQUE' ERROR
	UMSWR1			;ADDR OF 'NON-EXISTANT' ERROR
				;/WRITE KEYWORD TABLE
WRILST:	SWTAB	<YES,NO>
WRILEN==.-WRILST		;LENGTH OF THE TABLE

UMSPAS:	TROA	F,R.PAS		;SET SWITCH IF /PASSIVE
UMSACT:	TRZ	F,R.PAS		;CLEAR SWITCH IF /ACTIVE
	POPJ	P,		;RETURN

DMSWAI:	SKIPA	NUM,[SIXBIT .   D.] ;GET KEY-LETTER FOR DISMOUNT
UMSW:				;/W SWITCH
UMSWAI:	MOVEI	NUM,(SIXBIT .M.);GET KEY-LETTER FOR 'MOUNT'
	TRNE	F,R.NOWA	;DON'T ALLOW /WAIT AND /NOWAIT
	 JRST	COMERR		; IT'S WORTH A '?SYNTAX ERROR'
	SKIPE	NOTLOG		;TEST FOR LOGGED IN
	JRST	LOGERR		;  NO, GIVE AN ERROR
	TRO	F,R.WAIT	;SET IN CASE USER SPECIFIED A DEV:
	SKIPE	CMDFSN		;WAIT NOT ALLOWED WITH OTHER STUFF
	 POPJ	P,		; USER WANTS TO ISSUE REQUEST W/ /WAIT
	PUSHJ	P,CKEOL		;/WAIT MUST BE ALONE IF NO DEV:
	MOVE	A,NAMMNT	;GET NAME OF SERVICING PROGRAM
	JRST	WCOM1		;GO WAIT...


DMSNOW:				;LET DISMOUNT IN ON THE FUN
UMSNOW:	TRNE	F,R.WAIT	;DON'T ALLOW /WAIT AND /NOWAIT
	 JRST	COMERR		; IT'S WORTH A '?SYNTAX ERROR'
	TRO	F,R.NOWA	;SET /NOWAIT FLAG FOR OPREQ2
	POPJ	P,

UMSCRE:	TRZA	F,R.NOC		;CLEAR SWITCH FOR /CREATE
UMSNOC:	TRO	F,R.NOC		;SET SWITCH FOR /NOCREATE
	PJRST	UMSACT		;EITHER SWITCH IMPLIES /ACTIVE, GO SET IT

UMSSHO:	TROA	F,R.SHOV	;GET SET TO SHOVE IT
UMSNOS:	TRZ	F,R.SHOV
	POPJ	P,
;  NON-IMPLEMENTED SWITCHES
SWERR:	MOVEI	M,SWERM1	;'NON-EXISTANT SWITCH'
	JRST	SWERR3
SWERR2:	MOVEI	M,SWERM2	;'NON-UNIQUE SWITCH'
SWERR3:	PUSHJ	P,MSGTTY
	MOVE	M,A		;M=SWITCH TYPED
	PUSHJ	P,SIXMSG	;TYPE IT
	JRST	MONRET		;THATS ALL


UMOUN5:				;HERE TO PROCESS A F/S MOUNT REQUEST
	PUSHJ	P,CKEOL		;CALL TO CHECK FOR PROPER END OF LINE
	MOVE	A,[XWD CHRLEN,CHRBUF] ;DO A DSKCHR
	MOVE	B,FSNAME
	MOVEM	B,CHRBUF
	DSKCHR	A,
	  JRST	STRSRC		;NOT MOUNTED--CK STRLST.SYS
	LDB	B,D.ARGT	;SINGLE F.S.?
	CAIE	B,A.FS
	JRST	ILFERR		;NO
	TLNN	A,D.SIN		;IF ALREADY MOUNTED
	TLNE	F,L.SIN		;   AND NO SINGLE-ACCESS CONSIDERATIONS:
	JRST	STRSRC
	SETZ	NUM,		;CLEAR NUM, NORMALLY SETUP VIA STRSRC
	JRST	UMNT0		;   SKIP STRLST.SYS LOOKUP
SUBTTL	MOUNT COMMAND - FILE STRUCTURE PROCESSING
;HERE WHEN COMMAND HAS BEEN SCANNED - FIND FILE STRUCTURE IN STRLST.SYS

STRSRC:	MOVE	A,[PHOPEN!14]	;SET PHYS-ONLY & MODE
	MOVE	B,[STLSTX]	;SET STR NAME
	MOVEI	C,RH.USR	;SET BUFFER HEADER
	OPEN	USR,A		;OPEN THE STR
	  JRST	ERR26		;IF SYS DOES NOT EXIST, WE'RE IN TROUBLE
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;SET UP 1 BUFFER
	MOVE	A,[SIXBIT .STRLST.]
	MOVSI	B,(SIXBIT .SYS.)
	SETZ	C,
	MOVE	D,[STLPPX]
	LOOKUP	USR,A
	  JRST	ERR1		;STRLST HAS A PROBLEM
	PUSHJ	P,R.USR		;READ FORMAT VERSION NUMBER
	  JRST	ERR2
	HLRZS	A		;LH=NUMBER
	CAIE	A,STRFOR
	JRST	ERR27
STR1:	PUSHJ	P,R.USR		;GET NEXT WORD IN A
	  JRST	ERR2A		;HERE IF INPUT ERROR (PROBABLY EOF)
	JUMPE	A,STR1		;IGNORE 0 LENGTH BLOCKS
	MOVEI	B,-1(A)		;B=NUMBER OF WORDS THAT FOLLOW
	PUSHJ	P,R.USR		;READ FILE STRUCTURE NAME
	  JRST	ERR17		;YOU GOT SOMETHING AGAINST READING?
	CAMN	A,FSNAME	;SEE IF THIS IS THE RIGHT ENTRY
	JRST	HAVSTR		;YES!
	PUSHJ	P,SKPSTR	;SKIP THE REST OF THIS ENTRY
	JRST	STR1

;HERE WHEN HAVE FOUND THE FILE STRUCTURE'S ENTRY IN STRLST.SYS

HAVSTR:	MOVEI	NUM,-3(B)
	LSH	NUM,-1		;NUM=NUMBER OF PACKS IN FILE STRUCTURE
	PUSHJ	P,R.USR		;GET PROJ,PROG OF OWNER
	  JRST	ERR17
	MOVEM	A,OWNPPN
	MOVEI	B,2
	PUSHJ	P,SKPSTR	;SKIP OWNER'S NAME
	PUSHJ	P,R.USR		;READ FIRST PACK ID
	  JRST	ERR17
	MOVEM	A,PACKID	;PUT FIRST PACK IN TABLE
	PUSHJ	P,R.USR
	  JRST	ERR17
	MOVEM	A,PKCLAS	;AND FIRST CLASS WORD

UMNT1A:	MOVNI	D,-1(NUM)
	JUMPGE	D,UMNT1C	;JUMP IF ONLY ONE PACK
	HRLZ	D,D
UMNT1B:	PUSHJ	P,R.USR		;GET NEXT PACK ID
	  JRST	ERR17
	MOVEM	A,PACKID+1(D)	;AND STORE IN TABLE
	PUSHJ	P,R.USR		;AND CLASS, ETC.
	  JRST	ERR17
	MOVEM	A,PKCLAS+1(D)
	AOBJN	D,UMNT1B	;LOOP FOR ALL PACKS
UMNT1C:	RELEASE	USR,		;GET RID OF SYS

	CAML	NUM,NUMREQ	;TELL USER IF TOO MANY DRIVE REQUESTED
	JRST	UMNT1
	MOVEI	IO,W.TTY	;SELECT OUTPUT ROUTINE
	MOVE	M,CMDFSN	;FILE STRUCTURE NAME
	PUSHJ	P,SIXMSG
	MOVEI	M,TMRM1
	PUSHJ	P,MSG
	MOVE	N,NUM		;ACTUAL NUMBER OF DRIVES
	PUSHJ	P,DECPRT
	MOVEI	M,TMRM2
	PUSHJ	P,MSG

;HERE TO CHECK CURRENT STATE OF THE FILE STRUCTURE (MOUNTED OR NOT)

UMNT1:	MOVE	A,[XWD CHRLEN,CHRBUF]
	MOVE	B,FSNAME
	MOVEM	B,CHRBUF
	DSKCHR	A,		;DSKCHR OF FILE STRUCTURE NAME
	  JRST	FNDPAK		;ERROR RETURN - F.S. UNKNOWN
UMNT0:	SKIPLE	B,CHRBUF+CHRSAJ	;GET SINGLE ACCESS JOB
	TLNE	A,D.MC		;IF MC=0 DONT CARE WHAT SINGLE ACCESS JOB WAS
	JRST	UMNT2		;NOT SINGLE ACCESS
	CAME	B,JOBNO		;SEE IF WE HAVE IT
	JRST	ERR29		;NO, CANT GET IT
UMNT2:	TLNE	A,D.LOK		;SKIP IF NOT LOCKED OUT
	JRST	ERR21		;CANT HAVE THE FILE STRUCTURE
	MOVEI	M,IMNTM		;"STRUCTURE ALREADY MOUNTED"
	PUSHJ	P,MSGTTY	;TELL USER STR IS ALREADY MOUNTED
	SKIPGE	N,CHRBUF+CHRSMT	;GET MOUNT COUNT & TEST IT
	SETZ	N,		;  .LT.0, SET IT TO 0
	PUSHJ	P,DECPRT	;TYPE THE CURRENT MOUNT COUNT
	MOVEI	M,IMNTM1	;POINT AT REST OF MSG
	PUSHJ	P,MSGTTY	; & TYPE IT
	HRRZS	B
	TLNE	A,D.MC		;SKIP IF MOUNT COUNT NOT = 0
	JRST	MNTST2		;=0, ONWARD
	TLNE	F,L.SIN		;IF MOUNT COUNT GT 0, OBVIOUSLY WE CANNOT
	CAMN	B,JOBNO		; ALLOW SINGLE ACCESS, BUT OK IF WE HAVE IT
	JRST	MNTST2		;ALLOW SINGLE REQUESTS
	MOVEI	M,NSAM
	PUSHJ	P,MSGTTY	;TELL USER
	TLZ	F,L.SIN		;CANCEL SINGLE-ACCESS REQUEST

;CHECK /S CONDITIONS

MNTST2:	TLNN	F,L.SIN		;REQUESTED SINGLE ACCESS?
	JRST	MNTST3		;NO
	MOVE	A,USRPPN	;IF USER IS
	CAMN	A,FS1PPN	;    1,2
	JRST	MNTST3		;    ITS OK
	HLLZ	A,OWNPPN	;YES-OWNERS PROJ.=-1?
	JUMPL	A,MNTST3	;YES-ITS OK
	HLLZ	B,USRPPN	;NO- =JOB PROJ.?
	CAME	A,B		;YES-OK
	JRST	ERR5		;NO--CANT ALLOW
;HERE WHEN FILE STRUCTURE IS ALREADY MOUNTED - CHECK IF UNITS AS USER REQUESTED

MNTST3:	MOVE	BP,[POINT 6,B]
	MOVE	B,FSNAME
	ILDB	E,BP
	JUMPN	E,.-1		;FIND END OF F.S. NAME AND CLEAR E
	ADD	BP,[XWD 060000,0]	;DECREMENT BYTE POINTER
	MOVEM	BP,TEMBP
	MOVN	D,NUM
	HRLZS	D
CHKUP:	PUSHJ	P,FILDPT	;COMPUTE SIXBIT LOGICAL UNIT IN STR
	MOVE	A,[XWD 1,B]
	DSKCHR	A,		;DSKCHR OF NEXT LOGICAL UNIT
	  JRST	CNTMT		;NOT MOUNTED
	PUSHJ	P,UNISET	;COMPUTE UNIT NAME IN B FROM DSKCHR RETURN
	MOVE	N,A		;N=AC RETURN FROM DSKCHR
	MOVE	A,USRDRV(D)	;A=USER REQUEST
	PUSHJ	P,GETMSK	;GET MASK IN C
	AND	C,B		;C=NUMBER OF CHARS IN NAME THAT USER REQUIRED
	CAMN	C,USRDRV(D)	;SKIP IF ACTUAL UNIT INCOMPATIBLE (MOUNTED ELSEWHERE)
	JRST	CHKUP1		;OK
	MOVEI	IO,W.TTY
	MOVE	M,PACKID(D)	;GET UNIT ID
	PUSHJ	P,SIXMSG	;TYPE IT
	MOVEI	M,ARMM
	PUSHJ	P,MSG
	MOVE	M,B		;UNIT IT'S MOUNTED ON
	PUSHJ	P,SIXMSG	;TYPE THAT
	PUSHJ	P,CRLF
	JRST	CHKUP1
CNTMT:	MOVEI	IO,W.TTY
CNTMT1:	MOVE	M,PACKID(D)
	PUSHJ	P,SIXMSG	;TYPE UNIT ID
	AOBJP	D,CNTMT2	;JUMP IF NO MORE UNITS FROM STRLST
	MOVEI	CH,","
	PUSHJ	P,W.TTY		;AT LEAST ONE MORE, TYPE COMMA
	JRST	CNTMT1
CNTMT2:	MOVEI	M,UNMM
	PUSHJ	P,MSG		;TELL USER THESE UNITS NOT MOUNTED
	JUMPE	E,PAKUP		;JUMP IF ALL MOUNTED UNITS READY
	JRST	RDYREQ		;NO, REQUEST OPR TO READY
CHKUP1:	TLNN	N,D.OFFL	;SKIP IF DRIVE IS OFF-LINE
	JRST	CHKUP2		;OK, GO READ HOME BLOCK, CHECK ID
	ADDI	E,1
	MOVEI	IO,W.TTY
	MOVE	M,B		;B=UNIT NOT READY
	PUSHJ	P,SIXMSG	;TYPE UNIT
	MOVEI	M,NRM
	PUSHJ	P,MSG		;TELL USER NOT READY

CHKUP2:	AOBJN	D,CHKUP		;LOOP FOR ALL UNITS IN STR
	JUMPE	E,PAKUP		;JUMP IF ALL UNITS READY

RDYREQ:				;HERE TO ASK OPR TO READY DRIVES
	MOVE	A,STATES	;GET THE STATES WORD
	TRNE	A,STAOPR	;TEST FOR OPR PRESENT
	PUSHJ	P,ERR911		; NO, THEN CAN'T DO IT, UNLESS SHOVE
	PUSHJ	P,QUEREQ
	MOVEI	M,OPRDY		;REQUEST OMOUNT TO SET UNITS ON-LINE
	PUSHJ	P,OPREQ2
;;;  FALL THRU TO 'PAKUP' TO CREATE A UFD (IF NECESSARY)
;HERE IF ALL UNITS READY - FIRST READ QUOTA.SYS FOR QUOTAS

PAKUP:				;HERE TO CHECK FOR UFD
	MOVE	B,FSNAME	;GET DESIRED FS NAME
	MOVE	A,[XWD 1,B]	;POINT AT F/S NAME
	DSKCHR	A,		;FIND OUT ABOUT F/S
	  JRST	ERR6A		;  ERROR, TELL USER
	LDB	A,D.ARGT	;GET ARGUMENT TYPE
	CAIE	A,A.FS		;TEST FOR F/S
	JRST	ERR6A		;  NO, ERROR
	MOVE	A,USRPPN	;GET QUOTAS FROM QUOTA.SYS 
	MOVE	B,FSNAME
	PUSHJ	P,GETQUO
	  JRST	CANTM	;NO QUOTAS - NO UFD
	JUMPN	C,GETUFD	;FALL THROUGH IF LOGGED IN QUOTA = 0

CANTM:				;HERE WHEN UFD CAN'T BE CREATED
	SETO	D,		;NOTE NO UFD DESIRED

;HERE TO CALL UFDSET TO SET UP UFDS

GETUFD:	MOVE	A,USRPPN	;USER'S PPN
	MOVE	N1,MFDPPN	;MFD PPN
	MOVE	M,FSNAME	;NAME OF STR
	MOVEI	IO,W.TTY
	PUSHJ	P,UFDSET
	  JRST	MONRET		;GIVE UP
	JRST	MNTFIN		;FINISH UP
;HERE TO COMPILE A TABLE OF THE STATUS OF ALL DRIVES IN THE SYSTEM
;DRIVE=DRIVE MNEMONIC
;DRVSTT=0 IF DRIVE NOT AVAILABLE
;      NON-0 IF AVAILABLE, WITH RH=RH OF DSKCHR RETURN


FNDPAK:	SETZB	M,TEMBP
	SETZB	WD,DROFFL	;AND CLEAR THE FIRST IN CASE NOT SO
	MOVEI	IO,W.TTY	;SET IO FOR ERROR MESSAGES
FNDPK1:	SYSPHY	WD,		;RETURNS NEXT PHYSICAL DEVICE IN SYSTEM
	 JRST	ERR10		;THERE'S A PROBLEM HERE (NO SUCH DEVICE)
	JUMPE	WD,USRDR	;0 MEANS END OF DEVICES
	MOVEM	WD,CHRBUF
	MOVEM	WD,DRIVE(M)	;SAVE DRIVE IN CASE IT IS USEABLE
	MOVE	A,[XWD CHRNAM+1,CHRBUF]
	DSKCHR	A,		;FIND OUT WHAT WE HAVE
	  JRST	FNDPK1		;MUST NOT HAVE BEEN A DISK
	LDB	CH,D.ARGT	;GET TYPE OF ARGUMENT
	CAIE	CH,A.PUN	;SKIP IF WE HAVE A PHYSICAL UNIT
	JRST	FNDPK1		;NO
	LDB	CH,D.UST	;IS DRIVE AVAILABLE?
	CAIN	CH,2
	JRST	FNDPK5		;YES
	MOVEI	CH,2		;NO--CK FOR 'DORMANT' F/S
	TLNN	A,D.INFS	;SKIP IF NOT IN FILE STRUCTURE
	TLNE	A,D.MC		;SKIP IF MOUNT COUNT NOT = 0
	DPB	CH,D.UST	;ITS DORMANT SO MAKE IT AVAILABLE
FNDPK5:	MOVEM	A,DRVSTT(M)	;SAVE STATUS OF DRIVE
	AOJA	M,FNDPK1	;ALL DONE WITH THIS UNIT
;HERE TO LOOK FOR THE SPECIAL DRIVES THE USER REQUESTED


USRDR:	MOVN	M,M
	HRLZM	M,NUMDRV	;STORE NUMBER OF DRIVES IN SYSTEM
	SKIPN	NUMREQ		;SKIP IF USER ACTUALLY SPECIFIED SOMETHING
	JRST	ANYDRV		;ELSE FORGET THIS
	MOVNI	D,(NUM)
	HRLZ	C,D
USRDR1:	MOVE	A,USRDRV(C)	;GET NEXT DRIVE USER SPECIFIED
	TRNN	A,-1		;SKIP IF SPECIFIC DRIVE
	JRST	USRDR2		;NO, IGNORE THIS REQUEST
	PUSHJ	P,FNDDRV	;FIND THIS DRIVE IN THE DRIVE TABLE
	  JRST	ERR25		;WOULD YOU BELIEVE, NO SUCH DRIVE
	MOVE	A,DRVSTT(B)
	LDB	E,D.KONT	;E=CONTROLLER TYPE
	LDB	CH,KTPBYT	;CH=CONTROLLER TYPE NEEDED
				;(BYTE POINTER IS MODIFIED BY C)
	CAIN	CH,(E)		;SKIP IF WRONG KONTROLLER TYPE
	JRST	USRD1B		;OK
	MOVEI	M,WKTM
	PUSHJ	P,USPROB
	JRST	USRDR2
USRD1B:	LDB	E,D.UNIT	;E=UNIT TYPE
	LDB	CH,UTPBYT	;GET TYPE OF DRIVE REQUIRED
				;(BYTE POINTER IS MODIFIED BY C)
	CAIN	CH,(E)		;COMPARE WITH THIS DRIVE
	JRST	USRD1A		;OK
	MOVEI	M,WUTM		;WRONG UNIT TYPE
	PUSHJ	P,USPROB
	JRST	USRDR2

USRD1A:	LDB	CH,D.UST	;IS IT AVAILABLE?
	CAIN	CH,2
	 JRST	USRD1C		;UNIT IS AVAILABLE
	MOVEI	M,DNAM
	PUSHJ	P,USPROB
	JRST	USRDR2

USRD1C:	TLZ	A,B.UST		;MAKE IT UNAVAILABLE NOW
	MOVEM	A,DRVSTT(B)
USRDR2:	AOBJN	C,USRDR1
;HERE TO LOOK FOR DRIVES ON SPECIFIC CONTROLLERS THE USER REQUESTED

	HRLZ	C,D		;RESET NUMBER OF DRIVES REQUESTED
USRCON:	SKIPN	A,USRDRV(C)	;SKIP IF SOMETHING TO LOOK AT
	JRST	USRCN5
	TRNE	A,-1		;SKIP IF CONTROLLER ONLY REQUEST
	JRST	USRCN5		;SPECIFIC DRIVE - WE'VE ALREADY SEEN IT
	MOVE	B,[XWD 1,A]	;IS THIS A REAL CONTROLER?
	DSKCHR	B,
	  JRST	USRC1C		;NO
	LDB	N,UTPBYT	;YES-GET TYPE OF UNIT WE NEED
	PUSHJ	P,FNDCON	;LOOK FOR DRIVE ON THIS CONTROLLER
	  JRST	.+2		;NONE AT ALL?
	JRST	USRC1A		;OK
	MOVEI	M,KDNAM
	PUSHJ	P,USPROB
	JRST	USRCN5
USRC1A:	LDB	N1,D.KONT	;KONTROLLER TYPE
	LDB	N,KTPBYT	;TYPE NEEDED
	CAMN	N,N1		;SKIP IF WRONG KONTROLLER TYPE
	JRST	USRC1B		;OK
	MOVEI	M,WKTM
	PUSHJ	P,USPROB
	JRST	USRCN5
USRC1C:	MOVEI	M,IKON	;TELL USER 'NO SUCH CONT.
	PUSHJ	P,USPROB
	JRST	USRCN5

USRC1B:	TLZ	A,B.UST
	MOVEM	A,DRVSTT(B)	;SET THIS DRIVE UNAVAILABLE
USRCN5:	AOBJN	C,USRCON	;LOOP FOR ALL USER REQUESTS

;HERE TO FIND DRIVES FOR THE REST OF THE PACKS

ANYDRV:	HRLZ	C,D		;RESET NUMBER OF DRIVES REQUESTED
ANYDR1:	SKIPE	M,USRDRV(C)	;SKIP IF WE STILL NEED A DRIVE HERE
	JRST	ANYDR5		;NO, ALREADY TAKEN CARE OF
	LDB	N1,KTPBYT	;N1=KONTROLLER TYPE NEEDED
	LDB	N,UTPBYT	;GET TYPE OF UNIT NEEDED
	MOVE	B,NUMDRV
ANYDR2:	MOVE	A,DRVSTT(B)	;SKIP IF DRIVE AVAILABLE
	LDB	CH,D.UST
	CAIE	CH,2
	JRST	ANYDR3		;NO
	LDB	E,D.KONT		;E=KONTROLLER TYPE
	CAME	N1,E		;SKIP IF OK
	JRST	ANYDR3
	LDB	E,D.UNIT	;E=UNIT TYPE
	CAMN	N,E		;SKIP IF NO GOOD
	JRST	ANYDR4		;OK, GOT ONE
ANYDR3:	AOBJN	B,ANYDR2	;LOOP FOR THE DRIVES
	JRST	ERR14		;COULDN'T MAKE IT
ANYDR4:	TLZ	A,B.UST
	MOVEM	DRVSTT(B)	;SET THIS DRIVE UNAVAILABLE
ANYDR5:	AOBJN	C,ANYDR1
	JRST	OPREQ0
ERR14:	MOVEI	M,NEDAM
	PUSHJ	P,MSGTTY	;TELL USER NOT ENOUGH DRIVES AVAIL


OPREQ0:				;HERE TO ASK OPR TO MOUNT F/S
	MOVE	A,STATES	;GET THE STATES WORD
	TRNE	A,STAOPR	;TEST FOR OPR PRESENT
	PUSHJ	P,ERR911		;NO, THEN CAN'T DO IT, UNLESS SHOVE
	PUSHJ	P,QUEREQ
	MOVEI	M,OPMNT
	PUSHJ	P,OPREQ2
	JRST	PAKUP		;GO CREATE A UFD IF NECESSARY
;HERE TO REQUEST OPER TO MOUNT THE FILE STRUCTURE

QUEREQ:	SETZM	TAPEID
	SETZM	FILBLK
	HRLI	NUM,(SIXBIT .M.)
	PUSHJ	P,COMBEG	;SET UP THE COMMAND FILE
	TEXT	< MOUNT >
	PUSHJ	P,MSG
	SKIPN	M,PHYNAM
	MOVE	M,CMDFSN
	PUSHJ	P,SIXMSG
	SKIPN	LOGNAM
	JRST	OPRQ1A
	PUSHJ	P,SPACE
	MOVE	M,LOGNAM
	PUSHJ	P,SIXMSG
OPRQ1A:	PUSHJ	P,RIDOUT	;OUTPUT /REELID IF ANY
	PUSHJ	P,VIDOUT	;OUTPUT /VID IF ANY
	TEXT	< /S>
	TLNE	F,L.SIN
	PUSHJ	P,MSG
	TEXT	< /WL>
	TLNE	F,L.WRTL
	PUSHJ	P,MSG
	TEXT	< /WE>
	TLNE	F,L.WEN
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ . /PAS.] ;ASSUME /PASSIVE NEEDED
	TRNE	F,R.PAS		;TEST FOR /PASSIVE
	PUSHJ	P,MSG		;  YES, OUTPUT THE SWITCH
	MOVEI	M,[ASCIZ . /NOC.] ;ASSUME /NOCREATE NEEDED
	TRNE	F,R.NOC		;TEST FOR /NOCREATE
	PUSHJ	P,MSG		;  YES, OUTPUT THE SWITCH
	SKIPN	UDREQ		;SKIP IF USER REQUESTED SPECIFIIC UNITS
	JRST	OPRQ1C
	PUSHJ	P,LPAR
	MOVN	N,NUMREQ
	HRLZS	N
	SKIPA
OPRQ1D:	PUSHJ	P,COMMA
	MOVE	M,USRDRV(N)
	PUSHJ	P,SIXMSG
	AOBJN	N,OPRQ1D
	PUSHJ	P,RPAR
OPRQ1C:	PJRST	CRLF
MNTFIN:	MOVE	A,HLISTI	;BUILD IOWD LST IN LOW SEG.
	MOVEM	A,HLIST
	SETZM	HLIST+1
	MOVE	A,[PHOPEN!17]	;SET PHYS-ONLY & MODE
	SETZ	C,
	MOVE	B,FSNAME
	OPEN	USR,A		;SEE HOW IT ALL CAME OUT
	  JRST	ERR6A
	MOVEI	IO,W.TTY
	MOVE	A,[SIXBIT .HOME.]
	MOVSI	B,(SIXBIT .SYS.)
	SETZB	C,LASTUN	;CLEAR LAST UNIT TYPED
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;LOOKUP HOME.SYS[SYS] TO READ HOME BLOCKS
	  JRST	NOHOME		;  ERROR, GO PRINT A MSG
NXUNTY:	INPUT	USR,HLIST	;READ NEXT BLOCK
	STATZ	USR,20000	;SKIP UNLESS EOF
	JRST	NOFNTY
	MOVS	A,B.USR		;FIRS WORD
	CAIE	A,(SIXBIT .HOM.);MUST BE .HOM. OR IS NOT A HOME BLOCK
	JRST	NXUNTY
	MOVE	M,B.USR+HOMLOG	;GET SIXBIT LOGICAL UNIT IN STR
	CAMN	M,LASTUN	;NO SKIP IF ALREADY TYPED
	JRST	NXUNTY		;UNITS HAVE TWO HOME BLOCKS
	MOVEI	A,M
	DSKCHR	A,		;GET PHYSICAL UNIT
	  JRST	NXUNTY		;DOESN'T EXIST?
	MOVEM	M,LASTUN	;SAVE UNIT WE ARE ABOUT TO TYPE
	SKIPN	NUMREQ		;TEST FOR USER-SPECIFIED UNITS
	JRST	NXUNTY		;  NO, THEN DON'T TYPE THE PACK ID'S
	MOVE	M,B.USR+HOMHID	;GET UNIT ID
	PUSHJ	P,SIXMSG	;TYPE IT
	MOVEI	M,[ASCIZ . on .]
	PUSHJ	P,MSG
	PUSHJ	P,UNISET	;SET UP UNIT MNEMONIC IN B
	MOVE	M,B
	PUSHJ	P,SIXMSG
	PUSHJ	P,CRLF
	JRST	NXUNTY
NOHOME:	MOVEI	M,[ASCIZ /% LOOKUP for Home Blocks failed/] ;POINT AT MSG
	PUSHJ	P,MSGTTY	;TYPE THE WARNING MSG
				; & FALL THRU TO CONTINUE ON
NOFNTY:	PUSHJ	P,CRLF		;TYPE CR,LF
	MOVE	M,CMDFSN
	PUSHJ	P,SIXMSG	;AND FILE STRUCTURE NAME
	MOVEI	M,MNTD
	PUSHJ	P,MSG		;MOUNTED
IFN FTFACT,<
IFE FTFCT1,<
	SKIPE	IDIDIT		;IF OMOUNT USED, DON'T DO ACCOUNTING HERE TOO.
	 JRST	NOFNT1
>;	END IFE FTFCT1
	HRLI	NUM,'UM '	;SHOW USER MOUNT RQST
	MOVE	A,FSNAME	;GET F.S NAME
	PUSHJ	P,WRFACT	;CALL TO WRITE FACT RECORD
NOFNT1:
>;	END OF	IFN FTFACT
;NOW CHECK FOR USERS UFD

	MOVE	A,[PHOPEN!14]	;OPEN USR ON F.S.
	MOVE	B,FSNAME
	MOVEI	C,RH.USR
	OPEN	USR,A
	  JRST	NOFNT2		;CANT OPEN
	MOVEI	A,B.USR		;DECLAIR 1 BUFFER
	MOVEM	A,.JBFF
	INBUF	USR,1
	MOVE	A,USRPPN	;LOOKUP UFD
	MOVSI	B,(SIXBIT/UFD/)
	SETZM	C
	MOVE	D,MFDPPN
	LOOKUP	USR,A		;IS IT THERE AND ACCESSIBLE?
	  SKIPA			;NO
	JRST	ALLOVR		;YES-THATS ALL
NOFNT2:	MOVEI	M,[ASCIZ/No UFD created
/]		;TELL USER NO UFD
	JRST	ALLFIN



OPREQ2:	PUSHJ	P,MSGTTY	;TELL USER ALL ABOUT IT
TMWAIT:	MOVE	A,NAMMNT
	PUSHJ	P,WAKE0
	  PUSHJ	P,MSG113	;TELL USER NO OPERATOR JOB
	TLNN	F,L.PWA		;SKIP IF USER REQUESTED PAUSE BEFORE WAITING
	JRST	DOWAIT		;NO, CLOSE OUT COMMAND AND WAIT
	MOVEI	M,PBWM
	PUSHJ	P,MSGTTY
	TTCALL	CLRINB,		;CLEAR INPUT BUFFER
	PUSHJ	P,GETARG

DOWAIT:	CLOSE	CMD,		;CLOSE THE COMMAND FILE
	MOVE	A,NAMMNT	;GET NAME FOR MOUNT COMMANDS
	PUSHJ	P,WAKE1		;CALL TO WAKE ALL OMOUNTS
	  JFCL			; (IGNORE ERRORS)
REPEAT 0,<
	MOVEI	A,^D1000	;GET 1000 MSEC (1 SEC)
	HRLI	A,HIBNOJ!HIBTTL	;COMBINE WITH HIBER FLAG BITS
IFN DBUGSW, <
	TLZ	A,HIBNOJ	;CLEAR BIT IF DEBUGGING
>;	END OF	IFN DBUGSW
	MOVEI	B,1		;GET ONE SECOND
	HIBER	A,		;HIBERNATE FOR ONE SECOND MAXIMUM
	  SLEEP	B,		;  FAILED, SLEEP FOR ONE SECOND
DOWAT1:	PUSHJ	P,MSG111	;TELL USER WE ARE WAITING
	CLOSE	CMD,
>	;END OF REPEAT 0
	TRNE	F,R.NOWA	; DID USER SAY /NOWAIT
	 JRST	TERMIN		; YES...EXIT
	PUSHJ	P,MSG111	;TELL USER WE ARE WAITNG
MNTWAT:	MOVE	A,NAMMNT	;WAKE AN OMOUNT
	PUSHJ	P,WAKE1
	  JFCL
	MOVEI	A,MOUSLP	;AND HIBERNATE TILL WAKE OR ^C
	PUSHJ	P,WAIT0
	MOVE	A,CMDNAM	;NOW SEE IF OUR COMMAND STILL EXISTS
	MOVSI	B,(SIXBIT .CMD.)
	MOVEI	C,0
	MOVE	D,CMDPPN
	LOOKUP	CMD,A		;LOOK FOR THE FILE
	  POPJ	P,		;DONE! TELL USER
	JRST	MNTWAT		;STILL WAITING FOR SERVICE
SUBTTL	SUBROUTINES
;SUBROUT TO WAKE APPROPRIATE OMOUNTS
;ENTER	WAKE0 DONT WAKE, JUST CHK. FOR OMOUNTS
;	WAKE1 WAKE ALL APPROPRIATE OMOUNTS
;CALL:	A=OMOUNT JOB NAME OTHER THAN SYSOMO
;RET+1	IF NO APPROPRIATE OMOUNTS
;RET+2	IF WAS SOME OMOUNTS

WAKE0:	TDZA	B,B	;LH=0 FOR 'DONT WAKE'
WAKE1:	MOVSI	B,-1	;LH=-1 FOR 'WAKE'
IFN DBUGSW, <
	TRON	B,-1		;ASSUME WE FOUND AN OMOUNT
	AOS	(P)		;SO SET SKIP RETURN	  
>;	END OF	IFN DBUGSW
	MOVEI	C,1	;COUNT JOB NUMS IN C
WAKE2:	MOVEI	D,JBTPRG	;GET THIS JOB NAME
	HRL	D,C
	GETTAB	D,
	  POPJ	P,
	CAMN	D,NAMOMO	;IS IT SYSOMO
	JRST	WAKE3
	CAME	D,A	;  OR SPECIFIC NAME?
	AOJA	C,WAKE2	;NO-CK NEXT JOB
WAKE3:
IFE DBUGSW,<	;IF DEBUGGING DONT REQUIRE [1,2] OMOUNT
	MOVEI	D,PRJPRG	;YES-PPN 1,2?
	HRL	D,C
	GETTAB	D,
	  POPJ	P,
	CAME	D,FS1PPN
	AOJA	C,WAKE2		;NO-FORGET IT
> ;IFE DBUGSW
	HRLZ	D,C	;GET JBTSTS
	GETTAB	D,
	  POPJ	P,
	JUMPGE	D,WAKE4	;JUMP IF NOT RUNNING
	TRON	B,-1	;IS THIS 1ST ONE WEVE SEEN?
	AOS	(P)	;YES-REMEMBER TO SKIP RETURN
	JUMPGE	B,WAKE4	;DONT WAKE IF ENTERED WAKE0
	WAKE	C,		;YES-WAKE IT UP
	  POPJ	P,
WAKE4:	AOJA	C,WAKE2


;SUBROT TO WAIT FOR ^C OR WAKEUP FROM OMOUNT
;CALL:	A=NUM OF SECONDS TO SLEEP
;	EXITS IF ^C TYPED

WAIT0:
WAIT1:	MOVEI	B,^D60000
	HRLI	B,HIBNOJ!HIBSWP
IFN DBUGSW, <
	TLZ	B,HIBNOJ	;ANYBODY WAKES IF DEBUGGING
>;	END OF	IFN DBUGSW
	HIBER	B,
	  SLEEP	A,		;INCASE OLD MONITOR
	POPJ	P,
;SUBROUTINE TO COMPUTE SIXBIT LOGICAL UNIT IN STR
;ARGS	TEMBP=BYTE POINTER SET FOR IDPB
;	D(RH)=BINARY LOG. UNIT NUM IN STR
;VALUES	B=SIXBIT LUN

FILDPT:	MOVE	B,FSNAME	;START WITH NAME OF STR
	MOVE	BP,TEMBP	;BYTE POINTER
	MOVEI	N,(D)		;N=LOGICAL UNIT NUM
	IDIVI	N,^D10
	JUMPE	N,FILDP1	;JUMP IF ONLY 1 DIGIT
	ADDI	N,(SIXBIT .  0.) ;MAKE SIXBIT
	IDPB	N,BP		;STORE IN NAME
FILDP1:	ADDI	N1,(SIXBIT .  0.) ;MAKE NEXT DIGIT SIXBIT
	TLNE	BP,770000	;SKIP IF NAME FULL
	IDPB	N1,BP		;STORE IN NAME
	POPJ	P,

;INTERCEPT ROUTINES(SUPERSEDE CCTYPE HACK)
;
CONCOM:	MOVEI	A,1B34		;GET ^C BIT
	IORM	A,INTBLK+1
	POPJ	P,

CONCOF:	MOVEI	A,1B34		;GET ^C BIT
	ANDCAM	A,INTBLK+1	;AND DISABLE THE INTERCEPT
	POPJ	P,

INTLOC:	PUSH	P,A
	HLRZ	A,INTBLK+3	;GET TYPE OF INTERCEPT
	CAIE	A,1B34		;^C?
	 JRST	INTLC1		;NO
	JRST	TERMIN		;YES, EXIT
INTLC1:	MOVE	A,INTBLK+2	;GET PC WORD
	EXCH	A,(P)		;EXCHANGE WITH PUSH'D A
	SETZM	INTBLK+2
	POPJ	P, 		;AND RETURN TO INTERRUPTED CODE

;SUBROUTINE TO DETERMINE IF  ^C WAS TYPED
;IF YES, EXIT, ELSE RETURN

REPEAT 0,<
CCTYPE:	TTCALL	SKPINL,		;SKIP IF ANYTHING WAS TYPED
	  POPJ	P,		;NO, JUST RETURN
	PUSHJ	P,GETARG	;SEE WHAT IT WAS
CCTYP1:	CAIE	CH,CNTRLC	;SKIP IF ^C
	CAIN	CH,ALTMO	;OLD SCNSRF TURNS ^C TO ALTMODE
	JRST	.+2		;EITHER ONE WILL DO FOR AN EXIT
	POPJ	P,
	CLOSE	CMD,40		;ABORT COMMAND FILE IF NOT CLOSED YET
	JRST	TERMIN		;GO EXIT
>	;END OF REPEAT 0

;SUBROUTINE TO COMPUTE UNI NAME IN B FROM DSKCHR RETURN IN A
;ARGS	A=AC RETURN FROM DSKCHR
;VALUES	B=SIXBIT UNIT MNEMONIC

UNISET:	LDB	C,D.KONT	;GET CONTROLLER TYPE
	MOVE	B,KONSIX(C)	;SIXBIT MNEMONIC
	LDB	C,D.KONN	;GET CONTROLLER NUMBER
	ADDI	C,(SIXBIT .  A.) ;CONVERT TO LETTER A,B,C ETC
	TLO	B,(C)		;STORE LETTER IN NAME
	LDB	C,D.UNIN	;GET UNIT NUMBER
	ADDI	C,(SIXBIT .  0.) ;CONVERT TO SIXBIT
	DPB	C,[POINT 6,B,23]
	POPJ	P,
	;THIS ROUTINE SEARCHES THE DRIVE TABLE FOR A SPECIFIC DRIVE
	;ENTER A=SPECIFIC DRIVE (LEFT JUSTIFIED SIXBIT)
	;NON-SKIP RETURN IF NOT FOUND
	;SKIP RETURN IF FOUND, B=INDEX INTO TABLE

FNDDRV:	MOVE	B,NUMDRV
FNDRV1:	CAMN	A,DRIVE(B)	;LOOK FOR A MATCH
	JRST	CPOPJ1		;SKIP RETURN IF WE FOUND IT
	AOBJN	B,FNDRV1	;LOOP FOR ALL DRIVES
	POPJ	P,		;NON-SKIP RETURN IF NOT THERE



;THIS ROUTINE SEARCHES THE DRIVE TABLE FOR AN AVAILABLE DRIVE ON A SPECIFIC CONTROLLER.
;ARGS	A=CONTROLLER (LEFT JUSTIFIED SIXBIT)
;	N=UNIT TYPE NEEDED
	;ENTER AT FNDCON TO START AT THE BEGINNING OF THE TABLE
;ENTER AT FNDCN1 TO CONTINUE WHERE WE LEFT OFF LAST
;NON-SKIP RETURN IF NOT FOUND
;SKIP RETURN IF FOUND, B=INDEX INTO TABLE

FNDCON:	MOVE	B,NUMDRV	;START AT BEGINNING OF TABLE
	SKIPA	E,A		;SAVE CONTROLLER NEEDED IN E
FNDCN1:	AOBJP	B,CPOPJ		;TRY NEXT IN TABLE, EXIT IF LAST
	HLLZ	A,DRIVE(B)	;GET CONTROLLER PART OF NEXT DRIVE
	CAMN	A,E		;COMPARE WITH WHAT WE WANT
	MOVE	A,DRVSTT(B)	;OK, IS IT AVAILABLE?
	LDB	N1,D.UST
	CAIE	N1,2
	JRST	FNDCN1		;NO--NO GOOD TO US, TRY NEXT
	LDB	N1,D.UNIT	;YES-N1=UNIT TYPE
	CAIE	N,(N1)		;SKIP IF RIGHT TYPE OF UNIT
	JRST	FNDCN1		;ALAS
	JRST	CPOPJ1		;EVERYTHING OK, SKIP RETURN



;SUBROUTINE TO SKIP WORDS ON FILE OPEN ON CHANNEL USR
;	ARGS	B=NUMBER OF WORDS TO SKIP

SKPSTR:	PUSHJ	P,R.USR		;GET NEXT WORD FROM STRLST
	  JRST	ERR17
	SOJG	B,SKPSTR	;B CONTAINS THE NUMBER OF WORDS TO SKIP
	POPJ	P,		;RETURN

;THIS ROUTINE OUTPUTS A LIST OF SIXBIT ITEMS POINTED TO BY N.
;ENTER N=XWD -NUMBER OF WORDS, FIRST WORD ADDRESS OF THE TABLE

SNDLST:	MOVE	M,(N)
	PUSHJ	P,SIXMSG	;OUTPUT THE NEXT ITEM
	AOBJP	N,CRLF		;IF ALL DONE, OUTPUT CR,LF
	PUSHJ	P,COMMA		;ELSE PUT COMMAS BETWEEN
	JRST	SNDLST
SUBTTL	MOUNT COMMAND - FILE STRUCTURE ERROR MESSAGES
ERR1:	ERRMES <?Can't find STRLST.SYS>
ERR2A:	STATO	USR,20000	;SKIP IF EOF
	JRST	ERR17		;NO, READ ERROR
ERR2:	ERRMES <?Unknown device or structure name>
ERR17:	ERRMES <?Can't read STRLST.SYS>
ERR4:	ERRMES <?Uncertified packs may not be shared>
ERR5:	ERRMES <?Must be in owner's project to request single access>
ERR6:	MOVE	IO,FSNAME
	MOVEM	IO,UFDFSN
	MOVEI	IO,W.TTY
	PUSHJ	P,DISSTR
	ERRMES <?Structure not mounted>
ERR10:	ERRMES <?System error - SYSPHY UUO failed>
ERR21:	ERRMES <?File structure locked out by Operator>
ERR25:	MOVEI	CH,"?"
	MOVEI	IO,W.TTY	;SET UP IO FOR SIXMSG
	PUSHJ	P,W.TTY
	MOVE	M,A
	PUSHJ	P,SIXMSG	;M=DRIVE WHICH ISN'T A DRIVE
	ERRMES < Illegal unit>
ERR26:	ERRMES <?No SYS>
ERR27:	ERRMES <?System error - Wrong format version number in STRLST.SYS>
ERR29:	MOVEI	M,SABJM
	PUSHJ	P,MSGTTY
	MOVE	N,B
	PUSHJ	P,DECPRT
	PUSHJ	P,CRLF
ERR6A:	ERRMES <?Mount unsuccessful>

ERRMSB:	PUSHJ	P,MSGTTY
	PUSHJ	P,CRLF
	JRST	TERMIN		;GO EXIT

>	;END CONDITIONAL ON MNTSW

IFE MNTSW,<LIST>
SUBTTL	COMMAND-SCANNING & MISC. I/O ROUTINES
;SUBROUTINE TO SEARCH A TABLE FOR A COMMAND THAT WAS TYPED AND DISPATCH APPROPRIATELY
;ARGS	E=AOBJN POINTER TO LEGAL COMMANDS
;	2ND LOCATION BEFORE TABLE IS'NON-UNIQUE SWITCH' ERROR ADDRESS
;	1ST LOCATION BEFORE TABLE IS 'NON-EXISTANT SWITCH' ERROR ADRESS

UDSWIT:
;	TLNE	F,L.BRK		;SKIP UNLESS BREAK CHAR DETECTED
;	JRST	COMERR
	PUSHJ	P,GETARG	;GET SWITCH
	HLLZS	A		;KEEP ONLY FIRST THREE CHARS
	JUMPE	A,@-1(E)	;ERROR RET. IF NO NAME
	SETO	C,		;FIRST TRY FOR EXACT MATCH
	MOVE	D,E		;SAVE PTR IN D
	PUSHJ	P,SWPROC	;TRY TO FIND SWITCHES
	  JRST	.+2
	JRST	(B)		;MADE IT, DISPATCH
	PUSHJ	P,GETMSK	;CREATE MASK IN C FOR CHARS TYPED
	TRO	C,-1		;SET RH TO KEEP DISPATCH ADDR IN XOR
	MOVE	E,D		;RESET PTR TO TABLE OF SWITCHES
	PUSHJ	P,SWPROC	;TRY AGAIN
	  JRST	@-1(D)		;NO SUCH SWITCH
	AOBJP	E,(B)		;FOUND ONE, DISPATCH IF LAST IN LIST
	HRR	A,B		;SAVE DISPATCH ADDR
	PUSHJ	P,SWPROC	;LOOK FOR DOUBLE MATCH (NOT UNIQUE)
	  JRST	(A)		;NONE, OK, SO DISPATCH
	JRST	@-2(D)

;SUBROUTINE TO SEARCH TABLE FOR MASKED MATCH
;ARGS	A=CHARS TYPED (LEFT HALF ONLY)
;	C=MASK
;	E=AOBJN POINTER TO TABLE OF LEGAL COMMANDS

SWPROC:	HLLZ	B,A		;B=CHARS TYPED
	XOR	B,(E)		;COMPARE WITH NEXT SWITCH IN LIST
	AND	B,C		;KEEP ONLY NUM CHARS TYPED
	TLNN	B,-1		;ZERO IF MATCH
	JRST	CPOPJ1		;OUR WORK IS OVER, RH B=DISPATCH ADDR
	AOBJN	E,SWPROC	;LOOP FOR ALL SWITCHES IN LIST LOOKING FOR MAT
	POPJ	P,		;SADLY NONE

;SUBROUTINE TO CREATE A MASK IN C FOR ACTUAL CHARACTERS IN A
;ARGS	A=SIXBIT CHARACTERS
;VALUES	C=MASK OF ALL ONES IN NON-ZERO CHARACTER POSITIONS

GETMSK:	SETZ	C,		;ASSUME NO CHARS
	JUMPE	A,CPOPJ		;JUMP IF ASSUMPTION PROVES VALIDATED
	TLO	C,770000	;NO, MUST BE AT LEAST ONE CHAR
	PUSH	P,A		;SAVE A
GETMS1:	LSH	A,6		;SHIFT OFF CHARACTER WE KNOW ABOUT
	JUMPE	A,APOPJ		;EXIT IF NO MORE
	ASH	C,-6		;AT LEAST ONE MORE, EXTEND MASK ONE CHAR
	JRST	GETMS1		;AND LOOP
APOPJ:	POP	P,A		;RESTORE A
	POPJ	P,
;SUBROUTINE TO SET UP AND WRITE FIRST LINE OF A QUEUE REQUEST
;ARGS	NUM=SIXBIT CHAR IDENTIFYING TYPE OF MESSAGE

COMBEG:
IFN FTFACT,<
	SETOM	IDIDIT		;SET FLAG THAT OMOUNT USED FOR FACT
>;	END IFN FTFACT
	MOVSI	A,(PHOPEN)	;HERE TO WRITE CMD FILE
	MOVE	B,CMDSTR	;STR FOR COMMANDS
	HRLZI	C,WH.CMD
	OPEN	CMD,A
	  JSP	N,CMDERR

FILCL1:	HLLZ	WD,NUM		;NUM CONTAINS THE TYPE OF MESSAGE
	TIMER	CH,		;CHAR 2&3 ARE 12 LOW ORD OF TIMER
	ANDI	CH,7777		;ONLY LOW 12 WANTED
	TLO	WD,(CH)		;PUT IN LH OF NAME
	IOR	WD,IORPPN		;RH OF NAME IS IOR'D PPN
	CAMN	WD,CMDNAM		;NEW NAME SAME AS LAST TRY?
	JRST	FILCL1		;YES - TRY AGAIN FOR A DIFFERENT ONE
	MOVEM	WD,CMDNAM		;SAVE THIS NAME
	MOVE	A,CMDNAM
	MOVSI	B,(SIXBIT /CMD/)	;EXTENSION
	MOVEI	C,0
	MOVE	D,CMDPPN		;COMMAND AREA
	LOOKUP	CMD,A		;DOES THIS FILE ALREADY EXIST?
	 TRNE	B,-1		;MAYBE
	JRST	FILCL1		;YES
	MOVSI	B,(SIXBIT /CMD/)	;NO
IFN DBUGSW, <
	SETZ	C,		;SET CMD-FILE PROTECTION
>;	END OF	IFN DBUGSW
IFE DBUGSW, <
	MOVSI	C,(<077B8>)	;SET CMD-FILE PROTECTION
	MOVE	D,CMDPPN
>;	END OF	IFE DBUGSW
	ENTER	CMD,A		;IF THIS WORKS
	 JRST FILENF		;PITY
	MOVEI	IO,B.CMD		;WE CAN USE IT
	MOVEM	IO,.JBFF
	OUTBUF	CMD,1
FILOUT:	MOVEI	IO,W.CMD
	MOVE	CH,CMDCHR
	PUSHJ	P,0(IO)		;WRITE COMMAND CLASS
	MOVEI	M,[ASCIZ / Job/]
	PUSHJ	P,MSG		;JOB
	MOVE	N,JOBNO
	PUSHJ	P,DECPRT		;JOB NUMBER
	PUSHJ	P,SPACE		;SPACE
	SKIPN	M,TTYLIN		;TTYN IF KNOWN
	MOVE	M,[SIXBIT /TTYXXX/]
	PUSHJ	P,SIXMSG
	PUSHJ	P,SPACE		;SPACE
	HLRZ	N,USRPPN
	PUSHJ	P,OCTPRT		;USER'S PPN
	PUSHJ	P,COMMA
	HRRZ	N,USRPPN
	PUSHJ	P,OCTPRT
	PUSHJ	P,SPACE		;SPACE
	SKIPN	M,TAPEID		;AND THE TAPE NUMBER
	MOVSI	M,(SIXBIT /1/)
	PUSHJ	P,SIXMSG
	SKIPN	FILBLK		;NOW ANY FILES MENTIONED
	POPJ	P,		;NONE
FILOU1:	MOVEI	D,0
	PUSHJ	P,SPACE
FILOUL:	SKIPN	FILBLK(D)
	POPJ	P,
	SKIPE	D		;NO COMMA FIRST TIME
	PUSHJ	P,COMMA
	SKIPN	M,FILDEV(D)
	MOVSI	M,(SIXBIT .DSK.)
	SETZM	FILSTR		;CLEAR STR NAME (SHOWS NOT READING S/L)
	CAME	M,[SIXBIT /DSK/];TEST FOR 'DSK'
	JRST	FILST1		;  NO, JUMP
	JUMPE	D,FILST1	;ALSO JUMP IF 1ST FILE (DIRECTORY)
	MOVE	A,FILPPN(D)	;GET PPN FROM THE FILE
	CAME	A,USRPPN	;TEST FOR SAME AS [SELF]
	JUMPN	A,FILST1	;  NO, JUMP IF NON-ZERO (NOT DEFAULTED TO [SELF])
	MOVE	A,CMDCHR	;GET FILE-RQST TYPE LETTER
	CAIE	A,"F"		;TEST FOR 'FILE F'
	CAIN	A,"Z"		;TEST FOR 'FILE Z'
	SKIPA	A,[FILSTR]	;  EITHER, POINT AT PARM LIST & SKIP
	JRST	FILST1		;  NEITHER, JUMP TO IGNORE S/L
	SETOM	FILSTR		;SET STR NAME -1 FOR 1ST F/S
	JOBSTR	A,		;GET 1ST STR NAME IN S/L
	  SETZM	FILSTR		;  FAILED, SET TO ZERO
	SKIPE	A,FILSTR	;GET STR NAME & TEST FOR ZERO
	AOSN	FILSTR		;TEST FOR -1 (NULL S/L) RETURNED
	JRST	FILST1		;  YES, JUMP TO IGNORE S/L (0 OR -1 RET'D)
	MOVE	M,A		;COPY STR NAME TO START WITH IT
	MOVEM	M,FILSTR	; & RESTORE STR NAME FOR NEXT TIME
FILST1:				;HERE TO OUTPUT A FILE-SPEC
	MOVE	A,CMDCHR	;GET TYPE OF FILE COMMAND
	CAIN	A,"D"		;TEST FOR 'FILE D'
	JUMPN	D,FILNDV	;  YES, DON'T OUTPUT DEVICE UNLESS DIR FILE
	PUSHJ	P,SIXMSG
	PUSHJ	P,COLON		;OUTPUT A COLON
FILNDV:				;HERE NOT TO OUTPUT DEVICE NAME
	MOVE	M,FILBLK(D)
	PUSHJ	P,SIXMSG		;FILE NAME(EVEN IF *, PASSED ON TO OPFILE)
	SKIPE	M,FILBEX(D)
	PUSHJ	P,DOT		;PERIOD IF EXT COMMING
	SKIPE	M,FILBEX(D)
	PUSHJ	P,SIXMSG		;EXT IF SPECIFIED
	SKIPN	N,FILPPN(D)	;TEST FOR PPN SPECIFIED
	JRST	FILOU2		;  NO, JUMP
	CAMN	N,USRPPN	;TEST FOR PPN [SELF]
	JRST	FILOU2		;  YES, DON'T OUTPUT IT
	PUSHJ	P,LBRKET	;OUTPUT A "["
	HLRZ	N,FILPPN(D)	;GET THE PROJ #
	PUSHJ	P,OCTPRT	; & OUTPUT IT
	PUSHJ	P,COMMA		;OUTPUT A COMMA
	HRRZ	N,FILPPN(D)	;GET THE PROG #
	PUSHJ	P,OCTPRT	; & OUTPUT IT
	PUSHJ	P,RBRKET	;OUTPUT A "]"
FILOU2:				;HERE IF NO PPN
	SKIPN	FILSTR		;TEST FOR SCANNING S/L
	JRST	FILST2		;  NO, JUMP
	MOVEI	A,FILSTR	;POINT AT PARM LIST
	JOBSTR	A,		;GET NEXT STR FROM S/L
	  JSP	N,NEVERR	;  FAILED, A FATAL ERROR
	SKIPE	M,FILSTR	;GET STR NAME & TEST FOR ZERO
	CAMN	M,[-1]		;TEST FOR -1 RET'D
	JRST	FILST2		;  EITHER, DONE WITH THIS FILE SPEC
	PUSHJ	P,COMMA		;OUTPUT A COMMA
	MOVE	M,FILSTR	;GET RETURNED STR NAME
	JRST	FILST1		; & CONTINUE FOR NEXT STR
FILST2:				;HERE WHEN DONE WITH THIS FILE SPEC
	AOJA	D,FILOUL

	
IFN FTFACT, <

;
;  SUBROUTINE TO WRITE FACT RECORDS
;
;	CALL:	HRLI	NUM,'XX '	;PUT QUEUE CODE IN AC
;					;XX=UM FOR MOUNT, UD FOR DISMOUNT
;		MOVE	A,[DEVICE NAME]	;PUT DEVICE FOR F/S NAME IN AC
;		PUSHJ	P,WRFACT	;CALL TO WRITE ACCT'G RECORD
;		<RETURN>
;

WRFACT:	PUSH	P,A		;SAVE DEVICE NAME
	MOVEI	A,3		;GET DAEMON .FACT CODE
	MOVEM	A,FACT		;STORE AS PREFIX WORD
	MOVE	A,[XWD 271000,F.SIZE-1] ;GET HEADER WORD-WITH CODE 271
	TSO	A,JOBNO		;PUT JOB # IN L.H.
	MOVEM	A,F.HEAD	;STORE AS HEADER
	SETO	A,		;SET -1 FOR [SELF]
	GETLCH	A		;GET MY LINE CHARACTERISTICS
	TLNE	A,(1B1)		;TEST FOR CTY
	MOVNI	A,1		;  YES, SET -1
	GETLIN	B,		;GET MY LINE #
	TLNN	B,-1		;TEST FOR DETACHED
	MOVNI	A,2		;  YES, SET TO -2
	DPB	A,[POINT 12,F.HEAD,29] ;STORE INTO HEADER
	SETZM	F.DATE		;CLEAR DATE/TIME FOR DAEMON
	MOVE	A,[XWD F.DATE,F.DATE+1] ;GET BLT CONTROL WORD
	BLT	A,FACT+F.SIZE	;CLEAR REST OF FACT RECORD
	MOVE	A,[SERIAL]	;GET GETTAB PARMS FOR CPU SERIAL #
	GETTAB	A,		;GET CPU SERIAL #
	  SETZ	A,		;  FAILED, ASSUME ZERO
	HRRZM	A,F.QUE		;STORE INTO RECORD
	HRROI	A,.GTLOC	;GET GETTAB PARMS FOR MY STATION #
	GETTAB	A,		;GET MY STATION #
	  SETZ	A,		;  FAILED, ASSUME ZERO
	TLO	NUM,(A)		;TURN ON STATION # IN NUM ('QQN' IN L.H.)
	HLLM	NUM,F.QUE	;STORE INTO L.H. OF WORD
	POP	P,F.DEV		;STORE DEVICE INTO RECORD
	MOVSI	A,1		;SET SUCCESS FLAG IN F.UNIT (LH)
	MOVEM	A,F.UNIT	;THUS, F.UNIT=1,,0
	MOVE	A,[F.SIZE,,FACT];POINT AT RECORD
	DAEMON	A,		;CALL DAEMON TO WRITE THE RECORD
	  JFCL			;  FAILED, IGNORE IT
	POPJ	P,		;RETURN TO CALLER
>;	END OF	IFN FTFACT
FILENF:	HRRZS	B
	CAIN	B,NRMERR
	JRST	NOROOM
	CAIN	B,NUFERR
	JRST	NOCMU1
	CAIN	B,FBMERR
	JRST	FILCL1
FILLOS:	JRST	ERR120		;GO TELL ABOUT ERROR

NOROOM:	MOVEI	M,NORMMS
	JRST	ERREXI

HPACK:	SETZ	N,			;SUBR TO GET A WORD AND PACK OCTAL
HPACKL:	PUSHJ	P,0(IO)		;READ A CHAR
	CAIE	CH," "		;BLANK OR COMMA
	CAIN	CH,","		;TERMINATES FIELD
	POPJ	P,0		;EXIT IF TERMINATED
	ANDI	CH,7		;SAVE ONLY OCTAL PART
	LSH	N,3			;MAKE ROOM FOR A NEW DIGIT
	IOR	N,CH		;PACK DIGIT INTO WORD
	JRST	HPACKL		;BACK FOR NEXT DIGIT

;SUBROUTINE TO TYPE A USER'S REQUEST AND A MESSAGE FOLLOWING
;ARGS	M=ADDRESS OF ASCIZ MESSAGE

USPROB:	PUSH	P,M
	MOVE	M,USRDRV(C)
	PUSHJ	P,SIXMSG
	POP	P,M
	PUSHJ	P,MSG
	PJRST	CRLF

;THIS ROUTINE OUTPUTS ACCUMULATOR N AS A DECIMAL NUMBER

DECPR2:	MOVEI	CH,"0"
	CAIG	N,^D9
	PUSHJ	P,0(IO)
	PJRST	DECPRT

;SUBROUTINE TO READ F.S. NAME & IGNORE TRAILING COLON

REDEV:	PUSHJ	P,SST
	PUSHJ	P,SIXBRD
	CAIE	CH,":"
	POPJ	P,
	PJRST	(IO)
;THIS ROUTINE SCANS TTY TO THE FIRST
;NON-ALPHANUMERIC CHAR, FIRST 6 CHARS TO A IN SIXBIT,
;CH IS TERMINATING CHAR

GETARG:	TLZ	F,L.CMA!L.DOT!L.BRK!L.SPC!L.BRAK ;CLR ALL BITS
	MOVEI	IO,R.TTY
	PUSHJ	P,SSIXBR		;GET CHARS
GETAR2:		;HERE FROM GEFARG
	CAIN	CH,"["		;BRACKET?
	TLO	F,L.BRAK
	CAIN	CH,","
	TLO	F,L.CMA		;COMMA TERMINATOR
	CAIN	CH,"."
	TLO	F,L.DOT		;PERIOD TERMINATOR
	CAIE	CH,11		;TAB
	CAIN	CH,40
	TLO	F,L.SPC		;OR SPACE TERMINATOR
	CAIE	CH,33		;ALT MODE
	CAIGE	CH,15
	TLO	F,L.ARGD+L.BRK	;OR OTHER BREAK CHAR
	POPJ	P,0

;LIKE GETARG EXCEPTS ALSO ACCEPTS * (& SETS L.WLD)

GEFARG:	PUSHJ	P,GETARG
	CAIE	CH,"?"		;TEST FOR WILD CHARACTER
	JRST	GEFAR2		;  NO, JUMP
	TLO	F,L.WLD		;SET WILD-CARD FLAG
GEFAR1:	PUSHJ	P,SIXBR1	;STORE WILD-CHAR & CONTINUE SCAN
	CAIN	CH,"?"		;TEST FOR ANOTHER WILD CHARACTER
	JRST	GEFAR1		;  YES, GO STORE & CONTINUE
	PJRST	GETAR2		;GO CLASSIFY DELIMITER & RETURN
GEFAR2:				;HERE WHEN NO WILD CHARACTER READ
	JUMPN	A,CPOPJ
	CAIE	CH,"*"
	POPJ	P,
	TLO	F,L.WLD
	MOVSI	A,'*  '
	PUSHJ	P,(IO)
	PJRST	GETAR2
;THIS ROUTINE SCANS THE INPUT DEVICE, SKIPS LEADING SPACES OR TABS
;AND STORES ALPHANUMBERIC CHARS WITH BYTE POINTER BP

SSIXBR:	PUSHJ	P,SSST		;SKIP LEADING TABS OR SPACES
SIXBRD:	SETZB	A,B		;RETURNS FIRST NON-SPACE IN CH
	MOVE	BP,[POINT 6,A]
SIXBRL:	CAIL	CH,"A"
	CAILE	CH,"Z"
	SKIPA		;NOT LETTER
	JRST	SIXBR1
	CAIL	CH,"0"
	CAILE	CH,"9"
	JRST	SIXBRX
SIXBR1:	SUBI	CH,40		;CONVERT TO SIXBIT
	ADDI	B,1		;COUNT LENGTH OF STRING
	TLNE	BP,770000
	IDPB	CH,BP
	PUSHJ	P,0(IO)		;GET NEXT CHAR IN CH
	JRST	SIXBRL
SIXBRX:	POPJ	P,0

;THIS ROUTINE IGNORES LEADING TABS OR SPACES ON INPUT

SSST:	PUSHJ	P,0(IO)
SST:	CAIE	CH,11
	CAIN	CH,40
	JRST	SSST
	CAIE	CH,CHRLIN	;LINE CONTINUATION?
	JRST	SST2
	PUSHJ	P,(IO)	;YES-IGNORE IT
	PUSHJ	P,SST2	;   AND GOBBLE BREAK CHAR IF ANY
	TLZN	F,L.EOL
	POPJ	P,
	JRST	SSST
SST2:	CAIE	CH,33	;SET BIT IF END OF LINE
	CAIG	CH,14
SST3:	TLO	F,L.EOL
	POPJ	P,0
;SUBRS

DOT:	JSP	M,MSG
	ASCIZ /./
COMMA:	JSP	M,MSG
	ASCIZ /,/
SPACE:	JSP	M,MSG
	ASCIZ / /
LPAR:	JSP	M,MSG
	ASCIZ/ (/
RPAR:	JSP	M,MSG
	ASCIZ/) /
LBRKET:	JSP	M,MSG		;POINT AT TEXT & JUMP
	ASCIZ	/[/
RBRKET:	JSP	M,MSG		;POINT AT TEXT & JUMP
	ASCIZ	/]/
COLON:	JSP	M,MSG
	ASCIZ	/:/
QUEST:	JSP	M,MSG
	ASCIZ/? /

CLRLIN:	CAIE	CH,33
	CAIG	CH,14
	POPJ	P,0
	PUSHJ	P,R.TTY
	JRST	CLRLIN

MSGTTY:	MOVEI	IO,W.TTY
	TTCALL	13,0		;CLEAR ^O IF ON
	  JFCL			;((JUST IN CASE))
	PJRST	MSG

NOCMU:	TRNE	B,-1
	JRST	START1
NOCMU1:	MOVEI	M,CMMMSG
	JRST	ERREXI

SDECIN:	PUSHJ	P,SSST		;GET THE NEXT CHARACTER
DECIN:	PUSHJ	P,SST		;SKIP ALL BLANKS
	SETZ	N,		;CLEAR RESULT
DECINL:	CAIL	CH,"0"		;TEST FOR DECIMAL DIGIT
	CAILE	CH,"9"		;TEST FOR DECIMAL DIGIT
	POPJ	P,		;  NO, RETURN
	IMULI	N,^D10		;MULTIPLY PREVIOUS PRODUCT BY 10
	ADDI	N,-"0"(CH)	;ADD IN CURRENT DIGIT
	PUSHJ	P,(IO)		;READ NEXT CHARACTER
	JRST	DECINL		; & LOOP
;I/O	SUBRS

R.TTY:	TLZE	F,L.TYO
	OUTPUT	TTY,0		;OUTPUT ANY CHARS LEFT HANGING AROUND
	SOSLE	RH.TTY+2
	JRST	R.TOK
R.TTY1:	INPUT	TTY,0
	STATZ	TTY,740000
	  JSP	N,TTYERR
	STATO	TTY,20000	;EOF?
	 JRST	R.TOK		;NO, OK
	CLOSE	TTY,		;GET RID OF ^Z STATE
	JRST	R.TTY1		;AND TRY AGAIN

R.TOK:	ILDB	CH,RH.TTY+1
	JUMPE	CH,R.TTY
	CAIE	CH,177		;IGNORE RUBOUT
	CAIN	CH,15		;OR CR
	JRST	R.TTY
	CAIL	CH,175		;CHANGE 175,176 TO ALTMO
	MOVEI	CH,ALTMO		;WHICH IS ALTMODE
	CAIL	CH,140
	TRZ	CH,40		;CHANGE LOWER CASE TO UPPER
	CAIN	CH,3		;EXIT ON ^C
	JRST	TERMIN		;GO EXIT
	TLZ	F,L.EOL	;CLEAR EOL BIT
	PJRST	SST2		;GO CLASSIFY EOL CHARACTER

W.TTY:	SOSLE	WH.TTY+2
	JRST	W.TOK
	OUTPUT	TTY,0
	STATZ	TTY,760000
	  JSP	N,TTYERR
W.TOK:	IDPB	CH,WH.TTY+1
	TLO	F,L.TYO
	CAILE	CH,14
	POPJ	P,
	TLZ	F,L.TYO
	OUTPUT	TTY,0
	POPJ	P,0

W.CMD:	SOSLE	WH.CMD+2
	JRST	W.CDOK
	OUTPUT	CMD,0
	STATZ	CMD,760000
	  JSP	N,CMDERR
W.CDOK:	IDPB	CH,WH.CMD+1
	POPJ	P,0
R.CMD:	SOSLE	RH.CMD+2
	JRST	R.CDOK
	INPUT	CMD,0
	STATZ	CMD,760000
	SKIPA	CH,[12]
R.CDOK:	ILDB	CH,RH.CMD+1
	POPJ	P,0

R.CMU:	SOSLE	RH.CMU+2
	JRST	R.CUOK
	INPUT	CMU,0
	STATZ	CMU,760000
	POPJ	P,0
R.CUOK:	ILDB	WD,RH.CMU+1
CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,


USRERR:	GETSTS	USR,A	;IO ERROR ON USR CHAN
	JRST	IOERR
CMUERR:	GETSTS	CMU,A	;IO ERROR ON CMU CHAN
	JRST	IOERR
CMDERR:	GETSTS	CMD,A	;IO ERROR ON CMD CHAN
	JRST	IOERR
TTYERR:	GETSTS	TTY,A	;IO ERR ON TTY
IOERR:	MOVEI	M,IOMSG1	;'?SYSTEM IO ERROR'
	PUSHJ	P,MSGTTY
	HRRZS	N,
	PUSHJ	P,OCTPRT		;LOCATION
	MOVEI	M,IOMSG2		;'STATUS ='
	PUSHJ	P,MSGTTY
	MOVE	N,A			;STATUS
	PUSHJ	P,OCTPRT
	JRST	MONRET
ILFERR:	PUSH	P,FSNAME
	MOVEI	M,[ASCIZ/?Illegal name--/]
	JRST	ILDER2

ILDERR:	PUSH	P,B
	MOVEI	M,[ASCIZ/?Illegal device--/]
ILDER2:	PUSHJ	P,MSGTTY
	POP	P,M
	PUSHJ	P,SIXMSG
	JRST	MONRET

CKEOL:	PUSHJ	P,SST		;EAT UP TRAILING BLANKS AND TABS
	TLNE	F,L.EOL		;TEST FOR END OF LINE NOW
	JRST	CKEOL1		;EOL-GOOD
	CAIE	CH,";"		;IF NOT EOL, CAN ONLY ALLOW COMMENTS
	CAIN	CH,"!"		; (; AND ! START COMMENTS)
	 JRST	CKEOL1		;OK
	JRST	COMERR		;  NO, THEN GIVE SYNTAX ERROR
CKEOL1:	MOVEI	IO,W.TTY	;POINT AT TTY OUTPUT ROUTINE
	CAIN	CH,33		;TEST FOR CARRIAGE RETURNED AFTER LINE
	PJRST	CRLF		;  NO, THEN RETURN IT FOR THE USER
	POPJ	P,		;  YES, THEN RETURN TO CALLER

COMERR:	MOVEI	M,CERMSG
	JRST	ERREXI

	
;
;	SUBROUTINE TO READ A [P,P] FIELD - PPN RETURNED IN 'A'
;

REDPPN:	MOVE	A,CMDCHR	;GET RQST TYPE (LETTER)
	CAIE	A,"Z"		;TEST FOR 'FILE Z'
	CAIN	A,"F"		;TEST FOR 'FILE F'
	SKIPA	A,USRPPN	;  EITHER, LOAD USER'S PPN & SKIP
	JRST	PPNERR		;  NEITHER, GIVE ERROR MSG
	PUSHJ	P,SOCTIN	;READ PROJECT #
	SKIPN	N		;TEST FOR PROJ # RETURNED
	CAIE	CH,"]"		;TEST FOR END OF PPN (DASH SKIPPED)
	JRST	REDPP1		;  JUMP TO PROCESS NORMAL PPN
	MOVE	A,DIRPPN	;GET DIRECTORY PPN IF [-]
	JRST	REDPP2		; & VERIFY IT
REDPP1:	SKIPE	N		;TEST FOR PROJ # GIVEN
	HRL	A,N		;  YES, SAVE IT
	CAIE	CH,","		;TEST FOR PROPER DELIMITER
	JRST	COMERR		;  NO, SYNTAX ERROR
	PUSHJ	P,SOCTIN	;READ PROGRAMMER #
	SKIPE	N		;TEST FOR PROG # GIVEN
	HRR	A,N		;  YES, SAVE IT
REDPP2:	TLNE	F,L.EOL		;TEST FOR END OF LINE
	JRST	REDPP3		;  YES, GO MAKE FINAL CHECK
	CAIE	CH,"]"		;TEST FOR CLOSING BRACKET
	JRST	COMERR		;  NO, SYNTAX ERROR
REDPP3:	MOVE	N,DEFPPN	;GET DEFAULT PPN
	CAME	A,N		;TEST FOR INPUT PPN SAME AS DEFAULT
	CAMN	N,DIRPPN	;TEST FOR DEFAULT PPN SAME AS DIRECTORY
	POPJ	P,		;  RETURN IF SAME AS DEFAULT OR DEFAULT OVER-RIDABLE
	MOVEI	M,[ASCIZ /% Cannot override PPN implied by device /]
	PUSHJ	P,MSGTTY	;TYPE THE MESSAGE 1ST PART
	MOVE	M,DEFDEV	;GET THE DEFAULT DEVICE
	PUSHJ	P,SIXMSG	; & TYPE IT
	PUSHJ	P,COLON		;TYPE A COLON
	PUSHJ	P,CRLF		;END THE LINE
	MOVE	A,DEFPPN	;RETURN DEFAULT PPN JUST LIKE NOTHING HAPPENED
	POPJ	P,		;RETURN TO CALLER

SOCTIN:	PUSHJ	P,SSST		;THROW AWAY INITIAL CHARACTER
OCTIN:	PUSHJ	P,SST		;SKIP LEADING BLANKS
	SETZ	N,		;CLEAR RESULT REGISTER
OCTINL:	CAIL	CH,"0"		;TEST FOR OCTAL DIGIT
	CAILE	CH,"7"		;TEST FOR OCTAL DIGIT
	POPJ	P,		;  NO, RETURN TO CALLER
	LSH	N,3		;MULTIPLY PREVIOUS PRODUCT BY 8 (2**3)
	ADDI	N,-"0"(CH)	;ADD IN NEXT DIGIT
	PUSHJ	P,(IO)		;READ NEXT CHARACTER
	JRST	OCTINL		; & REPEAT

PPNERR:	MOVEI	M,[ASCIZ /? PPN or device permitted only on FILE F or FILE Z cmds
/]				;POINT AT ERROR MESSAGE
	JRST	ERREXI		;GO TYPE & ABORT THE RUN
;SUBROUTINE TO GET USERS QUOTAS FROM QUOTA.SYS
;CALL	B=F/S NAME
;	A=PPN
;RET+0	NO QUOTAS RETURNED
;RET+1	B=RESERVED QUOTA
;	C=FCFS QUOTA
;	D=LOGGED-OUT QUOTA

GETQUO:	TRNE	A,400000	;TEST FOR # PROG NUMBER
	HRRI	A,-2		;  YES, CONVERT TO -2
	MOVEM	A,QUOPPN
	HLLOM	A,QUODEF	;DEFAULT ENTRY (PROJ,-1)
	MOVE	A,[PHOPEN!14]
	MOVEI	C,RH.USR
	OPEN	USR,A		;TRY TO OPEN STR
	  PJRST	MSG262
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	MOVE	A,[SIXBIT .QUOTA.]
	MOVSI	B,(SIXBIT .SYS.)
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;SEE IF QUOTA.SYS EXISTS
	  JRST	GETAQ1		;NO -- SO TRY AUXACC.SYS
	PUSHJ	P,R.USR		;READ SIZE OF ENTRY
	  PJRST	MSG262
	HLRZ	B,A		;B=FORMAT VERSION NUMBER
	CAIE	B,QUOFOR
	PJRST	MSG263
	HRRZ	N,A
	SETOM	QUODFR		;USE QUODFR AS A SWITCH
	PUSHJ	P,R.USR		;GET 1ST ENTRY
	  JRST	GETQU3
	AOSE	A		;IS IT -1,-1?
	SOJA	A,GETQU5	;NO
	PUSHJ	P,GETQU		;YES-REMEMBER ITS QUOTAS FOR DEFAULTS
	  POPJ	P,
	MOVEM	B,QUODFR
	MOVEM	C,QUODFF
	MOVEM	D,QUODFO
	MOVEI	B,-3(N)		;MAINTAIN PROPER PLACE IN FILE
	JRST	GETQU2
GETQU1:	PUSHJ	P,R.USR		;READ FIRST WORD OF ENTRY (PPN)
	  JRST	GETQU3
GETQU5:	CAMLE	A,QUODEF	;SKIP IF NOT YET PAST USER
	JRST	GETQU7		;HE AIN'T THERE
	CAME	A,QUODEF	;DEFAULT?
	CAMN	A,QUOPPN	;SKIP IF THIS IS NOT USER'S PPN
	JRST	GETQU4		;HE EXISTS, GO MAKE UFD
GETQU6:	MOVE	B,N		;SKIP REST OF THIS ENTRY
GETQU2:	SOJLE	B,GETQU1
	PUSHJ	P,R.USR
	  JRST	GETQU3
	JRST	GETQU2
GETQU3:	STATZ	USR,20000	;EOF?
	JRST	GETQU7		;YES-NO ENTRY IN QUOTA.SYS
	PJRST	MSG262		;NO--ERROR

GETQU4:	PUSHJ	P,GETQU		;READ ENTRY
	  POPJ	P,
	JRST	GETQU8		;  & RETURN

GETQU7:	SKIPGE	B,QUODFR	;WAS THERE A DEFAULT?
	JRST	GETAQ1		;NO -- SO TRY AUXACC.SYS
	MOVE	C,QUODFF	;YES-USE THEM
	MOVE	D,QUODFO
GETQU8:	RELEASE	USR,
	JRST	CPOPJ1

;SUBROUT TO READ READ QUOTAS INTO B,C,D

GETQU:	PUSHJ	P,R.USR		;READ RESERVED QUOTA
	  PJRST	MSG262
	MOVEM	A,B		;B=QTR
	PUSHJ	P,R.USR		;READ FIRST COME, FIRST SERVED QUOTA
	  PJRST	MSG262
	MOVEM	A,C		;C=QTF
	PUSHJ	P,R.USR		;AND LOGGED-OUT QUOTA
	  PJRST	MSG262
	MOVEM	A,D		;D=QTO
	JRST	CPOPJ1

MSG261:	MOVEI	M,NQFM
	JRST	NOQUO
MSG262:	MOVEI	M,CRQFM
	JRST	NOQUO
MSG263:	MOVEI	M,WFVNQM
	JRST	NOQUO
MSG264:	MOVEI	M,NEQFM
NOQUO:	PJRST	MSGTTY


	U(QUOPPN)
	U(QUODFR)
	U(QUODFF)
	U(QUODFO)
	U(QUODEF)
	;NO QUOTAS IN QUOTA.SYS SO TRY AUXACC.SYS
GETAQ1:	MOVE	A,[PHOPEN!14]
	HRLZI	B,(SIXBIT .SYS.)
	MOVEI	C,RH.USR
	OPEN	USR,A
	  PJRST	MSG262
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR ONE BUFFER
	MOVE	A,[SIXBIT .AUXACC.]
	MOVSI	B,(SIXBIT .SYS.)
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;AUXACC.SYS
	  PJRST	MSG261		;LOOKUP FAILED
	PUSHJ	P,R.USR		;PASSOVER THE NULL WORD
	  PJRST	GETAQ9		;SOMETHING IS WRONG HERE
GETAQ2:	PUSHJ	P,R.USR		;READ WORD 0  =  -1
	  PJRST	GETAQ9		;READ ERROR OR NO ENTRY
	AOJN	A,MSG264	;NO ENTRY
	PUSHJ	P,R.USR		;NUMBER OF WORDS REMAINING IN THIS ENTRY
	  JRST	GETAQ9		;
	MOVEI	D,-1(A)		;DONT COUNT THE "P,,P" WORD
	PUSHJ	P,R.USR		;READ THE "P,,P" WORD
	  JRST	GETAQ9		;
	CAML	A,QUOPPN	;COULD THIS BE THE ENTRY?
	JRST	GETAQ4		;YES
GETAQ3:	PUSHJ	P,R.USR		;NO -- SO PASS OVER THIS ENTRY
	  JRST	GETAQ9		;
	SOJG	D,GETAQ3	;
	JRST	GETAQ2		;AND TRY THE NEXT ONE

	;EITHER THIS IS IT OR ITS NOT HERE
GETAQ4:	CAME	A,QUOPPN	;EXACT MATCH
	CAMN	A,QUODEF	;OR DEFAULT PROG NUMBER
	JRST	GETAQ5		;YES
	CAMG	A,QUODEF	;TEST FOR OUT OF RANGE
	JRST	GETAQ3		;  NO, KEEP READING
	PJRST	MSG264		;NO -- NOT HERE
GETAQ5:	PUSHJ	P,R.USR		;READ FILE-STR NAME
	  JRST	GETAQ9		;
GETAQ6:	CAMN	A,FSNAME	;IS THIS THE FILE-STR?
	JRST	GETQU4		;YES -- GET QUOTAS AND EXIT
	SUBI	D,5		;NO -- SKIP OVER THIS FILE-STR
	JUMPLE	D,MSG264	;ANY MORE FILE-STRS?  TOO BAD
	MOVEI	C,5		;YES
GETAQ7:	PUSHJ	P,R.USR		;SKIP OVER THE CURRENT ONE
	  JRST	GETAQ9		;
	SOJG	C,GETAQ7	;
	JRST	GETAQ6		;AND TRY THE NEXT ONE

GETAQ9:	STATZ	USR,20000	;EOF?
	PJRST	MSG264		;YES -- NO QUOTAS
	PJRST	MSG262		;READ ERRROR
IFE MNTSW,<XLIST>
IFN MNTSW,<

;SUBROUTINE TO SET UP A UFD FOR USE  V002
;ARGS	A=USER'S PPN
;	B=A+1=RESERVED QUOTA
;	C=B+1=FIRST COME FIRST SERVED QUOTA
;	D=C+1=LOGGED OUT QUOTA
;	N1=N+1=MFD PPN
;	M=NAME OF STR
;	IO=ADDRESS OF ROUTINE TO TYPE A CHAR
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;	F=FLAG REGISTER
;	  L.WRTL=BIT IN LH OF F = 1 IF USER REQUESTS WRITE LOCK
;	  L.NCR=BIT IN LH F = 1 IF USER REQUESTS NO CREATE SET
;	  L.SIN=BIT IN LH F = 1 IF SINGLE ACCESS REQUESTED
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;IF D=-1 ASSUME NO UFD DESIRED - PERFORM OTHER OPERATIONS
;
;	USR=FREE I/O CHANNEL
;	US1=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDSET
;ERROR	DONT PROCEED (MESSAGE TYPED)
;OK	STR IS IN SEARCH LIST (WARNING MAY BE TYPED)
;
;ASSUMES SYMBOLS FOR AC'S ABOVE DEFINED, LOCATIONS CPOPJ, CPOPJ1 DEFINED
;
;USES U AND UU MACROS TO RESERVE STORAGE FOR EITHER HIGH OR LOW
;SEGMENT OPERATION.
;
;ROUTINES DEFINED HERE:
;
;MSG:	 TYPES STRING OF ASCII CHARS TO FIRST NULL
;SIXMSG:	 TYPES CONTENTS OF M AS SIXBIT CHARS
;CRLF:	 TYPES CARRIAGE RETURN LINE FEED
;OCTPRT: TYPES CONTENTS OF N AS OCTAL NUMBER
;MPOPJ:	 POP P,M FOLLWED BY POPJ P,
;R.USR:	 READS NEXT WORD FROM CHANNEL USR INTO A (BUFFER HEADER RH.USR, BUFFER B.USR)
;ADDSTR: ADD FILE STRUCTURE TO SEARCH LIST
;DISSTR: DELETE FILE STRUCTURE FROM SEARCH LIST

MNTSUB==1		;DECLARE IN CASE DISMOUNT SUBROUTINE ALSO APPEARS

UFDGIL==^D60		;TIMES TO TRY TO GET UFD INTERLOCK

RACEY==2		;VALUE OF LEVEL D FIELD IN STATES WORD FOR MONITOR
			;  WHICH INCLUDES RACE CONDITION STUFF
UFDSET:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	N1,UFDMPN	;AND MFD PPN
	MOVEM	M,UFDFSN	;AND NAME OF STR
	MOVE	N,B		;N=RESERVED QUOTA
	MOVE	M,C		;M=FCFS QUOTA
	MOVE	CH,D		;CH=LOGGED OUT QUOTA
	MOVEI	N1,UFDGIL	;NUMBER OF TIMES TO TRY FOR UFD INTERLOCK
UFDSTA:	MOVEI	B,ULKSTR	;USER-MODE UFD INTERLOCK FUNCTION
	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	STUFBS		;BUSY, SLEEP AND RETRY
	MOVE	B,UFDFSN
	MOVE	A,[PHOPEN!14]
	MOVEI	C,RH.USR
	OPEN	USR,A		;INIT THIS FILE STRUCTURE
	  JRST	UFDSE2		;HOW CAN THIS BE?
	AOJE	CH,UFDOK	;JUMP IF NO UFD OPERATIONS DESIRED
	SUBI	CH,1		;NO, RESTORE LOGGED OUT QUOTA
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED LOOKUP OF UFD
	SETZB	C,SRCBUF+4	;CLEAR REST OF LOOKUP BLOCK
	MOVE	A,[XWD SRCBUF+4,SRCBUF+5]
	BLT	A,SRCBUF+EXLLEN-1
	LOOKUP	USR,SRCBUF	;LOOKUP UFD
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE IN A
	JRST	UFDEX		;UFD EXISTS, LOOK AT IT
	TRNE	A,-1		;SKIP IF NO UFD
	JRST	UFDSE3		;THERE'S SOMETHING WRONG WITH THIS UFD

;HERE IF MUST CREATE A UFD

	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO ;AND LOGGED OUT QUOTA
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED ENTER OF UFD
	MOVE	A,[XWD RIPLOG,RIPDIR]	;SET DIRECTORY BIT AND LOGGED IN BIT
	MOVEM	A,SRCBUF+EXLSTS
	ENTER	USR,SRCBUF	;TRY TO CREATE A UFD
	  JRST	UFDSE1		;IDENTIFY ENTER FAILURE
	SETSTS	USR,17		;CHANGE TO DUMP MODE SO CLOSE WONT DUMP BUFFERS
	USETO	USR,2
	CLOSE	USR,		;AN EMPTY UFD
	JRST	UFDOK		;ALL SET
;HERE IF UFD ALREADY EXISTS

UFDEX:	MOVE	A,SRCBUF+.RBSTS	;ALLOWED TO RENAME?
	TRNE	A,.RBNDL
	JRST	UFDOK		;NO-THATS ALL
	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO ;AND LOGGED OUT QUOTA
	MOVSI	A,RIPLOG	;LOGGED IN BIT
	TDNN	A,SRCBUF+EXLSTS	;SKIP IF BIT ON IN UFD
	JRST	UFDEX2		;NO, CAN PROCEED
	HRRI	B,.GTNSW	;GET HIGHEST NUMBER ASSIGNED BY MONITOR
	HRLI	B,%NSHJB	;(NOT HIGHEST NUMBER AVAILABLE)
	GETTAB	B,		;GET NUMBER OF JOBS
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,(B)
	HRLZS	B		;LH B=-NUMBER OF REAL JOBS
UFDEX1:	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF+GOBNAM	;NAME OF STR
	MOVE	A,UFDUPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	A,1(B)		;A=NEXT JOB NUMBER
	MOVEM	A,CHRBUF+GOBJOB
	MOVEI	A,CHRBUF
	GOBSTR	A,		;SEE IF STR IS IN THAT JOB'S SEARCH LIST
	  JRST	.+2		;NOT IN THIS JOBS LIST OR NOT OUR PPN
	JRST	UFDOK		;OK IS IN SOMEBODY ELSES SEARCH LIST SAME PPN
	AOBJN	B,UFDEX1	;LOOP FOR ALL JOBS

;HERE TO LOOKUP ALL FILES AND RECOMPUTE RIBUSD

	MOVSI	A,(PHOPEN)
	SETZ	C,
	MOVE	B,UFDFSN
	MOVEM	B,CHRBUF	;SAVE FOR DSKCHR
	OPEN	US1,A		;OPEN FILE STRUCTURE
	  JRST	UFDSE2
	SETZM	SRCBUF+EXLUSD	;CLEAR USED WORD
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JRST	UFDS9A
ALLK1:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDRER		;READ ERROR (MAY BE EOF)
	MOVEM	A,SECBUF+EXLNAM ;FILE NAME
	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD (EXT)
	  JRST	UFDRER		;READ ERROR
	SKIPN	SECBUF+EXLNAM	;SKIP IF REAL NAME
	JRST	ALLK1		;UFD'S DO HAVE ZEROS
	HLLZM	A,SECBUF+EXLEXT ;STORE EXT
	SETZM	SECBUF+EXLPPN	;CLEAR PPN WORD
	MOVEI	A,EXLALC
	MOVEM	A,SECBUF	;SET NUMBER OF ARGS TO GET ALC WORD
	LOOKUP	US1,SECBUF	;LOOKUP FILE
	  JRST	ALLK1		;SOMETHING WRONG, FORGET IT
	MOVE	A,SECBUF+EXLALC ;GET BLOCKS ALLOCATED FOR THIS FILE
	ADDM	A,SRCBUF+EXLUSD ;COUNT FOR ALL FILES
	JRST	ALLK1
;HERE IF READ ERROR (MAY BE EOF)

UFDRER:	CLOSE	US1,
	GETSTS	USR,A		;A=ERROR CODE
	MOVEI	M,[ASCIZ .UFD Read error, Status = .]
	TRNN	A,20000		;SKIP IF ERROR, NOT EOF
	JRST	UFDSE4		;TELL USER ABOUT ERROR, NO UFD
	MOVE	B,CHRBUF+CHRUFB	;PREVIOUS UFBTAL
	CAMN	B,[XWD 400000,0]
	JRST	UFDEX3
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET NEW UFBTAL
	  JRST	UFDS9A
	SUB	B,CHRBUF+CHRUFB	;OLD-NEW=-DIFFERENCE FREE
	ADDM	B,SRCBUF+EXLUSD	;=DIFFERENCE ALLOCATED
	JRST	UFDEX3		;ALL SET


UFDEX2:	IORM	A,SRCBUF+EXLSTS	;MAKE SURE LOGGED IN BIT ON
UFDEX5:	LDB	A,LVDBTS
	CAIL	A,RACEY
	SETOM	SRCBUF+EXLUSD	;USE MONITOR'S COPY OF UFBTAL TO COMPUTE RIBUSD
UFDEX3:	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED RENAME
	RENAME	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT
	JRST	UFDOK

	MOVEI	M,[ASCIZ .UFD RENAME Failure .]
	JRST	UFDSE4

UFDSE3:	MOVEI	M,[ASCIZ .UFD LOOKUP Failure .]
UFDSE4:	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,A		;N=ERROR CODE
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
	JRST	UFDOK

UFDSE1:	MOVEI	M,[ASCIZ .UFD ENTER Failure .]
	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,SRCBUF+EXLEXT
	PUSHJ	P,OCTPRT
UFDOK:	MOVEI	A,UFDFSN
	DSKCHR	A,		;NEED TO SEE IF MC=0
	  JRST	UFDSE2		;BAD LUCK
	TLNN	A,D.MC		;SKIP IF MOUNT COUNT=0
	JRST	UFDOK1		;NO
	SETZ	N,		;YES, REDEFINE STR
	TLNE	F,L.SIN		;IF SINGLE REQUEST, PASS ON TO MOUNT UUO
	TLO	N,S.SIN
	MOVEM	N,MNTFSN
	MOVE	B,UFDFSN	;AND FILE STRUCTURE NAME
	MOVEM	B,MNTTYP
	SETOM	UFDDMJ		;USE JOB'S JOB NUMBER
	SETOM	UFDDMP		;AND PPN
	MOVEI	A,RDFFST
	MOVEM	A,UFDMTP	;SET FUNCTION
	MOVEI	A,UFDMTP
	STRUUO	A,		;REDEFINE THE FILE STRUCTURE
	  JRST	UFDS7A		;NO, DONT
UFDOK1:	PUSHJ	P,ADDSTR	;ADD STR TO JOBS SEARCH LIST

;HERE TO CLEAR UFD INTERLOCK

	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	  JRST	CPOPJ1		;WHAT?
	JRST	CPOPJ1		;ALL DONE
;HERE WHEN UFD INTERLOCK IS BUSY - SLEEP AND RETRY

STUFBS:	CAME	A,[XWD 3,B]	;TEST FOR ERROR CODE
	JSP	N,NEVERR	;  YES, FATAL ERROR
	MOVEI	A,1
	SLEEP	A,	;SLEEP FOR 1 SECOND
	SOJG	N1,UFDSTA
	UFDSEM <UFD Interlock busy>

UFDSE2:	PUSHJ	P,STUFCL
	  JFCL
	UFDSEM <Can't OPEN>


;SUBROUTINE TO TEST/SET OR CLEAR UFD INTERLOCK
;ENTER AT STUFCL TO CLEAR
;ENTER AT STUFC1 WITH B=FUNCTION
;RETURN POPJ IF FAILED
;RETURN CPOPJ1 IF OK

STUFCL:	MOVEI	B,UCLSTR	;FCN TO CLEAR INTERLOCK
	PUSHJ	P,UFDLUU	;DO THE CLEAR
	JSP	A,NEVERR	;WHAT???
	PJRST	CONCOM		;EXIT VIA RTE. TO TURN ^C INTERCEPT BACK ON
STUFC1:	PUSHJ	P,CONCOF	;DISABLE ^C-INTERCEPT WHILE INTERLOCK'D UFD
	PUSHJ	P,UFDLUU	;DO FCN AS CALLED
	 POPJ	P,		;FAILED
	PJRST	CPOPJ1		;OK , SKIP RETURN

UFDLUU:	LDB	A,LVDBTS
	CAIGE	A,RACEY
	JRST	CPOPJ1
	MOVE	A,[XWD 3,B]
	MOVE	C,UFDFSN
	MOVE	D,UFDUPN
IFE DBUGSW,<
	STRUUO	A,
	  POPJ	P,
> ;END IFE DBUGSW
	PJRST	CPOPJ1

;SUBROUTINE TO SET UP HEADER FOR EXTENDED LOOKUP/ENTER/RENAME OF UFD

SETEXL:	MOVEI	A,EXLLEN-1	;LENGTH OF ARG LIST
	MOVEM	A,SRCBUF
	MOVE	A,UFDUPN	;NAME IS USER'S PPN
	MOVEM	A,SRCBUF+EXLNAM
	MOVSI	A,(SIXBIT .UFD.)	;EXT IS UFD
	HLLM	A,SRCBUF+EXLEXT
	MOVE	A,UFDMPN	;DIRECTORY IS MFD
	MOVEM	A,SRCBUF+EXLPPN
	POPJ	P,

R.USR:	SOSLE	RH.USR+2
	JRST	R.USOK
	INPUT	USR,
	STATZ	USR,760000
	POPJ	P,
R.USOK:	ILDB	A,RH.USR+1
	JRST	CPOPJ1

;THIS ROUTINE ADDS FILE STRUCTURE NAMED IN UFDFSN TO THE
;FILE STRUCTURE SEARCH LIST, OR DELETES THE FILE STRUCTURE FROM IT.
;ENTER AT ADDSTR TO ADD OR AT DISSTR TO DELETE.

DISSTR:	MOVEI	A,B
	MOVE	B,UFDFSN
	JOBSTR	A,
	  POPJ	P,		;NOT IN SEARCH LIST, OK
	TLOA	F,L.DIS		;SET FLAG NOTING DISMOUNT
ADDSTR:	TLZ	F,L.DIS		;CLEAR FLAG, NOTING ADD
	SETZB	E,UFDDMF	;SET FLAG TO REMEMBER
	TLNE	F,L.DIS		;SKIP IF ADDING AN STR
	AOS	UFDDMF		;SET FLAG TO DELETE
	MOVEI	A,SRCDSL
	MOVEM	A,UFDMTP	;SET FUNCTION TO DEFINE SEARCH LIST
	SETOB	B,UFDDMJ	;START JOBSTR WITH -1
	SETOM	UFDDMP		;CLEAR JOB AND PPN SO USES VALUES FOR THIS JOB
	TLZ	F,L.PEND	;BORROW THIS BIT TO MEAN FILE STRUCTURE THERE
MAKSRC:	MOVE	A,[XWD 3,B]
	JOBSTR	A,		;GET USER'S NEXT FILE STRUCTURE
	  JRST	UFDSE8		;SYSTEM PROBLEM
	TLNN	F,L.DIS		;SKIP IF DISMOUNT
	JUMPE	B,MAKSR2	;MOUNT STOPS AT FENCE
	AOJE	B,MAKSR2	;JUMP IF END OF LIST
	SOS	B
	MOVEM	B,MNTTYP+1(E)
	JUMPE	B,MAKSR1	;DONT DSKCHR THE FENCE
	MOVE	A,[XWD 1,B]
	DSKCHR	A,		;GET CURRENT STATUS OF THIS FILE STRUCTURE
	  JRST	UFDSE9		;CANT FAIL
	MOVE	B,MNTTYP+1(E)	;GET BACK FILE STRUCTURE NAME
	CAME	B,UFDFSN	;AND SEE IF WE ALREADY EXIST
	JRST	MAKSR1		;NO
	TLO	F,L.PEND
	TLNE	F,L.DIS		;SKIP IF ACTUALLY DELETING
	JRST	MAKSRC		;AND IGNORE THIS FILE STRUCTURE
	TRNN	F,R.PAS		;TEST FOR /PASSIVE
	 JRST	MAKSR0		;  NO, JUMP TO LOOK AT IT
	SETZM	MNTTYP+1(E)	;FORGET F/S IN ACTIVE S/L
	JRST	MAKSRC		; & KEEP ON LOOKING
MAKSR0:	MOVE	A,D
	LSH	A,^L<S.SWL>-^L<L.WRTL> ;ROTATE TO ALIGN BITS
	XOR	A,F		;COMPARE WRITE LOCK STATES
	TLNE	A,L.WRTL	;TEST FOR RQSTED .NE. PRESENT
	TLC	D,S.SWL		;  YES, INVERT THE PRESENT SETTING
	MOVE	A,D		;COPY CURRENT SETTINGS AGAIN
	LSH	A,^L<S.NOC>-^L<R.NOC>-^D18 ;ROTATE TO ALIGN BITS
	XOR	A,F		;COMPARE NOCREATE STATES
	TRNE	A,R.NOC		;TEST FOR RQSTED .NE. PRESENT
	TLC	D,S.NOC		;  YES, INVERT THE PRESENT SETTING
	SETZ	C,
MAKSR1:	MOVEM	C,MNTTYP+2(E)	;SAVE PROJECT,PROGRAMMER NUMBER
	MOVEM	D,MNTTYP+3(E)	;SAVE WRITE PROTECT REQUEST
	ADDI	E,3
	JRST	MAKSRC		;LOOP FOR ALL USER'S FILE STRUCTURES

UFDSE8:	UFDSEM <System error - JOBSTR UUO Failed>
UFDS9A:	PUSHJ	P,STUFCL
	  JFCL
UFDSE9:	UFDSEM <System error - DSKCHR UUO Failed>
MAKSR2:	TLZE	F,L.PEND
	 JRST	MAKSR3		;DONT ADD FILE STRUCTURE 
	TRNE	F,R.PAS		;TEST FOR /PASSIVE
	 JRST	MAKPAS		;  YES, JUMP TO PUT IN PASSIVE S/L
MAKSRA:	SKIPN	MNTTYP+1(B)	;B STARTS AT 0 FROM ABOVE
	 JRST	MAKSRB		;THE FENCE IS A 0
	ADDI	B,3
	CAIE	B,(E)		;IF END, NO FENCE
	JRST	MAKSRA
	JRST	MAKSR4		;OK TO PROCEED
MAKSRB:	MOVE	C,E		;IF FENCE, MUST MOVE EVERYTHING DOWN 1 ENTRY
MAKSRL:	CAIG	B,(C)		;SKIP IF MORE
	JRST	MAKSR4
	MOVE	A,MNTTYP(C)
	MOVEM	A,MNTTYP+3(C)
	SOJA	C,MAKSRL
MAKPAS:	SKIPN	MNTTYP+1(E)	;TEST FOR POINTING AT FENCE
	ADDI	E,3		;  NO, POINT AT IT NOW
	MOVE	B,E		;POINT AT PLACE WHERE F/S GOES
MAKSR4:	MOVE	A,UFDFSN
	MOVEM	A,MNTTYP+1(B)	;ADD NEW FILE STRUCTURE
	SETZB	A,MNTTYP+2(B)
	TLNE	F,L.WRTL
	TLO	A,S.SWL		;A SET TO 0 ABOVE
	TRNE	F,R.NOC		;TEST FOR /NOCREATE
	TLO	A,S.NOC		;  YES, SET THE BIT
	MOVEM	A,MNTTYP+3(B)
	ADDI	E,3
MAKSR3:	MOVEI	A,UFDMTP
	HRLI	A,4(E)		;LENGTH OF ARGUMENT LIST
	STRUUO	A,
	  JRST	UFDSE6
	POPJ	P,

UFDSE6:	TLNE	F,L.DIS
	JRST	UFDSE5
	MOVEI	N1,[ASCIZ .Can't add to your File Structure search list .]
	JRST	UFDSSE
UFDSE5:	MOVEI	N1,[ASCIZ .Can't remove file structure from search list .]
	JRST	UFDSSE
UFDS7A:	PUSHJ	P,STUFCL
	  JFCL
UFDSE7:	MOVEI	N1,[ASCIZ .Can't redefine File Structure .]
UFDSSE:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	MOVE	N,A
	PUSHJ	P,OCTPRT
	PJRST	CRLF

UFDSMP:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	PJRST	CRLF
;SUBROUTINE TO OUTPUT ACCUMULATOR M AS SIXBIT CHARS

SIXTTY:	MOVEI	IO,W.TTY
SIXMSG:	PUSH	P,M
	MOVE	M,[POINT 6,(P)]	;M=BYTE POINTER
SIXMSL:	ILDB	CH,M
	JUMPE	CH,MPOPJ	;QUIT AT FIRST NULL BYTE
	ADDI	CH,40
	PUSHJ	P,0(IO)
	TLNE	M,770000	;OR END OF WORD
	JRST	SIXMSL
MPOPJ:	POP	P,M
	POPJ	P,

;THIS ROUTINE OUTPUTS ACCUMULATOR N AS AN OCTAL NUMBER

OCTPRT:	IDIVI	N,^D8
	HRLM	N1,0(P)		;SAVE EACH CHAR ON THE STACK
	SKIPE	N
	PUSHJ	P,OCTPRT		;RECURSE AS NECESSARY
	HLRZ	CH,0(P)		;NOW RETRIEVE LAST CHAR
	ADDI	CH,"0"		;MAKE ASCII
	JRST	0(IO)		;OUTPUT AND ASCEND A LEVEL- EXIT WHEN DONE

CRLF:	MOVEI	M,[ASCIZ .
.]
MSG:	HRLI	M,(<POINT 7,>)
MSGL:	ILDB	CH,M
	JUMPE	CH,CPOPJ
	PUSHJ	P,0(IO)
	JRST	MSGL
LVDBTS:	POINT	3,STATES,9

UU(RH.USR,3)
UU(B.USR,205)
UU(CHRBUF,CHRLEN)
UU(SRCBUF,EXLLEN)
UU(SECBUF,EXLALC+1)
U(UFDMPN)
U(UFDUPN)
U(UFDFSN)
U(UFDMTP)
U(UFDDMJ)
U(UFDDMP)
U(UFDDMF)
MNTTYP=UFDDMF
U(MNTFSN)
U(MNTNUM)
	SRWPS==3		;WORDS PER STR. ENTRY IN SEARCH LIST
	STRJMX==9		;MAX. NO OF STRS PER JOB
UU(MNTBLK,SRWPS*STRJMX)

>	;END CONDITIONAL ON MNTSW

IFE MNTSW,<LIST>
IFE MNTSW,<XLIST>
IFN MNTSW,<

;SUBROUTINE TO CLEAR A FILE STRUCTURE FOR DISMOUNT  V002
;ARGS	A=USER'S PPN
;	B=A+1=JOB NUMBER
;	C=B+1
;	D=C+1=LOGGED OUT QUOTA (-1 TO IGNORE)
;	N1=N+1=MFD PPN
;	M=NAME OF FILE STRUCTURE
;	IO=ADDRESS OF ROUTINE TO TYPE A CHARACTER
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;	F=FLAG REGISTER
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;	USR=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDCLR
;ERROR	DONT PROCEED A=CODE (0=CANT OPEN 1=QUOTA EXCEEDED) MESSAGE TYPED
;OK	FILE STRUCTURE REMOVED FROM JOBS SEARCH LIST (WARNING MAY BE TYPED)
UFDCLR:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	B,UFDJBN	;AND JOB NUMBER
	MOVEM	D,UFBLOQ	;LOG-OUT QUOTA
	MOVEM	N1,UFDMPN	;MFD PPN
	MOVEM	M,UFDFSN	;STR NAME
	MOVEI	B,ULKSTR
	MOVEI	N1,UFDGIL	;TIMES TO TRY FOR UFD INTERLOCK
UFDCLA:	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	UFDCAA		;BUSY, SLEEP AND RETRY
	MOVE	A,[PHOPEN!14]
	MOVE	B,M		;STR NAME
	MOVEI	C,RH.USR
	OPEN	USR,A		;OPEN FILE STRUCTURE
	  JRST	UFDCAB
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED LOOKUP OF UFD
	LOOKUP	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE
	JRST	UFDCLC		;UFD EXISTS
	TRNN	A,-1		;SKIP IF UFD EXISTS, LOOKUP FAILED
	JRST	UFDCLJ		;NO UFD

;HERE IF UFD LOOKUP ERROR

	MOVEI	M,[ASCIZ .UFD LOOKUP Failure .]
	JRST	UFDCFA		;TYPE MESSAGE

UFDCLC:	HRRI	B,.GTNSW	;GET HIGHEST JOB NUMBER ASSIGNED
	HRLI	B,%NSHJB	;(NOT HIGHEST ONE AVAILABLE)
	GETTAB	B,		;GET NUMBER OF JOBS IN SYSTEM
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,(B)		;B=-NUMBER OF REAL JOBS (NOT NULL JOB)
	HRLZS	B
UFDCCA:	MOVE	A,UFDFSN	;NAME OF FILE STRUCTURE
	MOVEM	A,CHRBUF+GOBNAM	;STORE IN GOBSTR BLOCK
	MOVE	A,UFDUPN	;USER'S PPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	C,1(B)		;JOB NUMBER
	MOVEM	C,CHRBUF+GOBJOB
	MOVEI	A,CHRBUF
	CAME	C,UFDJBN	;IF THIS JOB, AVOID GOBSTR
	GOBSTR	A,		;SEE IF IN THIS JOBS SEARCH LIST
	  JRST	UFDCCB		;NO
	JRST	UFDCLJ		;NO, SOMEBODY ELSE COMING
UFDCCB:	AOBJN	B,UFDCCA	;NOT IN THAT JOBS SEARCH LIST

;THE STRUCTURE TO BE REMOVED IS ONLY IN THIS USER'S SEARCH LIST
;CHECK TO SEE IF F/S HAS /RONLY SET AND IF SO CLEAR IT BEFORE CONTINUING

	MOVEI	A,B		;IN THIS USER'S SEARCH LIST?
	MOVE	B,UFDFSN	;F/S
	JOBSTR	A,PHONLY
	 JRST	UFDCCD		;NO, CANNOT (DO NOT NEED TO) CHANGE S/L
	TDZ	F,[L.WRTL,,R.PAS!R.NOC]	;CLEAR THESE CONDITIONS
	PUSHJ	P,ADDSTR	; AND CHANGE S/L TO NOT HAVE THESE CONDITIONS
UFDCCD:	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JRST	UFDCLJ
	MOVE	B,SRCBUF+EXLQTO	;USE UFD QUOTA
	SKIPGE	UFBLOQ		; IF NONE IN QUOTA.SYS OR AUXACT.SYS
	MOVEM	B,UFBLOQ
	MOVE	B,CHRBUF+CHRUFB
	CAMN	B,[XWD 400000,0]
	JRST	UFDCCC		;IGNORE QUOTA TEST
	MOVE	A,SRCBUF+EXLQTF	;FCFS QUOTA

REPEAT 0,<ADD	A,SRCBUF+EXLQTR	;RESERVED QUOTA WHEM IMPLEMENTED>

	SUB	A,B	;QUOTA IN-FREE=USED
	SUB	A,UFBLOQ	;-QUOTA OUT=BLOCKS OVER QUOTA
	JUMPG	A,UFDCLM	;JUMP IF OVER QUOTA

;HERE TO SEE IF UFD EMPTY

UFDCCC:	MOVE	B,SRCBUF+.RBSTS	;ALLOWED TO RENAME/DELETE?
	TRNE	B,.RBNDL
	JRST	UFDCLJ		;NO-THATS ALL
	SKIPN	B,SRCBUF+EXLSIZ	;WORDS WRITTEN IN UFD
	JRST	UFDCLI		;NO WORDS WRITTEN - DELETE UFD
UFDCLD:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDCDA		;JUMP IF ERROR OR EOF
	JUMPN	A,UFDCLF	;JUMP IF NON-EMPTY ENTRY IN UFD
	SOJG	B,UFDCLD	;STILL EMPTY SO FAR, LOOP FOR WORDS WRITTEN

	JRST	UFDCLI		;NO NON-ZERO ENTRIES, DELETE UFD

UFDCDA:	GETSTS	USR,N
	TRNE	N,20000		;SKIP IF EOF
	JRST	UFDCLF		;EOF
	MOVEI	M,[ASCIZ .UFD Read error, Status = .]
	PUSHJ	P,MSG
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
UFDCLF:	MOVSI	A,RIPLOG	;LOGGED IN BIT
	ANDCAM	A,SRCBUF+EXLSTS	;CLEAR IN RENAME ARG LIST
	LDB	A,LVDBTS
	CAIL	A,RACEY
	SETOM	SRCBUF+EXLUSD	;REQUEST MONITOR TO COMPUTE RIBUSD
	CLOSE	USR,		;CLOSE TO GET RID OF /RONLY-SEE EDITS 54
				; AND 62 IN REVISION HISTORY
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED RENAME
	RENAME	USR,SRCBUF	;EXTENDED RENAME
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE IN A
	JRST	UFDCLJ
	MOVEI	M,[ASCIZ .UFD RENAME Failure .]
UFDCFA:	PUSHJ	P,MSG
	HRRZ	N,A
	PUSHJ	P,OCTPRT	;PRINT ERROR CODE
	PUSHJ	P,CRLF
	JRST	UFDCLJ		;GIVE UP

UFDCLI:	SETZB	A,B
	SETZB	C,D
	RENAME	USR,A		;DELETE UFD
	  JFCL
UFDCLJ:	PUSHJ	P,DISSTR	;TAKE STR OUT OF JOB'S SEARCH LIST
	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	  JRST	CPOPJ1
	JRST	CPOPJ1		;EVERYBODY HAPPY

UFDCLM:	MOVEI	M,[ASCIZ .Exceed Logged Out Quota .]
	PUSHJ	P,MSG
	MOVE	N,UFBLOQ
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ . by .]
	PUSHJ	P,MSG
	MOVE	N,A
	PUSHJ	P,DECPRT
	PUSHJ	P,STUFCL
	  JFCL
	MOVEI	M,[ASCIZ . blocks
.]
	MOVE	A,[CNOPR]	;GET GETTAB PARMS FOR 'OPR' TTY NAME
	GETTAB	A,		;GET 'OPR' TTY NAME
	  MOVSI	A,'CTY'		;  FAILED, ASSUME 'CTY'
	CAMN	A,TTYLIN	;TEST FOR CURRENT LINE # = 'OPR'
	PUSH	P,[UFDCCC]	;  YES, THEN SET UP A RETURN ADDRESS
				;	FOR THE FOLLOWING 'PJRST MSG'
				;	SO DISMOUNT WILL PROCEED NORMALLY
	MOVEI	A,UFDQEE
	PJRST	MSG

UFDCAA:	CAME	A,[XWD 3,B]	;TEST FOR ERROR CODE
	 JSP	N,NEVERR	;  YES, FATAL ERROR
	MOVEI	A,1
	SLEEP	A,
	SOJG	N1,UFDCLA
	UFDSEM <UFD Interlock busy>

UFDCAB:	PUSHJ	P,STUFCL
	  JFCL
	UFDSEM <Can't OPEN>

U(UFBLOQ)

DECPRT:	IDIVI	N,^D10
	HRLM	N1,0(P)		;SAVE EACH CHAR ON THE STACK
	SKIPE	N
	PUSHJ	P,DECPRT		;RECURSE AS NECESSARY
	HLRZ	CH,0(P)		;NO RETRIEVE THE LAST CHAR
	ADDI	CH,"0"
	JRST	0(IO)		;OUTPUT AND ASCEND A LEVEL OR EXIT

U(UFDJBN)

>	;END CONDITIONAL ON MNTSW
SUBTTL	MESSAGES
;TEXT MESSAGES

DEFINE MT (ADR,TEXT) <
ADR:	XLIST
	ASCIZ \TEXT\
	LIST>

MT RQSMSG,<Request queued
>
MT CLSMSG,<F(ile),Z(ero),R(ecall),D(elete),L(ist),C(heck),W(ait),H(elp)
*>
MT TAPMSG,<Tape ID:>
MT MNYMSG,<?Too many files. Last processed is >
MT FILMSG,<Files: >
MT MISMSG,<?Can't find file >
MT PROTMS,<?Protection failure >
;MT PNDMSG,<Pending:
;>
MT CERMSG,<?Syntax error
>
MT CMMMSG,<
?Have Operator start OMOUNT, then try again.
>
MT IOMSG1,<?System I/O Error at >
MT IOMSG2,< Status = >
REPEAT 0,<
MT MOHELP,<
/WRITE:YES	Permit writing (Default for Disk)
/WRITE:NO	Prohibit writing (Default for Tapes)
/VID:'text'	Visual IDentification (REQUIRED for Tapes)
/ACTIVE		Mount Disk in user's active search list
/PASSIVE  *     Mount Disk in user's passive search list
/CREATE	  *     Permit creation of files on this structure
/NOCREATE	Prohibit creation of files on this structure
/WAIT		Wait on pending MOUNT requests
/NOWAIT		Bypass Waiting... msg if to be queued
/CHECK		Check pending MOUNT requests
/PAUSE		Pause before queueing MOUNT requests
/HELP		Type this text  (* = Default)
/MULTI	*	Allow multiple access - Disk only
/SINGLE		Restrict access by other users - Disk only
/WENABL		Same as /WRITE:YES
/WLOCK		Same as /WRITE:NO
/RONLY		Same as /WRITE:NO
>

MT DIHELP,<
/RELEASE *      Release control of the device - Default for Tape
/KEEP		Retain control of the device for further use
/REASSIGN:n	Reassign the device to Job 'N'
/UNLOAD		Unload the device - Default for Tape
/REWIND		Rewind the device
/STAY		Do not reposition the device - Default for Disk
/WAIT		Wait on pending DISMOUNT requests
/CHECK		Check pending DISMOUNT requests
/REMOVE		Same as /UNLOAD
/PAUSE		Pause before queueing DISMOUNT requests
/HELP		Type this text  (* = Default)
>
>;	END REPEAT 0

MT NORMMS,<?No room in queue, try again later>
MT STAR,<
*>
MT NOLOGM,< Must not be a logical name>
MT NOWRTM,< Must not be locked or write prot.>

IFN MNTSW,<

MT FMDM,<FILE, MOUNT or DISMOUNT
*>
MT ARMM,< already mounted on >
MT UNMM,< not mounted
>
MT NRM,< not ready
>
MT PBWM,<Pause...(^C to quit, <CR> to queue request)
>
MT LEQM,<QUOTA.SYS LOOKUP Failure>
MT TMRM1,< has only >
MT TMRM2,< unit(s)
>
MT NSAM,<Other users--Cannot Single-Access
>
MT SABJM,<?Single Access by Job >
MT NQFM,<LOOKUP Failure for AUXACC.SYS
>
MT CRQFM,<QUOTA.SYS or AUXACC.SYS Read error
>
MT WFVNQM,<QUOTA.SYS Wrong format version
>
MT NEQFM,<No entry in QUOTA.SYS or AUXACC.SYS
>
MT SWERM1,<?Undefined switch />
SWERM2==SWERM1
MT NEDAM,<Not enough drives available
>
MT IMNTM,<Structure already mounted
[Mount count = >
MT IMNTM1,<]
>
MT OPRDY,<Request queued to ready drives
>
MT MNTD,< Mounted
>
MT OPMNT,<Request queued to mount units
>
MT DISDON,< Dismounted
>
MT DNAM,< Not available>
MT WKTM,< Wrong controller type>
MT WUTM,< Wrong unit type>
MT IKON,< Illegal drive name>
MT KDNAM,< No drive available on this controller>
MT DINCOM,< Dismount incomplete>
MT NDFD,<%No Device for Directory>
MSG100:	PUSHJ	P,SIXTTY
	PTYPE	< Not available>

MSG101:	MOVE	M,LOGNAM
	PUSHJ	P,SIXTTY
	PTYPE	< Logical name in use (Name ignored)>

MSG102:	TYPE	<Can't OPEN >
MSG103:	MOVE	M,B
	HRRZ	N,(P)
	PUSHJ	P,SIXTTY
	TYPE	< at loc >
	JRST	MSG902

MSG104:	TYPE	<Can't Assign >
	JRST	MSG103

MSG105:	MOVE	M,DVVNAM
	PUSHJ	P,SIXTTY
	XTYPE	< Not Assigned>	;QUIT IMMEDIATELY

MSG110:	MOVEI	M,RQSMSG	;POINT AT 'REQUEST QUEUED' MSG
	PJRST	MSGTTY		;TYPE IT & RETURN

MSG111:	PTYPE	<Waiting...2 ^C's to Exit>

REPEAT 0,<			;THE FOLLOWING 2 MESSAGES HAVE BEEN SUGGESTED
				;AS ALTERNATIVES TO THE RELEASED MESSAGES

MSG112:	TYPE	<None pending for your job [> ;TYPE START OF MSG
	HLRZ	N,USRPPN	;GET PROJECT #
	PUSHJ	P,OCTPRT	; & TYPE IT
	PUSHJ	P,COMMA		;OUTPUT A COMMA
	HRRZ	N,USRPPN	;GET PROG #
	PUSHJ	P,OCTPRT	; & TYPE IT
	PUSHJ	P,RBRKET	;TYPE A "]"
	PJRST	CRLF		;END THE MSG

MSG113:	PTYPE	<System can't handle request at this time.
Please be patient and the problem will be corrected momentarily>

>;	END REPEAT 0

MSG112:	PTYPE	<None pending for your job>

MSG113:	PTYPE	<No Opr. job for requests>

MSG900:	HRRZ	N,(P)
NEVMSG:		;'SHOULDNT GET HERE' ERRORS
MSG901:	TYPE	<System error at loc >
MSG902:	HRRZS	N
	PUSHJ	P,OCTPRT
	PJRST	CRLF

ERR101:	XTYPE	<?Requires Device Name
>

ERR103:	XTYPE	<?Program not privileged - Ignored!
>

IFE LOGSW, <
ERR104:	XTYPE	<?Requires Logical Name
>
>;	END OF	IFE LOGSW

ERR105:	XTYPE	<? /REELID Requires Magtape
>

ERR110:	XTYPE	<?FILE R illegal if DSK: contains no UFD
>

ERR120:	TYPE	<?Unable to create request in queue, ENTER code = >
	MOVE	N,B
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
	JRST	TERMIN

ERR130:	XTYPE	<?Ersatz devices not mountable
>

ERR503:	XTYPE	<?Monitor must be 5.03 or later
>

ERR900:	PUSHJ	P,MSG900
	JRST	ERR912
NEVERR:			;'NEVER GET HERE' ERRORS GET HERE
ERR901:	PUSHJ	P,MSG901
	JRST	ERR912

ERR911:	TYPE	<Operator not on duty!
>
	TRNN	F,R.SHOV	;IS USER SHOVING IT?
	 JRST	ERR912		;NO, GO SEND 'MOUNT INCOMPLETE'
	TYPE	<Shoving request anyway...
>
	POPJ	P,		;AND RETURN TO CALLER

DISFI1:	MOVE	M,CMDFSN	;GET TYPED-IN FILE STR NAME
	MOVEM	M,DVVNAM	;STORE AS NAME TO OUTPUT IN ERR912/ERR913
				;FALL THRU TO ERR912

ERR912:	MOVEI	IO,W.TTY	;POINT AT I/O RTN
	PUSHJ	P,QUEST
ERR913:	MOVE	M,DVVNAM
	PUSHJ	P,SIXTTY
	MOVE	M,CMDCHR	;GET COMMAND TYPEFLAG
	CAIN	M,"M"		;TEST FOR 'MOUNT'
	JRST	E913M		;  YES, JUMP
	CAIN	M,"D"		;TEST FOR 'DISMOUNT'
	JRST	E913D		;  YES, JUMP
	XTYPE	< FILE request not queued
>
E913D:	MOVEI	M,DINCOM	;POINT AT 'DISMOUNT INCOMPLETE'
	JRST	MSGRET		;GO TYPE & EXIT
E913M:				;HERE FOR MOUNT FAILURE
	XTYPE	< Mount Incomplete
>

>	;END CONDITIONAL ON MNTSW

IFE MNTSW,<
MT NODISM,<
DISMOUNT is not a legal command>
MT NOMNTM,<
MOUNT is not a legal command>
>	;END CONDITIONAL ON MNTSW

GOHELP:	OUTPUT	TTY,		;DUMP TTY OUTPUT BUFFER (JUST IN CASE)
	PUSHJ	P,.HELPR##	;CALL HELPER TO TYPE THE FACT FILE
	JRST	MONRET		;GO EXIT NOW

LOGERR:	MOVEI	M,[ASCIZ /? Must be logged in/] ;POINT AT MESSAGE
				;FALL THRU TO TYPE IT & EXIT

GOAWAY:
MSGRET:
ERREXI:
ALLFIN:
ERRRET:	PUSHJ	P,MSGTTY
ALLOVR:
MONRET:	OUTPUT	TTY,
TERMIN:	RESET			;RESET ALL I/O
	SKIPN	NOTLOG		;TEST FOR LOGGED IN
	JRST	GOEXIT		;  YES, THEN EXIT
	TTCALL	13,0		;CLEAR ^O IF ON
	  JFCL			;  (JUST IN CASE)
	OUTSTR	KJOB		;TYPE '.KJOB'
	LOGOUT			; & DIE
KJOB:	ASCIZ	/
.KJOB
./				;TRADITIONAL LOGOUT MSG

GOEXIT:				;HERE IF NORMAL EOJS
	EXIT	1,
	EXIT
SUBTTL	STORAGE, ET AL.
;DATA

MFDPPN:	XWD	1,1
SYSPPD:	XWD	1,4	;SYS PPN FOR LEVEL D
FSFPPN:	XWD	1,2	;FAILSA PPN (1,2)

IFN MNTSW,<
HLISTI:	IOWD	200,B.USR
	0

KONSIX:	SIXBIT	.DR.
	SIXBIT	.FH.
	SIXBIT	.DP.
	SIXBIT	.MF.
>

NAMFIL:	SYSFIL	;OMOUNT PROG.NAMES TO LOOK FOR
NAMMNT:	SYSMOU
NAMOMO:	SYSOMO

PDP:	IOWD	20,PDLIST

;LITERALS

XLIST
LIT
LIST

IFN DBUGSW, <
PATCH.:	BLOCK	50		;PATCH AREA FOR DEBUGGING
>;	END OF	IFN DBUGSW

HIEND:	;END OF HIGH SEG

;VARIABLES

UU(HLIST,2)
U(IORPPN)
U(CMDPPN)
U(CMDSTR)
U(FS1PPN)
U(SYSPPN)
U(CMDCHR)
U(CMDNAM)
U(COMCNT)
U(USRPPN)
U(JOBNO)
U(SAVED)
U(MONVER)
U(STATES)
U(STDDEV)
U(DEFDEV)	;DEFAULT F.S.
U(DEFPPN)		;DEFAULT PPN FOR FILE CMDS
U(TAPEID)
U(TTYLIN)

UU(FILBLK,DTDNFI+2)
UU(FILDEV,DTDNFI+2)
UU(FILBEX,DTDNFI+2)
UU(FILPPN,DTDNFI+2)		;STORAGE FOR FILE PPN'S
U(FILBKE)
IFNDEF SRCBUF,<
UU(SRCBUF,EXLLEN)>
UU(PDLIST,20)

UU(MYCMD,1)		;NAME OF CURRENTLY GENERATED CMD FILE

UU(INTBLK,4)		;PARM BLOCK FOR ERROR INTERCEPTING
UU(DMSPOS,1)		;CODE FOR DISMOUNT POSITIONING
			; -1=NOT SPEC, 0=STAY, 1=REWIND, 11=UNLOAD
UU(TOJOB,1)		;CODE FOR DISMOUNT DISPOSITION
			; -1=F/S, 0=RELEASE, +N=ASSIGN TO THAT JOB (INCL [SELF])

IFN LOGSW, <
UU(GENLOG,1)		;CODE FOR LOGICAL NAME
			; -1=GENERATED, 0=USER SPEC'D, +1=PHYSICAL USED
>;	END OF	IFN LOGSW

UU(DIRPPN,1)		;PPN FOR DEFAULT DIRECTORY PATH
UU(PTHPRM,PTHLEN)	;PARAMETER AREA TO READ DEFAULT DIR PATH

IFN SPONUL, <
UU(DVVTYP,1)		;STORAGE FOR DEVTYP UUO RESULTS
>;	END OF	IFN SPONUL

UU(IDIDIT,1)		;1=OMOUNT HAD TO BE USED;0=UMOUNT DID REQ. ITSELF
UU(NOTLOG,1)		;0=LOGGED IN, -1=NOT LOGGED IN
UU(CHKFLG,1)		;0=NOT /CHECK (FILE C), -1=/CHECK AND [1,2] OR [2,5]

UU(FILSTR,3)		;PARM BLOCK FOR JOBSTR UUO (1ST WD = 0 IF NOT BEING USED)

IFN FTFACT, <
UU(FACT,1)	;DAEMON (.FACT) REQUEST CODE (= 3)
UU(F.HEAD,1)	;DAEMON FACT ENTRY - HEADER W/ CODE 271 (MOUNT ENTRY)
UU(F.PPN,1)	; - USER'S PPN
UU(F.DATE,1)	; - CURRENT DATE & TIME (SUPPLIED BY DAEMON)
UU(F.QUE,1)	; - 0-11 QUEUE NAME (UM,UD), 12-17 STATION #,
		;	  18-35 APR0 SERIAL #
UU(F.TIME,1)	; - (CPU TIME) ZERO BECUASE ALREADY ACCOUNTED FOR
UU(F.KCS,1)	; - (KILO-CORE-TICKS) ZERO BECAUSE ALREADY ACCOUNTED FOR
UU(F.RCT,1)	; - (DISK BLOCKS READ) ZERO BECAUSE ALREADY ACCOUNTED FOR
UU(F.WCT,1)	; - (DISK BLOCKS WRITTEN) ZERO BECAUSE ALREADY ACCOUNTED FOR
UU(F.DEV,1)	; - DEVICE NAME USED BY THE REQUEST
UU(F.SEQ,1)	; - (SEQUENCE #) NOW ZERO
UU(F.UNIT,1)	;SPOOLER UNITS - SET LH TO 1 FOR OMOUNT COMPATABILITY
F.SIZE==F.UNIT-FACT+1	;LTH OF DAEMON PARM BLOCK
>;	END OF	IFN FTFACT
;BUFFER AREAS

UU(WH.CMD,3)
UU(WH.TTY,3)
UU(RH.TTY,3)
UU(RH.CMU,3)
UU(RH.CMD,3)

UU(B.TTY,2*30)
UU(B.CMD,205)
UU(B.CMU,205)

IFN MNTSW,<

U(CMDFSN)
U(PHYNAM)
U(DVVNAM)
FSNAME==DVVNAM
U(DEVMOD)
U(REELID)
VIDL==<VIDMAX+4>/5
UU(VID,VIDL)
U(VIDK)
U(LOGNAM)
U(LOOPX1)
U(ENTSIZ)
U(FSCLAS)
U(OWNPPN)
U(TEMBP)
LASTUN=TEMBP
U(NUMDRV)
U(NUMREQ)
U(SAVDRV)
U(UDREQ)
UU(USRDRV,8*MAXKON)
UU(PACKID,8*MAXKON)
UU(PKCLAS,8*MAXKON)
UU(DROFFL,8*MAXKON)
UU(DRIVE,8*MAXKON)
UU(DRVSTT,8*MAXKON)

>	;END CONDITIONAL ON MNTSW

IFN PURESW, <RELOC>
	VAR		;JUST IN CASE
IFN PURESW, <RELOC>

IFN PURESW, <
UU(LOWEND,0)		;ADDR OF END OF LOW SEGMENT, +1
>;	END OF	IFN PURESW

RELOC
LOEND:	END	UMOUNT
