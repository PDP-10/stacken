TITLE OMOUNT - OPERATOR HALF OF MOUNT, DISMOUNT & FILE COMMAND - V.27
;COPYRIGHT 1972,1973,1974,1975,1976,1977,1978,1979,1980 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
SUBTTL R CLEMENTS /RCC/DJB/JHT/JNG/RKH/DML/CER/CLRH/DC/AWC	20-Feb-80

VWHO==0			;WHO LAST PATCHED
VMAJOR==27		;MAJOR VERSION NUMBER
VMINOR==0		;MINOR VERSION NUMBER
VEDIT==205		;EDIT NUMBER
VOMNT== BYTE(3) VWHO (9) VMAJOR (6) VMINOR (18) VEDIT
;	REVISION HISTORY
;
;	1	INCORPORATE BROOKINGS CHANGES AND MAINTENANCE VERSION
;
;	2	CORRECT OPICK ROUTINE TO HANDLE THE OPR'S ASKING FOR
;		DIFFERENT DRIVES THAN THOSE SUGGESTED BY OMOUNT.
;		SPR 14159
;		 AREA AFFECTED: OPIK52
;
;	4	SHORTEN OPR. CHOICE MESSAGES AFTER OMOUNT GIVES ONE THE 
;		FIRST TIME.
;
;	4	FIX SAT ROUTINE
;		SPR?????
;		 AREA AFFECTED: FSDF10
;
;	5	USE GETTABS FOR OPR PPN. IT HAD BEEN ASSUMED TO BE [1,2]
;		 AREA AFFECTED: OMOUNT
;
;	6	PUT FEATURE THAT OPR REQUIRED TO USE DRIVE SPECIFICALLY 
;		REQUESTED BY USER INTO FEATURE TEST: DRIREQ
;		 AREA AFFECTED: MOUN47
;
;	7	IMPLEMENT "USERS PRIVATE" TO GIVE USER INFORMATION ABOUT
;		ALL STRUCTURES THAT ARE NOT IN THE SYS SEARCH LIST AND
;		ARE IN THE ACTIVE SWAPPING LIST
;		AREAS AFFECTED: USCOM
;		 NEW ROUTINES:SWPBLD, SWPCHK,SWPREM
;
;	10	HAVE THE /REMOVE CHECK FOR SWAPPING BE DETERMINED BY 
;		CHECKING THE ACTIVE SWAPPING LIST INSTEAD OF .UNK4S
;		RETURNED FROM A DSKCHR.
;		 AREA AFFECTED: CKMNC4
;
;	11	CLEAR REELID AT BEGINNING OF EVERY MOUNT
;		 AREA AFFECTED: MOCOMT
;
;	12	OMOUNT TYPES "STRUCTURE TYPE DOES NOT MATCH HOMEBLOCKS"
;		IF STRUCTURE ALREADY MOUNTED.
;		 AREA AFFECTED: GETUNI
;
;	13	REARRANGE NOTISW CONDITIONAL NOT TO TYPE 0'D DATE AND
;		TIME IN DECTAPE DIRECTORY.
;		 AREA AFFECTED: COMEN1
;
;	14	PUT FILE CODE INTO CONDITIONAL
;
;	15	EDIT 12 LOOKED AT WRONG UNITCL WORDS SINCE D WAS
;		INITIALLY SET TO 1 NOT 0. MAKE NEW BYTE POINTERS FOR GETUNI
;		THIS BUG LED TO THE MESSAGE:
;		 "STRUCTURE TYPE DOES NOT MATCH HOMEBLOCKS"
;		 AREA AFFECTED: GETUNI
;
;	16	EDIT 13 REARRANGED A LITTLE TOO MUCH SUCH THAT THE
;		DATE AND TIME WERE NOT SO SPIFFY
;		 AREA AFFECTED: COMEN1
;
;	17	CORRECT EDIT 7 WHICH LOOPED IN CKMNC DUE TO BAD CODE
;		 AREA AFFECTED: CKMNC
;
;	20	/VID SHOULD ACCEPT ' AND " AS DELIMITERS - FAILURE TO 
;		TAKE " LED TO ERROR IN PICKING UP /WE AND /WL
;		 AREA AFFECTED: VIDIN
;
;	21	FIX 'CMD FILE AUTHOR' MSG TO HAVE FULL PPN
;
;	22	ALLOW 'ST' AS VALID ABREVIATION FOR 'START' DESPITE CON-
;		FLICT WITH STOP
;		 AREA AFFECTED: SWITCH TABLES
;
;	23	ADD CAPABILITY TO HANDLE DISK OFF-LINE.  INTENDED FOR
;		REMOVING SUCH A STRUCTURE
;		 AREA AFFECTED: MANY
;
;	24	MAKE ARGUMENTS TO USERS COMMAND BE SWITCHES TO AVOID
;		HAVING TO TYPE ENTIRE SUB-COMMAND TO GET MATCH
;		 AREA AFFECTED: USCOM
;
;	25	MAKE ^Z TO TOP LEVEL BE SIGNAL FOR EXIT
;		 AREA AFFECTED: OPCOM
;
;	26	CLEAN UP SOME MESSAGES
;
;	27	MAKE BROOKINGS' CONDITIONAL FOR PUTTING FILE CMD DIAGS.
;		IN THE .DIR FILE INSTEAD OF ON TTY BE 'DIAGSW'
;
;	EDIT 27 WENT TO FIELD TEST #1 ON 12-JAN-75
;
;	30	ALLOW OPERATOR TO IGNORE WRITE-STATUS DISCREPENCY IF USER
;		REQUESTED /WE AND TAPE IS /WL.  THIS ABILITY IS UNDER
;		CONDITIONAL 'IGNWE'
;		QAR 3319
;		 AREA AFFECTED: CKDTID
;
;	31	FIX ROUTINE TO BUILD ACTIVE SWAPPING LIST, WHICH GOT
;		RANDOM 
;			?NOT ENOUGH TABLE SPACE FOR ACTIVE SWAPPING LIST
;		 AREA AFFECTED: SWPBL1
;
;	32	CHANGE FACT FILE BLOCK: CHANGE CODE TO 271 FROM 251.
;		DELETE F.ELPD, THE INFORMATION IN WHICH GOES TO RH OF 
;		F.UNIT IN SECONDS (LIKE SPRINT). LH OF F.UNIT BECOMES
;		SUCCESS/FAILURE FLAG (LIKE OLD RH OF F.UNIT).  UNITS FOR
;		F.TIME IS MILLISECONDS AND FOR F.KCS IS KILO-CORE CENTI-
;		SECONDS (LIKE SPOOL AND SPRINT)
;		**FACT PROCESSING FOR MOUNT NECESSITATES CHANGES TO
;		MONEY.MAC AND FACTPR.MAC.
;		AREA: COMEN3,CKCMD
;
;	33	CHANGE '?UNDEFINED DEVICE' TO '?COMMAND REQUIRES DEVICE
;		NAME' FOR MOUNT, DISMOUNT (USER), REMOVE (OPR), OR LOCK
;		COMMANDS WITH NO NAME OR NO SWITCHES.
;		QAR 3291
;		AREA AFFECTED: ERR200,ERR201,RECOM,LOCOM,MOCOM
;
;		RANGE TO COVER MORE UNNEEDED CODE.
;		QAR 3289
;		 AREA AFFECTED: FSQUIT,RPARSE,DTDERR,I/O MACROS
;
;	35	MAKE DELAY PART OF DATE/TIME TYPEOUT AT END OF COMMAND
;		BE ASSEMBLY OPTION GOVERNED BY 'DELYSW'.
;		QAR 3308
;		 AREA AFFECTED: COMEN1
;
;	36	FIX ASSEMBLY ERRORS CAUSED WHEN DIAGSW=0.
;		DIRFLG WAS UNDEFINED BUT REFERRED TO.
;		QAR 3306
;		 AREA AFFECTED: COMEN5
;
;	37	MAKE MAXIMUM TIME FOR DEFER COMMAND 24 HOURS TO AVOID
;		OPERATOR MISTAKES (AND PDL OVERFLOW).  'DEFERM' IS CON-
;		DITIONAL TO GOVERN THIS MAXIMUM.
;		QAR 3297,3298
;		 AREA AFFECTED: DEFERQ
;
;	40	IMPLEMENT 'NODEFER' COMMAND FOR TOP LEVEL SO OPERATOR
;		CAN PROCESS DEFERED COMMANDS AS THOUGH TIME HAD EXPIRED.
;		THIS SHOULD BE MOST USEFUL WHEN OPR MAKES MISTAKE IN THE
;		TIME WHICH IS OTHERWISE AWKWARD TO RECOVER FROM.
;		THE COMPLEMENT AND DEFAULT IS 'DEFER'
;		QAR 3246
;		 AREA AFFECTED: ASK2,NODCOM,DEFCOM
;
;	41	FIX COMNAM SO COLON FOLLOWING A DEVICE AND FOLLOWED 
;		IMMEDIATELY BY NON-BLANK OR NON-TAB WORKS CORRECTLY
;		QAR 3311
;		 AREA: COMNAM
;
;	42	INCREASE MAXSPT TO 40 TO ALLOW FOR LARGEST SPT TABLE
;		POSSIBLE WITH RP04'S.  COULD BE 20 IF RP03 LARGEST DISK
;		SPR 15401
;		 AREA: MAXSPT
;
;	43	ADD MISSING AC TO JSP TTYERR
;		QAR 3342
;		 AREA R.TTY2
;
;	44	ALLOW OPERATOR TO RESPOND "N" TO A DEVICE SELECTION MSG
;		FOR DISK AND USE DEFAULT CONTROLLER FOR DRIVE IN QUESTION
;		QAR 3302,3343
;		 AREA OPICK5
;
;	45	DO NOT ISSUE 'SYSTEM ERROR' MESSAGE IF USER LOGS OFF 
;		DURING MOUNT COMMAND. RATHER USE 'USER JOB HAS LOGGED
;		OFF' ONLY
;		QAR 3349
;		 AREA FSRDF
;
;	46	CLEAR REELID AT BETTER PLACE - NOT BEING CLEARED FOR
;		USER COMMANDS
;		QAR 3360
;		 AREAS: MOCOMT,MOCOM
;
;	47	IF CAN'T CREATE DIR FILE, DON'T TRY TO WRITE ERROR 
;		MESSAGE INTO DIR FILE. GO TO OPERATOR'S TTY INSTEAD.
;		WAR CCSS 43
;		 AREA: DCNUFE
;
;	50	COMPARISON OF AFTER AND CURRENT TIME FAILS UNLESS ONLY
;		LOOKING AT MINUTES
;		QAR 3383
;		 AREA: AFTCM1
;
;	51	CONVERT EDIT,ETC. TO STANDARD FORMAT
;		QAR 3332
;
;	52	A FILE CMD DEFERRED SOME PERIOD OF TIME GETS DIAG
;		'BAD FILE NAME, R COMMAND - '.  NXTFIL NOT PROPERLY
;		SCANNING /AFTER
;		QAR 3358
;		 AREA: NXTFLP
;
;	53	REMOVE STR/NOCHECK SAID "DONE.." BUT DID NOTHING
;		QAR 3385
;		 AREA: NOCHEK
;
;	54	CHANGE ALL ERROR MESSAGES BEGINNING "? " AND "& " TO
;		"?" AND "%".  (DELETE BLANK)
;
;	55	DON'T ISSUE 'STRUCTURE DOES NOT MATCH HOMEBLOCKS'
;		MESSAGE IF 'HOMUTP' WORD OF HOMEBLOCK = 0 (I.E. HASN'T
;		BEEN REFRESHED SINCE 5.03)
;		QAR 3374
;		 AREA: WATUN3
;
;	56	MAKE MODTAB AND MODNAM TABLES MATCH SO OMOUNT GETS ITS
;		NAME RIGHT IF FILESW = 0
;		QAR ???
;		 AREA: MODTAB,MODNAM
;
;	57	USE GETTAB FOR JIFSEC. JIFSEC IS NOT REMOVED SINCE IF
;		THE GETTAB FAILS, WE MUST PICK A DEFAULT (60).
;
;	60	CHANGE PAGE PSEUDO-OPS TO FORM-FEEDS. THIS WILL CHANGE
;		THE NUMBER OF PAGES IN THE OMOUNT LISTING
;		QAR 3330
;
;	61	ADD SUPPORT FOR OPERATOR TO PROVIDE /REELID AT
;		DRIVE SELECTION TIME. THIS EDIT AND SPECIFICALLY RIDSW
;		CONDITIONAL GO WITH EDITS 64 AND 65 OF UMOUNT. SEE RIDSW.
;		QAR: 3369
;
;	62	IF OMOUNT GETS A DEVICE NAME LIKE DSKB0: AND IF OMOUNT
;		HAS TO CREATE A UFD AND/OR LOOKUP QUOTAS FOR THAT F/S,
;		IT FAILS. THIS CODE IS REPEAT 0'D DUE TO INSUFFICIENT 
;		TESTING AND LOW LIKELIHOOD OF BEING NEEDED
;		QAR 3371
;		 AREA: MAKUFD
;
;	63	MAKE WRITE-STATUS CHECKING FOR MAGTAPES MORE ACCURATE FOR
;		MORE CONTROLLERS BY USING MTCHR. UUO INSTEAD OF DEVSTS
;		 AREA: CHKID7
;
;	64	RELEASED AS VERSION 26(64) IN APRIL, 1975
;
;	100	MAKE THIS VERSION 26A
;
;	101	MOUNT AND DISMOUNT WILL GIVE 'UNDEFINED DEVICE' ON SIX
;		CHARACTER DEVICE NAMES (602)
;		AREAS: MOCOM,DICOMF
;	102	TWO INSTRUCTIONS WASTED - REPLACE
;		SPR 16239
;		 AREA: OPIK60
;
;	103	MORE 6-CHARACTER DEVICE NAME SUPPORT FOR FILE COMMANDS:
;		1.) GIVE OPR CHOICE OF AVAILABLE DECTAPES BASED ON BEING
;		AVAILABLE TO THIS JOB AS OPPOSED TO ASSIGNED BY THIS TTY
;		2.) IN TYPING THIS NAME REPLACE CODE THAT PUTS SINGLE
;		UNIT NUMBER IN PARENTHESES WITH SIMPLE TYPE OUT OF FIRST
;		AVAILABLE DTA DEVICE
;		NO SPR
;		 AREA: RQTAPB
;
;	104	TOO MANY TAPE ID DISCREPENCY MESSAGES TYPED CAUSE LEADING
;		ZEROES CODE USES WRONG AC
;		SPR 16537
;		AREA: CKDID0
;
;	105	GET RID OF USETI AND REPLACE WITH SUSET. UUO
;		AREA: GETUNB
;
;	106	ACCESS DATE BUG IN FILE R
;		SPR 16476
;
;	107	DATE75 BUG IN UFD DATE - CREATION DATE HIGH ORDER BITS
;		CLOBBERED.
;		SPR 16476
;		 AREA: SETEXL
;
;	110	JNG	24-Jul-75	SPR 16693	UMOUNT edit 105
;		Implement "trailing asterisk" wildcard construction.
;		Areas: SETMSK,SSIXB2
;
;	111	JNG	7-Aug-75	SPR 16925
;		Re-enable interrupts after disk off line trap.
;		Areas: FSQUIT, MSG311
;
;	112	JNG	8-Aug-75	SPR 17034
;		Use correct default in directory listing if blank
;		tape ID for FILE command.
;		Areas: DCRTRY
;
;	113	JNG	8-Sep-75	SPR 17282
;		SRCBUF is one word too short, so 1st word of SECBUF
;		can sometimes be destroyed.
;		Areas: Definitions, REWCMD
;
;	114	JNG	8-Sep-75	SPR 17124
;		Fix a couple of backwards conditionals.
;		Areas: MOUNT6, MODVAL
;
;	115	JNG	20-Sep-75	SPR 17015
;		Fix several bugs, as follows:
;	(1)	Store the universal date/time in the fact entry.
;	(2)	Store the proper TTY for the user in the fact entry.
;	(3)	Recognize the %,% entry in AUXACC.SYS
;	(4)	Add some code to debug fact accounting.
;
;	116	JNG	16-Oct-75	SPR 17510
;		Look up files in the user's UFD when recomputing
;		his disk usage; don't look them up in our default path.
;		Areas: ALLK1
;
;	117	RKH	3-Mar-76	SPR 10-19082
;	Prevent directory read errors when mounting non PDP10
;	DECtapes with /VID switch.
;	Areas:IDRTRY
;	120	DML	9-JUL-76	SPR 19811, 20198
;		PRINT OUT ALL DRIVE NAMES WHEN A MULTIPACK
;		STRUCTURE IS REMOVED.
;		 AREAS AFFECTED: REMOV4

;	121	DML	14-JUL-76	SPR 20252
;		WHEN OMOUMT PROMPTS WITH A "/" THE FIRST 
;		CHARACTER MAY NOW BE LOWER CASE.
;		 AREAS AFFECTED:BEG1, R.TOK

;	122	DML	27-JUL-76	SPR 20079
;	OMOUNT NO LONGER RESCANS THE AVAILABLE RESOURCES LIST FOR
;	CERTAIN OPERATOR REPLIES ON NON F.S. MOUNT REQUEST.
;	 AREAS AFFECTED:MOUNT1, MOUN11, MOUNT3, MOUN41, MOUN54, SWPMAX

;	123	DML	2-AUG-76	SPR 19465, 20457
;		OMOUNT NOW CHECKS DTA ERROR STATUS ON FILE CLOSE.
;		 AREA AFFECTED: FCEOF

;	124	DML	3-AUG-76	SPR 20550
;		DELETE THE "FILE" FROM THE "X=ALL,NONE, FILE, MOUNT"
;		PART OF HELP MESSAGES IF FILESW=0.
;		 AREAS AFFECTED: HECOM, OPRHLP, OPAHE2, OPAHMS,
;			OPCHEL,OPRHEL

;	125	CER	2-Aug-76
;	ADD SUPPORT FOR TAPE LABELLING. THIS INCLUDES NEW SWITCHES ADDED
;	TO UMOUNT IN EDIT 115 AND A NEW FEATURE TEST SWITCH (FTTLAB)

;	126	JNG	5-Dec-76
;		Don't truncate block to 18 bits when doing SUSET. UUO

;	127	SPR # 10-20854	LCR	8-NOV-76.
;		Reset the DEFER command at DEFERQ+3 so that /DEFER or /DEFER:arg will work as intended.
;		Areas affected: DEFERQ+3.

;	130	JNG	5-Dec-76
;		Make safety factor calculation for file str's be
;		less generous (only do it once per unit, and never
;		allocate a saftey factor greater than 500).

;	131	JNG	5-Dec-76
;		Support 6.03-style private file structures.

;	132	JNG	5-Dec-76
;		Unload RP04's etc. (.DUUNL) on removal from system.

;	133	CER	28-Dec-76
;			More tape labelling stuff:
;			   If labeller is running, don't do ring-checking on magtapes

;
;	134	CER	3-Feb-77
;			Add support for a default label type.
;			Assemble OMOUNT with LT.DEF equal to
;			the desired default. Normal is LT.SL i.e. ANSI

;	135	CER	13-APR-77
;			FIX BUG IN EDIT 122 WHICH CAUSED WRONG DEVICE TYPE
;			SUGGESTED ON A MOUNT(I.E. DECTAPE ON MAGTAPE MOUNT)
;
;	136	CER	ADD CODE TO TYPE OUT DRIVE TYPE WHEN OMOUNT SAYS
;			"NOT ENOUGH DRIVES" ON A MOUNT REQUEST
;	137	CER	2-AUG-77
;			CHANGE DEFAULT LABEL TYPE TO BE LT.BLP (BYPASS)
;	140	CER	11-AUG-77
;			DON'T DO REWINDS IF BYPASS LABELS
;	141		;M7 and M9 ARE NOT RECONIZED (OSLO CODE)
;	142		;IMPLEMENT THE UNLOCK COMMAND (REQUIRES FTOSLO SET IN TOPS10)
;			(OSLO CODE)
;	143		;IMPLEMENT THE NEXT xx COMMAND (OSLO CODE)
;	144		;IMPLEMENT AUTO DEVICE SEARCH FOR LABELED TAPES
;			;REQUIRES AVR TO BE IMPLEMENTED IN PULSAR
;			;FOR A CORRECT OPERATION (OSLO CODE)
;	145	RESET LENGTH OF /VID: ARGUMENT SO THAT NEXT MOUNT REQUEST
;		AFTER DEFERRED REQUEST WITH A VID: SWITCH DOES NOT INHERIT
;		THE /VID: SWITCH.
;		AREAS AFFECTED: AFTVID  SPR: 10-25510
;	146	FIX SIX CHARACTER DEVICE NAMES
;		AREAS AFFECTED: MOUN42	SPR: 25921
;	147	CHECK FOR STRUCTURE NEEDS REFRESHING
;		AREAS AFFECTED: GETHO	SPR: 26011
;	150	CREATE CORRECT AOBJN POINTER FOR SWPTAB IN SWPAOB
;		(SWPFIN).  SPR: 27007
;	151	CREATE GOOD FACT FILE ENTRIES ON MOUNTS.
;		AREA: MOUN75
;		CLRH	8-NOV-78	SPR 26875
;	152	RELEASE CH.FS CHANNEL WHEN DONE USING IT.
;		AREA: GETUNB
;		CLRH	14-NOV-78
;	153	DO NOT CONVERT REELID TO SIXBIT IF FTTLAB IS OFF; IT IS ALREADY.
;		AREA: MOUN63
;		CLRH	16-NOV-78	SPR: 27106
;	154	REMOVE DEFAULT FILESW==0 ADDED BY EDIT 141
;		NO SPR	CLRH	30-NOV-78
;	155	CLOSE DIR FILE IF COMPILED WITH DIAGSW=0
;		SPR: 27152	CLRH	1-DEC-78
;		AREA: LCOMN1
;	156	FIX MOUNT COUNT CHECK IN REMOVE TEST.
;		SPR: 26805	CLRH	7-DEC-78
;		AREA: REMOV3
;	157	IF WE CANNOT REASSIGN THE MOUNTED DEVICE TO THE USER,
;		DO A DEVLNM TO GET RID OF THE USER'S LOGICAL NAME SO
;		THAT CONFLICTS IN LOGICAL NAMES WILL NOT OCCUR.
;		AREA: MOUN77
;		SPR: 26217	CLRH	7-DEC-78
;	160	SKIP UFD CHECK IF DISMOUNT COMMAND IS FOR A JOB WHICH
;		IS GONE; CHECK JOB START UP TIME AGAINST CREATION TIME
;		OF THE COMMAND FILE TO SEE.
;		AREAS: REWCMD, DISFS
;		SPR: 26805	CLRH	8-DEC-78
;	161	DO NOT SET OB.WFI EXCEPT FOR WAIT AND PAUSE COMMANDS.
;		SPR: 23789
;		AREAS: OPCOM1, WAICOM
;		CLRH	8-DEC-78
;	162	IF NXTFIL DOES NOT FIND A FILE, RETURN NONSKIP.  THIS WILL
;		MAKE DEFERRED FILE COMMANDS WORK.
;		AREA: NXTFLP	SPR: 27362
;		CLRH	4-JAN-79
;	163	CHECK THAT DRIVES FOR MULTI-PACK STRUCTURE ARE IN THE
;		CORRECT ORDER AND THAT NOTHING IS MISSING OR EXTRA.
;		AREA: DEFIN	SPR: 26215, 27581
;		CLRH	23-FEB-79
;	164	CORRECT MINOR OMISSION AT STR301+4.
;		CLRH	5-MAR-79	SPR: 27615
;	165	TAKE OUT UNLOCK; NOT IMPLEMENTED IN THE MONITOR
;		CLRH	28-MAR-79
;	166	CHANGE ALL REFERENCES TO FTOSLO TO FTTLAB
;		NOTE: I AM NOT GOING TO GIVE ALL OF THEM EDIT NUMBERS
;		ON THE LINES.
;		CLRH	28-MAR-79
;	167	TAKE OUT THE NEXT COMMAND.
;		CLRH	28-MAR-79
;	170	EDIT FROM WLH, 22-FEB-78
;		SET INFINITE IPCF SEND AND RECEIVE QUOTAS.
;		SHOULD HAVE BEEN DONE IN EDIT 125.
;		ALSO PUT AS MANY VOLID'S IN A PACKET AS WE
;		CAN INSTEAD OF JUST TWO.
;		CLRH	28-MAR-79
;	171	MAKE CODE THAT REJECTS 7-TRACK DRIVES UNDER
;		PULSAR ACCEPT THEM WHEN LABELS ARE BYPASS (BLP).
;	172	FROM DC	16-JAN-79
;		FIX SNDPLR SO WE GET PHYNAM RIGHT IF PULSAR SWAPS UNITS
;		DURING REWIND.
;	173	TEST FOR MISSING LABEL SWITCH AND PICK UP DEFAULT
;	174	MIGRATE SWAPPING OFF A UNIT WHICH IS GOING AWAY.
;		REQUIRES 701 OR LATER MONITOR.
;	175	FIX EDIT 167 TO NOT REMOVE NECESSARY CODE NOT RELATED TO
;		THE "NEXT" COMMAND (OPNCMD).
;	176	SPR 10-28039	CLRH	8-MAY-79
;		USE CORRECT MONTH'S LENGTH FOR /DEFER COMMAND (INCTIM)
;	177	ADD DISK. UUO TO ADD UNITS OF STR BEING MOUNTED
;		TO THE ACTIVE SWAP LIST
;		ALSO, EXTEND STRUUO .FSDEF UNIT BLOCK TO SPECIFY
;		START OF SWAP SPACE AND SIZE OF SWAP SPACE
;	200	ADD ANOTHER WORD TO THE UNIT BLOCK FOR THE .FSDEF STRUUO.
;		THE WORD DESCRIBES THE PREVIOUS POSITION OF THE PACK IN
;		THE ACTIVE SWAP LIST (IE. IT IS GOTTEN FROM THE HOME BLOCK)
;		IF THE PACK WAS NOT PREVIOUSLY IN THE SWAP LIST, THEN
;		THE PACK WILL NOT BE ADDED TO THE SWAP LIST.
;	201	FIX UP SOME MISMATCHED FTTLAB CONDITIONALS SO ASSEMBLY
;		WITH FTTLAB=0 WORKS.
;	202	MIGRATE SWAPPING OFF UNIT BEFORE STRUUO-ING TO REMOVE
;		STRUCTURE FROM STRTAB
;		THIS IS REQUIRED TO ALLOW OMOUNT TO WORK AFTER MCO#8778
;		IS INSTALLED
;	203	ADD CODE FROM LOGIN (UFDEXC+10) TO FORCE USAGE RECOMPUTATION
;		IF BLOCKS USED ON STRUCTURE IS NEGATIVE.  THIS HAPPENS BECAUSE
;		OF A MONITOR BUG WHICH STILL OCCURS.
;	204	DO NOT ALLOW MOUNT/SINGLE IF STRUCTURE CONTAINS SYSTEM QUEUES
;		OR IS IN THE SYSTEM SEARCH LIST.
;	205	ASK THE OPERATOR WHETHER TO ADD A STRUCTURE TO THE SWAP LIST
;		BEFORE DOING SO (QAR 10-04162)
;[END OF REVISION HISTORY]
;**; [160] INSERT AFTER END OF REVISION HISTORY	CLRH	8-DEC-78
	SEARCH	MACTEN		;[160]

;**; [154] REMOVE UIO DEFAULTS ADDED BY EDIT 141
;[154];Ui0		;[141] DEFAULTS
;[154]FILESW==0		;[141] NO DECTAPES


;IFNDEF FTOSLO,<FTOSLO==1>	;[141] INCLUDE THE UIO HACKS VIS SWS
;	IFN FTTLAB,<SEARCH	UUOSYM>	;[141]
	SEARCH	UUOSYM		;[166]
IFN FTTLAB,<LT.DEF==LT.BLP>	;*** IN-HOUSE VERSION DEFAULT TO BLP ***
;IFN FTTLAB,<LT.DEF==.TFLAL>	;[141]DEFAULT ANSII STANDARD LABELS
IFNDEF PURESW,<PURESW==1>	;NON-ZERO MEANS REENTRANT SHARABLE
IFNDEF NOTISW,<NOTISW==1>	;NON-ZERO MEANS NO DATE/TIME TYPEOUT
IFNDEF DELYSW,<DELYSW==1>	;NON-ZERO MEANS INCLUDE DELAY AS PART OF
				;DATE-TIME TYPEOUT.  NOTISW MUST BE ZERO
				;FOR THIS TO MATTER.
IFNDEF UNLOSW,<UNLOSW==1>	;NON-ZERO MEANS REWIND AND UNLOAD DTAS
IFNDEF DBUGSW,<DBUGSW==0>	;NON-ZERO MEANS ASSEMBLE FOR DEBUGGING (SEE BELOW)
IFNDEF R12SW,<R12SW==1>	;NON-ZERO MEANS OMOUNT MUST RUN AS A 1,2 JOB
				;  THIS SWITCH SHOULD =0 ONLY FOR SPECIAL DEBUGGING
IFNDEF SLPSW,<SLPSW==5>		;5 = MINUTES TO WAIT FOR OPERATOR RESPONSE BEFORE
				;  RETYPING THE OMOUNT REQUEST
IFNDEF RPTSIZ,<RPTSIZ==100>	;SIZE OF BLOCK TO SAVE TTY OUTPUT IN FOR /WHAT SWITCH

IFNDEF IGNSTS, <IGNSTS==1>	;NON-ZERO GIVES AN OPTION TO Opr TO 
				;IGNORE WRITE LOCK/WRITE ENABLE DISCRE-
				;PENCY FOR DECtapes AND MAGTAPES

IFNDEF IGNWE, <IGNWE==0>	;IF NON-ZERO, OPR CAN'T IGNORE DIS-
				; CREPENCY IN WRITE-STATUS IF USER REQUESTED
				; WRITE-ENABLE
IFNDEF DRIREQ, <DRIREQ==0>	;IF NON-ZERO, OPR MUST USE REQUEST
				;DRIVE OF USER

IFNDEF FILESW, <FILESW==1>	;IF NON-ZERO, INCLUDE FILE COMMAND CODE

IFNDEF OFFLIN,<OFFLIN==1>	;NON-ZERO ADDS CAPILITY TO REMOVE OFF-LINE UNIT

IFNDEF MTA0SW, <MTA0SW==0>	;MTA0 IS A SEVEN-TRACK DRIVE 
IFNDEF DIAGSW, <DIAGSW==1>	;PUT FILE CMD DIAGNOSTICS IN .DIR FILE INSTEAD OF ON TTY
IFNDEF FTFACT, <FTFACT==1>	;ADDS DEC-STYLE (FACT) ACCOUNTING
IFNDEF JIFSEC, <JIFSEC==^D60>
IFNDEF DEFERM,<DEFERM==24>	;MAX. NO. OF HOURS TO ALLOW FOR DEFER
	DEFERT==DEFERM*^D60	;CONVERT TO MINUTES FOR DEFERQ RTE.

IFNDEF RIDSW, <RIDSW==0>	;NON-ZERO ADDS OPERATOR ABILTIY TO SET
				;REELID DURING DRIVE SELECTION
				;VIA THE /REELID:XXXXXX COMMANDS, 
				;WHICH CAN BE USED IN RESPONSE TO THE DRIVE
				;SELECTION MESSAGE ITSELF AND A PROCEED?
				;THAT IS ISSUED IF THE REELID HAS NOT BEEN
				;PROVIDED.  ADDITIONALLY, THE /REELID IS
				;TYPED IN THE NORMAL MOUNT MESSAGE; THE
				;USER'S VID WILL BE SUBSTITUTED FOR A
				;MISSING REELID.  THE SWITCH IS FURTHER
				;REFINED BY:
				;  IF +, OPER *MUST* SUPPLY A REELID
				;	FOR MAGTAPES WHEN THE USER DIDN'T
				;  IF -, OPER IS GIVEN A CHANCE TO SUPPLY
				;	A REELID FOR MAGTAPES WHEN THE
				;	USER DIDN'T
IFNDEF FTTLAB,<FTTLAB==0>	;INCLUDE SUPPORT FOR PULSAR-10 (IF NON-ZERO)

IFN FTTLAB,<IFN RIDSW,<PRINTX<CAN'T HAVE BOTH RIDSW AND FTTLAB NON ZERO
>>>

.JBREN=124
.JBVER=137

LOC .JBVER
EXP VOMNT

LOC .JBREN
EXP	REENT

EXTERNAL .JBFF
INTERNAL .JBVER,.JBREN,OMOUNT


IFN PURESW,<
TWOSEG
RELOC	0
RELOC	400000
DEFINE	UU(A,B)<
RELOC
A:	BLOCK	B
RELOC>
> ;IFN PURESW

IFE PURESW,<
RELOC
DEFINE	UU(A,B)<
A:	BLOCK	B>
> ;IFE PURESW

DEFINE	U(A)<UU(A,1)>

MLON
;PARAMETERS, SPECIAL CHARACTERS, ETC.

CHRLIN=="-"	;LINE CONTIN.
VIDMAX==^D50	;MAX.LENGTH OF /VID: SWITCH VALUE
VIDCH1=="'"	;SINGLE QUOTE DELIMITER FOR  VID STRINGS
VIDCH2==42	;DOUBLE QUOTE ....

			;SLEEP TIMES IF NO HIBER UUO
SLPCOM==^D15		;BETWEEN QUEUE SCANS
SLPUNI==^D15		;WAITING FOR UNITS TO READY

CMDPPX==3,,3		;DEFAULT REQUEST QUEUE AREA
CMDSTX==SIXBIT/DSK/
STLPPX==0	;WHERE TO LOOK FOR STRLST.SYS
STLSTX==SIXBIT/SYS/

		;VALUES FOR MODNAM TABLE
SYSFIL==SIXBIT/OPRFIL/	;PROG.NAME WHEN LOOKING ONLY FOR 'FILE'
SYSMNT==SIXBIT/OPRMNT/	;... 'MOUNT' & 'DISMOUNT'
SYSALL==SIXBIT/OPROMO/	;...EVERYTHING
SYSNON==SIXBIT/OMOUNT/	;...NOTHING (ONLY OPR. COMMANDS)
;-------AC'S

F=0
A=1
B=2
C=3
D=4
E=5

IO=10
M=11
N=12
N1=13
BP=14
CH=15
WD=16
P=17

;I/O CHANNELS

CMD==1
CMU==2
USR==3	;MUST NOT BE CHAN.0
DSK==4
DTA==5
TTY==6
UFD==7
CM1==10
CH.FS==11	;FOR DEFINING NEW F.S. (READING HOME BLOCKS ETC.)
DIR==12		;FOR WRITING FILE CMD (*.DIR) FILES
US1==16		;FOR CREATING UFD,ETC.
;FLAGS  (LH OF F)

L.OCAN==1
L.WFIL==2
L.WEXT==4
L.TYO==10
L.SLP==20
L.TAPE==40
L.RCOM==100
L.REEN==200
L.VIDT==400
L.STOP==1000
L.MNT==2000
L.LVD==4000
L.CMDS==10000	;1 IF COMMANDS IN QUE (NXTASK)
L.UPRI==20000	; 1 IF USERS PRIVATE COMMAND FOUND
L.ODEF==40000	; 1 IF OPR /DEFER GIVEN W/O TIME DELAY
L.NOC==100000	; 1 IF NOCREATE FOR F/S
L.PAS==200000	; 1 IF PUT F/S IN PASSIVE S/L
L.CLR==L.REEN!L.OCAN!L.TAPE!L.NOC	;BITS TO CLEAR

IFN DIAGSW, <
L.DECER==400000	; 1 IF ATTEMPTING TO OPEN DIR FILE FOR ERROR MSG
L.CLR==L.CLR!L.DECER		;ANOTHER BIT TO CLEAR
>;	END OF	IFN DIAGSW

;MISC BITS AND VALUES

MODEF==1	;'FILE' MODE
MODEM==2	;'MOUNT/DISMOUNT' MODE
DVDTA==100
MINDAY==^D60*^D24
;PARAMETERS FROM COMMOD

;**;[113] CHANGE @ EXLLEN	JNG	8-Sep-75
EXLLEN==27		;[113]
EXLPPN==1
EXLNAM==2
EXLEXT==3
;**; [160] INSERT AFTER EXLEXT	CLRH	8-DEC-78
  RB.CRX==7B20		;[160] EXTENSION OF RB.CRD
EXLATT==4
;**; [160] INSERT AFTER EXLATT	CLRH	8-DEC-78
  RB.CRT==3777B23	;[160] CREATION TIME
  RB.CRD==7777B35	;[160] CREATION TIME
EXLSIZ==5
EXLALC==11
EXLDEV==16
EXLSTS==17
.RBSTS==17
EXLQTF==22
EXLQTO==23
EXLQTR==24
EXLUSD==25
EXLAUT==26
  .RBNDL==1B19
  RIPDIR==400000
  RIPLOG==400000
;SOME SYSTEM PARAMETERS

;STATES WORD
STAVER==POINT 3,STATES,9	;MONITOR VERSION #
V503==2		;'5.03' VERSION FIELD

MAXUNI==10	;MAX. # UNITS IN A FS.
MAXSPT==40	;MAX SPT TABLE SIZE (SATS/UNIT)
MAXFSL==11	;MAX # F/S IN A SEARCH LIST

HOMEB1==1	;LOG.BLK.NO. OF 1ST HOME BLOCK
HOMEB2==12	;"""2ND"""

UNVRSF==^D500	;RECIPROCAL SAFTY FACTOR FOR FREE-BLOCK TALLYS (MONGEN SYM.)
DSKTRY==3	;NUM. RETRIES ON ERROR--STRTRY (MONGEN SYM.)

;PARAMETERS FOR STRLST.SYS

STRFOR==0	;STRLST.SYS FORMAT VERSION #
STYPE:	POINT 3,UNITCL(D),^D32	;BYTE PTR FOR UNIT TYPE
SKTYP:	POINT 6,UNITCL(D),^D26	;  KONT TYPE
STYPE1:	POINT  3,UNITCL-1(D),^D32	;BYTE PTR FOR UNIT TYPE(GETUNI)
SKTYP1:	POINT  6,UNITCL-1(D),^D26	;BYTE PTR FOR KONT TYPE(GETUNI)
UCLDEF==2010		;UNITCL DEFAULT

;PARAMETERS FOR QUOTA.SYS
QUOFOR==0	;QUOTA.SYS FORMAT VERSION NUM.
;PARAMETERS FROM COMMOD

HOMSNM==4
HOMGAR==33
HOMOVR==32
HOMPT1==47
HOMUN1==50
HOMBSC==14
HOMSCU==15
HOMCNP==16
HOMCKP==17
HOMCLP==20
HOMHID==1
HOMLOG==7
HOMLUN==10
HOMGRP==13
HOMREF==23
HOMBPC==21
HOMSIC==24
HOMSPU==31
HOMSAT==34
HOMMFD==46
HOMUTP==57
HOMPVS==106
HOMCOD==176
HOMNAM==0
HOMSLB==27		;[177] START OF SWAP SPACE
HOMK4S==22		;[177] K FOR SWAP ON UNIT
HOMSUN==26		;[200] LOGICAL UNIT NUMBER IN ACTIVE SWAP LIST
CODHOM==707070

RIBFIR==0
RIBNAM==2
RIBEXT==3
RIBCOD==176
CODRIB==777777

TALSIZ==^D13
TALPOS==^D12
CLASIZ==^D23
CLAPOS==^D35

SAFFIR==0	;1ST (RELATIVE) LOCATION IN SAF BLOCK OF SAT BITS
PHONLY==200000		;PHYSICAL DEVICE NAME ONLY FOR UUOS
PHOPEN==(1B0)		;PHYSICAL DEVICE NAME ONLY FOR OPEN

;DEVCHR UUO PARAMETERS

ASSPRG==200000	;(RH) ASSIGNED BY PROGRAM
ASSCON==400000	;(RH) ASSIGNED BY CONSOLE
DC.FS==200000	;(LH)FILE STRUCTURE
DC.DTA==100	;(LH)DEC TAPE
DC.MTA==20	;(LH)MAG TAPE
DC.AVA==40	;(LH)AVAILABLE
DC.CDR==100000	;(LH) CARD READER / PUNCH
DC.PTP==400	;(LH) PAPER-TAPE PUNCH
DC.PTR==200	;(LH) PAPER-TAPE READER
DC.IN==2	;(LH) INPUT PERMITTED
DC.OUT==1	;(LH) OUTPUT PERMITTED

;DEVTYPE UUO PARAMETERS

	OPDEF	DEVTYP	[CALLI 53]

.TYAVL==40	;(LH)AVAILABLE
.TYJOB==POINT 9,0,26	;JOB #
.TYTYP==POINT 6,0,35	;DEVICE TYPE
  .TYDSK==0	;DISK

;DSKCHR UUO AND PARAMETERS

	OPDEF	DSKCHR	[CALLI 45]

;BITS RETURNED IN LH(AC)
.UPOFL==200000	;UNIT OFF LINE
.UPHWP==100000	;UNIT HARD WRITE PROTECT
.UPSWP== 40000	;F/S  SOFT WRITE PROTECT
.UPSAF== 20000	;F/S SINGLE ACCESS
.UPZMT== 10000	;F/S HAS ZERO MOUNT COUNT
.UPNNA==   200	;F/S IS LOCKED
.UPAWL==   100	;F/S IS WRITE-LOCKED FOR ALL JOBS
DCHUST:	POINT 2,A,^D8	;BYTE PTR FOR UNIT STATE
UNVNPM==2	;UNIT STATE FOR 'NO PACK MOUNTED'
DCHCOD:	POINT 3,A,^D17	;BYTE PTR FOR NAME CODE

;BITS RETURNED IN RH(AC)
DCHKTP:	POINT 6,A,^D26	;BYTE PTR FOR CONTROLLER TYPE


;CONTROLLER TYPES WE USE
	.DCCDP==2		;DP
	.DCCFS==4		;RS
	.DCCRP==5		;RP

DCHUTP:	POINT 3,A,^D32	;BYTE PTR FOR UNIT TYPE

;UNIT TYPES WE USE
	.DCUR6==2		;RP06

;DISPLACEMENTS FOR ARGS
.STNAM==4	;F/S NAME
.UNBPU==6	;BLOCKS/UNIT
.STMNT==7	;MOUNT COUNT
.UNK4S==12	;# K FOR SWAPPING
.UNJOB==13	;JOB # OF SING.ACCESSER (STRJOB)
.UNLOG==14	;LOGICAL UNIT NAME (UNILOG)
.UNNAM==15	;PHYSICAL UNIT NAME (UNINAM)
.UNHID==16	;PACK I.D. (UNIHID)
DSKCHL==26	;[205] LENGTH OF FULL ARG.LIST (CHANGED FROM 17 TO 26)
;GETTAB UUO AND PARAMETERS

	OPDEF	GETTAB	[CALLI 41]

CNFTBL==11	;CONFIGURATION TABLE

%CNTIC==44		;JIFFIES/SEC
%CNVER==34,,CNFTBL	;GETTAB ENTRY # FOR MONITOR VERSION
%CNDTM==53,,CNFTBL	;[115] UNIVERSAL DATE/TIME

.GTNSW==12		;NON-SWAPPING TABLE
%NSHJB==20		;HIGHEST JOB NUMBER ASSIGNED
UPTIME==15,,12		;UPTIME GETTAB PARAMETERS

.GTLVD==16		;LEVEL-D GETTAB TABLE
%LDFFA==2		;FAILSAFE PPN
%LDSWP==10		;ADDR. AND DISP. OF ACTIVE SWAPPING LIST

PRJPRG==2	;PPN TABLE

	OPQPTB==16		;TABLE FOR COMMAND QUEUE PPN
	OPQPIN==4		;INDEX IN TABLE FOR COMMAND QUEUE PPN
	OPQSTB==16		;TABLE FOR STR FOR COMMAND QUEUE
	OPQSIN==15		;INDEX IN TABLE FOR STR FOR COMMAND QUEUE
	STATAB==11		;TABLE FOR STATES WORD
	STAIND==17		;INDEX IN TABLE FOR STATES WORD

	LEVDS==7B27		;7B9 IS LEVEL D FLAG (3 BITS LEFT HALF)

IFN FTFACT, <
.GTTIM==4	;RUNTIME GETTAB TABLE #
.GTKCT==5	;KCT GETTAB TABLE #
.GTRCT==17	;DISK-BLOCKS READ GETTAB TABLE #
.GTWCT==20	;DISK-BLOCKS WRITTEN GETTAB TABLE #
.GTLOC==26	;REMOTE STATION GETTAB TABLE #

SERIAL==20,,CNFTBL ;CPU0 SERIAL # GETTAB PARAMETERS
>;	END OF	IFN FTFACT
;**; [160] INSERT AFTER END OF IFN FTFACT AFTER DEF. OF SERIAL	CLRH	8-DEC-78
.GTJLT==130		;[160] JOB LOG-IN TIME
;STRUUO UUO AND PARAMETERS

	OPDEF	STRUUO	[CALLI 50]

.FSDSL==1	;FUNCTION FOR DEF.SL.
.FSDEF==2	;" DEFINE FS.
.FSRDF==3	;" RE-DEFINE FS.
.FSLOK==4	;" LOCK FS.
.FSREM==5	;" REMOVE FS.
.FSULK==6	;" TEST/SET UFD INTERLOCK
.FSUCL==7	;" CLEAR "

;**; [165] REMOVE UNLOCK	CLRH	28-MAR-79
REPEAT	0,<			;[165] REMOVE UNLOCK
IFN FTTLAB,<
.FSCLK==12	;[142] CLEAR THE LOCK FUNCTION BITS
>;[142] END FTTLAB
>				;[165] REMOVE UNLOCK CODE
;DISPLACEMENTS FOR STRUUO(.FSDEF) ARG.LIST
SS.NAM==0	;STRNAM--STR PARAMETER BLOCK
SS.UNM==1	;STRUNM
SS.HGH==2	;STRHGH
SS.SIZ==3	;STRSIZ
SS.GAR==4	;STRGAR
SS.RES==5	;STRRES
SS.TAL==6	;STRTAL
SS.OVR==7	;STROVR
SS.PT1==10	;STRPT1
SS.1PT==11	;STR1PT
SS.UN1==12	;STRUN1
SS.TRY==13	;STRTRY
SS.BPU==14	;STRBPU
SS.BSC==15	;STRBSC
SS.SCU==16	;STRSCU
SS.JOB==17	;STRJOB
SS.CNP==20	;STRCNP
SS.CKP==21	;STRCKP
SS.CLP==22	;STRCLP
SS.PVS==23	;STYPV2
SS.PPN==24	;STRPPN
SS.L==25	;LENGTH OF STR PARAMETER BLOCK

SU.NAM==0	;UNINAM--UNIT PARAMETER BLOCK
SU.HID==1	;UNIHID
SU.LOG==2	;UNILOG
SU.LUN==3	;UNILUN
SU.DES==4	;UNIDES (SEE BELOW FOR BITS)
SU.GRP==5	;UNIGRP
SU.TAL==6	;UNITAL
SU.BPC==7	;UNIBPC
SU.CPS==10	;UNICPS
SU.WPS==11	;UNIWPS
SU.SIC==12	;UNISIC
SU.SPU==13	;UNISPU
SU.SPT==14	;PTR (XWD LENGTH,ADDRESS) TO SPT TABLE
SU.SSB==15	;[177] FIRST BLOCK FOR SWAPPING (HOMSLB)
SU.SKS==16	;[177] K FOR SWAP ON THE UNIT
SU.SUN==17	;[200] LOGICAL UNIT IN ACTIVE SWAP
SU.L==20	;LENGTH OF UNIT PARAMETER BLOCK
;BITS FOR STRUUO(.FSDSL)
DSLNOC==200000	;LH(F/S STATUS WD)  1=NO CREATE
DSLWLK==400000	;LH(F/S STATUS WD)  1=WRITE LOCK
DSLREM==     1	;RH(FLAGS WD) 1=REMOVE F/S & DEC. MOUNT COUNT

;BITS FOR STRUUO(.FSRDF)
DEFAWL==400000	;BIT FOR 'WRITE LOCK ALL USERS'
DEFSAF==200000	;"""'SINGLE-ACCESS'
;ERROR RETURN CODES
.ERUNC==13	;UNABLE TO COMPLETE--TRY AGAIN

	OPDEF	GOBSTR[CALLI 66]
GOBJOB==0				;INDEX FOR JOB # IN ARG LIST
GOBPPN==1				;INDEX FOR PPN
GOBNAM==2				;INDEX FOR STR NAME

;HIBERNATE UUO

	OPDEF	HIBER [CALLI 72]

HIBNOJ==4	;(LH) ONLY PRIV.JOBS CAN WAKE
HIBPRO==7	;PROTECTION
HIBTTC==10	;WAKE ON TTY CHAR
HIBTTL==20	;(LH) WAKE ON TTY LINE
HIBSWP==400000	;(LH) SWAPOUT IMMEDIATELY



;DISK. UUO

	OPDEF	DISK.[CALLI 121]

.DUUNL==3	;UNLOAD A UNIT
.DUSWP==10	;[174] MIGRATE SWAPPING OFF A UNIT
.DUASW==11	;[177] ADD UNIT TO ACTIVE SWAP LIST
;IPCF STUFF FOR TAPE LABELLING SUPPORT

	OPDEF	IPCFS. [CALLI 143]
	OPDEF	IPCFR. [CALLI 142]

.IPCFL==0	;FLAGS WORD IN HEADER
	IP.CFB==1B0	;DON'T BLOCK ON RECEIVE
	IP.CFT==1B4	;TRUNCATE MSG IF TOO LONG
	IP.CFL==1B5	;MESSAGE LONGER THAN SYSTEM LIMIT
	IP.CFP==1B18	;PRIV BIT
.IPCFR==2		;RECEIVER'S PID
.IPCFP==3		;LENGTH,,ADDR OF PACKET

;**; [170] INSERT BEFORE IPCRY%	CLRH	28-MAR-79
PKT.SZ==12		;[170] MAXIMUM PACKET SIZE
			;[170] NOTE: MAY NOT AGREE WITH %IPCML
IPCRY%==12		;OUT OF SYSTEM STORAGE

%SIIPC==0,,126	;GETTAB FOR PID OF [SYSTEM]IPCC
%SITLP==4,,126	;GETTAB FOR PID OF [SYSTEM] TAPE LABELLER

.IPCS0==0		;FUNCTION WORD FOR MSG TO [SYSTEM]IPCC
	.IPCSQ==7	;SET QUOTAS
.IPCS1==1		;FIRST ARGUMENT(PID TO SET QUOTAS FOR ON FCN 7)
.IPCS2==2		;SECOND ARGUMENT(QUOTAS TO SET ON FCN 7)

;TAPOP STUFF FOR TAPE LABELLING

	OPDEF	TAPOP.[CALLI 154]

.TFWAT==1	;TAPOP. FUNCTION TO WAIT FOR POSITIONING TO FINISH
.TFREW==2		;TAPOP. FUNCTION FOR REWIND
.TFTRK==1010		;TAPOP. TO READ TRACK STATUS (7 OR 9 TRACK TAPE)
.TFLTP==1024		;TAPOP. TO SET LABEL TYPE
.TFPLT==1025		;PRIVILEGED SET TO SET BLP
.TFSET==1000		;OFFSET TO TURN READ INTO SET
	LT.BLP==0		;BYPASS LABEL PROCESSING
	LT.SL==1		;STANDARD LABELS
IFNDEF LT.DEF,<LT.DEF==LT.BLP>	;BYPASS LABELS PROCESSING IS THE DEFAULT
;PULSAR MESSAGES SEND BY OMOUNT

;MOUNT MESSAGE

.MOUFN==1		;FUNCTION CODE FOR MOUNT MESSAGE

MOU.HD==0		;HEADER WORD -- LEN,,FCN
MOU.DV==1		;DEVICE NAME
MOU.JB==2		;JOB NUMBER DOING MOUNT
MOU.OW==3		;PPN OF JOB DOING MOUNT
MOU.LT==4		;LABEL TYPE
MOU.PS==5		;POSITION REQUEST WORD
MOU.DT==6		;EXPIRATION DATE
MOU.PT==7		;PROTECTION OF FILES TO BE WRITTEN
MOU.NV==10		;NUMBER OF VOLUMES IN SET
MOU.WS==11		;REQUESTED WRITE STATUS (=1 IF /RONLY)
MOU.IT==12		;ITN OF THIS REQUEST
MOU.SZ==13		;SIZE OF MOUNT MESSAGE

;VOLID MESSAGE

.VOLFN==2		;FUNCTION CODE FOR VOLID MESSAGE

VOL.HD==0		;HEADER WORD -- LEN,,FCN
VOL.IT==1		;ITN OF THIS REQUEST
VOL.VL==2		;START OFF VOLIDS IN MSG
;OTHER UUO'S AND OPDEFS

OPDEF	PJRST	[JRST]
OPDEF	SYSPHY	[CALLI 51]
OPDEF	SLEEP	[CALLI 31]
OPDEF	PJOB	[CALLI 30]
OPDEF	GETPPN	[CALLI 24]
OPDEF	DEVCHR	[CALLI 4]
   AVAIL.==40	;'DEVICE AVAILABLE' BIT
OPDEF	RESET	[CALLI 0]
OPDEF	EXIT	[CALLI 12]
OPDEF	UTPCLR	[CALLI 13]
OPDEF	DATE	[CALLI 14]
OPDEF	MSTIME	[CALLI 23]
OPDEF	SETNAM	[CALLI 43]
OPDEF	DEVPPN	[CALLI 55]
OPDEF	DEVNAM	[CALLI 64]
OPDEF	SYSSTR	[CALLI 46]
OPDEF	DEVLNM	[CALLI 107]
OPDEF	WAKE	[CALLI 73]
OPDEF	MTAID.	[CALLI 126]
OPDEF	MTCHR.	[CALLI 112]
OPDEF	PEEK	[CALLI 33]
;SWITCH BITS (RH F)

SB.H==     1	;/HELP
SB.WE==1000	;/WENABL
SB.WL==    2	;/WLOCK
SB.RO==SB.WL	;/RONLY
SB.UWL==   4	;/UWLOCK
SB.URO==SB.UWL	;/URONLY
SB.UWE==0	;/UWENAB
SB.M==0		;/MULTI
SB.SSL==  10	;/SYSTEM
SB.S==    20	;/SINGLE
SB.C==    40	;/CHECK
SB.P==   100	;/PAUSE
SB.R==   200	;/REMOVE
SB.VID==400	;/VID:
SB.NOS==2000	;/NOSEARCH
SB.CLR==3777	;BITS TO CLEAR AT BEG3

;OTHER BITS (RH F)

OB.NOC==200000	;1 IF ^C NOT ALLOWED
OB.NED==400000	;BIT FOR 'NOT ENOUGH DRIVES' (PICKD SUBROT)
OB.WFI==4000	;'WAIT FOR USER INPUT'
OB.PRO==10000	;REMEMBER TO TYPE 'PROCEED?'
OB.OPC==20000	;1 IF OPR. COMMAND BEING PROCESSED
OB.UFD==40000	;1 IF WE HAVE THE UFD INTERLOCK
OB.RDF==100000	;1 IF ALLOWED TO CHANGE F/S STATUS
OB.CLR==OB.NED!OB.PRO!OB.OPC!OB.RDF!OB.UFD!OB.NOC ;BITS TO CLEAR AT BEG3

;-------REDEFINE SOME THINGS IF DEBUGGING
IFN DBUGSW,<
SYSFIL==SIXBIT/XXXFIL/	;USE DIFFERENT NAMES SO AS NOT TO INTEFERE WITH OTHER OMOUNTS
SYSMNT==SIXBIT/XXXMNT/
SYSALL==SIXBIT/XXXOMO/
SYSNON==SIXBIT/OMOUNT/
CMDPPX==30,,5051	;USE DIFFERENT '3,3' AREA SO DONT CONFLICT WITH RUNNING OMOUNTS
CMDSTX==SIXBIT/DSKB/
STLPPX==0	;WHERE TO FIND STRLST.SYS
STLSTX==SIXBIT/SYS/
>  ;IFN DBUGSW
SUBTTL	START OF PROGRAM
;START OF PROGRAM

OMOUNT:	JFCL			;IN CASE OF CCL
	SETZB	F,CMDNAM
	SETZM	WAITFG		;CLEAR 'WAIT' FLAG
	SETZM	PRVFND		;SHOW NOTHING FOUND LAST UFD PASS
	MOVE	P,PDP
	INIT	TTY,0
	SIXBIT	/TTY/
	XWD	WH.TTY,RH.TTY
	  EXIT			;NOT MUCH GOOD WITHOUT A TTY
	MOVEI	A,B.TTY
	MOVEM	A,.JBFF
	INBUF	TTY,1
	OUTBUF	TTY,1

	PJOB	A,		;GET OUR JOB
	MOVEM	A,OURJOB
	GETPPN	A,		;GET OUR PPN
	  JFCL			;(JUST IN CASE)
	MOVEM	A,OURPPN

IFN FTTLAB,<
	PUSHJ	P,IPCSET	;SET UP IPCF QUOTAS
	MOVE	A,[%CNDTM]	;GET UNIVERSAL
	GETTAB	A,		;DATE TIME
	  SETZ	A,		;SHOULD NEVER HAPPEN
	MOVEM	A,LABITN	;SAVE AS INTERNAL MSG NUMBER FOR LABELLING
>
	MOVE	A,[XWD %CNTIC,CNFTBL]	;SET UP TO GET JIFFIES/SEC.
	GETTAB	A,
	 MOVEI	A,JIFSEC	;IF GETTAB FAILS,USE DEFAULT
	MOVEM	A,JIFFYS	;SAVE VALUE

IFN R12SW,<	;SOME SPECIAL CASES OF DEBUGGING DONT WANT RUN AS 1,2
	MOVSI	D,%LDFFA		;FAILSAFE PPN
	HRRI	D,.GTLVD		;LEVEL-D:GET PPN FOR OPR
	GETTAB	D,			;IF NOT THE OPERATOR, CLUNK
	  MOVE	D,FSFPPN
	MOVEM	D,FS1PPN		;SAVE IT FOR RAINY DAY IN FUTURE
	CAMN	D,OURPPN		;WE NEED TO BE FAILSAFE PPN
	JRST	START1		;OK
	MOVEI	M,[ASCIZ /?Must be run as /]
	PUSHJ	P,MSG999
	EXIT
>  ;IFN R12SW
START1:	MOVE	A,[IOWD 200,DTADIR]	;MOVE IOWD LIST TO LOW SEG.
	MOVEM	A,DIRIOW
	SETZM	DIRIOW+1
	MOVE	A,[IOWD 200,B.CMD+3]	;GET IOWD FOR UPDATING CMD FILE
	MOVEM	A,AFTIOW	; & STORE INTO LOW SEG
	SETZM	AFTIOW+1	;END THE IOWD LIST

	SETZM	MODE		;START OFF AS 'START:NONE'
	MOVE	A,NAMNON
	SETNAM	A,

	MOVE	A,[XWD STAIND,STATAB]
	GETTAB	A,
	  SETZ	A,
	MOVEM	A,STATES	;SAVE STATES WORD
	TLNE	A,LEVDS
	TLO	F,L.LVD
	MOVE	B,SYSPPC	;LEVEL C DEFAULT SYS PPN
	TLNE	F,L.LVD
	MOVE	B,SYSPPD	;LEVEL D DEFAULT SYS PPN
	MOVSI	A,(SIXBIT .SYS.)
	DEVPPN	A,
	  MOVE	A,B
	MOVEM	A,SYSPPN
;	ROUTINE TO BUILD  THE ACTIVE SWAPPING LIST TABLE
;	THIS IS USED BY USERS, AND DISMOUNT/REMOVE.
;

IFE DBUGSW,<
	MOVSI	A,%LDSWP		;MON. WILL GIVE US THE ADDR.
	HRRI	A,.GTLVD		; OF THE FIRST DRIVE IN THE LIST
	GETTAB	A,			;  (LH) AND THE DISPLACEMENT TO
	 JFCL				;  THE NEXT (RH)
	TRNN	A,-1			;IF NO DISPLACEMENT, USE DEFAULT
	 HRRI	A,SWPDSP
	HRLZI	D,-SWPMAX		;MAKE AOBJN PTR.
	HLRZ	B,A			;B=THE ONE WE'RE ON NOW
	HRRZ	C,A			;C=THE DISPLACEMENT
SWPBL1:	MOVE	A,B			;SET UP THE PEEK

	PEEK	A,			;LOOK AT THE NEXT IN THE LIST
	MOVEM	A,SWPTAB(D)		;SAVE IN SWPTAB
	ADD	B,C			; DITTO
	PEEK	B,			;GET NEXT POINTER
	TLNN	B,-1			;IF 0, END OF LIST
	 JRST	SWPFIN
	HLRZ	B,B			;SWAP HALVES:LH HAS NEXT IN LIST
	AOBJN	D,SWPBL1
	PJRST	ERR096			;WE'RE OUT OF TABLE SPACE

;**; [150] CHANGE AT SWPFIN	CLRH	8-NOV-78
SWPFIN:	MOVNI	D,1(D)			;[150] MAKE AOBJN COUNTER
;[150]SWPFIN:	MOVNS	D			;REMAKE THE REAL AOBJN PTR
	HRLZM	D,SWPAOB
>;	END OF IFE DBUGSW
IFN FTFACT, <
	SETZM	FACTFL		;SHOW DAEMON NOT AVAILABLE
	MOVEI	A,3		;GET DAEMON'S .FACT CODE
	MOVEM	A,FACT		;STORE AS RQST PREFIX
	MOVE	A,[XWD 271000,F.SIZE-1] ;GET RQST HEADER-CODE = 271
	TSO	A,OURJOB	;TURN ON JOB # IN L.H.
	MOVEM	A,F.HEAD	; & STORE IT
	SETZM	F.PPN		;CLEAR 2ND ENTRY WORD
	MOVE	A,[XWD F.PPN,F.PPN+1] ;GET BLT WORD
	BLT	A,FACT+F.SIZE	;CLEAR THE REST OF THE ACCT'G ENTRY
	MOVE	A,[SERIAL]	;GET GETTAB PARMS FOR CPU SERIAL #
	GETTAB	A,		;GET CPU0 SERIAL #
	  SETZ	A,		;  FAILED, ASSUME 0
	HRRZM	A,F.QUE		;STORE INTO ACCT'G ENTRY
	MOVE	A,[1,,FACT]	;GET PARMS FOR ZERO-LTH FACT ENTRY
	DAEMON	A,		;CALL DAEMON TO WRITE IT
	  JRST	DAEFAI		;  ERROR, GO LOOK AT ERROR CODE
	SETOM	FACTFL		;SHOW DAEMON (.FACT) FUNCTION WORKS
NOFACT:				;HERE ON .FACT FAILURE
;**;[115] INSERT @ NOFACT	JNG	20-Sep-75
IFN DBUGSW,<
	SETOM	FACTFL		;[115] GO THROUGH THE MOTIONS ANYWAY
>;[115] END IFN DBUGSW
>;	END OF 	IFN FTFACT
	MOVE	A,[XWD 4,INTLOC];GET LTH OF INTBLK & ADDR OF INT.LOC
	MOVEM	A,INTBLK	;STORE AS 1ST INTBLK WORD
IFE OFFLIN,<
	SETZM	INTBLK+1	;CLEAR 2ND WORD (NO INTERRUPTS PERMITTED YET)
>;	END IFE OFFLIN
IFN OFFLIN,<
	MOVE	A,[XWD 400000,4] ;DISK OFF-LINE INTERCEPT
	MOVEM	A,INTBLK+1
>;	END OF IFN OFFLIN
	SETZM	INTBLK+2	;CLEAR 3RD WORD TO ENABLE TRAPS
	MOVEI	A,INTBLK	;GET ADDR OF INTBLK
	MOVEM	A,.JBINT##	;STORE IN JOBDAT FOR MONITOR
IFE DBUGSW,<

	MOVE	A,[XWD OPQPIN,OPQPTB]
STAR11:	GETTAB	A,		;GET PPN FOR COMMANDS
	  MOVE	A,[CMDPPX]
	MOVEM	A,CMDPPN
	MOVE	A,[XWD OPQSIN,OPQSTB]
STAR12:	GETTAB	A,		;GET STR FOR COMMANDS
	  MOVE	A,[CMDSTX]
	MOVEM	A,CMDSTR
	PUSHJ	P,DSKUUO	;MAKE SURE CMDSTR NOT LOGICAL NAME
	  JRST	START2
	SETZM	NOSTAR			;STARTING OK SO FAR
	MOVE	A,DSKCHA+.STNAM
	CAMN	A,CMDSTR
	JRST	BEG1
START2:	MOVEI	M,[ASCIZ/? /]
	PUSHJ	P,MSGTTY
	MOVE	M,CMDSTR
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ must not be logical name/]
	PUSHJ	P,MSG994
	MOVEI	M,[ASCIZ/ No Structure for User Commands/]
	PUSHJ	P,MSGTTY
	SETOM	NOSTAR		;CAN'T START
	JRST 	BEG1

>  ;IFE DBUGSW

IFN DBUGSW,<	;IF DEBUGGING USE SEPERATE AREA FOR REQUESTS

	MOVE	A,[CMDSTX]
	MOVEM	A,CMDSTR
	MOVE	A,[CMDPPX]
	MOVEM	A,CMDPPN
	JRST	BEG1
PAT:	BLOCK	100

> ;IFN DBUGSW
IFN FTFACT, <
;  DIAGNOSE DAEMON (.FACT) FAILURE
DAEFAI:	SETZB	M,FACTFL	;CLEAR AC & SHOW NO ACCT'G TO BE DONE
	CAMN	A,[1,,FACT]	;TEST FOR AC UNCHANGED
	MOVEI	M,[ASCIZ /%DAEMON was not running
/]				;  YES, POINT AT CORREP. MSG
	CAIN	A,1		;TEST FOR BAD-FUNCTION CODE
	MOVEI	M,[ASCIZ /%.FACT function not in DAEMON
/]				;  YES, POINT AT CORREP. MSG
	CAIN	A,6		;TEST FOR NO-PRIVS CODE
	MOVEI	M,[ASCIZ /%No privs to write FACT file
/]				;  YES, POINT AT CORREP. MSG
	SKIPE	M		;TEST FOR FAILURE DIAGNOSED
	PUSHJ	P,MSGTTY	;  YES, TELL THE OPER
	MOVEI	M,[ASCIZ /%Accounting will not be done
/]				;POINT AT ALL-INCLUSIVE MSG
	PUSHJ	P,MSGTTY	; & TYPE IT, TOO
	JRST	NOFACT		;CONTINUE ON
>;	END OF	IFN FTFACT
SUBTTL	MAJOR COMMAND LOOP - BEGINNING
BEG1:	MOVE	P,PDP		;GET OFF ON THE RIGHT FOOT
	TDZ	F,[XWD L.CLR,OB.CLR!SB.CLR]
	SETZM	CMDNAM
	SETZM	VIDK		;CLEAR COUNT OF VID CHARACTERS
IFN OFFLIN,<
	SETZM	NCHKFG		;CLEAR /NOCHECK FLAG
>;	END IFN OFFLIN
IFN FTTLAB,<
	PUSHJ	P,CLNIPC	;CLEAN UP ANY TURNED AROUND IPCF MESSAGES
>;END IFN FTTLAB
	PUSHJ	P,CONCON

	MOVE	A,[ASCII /
   /]
	MOVEM	A,RPTTY		;NOTE THIS IS A REPEAT OF TTY OUTPUT
	MOVE	A,[ASCIZ/... /]
	MOVEM	A,RPTTY+RPTSIZ+1
	MOVE	A,[XWD RPTTY+1,RPTTY+2]
	SETZM	RPTTY+1		;ZERO THE REPEAT TTY BUFFER
	BLT	A,RPTTY+RPTSIZ	;DO IT
	MOVE	A,[POINT 7,RPTTY+1]
	MOVEM	A,RPTTYB	;INITIALIZE BYTE-POINTER
	MOVEI	A,RPTSIZ*5	; AND BYTE-COUNT
	MOVEM	A,RPTTYC	;
	SETZM	RH.TTY+2	;WIPE THIS INPUT
	TLZE	F,L.TYO		;TEST FOR OUTPUT PENDING
	OUTPUT	TTY,		;  YES, TYPE IT NOW	
	TTCALL	13,0		;CLEAR ^O IF ON		
	  JFCL			;(JUST IN CASE)		
	SKIPE	MODE		;WHAT  MODE?
	JRST	BEG2
	OUTCHR	["/"]		;ONLY LISTENING TO TTY	
	INCHWL	CH
;**; [121]	INSERT @ BEG2-1	JULY 14, 1976	DML
	PUSHJ	P,R.TOK1	;[121] CHANGE LC TO UC
	  JFCL			;[121]
	JRST	OPCOM
BEG2:	OUTCHR	["!"]		;SHOW PROCESSING CMDS	

BEG3:	TTCALL	14,
	SKIPA
	JRST	OPCOMS		;YES-SEE WHAT HE WANTS
	TRZN	F,OB.WFI	;NO--ARE WE SUPPOSED TO WAIT FOR HIM?
	JRST	BEG4		;NO
	SKIPE	WAITFG		;TEST FOR WAITING FOR OPR
	TRO	F,OB.WFI	;  YES, THEN SET WAIT-BIT ON AGAIN
	MOVEI	A,5		;YES-GIVE HIM 5 SECONDS
	MOVSI	B,HIBTTL!HIBSWP	;DO INFINITE SLEEP + IMMED. SWAP	
	HIBER	B,
	  SLEEP	A,
	JRST	BEG3
BEG4:
;**; [167] REMOVE NEXT	CLRH	28-MAR-79
REPEAT	0,<			;[167]
IFN FTTLAB,<
	SKIPN	NXTREQ		;[143] IS THERE A NEXT REQUEST
	SKIPN	NXTFLG		;[143] NO, DOING NEXT PROCESSING
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
	JRST	CKCMD		;GO SEE IF ANY COMMAND-FILES TO DO
NOCMD:				;HERE IF NONE
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	SKIPN	NXTREQ		;[143] NEXT REQUEST PROCESSING
	JRST	BEG5		;[143] NO
	SETZM	NXTREQ		;[143] YES, CLEAR THE REQUEST
	PUSHJ	P,ERR603	;[143] GIVE AN ERROR MESSAGE
BEG5:				;[143]
>;[143] END FTTLAB
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
>				;[167] REMOVE NEXT COMMAND
	SETZM	PRCFLG		;SHOW NOTHING PROCESSED YET
	SKIPE	FNDFLG		;TEST IF SOMETHING FOUND THIS PASS
	SKIPE	PRVFND		;TEST IF SOMETHING FOUND LAST PASS
	  SKIPA			; GO HIBER IF NOTHING FOUND THIS PASS
				;  OR SOMTHING FOUND BOTH PASSES
				;  (A DEFERED CMD FILE WE CAN'T PROCESS YET)
	JRST	NOCMD1		; ELSE GO LOOK AT WHAT WE FOUND
	TLO	F,L.SLP
	MOVEI	A,SLPCOM	;   SO SLEEP AWAILE
	MOVSI	B,HIBTTL!HIBSWP
	HRRI	B,^D60000
	HIBER	B,		;HIBERNATE
	  SLEEP	A,		;  OR IF DOESNT WORK, SLEEP
NOCMD1:	MOVE	A,FNDFLG	;GET CURRENT VALUE OF 'FNDFLG'
	MOVEM	A,PRVFND	;STORE AS PREVIOUS VALUE OF SAME
	SETZM	FNDFLG		;SHOW NO COMMAND FILES FOUND (YET)
	JRST	BEG3		;   AND DO IT AGAIN
SUBTTL	MAJOR COMMAND LOOP - ENDING
;HERE AFTER COMPLETION OF A COMMAND FILE

;**;[111] INSERT @ FSQUIT	JNG	7-Aug-75
FSQUIT:	SETZM	INTBLK+2	;[111] RE-ENABLE INTERRUPTS
	MOVE	C,FSNAME	;UNLOCK UFD
	MOVE	D,FSPPN
	TRZE	F,OB.UFD	;IF ITS LOCKED BY US
	PUSHJ	P,UFDUNL
IFN FILESW,<
	TLNE	F,L.TAPE
IFE UNLOSW,<	MTAPE DTA,1>
IFN UNLOSW,<	MTAPE DTA,11>
>;	END IFN FILESW
COMEN1:	MOVEI	M,[ASCIZ / -Defer- /] ;ASSUME COMMAND DEFERED
	SKIPN	CMDNAM		;TEST FOR COMMAND FILE TO BE DELETED
	TRNE	F,OB.OPC	;TEST FOR [OPR] COMMAND
	MOVEI	M,CMPMSG	;  EITHER, THEN ASSUME COMMAND DONE
	SKIPE	NOTDON		;TEST FOR COMMAND FAILURE
	MOVEI	M,[ASCIZ / -Abort- /] ;  YES, THEN CHANGE MSG
	PUSHJ	P,MSGTTY		;COMPLETED AT

	DATE	A,		;   DATE...
	MOVEM	A,TODAY
	MSTIME	A,		;	  TIME...
 	IDIVI	A,^D60000
	MOVEM	A,NOWMIN
IFE NOTISW,<

	PUSHJ	P,MINOUT
	PUSHJ	P,SPACE
	MOVE	A,TODAY
	PUSHJ	P,DATOUT
	SKIPE	CMDNAM				
IFN DELYSW,<
	TRNE	F,OB.OPC	;DONT PRINT DELAY IF OPER. COMMAND
	JRST	COMEN5
	MOVEI	M,DLYMSG	;DELAY WAS...
	PUSHJ	P,MSG
	MOVE	B,TODAY
	SUB	B,CMDCDA
	IMULI	B,MINDAY
	MOVE	A,NOWMIN
	SUB	A,CMDCTM
	ADD	A,B
	PUSHJ	P,MINOUT
>;	END IFN DELYSW
COMEN5:
> ;IFE NOTISW

	PUSHJ	P,CRLF
IFN FILESW,<
IFN DIAGSW,<

	SKIPN	DIRFLG		;TEST FOR WRITING A DIRECTORY
	JRST	COMEN6		;  NO, JUMP
	MOVEI	IO,W.DIR	;POINT AT DIRECTORY OUTPUT ROUTINE
	MOVEI	M,CMPMSG	;POINT AT 'DONE' MSG
	PUSHJ	P,MSG		;OUTPUT THE MESSAGE
	MOVE	A,NOWMIN	;GET CURRENT TIME OF DAY
	PUSHJ	P,MINOUT	; & OUTPUT IT
	PUSHJ	P,SPACE		;OUTPUT A SPACE
	MOVE	A,TODAY		;GET CURRENT DATE
	PUSHJ	P,DATOUT	; & OUTPUT IT
	PUSHJ	P,CRLF		;END THE LINE
	RELEAS	DIR,		;RELEASE THE DIRECTORY FILE
	SETZM	DIRFLG		;SHOW DIR FILE NOT OPEN NOW
>;	END IFN DIAGSW
>;	END IFN FILESW
COMEN6:				;HERE IF NOT 'FILE' CMD
	SKIPE	CMDNAM		;IF OPR.COMMAND OR 'DEFER'
	JRST	COMEN3
	CLOSE	CMD,0		;   THEN DONT DELETE FILE
	CLOSE	CM1,0
	JRST	COMEN4
COMEN3:	PUSHJ	P,DELCMD	;   OTHERWISE DELETE COMMAND FILE
	MOVE	A,CMDJOB	;   AND WAKE UMOUNT'R
	WAKE	A,
	  JFCL
IFN FTFACT, <
	SKIPN	FACTFL		;TEST FOR FACT-FILE ACCOUNTING
	JRST	NOACT1		;  NO, JUMP AROUND THIS CODE
	SKIPN	A,USRPPN	;GET USER'S PPN & TEST IT
	MOVE	A,OURPPN	;  ZERO, CHARGE IT TO [SELF]
	MOVEM	A,F.PPN		;STORE PPN INTO FACT BLOCK
;**;[115] DELETE @ COMEN3+11	JNG	20-Sep-75
	MOVE	A,OURJOB	;GET MY JOB #
	HRLZ	B,CMDJOB	;GET USER'S JOB #
	HRRI	B,PRJPRG	;COMBINE WITH PPN GETTAB TABLE #
	GETTAB	B,		;GET PPN ASSOC WITH USER'S JOB
	  MOVE	B,USRPPN	;  FAILED, ASSUME OK
	CAME	B,USRPPN	;TEST FOR SAME USER & SAME JOB
	DPB	A,[POINT 9,F.HEAD,17] ; NO, STORE OUR JOB #
;**;[115] INSERT @ COMEN3+27	JNG	20-Sep-75
	LDB	A,[POINT 9,F.HEAD,17]	;[115] GET JOB # OF USER (OR US)
	MOVE	B,A		;[115] MAKE A COPY
	TRMNO.	B,		;[115] FIND OUT WHAT TERMINAL HE'S ON
	  JRST	ACTY10		;[115] FAILED, SEE WHY
	JRST	ACTY30		;[115] GOT IT. GO PUT IT IN FACT FILE
ACTY10:	JUMPN	B,ACTY20	;[115] NOT IMPLEMENTED?
	MOVN	B,A		;[115] SETUP - JOB NUMBER
	JOBSTS	B,		;[115] FIND OUT ABOUT THAT JOB
	  JRST	ACTY20		;[115] HE LOGGED OUT. USE OUR JOB #
	JUMPGE	B,ACTY20	;[115] USE OURS IF HE'S NOT THERE
	MOVNI	B,2		;[115] MARK HIM DETACHED
	JRST	ACTY40		;[115] AND GO RECORD IT
ACTY20:	MOVNI	B,2		;[115] ASSUME WE'RE DETACHED
	GETLIN	A,		;[115] BUT FIND OUT
	TLNN	A,-1		;[115] ARE WE?
	JRST	ACTY40		;[115] YES, GO STORE IT
	SETO	B,		;[115] -1 FOR OUR TERMINAL
	GETLCH	B		;[115] FIND OUT ABOUT IT
	MOVE	A,B		;[115] ANOTHER COPY FOR POSTERITY
	JRST	ACTY35		;[115] GO CHECK THE BITS
ACTY30:	MOVE	A,B		;[115] ANOTHER COPY OF THE USER'S TTY
	GETLCH	A		;[115] GET OLD CHARACTERISTICS WORD
ACTY35:	TLNE	A,(1B1)		;[115] IS THE TERMINAL THE CTY?
	SETO	B,		;[115] YES, SO INDICATE
ACTY40:	DPB	B,[POINT 12,F.HEAD,29]	;[115] AT LAST! STORE THE LINE #
	MOVE	A,[%CNDTM]	;[115] NOW NEED UNIVERSAL DATE/TIME
	GETTAB	A,		;[115] WE PUT IT IN FOR ACCURACY
	  JRST	.+2		;[115] I FAILED, LET DAEMON DO IT
	MOVEM	A,F.DATE	;[115] STORE FOR DAEMON
	SETZ	A,		;CLEAR AC FOR [SELF]
	RUNTIM	A,		;GET MY RUNTIME IN MSEC.
	ADDM	A,F.TIME	;ADD TO -START RUNTIM FOR INCREMENTAL
	HRROI	A,.GTKCT	;GET GETTAB PARMS FOR MY KCT'S
	GETTAB	A,		;GET MY KILO-CORE-TICKS
	  SETZ	A,		;  FAILED, ASSUME ZERO
	ADD	A,F.KCS		;ADD TO -START KCT FOR INCREMENTAL
	IMULI	A,^D100		;CONVERT TO KILO-CORE CENTI-SECONDS
	IDIV	A,JIFFYS
	MOVEM	A,F.KCS
	HRROI	A,.GTRCT	;GET GETTAB PARMS FOR DISK-BLOCKS-READ
	GETTAB	A,		;GET MY # OF DISK-BLOCKS-READ
	  SETZ	A,		;  FAILED, ASSUME ZERO
	TLZ	A,777700	;CLEAR INCRMENTAL OUT
	ADDM	A,F.RCT		;ADD TO -START BLOCKS FOR INCREMENTAL
	HRROI	A,.GTWCT	;GET GETTAB PARMS FOR DISK-BLOCKS-WRITTEN
	GETTAB	A,		;GET MY # OF DISK-BLOCKS-WRITTEN
	  SETZ	A,		;  FAILED, ASSUME ZERO
	TLZ	A,777700	;CLEAR INCRMENTAL OUT
	ADDM	A,F.WCT		;ADD TO -START BLOCKS FOR INCRMENTAL
	MOVE	A,[UPTIME]	;GET GETTAB PARMS FOR UPTIME
	GETTAB	A,		;GET UPTIME FROM SYSTEM
	  SETZ	A,		;  FAILED, ASSUME ZERO
	SUB	A,F.UNIT	;COMPUTE INCREMENTAL UPTIME
	IDIV	A,JIFFYS	;CONVERT TICKS TO SEC
	HRRZM	A,F.UNIT	;STORE MSEC ELAPSED TIME
	SETZ	A,		;CLEAR # OF UNITS
	SKIPN	NOTDON		;TEST FOR FAILED RQST
	MOVSI	A,1		;GET SUCCESS FLAG TO LH
	IORM	A,F.UNIT	;AND SET IN LH OF F.UNIT
	MOVE	N,[F.SIZE,,FACT];GET PARMS FOR DAEMON (.FACT) CALL
;**;[115] INSERT @ NOACT1-5	JNG	20-Sep-75
IFN DBUGSW,<
	PUSHJ	P,RPTFCT	;[115] GO REPORT THE FACT ENTRY TO TTY:
>;[115] END IFN DBUGSW
	DAEMON	N,		;CALL DAEMON TO DO ACCOUNTING
	  PUSHJ	P,DAERR		;  FAILED, TELL US WHY
	MOVE	A,OURJOB	;GET OUR JOB # AGAIN
	DPB	A,[POINT 9,F.HEAD,17] ;RESTORE INTO HEADER
	SETZM	USRPPN		;CLEAR USER'S PPN
NOACT1:				;HERE IF ACCT'G NOT BEING DONE
>;	END OF	IFN FTFACT

COMEN4:	RELEAS	CMD,0
	RELEAS	CM1,
	RELEAS	USR,		;GIVE BACK INIT'D DEVICE IF
				; 'MOUNT' CMD FAILURE	
IFN FILESW,<
	RELEAS	DTA,0
>;	END IFN FILESW
	SETOM	CMDLTH		;SHOW CMD FILE NOT IN-CORE-READABLE
	SETZM	NOTDON		;CLEAR FAILURE FLAG NOW
	JRST	BEG1
IFN DBUGSW,<

	.REQUEST REL:SCAN	;[115] FOR THE TYPE-OUT ROUTINES

;[115] HERE TO PRINT OUT ON THE TTY THE FACT ENTRY JUST PRINTED.

RPTFCT:	PUSHJ	P,.PSH4T##	;[115] SAVE A-D TO BE SAFE
	MOVEI	A,0		;[115] SCAN CAN USE TTCALLS
	PUSHJ	P,.TYOCH##	;[115] PRIME THE PUMP
	OUTSTR	[ASCIZ/
[/]				;[115] START OF MESSAGE
	HLLZ	A,F.QUE		;[115] GET FACT CODE (SIXBIT)
	TLZ	A,77		;[115] ZAP EXTRA BITS
	PUSHJ	P,.TSIXN##	;[115] TYPE THE FACT CODE
	PUSHJ	P,.TSPAC##	;[115] A SPACE
	MOVE	A,F.DEV		;[115] GET THE DEVICE NAME
	PUSHJ	P,.TSIXN##	;[115] TYPE IT
	PUSHJ	P,.TCOLN##	;[115] A COLON
	PUSHJ	P,.TSPAC##	;[115] ANOTHER SPACE
	MOVSI	A,'JOB'		;[115] SOME TEXT
	PUSHJ	P,.TSIXN##	;[115] TYPE IT
	LDB	A,[POINT 9,F.HEAD,17]	;[115] GET THE JOB NUMBER
	PUSHJ	P,.TDECW##	;[115] TYPE
	PUSHJ	P,.TSPAC##	;[115] SPACE OVER
	LDB	A,[POINT 12,F.HEAD,29]	;[115] GET THE TTY NUMBER
	CAIN	A,7777		;[115] THE CTY?
	MOVSI	A,'CTY'		;[115] YES, SO INDICATE
	CAIN	A,7776		;[115] DETACHED?
	MOVSI	A,'DET'		;[115] YUP
	JUMPL	A,RPFCT1	;[115] PRINT DIFFERENTLY IF -1 OR -2
	MOVSI	A,'TTY'		;[115] TELL WHAT WE'RE PRINTING
	PUSHJ	P,.TSIXN##	;[115] TYPE IT
	LDB	A,[POINT 12,F.HEAD,29]	;[115] GET TTY # BACK
	PUSHJ	P,.TOCTW##	;[115] TYPE IT
	JRST	RPFCT2		;[115] AND CONTINUE
RPFCT1:	PUSHJ	P,.TSIXN##	;[115] IF SIXBIT, JUST TYPE IT
RPFCT2:	PUSHJ	P,.TSPAC##	;[115] SPACE OVER SOME
	MOVE	A,F.PPN		;[115] LOAD UP THE PPN
	PUSHJ	P,.TPPNW##	;[115] TYPE IT
	PUSHJ	P,.TSPAC##	;[115] MOVE OVER ONE
	MOVSI	A,'S  '		;[115] PREFIX FOR STATION NUMBER
	PUSHJ	P,.TSIXN##	;[115] OUT IT GOES
	LDB	A,[POINT 6,F.QUE,17]	;[115] STATION NUMBER
	PUSHJ	P,.TOCTW##	;[115] TYPE IN OCTAL
	PUSHJ	P,.TSPAC##	;[115] SEPERATE FROM THE CPU
	MOVSI	A,'CPU'		;[115] INDICATE CPU COMING
	PUSHJ	P,.TSIXN##	;[115] OUT IT GOES
	HRRZ	A,F.QUE		;[115] PICK UP CPU
	PUSHJ	P,.TDECW##	;[115] TYPE IN DECIMAL
	PUSHJ	P,.TSPAC##	;[115] OVER ONE MORE
	MOVE	A,F.DATE	;[115] GET DATE-TIME
	PUSHJ	P,.TDTTM##	;[115] TYPE
	HLRZ	A,F.UNIT	;[115] GET SUCCESS FLAG
	TRNE	A,1		;[115] SUCCESSFUL MOUNT?
	SKIPA	A,[' OK]  ']	;[115] YES
	MOVE	A,[' NO]  ']	;[115] NO
	PUSHJ	P,.TSIXN##	;[115] TYPE END OF LINE
	PUSHJ	P,.TCRLF##	;[115] FINISH IT OFF
	MOVE	A,F.TIME	;[115] GET RUNTIME USED (MSEC)
	PUSHJ	P,.TTIME##	;[115] TYPE FULL SECONDS
	MOVEI	A,"."		;[115] A DECIMAL POINT
	PUSHJ	P,.TCHAR##	;[115] TYPE IT
	MOVE	A,F.TIME	;[115] RESTORE RUNTIME
	IDIVI	A,^D1000	;[115] SEPARATE SECONDS AND MSECS
	MOVE	A,B		;[115] GET MSECS
	PUSHJ	P,.TDECW##	;[115] TYPE THEM
	MOVEI	A,[ASCIZ/ runtime, /]	;[115] TELL WHAT IT WAS
	PUSHJ	P,.TSTRG##	;[115] ..
	MOVE	A,F.KCS		;[115] GET KCS
	IDIVI	A,^D100		;[115] SEPARATE SECONDS & CENTISECONDS
	PUSH	P,B		;[115] SAVE DECIMAL PART
	PUSHJ	P,.TDECW##	;[115] PRINT INTEGER PART
	MOVEI	A,"."		;[115] A DECIMAL POINT
	PUSHJ	P,.TCHAR##	;[115] ..
	POP	P,A		;[115] RESTORE FRACTION
	PUSHJ	P,.TDECW##	;[115] OUT IT GOES
	MOVEI	A,[ASCIZ/ KCS, /]	;[115] TELL WHAT THAT WAS
	PUSHJ	P,.TSTRG##	;[115] ...
	HRRZ	A,F.UNIT	;[115] GET ELAPSED TIME
	IMULI	A,^D1000	;[115] SCAN WANTS MILLISECS
	PUSHJ	P,.TTIME##	;[115] TYPE
	MOVEI	A,[ASCIZ/ elapsed, /]	;[115] WHAT WAS THAT?
	PUSHJ	P,.TSTRG##	;[115] SO TELL ALL
	MOVE	A,F.RCT		;[115] DISK READS
	PUSHJ	P,.TDECW##	;[115] TYPE THEM
	MOVEI	A,[ASCIZ/ reads, /]	;[115] DOCUMENTATION
	PUSHJ	P,.TSTRG##	;[115] ...
	MOVE	A,F.WCT		;[115] WRITES
	PUSHJ	P,.TDECW##	;[115] TYPE THEM
	MOVEI	A,[ASCIZ/ writes
/]				;[115] END THE LINE
	PUSHJ	P,.TSTRG##	;[115] IN GRAND STYLE
	PUSHJ	P,.POP4T##	;[115] RESTORE ALL THE AC'S SAVED
	POPJ	P,		;[115] AND RETURN
>;[115] END IFN DBUGSW
SUBTTL	FIND NEXT QUEUED COMMAND
;HERE TO CHECK FOR COMMAND-FILES
;   JRST TO 'NOCMD' IF NO COMMANDS
;   OTHERWISE PROCESS ONE COMMAND-FILE AND JRST TO FSQUIT
CKCMD:	SKIPN	MODE		;SERVICING ANY USER COMMANDS?
	JRST	NOCMD		;NO
	TLNE	F,L.ODEF	;TEST FOR /DEFER
	JRST	CKCMD1		;  YES, JUMP NOT TO REWIND UFD
	PUSHJ	P,OPNCMU	;OPEN COMMAND FILE UFD
	  JRST	NOCMU
CKCMD1:				;HERE NOT TO REWIND [3,3] UFD
	SETZM	CMDNAM		;SO FSQUIT  WONT TRY TO DELETE NONEX FILE
	TLO	F,L.MNT		;SET MOUNT FLAG (CLEARED FOR DTA STUFF)
	PUSHJ	P,GETCUR	;CALL TO GET & SAVE THE CURRENT TIME & DATE
	SETZM	SCANSW		;CLEAR FOR NON-DEFER SWITCH
	MOVE	D,SAVD		;GET SAVED AOBJN PTR IF /DEFER
	TLNE	F,L.ODEF	;TEST FOR /DEFER GIVEN
	JRST	CKCMD2		;  YES, CONTINUE WITH PREVIOUS SCAN
	MOVSI	D,-TYPL		;GET AN AOBJN PTR FOR CMD-FILE TYPES
CLRCMF:	SETZM	CMFSVD(D)	;CLEAR SAVED CMD-FILE NAME OF THIS TYPE
	AOBJN	D,CLRCMF	;REPEAT FOR ALL TYPES
	SETZM	FNDFLG		;SHOW NOTHING FOUND THIS PASS (YET)
	SETZM	PRCFLG		;SHOW NOTHING PROCESSED (YET)
	MOVSI	D,-TYPL		;LOOK FOR A COMMAND FILE
CKCMD2:	LDB	C,[POINT 6,TYPCOM(D),17]	;CK MODE SWITCH
	TDNN	C,MODE
	JRST	CKCMD4		;NOT LOOKING FOR THIS KIND
	HLRZ	C,TYPCOM(D)	;RIGHT HALF OF C = TYPE DESIRED
	TRZ	C,77
	PUSHJ	P,NXTASK
	  JRST	CKCMD3		;NONE - LOOK FOR NEXT TYPE
IFN FTFACT, <
	SKIPN	FACTFL		;TEST FOR FACT-FILE ACCOUNTING
	JRST	NOACT2		;  NO, JUMP
	SETZ	A,		;CLEAR AC FOR [SELF]
	RUNTIM	A,		;GET MY RUNTIME IN MSEC.
	MOVNM	A,F.TIME	;STORE AS -RUNTIME AT START
	HRROI	A,.GTKCT	;GET GETTAB PARMS FOR MY KILO-CORE-TICKS
	GETTAB	A,		;GET MY KILO-CORE-TICKS SO FAR
	  SETZ	A,		;  FAILED, ASSUME ZERO
	MOVNM	A,F.KCS		;STORE AS -KCT AT START
	HRROI	A,.GTRCT	;GET GETTAB PARMS FOR DISK-BLOCKS-READ
	GETTAB	A,		;GET MY # OF DISK-BLOCKS-READ
	  SETZ	A,		;  FAILED, ASSUME ZERO
	TLZ	A,777700	;CLEAR INCREMENTAL BLOCKS
	MOVNM	A,F.RCT		;STORE AS -BLOCKS AT START
	HRROI	A,.GTWCT	;GET GETTAB PARMS FOR DISK-BLOCKS-WRITTEN
	GETTAB	A,		;GET MY # OF DISK-BLOCKS-WRITTEN
	  SETZ	A,		;  FAILED, ASSUME ZERO
	TLZ	A,777700	;CLEAR INCREMENTAL BLOCKS
	MOVNM	A,F.WCT		;STORE AS -BLOCKS AT START
	MOVE	A,[UPTIME]	;GET GETTAB PARMS FOR UPTIME
	GETTAB	A,		;GET SYSTEM UPTIME
	  SETZ	A,		;  FAILED, ASSUME ZERO
	MOVEM	A,F.UNIT	;STORE FOR LATER & CLEAR LH!
	HRROI	A,.GTLOC	;GET GETTAB PARMS FOR STATION #
	GETTAB	A,		;GET MY STATION #
	  SETZ	A,		;  FAILED, ASSUME ZERO
	MOVE	B,TYPCOM(D)	;GET QUEUE NAME IN BITS 0-5
	TLZ	B,007777	; & CLEAR ALL OTHER BITS
	LSH	B,-6		;PUT QUEUE NAME IN BITS 6-11
	TLO	B,'O  '(A)	;PREFIX W/ LETTER 'O' & INSERT STATION #
	HLLM	B,F.QUE		;STORE AS L.H. OF QUEUE WORD
	MOVSI	A,'???'		;GET UNKNOWN DEVICE NAME
	MOVEM	A,F.DEV		;STORE AS DEVICE NAME
NOACT2:				;HERE IF NO ACCOUNTING
>;	END OF	IFN FTFACT
	HRRZ	C,TYPCOM(D)	;TYPE FOUND OR END OF LIST
	JRST	(C)		;CALL ROUTINE TO PROCESS IT
CKCMD3:	TLZN	F,L.CMDS	;TEST FOR ANY OTHER CMDS
	JRST	NOCMD		;  NONE, QUIT THIS
CKCMD4:	TLZ	F,L.ODEF	;CLEAR /DEFER SWITCH NOW
	AOBJN	D,CKCMD2	;LOOP FOR NEXT CMD CLASS
	JRST	NOCMD		;  NONE, QUIT THIS
TYPCOM:
	XWD	MODEM!SIXBIT .   D.,DICOMF
	XWD	MODEM!SIXBIT .   M.,MOCOMF
IFN FILESW,<
	XWD	MODEF!SIXBIT .   F.,REQTAP
>;	END IFN FILESW
TYPL==.-TYPCOM

NOCMU:	TRNE	B,-1		;WHATS THE PROBLEM?
	JRST	ERR101		;ERROR
	PUSHJ	P,MAKCMU	;NO-UFD  CREATE ONE
	JRST	NOCMD		;AND RETURN FROM CKCMD
;C(WN=TYPE OF COMMAND TO LOOK FOR
;RET+1	NO COMMANDS OF PROPER TYPE
;	OB.CMDS=0 IF NO FILES WITH .CMD AT ALL
;RET+2	IF ONE FOUND
NXTASK:	MOVEM	D,SAVD
	PUSHJ	P,OPNCMD	;FIND A COMMAND FILE
	  JRST	NRET		;NONE OF THE PROPER TYPE
	PUSHJ	P,REWCMD	;START AT BEGINNING OF CMD FILE
	MOVEI	M,BELMSG
	TLZE	F,L.SLP		;WAKE UP OPR IF WE SLEPT
	PUSHJ	P,MSGTTY
PARSE1:	PUSHJ	P,R.CMD		;TYPE COMMAND FILE
	  JRST	ERR099
	CAIN	CH,12
	JRST	PARSE2
	PUSHJ	P,W.TTY
	JRST	PARSE1
PARSE2:	MOVEI	IO,W.TTY
	PUSHJ	P,CRLF
RPARSE:				;HERE IF RESCANNING CMD FILE
	MOVEI	IO,R.CMD
	PUSHJ	P,REWCMD
	PUSHJ	P,SSIXIN		;FIRST ARG TO A AFTER SSST	
	ROT	A,6
	ANDI	A,77		;JUST ONE CHAR
	MOVEM	A,CMDCHR		;TYPE OF COMMAND
	PUSHJ	P,SSST	;GET JOB NUMBER
	PUSHJ	P,(IO)
	  JRST	ERR099
	PUSHJ	P,(IO)
	  JRST	ERR099
	PUSHJ	P,SDECIN
	JUMPE	N,ERR099
	MOVEM	N,CMDJOB
	PUSHJ	P,SSIXIN		;AND ITS TTY			
	MOVEM	A,CMDTTY
	PUSHJ	P,SOCTIN		;PROJECT
	MOVSM	N,USRPPN
	PUSHJ	P,SOCTIN		;AND PROGRAMMER NUMBER
	HRRM	N,USRPPN
IFN FILESW,<
	TLNE	F,L.TAPE	;TEST FOR RESCAN ON DECTAPE DIR ERROR
	JRST	PARSE3		;  YES, SKIP POSSIBLE MSG
>;	END IFN FILESW

;USE FILE AUTHOR IN CASE DIFFERENT THAN ADVERTISED

	MOVE	A,SRCBUF+EXLAUT	;AUTHOR FROM EXTENDED LOOKUP
	CAME	A,USRPPN
	PUSHJ	P,MSG210
	MOVEM	A,USRPPN
	MOVEI	IO,R.CMD	;RESTORE CMD-FILE I/O PTR

PARSE3:	PUSHJ	P,SSIXIN		;AND TAPE NUMBER OR FILE STRUCTURE NAME 
	MOVEM	CH,TERMCH		;SAVE TERMINATING CHAR
	MOVEM	A,CMDTAP
	TLNE	F,L.TAPE	;TEST FOR RESCAN ON DECTAPE DIR ERROR
	POPJ	P,		;  YES, RETURN TO CALLER
	AOS	(P)		;SKIP RETURN
NRET:	MOVE	D,SAVD
	SETZM	CMFSVD(D)	;CLEAR SAVED CMD-FILE NAME OF THIS TYPE
	POPJ	P,
REWCMU:	MOVE	A,CMDPPN
	MOVSI	B,(SIXBIT .UFD.)
	SETZ	C,
	MOVE	D,MFDPPN
	LOOKUP	CMU,A
	  JSP	N,DSKERR
	POPJ	P,

;**;[113] CHANGE @ REWCMD	JNG	8-Sep-75
REWCMD:	MOVEI	A,EXLLEN-1	;[113]
	MOVEM	A,SRCBUF
	MOVE	A,CMDNAM
	MOVEM	A,SRCBUF+EXLNAM
	MOVSI	B,(SIXBIT /CMD/)
	MOVEM	B,SRCBUF+EXLEXT
	MOVE	D,CMDPPN
	MOVEM	D,SRCBUF+EXLPPN
	SKIPLE	CMDLTH		;TEST FOR FILE PREVIOUSLY READ
 	JRST	REWDON		;  YES, GO RESET BUFFER PTRS
	LOOKUP	CMD,SRCBUF		;WE KNOW THE FILE EXISTS
	  JRST	ERR098
;**; [160] INSERT AT REWCMD+13 1/2	CLRH	8-DEC-78
	LDB	A,[POINTR (SRCBUF+EXLATT,RB.CRT)]	;[160] GET CREATION TIME
	IMULI	A,^D60000	;[160] CONVERT TO MILLISECONDS
	LDB	B,[POINTR (SRCBUF+EXLEXT,RB.CRX)]	;[160] GET EXT. OF CR. DATE
	LSH	B,^D12		;[160] SHIFT OVER
	LDB	C,[POINTR (SRCBUF+EXLATT,RB.CRD)]	;[160] GET BASE CREATION DATE
	IOR	B,C		;[160] UNITE CREATION DATE
	PUSHJ	P,CONVDT	;[160] CONVERT TO UNIVERSAL DATE/TIME
	MOVEM	A,CMDDTM	;[160] SAVE IT
	SKIPE	CMDLTH		;TEST FOR 1-BLOCK FILE
	POPJ	P,		;  NO, RETURN
	INPUT	CMD,0		;READ THE ENTIRE FILE IN
	STATZ	CMD,740000	;TEST FOR I/O ERROR
	PJRST	CMDER		;  YES, GO PROCESS IT
	STATZ	CMD,20000	;TEST FOR EOF
	PJRST	CMDEOF		;  YES, GO PROCESS IT
	MOVE	C,RH.CMD+2	;GET INPUT BYTE COUNT
	MOVEM	C,CMDLTH	; & SAVE IT (NOTE THAT +VALUE SETS A SWITCH)
	MOVE	C,RH.CMD+1	;GET INPUT BYTE POINTER
	MOVEM	C,CMDSBP	; & SAVE IT, TOO
	POPJ	P,		;RETURN TO CALLER

REWDON:	MOVE	C,CMDLTH	;GET SAVED BYTE COUNT
	MOVEM	C,RH.CMD+2	; & RESTORE BUFFER HEADER
	MOVE	C,CMDSBP	;GET SAVED BYTE POINTER
	MOVEM	C,RH.CMD+1	; & RESTORE IT, TOO
	POPJ	P,		;RETURN TO CALLER
;**; [160] INSERT BEFORE DELCMD	CLRH	8-DEC-78
;[160] CONVDT CONVERTS A DATE IN OLD FORMAT AND TIME IN MILLISECONDS SINCE
;[160] MIDNIGHT TO SMITHSONIAN (UNIVERSAL) DATE/TIME FORMAT.
;[160] CALLED WITH:
;[160]     A = TIME (MILLISECONDS SINCE MIDNIGHT)
;[160]     B = DATE (OLD FORMAT)
;[160] RETURNS SMITHSONIAN (UNIVERSAL) DATE/TIME IN A.
;[160]
	RADIX	10		;[160] * * * NOTE WELL ! * * *

CONVDT:	PUSH	P,A		;[160] SAVE TIME TO PROCESS LATER
	IDIVI	B,12*31		;[160] B = YEARS - 1964
	CAILE	B,2217-1964	;[160] SEE IF AFTER 2217
	 JRST	GETNW2		;[160] YES, RETURN -1 (TOO BIG)
	IDIVI	C,31		;[160] C = MONTHS - JAN., D = DAYS - 1
	ADD	D,MNTAB(C)	;[160] D = DAYS - JAN. 1
	MOVEI	E,0		;[160] LEAP YEAR ADDITIVE IF JAN. OR FEB.
	CAIL	C,2		;[160] CHECK MONTH
	 MOVEI	E,1		;[160] ADDITIVE IF MAR. THRU DEC.
	MOVE	A,B		;[160] SAVE YEARS FOR REUSE
	ADDI	B,3		;[160] OFFSET SINCE LEAP YEAR DOES NOT GET COUNTED
	IDIVI	B,4		;[160] HANDLE REGULAR LEAP YEARS
	CAIE	C,3		;[160] SEE IF THIS IS A LEAP YEAR
	 MOVEI	E,0		;[160] NO, WIPE OUT ADDITIVE
	ADDI	D,<1964-1859>*365+<1964-1859>/4+<31-18>+31(B)
				;[160] D = DAYS BEFORE JAN. 1, 1964
				;[160]  + DAYS SINCE JAN 1., 1964
				;[160]  + ALLOWANCE FOR LEAP YEARS SINCE 1964
	MOVE	B,A		;[160] RESTORE YEARS SINCE 1964
	IMULI	B,365		;[160] DAYS SINCE 1964
	ADD	D,B		;[160] D = DAYS EXCEPT FOR 100 YEAR FUDGE
	HRREI	B,64-100-1(A)	;[160] B = YEARS SINCE 2001
	JUMPLE	B,GETNW1	;[160] ALL DONE IF NOT YET 2001
	 IDIVI	B,100		;[160] GET CENTURIES SINCE 2001
	 SUB	D,B		;[160] ALLOW FOR LOST LEAP YEARS
	 CAIE	C,99		;[160] SEE IF THIS IS A LOST LEAP YEAR
GETNW1:	 ADD	D,E		;[160] ALL FOR LEAP YEAR THIS YEAR
	CAILE	D,^O377777	;[160] SEE IF TOO BIG
GETNW2:	 SETOM	D		;[160] YES, SET TO -1
	POP	P,A		;[160] RESTORE MILLISECOND TIME
	MOVEI	B,0		;[160] CLEAR OTHER HALF
	ASHC	A,-17		;[160] POSITION
	DIV	A,[24*60*60*1000]	;[160] CONVERT TO 1/2**18 DAYS
	HRL	A,D		;[160] INCLUDE DATE
	POPJ	P,		;[160] RETURN (RESULT IS IN A)

;[160] DAY NUMBERS OF ENDS OF MONTHS

MNTAB:	EXP	0,31,59,90,120,151,181,212,243,273,304,334,365	;[160]

	RADIX	8		;[160] * * * NOTE WELL ! * * *
;DELETE COMMAND FILE HELD ON CMD & CM1

DELCMD:	SETZB	A,B		;SETUP FOR RENAME
	SETZB	C,CMDNAM	;CLEAR AC & FILENAME	
	MOVE	D,CMDPPN
	CLOSE	CMD,0	;CLOSE THE COMMAND FILE
	RENAME	CM1,A		;DELETE COMMAND FROM QUEUE
	PJRST	NEVMSJ
	POPJ	P,


;OPEN & LOOKUP COMMAND UFD ON CMU
;RET+0	NO UFD EXISTS
;RET+1	NORMALLY

OPNCMU:	MOVE	A,[PHOPEN,,14]	;OPEN COMMAND FILE DEVICE 
	MOVE	B,CMDSTR
	MOVEI	C,RH.CMU
	OPEN	CMU,A
	JSP	N,DSKERR

	MOVEI	A,B.CMU
	MOVEM	A,.JBFF
	INBUF	CMU,1

	MOVE	A,CMDPPN		;LOOKUP COMMAND UFD
	MOVSI	B,(SIXBIT /UFD/)
	MOVEI	C,0
	MOVE	D,MFDPPN
	LOOKUP	CMU,A		;SEE IF COMMAND AREA EXISTS
	  POPJ	P,		;NO COMMAND UFD
	JRST	CPOPJ1
;THIS ROUTINE SEARCHES THE COMMAND AREA FOR THE NEXT COMMAND
;THE TYPE OF COMMAND REQUESTED IS IN THE RIGHT HALF OF C
;  IF C=0 ALL TYPES WILL DO
;RET+1	IF NO COMMANDS OF REQUESTED TYPE
;	OB.CMDS=0 IF NO FILES WITH .CMD EXTENSION AT ALL
;RET+2	IF ONE FOUND

OPNCMD:				;HERE TO FIND & LOOKUP A CMD FILE
	TLZE	F,L.ODEF	;TEST FOR /DEFER CMD
	JRST	ASK1		;  YES, RESUME PREVIOUS SCAN
	TLZ	F,L.CMDS
	MOVEM	C,SAVC
	SETOM	REWFLG		;SET -1 TO SHOW UFD REWIND REQ'D
	TRNE	F,OB.OPC	;TEST FOR /KILL
	JRST	ASK1		;  YES, JUST READ THE UFD
	MOVE	A,SAVD		;GET SAVED CMD-FILE TYPE
	SKIPE	A,CMFSVD(A)	;GET SAVED CMD-FILE NAME & TEST IT
	JRST	ASK2		;  NAME SAVED, GO PROCESS IT 1ST!
ASK1:	AOSG	REWFLG		;TEST FOR UFD REWIND REQ'D
;**; [175] CHANGE AT ASK1 + 1	CLRH	4-APRIL-79
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
;[175]REPEAT	0,<		;[167] REMOVE NEXT COMMAND
;[175]IFE FTTLAB,<
	PUSHJ	P,REWCMU	;[143]  YES, GO DO IT NOW
;[175]>;[143] END FTTLAB
;[175]>				;[167] REMOVE NEXT COMMAND
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	PUSHJ	P,[SETZM CURREQ	;[143] CLEAR THE CURRENT REQUEST NUMBER ON REEWIND
		JRST	REWCMU]	;[143] REWIND THE UFD
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
	PUSHJ	P,R.CMU		;READ THE NEXT FILENAME FROM THE UFD
	  POPJ	P,		;  EOF, RETURN +0
	MOVE	A,WD
	PUSHJ	P,R.CMU		;READ EXT
	  POPJ	P,		;  EOF, RETURN +0
	HLRZ	B,WD
	CAIE	B,(SIXBIT .CMD.)
	JRST	ASK1		;IF EXT IS NOT CMD, ITS NOT OUR BABY
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<		;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	AOS	CURREQ		;[143] UPDATE THE REQUEST NUMBER
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
	TRNE	F,OB.OPC	;TEST FOR /KILL
	JRST	ASK1A		;  YES, JUMP
	MOVE	C,SAVD		;GET SAVED CMD-FILE TYPE
	CAMN	A,CMFSVD(C)	;TEST FOR PREVIOUSLY USED CMD FILE
	JRST	ASK1		;  YES, IGNORE IT NOW

ASK1A:				;HERE IF NOT USING SAVED FILENAMES
	HLRZ	C,A		;C=LEFT HALF OF FILE NAME
	TRZ	C,7777		;1ST CHAR ONLY
	SKIPE	SAVC
	CAMN	C,SAVC
	JRST	ASK2		;STILL CANT GET A MATCH
	TRNE	F,OB.OPC	;TEST FOR /KILL
	JRST	ASK1		;  YES, KEEP ON READING THE UFD
	MOVSI	D,-TYPL		;GET AOBJN PTR FOR CMD-FILE TYPES
ASK1B:	HLRZ	B,TYPCOM(D)	;GET CODE-LETTER FOR THIS CMD-FILE TYPE
	TRZ	B,77		; & CLEAR FLAG BITS
	CAIE	B,(C)		;TEST FOR MATCHING TYPE
	AOBJN	D,ASK1B		;  NO MATCH, REPEAT W/NEXT TYPE
	JUMPGE	D,ASK1		;JUMP TO IGNORE CMD-FILE IF NOT MATCHED
	LDB	B,[POINT 6,TYPCOM(D),17] ;GET CMD-FILE TYPE'S FLAG BITS
	TDNN	B,MODE			 ;TEST FOR PERMITTED MODE
	JRST	ASK1			 ;  NO, IGNORE THIS CMD-FILE
	SKIPN	CMFSVD(D)	;TEST FOR CMD FILE OF THIS TYPE SAVED YET
	MOVEM	A,CMFSVD(D)	;  NO, SAVE IT NOW
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	SKIPE	NXTFLG		;[143] IS THERE A NEXT REQUEST PROCESSING
	SETZM	CMFSVD(D)	;[143] YES, CLEAR SAVED COMMAND
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
	SETOM	FNDFLG		;SHOW COMMAND FILE FOUND THIS PASS
	TLO	F,L.CMDS
	JRST	ASK1

ASK2:
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	SKIPE	NXTFLG		;[143] DOING NEXT PROCESSING
	SKIPN	B,NXTREQ	;[143] YES, SPECIAL NEXT COMMAND
	JRST	ASK3		;[143] NO, CONTINUE
	CAME	B,CURREQ	;[143] IS THIS THE REQUEST
	JRST	ASK1		;[143] NO, TRY AGAIN
	SETZM	NXTREQ		;[143] YES, CLEAR THE REQUEST
ASK3:				;[143]
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
	MOVEM	A,CMDNAM	;GOT A COMMAND FILE
	MOVE	B,CMDSTR
	MOVSI	A,PHOPEN				
	MOVEI	C,RH.CMD
	OPEN	CMD,A
	  JSP	N,DSKERR
	MOVEI A,B.CMD
	MOVEM A,.JBFF
	INBUF CMD,1
;MAKE SURE THIS COMMAND NOT BEING 'HELD' BY ANOTHER OMOUNT

	MOVE	A,[PHOPEN,,17]	;OPEN 'HOLDING CHAN' (CM1) 
	SETZM	C
	OPEN	CM1,A
	  JSP	N,DSKERR

	MOVE	A,CMDNAM	;LOOKUP THE COMMAND FILE
	MOVSI	B,(SIXBIT/CMD/)
	MOVE	D,CMDPPN
	LOOKUP	CM1,A
	  JRST	ASK1		;SOME ONE JUST GOT IT?
	HLRES	D		;COPY LTH FROM L.H. TO R.H. & EXTEND SIGN
	MOVNS	D		;NOW MAKE LTH + IF WORDS, - IF BLOCKS
	SETZM	CMDLTH		;SET FLAG 0, ASSUMING 1-BLOCK FILE
	SKIPLE	D		;TEST FOR 0-LTH OR BIG FILE
	CAILE	D,^D128		;TEST FOR FILE.LE.1 BLOCK LONG
	SETOM	CMDLTH		; EITHER TOO BIG/SMALL, SET FLAG -
	LDB	D,PCRETM	;GET FILE'S CREATION TIME
	MOVEM	D,CMDCTM	; & SAVE IT
	LDB	D,PCREDA	;GET FILE'S CREATION DATE
	MOVEM	D,CMDCDA	; & SAVE IT
	LDB	D,[POINT 3,B,20];GET 15-BIT PART OF THE DATE
	MOVEM	D,HICRDT	;STORE HIGH PART OF CREATION DATE
	DPB	D,[POINT 3,CMDCDA,23] ; & SAVE IT, TOO
	MOVEM	C,CRDTMP	;STORE PROT, CREATION DATE/TIME
	MOVE	D,CMDPPN	;NOW TRY AN ENTER TO SEE IF ITS FREE
	ENTER	CM1,A
	  JRST	ASK1		;   NOT FREE (ANOTHER OMOUNT HAS IT)
	SKIPN	NODEFR		;SKIP IF OPR WANTS TO PROCESS DEFER'S
	TRNE	F,OB.OPC	;TEST FOR /KILL
	JRST	ASK2A		;  YES, JUMP (NOT CHECKING /AFTER TIMES)
	PUSHJ	P,AFTCHK	;CHECK THE CMD FILE FOR /AFTER LIMITATIONS
	  SKIPA			;  NOT TIME YET, SKIP
	JRST	ASK2A		;  TIME YET, JUMP
	CLOSE	CM1,		;RELEASE THE FILE FOR OTHER OMOUNT'S
	JRST	ASK1		;KEEP ON READING
ASK2A:				;HERE IF NOT CHECKING /AFTER TIMES
	SETOM	FNDFLG		;SHOW COMMAND FILE FOUND THIS PASS
	JRST	CPOPJ1
IFN FILESW,<
SUBTTL	FILE COMMAND PROCESSING
REQTAP:	MOVEI	IO,W.TTY		;ENTER HERE FROM FILE COMMAND
IFE DIAGSW, <
	TLZ	F,L.MNT		;CLEAR MOUNT FLAG CAUSE WE ARE DTA STUFF
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
	TLZ	F,L.MNT!L.DECER	;CLEAR MOUNT & ERROR FLAGS FOR FILE CMD
	SETZM	DIRFLG		;SHOW 'DIR' FILE NOT OPEN
>;	END OF	IFN DIAGSW
	MOVEI	M,MNTMSG
	PUSHJ	P,MSG		;ASK OPR TO PLEASE MOUNT
	MOVE	M,CMDTAP
	PUSHJ	P,SIXMSO		;OUR TAPE
	MOVEI	M,FORMSG
	PUSHJ	P,MSG		;FOR USER

	HLRZ	N,USRPPN
	PUSHJ	P,OCTPRT		;PROJECT
	PUSHJ	P,COMMA
	HRRZ	N,USRPPN
	PUSHJ	P,OCTPRT		;PROGRAMMER
	MOVEI	M,[ASCIZ/]
/]				;START A NEW LINE	
	PUSHJ	P,MSGTTY
RQTAP4:	MOVEI	M,WRLMSG
	MOVE	D,CMDCHR
	CAIE	D,"Z"-40		;IF Z
	CAIN	D,"F"-40		;OR F
	MOVEI	M,WRTMSG
	CAIN	D,"D"-40		;TEST FOR D -
	MOVEI	M,WRTMSG
	CAIN	M,WRTMSG	;TEST FOR WRITING ON DECTAPE
	TRO	F,SB.WE		;  YES, SET BIT TO REMEMBER
	PUSHJ	P,MSGTTY		;REQUEST WRITE ENABLE OR LOCK
	MOVEI	M,DRVMSG
	PUSHJ	P,MSGTTY		;ON DRIVE:
;TYPE (N): IF DTAN IS ASSIGNED

	SETOM	DTDRIV
	MOVSI	A,(SIXBIT/DTA/)	;IS A DTA ASSIGNED?
IFN FTFACT, <
	MOVEM	A,F.DEV		;STORE 'DTA' AS ACCT'G DEVICE NAME
>;	END OF IFN FTFACT
RQTAPB:	MOVS	C,A		;SAVE SWAPPED DEVICE NAME FOR LATER TESTS
	DEVNAM	A,PHONLY				
	  JRST	RQTAP8		;  ERROR, JUMP
	MOVE	B,A		;SAVE IT IN B
	DEVCHR	A,PHONLY	;ASSIGNED?		
	TLNE	A,DVDTA		;TEST FOR DECTAPE	
	TLNN	A,DC.AVA	;AVAILABLE TO OMOUNT?
	JRST	RQTAP8		;  NOT AVAILABLE DECTAPE, JUMP
	MOVEM	B,DTDRIV
	MOVE	M,B		;FOR SIXMSO
	JRST	RQTAP5		;GO ASK THE OPER
RQTAP8:	MOVSI	A,'DTB'		;ASSUME 2ND CONTROLLER
	CAIE	C,'DTB'		;TEST FOR ALREADY DONE NOW
	JRST	RQTAPB		;  NO, GO DO IT NOW
	MOVSI	M,'DTA'		;  YES, THEN ASSUME 'DTA' AS DEFAULT
	MOVEM	M,DTDRIV	;STORE AS CONTROLLER NAME
				;FALL THRU TO 'RQTAP5'
RQTAP5:				;HERE WITH POTENTIAL DRIVE SELECTED
	PUSHJ	P,SIXMSO	;TYPE THE DRIVE NAME
	PUSHJ	P,COLON
	OUTPUT	TTY,		;FORCE OUTPUT
	MOVEI	IO,R.TTY
	MOVEI	M,FILHLP
	PUSHJ	P,OPRARG
	JRST	.+1(N)	;DISPATCH ON N

	JRST	RQTAP7	;0-LONE C.R
	JUMPN	A,RQTAP6;1-NOT LONE C.R.
	JRST	RQTAP4	;2-/HELP
	JRST	RQTAP9	;3-SOME GARBAGE
	JRST	RQTAP9	;4-ERROR

RQTAP7:	MOVE	A,DTDRIV
RQTAP6:	TRNN	A,-1		;TEST FOR FULL DEVICE NAME TYPED
	JRST	RQTP6A		;  NO, GO LOOK AT SINGLE DIGIT
;[101]	TRNE	A,007777	;TEST FOR MORE THAN 4 CHARS TYPED
;[101]	JRST	RQTAP9		;  YES, TYPE AN ERROR MSG
	HLRZ	C,A		;COPY 1ST THREE CHARS
	CAIE	C,'DTA'		;TEST FOR 'DTA'
	CAIN	C,'DTB'		;TEST FOR 'DTB'
	JRST	RQTP6B		;  EITHER, JUMP
	JRST	RQTAP9		;  NEITHER, GIVE ERROR MSG
RQTP6A:	ROT	A,6		;PUT 1ST CHAR IN L.O. BITS
	CAIL	A,'0'		;TEST FOR LEGAL OCTAL
	CAILE	A,'7'		;TEST FOR LEGAL OCTAL
	JRST	RQTAP9		;  NO, GIVE ERROR MSG
	LSH	A,^D12		;PUT IN 4TH CHAR POSITION
	HLL	A,DTDRIV	;FILL IN DEFAULT CONTROLLER NAME
RQTP6B:	MOVE	B,A		;SAVE DRIVE NAME
	DEVCHR	A,PHONLY	;FIND OUT ABOUT THE DEVICE
	JUMPE	A,RQTAP9	;  NON-EXISTENT, GIVE AN ERROR
	MOVEM	B,DTDRIV	;SAVE THE DRIVE NAME
RQTAP1:	TLNE	A,DVDTA		;MUST BE A DECTAPE
	JRST	RQTAP2
	PUSHJ	P,MSG702
	JRST	RQTAP4
RQTAP2:	TLNE	A,AVAIL.		;AND AVAILABLE
	JRST	RQTAP3
	PUSHJ	P,MSG701
	JRST	RQTAP4
RQTAP3:	MOVEM	A,DEVMOD	;SAVE DEVCHR BITS FOR THIS DECTAPE
	MOVSI	A,(Z DTA,)	;GET CHANNEL # TO USE
	PUSHJ	P,CKDTID	;GO CHECK DECTAPE ID, ET AL.
	  JRST	REQTAP		;  OPEN ERROR, TRY AGAIN
	  JRST	RQTAP4		;  ID FAILURE, GET ANOTHER DRIVE
	MOVE	B,DTDRIV	;RESTORE DTA DRIVE #
	TLO	F,L.TAPE	;NOW WE KNOW WE HAVE A TAPE
	SETZM	DTWTAB		;CLEAR WILD-CARD FILE-USE TABLE
	RELEAS	DTA,0		;SO MONITOR WILL READ DTDIR
	MOVE	A,[PHOPEN,,14]	;FURTHER I/O IF BINARY BUFFERED 
	MOVE	C,[XWD WH.DTA,RH.DTA]
	OPEN	DTA,A		;GET DTA AGAIN
	JSP	N,DTERR		;SHOULDNT FAIL
IFN FTFACT, <
	MOVE	A,DTDRIV	;GET ACTUAL DRIVE NAME
	MOVEM	A,F.DEV		;STORE AS DEVICE NAME
>;	END OF	IFN FTFACT
	MOVE	D,CMDCHR
	CAIN	D,"Z"-40		;FIND OUT WHAT WE'RE EXPECTED TO DO
	JRST	ZCOM
	CAIN	D,"F"-40
	JRST	FCOM
	CAIN	D,"R"-40
	JRST	RCOM
	CAIN	D,"D"-40
	JRST	DCOM
	CAIN	D,"L"-40
	JRST	LCOM
	JRST	ERR099		;BAD COMMAND FILE FORMAT

RQTAP9:	PUSHJ	P,MSG200	;/H FOR HELP
	JRST	RQTAP4


	;WRITE DIRECTORY AS DISK FILE TAPENUM.DIR

LCOM:	MOVEI	IO,R.CMD
	PUSHJ	P,SSIXIN				
	SKIPN	B,A
	MOVSI	B,(SIXBIT .DSK.)
	JRST	.+2
IFN DIAGSW, <

;  SUBROUTINE TO OPEN THE 'DIR' FILE IF L.DECER BIT IS ON
;  IN L.H. OF AC 'F'.  CALL AS FOLLOWS:
;	TLO	F,L.DECER
;	PUSHJ	P,LCOM1
;	<RETURN>

>;	END OF	IFN DIAGSW
LCOM1:	MOVE	B,DIRDEV
IFN DIAGSW, <
	TLNE	F,L.DECER	;TEST FOR DTA-ERROR REPORTING
	PUSH	P,FILDEV	;  YES, SAVE PREVIOUS FILDEV
>;	END OF	IFN DIAGSW
	MOVEM	B,FILDEV
DCRTRY:	MOVSI	A,PHOPEN				
IFN DIAGSW, <
	SKIPE	DIRFLG		;TEST FOR DIR ALREADY OPEN
	JRST	LCOM3		;  YES, JUMP
>;	END OF	IFN DIAGSW
	HRLZI	C,WH.DIR	;GET OUTPUT BUFFER HDR ADDRESS
	OPEN	DIR,A		;OPEN THE STR
	  JSP	N,DSKERR	;  ERROR, GO PROCESS IT
	MOVEI	A,B.DIR		;POINT AT BUFFER ADDRESS
	MOVEM	A,.JBFF		;STORE FOR MONITOR
	OUTBUF	DIR,1		;GET 1 BUFFER ASSIGNED
	SKIPN	A,CMDTAP		;TAPE NUM IS FILE NAME
	MOVSI	A,(SIXBIT /DIR/)	;DIR IF 0
	MOVSI	B,(SIXBIT /DIR/)	;EXT IS DIR
	MOVEI	C,0
	MOVE	D,USRPPN
	ENTER	DIR,A		;ENTER THE DIRECTORY FILE
	  JRST	DCNUFD		;  ERROR, GO LOOK AT IT
	MOVEI	IO,W.DIR	;POINT AT OUTPUT ROUTINE
	MOVEI	CH,13		;GET A <VT> CHARACTER
	PUSHJ	P,W.DIR		; & START THE DIR WITH IT!
	SKIPE	A,DTADIR+177	;GET DECTAPE'S ID WORD & TEST FOR ZERO
	CAMN	A,[-1]		;TEST FOR MINUS ONE
;**;[112] CHANGE @ DCRTRY+25	JNG	8-Aug-75
	MOVE	A,CMDTAP	;[112] 0 OR -1, GET USER-SPECIFIED TAPE ID
	JUMPE	A,LCOM2		;JUMP IF TAPE ID NOT FOUND ANYPLACE
	PUSH	P,A		;SAVE TAPE ID
	MOVEI	M,[ASCIZ /
Tape ID: /]			;POINT AT HEADING MSG
	PUSHJ	P,MSG		; & OUTPUT IT
	POP	P,M		;RESTORE CHOSEN TAPE ID
	PUSHJ	P,SIXMSO	;OUTPUT THE TAPE ID
LCOM2:	PUSHJ	P,CRLF		;END THE LINE
IFN DIAGSW, <
	SETOM	DIRFLG		;SHOW DIR FILE OPENED
LCOM3:				;HERE IF FILE PREVIOUSLY OPEN
	MOVEI	IO,W.USR	;POINT AT OUTPUT ROUTINE
	TLZN	F,L.DECER	;TEST FOR DTA-ERROR REPORTING
	JRST	LCOM4		;  NO, JUMP
	POP	P,FILDEV	;RESTORE FILDEV
	POPJ	P,		;RETURN TO CALLER
LCOM4:				;HERE TO WRITE THE DIRECTORY
>;	END OF	IFN DIAGSW
	MOVEI	M,FREMS1	;POINT AT MSG - 'FREE: '
	PUSHJ	P,MSG		; & TYPE IT
	SETZ	D,		;SET FILE #0 FOR FREE BLOCKS
	PUSHJ	P,DTDCNT	;GO COUNT FREE BLOCKS
	PUSHJ	P,DECPRT	;TYPE # OF FREE BLOCKS
	MOVEI	M,FREMS2	;POINT AT MSG - ' BLOCKS, '
	PUSHJ	P,MSG		; & TYPE IT
	MOVEI	N,DTDNFI	;GET MAXIMUM # OF FILES PERMITTED
	MOVSI	D,-DTDNFI	;GET AOBJN PTR FOR DTA'S FILES
LCOM5:	SKIPE	DTDFIL(D)	;TEST FOR FREE FILE-SLOT
	SUBI	N,1		;  NO, SUBTRACT ONE FOR USED SLOT
	AOBJN	D,LCOM5		;REPEAT FOR ALL SLOTS
	MOVE	A,N		;SAVE # OF FILES FREE
	PUSHJ	P,DECPRT	;TYPE # OF FREE FILES
	MOVEI	M,FREMS3	;POINT AT MSG - ' FILES<CR><LF>'
	PUSHJ	P,MSG		; & TYPE IT
	CAIL	A,DTDNFI	;TEST FOR ALL FILES FREE
	JRST	LCOMN2		;  YES, JUMP FOR SPECIAL MSG
	MOVSI	D,-DTDNFI		;NUMBER OF FILES ON DTA
	HRRI	D,1
LCOML:	SKIPN	M,DTDFIL-1(D)
	JRST	LCOMN		;NO FILE NAME IN THIS SLOT
	PUSHJ	P,SIXMSG		;SO PUT OUT THE FILE
	PUSHJ	P,DOT
	HLLZ	M,DTDEXT-1(D)	;EXTENSION
	PUSHJ	P,SIXMS4		;OUTPUT EXACTLY 4 CHARS
	PUSHJ	P,DTDCNT		;COUNT ITS BLOCKS
	PUSHJ	P,DECPR3
	PUSHJ	P,TAB
	LDB	A,[POINT 12,DTDEXT-1(D),35]
	MOVEI	B,1		;GET BIT TO TEST WITH
	TDNE	B,DTADIR+<0*DTDNFI>-1(D) ;TEST FOR BIT STORED
	TRO	A,1B23		;  YES, SET IT
	TDNE	B,DTADIR+<1*DTDNFI>-1(D) ;TEST FOR BIT STORED
	TRO	A,1B22		;  YES, SET IT
	TDNE	B,DTADIR+<2*DTDNFI>-1(D) ;TEST FOR BIT STORED
	TRO	A,1B21		;  YES, SET IT
	PUSHJ	P,DATOUT		;AND THE CREATION DATE
	PUSHJ	P,CRLF
LCOMN:	AOBJN	D,LCOML		;LOOP FOR ALL POSSIBLE FILES
	PUSHJ	P,CRLF
LCOMN1:	RELEAS	USR,0
;**; [155] INSERT AT LCOMN1+1/2	CLRH	1-DEC-78
IFE DIAGSW,<		;[155]
	RELEAS	DIR,	;[155] RELEASE .DIR
>; END OF IFE DIAGSW	;[155]
	JRST	FSQUIT
LCOMN2:	MOVEI	M,[ASCIZ /Directory Empty
/]				;POINT AT MSG FOR EMPTY DIRECTORY
LCOMN3:	PUSHJ	P,MSG		; & OUTPUT IT
	JRST	LCOMN1		;GO QUIT NOW

DCNUFD:	RELEAS	USR,
	RELEAS	DIR,		;RELEASE DIRECTORY CHANNEL
	PUSHJ	P,UFDERR	;MAKE A UFD IF NECESSARY
	  JRST	DCNUFE		;  CAN'T OR OTHER ERRORS, JUMP
	MOVE	B,FILDEV
	JRST	DCRTRY		;TRY AGAIN
DCNUFE:	SETOM	NOTDON		;ASSUME FAILURE IF CAN'T WRITE DIR FILE
	MOVEI	M,[ASCIZ /?Can't write User's DIR file
/]				;POINT AT MESSAGE
	MOVEI	IO,W.TTY	;FORCED TO TELL OPR, NOT DIR FILE
	JRST	LCOMN3		;GO OUTPUT THE MSG & CANCEL
;RECALL COMMAND (DTA TO DSK)

RCOM:	MOVEI	A,B.DTA
	MOVEM	A,.JBFF
	INBUF	DTA,2
	TLZ	F,L.WFIL+L.WEXT
	TLO	F,L.RCOM
	PUSHJ	P,COMSET
RCOML:	MOVEI	IO,R.CMD		;GET NEXT FILE NAME
	PUSHJ	P,NXTFIL
	 JRST	RCOME		;NONE LEFT - ALL DONE
	SETZM	WRTDPF		;CLEAR	FLAG *NOT* TO WRITE STR: & PPN FOR FILES
	SKIPN	B,FILDEV
	MOVSI	B,(SIXBIT .DSK.)
	MOVE	A,[PHOPEN,,14]				
	HRLZI	C,WH.DSK
	OPEN	DSK,A
	  JSP	N,DSKERR
	MOVEI	A,B.DSK
	MOVEM	A,.JBFF
	OUTBUF	DSK,2
RCRTRY:	SKIPN	A,FILNAM
	JRST	RCBADN
	HLLZ	B,FILEXT		;AND EXT
	SETZ	C,		;CLEAR 3RD WORD OF PARM LIST
	MOVE	D,USRPPN	;GET USER'S PPN AS 4TH WORD
	MOVEI	E,2		;GET CODE=2 FOR SUPERSEDE OF FILE
	PUSHJ	P,CKPROT	;CALL TO CHECK PROTECTION
	  JRST	RCPRTF		;  PROTECTION FAILURE, GIVE MSG
	  TRZA	B,-1		;  LOOKUP ERROR, CLEAR ERROR CODE & SKIP
	CLOSE	DSK,34		;CLOSE DISK FILE W/O UPDATING RIB
	SETZB	C,D
	LOOKUP	DTA,A
	 JRST	RCMISS		;NOT THERE ON DTA
	MOVE	D,USRPPN
;[106] RCRTRY + 15 1/2
	ANDCMI	B,77777		;[106] CLEAR BLOCK NUMBER
	ANDI	C,7777		;[106] SAVE ONLY CREATION DATE
	ENTER	DSK,A		;SET UP TO WRITE ON DSK
	 JRST	RCNUFD
RCOML2:	PUSHJ	P,R.DTA		;TRANSFER THE FILE
IFE DIAGSW, <
	JRST	RCEOF
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
	  JRST	RCEOF1		;GO INSPECT ERROR CODE, ET AL.
>;	END OF	IFN DIAGSW
	PUSHJ	P,W.DSK
	JRST	RCOML2
IFE DIAGSW, <
RCMISS:	MOVEI	M,[ASCIZ /?Requested file missing - /]
RCMIS1:	PUSHJ	P,MSGTTY		;TELL OPR USER MESSED UP
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
RCMISS:	TLO	F,L.DECER	;SET BIT FOR ERROR LOGGING
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
	MOVEI	M,[ASCIZ /?Requested file missing - /]
RCMIS1:	PUSHJ	P,MSG		;OUTPUT THE MESSAGE
>;	END OF	IFN DIAGSW
	SKIPN	WRTDPF		;TEST FOR WRITING STR NAME
	JRST	RCMIS2		;  NO, JUMP
	SKIPN	M,FILDEV	;GET STR NAME & TEST IT
	MOVSI	M,'DSK'		;  NULL, ASSUME 'DSK'
	PUSHJ	P,SIXMSO	;OUTPUT THE STR NAME
	PUSHJ	P,COLON		; & THE TRAILING COLON
RCMIS2:				;HERE NOT TO WRITE THE STR NAME
	MOVE	M,FILNAM
	PUSHJ	P,SIXMSO		;TYPE EXACT FILE NAME	
	PUSHJ	P,DOT
	HLLZ	M,FILEXT
	PUSHJ	P,SIXMSO		;TYPE EXACT EXTENSION	
	SKIPN	WRTDPF		;TEST FOR WRITING THE PPN
	JRST	RCMIS3		;  NO, JUMP
	PUSHJ	P,LEFTB		;OUTPUT A "["
	HLRZ	N,USRPPN	;GET USER'S PROJECT #
	PUSHJ	P,OCTPRT	; & OUTPUT IT
	PUSHJ	P,COMMA		;OUTPUT A COMMA
	HRRZ	N,USRPPN	;GET USER'S PROGRAMMER #
	PUSHJ	P,OCTPRT	; & OUTPUT IT
	PUSHJ	P,RIGHTB	;OUTPUT A "]"
RCMIS3:				;HERE NOT TO RIGHT A PPN
	PUSHJ	P,CRLF

RCEOF:	CLOSE	DTA,0		;FINISH UP AND GO FOR NEXT FILE
	CLOSE	DSK,100		;CLOSE & DELETE ACCESS TABLES 
	JRST	RCOML

RCNUFD:	PUSHJ	P,UFDERR	;MAKE A UFD IF NECESSARY
	  JRST	RCENTF		;OTHER ERRORS
	JRST	RCRTRY		;TRY AGAIN
IFE DIAGSW, <
RCENTF:	MOVEI	M,[ASCIZ /?ENTER Failure: /]
	PUSHJ	P,MSGTTY
	MOVE	N,B
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
RCENTF:	TLO	F,L.DECER	;SET BIT FOR ERROR LOGGING
	PUSH	P,B		;SAVE ERROR CODE
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
	MOVEI	M,[ASCIZ /?ENTER Failure: /]
	PUSHJ	P,MSG		;OUTPUT THE TEXT
	POP	P,N		;RESTORE THE ERROR OCDE
>;	END OF	IFN DIAGSW
	HRRZS	N		;CLEAR L.H. OF ERROR CODE
	SETOM	WRTDPF		;RQST WRITING OF STR & PPN
	PUSHJ	P,OCTPRT
	MOVEI	M,[ASCIZ / Can't write user file - /]
	JRST	RCMIS1
IFE DIAGSW, <
RCBADN:	MOVEI	M,[ASCIZ /?Bad file name, R command - /]
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
RCBADN:	TLO	F,L.DECER	;SET BIT FOR ERROR LOGGING
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
	MOVEI	M,[ASCIZ /?Bad file name, R command - /]
>;	END OF	IFN DIAGSW
	JRST	RCMIS1
UFDERR:	HRRZS	B		;IS THERE A UFD?
	CAIE	B,1
	POPJ	P,		;YES-SOME OTHER ERROR
	MOVE	A,USRPPN	;NO--TRY TO MAKE ONE
	MOVE	B,FILDEV
	PJRST	MAKUFD

IFN DIAGSW, <
RCEOF1:	GETSTS	DTA,N		;GET DTA ERROR STATUS
	TRNN	N,740000	;TEST FOR I/O ERROR
	JRST	RCEOF		;  NONE, MUST BE REAL EOF
	CLOSE	DSK,40		;THROW AWAY PARTIAL DISK FILE
	PUSH	P,N		;SAVE ERROR STATUS
	TLO	F,L.DECER	;SET BIT FOR ERROR LOGGING
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
	MOVEI	M,[ASCIZ /?DTA Read Error (Status = /];POINT AT MSG
RCOMER:	PUSHJ	P,MSG		; & OUTPUT IT
	POP	P,N		;RESTORE ERROR STATUS
	TRZ	N,17		;CLEAR MODE BITS
	PUSHJ	P,OCTPRT	; & OUTPUT IT
	MOVEI	M,[ASCIZ /) on file /] ;POINT AT REST OF MSG
	JRST	RCMIS1		; & GO TO COMMON ROUTINE

RCIOER:	GETSTS	DSK,N		;GET DISK ERROR STATUS
	CLOSE	DSK,40		;CLOSE & DELETE THE DISK FILE
	PUSH	P,N		;SAVE THE ERROR STATUS
	TLO	F,L.DECER	;SET BIT FOR ERROR REPORTING
	PUSHJ	P,LCOM1		;OPEN THE DIR FILE
	SETOM	WRTDPF		;SET FLAG TO WRITE FULL FILE SPEC
	MOVEI	M,[ASCIZ /?Disk Write Error (Status = /] ;POINT AT MSG
	JRST	RCOMER		; & GO OUTPUT IT
>;	END OF	IFN DIAGSW

IFE DIAGSW, <
RCPRTF:	MOVEI	M,[ASCIZ /?Protection failure - /] ;POINT AT MSG
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
RCPRTF:	TLO	F,L.DECER	;SET BIT TO RQST DIR TO BE WRITTEN
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
	MOVEI	M,[ASCIZ /?Protection failure - /] ;POINT AT MSG
>;	END OF	IFN DIAGSW
	SETOM	WRTDPF		;SET FLAG TO WRITE STR & PPN
	JRST	RCMIS1		;GO OUTPUT THE MSG
;DELETE FILES FROM DECTAPE

DCOM:	TLZ	F,L.WFIL+L.WEXT	;RESET WILD FILE AND EXT FLAGS
	TLO	F,L.RCOM		;SET RCOM TO SEARCH DTA FOR "*"
	PUSHJ	P,COMSET
DCOML:	MOVEI	IO,R.CMD		;SET INPUT FROM COMMAND
	PUSHJ	P,NXTFIL		;GET NEXT FILE NAME AND EXT
	 JRST	DCOME		;ALL DONE - BRANCH
	MOVE	A,FILNAM		;GET FILE NAME
	HLLZ	B,FILEXT		;AND EXTENSION
	SETZB	C,D
	LOOKUP	DTA,A		;GET FILE TO BE DELETED
	  JRST	DCMISS		;NOT THERE - GIVE WARNING
	SETZB	A,B		;SET FOR DELETE
	RENAME	DTA,A		;DELETE FILE
	  JFCL			;IGNORE ERROR
DCEOF:	CLOSE	DTA,0
	JRST	DCOML		;AND DO NEXT

IFE DIAGSW, <
DCMISS:	MOVEI	IO,W.TTY	;POINT AT TTY I/O ROUTINE
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
DCMISS:	TLO	F,L.DECER	;SET BIT TO GET DIR FILE
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
>;	END OF	IFN DIAGSW
	MOVEI	M,[ASCIZ /%Could not find /] ;POINT AT MSG
	PUSHJ	P,MSG		;OUTPUT IT
	MOVE	M,FILNAM	;GET THE DESIRED FILENAME
	PUSHJ	P,SIXMSO	; & OUTPUT IT
	PUSHJ	P,DOT		;OUTPUT A DOT
	HLLZ	M,FILEXT	;GET THE DESIRED EXTENSION
	PUSHJ	P,SIXMSO	; & OUTPUT IT
	PUSHJ	P,CRLF		;END THE LINE
	JRST	DCEOF		;CONTINUE ONWARD...
;ZERO AND FILE COMMAND

ZCOM:	UTPCLR	DTA,		;CLEAR DIRECTORY
				;AND FALL INTO F COMMAND
;FILE COMMAND (DSK TO DTA)

FCOM:	MOVEI	A,B.DTA
	MOVEM	A,.JBFF
	OUTBUF	DTA,2
	TLZ	F,L.WFIL+L.WEXT+L.RCOM
	PUSHJ	P,COMSET
FCOML:	MOVEI	IO,R.CMD
	PUSHJ	P,NXTFIL
	 JRST	FCOME
	SKIPN	B,FILDEV
	 MOVSI	B,(SIXBIT .DSK.)
	MOVE	A,[PHOPEN,,14]				
	MOVEI	C,RH.DSK
	OPEN	DSK,A
	  JSP	N,DSKERR
	MOVEI	A,B.DSK
	MOVEM	A,.JBFF
	INBUF	DSK,2
	SKIPN	A,FILNAM
	 JRST	FCBADN
	HLLZ	B,FILEXT
	MOVEI	C,0
	SKIPN	D,FILPPN	;GET FILE'S PPN (IF ANY)
	 MOVE	D,USRPPN
	MOVEM	D,FILPPN	;STORE AS FILE PPN
	MOVEI	E,5		;GET CODE 5 FOR READ ACCESS
	PUSHJ	P,CKPROT	;CALL TO CHECK PROTECTION
	  JRST	FCPRTF		;  PROT. FAILURE, GIVE MSG
	  JRST	FCMISS		;  LOOKUP ERROR, GIVE MSG
	ENTER	DTA,A
	 JRST	FCENTF
FCOML2:	PUSHJ	P,R.DSK
IFE DIAGSW, <
	  JRST	FCEOF
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
	  JRST	FCEOF1		;GO LOOK FOR EOF/ERROR
>;	END OF	IFN DIAGSW
	PUSHJ	P,W.DTA
	JRST	FCOML2
FCMISS:	MOVEI	M,[ASCIZ /?Requested file missing - /]
IFE DIAGSW, <
FCMIS1:	PUSHJ	P,MSGTTY
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
FCMIS1:	PUSH	P,M		;SAVE MSG POINTER
	TLO	F,L.DECER	;SET BIT FOR ERROR LOGGING
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
	POP	P,M		;RESTORE MSG POINTER
	PUSHJ	P,MSG		;OUTPUT THE MESSAGE
>;	END OF	IFN DIAGSW
	SKIPN	M,FILDEV	;GET DESIRED STR NAME
	 MOVSI	M,'DSK'		;  NONE, ASSUME 'DSK'
	PUSHJ	P,SIXMSO	;OUTPUT THE STR NAME
	PUSHJ	P,COLON		;OUTPUT A COLON
	MOVE	M,FILNAM
	PUSHJ	P,SIXMSO		;TYPE THE EXACT FILE NAME	
	PUSHJ	P,DOT
	HLLZ	M,FILEXT
	PUSHJ	P,SIXMSO		;TYPE THE EXACT EXTENSION	
	SKIPN	FILPPN		;TEST FOR ZERO PPN
	 JRST	FCMIS2		;  YES, JUMP (DON'T PRINT IT)
	PUSHJ	P,LEFTB		;OUTPUT A "["
	HLRZ	N,FILPPN	;GET THE FILE'S PROJECT #
	PUSHJ	P,OCTPRT	; & OUTPUT IT
	PUSHJ	P,COMMA		;OUTPUT A COMMA
	HRRZ	N,FILPPN	;GET THE FILE'S PROGRAMMER #
	PUSHJ	P,OCTPRT	; & OUTPUT IT
	PUSHJ	P,RIGHTB	;OUTPUT A "]"
FCMIS2:				;HERE NOT TO PRINT THE PPN
	PUSHJ	P,CRLF
	JRST	FCEOF

FCENTF:	MOVEI	M,[ASCIZ /?DTA directory full, file /]
	JRST	FCMIS1

FCBADN:	MOVEI	M,[ASCIZ /?Bad file name, F command - /]
	JRST	FCMIS1

FCEOF:	CLOSE	DTA,0
;**; [123]	INSERT @ FCEOF+1	AUG 2, 1976
IFN DIAGSW, <			;[123]
	STATZ	DTA,760000	;[123] ERROR ON CLOSE?
	  JRST	FCIOER		;[123]
>;	END OF	IFN DIAGSW	 [123]
	CLOSE	DSK,100		;CLOSE FILE & DELETE A.T. 
	JRST	FCOML
IFN DIAGSW, <
FCIOER:	TLO	F,L.DECER	;SET BIT FOR ERROR LOGGING
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
	GETSTS	DTA,N		;GET DTA ERROR STATUS
	PUSHJ	P,FCLDTA	;CLOSE THE BAD DTA FILE
	TRZ	N,17		;CLEAR MODE BITS
	CAIN	N,1B21		;TEST FOR 'DTA FULL' ERROR
	 JRST	FCENTF		;  YES, TREAT AS 'ENTER FAILURE'
	MOVEI	M,[ASCIZ /?DTA Write Error (Status = /];POINT AT MSG
FCOMER:	PUSHJ	P,MSG		; & OUTPUT IT
	PUSHJ	P,OCTPRT	;OUTPUT THE ERROR STATUS
	MOVEI	M,[ASCIZ /) on file /] ;POINT AT REST OF MSG
	JRST	FCMIS1		;GO PROCESS IT

FCEOF1:	STATO	DSK,740000	;TEST FOR DISK I/O ERROR
	 JRST	FCEOF		;  NO, JUMP
	TLO	F,L.DECER	;SET BIT TO OPEN DIR FILE
	PUSHJ	P,LCOM1		;CALL TO OPEN DIR FILE
	PUSHJ	P,FCLDTA	;CLOSE THE BAD DTA FILE
	GETSTS	DSK,N		;GET THE DISK STATUS IN ERROR
	TRZ	N,17		;CLEAR THE MODE BITS
	MOVEI	M,[ASCIZ /?Disk Read Error (Status = /];POINT AT MSG
	JRST	FCOMER		; & GO OUTPUT

FCLDTA:	CLOSE	DTA,0		;CLOSE THE DTA FILE
	MOVE	A,FILNAM	;GET THE DTA'S FILENAME
	HLLZ	B,FILEXT	; & EXTENSION
	SETZB	C,D		;CLEAR OTHER ARGUMENTS
	LOOKUP	DTA,A		;LOOKUP THE FILE
	  POPJ	P,		;  FAILED, RETURN
	SETZB	A,B		;CLEAR ALL ARGUMENTS
	SETZB	C,D		;  DITTO
	RENAME	DTA,A		;DELETE THE PARTIAL DTA FILE
	  JFCL			; (IGNORE ERRORS)
	POPJ	P,		;DONE, RETURN TO CALLER
>;	END OF	IFN DIAGSW

FCPRTF:	MOVEI	M,[ASCIZ /?Protection failure - /];POINT AT MSG
	JRST	FCMIS1		;GO TYPE THE MSG
DCOME:			;ENTER FROM DELETE COMMAND
	TLZ	F,L.RCOM	;CLEAR SO UPDATES DIRECTORY PROPERLY
RCOME:			;ENTER FROM RECALL COMMAND
FCOME:	RELEAS	DTA,0
	MOVE	A,[PHOPEN,,117]			
	MOVE	B,DTDRIV
	MOVEI	C,0
	OPEN	DTA,A		;OPEN TAPE AGAIN
	 JSP	N,DTERR
	CLOSE	DSK,0
	TLNE	F,L.RCOM
	 JRST	FCOME1		;IF READING, CORE DIRECTORY IS STILL VALID
	USETI	DTA,144
	INPUT	DTA,DIRIOW	;ELSE READ DIRECTORY AGAIN
	STATZ	DTA,740000
	JRST	DTDER1		;JUMP IF DIRECTORY READ ERROR
FCOME1:	JRST	LCOM1		;DO DIRECTORY COM FOR FREE

COMSET:	MOVEI	IO,R.CMD
	PUSHJ	P,NXTFIL
	  JRST	.+2
	SKIPN	B,FILDEV
	MOVSI	B,(SIXBIT .DSK.)
	MOVEM	B,DIRDEV
	POPJ	P,
;  SUBROUTINE TO LOOKUP FILES BEING TRANSFERRED & CHECK FOR
;  PROTECTION FAILURE ON THE DISK FILE (READ FAILURE ON FILE F & 
;  FILE Z; SUPERSEDE FAILURE ON FILE R).
;
;	CALL:	<PUT FILE LOOKUP PARMS IN AC'S A-B-C-D>
;		<PUT CHKACC UUO ACCESS CODE IN AC E>
;		PUSHJ	P,CKPROT
;		  <PROTECTION FAILURE - FILE IS NOT OPEN>
;		  <LOOKUP ERROR - ERROR CODE IN R.H. AC B>
;		<SUCCESS RETURN - LOOKUP INFO RET'D IN AC'S A-B-C>
;
;	USES AC'S M-N-N1 AS SCRATCH
;	IF CHKACC UUO NOT AVAILABLE, PERMITS ACCESS IF FILE PPN
;	  IDENTICAL TO USER'S PPN.

CKPROT:	MOVEI	M,16		;GET LTH OF PARM BLOCK
	MOVEM	M,XLUBLK	;STORE AS 1ST WORD OF PARM BLOCK
	MOVEM	D,XLUBLK+1	;STORE PPN AS 2ND WORD
	MOVEM	A,XLUBLK+2	;STORE FILENAME AS 3RD WORD
	HLLZM	B,XLUBLK+3	;STORE EXTENSION AS 4TH WORD
	LOOKUP	DSK,XLUBLK	;DO EXTENDED LOOKUP OF THE FILE
	  JRST	CKPRT3		;  ERROR, GO CHECK IT OUT
	MOVE	B,XLUBLK+3	;RSTR ACCESS DATE, ET AL FOR 3RD WORD
	MOVE	C,XLUBLK+4	;RSTR CREATION DATE, ET AL FOR 4TH WORD
	CAME	D,XLUBLK+1	;TEST FOR FILE IN DESIRED AREA
	JRST	CKPRT6		;  NO, TREAT AS LOOKUP FAILURE
	LDB	M,[POINT 9,C,8]	;GET PROTECTION CODE IN R.H. OF AC
	HRLI	M,(E)		;GET DESIRED ACCESS CODE IN L.H.
	MOVE	N,D		;GET DIRECTORY (FILE) PPN IN 2ND AC
	MOVE	N1,USRPPN	;GET USER'S PPN IN 3RD AC
	MOVEI	E,M		;POINT AT PARM LIST
	CHKACC	E,		;CHECK FOR ACCESS PERMITTED
	  JRST	CKPRT2		;  NO SUCH UUO, MAKE A SIMPLE TEST
	AOJE	E,CKPRT5	;JUMP IF -1 RET'D (PROTECTION FAILURE)
CKPRT0:	AOS	(P)		;INCR RETURN ADDRESS
	JRST	CPOPJ1		;RETURN+2 FOR SUCCESSFUL LOOKUP
CKPRT1:	LOOKUP	DSK,A		;DO 4-WORD LOOKUP FOR LEVEL C
	  JRST	CKPRT4		;  ERROR, GO CHECK IT OUT
CKPRT2:	MOVE	N,XLUBLK+1	;GET DESIRED FILE PPN
	CAME	N,USRPPN	;TEST FOR SAME AS USER'S PPN
	JRST	CKPRT5		;  NO, TREAT AS PROTECTION FAILURE
	JRST	CKPRT0		;  YES, GO TAKE SUCCESS RETURN
CKPRT3:	HRR	B,XLUBLK+3	;GET ERROR CODE FROM EXTENDED LOOKUP
CKPRT4:	HRRZ	N,B		;GET ERROR CODE FROM THE LOOKUP
	CAIE	N,2		;TEST FOR PROTECTION FAILURE
	JRST	CPOPJ1		;  NO, JUST A LOOKUP FAILURE
CKPRT5:	CLOSE	DSK,114		;CLOSE FILE & DON'T UPDATE OR RETAIN INFO
	POPJ	P,		;TAKE PROTECTION FAILURE RETURN
CKPRT6:	CLOSE	DSK,114		;CLOSE FILE & DON'T UPDATE OR RETAIN INFO
	HLLZS	B		;ASSUME 'FILE NOT FOUND' IF IN WRONG AREA
	JRST	CPOPJ1		;TREAT AS LOOKUP FAILURE

>;	END IFN FILESW
SUBTTL	MISC. OPERATOR COMMAND PROCESSING
;HERE FOR OPERATOR COMMANDS

OPCOMS:	MOVEI	IO,R.TTY
	PUSHJ	P,SSST
OPCOM:	CAIN	CH,"/"		;ALLOW OPERATOR TO USE SLASH
	 SETZ	CH,
	TRZ	F,OB.WFI	;CLEAR 'WAIT-FOR-INPUT' FLAG
	SKIPE	WAITFG		;TEST FOR WAITING
	TRO	F,OB.WFI	;  YES, REQUEST FURTHER OPERATOR INPUT
	TRO	F,OB.OPC	;SET 'OPR-COMMAND' BIT
	SETZM	CMDNAM
	MOVE	A,OURJOB	;SET OUR JOB# & PPN
	MOVEM	A,FSJOB
	MOVE	A,OURPPN
	MOVEM	A,FSPPN

	MOVEI	B,OPCTAB	;LOOKUP NAME
	PUSHJ	P,TABLU0
	  SKIPA
	JRST	@OPCDIS(B)	;DISPATCH
	CAIN	CH,12		;IS IT LONE C.R.?
	JUMPE	A,OPCOM1	;YES--THATS ALRIGHT
	CAIN	CH,32		;CNTRL-Z?
	 JRST	EXICOM		; YES-EXIT
OPCOM0:	MOVEI	M,[ASCIZ/?Bad command name--Type H for help
/] 				;REMIND CLUMSY OPERATOR	
	PUSHJ	P,MSGTTY
	TTCALL	11,		;CLEAR TTY INPUT BUFFER
;**; [161] DELETE ONE LINE AT OPCOM1	CLRH	8-DEC-78
OPCOM1:				;[161]
;[161]OPCOM1:	TRO	F,OB.WFI	;WAIT FOR NEW INPUT
	JRST	BEG1


;WAIT & PAUSE COMMANDS

WAICOM:	SETOM	WAITFG		;SET WAIT FLAG ON
;**; [161] CHANGE AT WAICOM+1	CLRH	8-DEC-78
	TRO	F,OB.WFI	;[161] SET WAIT-FOR-INPUT FLAG
	JRST	BEG1		;[161] CONTINUE ON
;[161]	JRST	OPCOM1		;GO WAIT FOR NEW INPUT

;GO COMMAND

GOCOM:	TRZ	F,OB.WFI	;CLEAR WAIT-FOR-INPUT FLAG
	SETZM	WAITFG		;CLEAR WAIT FLAG
	JRST	BEG1		;CONTINUE ON

;EXIT COMMAND

EXICOM:	EXIT	1,		;RETURN TO MONITOR
	JRST	BEG1		;CONTINUE IF OPR SAYS SO

;DISMOUNT AND REMOVE COMMANDS

DICOMT:	TRZA	F,SB.R		;DISMOUNT - JUST REMOVE FROM SYSTEM
RECOM:	TRO	F,SB.R		;REMOVE - UNLOAD DRIVE TOO
IFN OFFLIN,<
	MOVEI	D,RESWIT	;ALLOW /NOCHECK
>;	END IFN OFFLIN
IFE OFFLIN,<
	MOVEI	D,NOSWIT	;NO SWITCHES
>;	END IFN OFFLIN
	PUSHJ	P,COMNAM	;GET F/S NAME
	JUMPE	A,ERR301	;NO NAME
	MOVEM	A,FSNAME
IFN OFFLIN,<
	PUSHJ	P,SWITCH	;LOOK FOR /NOCHECK
	 JRST	FSQUIT		;INVALID SWITCH..QUIT
>;	END IFN OFFLIN
	JRST	REMOV

IFN FTTLAB,<
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167]
;[143] NEXT xx COMMAND

NXTCOM:				;[143]
	SKIPN	NXTFLG		;[143] STARTED WITH START:NEXT
	JRST	ERR602		;[143] TYPE AN ERROR MESSGE
	CAIN	CH,12		;[143] LINE FEED DELIMETER
	TDZA	N,N		;[143] YES, DON'T READ AN ARGUMENT
	PUSHJ	P,SDECIN	;[143] GET THE REQUEST NUMBER
	SKIPN	N		;[143] CHECK FOR A ZERO
	MOVEI	N,1		;[143] DEFAULT TO FIRST ENTRY
	MOVEM	N,NXTREQ	;[143] STORE THE REQUEST NUMBER
	JRST	BEG1		;[143] EXIT THE COMMAND
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
;LOCK COMMAND

LOCOM:	MOVEI	D,NOSWIT	;NO SWITCHES
	PUSHJ	P,COMNAM	;GET F/S NAME
	JUMPE	A,ERR301	;NO NAME
	MOVEM	A,FSNAME	;GOOD F/S NAME?
	PUSHJ	P,CKFS
	  JRST	ERR300		;NO
	PUSHJ	P,CKMNC		;YES-CHECK THE MOUNT-COUNT
	MOVEI	A,.FSLOK	;DO STRUUO
	MOVE	B,FSNAME
	MOVEI	C,A
	STRUUO	C,
	  JRST	ERR422		;UUO LOOSES
	PUSHJ	P,MSG423	;UUO WINS--TYPE CONFIRMATION
	JRST	FSQUIT

;**; [165] REMOVE ULKCOM THROUGH END OF UNLOCK CODE	CLRH	28-MAR-79
;**; [165] THE CODE TO SUPPORT THIS IS NOT IN STANDARD MONITORS.
REPEAT 0,<			;[165]
;UNLOCK COMMAND

IFN FTTLAB,<
ULKCOM:	MOVEI	D,NOSWIT	;[142] NO SWITCHES
	PUSHJ	P,COMNAM	;[142] GET F/S NAME
	JUMPE	A,ERR301	;[142] NO NAME
	MOVEM	A,FSNAME	;[142] GOOD F/S NAME?
	PUSHJ	P,CKFS		;[142]
	  JRST	ERR300		;[142] NO
	PUSHJ	P,CKMNC		;[142] YES-CHECK THE MOUNT-COUNT
	MOVEI	A,.FSCLK	;[142] DO STRUUO
	MOVE	B,FSNAME	;[142]
	MOVEI	C,A		;[142]
	STRUUO	C,		;[142]
	  JRST	[JUMPE	C,ERR424	;[142] NOT LOCKED BY THE OPERATOR
		JRST	ERR423]		;[142] SOME OTHER ERROR
	PUSHJ	P,MSG424	;[142] UUO WINS--TYPE CONFIRMATION
	JRST	FSQUIT		;[142]
>;[142] END FTTLAB
>				;[165] END OF UNLOCK CODE REPEAT 0

;HELP

HECOM:	MOVEI	M,OPCHEL
	PUSHJ	P,MSGTTY
;**; [124] INSERT @ HECOM+2	DML	3-AUG-76
	MOVEI	M,OPCHE1	;[124] PRINT OUT OTHER PARTS
	PUSHJ	P,MSGTTY	;[124]
	MOVEI	M,OPCHE2	;[124]    OF HELP MESSAGES
	PUSHJ	P,MSGTTY	;[124]
	JRST	OPCOM1		;GIVE HIM ANOTHER CHANCE

WHTCOM:	PUSHJ	P,MSG800	;TYPE NO COMMANDS WAITING
	SKIPE	MODE		;TEST FOR NO CMDS ALLOWED
	SKIPE	WAITFG		;TEST FOR WAITING
	PUSHJ	P,MSG801	;  EITHER, TELL THE OPERATOR
	JRST	OPCOM1

NODCOM:	SETOM	NODEFR		;OPR WANTS TO PROCESS DEFER COMMANDS
	JRST	BEG1		; EVEN IF TIME NOT EXPIRED

DEFCOM:	SETZM	NODEFR		;TREAT DEFER'D COMMANDS AS USUAL
	JRST	BEG1
;START:X COMMAND
;STOP:X COMMAND

STCOM:
STACOM:	SKIPE	NOSTAR		;START ALLOWED?
	 JRST	STCOM1		;NO
	TLZA	F,L.STOP
STOCOM:	TLO	F,L.STOP
	PUSHJ	P,SETMOD
	  JRST	OPCOM0
	TLNN	F,L.STOP	;TEST FOR /START
	JRST	GOCOM		;  YES, /START IMPLIES /GO
	JRST	BEG1
STCOM1:	PUSHJ	P,MSG802	;NO STRUCTURE FOR COMMAND FILES
	JRST	BEG1

;KILL COMMAND

KILCOM:	PUSHJ	P,GETMOD	;WHAT TO KILL?
	  JRST	OPCOM0
	CAIL	B,3
	JRST	BEG1		;NONE
	MOVE	E,B
	PUSHJ	P,OPNCMU	;SOME-OPEN CMD. UFD
	  JRST	BEG1
	TLZ	F,L.ODEF	;SHOW NOTHING DEFERRED IF /KILL
	MOVSI	C,-TYPL		;GET AOBJN PTR
KILCO1:	SETZM	CMFSVD(C)	;CLEAR SAVED CMD-FILE NAME
	AOBJN	C,KILCO1	;INCR COUNTER & REPEAT
	MOVEI	C,0
	CAIN	E,2
	JRST	KILCO4		;ALL
	MOVEI	C,'F  '
	JUMPE	E,KILCO4		;FILE
	MOVEI	C,'D  '		;MOUNT (AND DISMOUNT)
	PUSHJ	P,KILCMD
	MOVEI	C,'M  '
KILCO4:	PUSHJ	P,KILCMD
	JRST	BEG1

KILCMD:	HRLM	C,(P)
KILCM2:	HLRZ	C,(P)
	PUSHJ	P,OPNCMD
	  POPJ	P,
	PUSHJ	P,DELCMD	;ZAP IT
	JRST	KILCM2
;SUBROUTINE TO PROCESS VALUES TO STOP/START COMMAND AND SWITCH
;L.STOP=1 FOR 'STOP'    =0 FOR 'START'
;NO ARGUMENT DEFAULT = 'ALL'
;RET+1	ERROR
;RET+2	OK

SETMOD:	PUSHJ	P,GETMOD
	  POPJ	P,
SETMO1:	MOVE	A,MODVAL(B)
	ANDCAM	A,MODE		;REMOVE OR ADD BIT DEPENDING
	TLNN	F,L.STOP	;   ON 'STOP' OR 'START'
	IORM	A,MODE
	MOVE	A,MODE		;SET PROG.NAME IN ACCORDENCE
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<		;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	SETZM	NXTFLG		;[143] CLEAR NEXT PROCESSING FLAG
	CAIN	B,MODNXT-MODTAB	;[143] NEXT MODE PROCESSING
	SETOM	NXTFLG		;[143] YES, SET FLAG
	SETZM	NXTREQ		;[143] CLEAR THE NEXT REQUEST
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
	MOVSI	B,-MODNUM
SETMO3:	CAME	A,MODVAL(B)
	AOBJN	B,SETMO3
	MOVE	A,MODNAM(B)
	SETNAM	A,
	TLNE	F,L.STOP	;TEST FOR /START
	JRST	CPOPJ1		;  NO, RETURN TO CALLER
	SETOM	FNDFLG		;  YES, FORCE ANOTHER UFD-PASS
	SETZM	PRVFND		;	(  DITTO  )
	JRST	CPOPJ1
;SUBROUT TO GET VALUES TO START/STOP/KILL COMMANDS
;NO ARGUMENT DEFAULT = 'ALL'
;RET+1	ERROR
;RET+2	B=INDEX TO MODE TABLES (0...3)

GETMOD:	SETZ	A,
	CAIE	CH,":"
	JRST	GETMO2
	MOVEI	B,MODTAB	;READ & LOOKUP ARG
	PUSHJ	P,TABLUK
	  SKIPA
	JRST	CPOPJ1
	JUMPN	A,CPOPJ
GETMO2:	MOVEI	B,MODALL-MODTAB	;NO ARG='ALL'
	JRST	CPOPJ1

	U(MODE)
;USERS COMMAND

USCOM:	TLZ	F,L.UPRI	;CLEAR USERS PRIVATE IF ON
	MOVEI	D,USWIT		;USERS' SWITCH TABLE
	PUSHJ	P,COMNAM	;GET F/S NAME
	JUMPE	A,USCALL	;NO NAME MEANS ALL
	MOVEM	A,FSNAME
	PUSHJ	P,CKFS		;VALID F/S NAME?
	  JRST	ERR300		;NO
	PUSHJ	P,SWITCH	;LOOK FOR ALL AND PRIVATE
	 JRST	FSQUIT		; NO GOOD
	PUSHJ	P,FSTAT		;PRINT ITS STATUS
	JRST	FSQUIT

USCPRI:	TLO	F,L.UPRI		;IN USERS PRIVATE MODE

USCALL:	MOVEI	M,0	;USE SYSSTR TO GET ALL F.S.S
USCAL2:	SYSSTR	M,
	  JSP	A,NEVERR
	JUMPE	M,USCAL3	;GO PRINT FREE UNITS IF OUT OF STR'S
	MOVEM	M,FSNAME
	TLNN	F,L.UPRI		;IN USERS PRIVATE MODE?
	 JRST	USCAL5			;NO, GO ON WITH "ALL" MODE
IFE DBUGSW,<
	PUSHJ	P,GETUNI		;GET UNIT DRIVES AND ID'S
	 JFCL
	MOVE	M,FSUAOB		;LOOK AT ALL DRIVES ASSOC. W/ STR
USCAL7:	MOVE	A,PDRIVE(M)		;GET THE DRIVE
	PUSHJ	P,SWPCHK		;CHECK IF DR. IN ACTIVE SWP LST
	 SKIPA				;NO, GOODIE, GO ON
	JRST	USCAL6			;YES, DON'T PRINT THIS ONE
	AOBJN	M,USCAL7		;THIS ONE'S OK;TRY MORE
>;	END OF IFE DBUGSW
	SETZM	GOBSTA
	MOVE	A,SYSPPN
	MOVEM	A,GOBSTA+1		;SET UP TO SEE IF THIS STR. IN
	MOVE	A,FSNAME		; THE SYSTEM SEARCH LIST
	MOVEM	A,GOBSTA+2
	MOVEI	A,GOBSTA
	GOBSTR	A,			;TESTING FOR JOB 0(SYS. SEARCH LIST)
	 JRST	USCAL5			;A PRIVATE STR.!! GO DO IT!
	JRST	USCAL6			;NOT THIS TIME, TRY AGAIN
USCAL5:	MOVE	M,FSNAME		;RE-SET UP M WITH STR.
	MOVEI	IO,W.TTY
	PUSHJ	P,SIXMSO	;PRINT F.S. NAME
	PUSHJ	P,COLON
	PUSHJ	P,CRLF
	PUSHJ	P,FSTAT		;PRINT ITS STATUS
	PUSHJ	P,CRLF
USCAL6:	MOVE	M,FSNAME	;GET NEXT F.S.
	JRST	USCAL2

USCAL3:	PUSHJ	P,MSG252	;TYPE 'FREE DRIVES: ' MSG
	SETZB	D,DSKCHA	;CLEAR D (AS A FLAG) & RQST 1ST UNIT
	PUSHJ	P,NXDRIV	;CALL TO GET 1ST FREE DRIVE
	  MOVE	A,['NONE  ']	;  NONE, SO INDICATE
USCAL4:	MOVE	M,A		;COPY DRIVE # INTO AC FOR TYPING
	PUSHJ	P,SIXMSO	;TYPE THE DRIVE NAME
	PUSHJ	P,SPACE		;TYPE A SPACE
	PUSHJ	P,NXDRIV	;CALL FOR NEXT FREE DRIVE
	  SKIPA			;  NONE, SKIP
	JRST	USCAL4		;  ELSE LOOP BACK
	PUSHJ	P,CRLF		;END THE LINE
	PUSHJ	P,CRLF		;LEAVE A BLANK LINE
	JRST	FSQUIT		;DONE NOW

;SUBROUTINE TO PRINT F/S STATUS AND USERS
;CALL	FSNAME=F/S NAME

FSTAT:	PUSHJ	P,GETUNI	;GET UNIT DRIVES & ID'S
	  JRST	FSTA0
	PUSHJ	P,PRTUNI	;PRINT DRIVE-ID LIST
FSTA0:	MOVE	A,FSNAME	;GET ITS CHARACTERSSTICS
	PUSHJ	P,DSKUUO
	  PUSHJ	P,NEVMSJ	;SHOULD'A BEEN A GOOD NAME
	PUSH	P,A		;SAVE THE UUO AC

	MOVE	N,DSKCHA+.STMNT	;PRINT THE MOUNT COUNT
	PUSHJ	P,MSG312
	SKIPN	DSKCHA+.STMNT	;IF 0, DONT PRINT USER LIST
	JRST	FSTAT3
	MOVEI	M,[ASCIZ/Job(s) /]
	PUSHJ	P,MSGTTY
;PRINT LIST OF JOB #S WITH THIS F/S IN THEIR SEARCH LISTS

	MOVEI	C,^D10		;NUM. JOB NUMS/LINE
	MOVE	M,FSUAOB
FSTATA:	MOVE	A,PDRIVE(M)
	PUSHJ	P,SWPCHK
	 SKIPA	
	JRST	FSTATB
	AOBJN	M,FSTATA
	JRST	FSTATC
FSTATB:	MOVEI	M,[ASCIZ /SWP /]
	PUSHJ	P,MSGTTY
	SOS	C
FSTATC:
	SETZB	A,GOBSTA+0	;START WITH JOB 0 (SYS)

FSTAT0:	JUMPN	A,FSTAT9	;SYS (JOB 0)?
	MOVE	A,SYSPPN	;YES
	JRST	FSTAT8
FSTAT9:	MOVSS	A
	HRRI	A,PRJPRG	;GET THIS JOB'S PPN
	GETTAB	A,
	  JRST	FSTAT1		;  ERROR, THEN OUT OF JOBS
	JUMPE	A,FSTAT2	;0,0 NOT A JOB
FSTAT8:	MOVEM	A,GOBSTA+1	;AND STORE FOR GOBSTR
	MOVE	A,FSNAME	;GET F.S. NAME
	MOVEM	A,GOBSTA+2

	MOVEI	A,GOBSTA	;DO THE GOBSTR UUO
	GOBSTR	A,
	  JRST	FSTAT2		;DONT QUIT--JOB MAY HAVE JUST DISAPEARED

	SOJGE	C,FSTAT6	; COUNT JOBS/LINE
	MOVEI	M,[ASCIZ/
       /]
	PUSHJ	P,MSGTTY
	MOVEI	C,^D9
FSTAT6:	SKIPE	N,GOBSTA+0	;YES-PRINT THIS JOB #
	JRST	FSTAT7
	MOVSI	M,'SYS'		;SET 'SYS' FOR JOB ZERO
	PUSHJ	P,SIXMSO
	JRST	FSTAT2
FSTAT7:				;HERE TO PRINT USER'S JOB #
	CAIL	N,^D100		;TEST FOR 3-DIGIT JOB #
	PUSHJ	P,SPACE		;  YES, NEED LEADING SPACE
	PUSHJ	P,DECPR3
FSTAT2:	AOS	A,GOBSTA+0	;INCR TO NEXT JOB #
	JRST	FSTAT0		; & CONTINUE

FSTAT1:	MOVEI	M,[ASCIZ /None/];GET MSG IF NO USERS
	CAIL	C,^D10		;TEST FOR ANYTHING PRINTED
	PUSHJ	P,MSGTTY	;  NO, THEN TYPE IT!
	PUSHJ	P,CRLF		;END THE LINE

FSTAT3:	POP	P,A		;RESTORE DSKCHR UUO AC
	TLNE	A,.UPNNA	;IF F/S LOCKED
	PUSHJ	P,MSG255	;   PRINT MESSAGE
	TLNE	A,.UPZMT	;DONT BELIEVE AWL & SAF IF M.C.=0
	JRST	FSTAT5
	TLNE	A,.UPAWL	;IF F/S IS READ-ONLY
	PUSHJ	P,MSG254	;   PRINT MESSAGE
	TLNE	A,.UPSAF	;IF F/S SINGLE-ACCESS
	PUSHJ	P,MSG256	;   PRINT MESSAGE

FSTAT5:	POPJ	P,
;SUBROUTINE TO GET OPERATOR ANSWER TO 'PROCEED?'

OPER:	TTCALL	13,0		;CLEAR ^O IF SET	
	  JFCL			;((JUST IN CASE))	
	MOVEI	M,[ASCIZ/Proceed?   /]
	PUSHJ	P,MSGTTY
	MOVEI	IO,R.TTY
OPER1:	PUSHJ	P,SSST		;GET HIS REPLY
	CAIN	CH,"/"		;IGNORE ANY /'S
	JRST	OPER1
	CAIN	CH,12		;WAS IT JUST CR (LF)?
	JRST	OPER		;YES--TRY AGAIN
OPER3:	MOVEI	B,OPRTAB	;MATCH THE REPLY
	PUSHJ	P,TABLU0
	  JRST	OPER0		;WHAT?
	JRST	@OPRDIS(B)

OPER0:	MOVEI	M,[ASCIZ/?Type H for help
/]				;REMIND OPR THAT HE'S A CLOD
	PUSHJ	P,MSGTTY
	SETZM	RH.TTY+2	;WIPE INPUT
	JRST	OPER


;'START:X' / 'STOP:X'

OPRSTA:	TLZA	F,L.STOP
OPRSTO:	TLO	F,L.STOP
	PUSHJ	P,SETMOD
	  JRST	OPER0	;TRY AGAIN
	JRST	OPER1

;'NO' / 'CANCEL'

OPRNO:	SETOM	NOTDON		;SHOW CMD NOT COMPLETED	
	JRST	FSQUIT

;'YES'

OPRYES:	POPJ	P,
;'DEFER'

OPRDEF:	PUSHJ	P,DEFERQ
	  JRST	OPER
	JRST	FSQUIT

;'HELP'

OPRHLP:	MOVEI	M,OPRHEL
	PUSHJ	P,MSGTTY
;**; [124]	INSERT @ OPRHLP+2	DML	3-AUG-76
	MOVEI	M,OPRHE1	;[124] PRINT OUT OTHER PARTS
	PUSHJ	P,MSGTTY	;[124]
	MOVEI	M,OPRHE2	;[124]    OF HELP MESSAGES
	PUSHJ	P,MSGTTY	;[124]
	JRST 	OPER

;'WHAT'
OPRWHT:	TTCALL	3,RPTTY
	JRST	OPER

;'WAIT'
OPRWAI:	TRNN	F,OB.OPC	;TEST FOR OPR COMMAND
	SKIPN	CMDNAM		;TEST FOR CMD FILE EXISENCE
	JRST	OPER		;  EITHER, OPR OR NO CMD FILE, IGNORE
OPRWA1:	TRO	F,OB.WFI	;SET WAIT-FOR-INPUT FLAG ON
	SETOM	WAITFG		;SET WAIT FLAG ON
	SETZM	CMDNAM		;CLEAR CMD-FILE NAME
	JRST	FSQUIT		;GO TERMINATE THIS COMMAND

;'PAUSE'
OPRPAU:	TRO	F,OB.WFI	;SET WAIT:FOR-INPUT FLAG ON
	SETOM	WAITFG		;SET WAIT FLAG ON
	JRST	OPER1		;CONTINUE ONWARD

IFN RIDSW, <
;'REELID:XXX'
OPRRID:	CAIE	CH,":"		;TEST FOR COLON
	JRST	OPER0		;  NO, GIVE ERROR
	PUSHJ	P,(IO)		;GET THE NEXT CHARACTER
	  JRST	OPER0		;  EOF, GIVE AN ERROR
	PUSHJ	P,SIXIN		; & ASSEMBLE A SIXBIT NAME
	JUMPE	A,OPER0		;  ERROR IF NULL NAME
	MOVEM	A,REELID	;STORE AS NEW REELID
	JRST	OPER1		; & CONTINUE
>;	END IFN	RIDSW
;HERE ON REENTER

	EXTERN	.JBOPC

REENT:	TLO	F,L.REEN	;REMEMBER REENTER
	TRO	F,OB.PRO	;REMEMBER TO 'PROCEED?'
	TRNE	F,OB.NOC	;IS ^C ALLOWED?
	JRST	@.JBOPC		;NO--TEND TO IT LATER

	MOVEM	17,SAVEAC+17	;YES-SAVE AC'S
	MOVEI	17,SAVEAC
	BLT	17,16
	MOVE	17,SAVEAC+17
	PUSHJ	P,OPER		;ASK THE OPERATOR
	HRLZI	17,SAVEAC	;  SO RESTORE THE AC'S & CONTINUE
	BLT	17,17
	TLZ	F,L.REEN	;HE CHANGED HIS MIND 
	JRST	@.JBOPC


;SUBROUTINE TO DISABLE ^C (SOME-DAY)

CONCOF:	TRO	F,OB.NOC	;BEST WE CAN DO NOW IS SET A BIT
	MOVEI	A,1B34		;GET ^C INTERRUPT ENABLE BIT
	IORM	A,INTBLK+1	;ENABLE FOR ^C INTERRUPT NOW
	POPJ	P,

;SUBROUTINE TO ENABLE ^C

CONCON:	TRZ	F,OB.NOC
	MOVEI	A,1B34		;GET ^C INTERRUPT ENABLE BIT
	ANDCAM	A,INTBLK+1	;DISABLE FOR ^C INTERRUPT NOW
	TLNE	F,L.REEN	;DID OPER. TRY TO REENTER
	TRZN	F,OB.PRO	;   DURING ^C-DISABLE?
	POPJ	P,		;NO--RETURN
	POP	P,.JBOPC	;YES-DO THE REENTER NOW
	JRST	REENT
;   INTERCEPT ROUTINE - FOR ^C AND DISK OFF-LINE
;
INTLOC:	PUSH	P,A		;SAVE AN AC
	HLRZ	A,INTBLK+3	;GET TYPE OF INTERRUPT
	CAIE	A,1B34		;TEST FOR ^C
IFE OFFLIN,<
	JRST	INTRET		;  NO, IGNORE IT
>;	END IFN OFFLIN
IFN OFFLIN,<
	JRST	INTOFF		;GO CHECK FOR DISK OFF-LINE
>;	END IFN OFFLIN
	TLO	F,L.REEN	;SET FLAG TO PRETEND ".REENTER"
	TRO	F,OB.PRO	;SET FLAG TO ASK "PROCEED"
INTRET:	MOVE	A,INTBLK+2	;GET SAVED INTERRUPT ADDRESS
	EXCH	A,(P)		;RESTORE AC & SAVE RETURN ADDR
	SETZM	INTBLK+2	;CLEAR TO RE-ENABLE FOR NEXT TRAP
	POPJ	P,		;RETURN TO INTERRUPTED PGM
;
;	TEST FOR AND HANDLE DISK OFF-LINE
;

IFN OFFLIN,<
INTOFF:	CAIE	A,1B33		;DISK OFF-LINE?
	 JRST	INTRET		;NO IGNORE
	PUSH	P,N
	PUSH	P,B
	SETZ	A,
	HRRZ	B,INTBLK+3	;GET CHANNEL: IT'S NOT NECESSARILY FSNAME
	DEVNAM	B,
	 MOVE	B,FSNAME	;HOPE WE GUESSED RIGHT
	MOVEM	B,OFFDSK	;SAVE UNIT
	MOVEI	M,[ASCIZ/? /]	;START MESSAGE
	PUSHJ	P,MSGTTY
IN1OFF:	PUSHJ	P,LOGUNI	;GET LOGICAL UNIT
	EXCH	A,B		;FLIP LOG. UNIT AND COUNTER
	PUSHJ	P,DSKUUO	;GET CHARACTERISTICS
	 JRST	IN2OFF
	TLNE	A,.UPOFL	;IS THIS THE OFF-LINE UNIT
	 JRST	IN3OFF		;YES..
	MOVE	A,B		;RESET LOG. UNIT COUNTER
	MOVE	B,OFFDSK	;RESTORE UNIT FOR LOGUNI
	AOJA	A,IN1OFF	;LOOK FOR NEXT LOG. UNIT

IN2OFF:	SKIPA	M,OFFDSK	;CAN'T FIND OFF-LINE UNIT

IN3OFF:	MOVE	M,DSKCHA+.UNNAM	;GET PHYSICAL NAME
	PUSHJ	P,MSG311
	PUSHJ	P,OPER		;GET OPERATOR'S ADVICE
	POP	P,B		;HE WANTS TO CONTINUE: MUST HAVE PUT
	POP	P,N		;  UNIT BACK ON-LINE
	JRST	INTRET
>;	END IFN OFFLIN
SUBTTL	MOUNT COMMAND PROCESSING
; M O U N T   C O M M A N D

;HERE TO READ COMMAND FILE

MOCOMF:	HRLZ	A,CMDJOB	;GET USER'S JOB #	
	HRRI	A,PRJPRG	;COMBINE WITH PPN GETTAB TABLE # 
	GETTAB	A,		;GET PPN OF USER'S JOB	
	  MOVE	A,USRPPN	;  FAILED, ASSUME OK	
	CAME	A,USRPPN	;TEST FOR THE USER	
	JRST	ERR500		;  NO, FATAL ERROR	
IFN FTFACT, <
	MOVE	A,CMDJOB	;GET USER'S JOB #
	DPB	A,[POINT 9,F.HEAD,17] ;STORE FOR ACCOUNTING
>;	END OF	IFN FTFACT
	MOVEI	IO,R.CMD
	PUSHJ	P,SSIXIN	;STEP PAST COMMAND NAME
	JRST 	MOCOM
;HERE TO READ TTY

MOCOMT:	MOVEI	IO,R.TTY

MOCOM:	SETZM	REELID		;CLEAR REELID IN CASE NOT REQ'D IN UMOUNT
	SETZM	NOSCAN		;[135]CLEAR RESCAN WORD TO PREVENT STARTING
				;[135]WITH DEVICE FROM EARLIER COMMAND
IFN FTTLAB,<
	SETOM	LABTYP		;CLEAR /LABELS SEEN
	SETZM	LABPOS		;CLEAR POSITION REQUEST
	SETZM	EXPDAT		;CLEAR EXPIRATION DATE
	SETZM	PROTEC		;CLEAR PROTECTION
>

	MOVEI	D,MOSWIT	;CHECK FOR SWITCHES
	PUSHJ	P,COMNAM	;   AND GET F/S NAME
	JUMPE	A,ERR201	;ERROR IF NONE
;[101]	TRNE	A,77		;PROPER NAME?
;	JRST	ERR200		;NO
	MOVEM	A,DVVNAM
IFN FTFACT, <
	MOVEM	A,F.DEV		;STORE DEVICE NAME FOR ACCOUNTING
>;	END OF	IFN FTFACT

	MOVEI	D,MOSWIT	;GET LOGICAL NAME (IF ANY)
	PUSHJ	P,COMNAM
	MOVEM	A,LOGNAM

	MOVEI	D,MOSWIT	;CK FOR SWITCHES AGAIN
	PUSHJ	P,SWITCH
	  JRST	FSQUIT		;BAD SWITCH

	HRLZI	D,-MAXUNI	;DEFAULT UNIT TABLES
MOCOM2:	SETZM	UDRIVE(D)
	SETZM	UNITID(D)
	SETZM	PDRIVE(D)
	MOVE	A,[UCLDEF]
	MOVEM	A,UNITCL(D)
	AOBJN	D,MOCOM2
	MOVE	B,[XWD -MAXUNI,UDRIVE] ;USER DRIVE TABLE
	PUSHJ	P,SIXLIS
	  JRST	FSQUIT		;SYNTAX ERROR
	MOVEM	B,FSUUNM	;REMEBER NUM. DRIVES USER REQUESTED

	MOVEI	D,MOSWIT	;CK SWITCHES A FINAL TIME
	PUSHJ	P,SWITCH
	  JRST	FSQUIT
	MOVEI	IO,W.TTY	;FOR MSG TYPING

;WHAT TYPE OF BEAST IS IT?

	MOVE	A,DVVNAM
	DEVCHR	A,PHONLY
	JUMPE	A,MOFS0		;IF NOT A DEVICE, ASSUME A F.S.
	MOVEM	A,DEVMOD
	TLNE	A,DC.FS
	JRST	MOFS1		;A DISK--NEEDS SPECIAL ATTENTION
	TRNN	F,OB.OPC	;OPR.CMDS ARE ONLY FOR F.S.'S & REELID
	JRST	MOCOM3		;NOT OPR, PROCEED

	TLNN	A,DC.MTA	;IS IT AN MTA?
	 JRST	ERR300
	SKIPN	B,REELID	;YES, CAN ONLY MEAN CHANGE OF REELID
	 JRST	ERR303
	MOVE	A,DVVNAM	;GET DEVICE NAME
	MTAID.	A,		;SET NEW REELID
	 JFCL
	JRST	MOFIN		;THAT'S ALL

;HERE IF NOT A F.S. REQUEST -- GENERIC OR SPECIFIC NAME?

MOCOM3:	LDB	A,[STAVER]	;MUST BE 503 FROM HERE ON IN
	CAIGE	A,V503
	 JRST	ERR097		;  QUIT IF NOT

MOUNT0:	MOVE	B,DVVNAM	;3 LETTERS OR LESS?
	TRNN	B,-1
	JRST	MOUNT1		;YES-GO FIND SPECIFIC UNIT
	MOVE	A,B		;NO--WHO DOES IT BELONG TO?
	DEVTYP	A,PHONLY
	  JSP	A,NEVERR
	SKIPN	A
	JSP	A,NEVERR	;  (SHOULD WORK IF DEVCHR WORKS)
	LDB	C,[.TYJOB+A]
	TLNE	A,.TYAVL	;   HAS ANYONE ASSIGNED DEVICE
	JUMPE	C,MOUNT4	;   NO ONE--TRY TO GET FOR USER
	CAMN	C,CMDJOB
	JRST	MOUNT8		;   THE USER-SKIP A LOT OF STUFF
	PUSHJ	P,MSG500	;   SOMEONE ELSE -- TELL OPERATOR
;HERE IF MUST FIND FREE UNIT FOR USER
;**; [122]	INSERT @ MOUNT1	JULY 27, 1976	DML
MOUNT1:	SKIPE	NOSCAN		;[122] RESCAN RESOURCES ?
	JRST	MOUN1A		;[122] NO
	HLLZ	B,DVVNAM	;[122] (REMOVE LABEL) START WITH DEV0
IFN FTTLAB,<
	TLNE	B,77		;[141] TWO CHARACTER DEVICE NAME
>;[141] END FTTLAB
	HRRI	B,'0  '
IFN MTA0SW, <
	CAMN	B,[SIXBIT /MTA0/] ;TEST FOR MTA0
	HRRI	B,'1  '		  ;  YES, CHANGE TO 'MTA1'
>;	END OF	IFN MTA0SW
	SETZ	D,		;CLEAR AC TO SHOW NO DVC ASSIGNED TO
				;THIS OMOUNT OF THE CORRECT TYPE
;**; [122]	INSERT @ MOUN11-1	JULY 27, 1976	DML
	JRST	MOUN11		;[122]
MOUN1A:	SETZM	NOSCAN		;[122] CLEAR NO RESCAN FLAG
	MOVE	B,DEVSCN	;[122] GET PREVIOUSLY SUGGESTED DEVICE
	JRST	MOUNT4		;[122] JUMP SO AS NOT TO RESCAN
MOUN11:
IFN FTTLAB,<
;**; [173]
;[173]	SKIPE	A,LABTYP	;[144] GET THE LABEL TYPE
;[173]	CAILE	A,.TFLIU	;[144] LEGAL LABEL TYPE FOR AVR ETC
;[173]	JRST	MOUN1D		;[144] NO, CONTINUE NORMALLY
;[173]	MOVEM	B,DEVSCN	;[144] SAVE THE DEVICE NAME
	MOVEM	B,DEVSCN	;[173] SAVE THE DEVICE NAME
	SETZM	AVRFLG		;[173] DON'T KNOW YET
	SKIPGE	A,LABTYP	;[173] GET THE LABEL TYPE
	MOVEI	A,LT.DEF	;[173] GET DEFAULT IF NONE GIVEN
	MOVEM	A,LABTYP	;[173] SAVE IT
	CAIGE	A,.TFLIU	;[173] LEGAL LABEL TYPE FOR AVR ETC
	CAIG	A,0		;[173] BPL
	JRST	MOUN1D		;[173] NO, CONINUE NORMALLY
	SETOM	AVRFLG		;[173] OK FOR AVR
	PUSH	P,D		;[144] SAVE D
	PUSHJ	P,SRCVOL	;[144] DOES THE VOLUME EXITS ETC
	  JRST	MOUN1B		;[144] NO, VOLUME DOES NOT EXIST
	  JRST	MOUN1B		;[144] YES, VOLUME EXISTS BUT ASSIGN TO ANOTHER USER
	POP	P,D		;[144] RESTORE D
	MOVEM	A,DEVSCN	;[144] YES, VOLUME EXISTS AND IS AVAILABLE
	MOVE	M,DEVSCN	;[144] GET THE DEVICE NAME
	PUSHJ	P,MSGMNT	;[144] TELL THE OPR WHAT IS GOING ON
	MOVE	B,DEVSCN	;[144] RESTORE THE DEVICE NAME
	JRST	MOUNT5		;[144] CONTINUE AS IF THE OPR RESPONDED
MOUN1B:	POP	P,D		;[144] RESTORE D
MOUN1D:	MOVE	B,DEVSCN	;[144] RESTORE THE DEVICE NAME
MOUN1C:				;[144]
>;[144] END FTTLAB
	MOVE	A,B
;**; [122]	INSERT @ MOUN11+1	JULY 27, 1976	DML
	MOVEM	B,DEVSCN	;[122] SAVE DEVICE IN CASE OF NO RESCAN
	DEVTYP	A,PHONLY
	  JRST	MOUNT3
	JUMPE	A,MOUNT3	;CANT FIND AVAILABLE UNIT
	LDB	C,[.TYJOB+A]
	TLNN	A,.TYAVL	;TEST FOR AVAILABLE DEVICE
	JRST	MOUN12		;  NO, JUMP
	JUMPE	C,MOUNT4	;FOUND IT IF AVAILABLE & UNASSIGNED
	CAME	C,OURJOB	;TEST FOR ASSIGNED TO [SELF]
	JRST	MOUN12		;  NO, IGNORE THIS DEVICE
	MOVE	D,B		;SAVE NAME OF DVC ASSIGNED TO OMOUNT
MOUN12:				;HERE IF DVC NOT AVAILABLE & UNASSIGNED
	ADDI	B,10000		;TRY NEXT ONE
IFN FTTLAB,<	JRST	MOUN1C>	;[144]
IFE FTTLAB,<	JRST	MOUN11>	;[144]

;HERE IF CANT FIND FREE UNIT

MOUNT3:				;HERE IF DVC NOT FOUND
	SKIPN	B,D		;TEST FOR DVC ASSIGNED TO OMOUNT FOUND
	JRST	MOUN31		;  NO, JUMP
	PUSHJ	P,MSG506	;TELL THE OPERATOR
;**; [122]	INSERT @ MOUN31-1	JULY 27, 1976	DML
	MOVEM	B,DEVSCN	;[122] SAVE DEVICE IN CASE OF NO RESCAN
	JRST	MOUNT4		; & TRY THAT ONE
MOUN31:				;HERE IF NO DVC (EVEN ASSIGNED TO OMOUNT) FOUND
	PUSHJ	P,MSG501	;TELL OPERATOR
	HLLZ	B,DVVNAM	;USE ONLY GENERIC NAME
;HERE TO GET OPERATORS OK OR CHOICE
;B HAS NAME TO TYPE AT HIM

MOUNT4:	HRRZ	M,B		;HERE TO ASK OPR ABOUT DEVICE AS SELECTED
	JUMPE	M,MOUN41
	CAMN	B,DVVNAM	;IS THIS THE USERS DESIRE?
	JRST	MOUN41		;YES
	HRRZ	A,DVVNAM	;GET R.H. OF REQUESTED UNIT NAME
IFN MTA0SW, <
	CAME	B,[SIXBIT /MTA0/];TEST FOR 'MTA0' SELECTED BUT NOT RQSTED
>;	END OF	IFN MTA0SW
	JUMPE	A,MOUN43	;JUMP IF GENERIC REQUESTED
	SETZ	M,		;ERASE SPECIFIC UNIT SELECTION
	HLLZS	B		;  DITTO
	JRST	MOUN41		;GO TYPE GENERIC UNIT # ONLY
MOUN43:	ROT	M,-6		;HERE IF GENERIC DEVICE RQSTED
	ADDI	M,'( )'		;PUT PARENS AROUND UNIT NUMBER
MOUN41:	HLL	M,B
	PUSH	P,B
	PUSHJ	P,MSGMNT	;TYPE THE MOUNT MSG TO THE OPR
	PUSHJ	P,SPACE		;LEAVE A SPACE BEFORE THE REPLY
	MOVEI	M,MONHLP	;GET THE WORD
IFE FTTLAB,<	PUSHJ	P,OPRARG>	;[144]
IFN FTTLAB,<	PUSHJ	P,OPRAVR>	;[144] GET OPR RESPONSE OR AVR RESPONSE
	POP	P,B
;**; [122]	INSERT @ MOUN41+7	JULY 28, 1976	DML
;**; [122] SET NO RECSAN FLAG FOR OPERATOR REPLIES:/ST, /STOP,
;**; [122]  /WH, /PA, /HE, /REELID
	CAIN	N,1		;[122] IF N=1 AND
	CAIE	A,0		;[122] A=0   OR
	CAIN	N,2		;[122] N=2
	SETOM	NOSCAN		;[122] SET NO RESCAN FLAG
	JRST	.+1(N)	;DISP. ON N
	JRST	MOUN42	;0-LONE C.R.
	JUMPN	A,MOUN44;1-NOT LONE C.R.
	JRST	MOUNT0	;2-/HELP
	JRST	MOUN54	;3-SOME GARBAGE
	JRST	MOUN54	;4-ERROR
MOUN42:
IFN FTTLAB,<
	TLNN	B,77		;[141] TWO CHARACTER DEVICE NAME
	HRRI	B,'0  '		;[141] YES, GICE IT UNIT 0
>;[141] END FTTLAB
;**; [146] REPLACE AT MOUN42+1 (AFTER OSLO EDIT)
	TRNN	B,777777	;[146] GENERIC?
	 JRST	MOUN45		;[146] COMPLETELY.
	TRNN	B,000077	;[146] SKIP IF DEFINITELY NOT
	 TRNN	B,007700	;[146] MAYBE.  SKIP IF SO.
	  JRST	MOUNT5		;[146] OK, USE IT
;[146]	TRNE	B,-1		;WAS IT A SPECIFIC UNIT?
;[146]	JRST	MOUNT5		;YES-USE IT
MOUN45:	PUSHJ	P,MSG701	;NO--TELL OPR TO TRY AGAIN
	JRST	MOUNT0

MOUN44:	TRNN	A,-1		;TEST FOR 'DEVN' TYPED
	JRST	MOUN46		;  NO, JUMP (MUST BE JUST 'N')
;**; [146] REMOVE TWO LINES AT MOUN44 + 2 (NOW UNDER OSLO SWITCH)
REPEAT 0,<
IFE FT0SLO.4,<
	TRNE	A,007777	;[144] TEST FOR MORE THAN 4 CHARS INPUT
	JRST	MOUN54		;[144]   YES, GIVE AN ERROR MSG
>;[144] END FTTLAB
>; END REPEAT 0			;[146]
	LDB	C,[POINT 12,A,11] ;GET 1ST TWO CHARS OF INPUT
	LDB	D,[POINT 12,B,11] ;GET 1ST TWO CHARS OF USER RQST
	CAME	C,D		;TEST FOR SAME TWO CHARS
	JRST	MOUN54		;  NO, GIVE AN ERROR MSG
	MOVE	B,A		;SAVE INPUT DEVICE NAME
;**; [146] REPLACE AT MOUN46-1	CLRH	4-AUG-78
;[146]	JRST	MOUN47		; & JUMP
	JRST	MOUN4X		;[146] AND JUMP
MOUN46:				;HERE IF SINGLE DIGIT INPUT
;**; [146] REPLACE AT MOUN46	CLRH	4-AUG-78
;[146]	ROT	A,6
;[146]	CAIL	A,'0'		;DIGIT?
;[146]	CAILE	A,'7'
;[146]	JRST	MOUN54		;NO--TRY AGAIN
;[146]	DPB	A,[POINT 6,B,23]	;YES-USE IT
	HLR	B,A		;[146] MASH CONTROLLER WITH UNIT

;**; [146] INSERT BEFORE MOUN47	CLRH	4-AUG-78
MOUN4X:	TRNN	B,777777	;[146] LOOK REASONABLE?
	 JRST	MOUN54		;[146] NO
	TRNN	B,000077	;[146] HAVE A SIXTH DIGIT?
	 TRNN	B,007700	;[146] NO, MUST NOT HAVE A FIFTH
	  JRST	.+2		;[146] OK.
	JRST	MOUN54		;[146] ERROR -- GIVE CHARS.
MOUN47:	MOVE	A,B		;COPY DEVICE NAME
	DEVCHR	A,PHONLY	;TEST FOR LEGAL NAME
	JUMPE	A,MOUN54	;  NO, GIVE ERROR MSG


IFN DRIREQ, <
	HRRZ	A,DVVNAM	;IF USER REQUESTED SPECIFIC DRIVE,
	JUMPE	A,MOUNT5	; (HE DIDN'T)
	 SUBI	A,(B)		;INSIST ON IT
	JUMPE	A,MOUNT5	;OK...
	 MOVEI	M,[ASCIZ /Use requested Drive
/]
	PUSHJ	P,MSGTTY
	MOVE	B,DVVNAM	;RESTORE USER'S CHOICE
	JRST	MOUNT0		; AND TRY AGAIN
>;	END OF IFN DRIREQ
;HERE WITH DEVICE THAT OPERATOR HAS BLESSED IN B
;TRY TO INIT IT

MOUNT5:				;HERE WITH CHOSEN DEVICE
IFN MTA0SW, <
	CAMN	B,[SIXBIT /MTA0/] ;TEST FOR MTA0 CHOSEN
	CAMN	B,DVVNAM	  ;TEST FOR MTA0 REQUESTED
	SKIPA			  ;  SKIP IF MTA0 NOT CHOSEN, OR
				  ;   BOTH CHOSEN AND REQUESTED
	JRST	MOUN45		  ;  JUMP IF CHOSEN BUT NOT REQUESTED
>;	END OF	IFN MTA0SW
	HRLZ	C,DEVMOD	;FIND A LEGAL MODE FOR THIS GUY
	TLZ	C,ASSPRG!ASSCON
	JFFO	C,MOUN51	;  CONVERT BIT.POSIT. TO NUMBER
	JSP	A,NEVERR
MOUN51:	MOVEI	A,^D17
	SUB	A,D
	TLO	A,PHOPEN	;RQST PHYSICAL-ONLY OPEN
	MOVEI	C,0		;NOW DO THE OPEN
	OPEN	USR,A
	  SKIPA	A,B
	JRST	MOUNT6	;SUCCESS

	DEVTYP	A,PHONLY	;WHATS THE PROBLEM?
	  JSP	A,NEVERR
	JUMPN	A,MOUN52
	PUSHJ	P,MSG703	;ILLEGAL NAME
	JRST	MOUNT0
MOUN52:	TLNE	A,.TYAVL
	JRST	MOUN53
	LDB	A,[.TYJOB+A]	;GET OWNER'S JOB #
	CAMN	A,OURJOB	;TEST FOR SELF
	JRST	MOUNT6		;  YES, WE CAN USE IT!, JUMP
	PUSHJ	P,MSG701	;UNAVAILABLE
	JRST	MOUNT0
MOUN53:	MOVE	C,B		;RANDOM OPEN FAILURE
	PUSHJ	P,MSG272
;**;[115] CHANGE @ MOUN53+2	JNG	20-Sep-75
	JRST	MOUNT0		;[115]

MOUN54:	PUSHJ	P,MSG200	;/H FOR HELP
;**; [122]	INSERT @ MOUN54+1	JULY 27, 1976	DML
	SETOM	NOSCAN		;[122] DONT RESCAN IF ERRORS OR JUNK
	JRST	MOUNT0
;HERE WITH DEVICE NAMED IN B OPENED ON USR
;ASSIGN LOGICAL NAME (IF ANY)

MOUNT6:				;HERE WITH OPEN DEVICE
	MOVEM	B,PHYNAM	;STORE THE PHYSICAL NAME
	MOVEM	B,DTDRIV	;STORE DEVICE NAME
	MOVE	A,DEVMOD	;GET DEVICE BITS
	TLNN	A,DC.DTA!DC.MTA ;TEST FOR DECTAPE/MAGTAPE MOUNTED
	JRST	MOUN61		;  NO, JUMP
;**;[114] CHANGE @ MOUNT6+6	JNG	8-Sep-75
IFN RIDSW, <			;[114]
	TLNN	A,DC.MTA	;TEST FOR MAGTAPE MOUNT
>;	END IFN	RIDSW
	PUSHJ	P,BLDTID	;GO BUILD DECTAPE ID
	  SETZM	CMDTAP		;  MAGTAPE/FAILED, CLEAR TAPE ID WORD
	MOVSI	A,(Z USR,)	;GET CHANNEL # TO USE
	PUSHJ	P,CKDTID	;GO CHECK DECTAPE ID, ET AL.
	  JRST	MOUN45		;  OPEN FAILURE, TRY AGAIN
	  JRST	MOUNT0		;  DIR/ID FAILURE, GO ASK AGAIN
IFN RIDSW, <
	MOVE	A,DEVMOD	;GET THE DEVCHR BITS FOR THE TAPE
	TLNE	A,DC.MTA	;TEST FOR A MAGTAPE
	SKIPE	REELID		;TEST FOR A REELID
	JRST	MOUN61		;  NOT A MAGTAPE/REELID GIVEN, THEN JUMP
	SKIPE	A,CMDTAP	;GET THE REELID DERIVED FROM THE VID
	MOVEM	A,REELID	; & STORE IT IF NON-NULL
	JUMPN	A,MOUN61	;DONE IF NON-ZERO NOW
	MOVE	A,[%CNVER]	;GET GETTAB PARMS FOR MONITOR VERSION
	GETTAB	A,		;GET THE MONITOR VERSION
	  JRST	MOUN61		;  FAILED, PRE-5.03, JUMP
	TLZ	A,-1		;CLEAR L.H.
	CAIGE	A,50700		;TEST FOR 5.07 OR LATER
	JRST	MOUN61		;  NO, THEN JUMP
MOUN60:	MOVEI	M,[ASCIZ \% Blank /REELID for \] ;POINT AT MSG
	PUSHJ	P,MSGTTY	;TYPE THE MSG
	MOVE	M,PHYNAM	;GET THE DEVICE NAME
	PUSHJ	P,SIXMSO	; & TYPE IT
	MOVEI	M,[ASCIZ /:
/]				;POINT AT REST OF MSG
	PUSHJ	P,MSGTTY	; & TYPE IT
	PUSHJ	P,OPER		;GIVE A 'PROCEED'
IFG RIDSW, <
	SKIPN	REELID		;TEST FOR A REELID NOW
	JRST	MOUN60		;  NO, REPEAT
>;	END OF	IFG RIDSW
>;	END OF	IFN RIDSW
MOUN61:				;HERE TO ASSIGN A LOGICAL NAME
	SKIPN	B,LOGNAM
	JRST	MOUN63		;NO LOGICAL NAME
	MOVEI	A,USR
	DEVLNM	A,
	  AOSA	A
	JRST	MOUN63		;SUCCESS
	AOJE	A,MOUN62	;LOGICAL NAME CONFICT?
	JSP	A,NEVERR	;NO--SHOULDNT BE
MOUN62:	MOVE	A,LOGNAM	;GET THE USER'S LOGICAL NAME
	DEVNAM	A,		;FIND OUT THE ASSOC PHYSICAL NAME
	  JSP	A,NEVERR	;  FAILED, A FATAL & UNKNOWN ERROR
	SETZ	B,		;SET A NULL NAME
	DEVLNM	A,PHONLY	;ERASE THE PREVIOUS LOGICAL NAME
	  JSP	A,NEVERR	;  FAILED, A FATAL & UNKNOWN ERROR
	JRST	MOUN61		;GO TRY AGAIN

;HERE TO GIVE A SPECIFIC DEVICE A REELID
MOUN63:	MOVE	A,DEVMOD
	TLNE	A,DC.MTA	;DEVICE A MAGTAPE?
	SKIPN	B,REELID	; AND IS A REELID SPECIFIED
	 JRST 	MOUNT7		;NO
;**; [153] CONDITIONALLY REMOVE AT MOUN63+4 FOR 8 LINES	CLRH	16-NOV-78
IFN FTTLAB, <				;[153] DO NOT CONVERT TO SIXBIT IF NOT FTTLAB
	MOVE	C,[POINT 8,REELID]	;BYTE POINTER TO REELID
	MOVE	D,[POINT 6,B]		;WHERE TO PUT IT
	SETZ	B,		;CLEAR B
MOUN64:	ILDB	A,C		;GET A CHARACTER
	SUBI	A,"0"-'0'	;CONVERT TO SIXBIT
	IDPB	A,D		;SAVE IT
	TLNE	D,770000	;WHOLE WORD
	JUMPN	A,MOUN64	;LOOP FOR NEXT CHARACTER
;**; [153] END OF CONDITONALLY REMOVED CODE AT MOUN64+5	CLRH	16-NOV-78
>	; END IFN FTTLAB	;[153] END OF CONDITIONALLY REMOVED CODE
	MOVEI	A,USR		;YES, GIVE THE DEVICE THIS REELID
	MTAID.	A,
	 JFCL
;HERE WITH ALL DONE EXCEPT REASSIGNMENT TO USER (OPENED ON USR)

MOUNT7:	HRLZ	A,CMDJOB	;SEE IF JOB HAS SAME PPN AS REQUESTOR
	HRRI	A,PRJPRG	;			
	GETTAB	A,		;
	  JRST	MOUN71		;
	CAME	A,USRPPN	;PPN'S THE SAME?
	JRST	MOUN77		;NO -- USER JOB NO LONGER AROUND
MOUN71:
IFN FTTLAB,<
	MOVE	A,DEVMOD		;GET DEVICE BITS
	TLNE	A,DC.MTA		;IS IT A MAGTAPE?
	PUSHJ	P,SNDPLR		;YES, SEND A MESSAGE TO PULSAR
MOUN72:
> ;END IFN FTTLAB
	MOVE	A,CMDJOB
	MOVEI	B,USR
	REASSI	A,
	JUMPE	A,MOUN77	;JUMP IF USER JOB NO LONGER AROUND
	MOVE	A,PHYNAM	;GET PHYSICAL NAME
	DEVTYP	A,PHONLY	;FIND OUT ABOUT IT
	  JSP	A,NEVERR	;  FAILED, A FATAL & UNKNOWN ERROR
	LDB	A,[.TYJOB+A]	;GET OWNER'S JOB #
	CAMN	A,CMDJOB	;TEST FOR SUCCESSFUL REASSIGN
	JRST	MOUN75		;  YES, JUMP (A WINNER)
	JUMPE	A,MOUN73	;JUMP IF NOT ASSIGNED ANYPLACE
	CAME	A,OURJOB	;TEST FOR OWNED BY [SELF]
	JSP	A,NEVERR	;  NO, A FATAL & UNOWN ERROR
	SETZ	A,		;GET ZERO JOB #
	MOVE	B,PHYNAM	;GET THE PHYSICAL NAME
	REASSI	A,		;DEASSIGN THE DEVICE
MOUN73:	MOVEI	M,[ASCIZ /REASSIGN UUO failure/] ;POINT AT POTENTIAL ERROR MSG
	SKIPN	LOGNAM		;TEST FOR LOGICAL NAME GIVEN
	JRST	ERR994		;  NO, GO GIVE THE ERROR MSG
	MOVEI	M,[ASCIZ \User logical-name conflict - Mount w/o logical name?
\]				;POINT AT MSG EXPLAINING ALL
	PUSHJ	P,MSGTTY	; & TYPE IT
	PUSHJ	P,OPER		;ASK FOR OPERATOR'S OPINION
	SETZM	LOGNAM		;ERASE THE LOGICAL NAME
	MOVE	B,PHYNAM	;RESTORE THE PHYSICAL NAME
	JRST	MOUNT5		; & REPEAT THE PROCESS
MOUN75:				;HERE IF IT ALL WORKED
IFN FTFACT, <
	MOVE	A,PHYNAM	;RESTORE THE PHYSICAL NAME
;**; [151]	INSERT @ MOUN75+1/2	CLRH	8-NOV-78
	DEVNAM	A,		;[151] GET THE DEVICE NAME
	 SKIPA			;[151] NONE, LEAVE ALONE
	MOVEM	A,F.DEV		;STORE IT FOR ACCOUNTING
>;	END OF IFN FTFACT

	JRST	MOFIN		;YEA!

;**; [157] INSERT AT MOUN77	CLRH	7-DEC-78
MOUN77:				;[157]
	SKIPN	A,LOGNAM	;[157] DID USER HAVE A LOGICAL NAME?
	 JRST	MOUN78		;[157] NO
	DEVNAM	A,		;[157] YES, GET REAL NAME
	 JRST	MOUN78		;[157] SOME ERROR, JUST RELEASE IT
	SETZ	B,		;[157] SET UP TO CLEAR LOGICAL NAME
	DEVLNM	A,PHONLY	;[157] CLEAR LOGICAL NAME
	 JFCL			;[157] SOME ERROR, JUST RELEASE IT
MOUN78:	RELEAS	USR,		;[157] USER JOB HAS GONE AWAY, SO MUST RELEASE
	JRST	ERR500		;[157] THE DEVICE BEFORE TELLING OPERATOR

;HERE IF USER ALREADY HAS DEVICE

MOUNT8:				;HERE IF USER ALREADY HAS THE DEVICE
	MOVE	M,DVVNAM	;GET THE USER'S DEVICE NAME
	PUSHJ	P,MSGMNT	;TYPE A MOUNT MSG
	PUSHJ	P,CRLF		;  DITTO
	MOVEI	M,[ASCIZ/Already assigned to user
/]
	PUSHJ	P,MSGTTY
	PUSHJ	P,OPER
	JRST	MOFIN
IFN FTTLAB,<
SUBTTL SRCVOL - SEARCH FOR A MTA WITH THE CORRECT VOLUME MOUNTED.
;[144] DEFINE THE AC'S

;[144] CALL	PUSHJ	P,SRCVOL
;[144] RETURN	CPOPJ		;VOLUME DOES NOT EXIST
;[144] 	CPOPJ1		;VOLUME EXITS BUT IS IN USE BY ANOTHER JOB
;[144]	CPOPJ2		;VOLUME EXITS AND IS AVAILABLE (A=PHY DEVICE NAME)

SRCVOL:				;[144] ENTRY TO SRCVOL
	MOVE	B,[POINT 8,REELID]	;[144]
	MOVE	C,[POINT 6,D]	;[144]
	SETZ	D,		;[144]
	ILDB	A,B		;[144] GET AN EIGHT BIT CHARACTER
	SUBI	A,"0"-'0'	;[144] SIXBIT
	IDPB	A,C		;[144] STORE
	TLNE	C,770000	;[144] WHOLE WORD
	JUMPN	A,.-4		;[144] CONTINUE
	JUMPE	D,CPOPJ		;[144] NO VOLUME ID
	SETZM	MTAVOL+1	;[144] INITIALIZE THE START
SRCVO1:	MOVEI	A,.TYMTA	;[144]
	MOVEM	A,MTAVOL	;[144] STORE THE DEVICE TYPE
	MOVE	A,[2,,MTAVOL]	;[144] DVPHY. ARG POINTER
	DVPHY.	A,		;[144] GET NEXT MTA UNIT
	  JRST	ERR450		;[144] WHAT NOT A 6.03 MONITOR
	SKIPN	C,MTAVOL+1	;[144] GET THE DRIVE NAME
	POPJ	P,		;[144] END OF DRIVE LIST
	MOVEI	B,.TFLBL	;[144] GET THE LABEL TYPE
	MOVE	C,MTAVOL+1	;[144] GET THE DRIVE NAME
	MOVE	A,[XWD 3,B]	;[144]
	TAPOP.	A,		;[144]
	  JRST	ERR452		;[144] FAILS READING LABEL TYPE
	JUMPE	A,SRCVO1	;[144] UNLABELED TAPE
	CAILE	A,.TFLIU	;[144] LOOK FOR LEGAL ARV LABELS
	JRST	SRCVO1		;[144] NO, MUST BE NON-STANDARD OR NO LABELS
	MOVEI	A,.TFSTA	;[144] FUNCTION TO GET THE MTA STATUS
	MOVEM	A,MTAVOL	;[144] STORE THE FUNCTION
	MOVE	A,[XWD 3,MTAVOL]	;[144]
	TAPOP.	A,		;[144] GET THE STATUS
	  JRST	ERR453		;[144] FAILS GETTING REELID
	SKIPE	A,MTAVOL+.TSRID	;[144] GET THE REEID ID
	CAME	A,D		;[144] IS IT THE ONE WE WANT
	JRST	SRCVO1		;[144] NO, LOOK FOR ANOTHER DRIVE
	AOS	(P)		;[144] SKIP RETURN VOLUME ID FOUND
	MOVE	A,MTAVOL+1	;[144] GET THE DEVICE NAME
	DEVTYP	A,		;[144] GET THE DEVICE TYPE AND OWNER IF ANY
	  JSP	A,NEVERR	;[144] BETTER NOT
	TRNN	A,777B26	;[144] ASSIGNED A JOB NUMBER
	AOS	(P)		;[144] NO, DOUBLE SKIP RETURN
	MOVE	A,MTAVOL+1	;[144] GET THE DEVICE NAME AND RETURN
	POPJ	P,		;[144] YES, SINGLE SKIP RETURN
	UU(MTAVOL,3)	;	;[144]
>;IFN FTTLAB
; ROUTINE TO TYPE A MOUNT MESSAGE
;	CALL WITH DEVICE NAME IN AC 'M'

MSGMNT:	PUSH	P,M		;SAVE DEVICE #
	MOVEI	M,[ASCII /Mount **** /] ;POINT AT MSG 1ST PART
	PUSHJ	P,MSGTTY	;TYPE IT
	SETZ	M,		;CLEAR MSG POINTER
	MOVE	B,DEVMOD	;GET DEVICE MODE BITS
	TLNE	B,DC.DTA	;TEST FOR DECTAPE
	MOVEI	M,[ASCIZ /DECtape /] ;  YES, POINT AT MSG
	TLNE	B,DC.MTA	;TEST FOR MAGTAPE
	MOVEI	M,[ASCIZ /MAGtape /] ;  YES, POINT AT MSG
	TLNE	B,DC.CDR	;TEST FOR CDR/CDP
	MOVEI	M,[ASCIZ /CARDS /];  YES, POINT AT MSG
	TLNE	B,DC.PTP!DC.PTR	;TEST FOR PTR/PTP
	MOVEI	M,[ASCIZ /Paper-Tape /] ;  YES, POINT AT MSG
	SKIPE	M		;TEST FOR DTA/MTA
	PUSHJ	P,MSGTTY	;  YES, TYPE THE TEXT
IFN RIDSW,<
	TLNE	B,DC.MTA	;TEST FOR A MAGTAPE
	SKIPN	REELID		;TEST FOR REELID GIVEN
	JRST	MSGMND		;  JUMP IF NOT A MAGTAPE W/REELID GIVEN
	MOVEI	M,[ASCIZ /# /]	;POINT AT MORE TEXT
	PUSHJ	P,MSGTTY	; & TYPE IT
	MOVE	M,REELID	;GET THE REELID
	PUSHJ	P,SIXMSO	; & TYPE IT
	MOVEI	M,[ASCIZ \
/VID: \]			;POINT AT MORE TEXT
	SKIPLE	VIDK		;TEST FOR /VID GIVEN
	PUSHJ	P,MSGTTY	;  YES, THEN SEPARATE THE REELID & VID
MSGMND:
>;	END IFN	RIDSW
	MOVE	A,VIDK		;GET COUNT OF VID LTH
	MOVE	B,[POINT 7,VID]	;GET BYTE POINTER FOR VID
MSGMNA:	SOJL	A,MSGMNB	;DECR CHAR COUNT & JUMP IF DONE
	ILDB	CH,B		;GET NEXT CHARACTER OF THE VID
	PUSHJ	P,(IO)		; & TYPE IT
	JRST	MSGMNA		;REPEAT
MSGMNB:	MOVEI	M,FORMSG	;POINT AT MSG ' FOR USER ['
	PUSHJ	P,MSGTTY	; & TYPE IT
	HLRZ	N,USRPPN	;GET PROJECT #
	PUSHJ	P,OCTPRT	; & TYPE IT
	PUSHJ	P,COMMA		;TYPE A COMMA
	HRRZ	N,USRPPN	;GET PROGRAMMER #
	PUSHJ	P,OCTPRT	; & TYPE IT
	MOVEI	M,[ASCIZ /]
/]				;POINT AT PPN CLOSE MSG
	PUSHJ	P,MSGTTY	; & TYPE IT
	MOVE	B,DEVMOD	;GET DEVCHR BITS
IFN FTTLAB,<
IFE <LT.DEF-LT.BLP>,<		;IF DEFAULT LABEL TYPE IS BLP
	JRST	MSGMND		;SKIP REQUEST TO OPR
>
IFN <LT.DEF-LT.BLP>,<		;IF DEFAULT LABEL TYPE IS NOT BLP
	SKIPN	LABTYP		;NO /LABELS OR NOT BLP?
>
	TLNN	B,DC.MTA	;A MAGTAPE?
	  JRST	MSGMND		;DON'T TALK ABOUT BYPASS LABELS
	MOVEI	M,[ASCIZ/BYPASS LABELS REQUESTED.
/]
	PUSHJ	P,MSGTTY	;TELL THE OPR
	PUSHJ	P,OPER		;ASK IF PROCEED? DON'T RETURN IF NO
MSGMND:	MOVE	B,DEVMOD	;GET BACK DEVMOD BITS

>	;END OF IFN FTTLAB

	TLC	B,DC.IN!DC.OUT	;INVERT INPUT & OUTPUT BITS
	TLNE	B,DC.IN!DC.OUT	;TEST FOR *BOTH* INPUT & OUTPUT POSSIBLE
	JRST	MSGMNC		;  NO, JUMP
	MOVEI	M,WRLMSG	;ASSUME 'WRITE-LOCKED'
	TRNE	F,SB.WE		;TEST FOR WRITE-ENABLED REQUESTED
	MOVEI	M,WRTMSG	;  YES, CHANGE TO 'WRITE-ENABLED'
	PUSHJ	P,MSGTTY	;  YES, TYPE IT THEN
MSGMNC:	MOVEI	M,[ASCIZ /on /]	;POINT AT MORE TEXT
	PUSHJ	P,MSGTTY	; & TYPE IT
	POP	P,M		;RESTORE DEVICE NAME
	PUSHJ	P,SIXMSO	;TYPE THE DEVICE NAME
	PJRST	COLON		;TYPE A COLON & RETURN TO CALLER
;
;  SUBROUTINE TO OPEN A TAPE ON SPECIFIED CHANNEL & MAKE VALIDITY CHECKS
;	VERIFIES READABILITY OF DECTAPE DIRECTORY, CORRECTNESS OF
;	DECTAPE ID, AND PROPER SETTING OF WRITE-LOCK/WRITE-ENABLE
;	SWITCH.
;
;	CALL:	SET UP 'DTDRIV', 'DEVMOD', & 'CMDTAP' AS DESIRED
;		MOVSI	A,(Z <CHANNEL #>,)
;		PUSHJ	P,CKDTID
;		  <OPEN FAILURE>
;		  <DIRECTORY ERROR / ID MISMATCH>
;		<NORMAL RETURN - CHANNEL IS ASSIGNED>
;

CKDTID:	MOVEM	A,DTCHAN	;STORE CHANNEL #
	SETZM	IDFLAG		;SHOW ID NOT CHECKED
IDRTRY:	MOVE	A,DEVMOD	;GET DEVCHR BITS FOR THE DEVICE
	TLNE	A,DC.MTA	;TEST FOR MAGTAPE
	JRST	CHKIDM		;  YES, JUMP
	MOVE	A,[PHOPEN,,117]	;GET PHYSICAL-ONLY OPEN PARMS
	MOVE	B,DTDRIV	;GET DEVICE NAME
	SETZ	C,		;SET NO BUFFER HEADERS
	PUSHJ	P,DTXCT		;EXECUTE NEXT INSTR W/ CORRECT CHANNEL #
	 OPEN	.-.,A		;OPEN THE DECTAPE
	  POPJ	P,		;  FAILED, RETURN+0
;**;[117]	Insert @ IDRTRY+8L	RKH	3-Mar-76
	SKIPN	CMDTAP		;[117] BYPASS LABEL VERIFICATION?
	JRST	CHKID7		;[117] YES, DON'T READ DIRECTORY
	PUSHJ	P,DTXCT		;EXECUTE NEXT INSTR W/ CORRECT CHANNEL #
	 USETI	.-.,144		;POSITION FOR THE DIRECTORY
	PUSHJ	P,DTXCT		;EXECUTE NEXT INSTR W/ CORRECT CHANNEL #
	 INPUT	.-.,DIRIOW	;READ THE DIRECTORY
	PUSHJ	P,DTXCT		;EXECUTE NEXT INSTR W/ CORRECT CHANNEL #
	 STATZ	.-.,740000	;TEST FOR READ ERROR
	  JRST	DTDERR		;  YES, GIVE DIAGNOSTIC & RETURN+1
	SKIPE	CMDTAP		;TEST FOR NULL ID (NO CHECKING DONE)
	SKIPE	IDFLAG		;TEST FOR ID ALREADY CHECKED
	JRST	CHKID7		;  EITHER, JUMP
	SKIPE	A,DTADIR+177	;GET DECTAPE ID WORD & TEST FOR ZERO
	CAMN	A,[-1]		;TEST FOR MINUS ONE
	JRST	CHKID6		;  ZERO OR MINUS ONE, JUMP
	CAMN	A,CMDTAP	;TEST FOR SAME
	JRST	CHKID7		;  YES, JUMP
CHKID0:	MOVE	M,CMDTAP	;[104] GET RQSTED TAPE ID
CHKID1:	TLNN	M,770000-'0  '	;TEST FOR LEADING ZERO
	TLNN	M,'0  '		;TEST FOR LEADING ZERO
	JRST	CHKID2		;  NO, JUMP
	LSH	M,6		;SHIFT THE LEADING ZERO AWAY
	JRST	CHKID1		; & REPEAT
CHKID2:	CAMN	M,DTADIR+177	;NOW TEST FOR MATCHING TAPE ID
	JRST	CHKID7		;  YES, ID IS *REALLY* OK
	MOVEI	M,BADID1	;POINT AT MSG - 'TAPEID'
	PUSHJ	P,MSGTTY	; & TYPE IT
	MOVE	M,DTADIR+177	;GET DTA'S ACTUAL ID
	PUSHJ	P,SIXMSO	; & TYPE IT
	MOVEI	M,BADID2	;POINT AT MSG - 'ON'
	PUSHJ	P,MSGTTY	; & TYPE IT
	MOVE	M,DTDRIV	;GET DTA DRIVE #
	PUSHJ	P,SIXMSO	; & TYPE IT
	MOVEI	M,BADID3	;POINT AT MSG - 'DOES NOT MATCH USER TAPE#'
	PUSHJ	P,MSGTTY	; & TYPE IT
	MOVE	M,CMDTAP	;GET REQUESTED TAPE ID
	PUSHJ	P,SIXMSO	; & TYPE IT
	PUSHJ	P,CRLF		;END THE LINE
CHKD2A:	MOVEI	M,BADID5	;GET SHORT MESSAGE
	SKIPE	TYPBAD		;IF NOT TYPED, USE LONG FORM
	 JRST	CHKD3A
CHKID3:	MOVEI	M,BADID4	;POINT AT MSG GIVING OPR OPTIONS
	SETOM	TYPBAD		;WORD TO TELL WE'VE DONE LONG FORM
CHKD3A:	PUSHJ	P,MSGTTY	; & TYPE IT
	OUTPUT	TTY,		;DUMP THE BUFFER
CHKD3B:	PUSHJ	P,R.TTY		;READ FROM THE TTY
	  JRST	CHKID3		;  EOF, ASK AGAIN
	CAIN	CH,"/"		;IF "/" READ AGAIN
	 JRST	CHKD3B
	SETZM	RH.TTY+2	;CLEAR BYTE COUNT TO THROW AWAY INPUT
	CAIN	CH,"I"		;TEST FOR 'I'(IGNORE)
	JRST	CHKID7		;  YES, TREAT ID AS VALID
	CAIN	CH,"Y"		;TEST FOR 'Y'
	JRST	IDRTRY		;  GO RETRY THE TEST
	CAIN	CH,"N"		;TEST FOR "N"
	JRST	CHKID4		;  YES, GO GET A NEW TAPE
	CAIE	CH,"C"		;TEST FOR 'C'
	JRST	CHKID3		;  NO, ASK AGAIN
IDCANC:				;HERE TO THROW AWAY A MOUNTED DECTAPE
	PUSHJ	P,DTRPOS	;GO REPOSITION THE TAPE
	SETOM	NOTDON		;SHOW REQUEST NOT SATISFIED
	JRST	FSQUIT		;GO CANCEL THE REQUEST
CHKID4:	PUSHJ	P,DTRPOS	;GO REPOSITION THE TAPE
CHKID5:	PUSHJ	P,DTXCT		;EXECUTE THE NEXT INSTR W/ CORRECT CHANNEL #
	 RELEAS	.-.,		;RELEASE THE TAPE IF ERROR
	JRST	CPOPJ1		; & RETURN +1
CHKID6:	MOVEI	M,BLNKID	;POINT AT MSG - 'TAPE MOUNTED HAS BLANK ID'
	PUSHJ	P,MSGTTY	; & TYPE IT
	JRST	CHKD2A		;GO GIVE THE OPR HIS OPTIONS

;  HERE IF MAGTAPE CALL
CHKIDM:
IFN FTTLAB,<
	MOVEI	A,.TFSET+.TFPLT		;TAPOP FUNCTION TO SET BLP
	LDB	B,[POINT 4,DTCHAN,12]	;CHANNEL NUMBER
	MOVEI	C,LT.BLP		;CODE FOR BLP
	MOVE	D,[3,,A]		;AC FOR TAPOP.
	TAPOP.	D,			;SET BLP
	  JFCL				;IGNORE ERRORS
	MOVEI	A,.TFTRK		;FUNCTION TO SEE IF 7 OR 9 TRACK
	LDB	B,[POINT 4,DTCHAN,12]	;CHANNEL NUMBER
	MOVE	C,[2,,A]		;AC FOR TAPOP.
	TAPOP.	C,			;DO THE TAPOP.
	  SETZ	C,			;IF IT LOSES, ASSUME 9 TRACK
;**; [171] ALLOW 7-TRACK TAPES
	SKIPGE	A,LABTYP		;[171] LOAD LABEL TYPED UNLESS NOT EXPLICIT
	 MOVEI	A,LT.DEF		;[171] LOAD THE DEFAULT
	CAIE	A,LT.BLP		;[171] BYPASS LABLES?
	 JUMPN	C,CHKD8C		;[171] NO, JUMP IF 7-TRK
	MOVEI	A,LT.DEF		;GET DEFAULT LABEL TYPE
	SKIPGE	LABTYP			;IGNORE IT IF USER TYPED /LABELS
	CAIE	A,LT.BLP		;IS DEFAULT BYPASS?
	CAIN	C,1			;IS THIS A 7 TRACK TAPE?
	SETZM	LABTYP			;YES, LABELS ARE BYPASS ALWAYS
	SKIPN	LABTYP			;WERE BYPASS LABELS REQUESTED?
	JRST	CHKD6A			;YES, DON'T DO THE REWIND STUFF
>;END IFN FTTLAB
	PUSHJ	P,DTXCT		;EXECUTE NEXT INSTR W/ CORRECT CHANNEL #
	 MTAPE	.-.,1		;REWIND THE TAPE
	PUSHJ	P,DTXCT		;EXECUTE NEXT INSTR W/ CORRECT CHANNEL #
	 MTAPE	.-.,0		;WAIT ON REWIND COMPLETION
				;NOTE THAT THESE INSTRUCTIONS REQUIRE A
				;MONITOR 'MTXSER' CHANGE TO ASSURE THAT
				;EVERY 'MTAPE ,1' UUO CAUSES THE TAPE
				;TO BE PHYSICALLY REPOSITIONED. THIS IS
				;NECESSARY FOR THE DEVSTS TO WORK!

IFN FTTLAB,<
CHKD6A:	MOVEI	A,.TFSET+.TFLTP		;TAPOP. FUNCTION TO SET LABEL TYPE
	LDB	B,[POINT 4,DTCHAN,12]	;GET CHANNEL NUMBER
	SKIPGE	C,LABTYP		;LOAD C WITH LABEL TYPE
	MOVEI	C,LT.DEF		;DEFAULT LABELS IF NONE SPECIFIED
	MOVE	D,[3,,A]		;AC FOR TAPOP.
	TAPOP.	D,			;SET DEFAULT LABELS
	  JFCL				;IGNORE ERROR
	MOVE	A,[%SITLP]		;CHECK FOR LABELLER
	GETTAB	A,			;DOES HE HAVE A PID?
	  SETZ	A,			;ASSUME NOT
	SKIPE	LABTYP			;IF BYPASS LABELS, SKIP WL/WE CHECK
	JUMPE	A,CHKID7		;IF NO LABELLER, DO WL/WE CHECKING
	SETOM	IDFLAG			;SAY ID HAS BEEN CHECKED
	JRST	CHKID9			;AND SKIP WL/WE CHECK
>;END IFN FTTLAB

CHKID7:	SETOM	IDFLAG		;SHOW ID CHECKED NOW
	MOVE	C,DEVMOD	;GET DEVCHR BITS
	TLNN	C,DC.MTA	;TEST FOR MAGTAPE
	 JRST	CHKD7A		; NO, DO REGULAR DECTAPE PROCESSING
	MOVE	A,PHYNAM	;TAPE'S NAME
	MTCHR.	A,		;GET WRITE-STATUS 
	 JRST	CHKID9		; NO UUO, SKIP THIS CODE
	MOVEI	B,1B32		;GET BIT FOR MAGTAPE WRITE-LOCK
	JRST	CHKD7B		;GO DO TESTS
CHKD7A:	HLRZ	A,DTCHAN	;GET CHANNEL # IN R.H.
	LSH	A,^D12-^D17	;SHIFT INTO L.O. BITS
	DEVSTS	A,		;GET DEVICE'S CURRENT STATUS
	  JRST	CHKID9		;  NO UUO, SKIP THIS CODE
	MOVEI	B,1B24		;GET BIT FOR DECTAPE WRITE-STATUS
CHKD7B:	TRNE	F,SB.WE		;TEST FOR WRITING ON THE TAPE
	TRC	A,(B)		;  YES, INVERT WRITE-STATUS
	TRNE	A,(B)		;TEST FOR RIGHT WRITE STATUS
	JRST	CHKID9		;  YES, JUMP
	MOVEI	M,ENMSG		;POINT AT 'PLEASE ENABLE'
	TRNN	F,SB.WE		;TEST FOR WRITING ON THE TAPE
	MOVEI	M,WLMSG		;  NO, POINT AT 'PLEASE WRITE-LOCK'
	PUSHJ	P,MSGTTY	;TYPE THE MESSAGE
	MOVE	M,DTDRIV	;GET DTA DRIVE #
	PUSHJ	P,SIXMSO	; & TYPE IT
	PUSHJ	P,COLON		;OUTPUT A COLON, ALSO
	PUSHJ	P,CRLF		;END THE LINE
IFN IGNSTS,<
	MOVEI	M,ENMSG2	;GET SHORT MESSAGE WITH 'I'
>;	END OF IFN IGNSTS
IFE IGNSTS,<
	MOVEI	M,ENMSG3	;GET SHORT MSG W/O 'I'
>;	END OF IFE IGNSTS
	SKIPE	TYPENA		;HAVE I SENT HIM THE SHORT ONE?
	 JRST	CHKD8A		;YES, SKIP LONG
CHKID8:				;HERE TO ASK FOR OPR ACTION
IFN IGNSTS,<
	MOVEI	M,[ASCIZ /Type 'I' to ignore error
/]				;POINT AT MSG
IFN IGNWE,<
	TRNN	F,SB.WE		;TEST FOR WRITE-ENABLE REQ'D
>;	END IFN IGNWE
	PUSHJ	P,MSGTTY	;  NO, GIVE OPR EXTRA CHOICE
>;	END OF	IFN IGNSTS
	MOVEI	M,ENMSG1	;POINT AT OPTIONS MSG
	SETOM	TYPENA		;FLAG: WE'VE DROPPED THE BIG ONE
CHKD8A:	PUSHJ	P,MSGTTY	; & TYPE IT
	OUTPUT	TTY,		;EMPTY THE BUFFER
CHKD8B:	PUSHJ	P,R.TTY		;READ FROM THE TTY
	  JRST	IDRTRY		;  EOF, GO RETRY THE TEST
	CAIN	CH,"/"		;IF "/" READ AGAIN
	 JRST	CHKD8B
	SETZM	RH.TTY+2	;CLEAR BYTE COUNT TO IGNORE INPUT
IFN IGNSTS, <
IFN IGNWE,<
	TRNN	F,SB.WE		;TEST FOR WRITING REQ'D
	CAIE	CH,"I"		;TEST FOR 'I'
	SKIPA			;  SKIP IF WRITING REQ'D OR NOT 'G'
>;	END IFN IGNWE
IFE IGNWE,<
	CAIN	CH,"I"		;TEST FOR IGNORE
>;	END IFE IGNWE
	JRST	CHKID9		;  ELSE IGNORE WRITE-LOCK ERROR
>;	END OF	IFN IGNSTS
	CAIN	CH,"N"		;TEST FOR 'N'
	JRST	CHKID4		;  YES, GO GET A NEW TAPE
	CAIN	CH,"C"		;TEST FOR 'C'
	JRST	IDCANC		;  YES, GO CANCEL THE RQST
	CAIE	CH,"Y"		;TEST FOR 'Y'
	JRST	CHKID8		;  NO, ASK THE OPR AGAIN
	JRST	IDRTRY		;GO RETRY THE TEST

;**; [171] INSERT BEFORE CHKID9
CHKD8C:	MOVEI	M,[ASCIZ /Request requires 9-trk drive--Please try again
/]					;[171]
	AOS	(P)			;[171]
	PJRST	MSGTTY			;[171]
CHKID9:	AOS	(P)		;INCR RETURN ADDRESS
	JRST	CPOPJ1		;RETURN +2 FOR TOTAL SUCCESS
;  SUBROUTINE TO BUILD TAPE ID (IN CMDTAP) FROM USER-SPECIFIED VID
;	TAPE ID IS BUILT ONLY IF THE VID CONSISTS OF
;	ONE TO SIX ALPHAMERICS NOT SURROUNDED BY QUOTES
;
;	CALL:	PUSHJ	P,BLDTID
;		  <FAILURE RETURN>
;		<SUCCESS RETURN>
;

BLDTID:	SETZM	CMDTAP		;CLEAR TAPE ID AREA
	SKIPLE	A,VIDK		;GET # OF CHARACTERS IN THE VID & TEST IT
	CAILE	A,6		;TEST FOR TOO MANY CHARACTERS
	POPJ	P,		;  RETURN IF TOO MANY OR TOO FEW CHARS
	MOVE	B,[POINT 7,VID]	;GET POINTER TO INPUT STRING
	MOVE	C,[POINT 6,CMDTAP] ;GET PTR TO OUTPUT STRING
BLDID1:	ILDB	CH,B		;GET NEXT CHAR OF VID
	CAIL	CH,"0"		;TEST FOR .LT. DIGIT
	CAILE	CH,"Z"		;TEST FOR .GT. LETTER
	POPJ	P,		;  YES, ILLEGAL CHAR, RETURN+0
	CAILE	CH,"9"		;TEST FOR A LETTER
	CAIL	CH,"A"		;TEST FOR A LETTER
	TRCA	CH,40		;  EITHER, CONVERT TO SIXBIT & SKIP
	POPJ	P,		;  NEITHER, ILLEGAL CHAR, RETURN+0
	IDPB	CH,C		;STORE INTO ID
	SOJG	A,BLDID1	;DECR CHAR COUNT & REPEAT
	JRST	CPOPJ1		;RETURN+1 WHEN SUCCESSFUL
DTDER1:				;HERE IF DIRECTORY READ ERROR AFTER FILE CMD
	MOVSI	N,(Z DTA,)	;GET DECTAPE CHANNEL #
	MOVEM	N,DTCHAN	;STORE FOR LATER
DTDERR:				;HERE IF ERROR READING DTA DIRECTORY
	PUSHJ	P,DTXCT		;EXECUTE NEXT INSTR W/ CORRECT CHANNEL #
	GETSTS	DTA,N		;GET DTA ERROR STATUS
	TRZ	N,117		;CLEAR MODE BITS
	PUSHJ	P,DTXCT		;EXECUTE NEXT INSTR W/CORRECT CHANNEL #
IFE UNLOSW,<	MTAPE	DTA,1>	;REWIND THE DECTAPE
IFN UNLOSW,<	MTAPE	DTA,11>	;UNLOAD THE DECTAPE
	MOVEI	M,[ASCIZ /?DTA directory read error (Status = /]
	PUSHJ	P,MSGTTY	;TYPE THE MESSAGE
	PUSHJ	P,OCTPRT	;TYPE THE STATUS
	MOVEI	M,[ASCIZ /) - Try again
/]				;POINT AT REST OF THE MSG
	PUSHJ	P,MSGTTY	; & TYPE IT, TOO
IFN FILESW,<
	TLNN	F,L.TAPE	;TEST FOR INITIAL DECTAPE CHECKING
>;	END IFN FILESW
	JRST	CHKID5		;  YES, GO TAKE 'BAD ID' ERROR RETURN
IFN FILESW,<
	PUSHJ	P,RPARSE	;RE-SCAN THE CMD FILE
	TLZ	F,L.TAPE	;CLEAR FLAG BIT
	JRST	RQTAP4		;GO ASK THE OPR FOR THE TAPE AGAIN
>;	END IFN FILESW
DTRPOS:				;HERE TO REPOSITION THE TAPE
IFE UNLOSW, <	MOVEI	E,1>	;GET CODE TO REWIND THE TAPE
IFN UNLOSW, <	MOVEI	E,11>	;GET CODE TO UNLOAD THE TAPE
	TLO	E,(MTAPE .-.,)	;SUPPLY 'MTAPE' OPCODE IN L.H.
	JRST	DTXCT1		;GO SUPPLY CHANNEL #

DTXCT:				;HERE TO EXECUTE NEXT INST W/CORRECT CHAN #
	MOVE	E,@(P)		;GET NEXT INSTRUCTION (AFTER PUSHJ)
	AOS	(P)		;INCR RETURN ADDRESS
DTXCT1:	TLZ	E,(Z 17,)	;CLEAR CHANNEL # IN AC
	IOR	E,DTCHAN	;SUPPLY CHANNEL # FROM STORAGE
	XCT	E		;EXECUTE THE UUO IN AC NOW
	  POPJ	P,		;  +0, RETURN +0
	JRST	CPOPJ1		;  +1, RETURN +1
;SUBROUTINE TO GET OPERATOR ARGUMENT
;CALL	M=0 OR ADDRESS OF HELP MESSAGE
;RET+1	A= 6 BIT ARGUMENT OR 0 IF NONE
;	N=4 IF ERROR
;	  3 IF GARBAGE
;	  2 IF /HELP TYPED
;	  1 IF NOT LONE C.R. (SWITCHES?)
;	   0 IF LONE CAR.RET.
;	  OTHERWISE A SIXBIT THING

IFN FTTLAB,<
OPRAVR:	SETOM	AVRFLG	;[144] SET AVR MODE
>;[144] END FTTLAB
OPRARG:	MOVEM	M,OPRAH	;SAVE HELP MSG
	PUSH	P,IO	;AND CALLERS DEVICE ADDRESS
	MOVEI	IO,R.TTY
	SETZB	N,A		;RETURN 0 IF LONE C.R.
	PUSH	P,A
	PUSHJ	P,SSST
IFN FTTLAB,<SETZM	AVRFLG>	;[144] CLEAR AVR FLAG
	CAIE	CH,33
	CAIG	CH,14
	JRST	OPRAR6
	MOVEI	N,1		;NOT C.R. -- -1 IIF NOTHING ELSE
	MOVEI	D,OPSWIT	;CK FOR SWITCHES
	PUSHJ	P,SWITCH
	  JRST	OPRAR4		;ERROR RETURN -4
	JUMPN	A,OPRAR3	;SPECIAL SWITCH LIKE /HELP
	PUSHJ	P,SIXIN		;GET ARGUMENT
	MOVEM	A,(P)
	MOVEI	D,OPSWIT	;CHECK SWITCHES AGAIN
	PUSHJ	P,SWITCH
	  JRST	OPRAR4
	JUMPN	A,OPRAR3
	PUSHJ	P,SST		;CHECK FOR REMAINING GARBAGE
	CAIE	CH,33
	CAIG	CH,14
	JRST	OPRAR6

	MOVEI	N,3		;RETURN -3 FOR GARBAGE
	JRST	OPRAR5
OPRAR3:	MOVE	N,A
	JRST	OPRAR5
OPRAR4:	MOVEI	N,4		;RETURN -4 FOR ERROR
OPRAR5:	SETZM	RH.TTY+2	;ZAP REMAINING INPUT
OPRAR6:	POP	P,A
	POP	P,IO
	TLZN	F,L.OCAN	;/CANCEL /DEFER ETC
	POPJ	P,		;NO
	TRNN	F,OB.OPC	;TEST FOR OPR COMMAND
	SKIPE	CMDNAM		;TEST FOR RQST DEFERED
	SETOM	NOTDON		;  OPR CMD OR NOT DEFERRED, THEN SHOW IT CANCELED
	JRST	FSQUIT		;YES-SHUT IT DOWN


U(OPRAH)
IFN FTTLAB,<U(AVRFLG)>		;[144] AVR FLAG
SUBTTL	MOUNT COMMAND PROCESSING - FILE STRUCTURES
;HERE IF UNDEF.DEVICE NAME (ASSUME F.S. TO BE MOUNTED)

MOFS0:	TRNE	F,SB.NOS	;SUPPRESS STRLST.SYS SEARCH?
	JRST	STR301		;YES

;LOOKUP SYS:STRLST.SYS ENTRY FOR THIS F/S

	MOVE	A,[PHOPEN,,14]	;BINARY MODE		
	MOVE	B,[STLSTX]				
	MOVEI	C,RH.USR				
	OPEN	USR,A					
	  JRST	ERR211		;IF SYS DOES NOT EXIST

	MOVEI	A,B.USR		;SET UP 1 BUFFER
	MOVEM	A,.JBFF
	INBUF	USR,1

	MOVE	A,[SIXBIT .STRLST.] ;LOOKUP STRLST.SYS
	MOVSI	B,(SIXBIT .SYS.)
	SETZM	C
	MOVE	D,[STLPPX]
	LOOKUP	USR,A
	  JRST	STR212		;ERROR 'NO STRLST.SYS'

	PUSHJ	P,R.USR		;READ FORMAT VERSION NUMBER
	  JRST	STR213
	HLRZS	WD		;LH=NUMBER
	CAIE	WD,STRFOR
	JRST	STR215		;ERROR 'WRONG FORMAT VERSION'

STR1:	PUSHJ	P,R.USR		;GET NEXT WORD IN WD
	  SKIPA
	JRST	STR2
	STATZ	USR,20000	;WHATS THE PROBLEM?
	JRST	STR216		;EOF--USER/OPER FAULT
	JRST	STR213		;IO ERROR--SYSTEM FAULT

STR2:	JUMPE	WD,STR1		;IGNORE 0 LENGTH BLOCKS
	MOVEI	A,-1(WD)	;A=NUMBER OF WORDS THAT FOLLOW
	PUSHJ	P,R.USR		;READ FILE STRUCTURE NAME
	  JRST	STR213	
	CAMN	WD,FSNAME	;SEE IF THIS IS THE RIGHT ENTRY
	JRST	STR3		;YES!

STR21:	PUSHJ	P,R.USR		;SKIP THE REST OF THIS ENTRY
	  JRST	STR216
	SOJG	A,STR21

	JRST	STR1
;FOUND STRLST.SYS ENTRY  -- READ IT

STR3:	SUBI	A,3		;COMPUTE NUM. OF PACKS
	LSH	A,-1
	MOVEM	A,FSUNM
	MOVNS	A		;FOR AOBJ POINTERS
	HRLZM	A,FSUAOB

	PUSHJ	P,R.USR		;GET PROJ,PROG OF OWNER
	  JRST	STR213
	MOVEM	WD,OWNPPN

	PUSHJ	P,R.USR		;SKIP OWNER'S NAME
	  JRST	STR216
	PUSHJ	P,R.USR
	  JRST	STR216

	MOVE	D,FSUAOB	;D=AOBJ PTR FOR # OF PACKS
STR4:	PUSHJ	P,R.USR		;GET PACK ID
	  JRST	STR213
	MOVEM	WD,UNITID(D)	;   AND STORE IN TABLE
	PUSHJ	P,R.USR		;GET CLASS, ETC.
	  JRST	STR213
	MOVEM	WD,UNITCL(D)	;   AND STORE
	AOBJN	D,STR4		;LOOP FOR ALL PACKS

	RELEASE	USR,		;GET RID OF SYS
	JRST	STR40

;VARIOUS ERRORS WHILE SEARCHING STRLST.SYS

STR212:	PUSHJ	P,MSG219	;NO STRLST.SYS
	JRST	STR300
STR213:	PUSHJ	P,MSG220	;I/O ERROR
	JRST	STR300
STR215:	PUSHJ	P,MSG221	;WRONG FORMAT VERSION
	JRST	STR300
STR216:	PUSHJ	P,MSG222	;NOT IN STRLST.SYS
STR300:	RELEAS	USR,
;HERE IF SUPPRESSED OR FAILED STRLST.SYS SEARCH

STR301:	SETOM	OWNPPN		;DEFAULT F.S. OWNER TO 'ANYONE'
	SKIPE	A,FSUUNM		;USER TYPE A DRIVE LIST?
	JRST	STR302		;  YES
	MOVSI	A,'DP '		;  NO-DEFAULT 1 'DP' DRIVE
;**; [164] CHANGE AT STR301+4	CLRH	5-MAR-79
	MOVEM	A,UDRIVE	;[164] STORE IT
;[164]	MOVEM	UDRIVE
	MOVEI	A,1
STR302:	MOVEM	A,FSUNM
	MOVNS	A
	HRLZM	A,FSUAOB
	JRST	STR41

;CK. NUM. DRIVES USER TYPED

STR40:	MOVE	N,FSUNM		;TOO MANY DRIVES REQUESTED?
	CAML	N,FSUUNM
	JRST	STR41		;NO
	TRO	F,OB.PRO	;YES-REMEMBER TO ASK 'PROCEED'
	PUSHJ	P,MSG212

;IF OPR.COMMAND, /SING IS ILLEGAL

STR41:	TRNE	F,OB.OPC	;OPR.COMMAND?
	TRZN	F,SB.S		;AND /SINGLE?
	JRST	STR42		;NO
	TRO	F,OB.PRO	;YES-TELL OPR NO
	PUSHJ	P,MSG214

;IF /SING OR /UWLOCK SWITCH, CHECK PROJ. #

STR42:	TRNN	F,SB.S!SB.UWL	;/SING OR /UWLOCK?
	JRST	STR5		;NO
	MOVE	A,FSPPN		;IF USER IS
	CAMN	A,FS1PPN	;    1,2
	JRST	STR5		;    ITS OK
	HLRZ	A,OWNPPN	;YES-OWNER PROJ.=USER PROJ.?
	HLRZ	B,FSPPN
	CAIE	A,-1		;  OR OWNER=-1?
	CAMN	A,B
	JRST	STR5		;YES-ITS OK THEN
	TRZ	F,SB.S!SB.UWL	;NO--CANCEL SWITCHES
	TRO	F,OB.PRO	;   REMEMBER TO 'PROCEED?'
	PUSHJ	P,MSG211	;   AND WRITE MESSAGE
;CK USER DRIVE REQUESTS

STR5:	MOVE	D,FSUAOB	;D=AOBJ PTR FOR UNITS

	;HERE FOR EACH UNIT

STR61:	MOVE	A,UDRIVE(D)	;DID USER SPECIFY DRIVE?
	JUMPE	A,STR66		;NO
	PUSHJ	P,DSKUUO	;YES--DO A DSKCHR
	  JRST	STR62		;NOT EVEN A DISK ! !

	LDB	B,DCHCOD	;WAS USER NAME  A UNIT OR CONTROLER?
	CAIL	B,3
	JRST	STR63		;YES
STR62:	PUSHJ	P,MSG218	;NO--TELL USER
	JRST	STR65

STR63:	LDB	C,DCHKTP	;*** CK CONTROLLER TYPE
	TRNE	F,SB.NOS	;WAS /NOSEARCH SPECIFIED?
	 DPB	C,SKTYP		;YES, IGNORE KON TYPE & SAVE FOR LATER
	LDB	E,SKTYP		;
	CAME	C,E		;***
	JRST	STR64		;*** COMPLAIN

	CAIE	B,6		;DONT CK UNIT TYPE UNLESS ITS A UNIT NAME
	JRST	STR66
	LDB	B,DCHUTP	;IS UNIT TYPE OK?
	TRNE	F,SB.NOS	;WAS /NOSEARCH SPECIFIED?
	 DPB	B,STYPE		;YES, IGNORE UNIT TYPE & SAVE FOR LATER
	LDB	C,STYPE
	CAMN	B,C
	JRST	STR66		;YES
STR64:	PUSHJ	P,MSG217	;NO--TELL USER
STR65:	TRO	F,OB.PRO	;ASK OPERATOR'S ADVICE
	SETZM	UDRIVE(D)	;AND FORGET LOOSING DRIVE REQUEST

STR66:	AOBJN	D,STR61		;USER DRIVE PASSES--CK NEXT ONE

;SEE IF F/S ALREADY EXISTS

MOFS1:	MOVE	A,FSNAME	;DSKCHR ON FSNAME
	PUSHJ	P,DSKUUO
	  PUSHJ	P,DEFIN		;NOT YET--GO DEFINE IT
	LDB	B,DCHCOD
	CAIE	B,2		;IS THIS A F/S NAME?
	JRST	ERR300		;NO
;FSNAME ALREADY DEFINED
;	CK USER ACCESS TO IT

	TLNE	A,.UPNNA	;F/S LOCKED?
	JRST	ERR221		;YES

;	IF F/S  SINGLE FOR USER, SKIP SOME TESTS

	TRO	F,OB.RDF	;PRESUME HE CAN CHANGE STATUS
	HRRZ	B,DSKCHA+.UNJOB	;B=SINGLE USER JOB # (IF ANY)
	CAMN	B,FSJOB		;STRJOB=USER JOB #?
	JRST	DSKCK4		;YES-THE USER IS ONLY USER OF F/S
	SKIPLE	DSKCHA+.UNJOB
	JRST	ERR222		;NO--IF F/S  IS S.A.  THIS REQUEST LOOSES
	TLNN	A,.UPZMT	;IF MOUNT-COUNT NOT 0
	TRZ	F,OB.RDF	;   DONT CHANGE STATUS

;CHECK USER SWITCHES AGAINST CURRENT STATUS OF F/S

;**; [204] INSERT AT DSKCK2 - 5 1/2	CLRH	20-FEB-80
	TRNN	F,SB.S		;[204] /SING ?
	 JRST	DSKCK2		;[204] NO
	MOVEI	N,B		;[204] CHECK FOR /SING STRUCTURE IN
	SETZM	B		;[204] ... SYSTEM
	MOVE	C,SYSPPN	;[204] ... SEARCH
	MOVE	D,FSNAME	;[204] ... LIST
	GOBSTR	N,		;[204] IN IT?
	 JRST	DSKCK5		;[204] NO
	PUSHJ	P,MSG223	;[204] SAY OTHER USERS, NO /SING
	TRZ	F,SB.S		;[204] TURN OFF /SING
	TRO	F,OB.PRO	;[204] ASK "PROCEED?"
	JRST	DSKCK2		;[204] SKIP OVER OTHER /SING CHECKS
DSKCK5:	MOVE	A,FSNAME	;[204] IS /SING STRUCTURE THE QUEUE STRUCTURE?
	CAME	A,CMDSTR	;[204] CHECK BY CHECKING AGAINST CMDSTR
	 JRST	DSKCK2		;[204] NO, SO OK SO FAR
	PUSHJ	P,MSG223	;[204] YES, TELL OPR OTHER USERS
	TRZ	F,SB.S		;[204] TURN OFF /SING
	TRO	OB.PRO		;[204] REMEMBER TO ASK "PROCEED?"
	JRST	DSKCK2		;[204] SKIP OVER OTHER /SING CHECKS
	TLNN	A,.UPZMT	;/SING WHEN MOUNT COUNT NOT 0?
	TRZN	F,SB.S
	JRST	DSKCK2		;NO
	PUSHJ	P,MSG223	;YES-CANCEL SWITCH AND TYPE MESSAGE
	TRO	F,OB.PRO

DSKCK2:	TLNN	A,.UPZMT	;/UWLOCK WHEN MOUNT-COUNT NOT 0?
	TRNN	F,SB.UWL
	JRST	DSKCK3		;NO
	TLNE	A,.UPAWL	;YES-IS IT ALREADY W.L.'D FOR ALL?
	JRST	DSKCK3		;YES-DONT GRIPE THEN
	TRZ	F,SB.UWL	;NO--CANCEL SWITCH AND TYPE MESSAGE
	TRO	F,OB.PRO
	PUSHJ	P,MSG223

DSKCK3:	TLNE	A,.UPAWL	;IS F/S W.L.'D FOR ALL
	TRNE	F,SB.UWL	;   BUT USER DIDNT TYPE /UWL?
	JRST	DSKCK4		;NO
	HLRZ	C,OWNPPN	;YES-IS HE ALLOWED TO TURN IT OFF?
	HLRZ	D,FSPPN		;   I.E. HIS PROJ.=OWNERS PROJ.?
	CAIE	C,-1		;   OR OWNER = 'ANYONE'?
	CAMN	C,D
	JRST	DSKCK4		;YES-ASSUME HE KNOWS WHAT HES DOING
	PUSHJ	P,MSG224	;NO--TELL HIM ITS W.L.'D FOR ALL
	TRON	F,SB.UWL!SB.WL	;IF HE DIDNT /WLOCK
	PUSHJ	P,MSG225	;   DO IT FOR HIM & TELL HIM YOU DID
;CHECK ACTUAL DRIVES AGAINST USER REQUEST & MAKE SURE UNITS ARE READY

DSKCK4:	PUSHJ	P,GETUNI	;GET F/S PHYSICAL UNITS
	  PUSHJ	P,NEVMSJ

;SHOULD WE CONSULT OPERATOR BEFORE PROCEEDING?

	TRZE	F,OB.PRO
	PUSHJ	P,OPER		;YES--DO SO

;	MAKE SURE UNITS ARE READY

	PUSHJ	P,WATUNI

;RESET THE F/S STATUS BITS

	TRNN	F,OB.RDF	;ALLOWED TO CHANGE STATUS?
	JRST	SLCK		;NO
	PUSHJ	P,FSRDF		;YES--DO IT
;CHECK FOR F/S IN JOB'S SEARCH LIST

SLCK:	TRNE	F,OB.OPC	;OPR.COMMAND?
	JRST	MOFIN		;YES-SKIP IT

	MOVE	C,FSNAME
	MOVE	D,FSPPN
	TRON	F,OB.UFD	;GET UFD INTERLOCK
	PUSHJ	P,UFDLOK	;  IF DONT ALREADY HAVE IT
	PUSHJ	P,MAKSL
	TLNE	F,L.PAS		;TEST FOR /PASSIVE
	 JRST	ACTOVR		;  YES, JUMP TO MAKE PASSIVE
	SKIPE	C		;MAKE FENCE (IF ANY) THE END OF LIST
	 MOVE	B,C
ACTOVR:				;HERE TO PUT STR IN PASSIVE S/L
	JUMPE	A,SLCK2		;JUMP IF NOT IN SEARCH-LIST
	CAMG	A,C		;WHICH SIDE OF FENCE IS F/S?
	JRST	SLCK3		;ACTIVE
SLCK2:	MOVE	A,B		;PUT F/S AT END OF LIST
	MOVEI	B,3(A)		;   AND BUMP END PAST IT
SLCK3:	MOVE	C,FSNAME	;F/S NAME TO ARG.LIST
	MOVEM	C,(A)
	SETZB	C,1(A)		;***PPN ENTRY = 0 FOR NOW
	TRNE	F,SB.WL		;WRITE-LOCK?
	TLO	C,DSLWLK	;YES-SET BIT
	TLNE	F,L.NOC		;TEST FOR /NOCREATE
	TLO	C,DSLNOC	;  YES, SET THE APPROPRIATE BIT
	MOVEM	C,2(A)		;STATUS BITS TO ARG.LIST

	SUBI	B,FSDSLA	;COMPUTE ARG.LIST LENGTH
	HRLZM	B,FSDSLA	;   AND SAVE IN FSDSLA FOR SLADD

;MAKE AND CHECK USER UFD ON THIS F/S IF NECCESSARY

	MOVE	A,FSPPN
	MOVE	B,FSNAME
	PUSHJ	P,MAKUFD
	  JUMPN	A,FSQUIT	;IF ITS JUST NO QUOTA.SYS
				;  GO AHEAD AND MOUNT
;ADD F/S TO END OF USER'S ACTIVE SEARCH LIST

	MOVEI	A,.FSDSL	;SET FUNCTION CODE
	EXCH	A,FSDSLA	;AND BUILD UUO AC
	HRRI	A,FSDSLA
	STRUUO	A,
	  JRST	ERR241		;UUO FAILURE

;HERE WHEN ALL HAS BEEN DONE THAT CAN BE DONE FOR THIS MOUNT

MOFIN:

	JRST	FSQUIT
;SUBROUTINE TO DEFINE A NEW F/S TO THE SYSTEM
;CALL	FSNAME=F/S NAME
;	UDRIVE=LIST OF USER DRIVE REQUESTS
;	UNITID=PACK I.D.'S
;	UNITCL=PACK CLASS AND TYPE (FROM STRLST.SYS)
;	FSUNM=NUM. OF UNITS
;	FSUAOB=AOBJ PTR FOR UNIT TABLES (XWD -#UNITS,0)
;RET+0	PDRIVE=PHYSICAL DRIVE NAMES
;	A=DSKCHR UUO AC
;	REST OF DSKCHR UUO VALUES IN DSKCHA...

DEFIN:

;TRY TO SATISFY USER DRIVE REQUESTS

;	FIND MOST SPECIFIC USER REQUESTS FIRST

	SETZ	B,		;USE B FOR MASK
UPICK2:	LSH	B,6		;EXPAND MASK
	ORI	B,77
	MOVE	D,FSUAOB	;D=AOBJ PTR TO DRIVE TABLES
UPICK3:	SKIPE	PDRIVE(D)	;HAVE WE ALREADY SELECTED THIS ONE?
	JRST	UPICK4		;YES
	SKIPL	B		;LAST TIME THRU CATCH 0 ENTRIES
	TDNE	B,UDRIVE(D)	;NO--IS IT SPECIFIC ENOUGH?
	PUSHJ	P,MPICK		;YES-GO FIND A DRIVE FOR IT
UPICK4:	AOBJN	D,UPICK3	;JUMP IF MORE DRIVES TO DO FOR THIS MASK
	JUMPGE	B,UPICK2	;JUMP IF MORE MASKS TO DO

;IF ANY PROBLEMS--ASK OPERATOR WHAT TO DO

	TRZE	F,OB.PRO
UPICK5:				;HERE IF NO FREE DRIVES
	PUSHJ	P,OPER
	SETZM	DSKCHA		;ASK FOR 1ST FREE UNIT
	MOVE	D,FSUAOB	;GET PTR TO 1ST DESIRED DEVICE
	PUSHJ	P,NXDRIV	;GET A POSSIBLE DRIVE
	  SKIPA			;  NONE, SKIP
	JRST	UPICK6		;SOMETHING, CONTINUE ON
	PUSHJ	P,MSG251	;SAY 'NOT ENOUGH DRIVE'
	PUSHJ	P,UNITYP	;TELL OPR WHAT KIND OF DRIVE
	JRST	UPICK5		;ASK 'PROCEED?' AGAIN
UPICK6:				;HERE IF DRIVES AVAILABLE

;TELL OPERATOR TO MOUNT UNITS & READ HIS DRIVE SELECTIONS

	PUSHJ	P,OPICK

;WAIT FOR UNITS TO BECOME READY

	PUSHJ	P,WATUNI
;HERE WHEN UNITS ARE FINALLY MOUNTED AND READY
;   FSNAME=F.S. NAME, FSUNM=NUM. OF LOG.UNITS
;   PDRIVE=LIST OF PHYS.DRIVE.NAMES, UNITID=LIST OF PACK ID'S

	MOVEI	A,DSKTRY	;INIT FSTRY
	MOVEM	A,FSTRY

;PUT 1ST HOME BLOCK (LOG.UNIT 0) INTO 'HOME'.

	SETZM	FSLUN		;LOG.UNIT=0
	PUSHJ	P,GETHOM	;READ HOME BLK
	  JRST	FSQUIT		;CANT--QUIT

;FILL IN STR PARAMETER BLOCK FOR STRUUO(.FSDEF)
;   STUFF FROM HOME BLOCK (AND A FEW OTHER PLACES)
;   ALSO SETS UP FSCNP & FSCLP POINTERS TO RIB-POINTERS

	SETZM	FSASTR+SS.JOB	;STRJOB=0
	MOVE	B,[XWD -FSXSTL,FSXSTR]
	MOVEI	C,FSASTR
	PUSHJ	P,MOVALU
	MOVEI	A,A		;MAKE FSCNP & FSCLP ADDRESS A
	HRRM	A,FSCNP
	HRRM	A,FSCLP

;CHECK HOME BLOCK NAME

	MOVE	N,HOME+HOMSNM
	CAMN	N,FSNAME
;**; [163] CHANGE AT FSDF5 - 3	CLRH	23-FEB-79
	JRST	FSDF7		;[163] CHECK FOR CORRECT UNIT ORDER
;[163]	JRST	FSDF5
	PUSHJ	P,MSG276	;DIFFERENT
	PUSHJ	P,OPER		;ASK OPR IF THATS OK
;**; [163] INSERT BEFORE FSDF5	CLRH	23-FEB-79
	JRST	FSDF5		;[163] IF OK, BELIEVE OPERATOR

;[163] HERE TO VERIFY THAT STRUCTURE IS MOUNTED AS OPERATOR SAID

FSDF7:	MOVE	B,FSUNM		;[163] CHECK EACH UNIT'S HOME BLOCK
	SOJE	B,FSDF5		;[163] DO NOT BOTHER IF NOT MULTIPACK
FSDF9:	MOVEM	B,FSLUN		;[163] SAVE THE UNIT NUMBER
	PUSHJ	P,GETHOM	;[163] GET THIS ONE'S HOME BLOCK
	 JRST	FSQUIT		;[163] CANNOT READ IT -- IN TROUBLE
	MOVE	B,FSLUN		;[163] RESTORE OUR UNIT COUNTER
	MOVE	A,HOME+HOMSNM	;[163] CHECK THE STRUCTURE NAME
	CAMN	A,FSNAME	;[163]  AGAINST USER'S STRUCTURE NAME
	 JRST	FSDF8		;[163] SAME
	PUSHJ	P,MSGFD1	;[163] NO THE SAME STRUCTURE
	JRST	FSQUIT		;[163] NO POINT IN TRYING TO CONTINUE
FSDF8:	MOVE	A,HOME+HOMLUN	;[163] GET LOGICAL UNIT NUMBER
	MOVEM	A,UNICHK(B)	;[163] SAVE IT
	SOJGE	B,FSDF9		;[163] GO BACK FOR MORE

;[163] NOW WE HAVE THE LOGICAL UNIT NUMBERS OF THE UNITS IN UNICHK IN THE
;[163] SAME ORDER AS THE DRIVES ARE IN PDRIVE.  IF THESE NUMBERS START WITH
;[163] ZERO, INCREASE BY ONE, AND END WITH FSUNM-1, THE UNITS OF THE STRUCTURE
;[163] ARE WHERE THE OPERATOR SAID THEY WERE.  OTHERWISE, PUT THEM WHERE THEY
;[163] BELONG IN PDRIVE, UNITID, AND UNITCL, AND TELL THE OPERATOR.

	SETOB	D,A		;[163] D: FLAG, ZERO IF WER CHANGE THE ORDER
FSDF15:	AOS	A		;[163] COMPARE FROM, FOR OUTER LOOP
	CAML	A,FSUNM		;[163] CHECK OUTER LOOP BOUNDS
	 JRST	FSDF11		;[163] DONE WITH LOOPS
	MOVE	B,A		;[163] COMPARE TO, FOR INNER LOOP
FSDF16:	AOS	B		;[163] INCREMENT COMPARE TO
	CAML	B,FSUNM		;[163] CHECKS INNER LOOP BOUNDS
	 JRST	FSDF15		;[163] DONE, DO OUTER LOOP
	MOVE	C,UNICHK(A)	;[163] GET LOGICAL UNIT NUMBER
	CAMGE	C,UNICHK(B)	;[163] COMPARE
	 JRST	FSDF16		;[163] OK, CONTINUE INNER LOOP
	SETZ	D,		;[163] NOT OK, SET FLAG THAT ORDER CHANGED
	EXCH	C,PDRIVE(A)	;[163] EXCHANGE PDRIVE ENTRIES
	EXCH	C,PDRIVE(B)	;[163] ...
	EXCH	C,PDRIVE(A)	;[163] ...
	EXCH	C,UNITID(A)	;[163] EXCHANGE UNITID ENTRIES
	EXCH	C,UNITID(B)	;[163] ...
	EXCH	C,UNITID(A)	;[163] ...
	EXCH	C,UNICHK(A)	;[163] EXCHANGE UNITCHK ENTRIES
	EXCH	C,UNICHK(B)	;[163] ...
	EXCH	C,UNICHK(A)	;[163] ...
	EXCH	C,UNITCL(A)	;[163] EXCHANGE UNITCL ENTRIES
	EXCH	C,UNITCL(B)	;[163] ...
	EXCH	C,UNITCL(A)	;[163] ...
	JRST	FSDF16		;[163] CONTINUE INNER LOOP

;[163] NOW WE HAVE SORTED THE DRIVES.  IF ANYTHING IS MISSING OR DUPLICATED,
;[163] GIVE UP AND TELL THE OPERATOR.

FSDF11:	SETZ	A,		;[163] COUNTER
FSDF17:	CAML	A,FSUNM		;[163] CHECK
	 JRST	FSDF13		;[163] DONE ALL UNITS
	CAMN	A,UNICHK(A)	;[163] CHECK ONE UNIT
	 AOJA	A,FSDF17	;[163] LOOP IF OK
	PUSHJ	P,MSGFD2	;[163] MISSING OR DUPLICATE NUMBER
	JRST	FSQUIT		;[163] GIVE UP

;[163] CHECK FLAG TO SEE IF WE HAVE ANYTHING TO TELL THE OPERATOR.

FSDF13:	SKIPE	D		;[163] CHECK FLAG
	 JRST	FSDF14		;[163] NO TROUBLE, GO READ FIRST HOME BLOCK
	PUSHJ	P,MSGFD3	;[163] CHANGED THE ORDER, TELL OPERATOR
	PUSHJ	P,OPER		;[163] ASK OPERATOR IF THAT IS OK

FSDF14:	SETZM	FSLUN		;[163] SET TO LOGICAL UNIT ZERO
	PUSHJ	P,GETHOM	;[163] AND GET ITS HOME BLOCK BACK IN CORE
	 JRST	FSQUIT		;[163] THIS WORKED THE FIRST TIME, SO TROUBLE
	JRST	FSDF5		;[163] GO ON TO COMPUTE FOR STRUUO

;[163] HANDLE POSSIBLE MULTIPACK STRUCTURE ERRORS.

;[163] SOME PACK WAS NOT A MEMBER OF THE RIGHT STRUCTURE.

MSGFD1:	MOVEI	M,[ASCIZ /?Drive /]	;[163] DRIVE
	PUSHJ	P,MSGTTY	;[163] ...
	MOVE	M,PDRIVE(B)	;[163] <NAME>
	PUSHJ	P,SIXMSG	;[163] ...
	MOVEI	M,[ASCIZ / has incorrect structure /]	;[163]
	PUSHJ	P,MSGTTY	;[163] ...
	MOVE	M,HOME+HOMSNM	;[163] <NAME>
	PUSHJ	P,SIXMSG	;[163] ...
	PJRST	CRLF		;[163] <CR><LF>

;[163] A UNIT IS DUPLICATED OR MISSING.

MSGFD2:	MOVEI	M,[ASCIZ /?Structure missing or has two of unit # /]	;[163]
	MOVE	N,A		;[163] DECIMAL NUMBER
	PJRST	MSG998		;[163] AND <CR><LF>

;[163] WE CHANGED THE ORDER BUT CAN PROCEED IF OPERATOR SAYS IT IS OK.

MSGFD3:	MOVEI	M,[ASCIZ /Units are ordered: /]	;[163]
	PUSHJ	P,MSGTTY	;[163] ...
	SETO	D,		;[163] COUNT
MSGFD4:	AOS	D		;[163] UP THE DRIVE COUNT
	CAMLE	D,FSUNM		;[163] CHECK FOR END OF LIST
	 PJRST	CRLF		;[163] END OF LIST, WRITE <CR><LF>
	MOVE	M,PDRIVE(D)	;[163] GET DRIVE NAME
	PUSHJ	P,SIXMSG	;[163] AND PRINT IT
	JRST	MSGFD4		;[163] LOOP

;USE DSKCHR TO COMPUTE STRBPU, STRSIZ, & STRHGH

FSDF5:	MOVE	B,FSUNM	;COUNT NO. OF UNITS IN B
	SETZB	C,D		;C FOR BIGGEST UNIT, D FOR SUM
FSDF6:	MOVE	A,PDRIVE-1(B)	;GET PHYS UNIT NAME
	PUSHJ	P,DSKUUO	;DO DSKCHR FOR IT
	  JSP	A,NEVERR	;IMPOSSIBLE ERROR RETURN
	ADD	D,DSKCHA+.UNBPU	;ACCUMULATE TOTAL BLOCKS
	CAMGE	C,DSKCHA+.UNBPU	;CK. FOR LARGEST UNIT
	MOVE	C,DSKCHA+.UNBPU
	SOJG	B,FSDF6		;LOOP FOR ALL UNITS

	MOVEM	C,FSASTR+SS.BPU	;PUT VALUES IN STR PARAM.BLOCK
	MOVEM	D,FSASTR+SS.SIZ
	MOVEM	C,FSBPU		;GETFSB NEEDS THIS
	IMUL	C,FSUNM		;COMPUTE STRHGH
	SOS	C
	MOVEM	C,FSASTR+SS.HGH

;SET STR1PT PARAMETER

	SETOM	FSASTR+SS.1PT	;ASSUME ONLY 1 PTR.

MFDRIB==SATRIB		;USE SATRIB BUFFER

	MOVE	A,[IOWD 200,MFDRIB];GET MFD RIB
	MOVE	B,HOME+HOMMFD
	PUSHJ	P,GETFSB
	  JRST	ERR276		;'ERROR WHILE GETTING MFD-RIB'
	MOVE	A,RIBFIR+MFDRIB	;GET REL.ADDR. OF 1ST PTR.
	SKIPE	A,MFDRIB+2(A)	;SKIP IF 2ND PTR.=0 (ONLY 1 PTR.)
	SETZM	FSASTR+SS.1PT	;CLEAR 'ONLY 1 PTR.' BIT
;PUT SAT-RIB IN 'SATRIB'

	MOVE	A,[IOWD 200,SATRIB]
	MOVE	B,HOME+HOMSAT	;LOG.BLK.NO. IS IN HOME BLOCK
	PUSHJ	P,GETFSB
	  JRST	ERR270		;ERROR 'WHILE GETTING SAT-RIB'
	MOVS	A,SATRIB+RIBNAM	;IS IT SAT.SYS?
	HLRZ	B,SATRIB+RIBEXT
	CAIN	A,(SIXBIT /SAT/)
	CAIE	B,(SIXBIT /SYS/)
	JRST	ERR271		;NO--TYPE 'NAME OR CODE FAILURE...'

;INITIALIZATION FOR LOOKING AT UNITS

	MOVE	A,SATRIB+RIBFIR	;MAKE AOBJ PTR. INTO SAT-RIB
	ADDI	A,SATRIB
	MOVE	B,(A)		;MOVE 1ST PTR. (UNIT PTR.) DOWN OVER
	MOVEM	B,1(A)		;   2ND PTR.(RIB) SO UNIT CK. BELOW WILL WORK
	MOVEM	A,FSATPT	;AND STORE PTR. IN FSATPT

	SETZM	FSASTR+SS.TAL	;CLEAR THESE SO CAN ACCUM. SUMS
	SETZM	FSASTR+SS.RES
	PUSHJ	P,FSBITS	;SETUP UNIDES BITS

;HERE FOR EACH UNIT TO FILL ITS PARAMETER BLOCK
;ITS HOME BLOCK IS ALREADY IN 'HOME AND FSLUN=ITS LOG.UNIT.NO.

FSDF10:

	MOVE	A,FSLUN

;GET ADDRESS OF THIS UNIT PARAMETER BLOCK (SAVE IN FSUPA)

	MOVE	C,FSARG+2(A)
	MOVEM	C,FSUPA

;DO DSKCHR FOR THIS UNIT (C=PARAM.BLK.ADDR.)

	MOVE	B,FSNAME	;MAKE NEW F.S. LOG. UNIT NAME
	PUSHJ	P,LOGUNI
	MOVEM	B,SU.LOG(C)
	MOVE	B,HOME+HOMHID	;AND GET PACK ID IF DONT HAVE IT
	SKIPN	UNITID(A)
	MOVEM	B,UNITID(A)
	MOVE	A,PDRIVE(A)	;A=PHYS.UNIT NAME
	MOVEM	A,SU.NAM(C)	;STORE IT IN UNIT PARAM.BLOCK
	PUSHJ	P,DSKUUO	; DO DSKCHR
	  JSP	A,NEVERR	;IMPOSSIBLE ERROR RETURN
;MOVE SOME STUFF INTO PARAM.BLOCK (MOSTLY HOME BLOCK VALUES)

	MOVE	B,[XWD -FSXUNL,FSXUNI]
	PUSHJ	P,MOVALU

;COMPUTE UNICPS & UNIWPS  (STILL EXPECT C=PARAM.BLK.ADDRESS)

	MOVE	A,DSKCHA+.UNBPU	;A=BLOCKS/UNIT
;SWAPPED TWO INSTRUCTIONS
	IDIV	A,HOME+HOMBPC	;A=LARGEST CLUSTER ADDRESS
	SOS	A
	IDIV	A,HOME+HOMSPU	;A=CLUSTERS/SAT-1
	MOVEM	A,SU.CPS(C)	;STORE
	AOS	SU.CPS(C)	;   & BUMP
	IDIVI	A,^D36		;A=WORDS/SAT-1
	AOS	A		;BUMP
	MOVEM	A,SU.WPS(C)	;   & STORE

;MAKE & STORE PTR. TO SPT TABLE (STILL NEED C=PARAM.BLK.ADDRESS)

	MOVS	D,HOME+HOMSPU	;LENGTH=SATS/UNIT
	HRRI	D,SU.L(C)	;EXPECT ROOM FOR SPT AT END OF
	MOVEM	D,SU.SPT(C)	;   UNIT PARAM.BLOCK
	MOVN	A,HOME+HOMSPU	;MAKE AOBJ PTR TO SPT TABLE
	HRL	D,A

	SETZM	SU.TAL(C)	;CLEAR FREE BLOCK TALLY

;BUILD SPT TABLE FROM SAT-RIB PTRS. (D=SPT TABLE ADDRESS)
;   CK THAT UNIT PTR. IS FOR THIS UNIT

	MOVE	C,FSATPT	;C=AOBJ PTR. INTO RIB
	AOBJP	C,ERR273
	MOVE	A,(C)		;A=1ST RIB PTR.
	JUMPE	A,ERR273	;IF 1ST PTR. NOT THIS UNIT 
	LDB	B,FSCNP	;   ERROR'SAT-RIB HAS BAD FORMAT...
	JUMPN	B,ERR273
	ANDI	A,77
	CAME	A,FSLUN
	JRST	ERR273
;HERE FOR EACH GROUP PTR. FOR THIS UNIT
;   C=AOBJ PTR. INTO RIB, D=AOBJ PT. TO SPT

FSDF12:	AOBJP	C,ERR273	;GET NEXT PTR.
	MOVE	A,(C)
	LDB	B,FSCNP	;IS IT A GROUP PTR.?
	JUMPE	B,ERR273	;NO--ERROR 'BAD FORMAT...'

	LDB	B,FSCLP	;YES-PUT CLUST.ADDR. IN SPT TABLE
	DPB	B,FSCLA

;READ SAT BLOCK INTO 'SAT'

	IMUL	B,HOME+HOMBPC	;MAKE BLOCK ADDR. FROM CLUST.ADDR.
	MOVEM	D,FSPTAD	;SAVE SOME AC'S
	MOVEM	C,FSATPT
	MOVE	A,[IOWD 200,SAT]
	MOVE	C,FSLUN
	PUSHJ	P,GETUNB	;READ SAT IN
	  JRST	ERR274		;ERROR 'WHILE GETTING SAT BLOCK'

;COUNT 0'S AND ADD TO VARIOUS TALLYS

	MOVE	D,FSUPA	;MAKE AOBJ PTR. FOR ZBITS
	MOVN	D,SU.WPS(D)
	MOVSS	D
	HRRI	D,SAT+SAFFIR
	PUSHJ	P,ZBITS		;RETURN NUM. 0'S IN A
	MOVE	D,FSPTAD	;RESTOR SPT ADDRESS
	DPB	A,FSTAL		;   AND DEPOSIT IN SPT PTR.

	IMUL	A,HOME+HOMBPC	;MAKE A=FREE BLOCK COUNT
	MOVE	B,FSUPA	;B=ADDR. OF UNIT PARAM.BLOCK
	ADDM	A,FSASTR+SS.TAL	;ADD TO STR TALLY
	ADDM	A,SU.TAL(B)	;   AND UNIT TALLY

;LOOP BACK TO FSDF12 FOR NEXT RIB GROUP PTR.

	MOVE	C,FSATPT	;RESTORE RIB PTR. PTR.
	AOBJN	D,FSDF12	;BUMP SPT PTR. AND LOOP IF MORE TO DO
;HERE WHEN FINISHED WITH A UNIT
;COMPUTE SAFETY FACTOR = MIN(500, NON-SWAPPING BLOCKS/UNVRSF)
;SEE PAGE 14 OF ONCMOD (NXTSA2+)

	MOVE	A,DSKCHA+.UNBPU	;TOTAL BLOCKS ON THE UNIT
	MOVE	B,DSKCHA+.UNK4S	;K FOR SWAPPING ON THE UNIT
	LSH	B,3		;CONVERT K TO 200 WORD BLOCKS
	SUB	A,B		;BLOCKS ON WHICH TO BASE SAFETY FACTOR
	IDIVI	A,UNVRSF	;HIDE 1 OUT OF EVERY UNVRSF BLOCKS
	CAILE	A,^D500		;NEVER ALLOW MORE THAN 500 BLOCKS
	MOVEI	A,^D500		;TO BE RESERVED AS A SAFETY FACTOR
	MOVNS	A		;NOW SUBTRACT SAFETY FACTOR
	ADDM	A,FSASTR+SS.TAL	;  FROM STR TALLY
	MOVE	B,FSUPA		; (POINT TO CURRENT UNIT)
	ADDM	A,SU.TAL(B)	;  AND FROM UNIT TALLY


;IF ANY MORE UNITS, GET HOME BLOCK & LOOP BACK TO FSDF10

	AOS	A,FSLUN		;BUMP LOG.UNIT NUM.
	CAML	A,FSUNM
	JRST	FSDF20		;TO FSDF20 IF ALL DONE
	PUSHJ	P,GETHOM
	  JRST	FSQUIT		;QUIT IF CANT GET HOME BOLCK
	JRST	FSDF10


;HERE WHEN FINISHED WITH LAST UNIT

FSDF20:	MOVE	C,FSATPT	;CK. SAT-RIB TO SEE THAT ONLY 2ND
	AOBJP	C,ERR273	;   RIB PTR. & EOF PTR. REMAIN
	AOBJP	C,ERR273
	SKIPE	(C)
	JRST	ERR273

;DO THE STRUUO(.FSDEF)

	HRLZ	A,FSUNM		;BUILD UUO AC
	ADD	A,[XWD 2,FSARG]
	STRUUO	A,
	  JRST	ERR275		;DIDNT WORK
	MOVE	A,FSNAME	;DSKCHR THE NEW F/S
	PUSHJ	P,DSKUUO
	  PUSHJ	P,NEVMSJ	;DIDNT LAST LONG

FSDF25:	SKIPN	DSKCHA+.DCK4S	;[205] ANY SWAP SPACE ON THIS STRUCTURE ???
	JRST	FSDF30		;[205] NO,,CONTINUE ONWARD
	TTCALL	13,0		;[205] CLEAR ^O IF SET	
	  JFCL			;[205] ((JUST IN CASE))	
	SKIPA	M,.+1		;[205] GET MESSAGE ADDRESS
	[ASCIZ/Add structure to system SWAP list (Y or N)? /] ;[205] GEN MSG
	PUSHJ	P,MSGTTY	;[205] TELL OPERATOR
	MOVEI	IO,R.TTY	;[205] GET HIS
FSDF26:	PUSHJ	P,SSST		;[205]      REPLY
	CAIN	CH,"/"		;[205] IGNORE ANY /'S
	JRST	FSDF26		;[205] GET NEXT CHARACTER
	CAIE	CH,15		;[205] WAS IT A CR ?
	CAIN	CH,12		;[205] WAS IT JUST LF ?
	JRST	FSDF25		;[205] YES--TRY AGAIN
	CAIE	CH,116		;[205] WAS IT 'N' ??
	CAIN	CH,156		;[205] OR WAS IT 'n' ??
	JRST	FSDF30		;[205] YES,,RETURN
	CAIE	CH,131		;[205] WAS IT 'Y' ??
	CAIN	CH,171		;[205] OR WAS IT 'y' ??
	SKIPA			;[205] YES,,LETERRIP !!!
	JRST	FSDF25		;[205] NO,,TRY AGAIN

	MOVE	B,FSUNM		;[177] GET NUMBER OF UNITS
	MOVE	D,[XWD .DUASW,C] ;[177] MAKE POINTER TO UNIT NAME
FSDF27:	SOJL	B,FSDF30	;[177] COUNT DOWN, QUIT WHEN 0
	MOVE	C,PDRIVE(B)	;[177] GET UNIT NAME
	DISK.	D,		;[177] ADD THIS UNIT TO SWAP LIST
	JFCL			;[177] SWAP LIST FULL.
	JRST	FSDF27		;[177] TRY NEXT UNIT

FSDF30:	POPJ	P,		;F/S IS NOW DEFINED--GO FINISH MOUNT
SUBTTL	DISMOUNT COMMAND PROCESSING
; D I S M O U N T    C O M M A N D

;HERE TO READ TTY

;HERE TO READ COMMAND FILE

DICOMF:	IFN FTFACT, <
	MOVE	A,CMDJOB	;GET USER'S JOB #
	DPB	A,[POINT 9,F.HEAD,17] ;STORE FOR ACCOUNTING
>;	END OF	IFN FTFACT
	MOVEI	IO,R.CMD
	PUSHJ	P,SSIXIN	;STEP PAST COMMAND NAME

	MOVEI	D,DISWIT	;CHECK FOR SWITCHES
	PUSHJ	P,COMNAM	;   AND GET F/S NAME
	JUMPE	A,ERR301	;ERROR IF NONE
;[101]	TRNE	A,77		;PROPER NAME?
;[101]	JRST	ERR200		;NO
	MOVEM	A,DVVNAM
IFN FTFACT, <
	MOVEM	A,F.DEV		;STORE THE DEVICE NAME FOR ACCOUNTING
>;	END OF	IFN FTFACT

	MOVEI	D,DISWIT	;CHECK SWITCHES AGAIN
	PUSHJ	P,SWITCH
	  JRST	FSQUIT		;BAD SWITCH

;IS IT A DISK?

	MOVE	A,DVVNAM
	DEVTYP	A,
	  JRST	ERR501
	JUMPE	A,ERR501	;UNDEF.DEVICE
	LDB	B,[.TYTYP+A]
	CAIN	B,.TYDSK	;DISK OR F.S.?
	JRST	DISFS		;YES--SPECIAL ATTENTION

;HERE IF NOT A F.S.

	MOVE	M,DVVNAM	;GET DEVICE NAME
	DEVNAM	M,		;GET IT'S PHYSICAL NAME
	  MOVE	M,DVVNAM	;  FAILED, RESTORE ORIG INPUT
	MOVEI	IO,W.TTY	;POINT AT TTY OUTPUT ROUTINE
	PUSHJ	P,SIXMSO	;TYPE THE DEVICE NAME
	LDB	N,[.TYJOB+A]	;GET CURRENT OWNER'S JOB #
	TLNE	A,.TYAVL	;TEST FOR DEVICE AVAILABLE
	SETZ	N,		;  YES, THEN JOB # MUST BE ZERO
	MOVEI	M,[ASCIZ / released/] ;ASSUME /RELEASE
	SKIPE	N		;TEST FOR ASSIGNED TO A JOB
	MOVEI	M,[ASCIZ / reassigned to job /] ;  YES, CHANGE MSG
	CAMN	N,CMDJOB	;TEST FOR /KEEP
	MOVEI	M,[ASCIZ / kept by job /] ;  YES, CHANGE MSG
	PUSHJ	P,MSGTTY	;TYPE THE MESSAGE
	SKIPE	N		;TEST FOR NOT RELEASED
	PUSHJ	P,DECPRT	;  YES, TYPE OWNER'S JOB #
	PUSHJ	P,CRLF		;END THE LINE
	TRNN	F,SB.R		;[141] BRING /REMOVE SWITCH TO OPRS ATTENTION
	JRST	DIFIN		;[141] EXIT
	PUSHJ	P,MSG505	;[141]
	PUSHJ	P,OPER		;GET OPERATORS GOAHEAD
	JRST	DIFIN
;HERE IF F.S.
;IS F/S IN HIS SEARCH LIST?

DISFS:	PUSHJ	P,CKFS		;IS IT A GOOD F/S NAME?
	  JRST	ERR311		;NO
	HRLZ	A,FSJOB		;GET USER'S JOB #	
	HRRI	A,PRJPRG	;COMBINE WITH GETTAB TABLE # 
	GETTAB	A,		;GET PPN FOR THAT JOB	
	  MOVE	A,FSPPN		;  FAILED, ASSUME OK	
	CAMN	A,FSPPN		;TEST FOR USER'S JOB STILL AROUND 
	TRNE	F,OB.OPC	;OPR.COMMAND?
	JRST	DISFS2		;YES-IGNORE SEARCH LIST
;**; [160] INSERT AT DISFS+10 1/2	CLRH	8-DEC-78
	MOVEI	A,.GTJLT	;[160] FIND OUT WHEN USER JOB LOGGED IN
	HRL	A,FSJOB		;[160] USE LOGGED-IN TIME INDEXED BY JOB NUMBER
	GETTAB	A,		;[160] GET UNIVERSAL DATE/TIME FORMAT
	 SETZ	A,		;[160] TROUBLE WITH GETTAB, ASSUME DISMOUNT IS OK
	CAMLE	A,CMDDTM	;[160] COMPARE WITH FILE CREATION
	 JRST	DISFS2		;[160] OLD FILE, PREDATES USER JOB
	MOVE	C,FSNAME
	MOVE	D,FSPPN
	TRON	F,OB.UFD	;GET THE UFD INTERLOCK
	PUSHJ	P,UFDLOK	;   IF DONT HAVE IT YET
	PUSHJ	P,MAKSL		;SEE IF ITS IN S.L. & BUILD .FSDSL ARG.LST
	JUMPE	A,REMSL5	;NOT IN S.L.--SKIP STRUUO(.FSDSL)

;YES--MUST CHECK UFD BEFORE REMOVING

	MOVE	A,FSPPN		;GET QUOTA.SYS LOG-OUT QUOTA
	MOVE	B,FSNAME
	PUSHJ	P,GETQUO
	  SETOM	D
	MOVE	A,FSPPN
	MOVE	B,FSJOB
	SETZ	N,
	MOVE	N1,MFDPPN
	MOVE	M,FSNAME
	MOVEI	IO,W.TTY

	PUSHJ	P,UFDCLR
	  JRST	FSQUIT
;NOW REMOVE IT FROM SEARCH-LIST

	PUSHJ	P,MAKSL
	  JUMPE	A,REMSL5
	HRLI	A,3(A)		;IS IN S.L.--REMOVE IT FROM ARG.LST.
	BLT	A,-3(B)		;   BY BLT'ING OVER IT
	MOVEI	A,.FSDSL	;SET FUNCTION CODE
	MOVEM	A,FSDSLA
	MOVEI	A,DSLREM	;SET BIT TO REMOVE F/S & DEC. MNT.COUNT
	ORM	A,FSDSLA+3

	SUBI	B,FSDSLA+3	;BUILD UUO AC
	HRL	A,B
	HRRI	A,FSDSLA
	STRUUO	A,
	  JRST	ERR241		;UUO FAILED

REMSL5:	MOVE	C,FSNAME	;GIVEUP THE UFD INTERLOCK
	MOVE	D,FSPPN
	TRZE	F,OB.UFD	;   IF WE HAVE IT
	PUSHJ	P,UFDUNL

DISFS2:	TRNE	F,SB.R		;WANTS TO REMOVE PACKS?
	JRST	REMOV		;YES

	PUSHJ	P,CKFS		;IS MOUNT COUNT NOW 0?
	  PUSHJ	P,NEVMSJ
	TRZ	F,SB.S!SB.UWL
	SKIPN	DSKCHA+.STMNT
	PUSHJ	P,FSRDF		;YES-SET F/S STATUS BIT S TO 0

;HERE WHEN ALL HAS BEEN DONE THAT CAN BE DONE FOR DISMOUNT

DIFIN:	JRST 	FSQUIT
;HERE TO REMOVE F/S FROM THE SYSTEM

REMOV:	PUSHJ	P,CKFS		;IS IT A FILE STRUCTURE?
	  JRST	ERR311		;NO--SAY SO

	TRNN	F,OB.OPC	;OPERATOR COMMAND?
	PUSHJ	P,MSG320	;NO--TELL HIM USER WANTS TO REMOVE

REMOV1:	MOVE	A,DSKCHA+.STMNT	;GET OLD MOUNT COUNT
	MOVEM	A,SAVCNT	;AND SAVE IT FOR LAST MINUTE
	PUSHJ	P,CKMNC		;CHECK MOUNT COUNT
REMOV2:	PUSHJ	P,GETUNI	;GET PHYS. DRIVE NAMES
	  PUSHJ	P,NEVMSJ
REMOV3:	MOVE	A,SAVCNT	;SET UP TO SEE IF NEW USER HAS MOUNTED
;**; [156] CHANGE AT REMOV3+1	CLRH	7-DEC-78
	CAMGE	A,DSKCHA+.STMNT	;[156]THIS STRUCTURE...IF SO NEED MORE
;[156]	CAMLE	A,DSKCHA+.STMNT	;THIS STRUCTURE...IF SO NEED MORE
	 JRST	REMOV1		; CHECKING WITH OPERATOR
	MOVE	A,FSUAOB	;[202] GET AOBJN PTR TO UNITS IN STR
REMV3B:	MOVE	B,PDRIVE(A)	;[202] GET NEXT UNIT NAME
	MOVE	C,[XWD .DUSWP,B]  ;[202]CODE TO MIGRATE SWAP,,AIM AT ARGUMENT BLOCK
	DISK.	C,		;[202] MOVE THE SWAP SPACE OFF THIS PACK
	 PUSHJ	P,MSG321	;[202] CAN'T DO IT, INFORM OPR
	AOBJN	A,REMV3B	;[202] DO ALL UNITS IN STR
	MOVEI	A,.FSREM	;NO NEW USER HAS ARRIVED, SO DO THE STRUUO
	MOVE	B,FSNAME
	MOVEI	C,A
	STRUUO	C,
	  JRST	REMOV5		;WHAT ERROR?

;F/S IS NOW GONE -- TELL OPERATOR

	PUSHJ	P,MSG330

;	PRINT DRIVE NAMES

	MOVE	D,FSUAOB
REMOV4:	MOVE	M,PDRIVE(D)
;**; [120]	INSERT @ REMOV4+1	JULY 9, 1976	DML
	PUSH	P,D			;[120] SAVE D FROM OTHER ROUTINES
;**; [174]
	MOVE	D,[.DUUNL,,M]		;ARG TO DISK. UUO TO UNLOAD UNIT
	TRNE	F,SB.R			;ONLY IF /REMOVE OR OPR REMOVE
	DISK.	D,			;DO IT (RP04 & LATER ONLY)
	  JFCL				;PROBABLY WRONG TYPE OF UNIT
REMV4B:	PUSHJ	P,SWPCHK		;[174] CHECK IF THIS DRIVE IN SWAP TBL
	 SKIPA				;NO
	PUSHJ	P,SWPREM		;YES, TAKE IT OUT OF THE TABLE
	PUSHJ	P,SIXMSG
;**; [120]	INSERT @ REMOV4+5	JULY 9, 1976	DML
	POP	P,D			;[120] RESTORE D
	AOBJN	D,REMOV4
	PUSHJ	P,CRLF

	JRST	DIFIN

REMOV5:	CAIN	C,.ERUNC	;IS IT THE 'TRY AGAIN' ERROR?
	JRST	REMOV3		;YES--TRY AGAIN THEN
	JRST	ERR320		;NO---LOOSE
SUBTTL	SUBROUTINES - FILE STRUCTURE PROCESSING
;SUBROUTINE TO GET DRIVE FOR A USER REQUEST
;CALL	D=INDEX ON PDRIVE-UDRIVE
;	B=MASK RIGHT JUSTIFIED COVERING LOW ORDER CHARACTER

MPICK:	MOVEM	B,MPICKB	;SAVE B
	SKIPL	B
	LSH	B,-6		;MAKE A LEFT JUST. MASK
	SETCA	B,

;LOOK THROUGH SYSTEM UNITS FOR ONE THAT SATISFIES

MPICK0:	SETZM	DSKCHA
MPICK1:	PUSHJ	P,NXDRIV	;GET NEXT SYS.DRIVE
	  JRST	MPICK5		;  NO MORE
	MOVE	C,UDRIVE(D)	;YES-DOES IT SATISFY USER REQUEST
	AND	C,B		;   WHEN MASKED?
	MOVE	A,DSKCHA
	AND	A,B
	CAME	A,C
	JRST	MPICK1		;NO--TOO BAD

	MOVE	A,FSUAOB	;YES-HAVE WE ALREADY USED IT?
	MOVE	C,DSKCHA
MPICK3:	CAMN	C,PDRIVE(A)
	JRST	MPICK1		;YES-FORGET IT THEN
	AOBJN	A,MPICK3

;	HERE WHEN FOUND A DRIVE (NOT NECESSARILLY USER'S REQUEST)

	MOVEM	C,PDRIVE(D)	;NO--USE IT
	LSH	B,6		;DID WE SATISFY THE REQUEST?
	SETCA	B,
	CAME	B,MPICKB
	PUSHJ	P,MSG250	;NO--TELL THE USER
	MOVE	B,MPICKB
	POPJ	P,
;	HERE WHEN CANT FIND A SATISFING DRIVE FOR THIS MASK

MPICK5:	TRO	F,OB.PRO	;REMEMBER TO ASK OPR 'PROCEED?'
	TLNN	B,77		;MORE SPECIFIC THAN CONTROLLER CLASS?
	JRST	MPICK7		;NO--NOT ENOUGH DRIVES THEN
	LSH	B,6		;YES-TRY SOMETHING MORE GENERAL
	JRST	MPICK0

;	HERE WHEN CANT FIND ANY DRIVE THAT WILL WORK

MPICK7:	TRON	F,OB.NED	;HAVE WE ALREADY FAILED?
	PUSHJ	P,MSG251	;NO--TYPE THE BAD NEWS
	PUSHJ	P,UNITYP	;TELL OPR WHAT KIND OF DRIVE
	MOVE	B,MPICKB	;RESTORE B
	POPJ	P,		;   AND RETURN

	U(MPICKB)
;SUBROUTINE TO GET OPERATOR DRIVES
;CALL	PDRIVE=SYSTEM PICKED UNITS (MPICK)
;	UDRIVE=USER "
;RET+0	PDRIVE=OPERATOR PICKED UNITS

;	TYPE F/S NAME

OPICK:	TRNN	F,OB.OPC	;SKIP MESSAGE IF AN OPERATOR COMMAND
	PUSHJ	P,MSG253

;	TYPE LIST OFFREE DRIVES

	PUSHJ	P,MSG252
	SETZM	DSKCHA
	MOVE	D,FSUAOB	;INIT INDEX
	PUSHJ	P,NXDRIV
	  MOVE	A,['NONE  ']	;NO FREE DRIVES
OPICK1:	MOVE	M,A
	PUSHJ	P,SIXMSO
	PUSHJ	P,SPACE
	PUSHJ	P,NXDRIV
	  SKIPA
	JRST	OPICK1
	PUSHJ	P,CRLF

;	GET OPERATOR DRIVES

OPICK0:	MOVE	D,FSUAOB	;AOBJ PTR
OPICK3:	MOVEI	IO,W.TTY
	PUSHJ	P,CRLF
	PUSHJ	P,QUOTE		;  PRINT LOG NAME IN QUOTES
	MOVE	B,FSNAME
	MOVE	A,D
	PUSHJ	P,LOGUNI
	MOVE	M,B
	PUSHJ	P,SIXMSO
	PUSHJ	P,QUOTE
	SKIPN	UNITID(D)	;TEST FOR ZERO UNIT ID
	JRST	OPIC33		;  YES, JUMP
	PUSHJ	P,SPACE		;OUTPUT A SPACE
	MOVE	M,UNITID(D)	;GET THE UNIT ID NOW
OPIC32:	PUSHJ	P,SIXMSO
OPIC33:	PUSHJ	P,TAB
	PUSHJ	P,LEFTP		;YES-TYPE IT IN PARENS
	SKIPN	M,PDRIVE(D)	;GET THE DRIVE # & TEST IT
	MOVE	M,['NONE  ']	;  NONE ASSIGNED, TYPE THAT INSTEAD
	PUSHJ	P,SIXMSO
	PUSHJ	P,RIGHTP
OPIC34:	PUSHJ	P,COLON
	OUTPUT	TTY,
	MOVEI	IO,R.TTY
	MOVEI	M,OPKHLP	;GET OPERATORS REPLY
	PUSH	P,D
	PUSHJ	P,OPRARG
	POP	P,D
	JRST	.+1(N)	;DISP. ON N
	JRST	OPICK4	;0-LONE C.R.
	JUMPN	A,OPICK5;1-NOT LONE C.R.
	JRST	OPICK3	;2-/HELP
	JRST	OPIC98	;3-GARBAGE
	JRST	OPIC98	;4-ERROR

OPICK4:	MOVE	A,PDRIVE(D)	;USE THE SUGGESTED DRIVE
OPICK5:	HRRZ	B,D		;ARE WE ALREADY USING THIS NAME?
	TRNE	A,-1		;TEST FOR 'DPAN' FORMAT
	 JRST	OPIK51		; YES,JUMP
	HLRZS	A		;GET 'N' TO RH
	HLL	A,PDRIVE(D)	;USE DEFAULT CONTROLLER
	TLNN	A,-1		;TEST FOR CONTROLLER TO DEFAULT TO
	 JRST	OPIC98		; NO, ERROR
OPIK51:	SOJL	B,OPIK52
	CAME	A,PDRIVE(B)
	JRST	OPIK51
	JRST	OPICK8		;'UNAVAILABLE' MSG.	

OPIK52:				;HERE WITH NAME AS PICKED BY OPR
	LDB	B,[POINT 12,A,11] ;GET 1ST TWO CHARS OF INPUT
	LDB	C,[POINT 12,PDRIVE(D),11] ;GET 1ST TWO CHARS OF SELECTED DRIVE
	CAME	B,C		;TEST FOR SAME TWO CHARS
	JUMPN	C,OPIC98	;  ERROR UNLESS NO DEVICE PICKED
	TRNN	A,007777	;TEST FOR .LT. 5 CHARS TYPED
	TRNN	A,770000	;TEST FOR 4 CHARS TYPED
	JRST	OPIC98		;  ERROR IF NOT 4 CHARS INPUT
	PUSHJ	P,CKDRIV	;NO--CHECK THIS NAME
	  JRST	OPICK8		;ITS NO GOOD
	MOVE	A,DSKCHA	;ITS OK SO SUBSTITUTE IT
	MOVE	B,D		;GET AOBJN PTR
OPIK60:	CAME	A,PDRIVE(B)	;MATCH OPR'S CHOICE WITH FREE DRIVE
	 AOBJN	B,OPIK60	;IF NOT FOUND, CHECK NEXT FREE DRIVE
	EXCH	A,PDRIVE(D)	;[102] SWITCH OPR'S CHOICE AND PDRIVE(D)
	SKIPGE	B		;AND UNLESS OPR'S CHOICE WAS NOT AMONG
	 MOVEM	A,PDRIVE(B)	;OMOUNT'S CHOICES, PUT IT IN NEW SLOT
	AOBJN	D,OPICK3	;LOOP
	POPJ	P,

OPICK8:	MOVEI	M,[ASCIZ/  Unavailable/]
	PUSHJ	P,MSGTTY
	JRST	OPICK3

OPIC98:	PUSHJ	P,MSG200	;/H FOR HELP

	JRST	OPICK3
;SUBROUTINE TO WAIT FOR UNITS TO BECOME READY
;CALL	PDRIVE=DRIVE NAMES
;	UNITID=UNIT ID'S


WATUN0:	SLEEP	A,

WATUNI:	SETZB	A,FSLUN		;LOGICAL UNIT 0
	SETZM	WATUNS		;CLEAR SLEEP FLAG

WATUN3:
;	MOVE	A,PDRIVE(A)	;DO A DSKCHR ON THIS UNIT
;	PUSHJ	P,DSKUUO
;	  JSP	A,NEVERR
;	--IF NOT ONLINE GO TO WATUN4--
	PUSHJ	P,GETHOM	;READ HOME BLOCK
	  JRST	WATUN4		;NOT READY YET
	MOVE	D,FSLUN		;IS IT RIGHT PACK?
	LDB	A,STYPE		;GET THE DRIVE TYPE
	MOVE	B,HOME+HOMUTP	;GET TYPE IN HOMEBLOCK
	CAME	A,B		;DOES IT MATCH TYPE IN HOMEBLOCK
	 JUMPN	B,ERR510	;NO, TELL OPR AND ABORT
	MOVE	A,UNITID(D)
	JUMPE	A,WATUN5	;SKIP CK. IF NO UNITID
	CAMN	A,HOME+HOMHID
	JRST	WATUN5		;YES

	MOVEI	M,[ASCIZ/Wrong unit on /] ;NO--TELL OPERATOR
	PUSHJ	P,MSGTTY
	MOVE	M,PDRIVE(D)
	PUSHJ	P,SIXMS4
	MOVEI	M,[ASCIZ/
...Is /]
	PUSHJ	P,MSGTTY
	MOVE	M,HOME+HOMHID
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ Should be /]
	PUSHJ	P,MSGTTY
	MOVE	M,UNITID(D)
	PUSHJ	P,SIXMSG
	PUSHJ	P,CRLF
	HRROS	WATUNS		;SET SLEEP SWITCH FOR 'LONG TIME'
	JRST	WATUN5

WATUN4:	HLLOS	WATUNS		;SET SLEEP SWITCH FOR 'SHORT TIME'
WATUN5:	AOS	A,FSLUN		;BUMP LOG.UNIT #
	CAMGE	A,FSUNM
	JRST	WATUN3		;LOOP IF MORE TO CHECK

	SKIPN	A,WATUNS	;WAS EVERYTHING OK?
	POPJ	P,		;YES-RETURN
	JUMPG	A,WATUN0		;NO--SLEEP SHORT
	PJRST	OPER		;NO--GIVE OPER CHANCE TO FLUSH

	U(WATUNS)

;SUBROUTINE TO GET F/S DRIVE NAMES AND PACK I.D.'S
;CALL	FSNAME=F/S NAME
;RET+0	NO UNITS--ERGO--NO F/S
;RET+1	DRIVES IN PDRIVE
;	I.D.'S IN UNITID
;	STYPE=DRIVE TYPE
;	SKTYP=KON CLASS
;	FSUNM=NUM. OF UNITS
;	FSUAOB=AOBJ PTR FOR UNITS

GETUNI:	MOVEI	D,1		;COUNT UNITS IN D
	MOVEI	A,-1(D)
	MOVE	B,FSNAME
	PUSHJ	P,LOGUNI
	MOVE	C,N		;SAVE BYTE-PTR TO THE LAST BYTE
	HRRI	C,A		;  LOG-NAME IS IN A
	MOVE	A,B
	PUSHJ	P,DSKUUO
	  POPJ	P,		;NO UNITS

GETUN2:	LDB	N,DCHUTP	;GET UNIT TYPE
	DPB	N,STYPE1	;SAVE FOR OTHER ROUTINES
	LDB	N,DCHKTP	;GET KON CLASS
	DPB	N,SKTYP1	;AND SAVE FOR OTHER ROUTINES
	MOVE	A,DSKCHA+.UNNAM	;PUT DRIVE NAME IN PDRIVE
	MOVEM	A,PDRIVE-1(D)
	MOVE	A,DSKCHA+.UNHID	;AND I.D. IN UNITID
	MOVEM	A,UNITID-1(D)
	MOVE	A,DSKCHA	;MAKE NEXT LOG.NAME
	MOVEI	E,'  0'(D)	;INCREMENT THE LAST BYTE
	DPB	E,C		;  AND UPDATE THE UNIT NAME
	PUSHJ	P,DSKUUO
	  SKIPA
	AOJA	D,GETUN2

	MOVEM	D,FSUNM		;NUM. UNITS TO FSUNM
	MOVNS	D		;& AOBJ PTR TO FSUAOB
	HRLZM	D,FSUAOB
	JRST	CPOPJ1

;SUBROUTINE TO CREATE LOG.UNIT NAMES
;CALL	A=LOGICAL UNIT NUMBER (PRESERVED)
;	B=F.S. NAME
;RET+1	B=LOG.UNIT NAME

LOGUNI:	MOVE	N,[POINT 6,B]
LOGUN1:	ILDB	M,N
	JUMPN	M,LOGUN1
	MOVEI	M,'  0'(A)
	DPB	M,N
	POPJ	P,
;SUBROUTINE TO CHECK A DRIVE FOR TYPE AND AVAILABLILITY
;CALL	A=DRIVE NAME
;	D=INDEX ON UNITCL
;RET+0	C .EQ. 0 IF ILLEGAL NAME OR TYPE
;	C .NE. 0 IF NOT AVAILABLE
;RET+1	IF AVAILABLE AND OK
;	PRESERVES B AND D

CKDRIV:	PUSHJ	P,DSKUUO
	  JRST	CKDRI2		;BAD NAME
	LDB	C,DCHCOD	;SPECIFIC DRIVE NAME?
	CAIE	C,6
	JRST	CKDRI2		;NO--REJECT IT
	LDB	C,DCHKTP	;YES-RIGHT CONTROLLER TYPE?
	LDB	E,SKTYP		;
	CAME	C,E		;***
	JUMPN	D,CKDRI2	;GIVE ERROR RETURN IF CHECKING FOR SPECIFIC UNIT

	LDB	C,DCHUST	;YES-DOES STATE CODE='NO PACK MOUNTED?
	CAIE	C,UNVNPM
	JRST	CKDRI3		;NO--RET+0

	JUMPE	D,CPOPJ1	;RETURN SUCCESSFUL IF NOT CHECKING
				; FOR SPECIFIC UNITS

	LDB	C,DCHUTP	;YES-RIGHT UNIT TYPE?
	LDB	A,STYPE
	CAMN	C,A
	JRST	CPOPJ1		;YES-RET+1
CKDRI2:	TDZA	C,C		;NO--RETURN+0 C=0
CKDRI3:	SETO	C,		;    RETURN+0 C NON0
	POPJ	P,

;SUBROUTINE TO GET SUCCESSIVE FREE DRIVES
;INIT	SETZM DSKCHA
;CALL	LAST DRIVE NAME IN DSKCHA
;RET+1	NO MORE DRIVES
;RET+2	DRIVE NAME IN A & DSKCHA
NXDRIV:	MOVE	A,DSKCHA	;GET NEXT SYSTEM DRIVE
	SYSPHY	A,
	  JSP	A,NEVERR		;UUO FAILURE
	JUMPE	A,CPOPJ	;JUMP IF THAT WAS LAST UNIT
	PUSHJ	P,CKDRIV	;WILL THIS DRIVE DO?
	  JRST	NXDRIV		;NO
	MOVE	A,DSKCHA
	JRST	CPOPJ1
;SUBROUTINE TO GET UFD INTERLOCK
;CALL	C=F/S
;	D=PPN
;RET+0	;ALWAYS WHEN HAVE THE INTERLOCK
;
;	USES A,B,C,D

UFDLOK:	PUSHJ	P,CONCOF	;NO ^C WHILE HAVE UFD INTERLOCK
	MOVEI	N,10		;PANIC IF CANT GET INTERLOCK IN 10 SEC.
UFDLO0:	MOVEI	B,.FSULK
	PUSHJ	P,UFDLUU	;ALREADY LOCKKED?
	  SKIPA
	POPJ	P,		;NO--WE HAVE IT NOW
	CAME	A,[3,,B]	;TEST FOR NON-LOCKED ERROR
	JSP	A,NEVERR	;  NO, FATAL ERROR	
	MOVEI	A,1		;YES-SLEEP AND TRY AGAIN
	SLEEP	A,
	SOJG	N,UFDLO0	;TRY AGAIN IF NOT EXAUSTED
	PUSHJ	P,MSG260	;SOMETHING WRONG--
	PJRST	OPER		;   LET OPERATOR DECIDE

;SUBROUTINE TO CLEAR UFD INTERLOCK
;CALL	C=F/S
;	D=PPPN
;RET+0	ALWAYS
;
;	USES A,B,C,D

UFDUNL:	MOVEI	B,.FSUCL
	PUSHJ	P,UFDLUU
	  JSP	A,NEVERR
	PJRST	CONCON		;^C OK NOW

UFDLUU:	MOVEI	A,B		;HERE WITH FCN.CODE IN B TO DO THE UUO
	HRLI	A,3
IFE DBUGSW, <
	STRUUO	A,
	  POPJ	P,
>;	END OF	IFE DBUGSW
	JRST	CPOPJ1
;SUBROUTINE TO CHECK IF FSNAME IS A CUREN F/S NAME
;CALL	FSNAME=F/S NAME
;RET+0	NOT MOUNTED OR NOT A F/S NAME
;RET+1	FSNAME IS A CURRENTLY MOUNTED F/S

CKFS:	MOVE	A,FSNAME
	PUSHJ	P,DSKUUO	;DO A DSKCHR ON IT
	  POPJ	P,
	LDB	A,DCHCOD	;CK NAME TYPE
	CAIE	A,2
	  POPJ	P,	;NOT A F/S NAME
	JRST	CPOPJ1


;SUBROUTINES TO HANDLE THE ACTIVE SWAPPING LIST: USED BY USERS COMMAND 
;AND DISMOUNT /REMOVE LOGIC

SWPCHK:	MOVE	D,SWPAOB		;IS DRIVE IN A IN OMOUNT'S LIST
SWPCH2:	CAMN	A,SWPTAB(D)		;IF IT IS FOUND RET +1
	 JRST	CPOPJ1
	AOBJN	D,SWPCH2		;IF NOT RET +0
	POPJ	P,

;TO REMOVE ITEM FROM OMOUNT'S LIST: CALLED WITH AOBJN PTR FROM SWPCHK
;IN D

SWPREM:	MOVE	A,SWPTAB+1(D)		;REMOVE THE ENTRY POINTED TO BY
	MOVEM	A,SWPTAB(D)		;  D AND COMPRESS TABLE
	AOBJN	D,SWPREM
	MOVE	D,SWPAOB
	AOBJP	D,SWPZER
	HLLM	D,SWPAOB
	POPJ	P,

SWPZER:	MOVEI	M,[ASCIZ/%The last Swapping unit was just removed/]
	SETZM	SWPAOB
	PJRST	ERR994
	POPJ	P,
;SUBROUTINE TO CHECK F.S. FOR SPECIAL CONDITIONS (SYSTEM S.L. NON-ZERO MOUNTCOUNT ETC.)
;CALL	DSKCHR STUFF IN DSKCHA...
;RET+0	IF F.S. PASSES ALL TESTS OR OPR. SAYS GO AHEAD ANYWAY
;	OTHERWISE JRSTS TO FSQUIT

CKMNC:	SKIPE	N,DSKCHA+.STMNT	;MOUNT-COUNT=0?
	PUSHJ	P,MSG312	;NO--TELL THE OPER
	LDB	A,[STAVER]
	CAIGE	A,V503
	JRST	CKMNC2
	MOVEI	N,A		;CHECK SYS.SRC.LST
	SETZM	A
	MOVE	B,SYSPPN
	MOVE	C,FSNAME
	GOBSTR	N,
	  JRST	CKMNC1
	PUSHJ	P,MSG313	;TELL OPR ITS IN SYS.SRC.LST
	JRST	CKMNC2
CKMNC1:	CAIE	N,3	;'NOT THERE' RETURN?
	PUSHJ	P,NEVMSJ	;NO-THATS AN ERROR
CKMNC2:	MOVE	A,FSNAME	;IS THIS THE QUEUE F.S. (3,3)?
	CAMN	A,CMDSTR
	PUSHJ	P,MSG314	;YES-TELL OPR

;SEE IF F.S. CONTAINS STRLST.SYS

IFN OFFLIN,<
	SKIPE	NCHKFG		;DID OPER SAY NOT TO CHECK?
	 JRST	MSG310		;YES, TELL HIM STRLST MAY BE ON F.S.
>;	END IFN OFFLIN

	MOVE	B,FSNAME	;OPEN F.S.
	MOVSI	A,PHOPEN				
	SETZ	C,					
	OPEN	USR,A
	  JRST	CKMNC3
	MOVE	A,[SIXBIT/STRLST/]	;LOOKUP STRLST.SYS
	MOVSI	B,(SIXBIT/SYS/)
	SETZM	C
	MOVE	D,SYSPPN
	LOOKUP	USR,A
	  JRST	CKMNC3		;NOT THERE
	PUSHJ	P,MSG317	;ITS THERE SO TELL OPR.
CKMNC3:	RELEASE	USR,

;CK. ALL UNITS FOR SWAPPING SPACE

CKMNC5:	MOVEI	C,0
CKMNC4:	MOVE	A,C
	MOVE	B,FSNAME
	PUSHJ	P,LOGUNI
	MOVE	A,B
	PUSHJ	P,DSKUUO
	  JRST	CKMNC6
IFN DBUGSW,<
	SKIPN	DSKCHA+.UNK4S
>;	END OF IFN DBUGSW

IFE DBUGSW,<
	MOVE	A,DSKCHA+.UNNAM	;GET PHYS. NAME FOR SWPCHK
	PUSHJ	P,SWPCHK	;CHECK IF IN THE ACTIVE SWAP LIST
>;	END OF IFE DBUGSW

	AOJA	C,CKMNC4
	PUSHJ	P,MSG315	;TELL OPER THERES SWAPPING SPACE

CKMNC6:	TRZE	F,OB.PRO	;ANY PROBLEMS?
	PUSHJ	P,OPER		;YES-LET OPR MAKE DECISION
	POPJ	P,		;NO--OR OPR SAYS GO AHEAD ANYWAY
;SUBROUTINE TO MAKE UNIDES BITS FROM SWITCH BITS
;CALL	F=SWITCH BITS
;RET+0	ALWAYS WITH FSDES=UNIDES BITS

FSBITS:	SETZ	A,
	TRNE	F,SB.S		;SING-ACCESS?
	TLO	A,DEFSAF
	TRNE	F,SB.UWL	;WRITE-LOCK ALL JOBS?
	TLO	A,DEFAWL
	MOVEM	A,FSDES
	POPJ	P,


;SUBROUTINE TO SET F/S STATUS BITS
;CALL	SWITCH BITS (SB.S,SB.UWL) IN F
;RET+0	ALWAYS (UNLESS UUO FAILS)

FSRDF:	PUSHJ	P,FSBITS	;YES-MAKE UNIDES BITS OUT OF SWITCH-BITS
	MOVE	B,[XWD -FSXRDL,FSXRDF]	;SETUP .FSRDF ARG.LIST
	MOVEI	C,FSRDFA
	PUSHJ	P,MOVALU
	STRUUO	C,		;DO THE UUO
	 TLZA	C,-1
	POPJ	P,
	CAIE	C,6		;IS USER GONE?
	 JRST	ERR225		; NO, ERROR
	JRST	ERR224		;YES, SAY SO AND ABORT REQUEST
;SUBROUTINE TO BUILD SEARCH LIST IN STRUUO(.FSDSL)FORMAT
;CALL	FSPPN=JOB'S PPN
;	FSJOB=JOB'S #
;	FSNAME=A F/S NAME
;RET+0	ALWAYS
;	A=ADDR. OF F/S ENTRY (OR 0 IF NONE)
;	B=ADDR. OF END OF ARG.LIST
;	C=ADDR. OF FENCE ENTRY (OR 0 IF NONE)

MAKSL:	MOVE	A,FSNAME	;A=F/S WERE LOOKING FOR
	MOVE	B,FSJOB		;SETUP GOBSTR ARG.LIST
	MOVEM	B,GOBSTA+0
	MOVEM	B,FSDSLA+1	;   AND .FSDSL ARG LIST
	MOVE	B,FSPPN
	MOVEM	B,GOBSTA+1
	MOVEM	B,FSDSLA+2
	SETOM	GOBSTA+2	;-1 GETS 1ST F/S
	SETZM	FSDSLA+3	;0 FOR FSDSL FLAGS

	MOVE	B,[XWD GOBSTA+2,FSDSLA+4] ;USE B FOR BLT'S TO FSDSLA
	SETZM	MAKSLA
	SETZM	MAKSLC		;			

MAKSL2:	MOVE	C,[XWD 5,GOBSTA] ;USE C FOR GOBSTR AC
	GOBSTR	C,
	  JRST	ERR240		;UUO FAILURE
	SKIPN	D,GOBSTA+2	;IS IT THE FENCE?
	HRRZM	B,MAKSLC	;YES-REMEMBER ADDR.
	AOJE	D,MAKSL8	;NO--JUMP OUT OF LOOP IF LAST F/S (-1)
	CAMN	A,GOBSTA+2	;IS THIS THE F/S WERE LOOKING FOR?
	HRRZM	B,MAKSLA	;YES-REMEMBER ITS ADDR/
	MOVE	C,B		;BLT THIS TRIPLET OVER TO .FSDSL ARG.LST
	BLT	C,2(B)
	ADDI	B,3		;BUMP B FOR NEXT F/S
	JRST	MAKSL2		;   AND LOOP

MAKSL8:	MOVE	A,MAKSLA
	MOVE	C,MAKSLC
	POPJ	P,

	U(MAKSLA)
	U(MAKSLC)
;SUBROUTINE TO GET USERS QUOTAS FROM QUOTA.SYS
;CALL	B=F/S NAME
;	A=PPN
;RET+0	NO QUOTAS RETURNED
;RET+1	B=RESERVED QUOTA
;	C=FCFS QUOTA
;	D=LOGGED-OUT QUOTA

GETQUO:	TRNE	A,400000	;TEST FOR # PROG NUMBER	
	HRRI	A,-2		;  YES, CONVERT IT	
	MOVEM	A,QUOPPN	;			
	HLLOM	A,QUODEF	;DEFAULT (PROJ,-1)
	MOVEM	B,QUOSTR	;STORE STR		
	MOVE	A,[PHOPEN,,14]				
	MOVEI	C,RH.USR
	OPEN	USR,A		;TRY TO OPEN STR
	  PJRST	MSG262
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	MOVE	A,[SIXBIT .QUOTA.]
	MOVSI	B,(SIXBIT .SYS.)
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;SEE IF QUOTA.SYS EXISTS
	  JRST	GETAQ1		;NO -- SO TRY FOR AUXACC.SYS
	PUSHJ	P,R.USR		;READ SIZE OF ENTRY
	  PJRST	MSG262
	HLRZ	B,WD		;B=FORMAT VERSION NUMBER
	CAIE	B,QUOFOR
	PJRST	MSG263
	HRRZ	A,WD
	SETOM	QUODFR		;USE QUODFR AS A SWITCH
	PUSHJ	P,R.USR		;GET 1ST ENTRY
	  JRST	GETQU3
	AOSE	WD		;IS IT -1,-1?
	SOJA	WD,GETQU5	;NO
	PUSHJ	P,GETQU		;YES-REMEMBER ITS QUOTAS FOR DEFAULTS
	  POPJ	P,
	MOVEM	B,QUODFR
	MOVEM	C,QUODFF
	MOVEM	D,QUODFO
	JRST	GETQU6

GETQU1:	PUSHJ	P,R.USR		;READ FIRST WORD OF ENTRY (PPN)
	  JRST	GETQU3
GETQU5:	CAMLE	WD,QUODEF	;SKIP IF NOT YET PAST USER
	JRST	GETQU7		;HE AIN'T THERE
	CAME	WD,QUODEF	;DEFAULT?
	CAMN	WD,QUOPPN	;SKIP IF THIS IS NOT USER'S PPN
	JRST	GETQU4		;HE EXISTS, GO MAKE UFD
GETQU6:	MOVE	B,A		;SKIP REST OF THIS ENTRY
GETQU2:	SOJLE	B,GETQU1
	PUSHJ	P,R.USR
	  JRST	GETQU3
	JRST	GETQU2
GETQU3:	STATZ	USR,20000	;EOF?
	JRST	GETQU7		;YES-NO ENTRY IN QUOTA.SYS
	PJRST	MSG262		;NO--ERROR

GETQU4:	PUSHJ	P,GETQU		;READ ENTRY
	  POPJ	P,
	JRST	GETQU8		;  & RETURN

GETQU7:	SKIPGE	B,QUODFR	;WAS THERE A DEFAULT?
	JRST	GETAQ1		;NO -- SO TRY FOR AUXACC.SYS
	MOVE	C,QUODFF	;YES-USE THEM
	MOVE	D,QUODFO
GETQU8:	RELEASE	USR,
	JRST	CPOPJ1

;SUBROUT TO READ READ QUOTAS INTO B,C,D

GETQU:	PUSHJ	P,R.USR		;READ RESERVED QUOTA
	  PJRST	MSG262
	MOVEM	WD,B		;B=QTR
	PUSHJ	P,R.USR		;READ FIRST COME, FIRST SERVED QUOTA
	  PJRST	MSG262
	MOVEM	WD,C		;C=QTF
	PUSHJ	P,R.USR		;AND LOGGED-OUT QUOTA
	  PJRST	MSG262
	MOVEM	WD,D		;D=QTO
	JRST	CPOPJ1

	U(QUOPPN)
	U(QUODFR)
	U(QUODFF)
	U(QUODFO)
	U(QUODEF)
	U(QUOSTR);					
	;NO QUOTAS IN QUOTA.SYS SO TRY AUXACC.SYS
GETAQ1:	MOVE	A,[PHOPEN,,14]				
	HRLZI	B,(SIXBIT .SYS.)
	MOVEI	C,RH.USR
	OPEN	USR,A
	  PJRST	MSG262
;**;[115] INSERT @ GETAQ1+5	JNG	20-Sep-75
	SETOM	QUODFR		;[115] REMEMBER HAVEN'T SEEN DEFAULT YET
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	MOVE	A,[SIXBIT .AUXACC.]
	MOVSI	B,(SIXBIT .SYS.)
	MOVE	D,SYSPPN
	LOOKUP	USR,A		;AUXACC.SYS
	  PJRST	MSG261		;LOOKUP FAILED
	PUSHJ	P,R.USR		;PASSOVER THE NULL WORD
	  PJRST	GETAQ9		;SOMETHING IS WRONG HERE
GETAQ2:	PUSHJ	P,R.USR		;READ WORD 0  =  -1
	  PJRST	GETAQ9		;READ ERROR OR NO ENTRY
;**;[115] CHANGE @ GETAQ2+2	JNG	20-Sep-75
	AOJN	WD,GETAQ8	;[115] NONE FOR HIM, CHECK DEFAULT
	PUSHJ	P,R.USR		;NUMBER OF WORDS REMAINING IN THIS ENTRY
	  JRST	GETAQ9		;
	MOVEI	D,-1(WD)	;DONT COUNT THE "P,,P" WORD 
	PUSHJ	P,R.USR		;READ THE "P,,P" WORD
	  JRST	GETAQ9		;
	CAML	WD,QUOPPN	;COULD THIS BE THE ENTRY?
	JRST	GETAQ4		;YES
;**;[115] INSERT @ GETAQ2+12	JNG	20-Sep-75
	AOJE	WD,GETDQ1	;[115] IF THIS IS %,% GO SAVE IT
GETAQ3:	PUSHJ	P,R.USR		;NO -- SO PASS OVER THIS ENTRY
	  JRST	GETAQ9		;
	SOJG	D,GETAQ3	;
	JRST	GETAQ2		;AND TRY THE NEXT ONE

	;EITHER THIS IS IT OR ITS NOT HERE
GETAQ4:	CAME	WD,QUOPPN	;EXACT MATCH		
	CAMN	WD,QUODEF	;OR DEFAULT PROG NUMBER	
	JRST	GETAQ5		;YES
	CAMG	WD,QUODEF	;TEST FOR OUT OF RANGE	
	JRST	GETAQ3		;  NO, KEEP ON READING	
;**;[115] CHANGE @ GETAQ4+5	JNG	20-Sep-75
	JRST	GETAQ8		;[115] NONE FOR HIM, GO GET DEFAULT
GETAQ5:	PUSHJ	P,R.USR		;READ FILE-STR NAME
	  JRST	GETAQ9		;
GETAQ6:	CAMN	WD,QUOSTR	;IS THIS THE FILE-STR?	
	JRST	GETQU4		;YES -- GET QUOTAS AND EXIT
	SUBI	D,5		;NO -- SKIP OVER THIS FILE-STR
	JUMPLE	D,MSG264	;ANY MORE FILE-STRS? TOO BAD
	MOVEI	C,5		;YES
GETAQ7:	PUSHJ	P,R.USR		;SKIP OVER THE CURRENT ONE
	  JRST	GETAQ9		;
	SOJG	C,GETAQ7	;
	JRST	GETAQ6		;AND TRY THE NEXT ONE
;**;[115] REPLACE @ GETAQ9	JNG	20-Sep-75

GETAQ9:	STATO	USR,20000	;[115] CHECK FOR END OF FILE
	PJRST	MSG262		;[115] NO, GO REPORT READ ERROR
GETAQ8:	SKIPGE	B,QUODFR	;[115] NO QUOTAS FOR HIM, ANY DEFAULTS?
	PJRST	MSG264		;[115] NO, GO TELL HIM NO QUOTAS
	MOVE	C,QUODFF	;[115] SET UP FCFS QUOTA
	MOVE	D,QUODFO	;[115] AND LOGOUT QUOTA
	JRST	GETQU8		;[115] AND RETURN TRIUMPHANT


;[115] HERE ON THE %,% ENTRY. STORE IN CASE NO ENTRY FOR THIS GUY.

GETDQ1:	PUSHJ	P,R.USR		;[115] READ NEXT STR NAME
	  JRST	GETAQ9		;[115] FAILED, GO SEE WHY
	CAMN	WD,QUOSTR	;[115] TEST FOR RIGHT STR
	JRST	GETDQ3		;[115] YES, GO SAVE IT
	SUBI	D,5		;[115] NO, SKIP THIS ENTRY
	MOVEI	C,4		;[115] ...
GETDQ2:	PUSHJ	P,R.USR		;[115] ...
	  JRST	GETAQ9		;[115] SNH, BUT GO SEE WHY
	SOJG	C,GETDQ2	;[115] LOOP TILL THIS STR SKIPPED
	JUMPG	D,GETDQ1	;[115] KEEP LOOKING IF MORE TO LOOK AT
	JRST	GETAQ2		;[115] NO QUOTAS ON THIS STR BY DEFAULT
GETDQ3:	MOVEM	D,QUODFO	;[115] SAVE WORDS REMAINING IN TEMP
	PUSHJ	P,GETQU		;[115] GET ALL THE QUOTAS
	  POPJ	P,		;[115] ???
	MOVEM	B,QUODFR	;[115] STORE DEFAULTS
	MOVEM	C,QUODFF	;[115] ...
	EXCH	D,QUODFO	;[115] RETRIEVE OLD WORD COUNT
	SUBI	D,4		;[115] ACCOUNT FOR WORD READ
	JRST	GETAQ3		;[115] & FLUSH REST OF THIS ENTRY
;SUBROUTINE TO TYPE OUT UNIT TYPE
;CALLED WITH UNITCL SET UP

UNITYP:	LDB	A,STYPE		;GET THE UNIT TYPE
	LDB	B,SKTYP		;AND THE KONTROLLER TYPE
	MOVEI	M,[ASCIZ/UNKNOWN UNIT TYPE/]	;IN CASE WE LOSE
	CAIG	A,.DCUR6	;UNIT IN RANGE?
	CAILE	B,.DCCRP	;OR KONT NOT IN RANGE?
	JRST	MSG994		;TELL OPR ABOUT BAD UNIT
	JRST	@[EXP UNI.0,UNI.1,UNI.2](A)	;DISPATCH BY UNIT TYPE

UNI.0:	MOVEI	M,[ASCIZ/RD10/]		;ASSUME DRUM
	CAIN	B,.DCCFS		;FIXED HEAD RH10?
	MOVEI	M,[ASCIZ/RS04/]		;YES, THEN RS04
	CAIN	B,.DCCRP		;POSITIONING RH10?
	MOVEI	M,[ASCIZ/RP04/]		;YES, THEN RP04 IS IT
	JRST	MSG994			;OUTPUT UNIT TYPE AND CRLF
UNI.1:	MOVEI	M,[ASCIZ/RM10B/]	;ASSUME DRUM
	CAIN	B,.DCCDP		;A DP PACK?
	MOVEI	M,[ASCIZ/RP02/]		;THEN RP02 IS IT
	CAIN	B,.DCCRP		;A RP PACK
	MOVEI	M,[ASCIZ/RP06/]		;THEN USE THIS
	JRST	MSG994			;OUTPUT GOOD STUFF
UNI.2:	MOVEI	M,[ASCIZ/RP03/]	;TRY RP03
	CAIN	B,.DCCRP		;AN RH10 CONTROLLER?
	MOVEI	M,[ASCIZ/RP06/]		;THEN ITS AN RP06
	JRST	MSG994			;OUTPUT UNIT TYPE
SUBTTL	ERROR MESSAGES
;ERROR RETURNS---JRST TO FSQUIT WHEN FINISHED

ERR010:	MOVEI	M,[ASCIZ/?Syntax error/]
	JRST	ERR994

ERR040=ERR010	;NAME-LIST TOO LONG

ERR041=ERR010	;NO CLOSING PAREN ON NAME-LIST

ERR096:	MOVEI	M,[ASCIZ/?Not enough table space for Act Swapping List/]
	JRST	ERR994

ERR097:	MOVEI	M,[ASCIZ/?Monitor must be 5.03 or later/]
	JRST	ERR994

ERR098:	SETZM	CMDNAM		;SO WONT GET HERE AGAIN
	MOVEI	M,[ASCIZ/Command-file has vanished!/]
	JRST	ERR994

ERR099:	MOVEI	M,[ASCIZ/Bad command-file format/]
	JRST	ERR990

ERR100:	MOVEI	M,[ASCIZ/...Can't create UFD for command-files/]
	JRST	ERR994

ERR101:	MOVEI	M,[ASCIZ/Can't read UFD for command-files/]
	JRST	ERR990

ERR200:	MOVEI	M,[ASCIZ/?Undefined device/]
	JRST	ERR994

ERR201:	MOVEI	M,[ASCIZ/?Command requires device name/]
	JRST	ERR994

ERR211:	MOVEI	M,[ASCIZ/Can't INIT SYS/]
	JRST	ERR990

ERR221:	MOVEI	M,[ASCIZ/?Locked-out by Operator/]
	JRST	ERR994

ERR222:	MOVE	N,DSKCHA+.UNJOB	;PICKUP JOB #
	MOVEI	M,[ASCIZ/?Single-access by job /]
	JRST	ERR998

ERR224:	MOVE	N,C
	PUSHJ	P,ERR226
	JRST	ERR994

ERR225:	MOVE	N,C
	PUSHJ	P,ERR226
	MOVEI	M,[ASCIZ/STRUUO(.FSRDF) UUO -- Error code /]
	JRST	ERR996

ERR226:	MOVEI	M,[ASCIZ /User Job has Logged off/]
	CAIE	C,6
	 POPJ	P,
	PUSHJ	P,MSGTTY
	PJRST	CRLF
ERR240:	MOVE	N,C		;SAVE UUO ERROR CODE
	PUSHJ	P,ERR226
ERR242:	MOVEI	M,[ASCIZ/GOBSTR UUO -- Error code /]
	JRST	ERR996

ERR241:	MOVE	N,A
	MOVEI	M,[ASCIZ/STRUUO(.FSDSL) UUO -- Error code /]
	JRST	ERR996

ERR270:	MOVEI	M,[ASCIZ/...While getting SAT-RIB/]
	JRST	ERR994

ERR271:	MOVEI	M,[ASCIZ/Consistancy failure for SAT-RIB/]
	JRST	ERR990

ERR273:	MOVEI	M,[ASCIZ/SAT-RIB has bad format/]
	JRST	ERR990

ERR274:	MOVEI	M,[ASCIZ/...While getting SAT block/]
	JRST	ERR994

ERR275:	MOVE	N,A		;SAVE ERR CODE FOR TYPEOUT
	MOVEI	M,[ASCIZ/STRUUO(.FSDEF) UUO -- Error code /]
	JRST	ERR996

ERR276:	MOVEI	M,[ASCIZ/...While getting MFD-RIB/]
	JRST	ERR994

ERR300:	MOVEI	M,[ASCIZ/?Illegal structure name/]
	JRST	ERR994

ERR301=ERR201	;NO F/S NAME ON DISMOUNT COMMAND

ERR303:	MOVEI	M,[ASCIZ . Requires /REELID.]
	JRST	ERR994

ERR311=ERR300		;ILLEGAL F/S NAME

ERR320:	MOVE	N,C
	MOVEI	M,[ASCIZ/STRUUO(.FSREM) UUO -- Error code /]
	JRST	ERR996

ERR411=ERR201		;NO F/S NAME ON REMOVE COMMAND

ERR421=ERR201		;NO F/S NAME ON LOCK COMMAND

ERR422:	MOVE	N,C
	MOVEI	M,[ASCIZ/STRUUO(.FSLOK) UUO -- Error code /]
	JRST	ERR996
;**; [165] REMOVE UNLOCK	CLRH	28-MAR-79
REPEAT	0,<			;[165] REMOVE UNLOCK
IFN FTTLAB,<
ERR423:	MOVE	N,C	;[142]
	MOVEI	M,[ASCIZ/STRUUO(.FSCLK) UUO -- Error code /]	;[142]
	JRST	ERR996	;[142]

ERR424:	;[142]
	MOVEI	M,[ASCIZ/ Structure not LOCKED by the operator/]	;[142]
	JRST	ERR994	;[142]
>;[142] END FTTLAB
>			;[165] REMOVE UNLOCK CODE

IFN FTTLAB,<
ERR450:	MOVE	N,A	;[144]
	MOVEI	M,[ASCIZ/DVPHY. UUO -- Error code /]	;[144]
	JRST	ERR996	;[144]
ERR451:	MOVE	N,A	;[144]
	MOVEI	M,[ASCIZ/TAPOP. (.TFTRK)  UUO -- Error code /]	;[144]
	JRST	ERR996	;[144]
ERR452:	MOVE	N,A	;[144]
	MOVEI	M,[ASCIZ/TAPOP. (.TFLBL)  UUO -- Error code /]	;[144]
	JRST	ERR996	;[144]
ERR453:	MOVE	N,A	;[144]
	MOVEI	M,[ASCIZ/TAPOP. (.TFSTA)  UUO -- Error code /]	;[144]
	JRST	ERR996	;[144]
>;[144] END FTTLAB

ERR500:	MOVEI	M,[ASCIZ/?Invalid job - Cancelled/]
	JRST	ERR994

ERR501==ERR200
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
ERR602:	MOVEI	M,[ASCIZ /?OMOUNT not started with "START:NEXT" , request ignored/]	;[143]
	JRST	ERR994	;[143]
ERR603:	MOVEI	M,[ASCIZ/%NEXT request out of range, request ignored/]	;[143]
	JRST	ERR994	;[143]
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND

IFN FTFACT, <
DAERR:
;**;[115] INSERT @ DAERR	JNG	20-Sep-75
IFN DBUGSW,<
	CAIN	N,6		;[115] NOT PRIVILEGED?
	POPJ	P,		;[115] YES, JUST IGNORE THAT ERROR
>;[115] END IFN DBUGSW
	MOVEI	M,[ASCIZ /%DAEMON UUO failure - Error code /]
	PJRST	MSG991		;GO TYPE ERROR MSG & OCTAL CODE
>;	END OF	IFN FTFACT

ERR510:	MOVEI	M,[ASCIZ /?Structure type does not match Homeblocks/]
	PJRST	ERR994
;HERE  (JSP A) ON'CANT HAPPEN' ERROR
NEVERR:	HRRZ	N,A	;SAVE ADDRESS FOR TYPEOUT
	MOVEI	M,[ASCIZ/?System error at loc /]
	JRST	ERR991

ERR990:	PUSHJ	P,ERRSYS
	JRST	ERR994

ERR996:	PUSHJ	P,ERRSYS	;'SYSTEM ERROR' WITH TRAILING OCTAL
ERR991:	PUSHJ	P,MSGTTY	;PRINT TRAILING OCTAL #
	PUSHJ	P,OCTPRT
	JRST	ERR995

ERR998:	PUSHJ	P,MSGTTY	;PRINT TRAILING DECIMAL #
	PUSHJ	P,DECPR3
	JRST	ERR995

ERR993:	PUSHJ	P,MSGTTY	;PRINT TRAILING SIXBIT NAME
	MOVE	M,N
	PUSHJ	P,SIXMSG
	JRST	ERR995

ERR994:	PUSHJ	P,MSGTTY
ERR995:	PUSHJ	P,CRLF
	SETOM	NOTDON		;REMEMBER NOT TO TYPE "DONE"
	JRST	FSQUIT

;ERROR RETURNS--EXIT WHEN FINISHED
;CALL WITH JSP N,...

TTYERR:	MOVEI	M,[ASCIZ/?TTY/]
	JRST	BADERR
DSKERR:	MOVEI	M,[ASCIZ /?Disk/]
	JRST	BADERR
DTERR:	MOVEI	M,[ASCIZ /?DECtape/]
BADERR:	PUSHJ	P,MSGTTY
	MOVEI	M,[ASCIZ/ error at loc /]
	PUSHJ	P,MSGTTY
	HRRZS	N
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF					
	EXIT	1,					
	EXIT						

ERRSYS:	PUSH	P,M
	MOVEI	M,[ASCIZ/
?System error -- /]					
	PUSHJ	P,MSGTTY
	POP	P,M
	POPJ	P,
;MESSAGE TYPEOUTS--POPJ WHEN FINISHED

MSG010:	MOVEI	M,[ASCIZ/?Syntax error/]
	JRST	MSG994

MSG050=MSG010	;'/' WITH NO NAME

MSG051:	MOVE	N,A
	MOVEI	M,[ASCIZ\?Undefined switch /\]
	JRST	MSG993

MSG052=MSG051	;NON-UNIQUE SWITCH

MSG200:	MOVEI	M,[ASCIZ ./H for help.]
	JRST	MSG994

MSG210:	MOVEI	M,[ASCIZ/Cmd-file author= /]
	MOVE	D,A		;GET WHOLE PPN
	JRST	MSG999

MSG211:	HLRZ	N,OWNPPN	;GET OWNER PROJ.#
	MOVEI	M,[ASCIZ\/SING or /UWLOCK requires Owner's Project --\]
MSG213:	PUSHJ	P,MSG991
	MOVEI	M,[ASCIZ/...Switch(es) ignored/]
	JRST	MSG994

MSG214:	MOVEI	M,[ASCIZ\/SINGLE not allowed in Oper. command\]
	JRST	MSG213

MSG212:	MOVEI	M,[ASCIZ/Too many drives typed--Structure has only /]
	JRST	MSG991

MSG217:	MOVE	N,DSKCHA	;PICKUP UNIT NAME  FROM DSKCHR
	MOVEI	M,[ASCIZ/?Illegal drive-- /]
	JRST	MSG993

MSG218:	MOVE	N,DSKCHA
	MOVEI	M,[ASCIZ/?Non-existent drive-- /]
	JRST	MSG993

MSG219:	MOVEI	M,[ASCIZ/No STRLST.SYS/]
	JRST	MSG994
MSG220:	MOVEI	M,[ASCIZ/...While reading STRLST.SYS/]
	JRST	MSG994

MSG221:	MOVEI	M,[ASCIZ/Wrong format version STRLST.SYS/]
	JRST	MSG994

MSG222:	MOVEI	M,[ASCIZ/Structure not in STRLST.SYS/]
	JRST	MSG994

MSG223:	MOVEI	M,[ASCIZ\Other users -- Can't /SING or /UWLOCK
...Switch(es) ignored\]
	JRST	MSG994

MSG224:	MOVEI	M,[ASCIZ/Structure is write-locked for all jobs/]
	JRST	MSG994

MSG225:	TRO	F,OB.PRO
	MOVEI	M,[ASCIZ\...Assume /WLOCK\]
	JRST	MSG994

MSG250:	MOVE	N,UDRIVE(D)	;GET DRIVE NAME
	MOVEI	M,[ASCIZ/Unavailable drive-- /]
	JRST	MSG993

MSG251:	MOVEI	M,[ASCIZ/Not enough drives -- /]
	JRST	MSGTTY

MSG252:	MOVEI	M,[ASCIZ/Free drives: /]
	PJRST	MSGTTY
MSG253:	MOVE	N,FSNAME
	MOVEI	M,[ASCIZ/Please mount /]
	JRST	MSG993

MSG254:	MOVEI	M,[ASCIZ/Write-Locked/]
	JRST	MSG994

MSG255:	MOVEI	M,[ASCIZ/Locked/]
	JRST	MSG994

MSG256:	MOVE	N,DSKCHA+.UNJOB	;THE SINGLE-ACCESSOR
	MOVEI	M,[ASCIZ/Single-access by job /]
	JRST	MSG998

MSG260:	MOVEI	M,[ASCIZ/?Can't get UFD interlock for /]
	JRST	MSG999

MSG261:	MOVEI	M,[ASCIZ/No AUXACC.SYS/]
	JRST	MSG266

MSG262:	MOVEI	M,[ASCIZ/Can't read QUOTA.SYS or AUXACC.SYS/]
	JRST	MSG266

MSG263:	MOVEI	M,[ASCIZ/QUOTA.SYS is wrong format version #/]
	JRST	MSG266

MSG264:	MOVEI	M,[ASCIZ/No entry in QUOTA.SYS or AUXACC.SYS/]
MSG266:	PUSHJ	P,MSG994
	MOVEI	M,[ASCIZ/...No UFD created/]
	JRST	MSG994

MSG270:	MOVEI	M,[ASCIZ/...While reading 1st Home Block/]
	JRST	MSG994

MSG271:	MOVEI	M,[ASCIZ/...While reading 2nd Home Block/]
	JRST	MSG994

MSG272:	MOVE	N,C
	MOVEI	M,[ASCIZ/Can't OPEN unit /]
	JRST	MSG993

MSG273:	MOVE	N,C
	MOVEI	M,[ASCIZ/Can't read unit /]
	JRST	MSG993

MSG275:	MOVEI	M,[ASCIZ/Consistancy failure/]
	JRST	MSG994

MSG276:	MOVEI	M,[ASCIZ/Home Block name = /]
	JRST	MSG993

;**; [147] INSERT AFTER MSG276+1	CLRH	10-AUG-78
MSG277:	MOVEI	M,[ASCIZ /Must refresh structure/]	;[147]
	JRST	MSG994					;[147]
IFN OFFLIN,<
MSG310:	MOVE	M,FSNAME
	MOVEI	IO,W.TTY
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ may contain STRLST.SYS/]
	PUSHJ	P,MSG994
	JRST	CKMNC5		;RETURN TO CHECK SWAPPING STATUS

;**;[111] CHANGE @ MSG311	JNG	7-Aug-75
MSG311:	PUSHJ	P,SIXMSO	;[111]
	MOVEI	M,[ASCIZ/ is off-line/]
	JRST	MSG994
>;	END IFN OFFLIN

MSG312:	MOVEI	M,[ASCIZ/Mount Count = /]
	TRO	F,OB.PRO	;SET 'ASK OPR' BIT
	JRST	MSG998

MSG313:	MOVEI	M,[ASCIZ/In System Search List/]
	JRST	MSG316

MSG314:	MOVEI	M,[ASCIZ/Contains queues ([3,3].UFD)/]
	JRST	MSG316

MSG315:	MOVEI	M,[ASCIZ/In Active Swapping List/]
MSG316:	TRO	F,OB.PRO	;SET 'CONSULT OPR' BIT
	JRST	MSG994

MSG317:	MOVEI	M,[ASCIZ/Contains STRLST.SYS/]
	JRST	MSG316

MSG320:	TRO	F,OB.PRO	;REMEMBER TO ASK OPER
	MOVE	N,FSNAME
	MOVEI	M,[ASCIZ/Requested to remove /]
	JRST	MSG993

;**; [174] INSERT BEFORE MSG330
MSG321:	PUSH	P,M			;[174] PRESERVE DRIVE NAME
	PUSHJ	P,SIXMSG		;[174] AND TYPE IT OUT
	MOVE	N,C			;[174] GET ERROR CODE FROM DISK. UUO
	MOVEI	M,[ASCIZ /DISK. UUO (.DUSWP) error code /]	;[174]
	PUSHJ	P,MSG991		;[174] TYPE OUT ERROR NUMBER
	POP	P,M			;[174] RESTORE DRIVE NAME
	POPJ	P,			;[174]

MSG330:	MOVEI	IO,W.TTY
	MOVE	M,FSNAME
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ Removed... drive(s) /]
	PJRST	MSGTTY

MSG423:	MOVEI	IO,W.TTY
	MOVE	M,FSNAME
	PUSHJ	P,SIXMSG
	MOVEI	M,[ASCIZ/ Locked/]
	JRST	MSG994

;**; [165] REMOVE UNLOCK CODE AT MSG424	CLRH	28-MAR-79
;**; [165] REMOVED BECAUSE MONITOR DOES NOT SUPPORT IT
REPEAT	0,<				;[165]
IFN FTTLAB,<
MSG424:	MOVEI	IO,W.TTY		;[142]
	MOVE	M,FSNAME		;[142]
	PUSHJ	P,SIXMSG		;[142]
	MOVEI	M,[ASCIZ/Unlocked/]	;[142]
	JRST	MSG994			;[142]
>;[142] END FTTLAB
>					;[165] END OF UNLOCK CODE REPEAT 0

MSG500:	MOVE	M,B
	CAMN	C,OURJOB	;TEST FOR ASSIGNED TO [SELF]
	JRST	MSG506		;  YES, GIVE SPECIAL MSG
	PUSHJ	P,SIXMSO
	MOVEI	M,[ASCIZ/ already assigned to job /]
	MOVE	N,C
	JRST	MSG998

MSG501:	HLLZ	M,DVVNAM
	PUSHJ	P,SIXMSO
	MOVEI	M,[ASCIZ/ has no available units/]
	JRST	MSG994


MSG503==MSG254		;WRITE-LOCKED

MSG504:	MOVEI	M,[ASCIZ/Write-Enabled/]
	JRST	MSG994

MSG505==MSG320		;REMOVE SWITCH

MSG506:	MOVE	M,B		;PUT DEVICE NAME IN RIGHT AC
	PUSHJ	P,SIXMSO	;TYPE THE DVC NAME (ASSIGNED TO OMOUNT)
	MOVEI	M,[ASCIZ / assigned to OMOUNT/] ;POINT AT MSG
	PJRST	MSG994		;GO TYPE THE MSG & RETURN

MSG600:	MOVEI	M,[ASCIZ/%DEFER time too large - 0 assumed/]
	PJRST	MSG994
MSG701:	MOVEI	M,[ASCIZ/Not available/]
	JRST	MSG994

MSG702:	MOVEI	M,[ASCIZ/Not a DECtape/]
	JRST	MSG994

MSG703:	MOVEI	M,[ASCIZ/Not a device/]
	JRST	MSG994

MSG800:	MOVEI	M,[ASCIZ /Not processing commands/] ;POINT AT MSG
	SKIPN	A,MODE		;TEST FOR IDLE MODE
	JRST	MSG994		;  YES, GO TYPE IT
	MOVEI	M,[ASCIZ /No /]	;POINT AT MSG
	SKIPN	PRVFND		;TEST FOR COMMANDS WAITING
	SKIPE	PRCFLG		;TEST FOR PROCESSING A COMMAND
	SKIPA			;  SKIP IF COMMANDS WAITING, OR NOW PROCESSING
	PUSHJ	P,MSGTTY	;  NO, THEN TYPE 'NO'
	MOVE	M,[[ASCIZ /FILE /]
		   [ASCIZ /MOUNT /]
			0	 ]-1(A) ;GET ADDR OF PROPER MSG
	SKIPE	M		;TEST FOR ANYTHING TO TYPE
	PUSHJ	P,MSGTTY	;  YES, TYPE IT
	MOVEI	M,[ASCIZ /Commands Waiting/] ;POINT AT REST OF MSG
	JRST	MSG994

MSG801:	MOVEI	M,[ASCIZ /Waiting on Operator input/] ;POINT AT MSG
	JRST	MSG994		;GO TYPE IT & RETURN

MSG802:	MOVEI	M,[ASCIZ /?Can't START, No Structure for CMD Files/]
	JRST	MSG994

NEVMSJ:	MOVE	N,(P)
NEVMSG:	HRRZS	N
	MOVEI	M,[ASCIZ/?System error at loc /]
;	JRST	MSG991

MSG991:	PUSHJ	P,MSGTTY	;PRINT TRAILING OCTAL
	PUSHJ	P,OCTPRT
	PJRST	CRLF

MSG993:	PUSHJ	P,MSGTTY	;PRINT TRAILING SIXBIT
	MOVE	M,N
	PUSHJ	P,SIXMSO
	PJRST	CRLF

MSG994:	PUSHJ	P,MSGTTY
	PJRST	CRLF

MSG998:	PUSHJ	P,MSGTTY	;PRINT TRAILING DECIMAL
	PUSHJ	P,DECPRT
	PJRST	CRLF

MSG999:	PUSHJ	P,MSGTTY
	HLRZ	N,D
	PUSHJ	P,OCTPRT
	PUSHJ	P,COMMA
	HRRZ	N,D
	PUSHJ	P,OCTPRT
	PJRST	CRLF
SUBTTL	SUBROUTINES - COMMAND SCANNING
;SUBROUTINE TO DO A DSKCHR UUO
;CALL	A=F/S OR UNIT NAME
;RET+0	UUO ERROR RETURN
;RET+1	A=DSKCHR AC

DSKUUO:	MOVEM	A,DSKCHA
	MOVE	A,[XWD DSKCHL,DSKCHA]
	DSKCHR	A,PHONLY
	  POPJ	P,
	JRST	CPOPJ1

;SUBROUTINE TO READ A /VID SWITCH
;ALWAYS SKIP RETURNS

VIDIN:	TRO	F,SB.VID
	SETZM	VIDK
	CAIE	CH,":"	;FOLLOWED BY TEXT?
	JRST	CPOPJ1		;NO-THATS ALL
	MOVNI	A,VIDMAX
	MOVE	B,[POINT 7,VID]
	TLZ	F,L.VIDT
	PUSHJ	P,(IO)
	  JRST	VIDIN4
	CAIE	CH,VIDCH1	;IS IT '?
	CAIN	CH,VIDCH2	;OR IS IT "?
	 SKIPA	C,CH		;YES
	JRST	VIDIN6
	TLO	F,L.VIDT
	JRST	VIDIN3
VIDIN2:	PUSHJ	P,(IO)
	  JRST	VIDIN4
VIDIN6:	CAIL	CH,"0"	;DIGITS ARE LEGAL
	CAILE	CH,"9"
	CAIN	CH,"-"	;HYPHEN IS LEGAL
	JRST	VIDIN3
	CAIL	CH,"A"	;LETTERS ARE LEGAL
	CAILE	CH,"Z"
	CAIN	CH,"."	;PERIOD IS LEGAL
	JRST	VIDIN3
	CAILE	CH,15
	TLNN	F,L.VIDT
	JRST	VIDIN4
	CAME	CH,C		;IS THIS END OF QUOTED STRING
	JRST	VIDIN3
	AOSLE	A
	TDZA	A,A
	IBP	B
	DPB	CH,B
	PUSHJ	P,(IO)
	  JRST	VIDIN4
VIDIN4:	ADDI	A,VIDMAX	;FINISHED-COUNT CHARACTERS
	MOVEM	A,VIDK
	JRST	CPOPJ1
VIDIN3:	JUMPGE	A,VIDIN2	;DONT OVERUN BUFFER
	IDPB	CH,B
	AOJA	A,VIDIN2

;HERE TO READ A REELID 

IFE FTTLAB,<

RIDIN:	CAIE	CH,":"		;ANY VALUE?
	 JRST	CPOPJ1		;NO, IGNORE
	PUSHJ	P,(IO)		;READ SWITCH
	 JRST	CPOPJ1		;
	PUSHJ	P,SIXIN
	JUMPE	A,CPOPJ1
	MOVEM	A,REELID
	JRST	CPOPJ1
>;END IFE FTTLAB

IFN FTTLAB,<
RIDIN:	CAIE	CH,":"	;ANY VALUE
	  JRST	CPOPJ1		;NO, IGNORE
	PUSHJ	P,(IO)		;GET NEXT CHARACTER
	  JRST	CPOPJ1		;SOMETHING IS WRONG, IGNORE
	CAIE	CH,"("		;IS IT A LIST
	  JRST	CPOPJ1		;MUST BE WRONG UMOUNT, IGNORE
	SETZ	A,		;CLEAR COUNT OF REELIDS
RIDIN1:	MOVEI	B,6		;LENGTH OF A REELID
	MOVE	BP,[POINT 8,REELID(A)] ;WHERE TO STORE THIS ONE
RIDIN2:	PUSHJ	P,(IO)		;GET NEXT CHARACTER
	  JRST	CPOPJ1		;SHOULD NEVER HAPPEN
	CAIN	CH,","		;END OF THIS REELID?
	  JRST	RIDIN3		;YUP, SET UP FOR NEXT
	CAIN	CH,")"		;END OF LIST?
	  JRST	RIDIN5		;YES, FINISH UP
	SOSL	B		;COUNT CHARS SEEN SO FAR
	  IDPB	CH,BP		;SAVE CHARACTERS FOR PULSAR
	JRST	RIDIN2		;LOOP FOR MORE CHARACTERS
RIDIN3:	JUMPLE	B,RIDIN4	;STORE 6 OR MORE CHARACTERS?
	MOVEI	CH," "		;NO, PAD WITH BLANKS
	IDPB	CH,BP		;STORE A BLANK
	SOJA	B,RIDIN3	;COUNT CHAR AND KEEP PADDING
RIDIN4:	ADDI	A,2		;ACCOUNT FOR THIS REELID
	JRST	RIDIN1		;LOOP FOR NEXT REELID
RIDIN5:	JUMPLE	B,RIDIN7	;GO ON IF LAST REELID WAS 6 CHARS
	MOVEI	CH," "		;GET A BLANK
	IDPB	CH,BP		;SAVE IT
	SOJG	B,.-1		;UNTIL ALL PADDED OUT TO 6 CHARS
RIDIN7:	ADDI	A,2		;ACCOUNT FOR LAST REELID
	MOVEM	A,NVOLS		;SAVE NUMBER OF VOLUMES
	PJRST	(IO)		;GET NEXT CHAR AND RETURN

;HERE TO READ /EXPIRE SWITCH
MOSEXP:	CAIE	CH,":"		;ANY VALUE?
	  JRST	CPOPJ1		;NO, IGNORE
	PUSHJ	P,SDECIN	;READ WHERE TO GO
	JUMPLE	N,CPOPJ1	;BAD VALUE
	MOVEM	N,EXPDAT	;SAVE AS EXPIRATION DATE FOR PULSAR
	JRST	CPOPJ1		;RETURN

;HERE TO READ /POSITION SWITCH
MOSPOS:	CAIE	CH,":"		;ANY VALUE?
	  JRST	CPOPJ1		;NO, IGNORE SWITCH
	PUSHJ	P,SDECIN	;READ THE VALUE
	JUMPLE	N,CPOPJ1	;IGNORE BAD VALUES
	MOVEM	N,LABPOS	;SAVE FOR PULSAR MESSAGE
	JRST	CPOPJ1		;RETURN

;HERE TO READ /LABELS SWITCH
MOSLAB:	CAIE	CH,":"		;ANY VALUE?
	  JRST	CPOPJ1		;NO, IGNORE SWITCH
	PUSHJ	P,SOCTIN	;READ THE VALUE
	JUMPL	N,CPOPJ1	;BAD VALUE -- IGNORE
	MOVEM	N,LABTYP	;SAVE AS LABEL TYPE
	JRST	CPOPJ1		;RETURN

;HERE TO READ /PROTECT SWITCH
MOSPRO:	CAIE	CH,":"		;ANY VALUE?
	  JRST	CPOPJ1		;NO, IGNORE SWITCH
	PUSHJ	P,SOCTIN	;READ THE VALUE
	JUMPL	N,CPOPJ1	;BAD VALUE -- IGNORE
	MOVEM	N,PROTEC	;SAVE AS PROTECTION
	JRST	CPOPJ1		;RETURN

>;END IFN FTTLAB
;SUBROUTINE TO READ SWITCHES
;CALL	IO=READER ADDRESS (PRESERVED)
;	D=ADDR. OF: XWD  DISPATCH-TABLE,NAME-TABLE
;RET+0	ERROR--UNDEF. OR NON-UNIQUE SWITCH OR POPJ FROM SWITCH ROUTINE
;RET+1	NORMAL RETURN

SWITCH:	HRRZ	B,(D)		;SWITCB=OFFSET TO BITS TABLE
	MOVNM	B,SWITCB
	HLRZ	B,(D)
	ADDM	B,SWITCB
	MOVE	E,(D)
	SETZM	A

SWITC2:	MOVE	B,E
	PUSHJ	P,SST		;IGNORE BLANKS
	CAIE	CH,"/"		;SLASH?
	JRST	CPOPJ1		;NO--THATS ALL
	PUSHJ	P,(IO)		;YES-BUMP PAST IT
	  MOVEI	CH,32		;EOF
	PUSHJ	P,SIXIN		;GET NAME (RET'D IN A)
	JUMPE	A,MSG050	;ERROR IF NO NAME
	PUSHJ	P,NAMLUK	;LOOK UP THE NAME
	  JUMPN	B,MSG051	;JUMP IF 'NOT UNIQUE'
	JUMPE	B,MSG052	;JUMP IF 'NOT FOUND'

SWITC3:	ADD	B,SWITCB	;ADDRESS DISP. TABLE
	PUSHJ	P,@(B)		;DISPATCH
	  POPJ	P,	;PASS ERROR RETURN ALONG
	JRST	SWITC2

	U(SWITCB)

;SUBROUTINE TO READ AND LOOKUP NAME IN TABLE
;CALL	B=TABLE ADDRESS
;RET+1	A=0:     NO NAME TYPED
;	A NOT 0:
;		B=0:    NAME NOT FOUND
;		B NOT 0:NAME NOT UNIQUE
;RET+2	NAME FOUND & UNIQUE, B=TABLE DISPLACEMENT

TABLUK:	MOVEI	IO,R.TTY
	PUSHJ	P,SSST
TABLU0:	MOVEI	IO,R.TTY
	PUSHJ	P,SIXIN
	JUMPE	A,CPOPJ	;RET+1 A=0 IF NOTHING TO READ
	MOVE	D,B
	PUSHJ	P,NAMLUK
	  POPJ	P,		;PASS ON ERROR RETURN
	HRRZS	B
	SUB	B,D
	JRST	CPOPJ1		;RET+2 WITH DISP. IN B
;SUBROUTINE TO LOOKUP A NAME IN A TABLE
;
;CALL	A=SIXBIT NAME
;	B=ADDRESS OF NAME TABLE
;RET+0	B=0:	NOT FOUND
;	B.NE.0:	NOT UNIQUE--NO EXACT MATCH AND MULTIPLE PARTIAL MATCHES
;		RH(B)=ADDRESS OF 1ST PARTIAL MATCH
;RET+1	RH(B)=ADDRESS OF MATCH (EXACT OR UNIQUE PARTIAL)
;
;	USES C,LH(B)   PRESERVES A

NAMLUK:	SETZM	NAMLUT
NAMLU1:	PUSHJ	P,NAMCOM	;FIND A MATCH
	  JRST	NAMLU2		;END OF TABLE
	CAMN	A,(B)		;EXACT MATCH?
	JRST	CPOPJ1		;YES-RETURN IT
	SKIPE	C,NAMLUT	;NO--
	TLOA	C,-1		;   REMEMBER IF MORE THAN ONE PARTIAL
	HRRZ	C,B		;   AND 1ST ONE
	MOVEM	C,NAMLUT
	AOJA	B,NAMLU1

NAMLU2:	SKIPG	B,NAMLUT	;WAS THERE 1 & ONLY 1 PARTIAL MATCH?
	POPJ	P,		;NO--RET+0
	JRST	CPOPJ1		;YES-RET+1

	U(NAMLUT)

;SUBROUTINE TO COMPARE A NAME TO A TABLE & RETURN PARTIAL OR EXACT
;   MATCHES
;
;CALL	A=SIXBIT NAME
;	B=ADDRESS OF 1ST NAME-TABLE ENTRY TO TRY
;		(0 ENTRY SIGNALS END OF TABLE)
;RET+0	NO MATCH (PARTIAL OR EXACT)
;RET+1	RH(B)=ADDRESS OF 1ST MATCH (PARTIAL OR EXACT)

NAMCOM:	JUMPE	A,CPOPJ		;NULL NEVER MATCHES
	SETO	C,
NAMCO1:	LSH	C,-6		;MAKE MASK FOR A IN C
	TDNE	A,C
	JRST	NAMCO1
	SETCAM	C,NAMCOT

NAMCO2:	SKIPN	C,(B)		;END OF TABLE?
	POPJ	P,		;YES-RET+0
	AND	C,NAMCOT	;NO--MASK TABLE ENTRY
	CAME	C,A		;=A?
	AOJA	B,NAMCO2	;NO--CONTINUE
	JRST	CPOPJ1		;YES-RET+1

	U(NAMCOT)
;SUBROUTINE TO READ LIST OF SIXBIT NAMES
;   MUST BE DELIMITED BY COMMAS AND ENCLOSED BY PARENS
;
;CALL	IO=READER ADDRESS
;	B=XWD -LENGTH,NAMES   WHERE TO PUT NAMES FOUND
;RET+0	SYNTAX ERROR OR LIST TOO LONG
;RET+1	'PROCEED' RETURN--LIST NOT NECESSARILY FOUND

SIXLIS:	HRRZ	C,B		;REMEBER B FOR NAME COUNT
	PUSHJ	P,SST		;IGNORE LEADING BLANKS/TABS
	CAIE	CH,"("		;(?
	JRST	SIXLI3		;NO--NOT A LIST THEN
	SUB	B,[XWD 1,1]	;YES-MAKE LEADING AOBJ PTR

SIXLI2:	PUSHJ	P,SSIXIN	;GET A NAME
	AOBJP	B,ERR040	;ERROR IF LIST TOO LONG
	MOVEM	A,(B)		;STORE NAME (OR 0 IF LONE COMMA)
	PUSHJ	P,SST		;IGNORE SOME BLANKS
	CAIN	CH,","		;,?
	JRST	SIXLI2		;YES-GET NEXT NAME
	CAIE	CH,")"		;NO--CLOSING ) ?
	JRST	ERR041		;NO--SYNTAX ERROR
	PUSHJ	P,SSST		;YES-BUMP PAST )
SIXLI3:	SUBI	B,-1(C)		;CALC. NUM NAMES SEEN
	HRRZS	B
	JRST	CPOPJ1

;SUBROUTINE TO READ SWITCHES &  DEV. NAME OPTIONALLY FOLLOWED BY A COLON
;CALL	D=SWITCH TABLE ADDRESS (SEE SWITCH)

COMNAM:	PUSHJ	P,SWITCH	;GET SWITCHS IF ANY
	 JRST	FSQUIT		;SWITCH ERROR
	PUSHJ	P,SIXIN		;GET NAME
	CAIE	CH,":"
	POPJ	P,
	PUSHJ	P,(IO)
	  MOVEI	CH,32	;EOF
	POPJ	P,
SUBTTL	SUBROUTINES - MORE FILE STRUCTURE HANDLING
;SUBROUTINE TO PRINT LIST OF UNIT I.D.'S AND  DRIVES
;CALL	PDRIVE=LIST IF DRIVE NAMES
;	UNITID=LIST OF UNIT I.D.'S
;	FSUAOB=AOBJ PTR FOR THE ABOVE

PRTUNI:	MOVE	D,FSUAOB	;AOBJ PTR
	MOVEI	IO,W.TTY
PRTUN0:	MOVE	M,UNITID(D)	;TYPE UNIT ID
	PUSHJ	P,SIXMSO
	PUSHJ	P,TAB
	MOVE	M,PDRIVE(D)	;TYPE SUGGESTED DRIVE
	PUSHJ	P,SIXMSO
	PUSHJ	P,CRLF
	AOBJN	D,PRTUN0	;LOOP
	POPJ	P,
;SUBROUTINE TO GET HOME BLOCK
;CALL	FSLUN=LOG.UNIT NUM.
;RET+0	I/O ERRORS--MESSAGE HAS BEEN TYPED
;RET+1	OK

GETHOM:	MOVEI	B,HOMEB1	;TRY 1ST HOME BLOCK 1ST
	PUSHJ	P,GETHO
	  SKIPA			;ERROR--TRY 2ND BLOCK
	JRST	CPOPJ1		;GOT IT --RET+1
	PUSHJ	P,MSG270	;TYPE 'WHILE READING 1ST HOME BLOCK'
	MOVEI	B,HOMEB2
	PUSHJ	P,GETHO
	  PJRST	MSG271		;ERROR 'WHILE READING 2ND HOME BLOCK'
	JRST	CPOPJ1		;OK RETURN IF GOT 2ND HOME BLOCK

GETHO:	MOVE	A,[IOWD 200,HOME] ;PUT HOME BLOCK IN 'HOME'
	MOVE	C,FSLUN	;USE CURRENT UNIT.NO.
	PUSHJ	P,GETUNB
	  POPJ	P,		;PASS ERRROR RETURN ALONG
	MOVS	A,HOME+HOMNAM	;DO NAME AND CODE CHECK?
	MOVE	B,HOME+HOMCOD
	CAIN	A,(SIXBIT /HOM/)
	CAIE	B,CODHOM
	PJRST	MSG275		;NO--TYPE'NAME OR CODE FAILURE'
;**; [147] INSERT AT GETHO + 10 1/2	CLRH	10-AUG-78
	SKIPE	HOME+HOMREF	;[147] MUST REFRESH FLAG SET?
	 PJRST	MSG277		;[147] YES, ERROR (MUST REFRESH)
	AOS	(P)		;YES--GOOD, RETURN+1
	POPJ	P,
;SUBROUTINES TO READ A BLOCK
;CALL	GETFSB	A=CORE ADDRESS IOWD
;		B=LOG.BLOCK.NUM. WITHIN FS.
;		---EXPECTS FSBPU='NOMINAL'BLOCKS/UNIT---
;	GETUNB	A=CORE ADDRESS IOWD
;		B=LOG.BLOCK NUM. WITHIN UNIT
;		C=LOG.UNIT NUM.
;RET+0	I/O ERROR--MESSAGE TYPED
;RET+1	OK

GETFSB:	IDIV	B,FSBPU	;MAKE UNIT & UNIT BLK. FROM FS. BLK.
	EXCH	B,C

GETUNB:	MOVE	C,PDRIVE(C)	;C=PHYS.DRIVE NAME
	MOVEM	B,FSTEMP
	MOVE	B,[PHOPEN,,16]	;FOR DUMP MODE		
	SETZ	D,
	OPEN	CH.FS,B		;OPEN THE UNIT
	  PJRST	MSG272		;TYPE 'CANT OPEN UNIT ...' & RET+0
	MOVSI	B,400000	;SET UP SUSET. FOR INPUT
	MOVEI	C,CH.FS		;CHANNEL
	DPB	C,[POINT 4,B,12]
	IOR	B,FSTEMP	;BLOCK NUMBER
	SUSET.	B,
	 USETI	CH.FS,FSTEMP	;SET BLK. NUM.
	SETZ	B,		;A,B=CHAN.COMMAND LIST FOR IN
	IN	CH.FS,A		;INPUT THE BLOCK
;**; [152] CHANGE AT GETUNB+16	CLRH	14-NOV-78
;[152]	JRST	CPOPJ1		;GOT IT--RET+1
;[152]	  PJRST	MSG273		;TYPE 'CANT READ UNIT ...' & RET+0
	JRST	[RELEAS	CH.FS,	;[152] RELEASE CHANNEL NOW
		JRST	CPOPJ1]	;[152] GOT IT -- RETURN +1
	RELEAS	CH.FS		;[152] RELEASE CHANNEL
	PJRST	MSG273		;[152] TYPE 'CANT READ UNIT ...' & RET +0
;SUBROUTINE TO MOVE VALUES INTO PARAMENTER BLOCKS
;CALL	B=XWD -LENGTH,ADDRESS  OF TRANSFER TABLE
;	C=ADDRESS OF PARAM. BLOCK
;RET+0	ALWAYS
;	C IS PRESERVED
;
;TRANSFER TABLE ENTRIES ARE XWD ADDRESS,DISPLACEMENT
;   WHERE ADDRESS=ADDRESS CONTAING VALUE (FETCH)
;   AND DISPLACEMENT= DISP. ON B INTO PARAMENTER TABLE (STORE)

MOVALU:	MOVS	A,(B)
	MOVE	A,(A)
	HRRZ	D,(B)
	ADD	D,C
	MOVEM	A,(D)
	AOBJN	B,MOVALU
	POPJ	P,


;TRANSFER TABLE FOR STR PARAMENTERS (STRUUO(.FSDEF))

FSXSTR:	XWD	FSNAME,SS.NAM
	XWD	FSUNM,SS.UNM
	XWD	HOME+HOMGAR,SS.GAR
	XWD	HOME+HOMOVR,SS.OVR
	XWD	HOME+HOMPT1,SS.PT1
	XWD	HOME+HOMUN1,SS.UN1
	XWD	FSTRY,SS.TRY
	XWD	HOME+HOMBSC,SS.BSC
	XWD	HOME+HOMSCU,SS.SCU
	XWD	HOME+HOMCNP,SS.CNP
	XWD	HOME+HOMCKP,SS.CKP
	XWD	HOME+HOMCLP,SS.CLP
	XWD	HOME+HOMPVS,SS.PVS
	XWD	OWNPPN,SS.PPN
	XWD	HOME+HOMCNP,FSCNP-FSASTR	;ALSO SETUP FSCNP
	XWD	HOME+HOMCLP,FSCLP-FSASTR	;   AND FSCLP
FSXSTL==.-FSXSTR
;TRANSFER TABLE FOR UNIT PARAMETER BLOCKS (STRUUO(.FSDEF))

FSXUNI:	XWD	HOME+HOMHID,SU.HID
	XWD	HOME+HOMLUN,SU.LUN
	XWD	HOME+HOMGRP,SU.GRP
	XWD	HOME+HOMBPC,SU.BPC
	XWD	HOME+HOMSIC,SU.SIC
	XWD	HOME+HOMSPU,SU.SPU
	XWD	FSDES,SU.DES
	XWD	HOME+HOMSLB,SU.SSB	;[177] START OF SWAP SPACE
	XWD	HOME+HOMK4S,SU.SKS	;[177] SIZE OF SWAP SPACE
	XWD	HOME+HOMSUN,SU.SUN	;[200] LOGICAL UNIT IN ACTIVE SWAP
FSXUNL==.-FSXUNI

;TRANSFER TABLE TO SETUP FOR STRUUO(.FSRDF)

FSXRDF:	XWD	[.FSRDF],0
	XWD	FSJOB,1
	XWD	FSPPN,2
	XWD	FSNAME,3
	XWD	FSDES,4
FSXRDL==.-FSXRDF
;SUBROUTINE TO COUNT 0 BITS
;CALL	D=AOBJ PTR TO WORDS WHOSE BITS TO COUNT
;RET+0	ALWAYS--A=NO. OF 0 BITS

ZBITS:	TDZA	A,A		;COUNT BITS IN A
ZBITS1:	AOBJP	D,CPOPJ	;BUMP WD PTR
	SETCM	B,(D)		;GET COMP. OF WORD
	JUMPE	B,ZBITS1	;SKIP WDS WITH ALL 1'S

ZBITS2:	SETCA	B,		;COUNT LEADING 0'S
	JFFO	B,ZBITS3
	ADDI	A,^D36		;MUST HAVE BEEN ALL 0'S
	JRST	ZBITS1
ZBITS3:	SETCA	B,
	ADDI	A,(C)		;ADD COUNT TO A
	LSH	B,(C)		;SHIFT OFF 1'S
	JFFO	B,ZBITS4
	JRST	ZBITS1		;FINISHED WITH THIS WORD
ZBITS4:	LSH	B,(C)
	JRST	ZBITS2
;CONSTANT STORAGE

;ARG.LIST FOR STRUUO--.FSDEF FUNCTION

FSARG:	.FSDEF
	XWD	SS.L,FSASTR	;PTR. TO STR PARAMETER BLOCK
REPTEM==FSAUNI			;PTRS. TO UNIT PARAMETER BLOCKS
				;   LEAVE ROOM FOR SPT TABLE AFTER
				;   EVERY PARAMETER BLOCK
REPEAT	MAXUNI,<
	XWD	SU.L,REPTEM
	REPTEM==REPTEM+SU.L+MAXSPT>

FSTAL:	POINT	TALSIZ,(D),TALPOS	;SPT FREE CLUSTER TALLY FIELD
FSCLA:	POINT	CLASIZ,(D),CLAPOS	;"""CLUSTER ADDRESS"""
;SUBROUTINE TO CREATE THE COMMAND-FILE UFD
;CALL	CMDSTR=CMD F/S
;	CMDPPN=CMD PPN
;	MFDPPN=MFD PPN
;RET+0	ALWAYS

MAKCMU:	MOVE	C,CMDSTR	;GET UFD INTERLOCK
	MOVE	D,CMDPPN
	PUSHJ	P,UFDLOK
	MOVE	B,CMDSTR	;HERE FOR LEVEL-D
	MOVE	A,CMDPPN
	PUSHJ	P,GETQUO	;GET CMD QUOTAS
	  SKIPA
	JRST	MAKCM2
	MOVEI	B,^D1000	;DEFAULTS IF NO QUOTA.SYS
	MOVEI	C,^D1000
	MOVEI	D,^D1000
MAKCM2:	MOVEI	N,777		;PRIV.
	MOVE	N1,MFDPPN
	MOVE	M,CMDSTR
	MOVE	A,CMDPPN	;RESTORE COMMAND PPN
	MOVEI	IO,W.TTY
	PUSHJ	P,UFDSET
	  JRST	MAKCM3		;CANT
	MOVE	C,CMDSTR	;RETURN UFD INTERLOCK
	MOVE	D,CMDPPN
	PUSHJ	P,UFDUNL
	POPJ	P,

MAKCM3:	MOVE	C,CMDSTR	;RETURN UFD INTERLOCK AND GIVE ERROR MSG
	MOVE	D,CMDPPN
	PUSHJ	P,UFDUNL
	JRST	ERR100
;SUBROUTINE TO MAKE USER UFD
;CALL	A=UFD PPN
;	B=F/S NAME
;RET+0	NO UFD CREATED
;	LEVEL-D: A=0 IF BECAUSE NO QUOTA.SYS ENTRY
;	         A NOT= 0 IF OTHER REASONS
;RET+1	UFD CREATED

MAKUFD:	MOVEM	A,UFDPP
REPEAT 0, <
;  CHECK FOR 'DSKB0' (F/S UNIT) & CONVERT TO 'DSKB' (F/S NAME)
MKUF1A:	MOVE	A,B		;COPY THE F.S NAME
	PUSHJ	P,DSKUUO	;GO DO A DSKCHR
	  JRST	MAKUFR		;  NOT A DISK, GIVE ERROR
	LDB	A,DCHCOD	;GET THE TYPE OF DISK
	CAIN	A,2		;TEST FOR F/S
	JRST	MKUF1C		;  YES, JUMP
	CAIE	A,3		;TEST FOR F/S UNIT
	JRST	MAKUFR		;  NO, ERROR
	MOVEI	A,000077	;GET A SIXBIT CHAR MASK
MKUF1B:	TDZE	B,A		;TEST FOR CHAR & CLEAR IT
	JRST	MKUF1A		;  FOUND ONE, REPEAT TESTS
	LSH	A,6		;MOVE THE MASK LEFT ONE CHAR
	JUMPN	A,MKUF1B	;REPEAT IF NOT DONE
	JRST	MAKUFR		;  DONE, ERROR
MKUF1C:	MOVE	A,UFDPP		;RESTORE THE PPN
>;	END	REPEAT 0
	MOVEM	B,UFDFS		; & STORE THE F/S NAME
	TRNE	F,OB.UFD	;GET INTRLOCK IF DONT HAVE IT
	JRST	MAKUF2
	MOVE	C,UFDFS
	MOVE	D,UFDPP
	PUSHJ	P,UFDLOK
	MOVE	A,UFDPP
	MOVE	B,UFDFS
	PUSHJ	P,MAKUF2	;MAKE THE UFD
	  SOS	(P)		;  OR AT LEAST TRY TO
	MOVE	N,A		;AND UNLOCK UFD IF WE LOCKED IT
	MOVE	C,UFDFS
	MOVE	D,UFDPP
	PUSHJ	P,UFDUNL
	MOVE	A,N
	JRST	CPOPJ1		;WILL SKIP OR NOT DEPENDING ON MAKUF2 RETURN ABOVE


MAKUF2:	PUSHJ	P,GETQUO	;GET USERS QUOTAS
	  JRST	MAKUF3		;NO QUOTAS
	MOVE	M,UFDFS		;F/S NAME
	MOVE	A,UFDPP		;PPN
	SETZM	N		;STANDARD PRIV.
	MOVE	N1,MFDPPN	;MFD PPN
	MOVEI	IO,W.TTY	;MESSAGE WRITER
	PUSHJ	P,UFDSET
MAKUFR:	  TLOA	A,-1		;GIVE NON-0 ERROR RETURN
	JRST	CPOPJ1
	POPJ	P,

MAKUF3:	SETZM	A		;GIVE 0 ERROR RETURN
	POPJ	P,

	U(UFDFS)
	U(UFDPP)
SUBTTL	SUBROUTINES - MORE COMMAND SCANNING
;HANDY-DANDY SUBRS GO ON AND ON

DTDCNT:	MOVEI	N,0		;THIS ROUTINE COUNTS BLOCKS
	MOVNI	N1,1103		;ALLOCATED TO FILE (D) IN DTDIR
	MOVE	BP,[POINT 5,DTDBYT]	;ANSWER IN N.
DTDCL:	ILDB	CH,BP
	CAIN	CH,0(D)
	ADDI	N,1
	AOJL	N1,DTDCL
	POPJ	P,0

DATOUT:	IDIVI	A,^D12*^D31
	IDIVI	B,^D31
	MOVEI	N,1(C)
	PUSHJ	P,DECPR2
	MOVE	M,MONTAB(B)
	PUSHJ	P,SIXMS4
	PUSHJ	P,DASH
	MOVEI	N,^D64(A)
	PUSHJ	P,DECPRT
	POPJ	P,0

MONTAB:	SIXBIT /-JAN/
	SIXBIT /-FEB/
	SIXBIT /-MAR/
	SIXBIT /-APR/
	SIXBIT /-MAY/
	SIXBIT /-JUN/
	SIXBIT /-JUL/
	SIXBIT /-AUG/
	SIXBIT /-SEP/
	SIXBIT /-OCT/
	SIXBIT /-NOV/
	SIXBIT /-DEC/
	EXP	0		;PUT IN STOPPER TO USE FOR TABLE LOOKUP

MINOUT:	IDIVI	A,^D60
	MOVE	N,A
	PUSHJ	P,DECPR2
	PUSHJ	P,COLON
	MOVE	N,B
	PUSHJ	P,DECPR2
	POPJ	P,0
IFN FILESW,<
;SUBRS TO GET FILE NAME FROM COMMAND

NXTFIL:	TLNE	F,L.WFIL+L.WEXT
	JRST	REWILD
	SETZM	FILNAM
	SETZM	FILEXT
	SETZM	FILDEV
	SETZM	FILPPN		;CLEAR FILE PPN
	SETOM	FILMSK		;SET FILE MASK TO ALL 1'S
	MOVSI	A,-1		;GET -1,,0 IN AC
	MOVEM	A,EXTMSK	;SET EXT MASK TO ALL 1'S IN L.H.
	SETZM	TSTNAM		;CLEAR MASKED NAME
	SETZM	TSTEXT		;CLEAR MASKED EXTENSION
	SETZM	WLDFND		;SHOW NO WILD-CARD FILE FOUND
	MOVE	CH,TERMCH
	CAIGE	CH,40
	CAIN	CH,11
	SKIPA
	POPJ	P,0
NXTFLP:				;HERE TO SCAN FOR A FILE SPEC
	PUSHJ	P,SSIXBR
	MOVEM	CH,TERMCH
	CAIN	CH,"/"		;TEST FOR A SWITCH (/AFTER)
	JRST	NXTFI7		;  YES, GO PROCESS IT
;**; [162] CHANGE AT NXTFLP+4	CLRH	4-JAN-79
	JUMPE	A,CPOPJ		;[162] NO FILE FOUND
;[162]	JUMPE	A,CPOPJ1
	CAIN	CH,":"
	JRST	NXTFI2
	MOVEM	A,FILNAM	;STORE AS FILE NAME
	PUSHJ	P,SETMSK	;CALL TO COMPUTE WILD-CARD MASKS
	  TLO	F,L.WFIL	;  WILD, SET A BIT TO REMEMBER
	MOVEM	A,TSTNAM	;STORE MASKED NAME FOR TESTING
	MOVEM	B,FILMSK	;STORE MASK FOR FILE NAME
	CAIE	CH,"."
	JRST	NXTFI1
	PUSHJ	P,SSIXBR
	MOVEM	CH,TERMCH
	HLLZS	A		;CLEAR R.H. OF EXTENSION
	MOVEM	A,FILEXT	;STORE FILE EXTENSION
	PUSHJ	P,SETMSK	;CALL TO CHECK FOR WILD-CARD
	  TLO	F,L.WEXT	;  WILD, SET A BIT TO REMEMBER
	HLLZM	A,TSTEXT	;STORE MASKED EXTENSION
	HLLZM	B,EXTMSK	;STORE MASK FOR EXT
NXTFI1:	CAIE	CH,"["		;TEST FOR PPN COMING
	JRST	NXTFI3		;  NO, JUMP
	PUSHJ	P,SOCTIN	;READ THE PROJECT #
	MOVSM	N,FILPPN	; & STORE IT IN L.H.
	PUSHJ	P,SOCTIN	;READ THE PROGRAMMER #
	HRRM	N,FILPPN	; & STORE IT IN R.H.
	PUSHJ	P,SSST		;READ 'TIL NEXT DELIMITER
	MOVEM	CH,TERMCH	; & STORE IT FOR LATER
NXTFI3:	SETZ	N,		;CLEAR POTENTIAL AOBJN REGISTER
	TLNE	F,L.WFIL!L.WEXT	;TEST FOR WILD FILE OR EXT
	JRST	NXTFI6		;  YES, JUMP
	TLNN	F,L.RCOM	;TEST FOR FILE R/FILE D
	JRST	CPOPJ1		;  NO, DONE NOW
	MOVSI	N,-DTDNFI	;GET AOBJN PTR TO SEARCH DIRECTORY
NXTFI4:	SKIPN	A,DTDFIL(N)	;GET NEXT FILENAME & TEST IT
	JRST	NXTFI5		;  ZERO, IGNORE
	HLLZ	B,DTDEXT(N)	;GET FILE EXTENSION
	CAMN	A,FILNAM	;TEST FOR SAME FILENAME
	CAME	B,FILEXT	;TEST FOR SAME EXTENSION
NXTFI5:	AOBJN	N,NXTFI4	;  NOT A MATCH, REPEAT
	JUMPGE	N,CPOPJ1	;FILE NOT FOUND, RETURN ANYWAY
	MOVEI	C,1		;GET A SINGLE BIT
	LSH	C,(N)		;SHIFT ACCORDINGLY
	TDOE	C,DTWTAB	;TEST FOR PREV PROCESSED
	JRST	NXTFIL		;  YES, GO GET NEXT FILE
	MOVEM	C,DTWTAB	;  NO, STORE FLAGGED WORD BACK
	JRST	CPOPJ1		;RETURN WITH NEXT FILENAME NOW
NXTFI6:	MOVSI	N,-DTDNFI		;HERE IF FILE WILD-CARDED
	TLNN	F,L.RCOM
	JRST	WWILD
WILDL1:	SKIPN	A,DTDFIL(N)
	JRST	WILDN
	HLLZ	B,DTDEXT(N)
	MOVE	C,A		;COPY FILE NAME
	AND	C,FILMSK	; & MASK IT OFF
	CAME	C,TSTNAM	;TEST FOR MASKED EQUALITY
	JRST	WILDN		;  NO, GO LOOK FOR NEXT FILE
	MOVE	C,B		;COPY FILE EXTENSION
	AND	C,EXTMSK	; & MASK IT OFF
	CAMN	C,TSTEXT	;TEST FOR MASKED EQUALITY
	JRST	WILD1		;  YES, JUMP TO PROCESS IT
WILDN:	AOBJN	N,WILDL1
WILDN1:	TLZ	F,L.WFIL+L.WEXT
	SKIPN	WLDFND		;TEST FOR WILD-CARD FILE FOUND
	JRST	CPOPJ1		;  NO, RETURN TO PRINT DIAGNOSITC
	JRST	NXTFIL

WILD1:	MOVEI	C,1		;GET A BIT IN AC
	LSH	C,(N)		;POSITION TO BIT (35-N)
	TDOE	C,DTWTAB	;TEST FOR FILE PROCESSED
	JRST	WILDN		;  YES, CONTINUE SEARCH
	MOVEM	C,DTWTAB	;  NO, REMEMBER THAT WE DID NOW
	MOVEM	A,FILNAM
	MOVEM	B,FILEXT
	MOVEM	N,STRPTR
	SETOM	WLDFND		;SHOW WILD-CARD FILE FOUND
	JRST	CPOPJ1

NXTFI2:	MOVEM	A,FILDEV
	JRST	NXTFLP

NXTFI7:	MOVEI	D,FILSWT	;POINT AT SWITCH LIST
	PUSHJ	P,SWITCH	;GO READ THE SWITCH(ES)
	  JRST	FSQUIT		;  ERROR, DONE NOW
	JRST	NXTFLP		;CONTINUE WITH THE SCAN
;MORE OF NEXT FILE FINDER WILD STUFF

REWILD:	TLNN	F,L.RCOM
	JRST	RWWILD
	MOVE	N,STRPTR
	JRST	WILDN

WWILD:	SKIPN	B,FILDEV
	MOVSI	B,(SIXBIT /DSK/)
	MOVE	A,[PHOPEN,,14]				
	MOVEI	C,RH.USR
	OPEN	USR,A
	  JSP	N,DSKERR
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1
	SKIPN	A,FILPPN	;GET FILE PPN (IF ANY) & SKIP
	MOVE	A,USRPPN
	MOVSI	B,(SIXBIT /UFD/)
	MOVEI	C,0
	MOVE	D,MFDPPN
	LOOKUP	USR,A
	 JRST	WNOUSR

RWWILD:	PUSHJ	P,R.USR
	 JRST	RWWEND
	MOVE	C,WD
	PUSHJ	P,R.USR
	 JRST	RWWEND
	HLLZ	D,WD
	SKIPN	WD,C		;GET FILE NAME & TEST IT
	JRST	RWWILD		;  NULL, GO GET ANOTHER
	AND	WD,FILMSK	;MASK OFF FILE NAME
	CAME	WD,TSTNAM	;TEST FOR MASKED EQUALITY
	JRST	RWWILD		;  NO, GO GET ANOTHER NAME
	MOVE	WD,D		;COPY FILE EXTENSION
	AND	WD,EXTMSK	; & MASK IT OFF
	CAME	WD,TSTEXT	;TEST FOR MASKED EQUALITY
	JRST	RWWILD		;  NO, GO GET ANOTHER NAME
				;  YES, FALL THRU TO PROCESS IT

WWILD1:	MOVEM	C,FILNAM
	MOVEM	D,FILEXT
	SETOM	WLDFND		;SHOW WILD-CARD FILE FOUND
	JRST	CPOPJ1

RWWEND:	RELEAS	USR,0
	JRST	WILDN1

WNOUSR:	MOVEI	M,[ASCIZ /?Can't find user's UFD on device 
/]
	PUSHJ	P,MSGTTY
	SKIPN	M,FILDEV	;DID HE SPECIFY A DEVICE
	MOVSI	M,(SIXBIT /DSK/)	;NO
	PUSHJ	P,SIXMSO
	JRST	RWWEND
;
;  SUBROUTINE TO TEST FOR WILD-CARD/CHAR IN FILE NAME/EXT
;   & TO BUILD A MASK & MASKED FILE NAME FOR TESTING
;
;	CALL:	<NAME IN AC 'A'>
;		PUSHJ	P,SETMSK
;		  <NAME IS WILD, SOMEHOW>
;		<NAME IS NOT WILD>
;
;	RETURNS MASKED NAME IN AC 'A', MASK IN AC 'B'
;	USES AC'S C,D,BP
;

SETMSK:	SETZ	B,		;ASSUME TOTALLY WILD
;**;[110] DELETE @ SETMSK+1	JNG	24-Jul-75
	MOVE	BP,[POINT 6,A]	;SET UP BYTE PTR TO INSPECT NAME
	MOVSI	D,770000	;GET MASK FOR SINGLE CHAR
SETMS1:	ILDB	C,BP		;GET NEXT CHARACTER OF THE NAME
;**;[110] INSERT @ SETMS1+1	JNG	24-Jul-75
	CAIN	C,'*'		;[110] TRAILING ASKERISK?
	JRST	SETMS2		;[110] YES, REST OF WORD IS WILD
	CAIE	C,'?'		;TEST FOR WILD CHARACTER
	IOR	B,D		;  NO, 'OR' IN MASK BITS
	LSH	D,-6		;MOVE MASK BITS RIGHTWARD 1 CHAR
	TLNE	BP,770000	;TEST FOR 6TH CHARACTER
	JRST	SETMS1		;  NO, REPEAT
SETMS2:	AND	A,B		;MASK OUT THE FILE NAME
	CAMN	B,[-1]		;TEST FOR TOTAL MASK (ALL 1'S)
	AOS	(P)		;  YES, SET SKIP RETURN
	POPJ	P,		;RETURN TO CALLER

>;	END IFN FILESW

;SUBROUTINES TO WRITE A SPECIAL CHAR(S)
;CALL	RH(IO)=WRITER ADDRESS (OR 0)

EXCLAM:	JSP	M,MSGTTY
	ASCIZ	/!/
TAB:	JSP	M,MSG
	ASCIZ	/	/
COMMA:	JSP	M,MSG
	ASCIZ	/,/
DOT:	JSP	M,MSG
	ASCIZ	/./
SPACE:	JSP	M,MSG
	ASCIZ	/ /
DASH:	JSP	M,MSG
	ASCIZ	/-/
COLON:	JSP	M,MSG
	ASCIZ	/:/
QUOTE:	JSP	M,MSG
	ASCIZ	/'/
LEFTP:	JSP	M,MSG
	ASCIZ	/(/
RIGHTP:	JSP	M,MSG
	ASCIZ	/)/
CRLF:	JSP	M,MSG
	ASCIZ	/
/
LEFTB:	JSP	M,MSG
	ASCIZ	/[/
RIGHTB:	JSP	M,MSG
	ASCIZ	/]/

;SUBROUTINE TO WRITE MESSAGE
;CALL	MSGTTY	TO FORCE TTY
;	MSG	TO USE WRITER WHOSE ADDR. IS RH(IO) -- IF 0 THEN IGNORE
;		M=ADDR. ASCIZ STRING

MSGTTY:	MOVEI	IO,W.TTY
MSG:	HRLI	M,(<POINT 7,>)
MSGL:	ILDB	CH,M
	JUMPE	CH,CPOPJ
	PUSHJ	P,0(IO)
	JRST	MSGL

CPOPJ1:	AOS	0(P)
CPOPJ:	POPJ	P,0
;SUBROUTINE TO WRITE DECIMAL NUMS.
;CALL	N=NUMBER

DECPR3:	CAIGE	N,^D100
	PUSHJ	P,SPACE
DECPR2:	MOVEI	CH,"0"
	CAIGE	N,^D10
	PUSHJ	P,0(IO)
DECPRT:	IDIVI	N,^D10
	HRLM	N1,0(P)
	SKIPE	N
	PUSHJ	P,DECPRT
	HLRZ	CH,0(P)
	ADDI	CH,"0"
	JRST	0(IO)

;SUBROUTINE TO WRITE OCTAL NUMS.
;CALL	N=NUMBER

OCTPRT:	IDIVI	N,^D8
	HRLM	N1,0(P)
	SKIPE	N
	PUSHJ	P,OCTPRT
	HLRZ	CH,0(P)
	ADDI	CH,"0"
	JRST	0(IO)

;SUBROUTINE TO WRITE SIXBIT THING
;CALL	SIXMS4	FOR 4 LEFT-MOST CHAR'S
;	SIXMSL	FOR ALL 6
;		M=SIXBIT THING
;		RH(IO)=WRITER ADDRESS (OR 0)

SIXMS4:	SKIPA	N1,[POINT 6,M,23]
SIXMSG:	MOVE	N1,[POINT 6,M,35]
	MOVE	BP,[POINT 6,M]
SIXMSL:	ILDB	CH,BP
	ADDI	CH,40
	TRNN	IO,-1
	POPJ	P,
	PUSHJ	P,0(IO)
	CAME	BP,N1
	JRST	SIXMSL
	POPJ	P,0

;SUBROUTINE TO PRINT SIXBIT & IGNORE TRAILING BLANKS
SIXMSO:	LDB	CH,[POINT 6,M,5]
	ADDI	CH,40
	PUSHJ	P,(IO)
	LSH	M,6
	JUMPN	M,SIXMSO
	POPJ	P,
;SUBROUTINE TO READ OCTAL NUMBER
;CALL	SOCTIN	IGNORE LEADING TAB/BLANK
;	OCTIN	IF 1ST CHAR. ALREADY IN CH
;		RH(IO)=READER ADDRESS
;RET+0	ALWAYS WITH N=NUMBER

SOCTIN:	PUSHJ	P,SSST
OCTIN:	PUSHJ	P,SST
	MOVEI	N,0
OCTINL:	CAIL	CH,"0"
	CAILE	CH,"7"
	POPJ	P,0
	ASH	N,3
	ADDI	N,-60(CH)
	PUSHJ	P,0(IO)
	 MOVEI CH,32		;EOF
	JRST	OCTINL

;SUBROUTINE TO READ DECIMAL NUMBER

SDECIN:	PUSHJ	P,SSST
DECIN:	PUSHJ	P,SST
	MOVEI	N,0
DECINL:	CAIL	CH,"0"
	CAILE	CH,"9"
	POPJ	P,0
	IMULI	N,^D10
	ADDI	N,-60(CH)
	PUSHJ	P,(IO)
	  MOVEI	CH,32	;EOF
	JRST	DECINL
;SUBROUTINE TO READ NAME AND CONVERT TO SIXBIT
;CALL	SSIXIN	TO IGNORE LEADING TAB/BLANK
;	SIXIN	IF 1ST CHAR. ALREADY IN CH
;		RH(IO)=READER ADDRESS
;RET+0	ALWAYS WITH SIXBIT NAME IN A (0 IF NO NAME)

SSIXIN:	PUSHJ	P,SSST
SIXIN:	PUSHJ	P,SST
	MOVEI	A,0
	MOVE	BP,[POINT 6,A]
SIXINL:	CAIL	CH,"0"
	CAILE	CH,"9"
	SKIPA
	JRST	SIXIN1
	CAIL	CH,"A"
	CAILE	CH,"Z"
	POPJ	P,
SIXIN1:	TRC	CH,40
	TLNE	BP,770000
	IDPB	CH,BP
	PUSHJ	P,0(IO)
	  MOVEI	CH,32		;EOF
	JRST	SIXINL

;SUBROUTINE TO READ FILE NAME (INCLUDING *) AND CONVERT TO SIXBIT
;CALL	RH(IO)=READER ADDRESS
;RET+0	ALWAYS WITH NAME IN A (OR 0 IF NO NAME)

SSIXBR:	PUSHJ	P,SSIXIN
	CAIE	CH,"?"		;TEST FOR WILD CHARACTER
	JRST	SSIXB2		;  NO, JUMP
SSIXB1:	PUSHJ	P,SIXIN1	;GO STORE IT & CONTINUE SCAN
	CAIN	CH,"?"		;TEST FOR ADDITIONAL WILD CHAR
	JRST	SSIXB1		;  YES, KEEP ON READING
	POPJ	P,		;  NO, RETURN TO CALLER
SSIXB2:				;HERE IF NOT WILD CHARACTER
;**;[110] DELETE @ SSIXB2	JNG	24-Jul-75
	CAIE	CH,"*"		;YES--WAS IT * ?
	POPJ	P,		;NO--RETURN BLANK
	TRC	CH,40
;**;[110] INSERT @ SSIXB2+4	JNG	24-Jul-75
	TLNE	BP,770000	;[110] DON'T DEPOSIT IF AC FULL
	IDPB	CH,BP
	PUSHJ	P,(IO)
	  MOVEI	CH,32		;EOF
	POPJ	P,
;SUBROUTINE TO IGNORE BLANKS AND TABS
;CALL	SSST	TO GET NEXT CHAR
;	SST	IF NEXT CHAR ALREADY IN CH
;RET+0	ALWAYS WITH 1ST NON-BLANK/TAB CHAR OR EOF(32) IN CH

SSST:	PUSHJ	P,0(IO)
	  MOVEI	CH,32		;EOF
SST:	JUMPE	CH,SSST
	CAIE	CH,11
	CAIN	CH,40
	JRST	SSST
	CAIN	CH,15		;IGNORE CR
	JRST	SSST
	CAIE	CH,CHRLIN		;"?
	POPJ	P,		;NO
	PUSHJ	P,(IO)		;YES-INGORE IT AND EAT BREAK CHAR.
	  MOVEI	CH,32
	CAIE	CH,33
	CAIG	CH,14
	JRST	SSST
	POPJ	P,0
SUBTTL	/DEFER:N OPERATOR REPLY & /AFTER SWITCH - PROCESSING
;
;  AFTCHK -	SUBROUTINE TO CHECK COMMAND FILE FOR /AFTER TIME
;
;		FORMAT OF THE /AFTER SWITCH IS:
;			.... /AFTER:DD-MON-YY:HH:MM
;		IT *MUST* BE THE LAST TEXT IN THE COMMAND FILE.
;
;	RETURNS: (IF SCANSW = 0)	 (IF SCANSW = -1)
;		+0 IF IN THE FUTURE	+0 IF SWITCH FOUND
;		+1 IF NOT IN THE	+1 IF SWITCH NOT FOUND
;		   FUTURE OR NOT FOUND
;

AFTCHK:	PUSHJ	P,REWCM1	;REWIND THE CMD FILE
	MOVEI	IO,R.CM1	;POINT AT I/O ROUTINE
AFTLP1:	PUSHJ	P,SSIXIN	;READ NEXT ELEMENT FROM THE FILE
AFTLP2:	CAIN	CH,32		;TEST FOR EOF
	JRST	CPOPJ1		;  YES, RETURN +1
	CAIE	CH,"/"		;TEST FOR SWITCH FOLLOWING
	JRST	AFTLP1		;  NO, KEEP ON READING
	PUSHJ	P,SSIXIN	;READ THE SWITCH VALUE
	JUMPE	A,AFTLP2	;  NULL SWITCH, KEEP ON READING
	MOVE	B,SAVD		;GET SAVED CMD-FILE TYPE
	HRRZ	B,@TYPSTB(B)	;GET ADDR OF PROPER SWITCH LIST
	PUSHJ	P,NAMLUK	;CALL TO MATCH THE SWITCH NAME
	  JRST	AFTLP2		;  NO MATCH, KEEP ON READING
	MOVE	A,(B)		;LOAD COMPLETE SWITCH VALUE FROM TABLE
	CAMN	A,[SIXBIT /VID/];TEST FOR '/VID'
	JRST	AFTVID		;  YES, GO SCAN ACROSS THE VID
	CAME	A,[SIXBIT /AFTER/];TEST FOR '/AFTER'
	JRST	AFTLP2		  ;  NO, KEEP ON READING
	SKIPE	SCANSW		;TEST TYPE OF CALL
	POPJ	P,		;  SCAN ONLY, RETURN+0 (WE FOUND IT!)
	CAIE	CH,":"		;TEST FOR VALUE FOLLOWING IT
	JRST	CPOPJ1		;  NO, RETURN+1 (NOT IN THE FUTURE)
	PUSHJ	P,SDECIN	;READ THE DAY
	MOVEM	N,AFTDAY	; & STORE IT
	CAIE	CH,"-"		;TEST FOR PROPER DELIMITER
	JRST	CPOPJ1		;  NO, RETURN+1
	PUSHJ	P,SSIXIN	;READ THE MONTH
	JUMPE	A,CPOPJ1	; & RETURN+1 IF NULL
	CAIE	CH,"-"		;TEST FOR PROPER DELIMITER
	JRST	CPOPJ1		;  NO, RETURN+1
	LSH	A,-6		;SHIFT TYPE-IN RIGHT 1 CHAR
	TLO	A,'-  '		; & FILL IN A DASH (TO MATCH 'MONTAB')
	MOVEI	B,MONTAB	;POINT AT TABLE OF SIXBIT MONTHS
	PUSHJ	P,NAMLUK	;CALL TO MATCH THE MONTH
	  JRST	CPOPJ1		;  NO MATCH, RETURN +1
	SUBI	B,MONTAB-1	;CONVERT TABLE ADDRESS TO INDEX (1-12)
	MOVEM	B,AFTMON	; & STORE IT
	PUSHJ	P,SDECIN	;READ THE YEAR
	CAIGE	N,^D1900	;TEST FOR 19XX-FORMAT YEAR
	ADDI	N,^D1900	;  NO, MAKE IT SO
	MOVEM	N,AFTYR		;STORE THE YEAR
	MOVEI	N,^D23		;GET MAXIMUM POSSIBLE HOUR
	MOVEM	N,AFTHR		; & INITIALIZE
	MOVEI	N,^D59		;GET MAXIMUM POSSIBLE MINUTE
	MOVEM	N,AFTMIN	; & INITIALIZE
	CAIE	CH,":"		;TEST FOR TIME FOLLOWING
	JRST	AFTCMP		;  NO, GO COMPARE WHAT WE ALREADY HAVE
	PUSHJ	P,SDECIN	;READ THE HOUR
	MOVEM	N,AFTHR		; & STORE IT
	CAIE	CH,":"		;TEST FOR MINUTES FOLLOWING
	JRST	AFTCMP		;  NO, GO COMPARE
	PUSHJ	P,SDECIN	;READ THE MINUTES
	MOVEM	N,AFTMIN	; & STORE IT
AFTCMP:	MOVSI	B,-AFTLTH	;GET AOBJN PTR FOR COMPARISON
AFTCM1:	MOVE	A,CURYR(B)	;GET NEXT ELEMENT FOR CURRENT DATE/TIME
	CAME	A,AFTYR(B)	;TEST WITH NEXT ELEMENT OF /AFTER DATE/TIME
	JRST	AFTCM2		;IF UNEQUAL, READY TO DECIDE ON TIME
	AOBJN	B,AFTCM1	;BUT IF =, ONLY WANT TO KEEP GOING
	JRST	CPOPJ1		;IF WENT THRU IT ALWAYS =, IT'S OK
AFTCM2:	CAML	A,AFTYR(B)	;IF CURYR(B) PAST AFTYR(B), 
	JRST	CPOPJ1		;THE TIME HAS EXPIRED; IF NOT, WAIT MORE
	RELEAS	CMD,		;RELEASE THE CMD FILE
	RELEAS	CM1,		;  DITTO
	POPJ	P,		;RETURN+0 (/AFTER TIME IN THE FUTURE)

AFTVID:	PUSHJ	P,VIDIN		;SCAN THE VID FIELD
	  JSP	A,NEVERR	;  ERROR, SHOULDN'T HAVE COME HERE
	TDZ	F,[L.VIDT,,SB.VID] ;CLEAR FLAGS THAT MIGHT HAVE BEEN SET
;**; [145] INSERT AT AFTVID+2 1/2	CLRH	19-JUN-78
	SETZM	VIDK		;[145] CLEAR VID COUNT
	JRST	AFTLP2		;GO INSPECT FINAL VID DELIMITER
;
;  GETCUR -	SUBROUTINE TO OBTAIN & SEPARATE THE CURRENT TIME-OF-DAY
;		INTO ITS CONSTITUENT PARTS OF YEAR-MONTH-DAY-HOUR-MINUTE
;

GETCUR:	DATE	A,		;READ THE CURRENT DATE
	IDIVI	A,^D31		;DIVIDE TO SEPARATE OUT THE DAY
	ADDI	B,1		;MAKE RELATIVE TO 1
	MOVEM	B,CURDAY	;STORE CURRENT DAY
	IDIVI	A,^D12		;DIVIDE TO SEPARATE OUT THE MONTH
	ADDI	B,1		;MAKE RELATIVE TO 1
	MOVEM	B,CURMON	;STORE CURRENT MONTH
	ADDI	A,^D1964	;GET ACTUAL YEAR
	MOVEM	A,CURYR		; & STORE IT
	MSTIME	A,		;GET TIME OF DAY
	IDIVI	A,^D60*^D1000	;CONVERT TO MINUTES
	PUSH	P,B		; & SAVE REMAINDER
	IDIVI	A,^D60		;SEPARATE HOURS FROM MINUTES
	MOVEM	A,CURHR		;STORE CURRENT HOUR
	MOVEM	B,CURMIN	; & CURRENT MINUTES
	POP	P,B		;RESTORE REMINDER (FRACTIONAL MINUTES)
	CAIGE	B,<^D60*^D1000>/2 ;TEST FOR .GE. 30 SECONDS
	POPJ	P,		  ;  NO, RETURN TO CALLER
	MOVEI	A,1		;GET ROUNDING CONSTANT +1 MINUTE
				;  FALL THRU TO ROUND THE CURRENT TIME

;
;  INCTIM -	SUBROUTINE TO INCREMENT THE CURRENT TIME
;		USES CURRENT TIME AS DETERMINED BY 'GETCUR'
;		INCREMENTS IT BY THE NUMBER OF MINUTES SUPPLIED
;		  IN AC 'A'
;

INCTIM:	ADDB	A,CURMIN	;UPDATE MINUTES & PUT ANSWER BOTH PLACES
	CAIGE	A,^D60		;TEST FOR .LT. 60 MINUTES
	POPJ	P,		;  YES, RETURN TO CALLER
INCTL1:	SUBI	A,^D60		;SUBTRACT OFF ONE HOUR
	AOS	CURHR		;INCREMENT BY ONE HOUR
	CAIL	A,^D60		;TEST FOR .LT. 60 MINUTES YET
	JRST	INCTL1		;  NO, KEEP ON LOOPING
	MOVEM	A,CURMIN	;STORE AS CURRENT MINUTES NOW
	MOVE	A,CURHR		;GET CURRENT HOUR
	CAIGE	A,^D24		;TEST FOR .LT. 24 HOURS
	POPJ	P,		;  YES, RETURN TO CALLER
INCTL2:	SUBI	A,^D24		;SUBTRACT OFF ONE DAY
	AOS	CURDAY		;INCREMENT BY ONE DAY
	CAIL	A,^D24		;TEST FOR .LT. 24 HOURS YET
	JRST	INCTL2		;  NO, KEEP ON LOOPING
	MOVEM	A,CURHR		;STORE AS CURRENT HOUR NOW
	MOVE	B,CURMON	;GET CURRENT MONTH
INCTL3:	MOVE	A,CURYR		;GET CURRENT YEAR
INCTL4:	TRNN	A,3		;TEST FOR YEAR DIVISIBLE BY 4
	CAIE	B,2		;TEST FOR MONTH .EQ. FEBRUARY
	TDZA	A,A		;  NOT LEAP YEAR, CLEAR 'A' & SKIP
	SETO	A,		;  LEAP YEAR, SET 'A' -1
	ADD	A,CURDAY	;GET CURRENT DAY (-1 IF LEAP YEAR)
;**; [176] CHANGE AT INCTL4 + 5	CLRH	8-MAY-79
	SUB	A,MONCNT-1(B)	;[176] GET EXCESS # OF DAYS FOR CURRENT MONTH
;[176]	SUB	A,MONCNT(B)	;GET EXCESS # OF DAYS FOR CURRENT MONTH
	JUMPLE	A,CPOPJ		;  NONE, THEN RETURN
	MOVEM	A,CURDAY	;STORE FOR NEXT MONTH
	AOS	B,CURMON	;INCREMENT THE CURRENT MONTH
	CAIG	B,^D12		;TEST FOR W/IN THE YEAR
	JRST	INCTL3		;  YES, REPEAT THE TEST FOR NEXT MONTH
	MOVEI	B,1		;GET 1ST MONTH AGAIN
	MOVEM	B,CURMON	; & STORE
	AOS	A,CURYR		;INCREMENT TO NEXT YEAR
	JRST	INCTL4		; & REPEAT THE TEST
;
;  SETAFT -	ROUTINE TO APPEND THE /AFTER SWITCH TO A CMD FILE
;		RECEIVES A DELAY TIME (IN MINUTES) IN AC 'N'
;		ADDS THAT TO THE CURRENT T-O-D (AS READ BY 'GETCUR')
;		  USING THE 'INCTIM' SUBROUTINE
;		RE-WRITES THE COMMAND FILE USING DUMP MODE I/O
;

SETAFT:	PUSHJ	P,GETCUR	;READ THE CURRENT TIME-OF-DAY
	MOVE	A,N		;COPY THE TIME INTERVAL
	PUSHJ	P,INCTIM	;COMPUTE THE DESIRED /AFTER TIME
	SETOM	SCANSW		;SET FLAG FOR SCAN ONLY
	PUSHJ	P,AFTCHK	;SCAN THE COMMAND FILE FOR PREV /AFTER
	  TDZA	A,A		;  FOUND ONE, CLEAR AC & SKIP
	SETO	A,		;  NOT FOUND, SET AC -1
	MOVEI	IO,W.CM1	;POINT AT UPDATE-MODE I/O ROUTINE
	USETO	CM1,-1		;POSITION TO RE-WRITE LAST CMD BLOCK
	JUMPE	A,SETAF1	;JUMP IF /AFTER SWITCH EXISTS
	MOVEI	CH," "		;GET A BLANK
	DPB	CH,RH.CMD+1	;STORE OVER LAST CHAR READ
	MOVEI	M,[ASCIZ \/AFTER:\] ;POINT AT SWITCH TEXT
	PUSHJ	P,MSG		;OUTPUT THE SWITCH
SETAF1:	MOVE	N,CURDAY	;GET THE UPDATED DAY
	PUSHJ	P,DECPR2	; & OUTPUT IT
	MOVE	M,CURMON	;GET THE UPDATED MONTH
	MOVE	M,MONTAB-1(M)	;GET THE SIXBIT TEXT (& PRECEDING DASH)
	PUSHJ	P,SIXMSO	; & OUTPUT IT
	PUSHJ	P,DASH		;OUTPUT A DASH
	MOVE	N,CURYR		;GET THE CURRENT YEAR
	SUBI	N,^D1900	;CONVERT TO TWO-DIGIT #
	PUSHJ	P,DECPRT	; & OUTPUT IT
	PUSHJ	P,COLON		;OUTPUT A COLON
	MOVE	N,CURHR		;GET THE UPDATED HOUR
	PUSHJ	P,DECPR2	; & OUTPUT IT
	PUSHJ	P,COLON		;OUTPUT ANOTHER COLON
	MOVE	N,CURMIN	;GET THE UPDATED MINUTES
	PUSHJ	P,DECPR2	; & OUTPUT IT
	PUSHJ	P,CRLF		;END THE LINE (ASSUMED)
	OUTPUT	CM1,AFTIOW	;WRITE THE COMMAND FILE BUFFER
	STATZ	CM1,760000	;TEST FOR LAST I/O ERROR
	  JRST	CM1ERW		;  YES, GO PROCESS IT
	MOVE	A,CMDNAM	;GET THE FILE NAME
	MOVSI	B,'CMD'		;GET THE EXTENSION
	MOVE	C,HICRDT	;GET HIGH-ORDER PART OF THE CREATION DATE
	DPB	C,[POINT 3,B,20]; & STORE INTO 2ND WORD
	MOVE	C,CRDTMP	;GET CREATION DATE/TIME, ETC.
	MOVE	D,CMDPPN	;GET FILE'S PPN
	RENAME	CM1,A		;CLOSE THE FILE, RETAINING CREATION DATE
	  JRST	CM1ERW		;  ERROR, GO REPORT IT
	SETZM	CMDNAM		;CLEAR CMD FILE NAME NOT TO DELETE IT
	JRST	CPOPJ1		;RETURN+1 FOR /DEFER:N SUCCESSFUL

;
;  REWCM1 -	SUBROUTINE TO REWIND THE CMD FILE
;		  USES 'REWCMD' IF SCANSW .EQ. 0 (CMD CHANNEL)
;		  DOES USETI IF SCANSW .NE. 0 (CM1 CHANNEL)
;

REWCM1:	SKIPN	SCANSW		;TEST FOR /AFTER SCANNING
	PJRST	REWCMD		;  NO, GO TO REWCMD
	CLOSE	CMD,		;CLOSE THE CMD-FILE (INPUT CHANNEL ONLY)
	SKIPLE	CMDLTH		;TEST FOR IN-CORE FLAG SET
	SETZM	CMDLTH		;  YES, CLEAR IT
	USETI	CM1,1		;POSITION TO READ 1ST BLOCK
	SETZM	RH.CMD+2	;CLEAR BYTE COUNT TO FORCE INPUT
	POPJ	P,		;RETURN TO CALLER


;
;  R.CM1 -	SUBROUTINE TO READ A COMMAND FILE
;		  USES 'R.CMD' IF SCANSW .EQ. 0 (CMD CHANNEL)
;		IF SCANSW.NE.0 SIMULATES BUFFERED MODE VIA DUMP MODE
;		  I/O ON CHANNEL CM1, USING NORMAL BUFFER & ASSOC. HEADER
;

R.CM1:	SKIPN	SCANSW		;TEST FOR /AFTER SCANNING
	PJRST	R.CMD		;  NO, GO TO R.CMD
R.CM1A:	SOSL	RH.CMD+2	;TEST FOR INPUT REMAINING
	JRST	CM1OKR		;  YES, JUMP
	INPUT	CM1,AFTIOW	;READ THE NEXT BLOCK
	STATZ	CM1,740000	;TEST FOR INPUT ERROR
	  JRST	CMDER		;  YES, JUMP TO PROCESS IT
	STATZ	CM1,20000	;TEST FOR EOF
	  JRST	CMDEOF		;  YES, JUMP TO PROCESS IT
	MOVEI	CH,<200*5>	;GET BUFFER CHAR COUNT
	MOVEM	CH,RH.CMD+2	;STORE INTO HEADER
	MOVE	CH,[POINT 7,B.CMD+3] ;GET FRESH BUFFER POINTER
	MOVEM	CH,RH.CMD+1	;STORE INTO HEADER
CM1OKR:	ILDB	CH,RH.CMD+1	;GET NEXT CHARACTER FROM THE BUFFER
	JUMPE	CH,R.CM1A	;JUMP IF NULL TO GET NXT CHARACTER
	CAIN	CH,177		;TEST FOR DELETE
	JRST	R.CM1A		;  YES, GET NEXT CHARACTER
	CAIL	CH,175		;TEST FOR OLD ALTMODE
	MOVEI	CH,33		;  YES, MAKE NEW ALTMODE
	CAIL	CH,140		;TEST FOR LOWER-CASE ASCII
	TRZ	CH,40		;  YES, MAKE UPPER-CASE
	CAIE	CH,33		;TEST FOR ALTMODE
	CAIG	CH,15		;TEST FOR <CR>,<LF>,ETC.
	JRST	CMDEOF		;  YES, TREAT AS EOF
	JRST	CPOPJ1		;RETURN+1 WITH NEXT CHARACTER


;
;  W.CM1 -	SUBROUTINE TO UPDATE A COMMAND FILE IN DUMP MODE
;		SIMULATES BUFFERED MODE CHARACTER OUTPUT
;		USES INPUT BUFFER & ASSOC. HEADER AS I/O AREA
;

W.CM1:	SOSL	RH.CMD+2	;DECR BYTE COUNTER & TEST IT
	JRST	CM1OKW		;  SPACE REMAINS, JUMP TO STORE
	OUTPUT	CM1,AFTIOW	;OUTPUT A BUFFER-FULL
	STATZ	CM1,760000	;TEST FOR I/O ERROR
	  JRST	CM1ERW		;  YES, JUMP
	PUSH	P,A		;SAVE A REGISTER
	MOVEI	A,<200*5>	;GET # OF CHARS PERMITTED IN THE BUFFER
	MOVEM	A,RH.CMD+2	;STORE AS SPACE REMAINING
	MOVE	A,[POINT 7,B.CMD+3] ;GET NEW INITIAL BUFFER PTR
	MOVEM	A,RH.CMD+1	;STORE AS NEW POINTER
	SETZM	B.CMD+3		;CLEAR 1ST WORD OF THE BUFFER
	MOVE	A,[XWD B.CMD+3,B.CMD+4] ;GET BLT WORD TO CLEAR THE BUFFER
	BLT	A,B.CMD+202	;CLEAR THE ENTIRE BUFFER
	POP	P,A		;RESTORE THE SAVED AC
CM1OKW:	IDPB	CH,RH.CMD+1	;STORE THE NEXT CHARACTER INTO THE BUFFER
	POPJ	P,		;RETURN TO CALLER
CM1ERW:	MOVEI	M,[ASCIZ /?Error updating CMD. Status = /] ;POINT AT MSG
	PUSHJ	P,MSGTTY	;TYPE THE MSG
	GETSTS	CM1,N		;GET THE ERROR STATUS
	PUSHJ	P,OCTPRT	; & TYPE IT
	PJRST	CRLF		;END LINE & RETURN TO CALLER
;  STORAGE FOR THE /DEFER /AFTER ROUTINES

TYPSTB:				;TABLE OF SWITCH LISTS CORRSPONDING TO
				; THE 'TYPCOM' DISPATCH TABLE
	Z	DISWIT		;XWD ADDRESS FOR 'DISMOUNT'
	Z	MOSWIT		;XWD ADDRESS FOR 'MOUNT'
	Z	FILSWT		;XWD ADDRESS FOR 'FILE'

MONCNT:	DEC	31,28,31	;TABLE OF # OF DAYS IN EACH MONTH (JAN,FEB,MAR)
	DEC	30,31,30	;  DITTO	(APR,MAY,JUN)
	DEC	31,31,30	;  DITTO	(JUL,AUG,SEP)
	DEC	31,30,31	;  DITTO	(OCT,NOV,DEC)

;STORAGE FOR IOWD LIST
UU(AFTIOW,2)

;  TIMES READ FROM /AFTER SWITCH
UU(AFTYR,1)			;/AFTER YEAR
UU(AFTMON,1)			;/AFTER MONTH
UU(AFTDAY,1)			;/AFTER DAY
UU(AFTHR,1)			;/AFTER HOUR
UU(AFTMIN,1)			;/AFTER MINUTE
AFTLTH==AFTMIN-AFTYR+1		; # OF /AFTER TIME ELEMENTS

;  CURRENT OR UPDATED-CURRENT TIMES
UU(CURYR,1)			;CURRENT YEAR
UU(CURMON,1)			;CURRENT MONTH
UU(CURDAY,1)			;CURRENT DAY
UU(CURHR,1)			;CURRENT HOUR
UU(CURMIN,1)			;CURRENT MINUTE

;  MISC FLAGS
UU(SCANSW,1)			;0 IF CHECKING /AFTER, -1 IF FINDING /AFTER
UU(CRDTMP,1)			;3RD WORD FROM LOOKUP INFO
UU(HICRDT,1)			;HIGH-ORDER PART OF CREATION DATE
SUBTTL	SUBROUTINES - I/O
;I/O SUBRS

R.TTY:	TLZE	F,L.TYO
	OUTPUT	TTY,0		;OUTPUT ANY CHARS LEFT HANGING AROUND
	SOSLE	RH.TTY+2
	JRST	R.TOK
IFG SLPSW, <						
R.TTY1:	MOVEI	M,SLPSW		;NUMBER OF MINUTES TO SLEEP
	MOVE	CH,STATES	;GET THE STATES WORD
	TLNN	CH,(1B6)	;TEST FOR 60 HZ. CLOCK
	IMULI	M,^D60*^D60	;  YES, CONVERT TO TICKS
	TLNE	CH,(1B6)	;TEST FOR 50 HZ. CLOCK
	IMULI	M,^D50*^D60	;  YES, CONVERT TO TICKS
	MOVE	CH,[UPTIME]	;GET GETTAB PARMS FOR SYSTEM UPTIME
	GETTAB	CH,		;GET CURRENT UPTIME FOR THE SYSTEM
	  SKIPA	M,[SLPSW]	;  FAILED, RESTORE AC & SKIP
	ADD	M,CH		;PUT UPTIME TO REPEAT IN AC 'M'
R.TTY3:	HRRI	CH,^D60000	;WAKE AFTER 60 SECONDS	
IFN FTTLAB,<SKIPE AVRFLG	;[144]
		HRRI CH,^D4000>	;[144]
	HRLI	CH,HIBTTL	;    OR TTY BREAK CHARACTER
	HIBER	CH,		;HIBERNATE
	  JRST	R.TTY2		;IF ERROR JUST WAIT
IFN FTTLAB,<
	SKIPN	AVRFLG		;[144] AVR PROCESSING
	JRST	R.TTY4		;[144] NO, READ A CHARACTER
	PUSH	P,A		;[144] SAVE THE AC'S
	PUSH	P,B		;[144]
	PUSH	P,C		;[144]
	PUSH	P,D		;[144]
	PUSHJ	P,SRCVOL	;[144] SEE IF THE VOLUME EXISTS
	  JFCL			;[144] NO, VOLUME LOOK FOR TTY
	  JRST	R.TTY5		;[144] YES, BUT NOT AVAILABLE
	HRRZ	B,RH.TTY	;[144] SIMULATE AN INPUT UUO
	HRLI	B,(POINT 7)	;[144]
	ADDI	B,1		;[144] POINT TO DATA
	MOVEM	B,RH.TTY+1	;[144]
	SETZM	RH.TTY+2	;[144] CLEAR BYTE COUNT
	MOVE	C,[POINT 6,A]	;[144] COPY THE DEVICE NAME
R.TTY6:	ILDB	D,C		;[144] GET A CHARACTER
	ADDI	D,"0"-'0'	;[144] MAKE INTO ASCII
	IDPB	D,B		;[144] STORE
	AOS	RH.TTY+2	;[144] INCREASE BYTE COUNT
	TLNE	C,770000	;[144] END OF BYTE
	JRST	R.TTY6		;[144] NO
	MOVEI	D,15		;[144]
	IDPB	D,B		;[144]
	AOS	RH.TTY+2	;[144]	
	MOVEI	D,12		;[144] GET LINE FEED
	IDPB	D,B		;[144] STORE
	AOS	RH.TTY+2	;[144] AOS BYTE COUNT
	POP	P,D		;[144]
	POP	P,C		;[144]
	POP	P,B		;[144]
	POP	P,A		;[144]
	JRST	R.TOK		;[144] CONTINUE AS IF AN INPUT UUO
R.TTY5:	POP	P,D		;[144]
	POP	P,C		;[144]
	POP	P,B		;[144]
	POP	P,A		;[144]
R.TTY4:				;[144]
>;[144] END FTTLAB
	TTCALL	14,		;SKIP IF SOMETHING WAS TYPED
	JRST	[
		MOVE	CH,[UPTIME] ;GET GETTAB PARMS FOR UPTIME
		GETTAB	CH,	    ;GET CURRENT UPTIME
		  SOJG	M,R.TTY3    ;  FAILED, COUNT DOWN MINUTES
		CAMGE	CH,M	    ;TEST FOR PAST TIME TO ECHO
		JRST	R.TTY3	    ;  NO, JUST WAIT SOME MORE
		TTCALL	3,BELMSG	;WAKE UP THE OPR	
		TTCALL	3,RPTTY		;REMIND OPR A COMMAND IS WAITING
		JRST	R.TTY1]		;LOOP TIL BREAK CHARACTER IS TYPED
>;	END OF	IFG SLPSW				
R.TTY2:	INPUT	TTY,0
	STATZ	TTY,740000
	 JSP	N,TTYERR
	STATO	TTY,20000
	 JRST	R.TOK
	CLOSE	TTY,
	JRST	R.TTY2
R.TOK:	ILDB	CH,RH.TTY+1
	JUMPE	CH,R.TTY
	SOSL	RPTTYC
	IDPB	CH,RPTTYB
	CAIE	CH,177		;IGNORE RUBOUT
	CAIN	CH,15		;OR CR
	JRST	R.TTY
;**; [121]	INSERT LABEL @ R.TOK+7	JULY 14, 1976	DML
R.TOK1:	CAIL	CH,175		;[121] CHANGE 175,176 TO ALTMO
	MOVEI	CH,33		;WHICH IS ALTMODE
	CAIL	CH,140
	TRZ	CH,40		;CHANGE LOWER CASE TO UPPER
	JRST	CPOPJ1

W.TTY:	SOSLE	WH.TTY+2
	JRST	W.TOK
	OUTPUT	TTY,0
	STATZ	TTY,760000
	 JSP	N,TTYERR
W.TOK:	IDPB	CH,WH.TTY+1
	SOSL	RPTTYC
	IDPB	CH,RPTTYB
	TLO	F,L.TYO
	CAILE	CH,14				
	POPJ	P,				
	TLZ	F,L.TYO				
	OUTPUT	TTY,0
	POPJ	P,0
;I/O ROUTINES

DEFINE READER (FILE,AC)<
;R.'FILE:	IFIDN <FILE>,<TTY>,<		
;	TLZE	F,L.TYO				
;	OUTPUT	FILE,0				
;>						
R.'FILE:	SOSL	RH.'FILE+2				
	JRST	FILE'OKR
	IFIDN	<FILE>,<CMD>,<
	SKIPLE	CMDLTH
	JRST	FILE'EOF
>
	INPUT	FILE,0
	STATZ	FILE,740000
	JRST	FILE'ER
	STATZ	FILE,20000
	JRST	FILE'EOF
	JRST	R.'FILE				
FILE'OKR:	ILDB	AC,RH.'FILE+1
	IFIDN	<AC>,<CH>,<
	JUMPE	AC,R.'FILE
	CAIE	AC,177
	CAIN	AC,15
	JRST	R.'FILE
	CAIL	AC,175
	MOVEI	AC,33
	CAIL	AC,140
	TRZ	AC,40
>
	JRST	CPOPJ1

IFE DIAGSW, <
FILE'ER:	MOVEI	M,[ASCIZ /?Error reading FILE'. Status = /]
	PUSHJ	P,MSGTTY
	GETSTS	FILE,N
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
	IFDIF	<FILE>,<DTA>,<
	IFDIF	<FILE>,<DSK>,<
FILE'ER:	MOVEI	M,[ASCIZ /?Error reading FILE'. Status = /]
	PUSHJ	P,MSGTTY
	GETSTS	FILE,N
	TRZ	N,17
	PUSHJ	P,OCTPRT
	PJRST	CRLF
>
>
	IFIDN	<FILE>,<DTA>,<
DTAER:	POPJ	P,
>
	IFIDN	<FILE>,<DSK>,<
DSKER:	POPJ	P,
>
>;	END OF	IFN DIAGSW
FILE'EOF:	POPJ	P,0
UU(RH.'FILE,3)
>

DEFINE WRITER (FILE,AC) <

W.'FILE:	SOSLE	WH.'FILE+2
	JRST	FILE'OKW
	OUTPUT	FILE,0
	STATZ	FILE,760000
	JRST	FILE'ERW
FILE'OKW:	IDPB	AC,WH.'FILE+1
;	IFIDN	<FILE>,<TTY>,<			
;	TLO	F,L.TYO				
;	CAIG	AC,15				
;	OUTPUT	FILE,0				
;>						
	POPJ	P,0

IFE DIAGSW, <
FILE'ERW:	MOVEI	M,[ASCIZ /?Error writing FILE'. Status = /]
	PUSHJ	P,MSGTTY
	GETSTS	FILE,N
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
	POPJ	P,0
>;	END OF	IFE DIAGSW
IFN DIAGSW, <
	IFDIF	<FILE>,<DTA>,<
	IFDIF	<FILE>,<DSK>,<
FILE'ERW:	MOVEI	M,[ASCIZ /?Error writing FILE'. Status = /]
	PUSHJ	P,MSGTTY
	GETSTS	FILE,N
	TRZ	N,17
	PUSHJ	P,OCTPRT
	PJRST	CRLF
>
>
	IFIDN	<FILE>,<DTA>,<
DTAERW:	POP	P,(P)
	JRST	FCIOER
>
	IFIDN	<FILE>,<DSK>,<
DSKERW:	POP	P,(P)
	JRST	RCIOER
>
>;	END OF	IFN DIAGSW
UU(WH.'FILE,3)
>

READER (CMD,CH)
READER (CMU,WD)
READER (USR,WD)
READER (DSK,WD)
IFN FILESW,<
READER(DTA,WD)
WRITER (DSK,WD)
WRITER (DTA,WD)
WRITER (DIR,CH)
W.USR=W.DIR			;GENERATE SAME NAME OF ROUTINE,
				;EVEN THOUGH DIFFERENT CHANNEL
>;	END IFN FILESW
SUBTTL	SUBROUTINE - BUILD A UFD
;SUBROUTINE TO SET UP A UFD FOR USE  V001
;ARGS	A=USER'S PPN
;	B=A+1=RESERVED QUOTA
;	C=B+1=FIRST COME FIRST SERVED QUOTA
;	D=C+1=LOGGED OUT QUOTA
;;	N=PRIV.BYTE (RIGHT-JUST.)
;	N1=N+1=MFD PPN
;	M=NAME OF STR
;	IO=ADDRESS OF ROUTINE TO TYPE A CHAR
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;;	WD=AC USED BY R.USR
;	F=FLAG REGISTER
;	  L.WRTL=BIT IN LH OF F = 1 IF USER REQUESTS WRITE LOCK
;	  L.NCR=BIT IN LH F = 1 IF USER REQUESTS NO CREATE SET
;	  L.SIN=BIT IN LH F = 1 IF SINGLE ACCESS REQUESTED
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;	USR=FREE I/O CHANNEL
;	US1=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDSET
;ERROR	DONT PROCEED (MESSAGE TYPED)
;OK	STR IS IN SEARCH LIST (WARNING MAY BE TYPED)
;
;ASSUMES SYMBOLS FOR AC'S ABOVE DEFINED, LOCATIONS CPOPJ, CPOPJ1 DEFINED
;
;USES U AND UU MACROS TO RESERVE STORAGE FOR EITHER HIGH OR LOW
;SEGMENT OPERATION.
;
;ROUTINES DEFINED HERE:
;
;MSG:	 TYPES STRING OF ASCII CHARS TO FIRST NULL
;SIXMSG:	 TYPES CONTENTS OF M AS SIXBIT CHARS
;CRLF:	 TYPES CARRIAGE RETURN LINE FEED
;OCTPRT: TYPES CONTENTS OF N AS OCTAL NUMBER
;MPOPJ:	 POP P,M FOLLWED BY POPJ P,
;;R.USR:	 READS NEXT WORD FROM CHANNEL USR INTO WD (BUFFER HEADER RH.USR, BUFFER B.USR)
;ADDSTR: ADD FILE STRUCTURE TO SEARCH LIST
;DISSTR: DELETE FILE STRUCTURE FROM SEARCH LIST

;;MNTSUB==1		;DECLARE IN CASE DISMOUNT SUBROUTINE ALSO APPEARS


RACEY==2		;VALUE OF LEVEL D FIELD IN STATES WORD FOR
			;  FOR MONITORS WHICH CONTAIN RACE COND.STUFF

CHRUFB==1	;UFBTAL WORD
CHRLEN==14	;LENGTH OF DSKCHR BLOCK
UFDQEE==1		;ERROR CODE FOR QUOTA EXCEEDED


	DEFINE UFDSEM(TEXT)<
	XLIST
	MOVEI	N1,[ASCIZ \TEXT\]
	JRST	UFDSMP
	LIST
>
UFDSET:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	N,UFDPRV	;;
	MOVEM	N1,UFDMPN	;AND MFD PPN
	MOVEM	M,UFDFSN	;AND NAME OF STR
	MOVE	N,B		;N=RESERVED QUOTA
	MOVE	M,C		;M=FCFS QUOTA
	MOVE	CH,D		;CH=LOGGED OUT QUOTA
UFDSTA:	MOVEI	B,.FSULK	;USER-MODE UFD INTERLOCK FUNCTION
	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	STUFBS		;BUSY, SLEEP AND RETRY
	MOVE	B,UFDFSN
	MOVE	A,[PHOPEN,,14]				
	MOVEI	C,RH.USR
	OPEN	USR,A		;INIT THIS FILE STRUCTURE
	  JRST	UFDSE2		;HOW CAN THIS BE?
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED LOOKUP OF UFD
	SETZB	C,SRCBUF+4	;CLEAR REST OF LOOKUP BLOCK
	MOVE	A,[XWD SRCBUF+4,SRCBUF+5]
	BLT	A,SRCBUF+EXLLEN-1
	LOOKUP	USR,SRCBUF	;LOOKUP UFD
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE IN A
	JRST	UFDEX		;UFD EXISTS, LOOK AT IT
	TRNE	A,-1		;SKIP IF NO UFD
	JRST	UFDSE3		;THERE'S SOMETHING WRONG WITH THIS UFD

;HERE IF MUST CREATE A UFD

	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO	;AND LOGGED OUT QUOTA
	MOVE	A,UFDPRV	;;AND PRIV.
	DPB	A,[POINT 9,SRCBUF+EXLATT,8]	;;
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED ENTER OF UFD
	MOVE	A,[XWD RIPLOG,RIPDIR]	;SET DIRECTORY BIT AND LOGGED IN BIT
	MOVEM	A,SRCBUF+EXLSTS
	ENTER	USR,SRCBUF	;TRY TO CREATE A UFD
	  JRST	UFDSE1		;IDENTIFY ENTER FAILURE
	SETSTS	USR,17		;SET STATUS TO DUMP MODE SO CLOSE WONT DUMP BUFS
	USETO	USR,2
	CLOSE	USR,		;AN EMPTY UFD		
	JRST	UFDOK		;ALL SET
;HERE IF UFD ALREADY EXISTS

UFDEX:	MOVE	A,SRCBUF+.RBSTS	;ALLOWED TO RENAME?
	TRNE	A,.RBNDL
	JRST	UFDOK		;NO-THATS ALL
	MOVEM	N,SRCBUF+EXLQTR	;STORE RESERVED QUOTA
	MOVEM	M,SRCBUF+EXLQTF	;AND FCFS
	MOVEM	CH,SRCBUF+EXLQTO ;AND LOGGED OUT QUOTA
;**; [203] CHANGE AT UFDEX + 6	CLRH	20-FEB-80
;[203]	MOVSI	A,RIPLOG	;LOGGED IN BIT
;[203]	TDNN	A,SRCBUF+EXLSTS	;SKIP IF BIT ON IN UFD
	MOVE	A,SRCBUF+EXLSTS	;[203] GET STATUS BITS
	SKIPGE	SRCBUF+EXLUSD	;[203] IF NEGATIVE USED COUNT,
	 TLO	A,RIPLOG	;[203] ...MONITOR BUG, SO FORCE A RECOMPUTE
	TLNN	A,RIPLOG	;[203] SKIP IF NEED TO RECOMPUTE
	JRST	UFDEX2		;NO, CAN PROCEED
	HRRI	B,.GTNSW	;USE HIGHEST JOB NUMBER ASSIGNED
	HRLI	B,%NSHJB	;NOT HIGHEST AVAILABLE
	GETTAB	B,		;GET NUMBER OF JOBS
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,(B)
	HRLZS	B		;LH B=-NUMBER OF REAL JOBS
UFDEX1:	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF+GOBNAM	;NAME OF STR
	MOVE	A,UFDUPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	A,1(B)		;A=NEXT JOB NUMBER
	MOVEM	A,CHRBUF+GOBJOB
	MOVEI	A,CHRBUF
	GOBSTR	A,		;SEE IF STR IS IN THAT JOB'S SEARCH LIST
	  JRST	UFDEX0		;NOT IN THIS JOBS LIST OR NOT OUR PPN
	JRST	UFDOK		;OK IS IN SOMEBODY ELSES SEARCH LIST SAME PPN
UFDEX0:	AOBJN	B,UFDEX1	;LOOP FOR ALL JOBS
;HERE TO LOOKUP ALL FILES AND RECOMPUTE RIBUSD

	MOVSI	A,PHOPEN				
	SETZ	C,					
	MOVE	B,UFDFSN
	MOVEM	B,CHRBUF	;SAVE FOR DSKCHR
	OPEN	US1,A		;OPEN FILE STRUCTURE
	  JRST	UFDSE2
	SETZM	SRCBUF+EXLUSD	;CLEAR USED WORD
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JSP	A,UFDNEV
ALLK1:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDRER		;READ ERROR (MAY BE EOF)
	MOVEM	WD,SECBUF+EXLNAM ;;FILE NAME
	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD (EXT)
	  JRST	UFDRER		;READ ERROR
	SKIPN	SECBUF+EXLNAM	;SKIP IF REAL NAME
	JRST	ALLK1		;UFD'S DO HAVE ZEROS
	HLLZM	WD,SECBUF+EXLEXT ;;STORE EXT
;**;[116] Replace @ ALLK1+8L	JNG	16-Oct-75
	MOVE	A,UFDUPN	;[116] GET USER'S PPN
	MOVEM	A,SECBUF+EXLPPN	;[116] STORE IN LOOKUP BLOCK
	MOVEI	A,EXLALC
	MOVEM	A,SECBUF	;SET NUMBER OF ARGS TO GET ALC WORD
	LOOKUP	US1,SECBUF	;LOOKUP FILE
	  JRST	ALLK1		;SOMETHING WRONG, FORGET IT
	MOVE	A,SECBUF+EXLALC ;GET BLOCKS ALLOCATED FOR THIS FILE
	ADDM	A,SRCBUF+EXLUSD ;COUNT FOR ALL FILES
	JRST	ALLK1
;HERE IF READ ERROR (MAY BE EOF)

UFDRER:	CLOSE	US1,
	GETSTS	USR,A		;A=ERROR CODE
	MOVEI	M,[ASCIZ .UFD read error, status = .]
	TRNN	A,20000		;SKIP IF ERROR, NOT EOF
	JRST	UFDSE4		;TELL USER ABOUT ERROR, NO UFD
	MOVE	B,CHRBUF+CHRUFB	;PREVIOUS UFBTAL
	CAMN	B,[XWD 400000,0]
	JRST	UFDEX3
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET NEW UFBTAL
	  JSP	A,UFDNEV
	SUB	B,CHRBUF+CHRUFB	;OLD-NEW=-DIFFERENCE FREE
	ADDM	B,SRCBUF+EXLUSD	;=DIFFERENCE ALLOCATED
	JRST	UFDEX3		;ALL SET


UFDEX2:	IORM	A,SRCBUF+EXLSTS	;MAKE SURE LOGGED IN BIT ON
UFDEX5:	LDB	A,LVDBTS
	CAIL	A,RACEY
	SETOM	SRCBUF+EXLUSD	;USE MONITOR'S COPY OF UFBTAL TO COMPUTE RIBUSD
UFDEX3:	PUSHJ	P,SETEXL	;SET UP SRCBUF FOR EXTENDED RENAME
	RENAME	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT
	JRST	UFDOK

	MOVEI	M,[ASCIZ .UFD RENAME failure .]
	JRST	UFDSE4

UFDSE3:	MOVEI	M,[ASCIZ .UFD LOOKUP failure .]
UFDSE4:	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,A		;N=ERROR CODE
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
	JRST	UFDOK

UFDSE1:	MOVEI	M,[ASCIZ .UFD ENTER failure .]
	PUSHJ	P,MSG		;IDENTIFY FAILURE
	HRRZ	N,SRCBUF+EXLEXT
	PUSHJ	P,OCTPRT
	MOVEI	M,[ASCIZ .
No UFD created
.]
	PUSHJ	P,MSG		;TELL POOR USER WE CANT MAKE A UFD
UFDOK:	;;
;HERE TO CLEAR UFD INTERLOCK

	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	JSP	A,UFDNEV
	JRST	CPOPJ1		;ALL DONE

;HERE WHEN UFD INTERLOCK IS BUSY - SLEEP AND RETRY

STUFBS:	MOVEI	A,1
	SLEEP	A,		;SLEEP FOR 1 SECOND
	JRST	UFDSTA

UFDSE2:	PUSHJ	P,STUFCL
	UFDSEM <Can't OPEN>


;SUBROUTINE TO TEST/SET OR CLEAR UFD INTERLOCK
;ENTER AT STUFCL TO CLEAR
;ENTER AT STUFC1 WITH B=FUNCTION
;RETURN POPJ IF FAILED
;RETURN CPOPJ1 IF OK

STUFC1:		;;
STUFCL:	JRST	CPOPJ1	;;

;;STUFCL:	MOVEI	B,UCLSTR
;;STUFC1:	MOVE	A,[XWD 3,B]
;;	MOVE	C,UFDFSN
;;	MOVE	D,UFDUPN
;;	STRUUO	A,
;;	  POPJ	P,
;;	PJRST	CPOPJ1

;SUBROUTINE TO SET UP HEADER FOR EXTENDED LOOKUP/ENTER/RENAME OF UFD

SETEXL:	MOVEI	A,EXLLEN-1	;LENGTH OF ARG LIST
	MOVEM	A,SRCBUF
	MOVE	A,UFDUPN	;NAME IS USER'S PPN
	MOVEM	A,SRCBUF+EXLNAM
	MOVSI	A,(SIXBIT .UFD.)	;EXT IS UFD
;[107] SETEXL + 5
	HLLM	A,SRCBUF+EXLEXT	;[107] GET EXT W/O DATE75 BUG
	MOVE	A,UFDMPN	;DIRECTORY IS MFD
	MOVEM	A,SRCBUF+EXLPPN
	POPJ	P,

UFDSMP:	MOVEI	CH,"?"
	PUSHJ	P,(IO)
	MOVE	M,UFDFSN
	PUSHJ	P,SIXMSG
	MOVEI	CH," "
	PUSHJ	P,(IO)
	MOVE	M,N1
	PUSHJ	P,MSG
	PJRST	CRLF
SUBTTL	SUBROUTINE - F/S DISMOUNT
;SUBROUTINE TO CLEAR A FILE STRUCTURE FOR DISMOUNT  V001
;ARGS	A=USER'S PPN
;	B=A+1=JOB NUMBER
;	C=B+1
;	D=C+1=LOGGED OUT QUOTA (-1 TO IGNORE)

;	N1=N+1=MFD PPN
;	M=NAME OF FILE STRUCTURE
;	IO=ADDRESS OF ROUTINE TO TYPE A CHARACTER
;	CH=ACCUMULATOR TO CONTAIN CHAR TO BE TYPED
;	F=FLAG REGISTER
;	  L.FRE1=AVAILABLE BIT IN LH OF F
;	  L.FRE2=AVAILABLE BIT IN LH OF F
;	P=PUSH DOWN LIST POINTER
;
;	USR=FREE I/O CHANNEL
;
;CALL	PUSHJ	P,UFDCLR
;ERROR	DONT PROCEED A=CODE (0=CANT OPEN 1=QUOTA EXCEEDED) MESSAGE TYPED
;OK	FILE STRUCTURE REMOVED FROM JOBS SEARCH LIST (WARNING MAY BE TYPED)

UFDCLR:	MOVEM	A,UFDUPN	;SAVE USER'S PPN
	MOVEM	B,UFDJBN	;AND JOB NUMBER
	MOVEM	D,UFBLOQ	;SAVE LOGGED-OUT QUOTA
	MOVEM	N1,UFDMPN	;MFD PPN
	MOVEM	M,UFDFSN	;STR NAME
	MOVEI	B,.FSULK
UFDCLA:	PUSHJ	P,STUFC1	;TEST/SET UFD INTERLOCK
	  JRST	UFDCAA		;BUSY, SLEEP AND RETRY
	MOVE	A,[PHOPEN,,14]				
	MOVE	B,M		;STR NAME
	MOVEI	C,RH.USR
	OPEN	USR,A		;OPEN FILE STRUCTURE
	  JSP	A,UFDNEV
	MOVEI	A,B.USR
	MOVEM	A,.JBFF
	INBUF	USR,1		;DECLARE OUR 1 BUFFER
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED LOOKUP
	LOOKUP	USR,SRCBUF
	  SKIPA	A,SRCBUF+EXLEXT	;GET ERROR CODE
	JRST	UFDCLC		;UFD EXISTS
	TRNN	A,-1		;SKIP IF UFD EXISTS, LOOKUP FAILED
	JRST	UFDCLJ		;NO UFD

;HERE IF UFD LOOKUP ERROR

	MOVEI	M,[ASCIZ .UFD LOOKUP failure .]
	JRST	UFDCFA

UFDCLC:	HRRI	B,.GTNSW	;USE HIGHEST JOB NUMBER ASSIGNED
	HRLI	B,%NSHJB	;NOT HIGHEST AVAILABLE
	GETTAB	B,		;GET NUMBER OF JOBS IN SYSTEM
	  MOVEI	B,100		;ASSUME 64
	MOVNI	B,(B)		;B=-NUMBER OF REAL JOBS (NOT NULL JOB)
	HRLZS	B
UFDCCA:	MOVE	A,UFDFSN	;NAME OF FILE STRUCTURE
	MOVEM	A,CHRBUF+GOBNAM	;STORE IN GOBSTR BLOCK
	MOVE	A,UFDUPN	;USER'S PPN
	MOVEM	A,CHRBUF+GOBPPN
	MOVEI	C,1(B)		;JOB NUMBER
	MOVEM	C,CHRBUF+GOBJOB
	MOVEI	A,CHRBUF
	CAME	C,UFDJBN	;IF THIS JOB, IGNORE
	GOBSTR	A,		;SEE IF IN THIS JOBS SEARCH LIST
	  JRST	UFDCCB		;NO
	JRST	UFDCLJ		;NO, SOMEBODY ELSE COMING
UFDCCB:	AOBJN	B,UFDCCA	;NOT IN THAT JOBS SEARCH LIST

	MOVE	A,UFDFSN
	MOVEM	A,CHRBUF
	MOVE	A,[XWD CHRUFB+1,CHRBUF]
	DSKCHR	A,		;GET CURRENT UFBTAL
	  JSP	A,UFDNEV
	MOVE	B,SRCBUF+EXLQTO	;USE UFD QUOTA
	SKIPGE	UFBLOQ		; IF NONE IN QUOTA.SYS OR AUXACC.SYS
	MOVEM	B,UFBLOQ	;
	MOVE	B,CHRBUF+CHRUFB
	CAMN	B,[XWD 400000,0]
	JRST	UFDCCC		;IGNORE QUOTA TEST
	MOVE	A,SRCBUF+EXLQTF	;FCFS QUOTA

REPEAT 0,<ADD	A,SRCBUF+EXLQTR	;RESERVED QUOTA WHEM IMPLEMENTED>

	SUB	A,B	;QUOTA IN-FREE=USED
	SUB	A,UFBLOQ	;-QUOTA OUT=BLOCKS OVER QUOTA
	JUMPG	A,UFDCLM	;JUMP IF OVER QUOTA

;HERE TO SEE IF UFD EMPTY

UFDCCC:	MOVE	B,SRCBUF+.RBSTS	;'NO DELETE/RENAME' BIT?
	TLNE	B,.RBNDL
	JRST	UFDCLJ		;YES-NO MORE TO DO
	SKIPN	B,SRCBUF+EXLSIZ	;WORDS WRITTEN IN UFD
	JRST	UFDCLI		;NO WORDS WRITTEN - DELETE UFD
UFDCLD:	PUSHJ	P,R.USR		;READ NEXT WORD OF UFD
	  JRST	UFDCDA		;JUMP IF ERROR OR EOF
	JUMPN	WD,UFDCLF	;JUMP IF NON-EMPTY ENTRY IN UFD
	SOJG	B,UFDCLD	;STILL EMPTY SO FAR, LOOP FOR WORDS WRITTEN

	JRST	UFDCLI		;NO NON-ZERO ENTRIES, DELETE UFD

UFDCDA:	GETSTS	USR,N
	TRNE	N,20000		;SKIP IF EOF
	JRST	UFDCLF		;EOF
	MOVEI	M,[ASCIZ .UFD read error, status = .]
	PUSHJ	P,MSG
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
UFDCLF:	MOVSI	A,RIPLOG	;LOGGED IN BIT
	ANDCAM	A,SRCBUF+EXLSTS	;CLEAR IN RENAME ARG LIST
	LDB	A,LVDBTS
	CAIL	A,RACEY
	SETOM	SRCBUF+EXLUSD	;REQUEST MONITOR TO COMPUTE RIBUSD
	PUSHJ	P,SETEXL	;SET UP FOR EXTENDED RENAME
	RENAME	USR,SRCBUF	;EXTENDED RENAME
	  SKIPA	A,SRCBUF+EXLEXT
	JRST	UFDCLJ
	MOVEI	M,[ASCIZ/?UFD RENAME failure /]
UFDCFA:	PUSHJ	P,MSG
	HRRZ	N,A
	PUSHJ	P,OCTPRT	;PRINT ERROR CODE
	PUSHJ	P,CRLF
	JRST	UFDCLJ		;GIVE UP
UFDCLI:	SETZB	A,B
	SETZB	C,D
	RENAME	USR,A		;DELETE UFD
	  JSP	A,UFDNEV

UFDCLJ:
;;	PUSHJ	P,DISSTR	;TAKE STR OUT OF JOB'S SEARCH LIST
	PUSHJ	P,STUFCL	;CLEAR UFD INTERLOCK
	  JRST	CPOPJ1
	JRST	CPOPJ1		;EVERYBODY HAPPY
UFDCLM:	MOVEI	M,[ASCIZ .Exceed Logged-Out Quota .]
	PUSHJ	P,MSG
	MOVE	N,UFBLOQ
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ . by .]
	PUSHJ	P,MSG
	MOVE	N,A
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ . blocks
.]
	MOVEI	A,UFDQEE
	PJRST	MSG

UFDCAA:	MOVEI	A,1
	SLEEP	A,
	JRST	UFDCLA


UFDNEV:	MOVE	N,A		;HERE ON IMPOSSIBLE ERROR
	PJRST	NEVMSG
LVDBTS:	POINT 3,STATES,9
UU(CHRBUF,CHRLEN)
UU(SRCBUF,EXLLEN)
UU(SECBUF,EXLALC+1)
U(UFDMPN)
U(UFDPRV)	;;
U(UFDUPN)
U(UFDFSN)
U(UFDJBN)
U(UFBLOQ)
SUBTTL	SUBROUTINES  --  IPCF HANDLING FOR TAPE LABELLING

IFN FTTLAB,<

;HERE TO SET UP OUR IPCF QUOTAS

IPCSET:	MOVEI	A,IP.CFP	;ASK FOR PRIVS
	MOVEM	A,IPS.BL+.IPCFL	;SAVE IN SEND FLAGS
	MOVE	A,[%SIIPC]	;GETTAB PID OF SYSTEM IPCC
	GETTAB	A,		;...
	  POPJ	P,		;NO, MUST NOT BE ANY IPCF
	MOVEM	A,IPS.BL+.IPCFR	;SAVE AS RECEIVER OF MESSAGE
;[170]	MOVE	A,3		;GET LENGTH OF MESSAGE TO SEND TO IPCC
;[170]	HRL	A,IPS.BL+1	;SAVEIN MSG HDR
;[170]	MOVE	A,[0,,.IPCSQ]	;FUNCTION TO SET QUOTAS
;**; [170]
	MOVE	A,[3,,IPS.DT]	;[170] GET POINTER TO DATA BLOCK
	MOVEM	A,IPS.BL+.IPCFP	;[170] AND PLANT IN HEADER BLOCK
	MOVEI	A,.IPCSQ	;[170] LOAD FUNCTION TO SET QUOTAS
	MOVEM	A,IPS.DT+.IPCS0	;STORE IN MESSAGE
	MOVE	A,OURJOB	;OURJOB
	MOVEM	A,IPS.DT+.IPCS1	;STORE IN MESSAGE

;[170]	MOVEI	A,777000	;INFINITE SEND QUOTA, NO RECEIVE QUOTA
;**; [170]
	MOVEI	A,-1		;[170] SET INFINITE SEND/RECEIVE QUOTAS
	MOVEM	A,IPS.DT+.IPCS2	;SAVE IN MESSAGE
IPCS.0:	MOVE	A,[4,,IPS.BL]	;POINT AT PACKET BLOCK
	IPCFS.	A,		;SEND THE MESSAGE TO SYSTEM IPCC
	  JRST	SNDERR		;SEND ERROR SEE WHY
IPCS.1:	SETZM	IPR.BL+.IPCFL	;NO FLAGS FOR THIS RECEIVE
	MOVE	A,[6,,IPR.BL]	;POINT AT RECIEVE BLOCK
	IPCFR.	A,		;RECEIVE THE ANSWER
	  JFCL			;IGNORE ERRORS-CLNIPC WILL TRUNCATE THEM LATER IF POSSIBLE
	POPJ	P,		;YUP, ALL SET

SNDERR:	CAIE	A,IPCRY%	;SEND FAILED DUE TO NO FREE SPACE?
	  POPJ	P,		;NO, JUST GIVE UP
	MOVEI	A,1		;ONE SECOND
	SLEEP	A,		;WAIT AND HOPE SOME FREES UP
	JRST	IPCS.0		;TRY AGAIN

;HERE TO RECEIVE ANY RANDOM MESSAGES IN OUR QUEUE
;(MIGHT HAVE BEEN TURNED AROUND)
CLNIPC:	MOVE	A,[IP.CFT+IP.CFB] ;GET TRUNCATE TOO LONG FLAG
	MOVEM	A,IPR.BL+.IPCFL	;AS FLAG FOR RECEIVE
CLNI.1:	MOVE	A,[6,,IPR.BL]	;LEN,,MESSAGE HEADER
	IPCFR.	A,		;TRY TO CLEAN UP OUR QUEUE
	  POPJ	P,		;PROBABLY NOTHING THERE
	JUMPN	A,CLNI.1	;MORE MESSAGES
	POPJ	P,		;GOT THEM ALL, RETURN

;STILL IN IFN FTTLAB
;STILL IN IFN FTTLAB

;HERE ON MAGTAPE MOUNT WHEN DONE TO SEND A MESSAGE TO PULSAR

SNDPLR:
IFE <LT.DEF-LT.BLP>,<		;IF DEFAULT IS BLP,
	SKIPLE	LABTYP		;SKIP IF BLP OR DEFAULT
>
IFN <LT.DEF-LT.BLP>,<		;IF DEFAULT IS NOT BLP,
	SKIPE	LABTYP		;WAS TYPE BLP?
>
	  JRST SNDPL1		;NOT BLP
	MOVEI	A,.TFPLT+.TFSET	;SET BYPASS LABEL PROCESSING
	MOVE	B,PHYNAM	;GET DEVICE'S PHYSICAL NAME
	MOVEI	C,LT.BLP	;CODE FOR BLP
	MOVE	D,[3,,A]	;AC FOR TAPOP.
	TAPOP.	D,		;SET BLP
	  JSP	A,NEVERR	;SHOULD NEVER HAPPEN
	POPJ	P,		;RETURN-NO MSG TO PULSAR ON BLP
SNDPL1:	MOVE	A,[%SITLP]	;GET PULSAR'S PID
	GETTAB	A,		;...
	  POPJ	P,		;NO PULSAR
	JUMPE	A,CPOPJ		;NO PULSAR
	MOVEM	A,IPS.BL+.IPCFR	;WHERE TO SEND MESSAGE
	SKIPG	A,LABTYP	;PICK UP SPECIFIED LABEL TYPE
	SETZ	A,		;IF NO /LABELS SWITCH, USE ZERO
	MOVEM	A,IPS.DT+MOU.LT	;SAVE IN MOUNT MESSAGE
	MOVE	A,[MOU.SZ,,.MOUFN]	;LENGTH,,FUNCTION CODE
	MOVEM	A,IPS.DT+MOU.HD	;SAVE IN MESSAGE
	MOVE	A,PHYNAM	;DEVICE NAME
	DEVNAM	A,		;MAKE IT A REAL PHYSICAL NAME
	  MOVE	A,PHYNAM	;USE THE BEST WE HAVE
	MOVEM	A,IPS.DT+MOU.DV	;...
	MOVE	A,LABPOS	;POSITION REQUEST
	MOVEM	A,IPS.DT+MOU.PS	;...
	MOVE	A,NVOLS		;NUMBER OF VOLUMES
	LSH	A,-1		;MAKE IT VOLUMES, NOT WORDS USED!
	MOVEM	A,IPS.DT+MOU.NV
	MOVE	A,PROTEC	;PROTECTION
	MOVEM	A,IPS.DT+MOU.PT	;
	MOVE	A,EXPDAT	;EXPIRATION DATE
	MOVEM	A,IPS.DT+MOU.DT
	MOVE	A,CMDJOB	;GET USER'S JOB NUMBER
	MOVEM	A,IPS.DT+MOU.JB	;SAVE IN MESSAGE
	MOVE	A,USRPPN	;GET HIS PPN
	MOVEM	A,IPS.DT+MOU.OW	;SAVE IN MESSAGE
	SETZ	A,		;ASSUME /WE
	TRNN	F,SB.WE		;IS THAT RIGHT?
	MOVEI	A,1		;NO, SAY /WL
	MOVEM	A,MOU.WS+IPS.DT	;SAVE IN PACKET FOR PULSAR
	AOS	A,LABITN	;COUNT ANOTHER ITN AND 
	MOVEM	A,IPS.DT+MOU.IT	; SAVE IT IN THE MSG
	MOVE	A,[MOU.SZ,,IPS.DT] ;LEN,,PACKET ADDR
	MOVEM	A,IPS.BL+.IPCFP	;IN MSG HDR
	MOVSI	A,(IP.CFL)	;LONGER THAN SYSTEM LIMIT
	IORM	A,IPS.BL+.IPCFL	;IN PACKET HEADER FLAGS
	MOVE	A,[4,,IPS.BL]	;LEN,,MSG HDR
	IPCFS.	A,		;SEND THE MESSAGE
	  POPJ	P,		;IGNORE THE ERROR
	SETZ	C,		;CLEAR A COUNTER
SNDPL2:	MOVE	B,NVOLS		;GET THE NUMBER OF VOLID'S
;[170]	CAILE	B,4		;ALL FIT IN A PACKET?
;[170]	MOVEI	B,4		;NO, JUST DO A PACKETS WORTH
;**; [170] 
	CAILE	B,<PKT.SZ-VOL.VL> ;[170] ALL FIT IN A PACKET?
	 MOVEI	B,<PKT.SZ-VOL.VL> ;[170] NO, JUST DO A PACKET'S WORTH
	HRLI	A,REELID(C)	;WHERE TO GET DATA FROM
	HRRI	A,IPS.DT+VOL.VL	;WHERE TO STORE IT
	BLT	A,IPS.DT+VOL.VL(B) ;PUT IT IN THE MESSAGE
	MOVE	A,LABITN	;PICK UP ITN
	MOVEM	A,IPS.DT+VOL.IT	;AND PUT IT IN MSG
	ADDI	B,VOL.VL	;ACITN FOR HDR WORD AND COUNT
	HRLM	B,IPS.BL+.IPCFP	;PUT LENGTH  IN MESSAGE HDR
	MOVEI	A,.VOLFN	;VOLID FUNCTION FOR MSG
	HRRM	A,IPS.DT+VOL.HD	;SAVE FUNCTION IN MSG
	HRLM	B,IPS.DT+VOL.HD	;SAVE LENGTH IN HDR WORD
	MOVEI	A,IPS.DT	;ADDR OF PACKET
	HRRM	A,IPS.BL+.IPCFP	;INTO PACKET HDR
	MOVE	A,[4,,IPS.BL]	;SEND THAT MSG
	IPCFS.	A,		;SEND THE MSG
	  POPJ	P,		;EXIT ON ERROR
	MOVE	B,NVOLS		;GET NUMBER OF VOLIDS
;[170]	SUBI	B,4		;ACCOUNT FOR THOSE SENT ALREADY
	SUBI	B,<PKT.SZ-VOL.VL> ;[170] ACCOUNT FOR THOSE SENT ALREADY
	JUMPLE	B,SNDPL3	;IF ALL SENT, TOUCH THE TAPE TO WAKE PULSAR
	MOVEM	B,NVOLS		;SAVE NUMBER LEFT
;[170]	ADDI	C,4		;ACCOUNT FOR THOSE SENT
	ADDI	C,<PKT.SZ-VOL.VL> ;[170] ACCOUNT FOR THOSE SENT
	JRST	SNDPL2		;LOOP TO SEND MORE
SNDPL3:	MOVEI	A,.TFREW		;CODE TO REWIND THE TAPE
	MOVEI	B,USR		;AND THE CHANNEL
	MOVE	C,[2,,A]	;AC FOR TAPOP.
	TAPOP.	C,		;REWIND THE TAPE
	  POPJ	P,		;GIVE UP NOW IF WE CAN'T
;**; [172]
	MOVEI	A,USR		;[172] AIM AT OUR CHANNEL
	DEVNAM	A,		;[172] FIND OUT DEVICE NOW ON THAT
				;[172] CHANNEL, PULSAR MAY HAVE SWAPPED UNITS
	 POPJ	P,		;[172] WHAT!!
	MOVEM	A,PHYNAM	;[172] SAVE IT
	MOVEI	A,.TFWAT	;WAIT FOR THE REWIND TO FINISH
	MOVEI	B,USR		;CHANNEL NUMBER
	MOVE	C,[2,,A]	;AC FOR TAPOP.
	TAPOP.	C,		;WAIT
	  POPJ	P,		;GIVE UP IF THIS LOSES
	GETSTS	USR,A		;NOW LOOK AT THE IO STATUS
	TRNN	A,740000	;ANY ERRORS?
	POPJ	P,		;NO, JUST GO ON
	MOVEI	M,[ASCIZ/Label error mounting tape/]
	PJRST	ERR994		;TYPE OUT ERROR

>;END OF IFN FTTLAB
SUBTTL	COMMAND SWITCHES & HELP MESSAGES
MONHLP:	ASCIZ/<CR> Use suggested unit
DIGIT    Use unit 'DIGIT'
/

FILHLP==MONHLP

OPKHLP:	ASCIZ/<CR> Use suggested drive
NAME     Use drive 'NAME'
/
;MACRO FOR SWITCH TABLES

DEFINE	SWITAB	(NAME)<
DEFINE	NAM	(A,B)<
SIXBIT	/A/>
MACT1=.
NAMES
EXP	0
DEFINE	NAM	(A,B)<
EXP	B>
MACT2=.
NAMES
NAME:	XWD	MACT2,MACT1>

;MOUNT SWITCHES

DEFINE	NAMES<
NAM	HELP  ,MOSH
NAM	UWLOCK,MOSUWL
NAM	URONLY,MOSURO
NAM	UWENAB,MOSUWE
NAM	WENABL,MOSWE
NAM	WLOCK ,MOSWL
NAM	RONLY ,MOSRO
NAM	MULTI ,MOSM
NAM	SINGLE,MOSS
NAM	NOSEAR,MOSNOS
NAM	VID   ,MOSVID
NAM	REELID,MOSRID
NAM	PASSIV,MOSPAS
NAM	CREATE,MOSCRE
NAM	NOCREA,MOSNOC
NAM	AFTER ,MOSAFT
IFN FTTLAB,<
NAM	VOLID ,MOSRID
NAM	EXPIRE,MOSEXP
NAM	POSITI,MOSPOS
NAM	LABELS,MOSLAB
NAM	PROTEC,MOSPRO
>
>

SWITAB(MOSWIT)
MOSH:	MOVEI	M,MOHELP
	PUSHJ	P,MSGTTY
	POPJ	P,

MOSUWL:	TRO	F,SB.UWL
	JRST	CPOPJ1

MOSURO==MOSUWL

MOSUWE:	TRZ	F,SB.UWL
	JRST	CPOPJ1

MOSWE:	TRO	F,SB.WE
	TRZ	F,SB.WL
	JRST	CPOPJ1

MOSWL:	TRO	F,SB.WL
	TRZ	F,SB.WE
	JRST	CPOPJ1

MOSRO==MOSWL

MOSM:	TRZ	F,SB.S
	JRST	CPOPJ1

MOSS:	TRO	F,SB.S
	JRST	CPOPJ1

MOSNOS:	TRO	F,SB.NOS
	JRST	CPOPJ1

MOSVID==VIDIN
MOSRID==RIDIN

MOSPAS:	TLO	F,L.PAS		;SHOW /PASSIVE SEEN
	JRST	CPOPJ1		; & RETURN

MOSCRE:	TLZA	F,L.NOC		;CLEAR IT ON /CREATE
MOSNOC:	TLO	F,L.NOC		;SHOW /NOCREATE SEEN
	JRST	CPOPJ1		; & RETURN

MOSAFT:	MOVEI	N,5		;GET DELIMITER COUNTER
MOSAF1:	PUSHJ	P,SSIXIN	;READ NEXT INPUT ITEM
	CAIE	CH,"-"		;TEST FOR DASH AS DELIMITER
	CAIN	CH,":"		;TEST FOR COLON AS DELIMITER
	SOJG	N,MOSAF1	;  EITHER, COUNT DOWN FOR NEXT FIELD
	JRST	CPOPJ1		;RETURN WITH /AFTER SWITCH SKIPPED
MOHELP:	ASCIZ\
(*=Default)
/WENABL *Write enable
/WLOCK   Write lock
/RONLY   Read only = /WLOCK
/MULTI  *Multi access
/SINGLE  Single access
/UWENAB *Universal write enable
/UWLOCK  Universal write lock
/URONLY  =/UWLOCK
/NOSEARCH Don't search STRLST.SYS
\
;DISMOUNT SWITCHES

IFN OFFLIN,<
REMTAB:	SIXBIT	/NOCHEC/
	EXP	0
REMDIS:	EXP	NOCHEK

RESWIT:	XWD	REMDIS,REMTAB

NOCHEK:	SETOM	NCHKFG
	JRST	CPOPJ1		; GOOD RETURN
>;	END IFN OFFLIN

DEFINE	NAMES<
NAM	REMOVE,DMSR
NAM	VID   ,DMSVID
NAM	AFTER ,DMSAFT
>

SWITAB(DISWIT)


DMSR:	TRO	F,SB.R
	JRST	CPOPJ1

DMSVID==VIDIN

DMSAFT=MOSAFT			;/AFTER ON DISMOUNT SAME AS ON MOUNT


;FILE COMMAND SWITCHES (/AFTER)

DEFINE	NAMES<
NAM	AFTER ,FILAFT>

SWITAB(FILSWT)

FILAFT=MOSAFT

;'NO SWITCHES' SWITCHES

DEFINE NAMES<
NAM	HELP,NOSH>

SWITAB	(NOSWIT)

NOSH:	MOVEI	M,[ASCIZ/No switches
/]
	PJRST	MSGTTY

;OPRARG SWITCHES (PERMITTED WHEN REPLYING TO DRIVE-SELECTION MESSAGES)

DEFINE	NAMES<
NAM	CANCEL,OPACAN
NAM	DEFER ,OPADEF
NAM	START ,OPASTA
NAM	STOP  ,OPASTO
NAM	HELP  ,OPAHEL
NAM	WHAT  ,OPAWHT
NAM	WAIT  ,OPAWAI
NAM	PAUSE ,OPAPAU
IFN RIDSW, <
NAM	REELID,OPARID
>;	END IFN	RIDSW
>

SWITAB	(OPSWIT)
OPADEF:	PUSHJ	P,DEFERQ
	  POPJ	P,
OPACAN:	TLO	F,L.OCAN
OPACA2:	SETZM	A
	JRST	CPOPJ1

OPAWAI:	TRNN	F,OB.OPC	;TEST FOR OPR INPUT
	SKIPN	CMDNAM		;TEST FOR COMMAND FILE EXISTS
	POPJ	P,		;  OPR OR NO CMD FILE, IGNORE CMD
	JRST	OPRWA1		;GO TO THE WAIT CMD

OPAPAU:	TRO	F,OB.WFI	;SET WAIT-FOR-INPUT FLAG
	SETOM	WAITFG		;SET WAIT FLAG
	MOVEI	A,2		;GET ACTION CODE
	JRST	CPOPJ1		;RETURN SUCCESSFUL

DEFERQ:				;HERE TO SCAN THE 'DEFER' COMMAND
	TRNN	F,OB.OPC	;TEST FOR OPERATOR COMMAND
	SKIPN	CMDNAM		;TEST FOR NO CMD FILE
	 POPJ	P,		;  EITHER, GIVE ERROR RETURN
;**;	[127]	INSERT AT DEFERQ+3 LCR. 8-NOV-76.
	SETZM	NODEFR		;[127] RESET /NODEFER MODE
	CAIE	CH,":"		;IS THERE A PARAMETER (TIME)?
	 JRST	OPRDF2		;NO, NO /AFTER NECESSARY
	PUSHJ	P,SDECIN	;GET NUMBER OF MINS
	CAIE	CH,":"		;IS THE FORMAT HH:MM?
	 JRST	OPRDF3		;NO, SEE IF N=0
	IMULI	N,^D60		;CONVERT HOURS TO MINUTES
	MOVE	A,N		;SAVE THE CONVERT
	PUSHJ	P,SDECIN	;GO GET MINUTES
	ADD	N,A		;ADD HIS MINS. TO CNVRTD MIN.(FR. HRS)
OPRDF3:	CAIG	N,DEFERT	;IS TIME GIVEN BY OPR PAST DEFERT?
	 JRST	OPRDF4		; NO, OK TO USE GIVEN VALUE
	PUSHJ	P,MSG600	;YES, TELL HIM WE'LL USE 0
	TDZA	N,N		;SET N TO 0 FOR POSTERITY 
OPRDF4:	JUMPN	N,SETAFT	;/DEFER:N, GO PROCESS THE INTERVAL
OPRDF2:	TLO	F,L.ODEF	;SET SWITCH FOR /DEFER
	SETZM	CMDNAM		;DONT DELETE COMMAND FILE
	JRST	CPOPJ1
IFN RIDSW, <
OPARID:	CAIE	CH,":"		;TEST FOR A COLON
	POPJ	P,		;  NO, RETURN TO CALLER
	PUSHJ	P,(IO)		;READ THE NEXT CHARACTER
	  POPJ	P,		;  EOF, RETURN TO CALLER
	PUSHJ	P,SIXIN		;READ A SIXBIT NAME
	JUMPE	A,CPOPJ		;  NULL, RETURN TO CALLER
	MOVEM	A,REELID	;STORE THE NEW REELID
	SETZ	A,		;CLEAR AC 'A' TO SHOW NO SPECIAL ACTION
	JRST	CPOPJ1		;TAKE SUCCESS RETURN
>;	END IFN	RIDSW

OPAHEL:	PUSH	P,CH
	SKIPE	M,OPRAH		;TYPE CALLERS HELP MSG FIRST
	OUTSTR	(M)		;TYPE THE USER'S MSG
	OUTSTR	OPAHMS		;THEN TYPE GEN'L HELP MSG
;**; [124]	INSERT @ OPAHE2	DML	3-AUG-76
	OUTSTR	OPAHM1		;[124] PRINT OUT OTHER PARTS
	OUTSTR	OPAHM2		;[124]    OF HELP MESSAGES
OPAHE2:	MOVEI	A,2
	POP	P,CH
	JRST	CPOPJ1

OPASTA:	TLZA	F,L.STOP
OPASTO:	TLO	F,L.STOP
	PUSHJ	P,SETMOD
	  POPJ	P,
	JRST	OPACA2

	;/WHAT -- REPEAT THE CURRENT REQUEST
OPAWHT:	TTCALL	3,RPTTY
	MOVEI	A,2
	JRST	CPOPJ1

OPAHMS:	ASCIZ*/CANCEL  Cancel this command
/REELID:XXX	Set the REELID for this tape
/DEFER:n Defer command where n is hh:mm or mm
/WAIT	Defer the request and waiT for further Operator input
/PAUSE	 Pause for Operator input after current operation
/START:x Start processing x requests
/STOP:x  Stop processing x requests	*
;**; [124]	CHANGE @ OPAHMS+6	DML	3-AUG-76
;**; [124] INSERT THE "*" DELIMITER AT END OF "STOP:X...." STRING
;**; [124]	DELETE @ OPAHMS+7	DML	3-AUG-76
;**; [124]	INSERT @ OPAHMS+7	DML	3-AUG-76
OPAHM1:	IFN FILESW,<ASCIZ/
	x=ALL,NONE,FILE,MOUNT/>	;[124]
; END OF IFN FILESW		;[124]
	IFE FILESW,<ASCIZ/
	x=ALL,NONE,MOUNT/>	;[124]
; END OF IFE FILESW		;[124]
OPAHM2:ASCIZ*
/WHAT	 Retype the request
/HELP	 Type this message
*

;OPERATOR COMMANDS AND HELP MESSAGE

OPCTAB:	SIXBIT	/MOUNT/
	SIXBIT	/DISMOU/
	SIXBIT	/REMOVE/
	SIXBIT	/LOCK/
	SIXBIT	/USERS/
	SIXBIT	/HELP/
	SIXBIT	/START/
	SIXBIT	/ST/
	SIXBIT	/STOP/
	SIXBIT	/KILL/
	SIXBIT	/WHAT/
	SIXBIT	/WAIT/
	SIXBIT	/GO/
	SIXBIT	/PAUSE/
	SIXBIT	/EXIT/
	SIXBIT	/NODEFE/
	SIXBIT	/DEFER/
;**; [165] REMOVE UNLOCK	CLRH	28-MAR-79
REPEAT 0,<			;[165]
IFN FTTLAB,<
	SIXBIT	/UNLOCK/	;[142]
>;[142] END FTTLAB
>				;[165] END OF UNLOCK REPEAT 0
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	SIXBIT	/NEXT/	;[143]
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
	0			;0 FOR END OF TABLE

OPCDIS:	MOCOMT
	DICOMT
	RECOM
	LOCOM
	USCOM
	HECOM
	STACOM
	STACOM
	STOCOM
	KILCOM
	WHTCOM
	WAICOM			;"WAIT" COMMAND PROCESSOR
	GOCOM			;"GO" COMMAND PROCESSOR
	WAICOM			;"PAUSE" COMMAND PROCESSOR
	EXICOM			;"EXIT" COMMAND PROCESSOR
	NODCOM			;"NODEFER" COMMAND PROCESSOR
	DEFCOM			;"DEFER" COMMAND PROCESSOR
;**; [165] REMOVE UNLOCK	CLRH	28-MAR-79
REPEAT 	0,<		;[165] REMOVE UNLOCK CODE
IFN FTTLAB,<
	ULKCOM		;[142] UNLOCK A LOCKED STRUCTURE
>;[142] END FTTLAB
>			;[165] END OF UNLOCK CODE REPEAT 0
;**; [167] REMOVE NEXT COMMAND	28-MAR-79
REPEAT	0,<		;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	NXTCOM		;[143] PROCESS THE Nth REQUEST IN THE QUEUE
>;[143] END FTTLAB
>			;[167] REMOVE NEXT COMMAND

OPCHEL:	ASCIZ\
START:x Start processing x requests
STOP:x  Stop processing x requests
KILL:x  Delete all pending x requests	\
;**; [124]	CHANGE @ OPCHEL+3	DML	3-AUG-76
;**; [124] INSERT THE "\" DELIMITER AT END OF "KILL:X..." STRING
;**; [124]	DELETE @ OPCHEL+4	DML	3-AUG-76
;**; [124]	INSERT @ OPCHEL+4	DML	3-AUG-76
;**; [167] REMOVE NEXT COMMAND AT OPCHE1	CLRH	28-MAR-79
REPEAT	0,<			;[167]
OPCHE1: IFN FILESW,<IFE FTTLAB,<ASCIZ/
	x=ALL,NONE,FILE,MOUNT/>	;[143][124]
		    IFN FTTLAB,<ASCIZ/
	x=ALL,NONE,FILE,MOUNT,NEXT(implies ALL)/>
>;[143] END OF IFN FILESW		;[124]
	IFE FILESW,<IFE FTTLAB,<ASCIZ/
	x=ALL,NONE,MOUNT/>	;[143][124]
		    IFN FTTLAB,<ASCIZ/
	x=ALL,NONE,MOUNT,NEXT(implies ALL)/>
>;[143]  END OF IFE FILESW		;[124]
>			;[167] END OF REMOVE NEXT COMMAND
OPCHE1:	IFN	FILESW,<ASCIZ/
	x=ALL,NONE,FILE,MOUNT/>	;[167]
	IFE	FILESW,<ASCIZ/
	x=ALL,NONE,MOUNT/>	;[167]
;**; [165] REMOVE REFERENCE TO UNLOCK FROM STRING AT OPCHE2	CLRH	28-MAR-79
;**; [167] REMOVE REFERENCE TO NEXT FROM STRING AT OPCHE2	CLRH	28-MAR-79
OPCHE2:	ASCIZ\
WAIT	Wait for further Operator input
PAUSE	Same as "WAIT"
GO	Continue from a 'WAIT' condition
EXIT	Return to Monitor
MOUNT   Mount F/S -or- Set REELID for a magtape drive
DISMOU  Remove F/S from system
REMOVE  Remove F/S from system and stop drive if possible
LOCK    Lock-out F/S from further access
USERS n   Type current users of F/S (where n=DEVn, /ALL or /PRIVAT)
WHAT	Retype the request
DEFER	Process DEFERed requests normally
NODEFER	Process DEFERed requests now
HELP	Type this message
\

;	SWITCHES FOR USERS COMMAND
;

USWIT:	XWD	USDIS,USTAB	
USTAB:	SIXBIT	/ALL/
	SIXBIT	/PRIVAT/
	EXP	0
USDIS:	USCALL
	USCPRI
;OPERATOR REPLIES TO 'PROCEED?'

OPRTAB:	SIXBIT	/NO/
	SIXBIT	/CANCEL/
	SIXBIT	/YES/
	SIXBIT	/DEFER/
	SIXBIT	/HELP/
	SIXBIT	/START/
	SIXBIT	/ST/
	SIXBIT	/STOP/
	SIXBIT	/WHAT/
	SIXBIT	/WAIT/
	SIXBIT	/PAUSE/
IFN RIDSW, <
	SIXBIT	/REELID/
>;	END IFN	RIDSW
	0		;0  ENDS THE TABLE

OPRDIS:	OPRNO
	OPRNO
	OPRYES
	OPRDEF
	OPRHLP
	OPRSTA
	OPRSTA
	OPRSTO
	OPRWHT
	OPRWAI		;"WAIT" COMMAND PROCESSOR
	OPRPAU		;"PAUSE" COMMAND PROCESSOR
IFN RIDSW, <
	OPRRID		;"REELID" COMMAND PROCESSOR
>;	END IFN	RIDSW

OPRHEL:	ASCIZ\
CANCEL   Cancel this command
NO       =CANCEL
YES      Proceed if possible
REELID:XXX	Set REELID for this tape
WAIT	 Wait for further Operator input
PAUSE	 Pause for Operator input after current operation
START:x  Start processing x requests
STOP:x   Stop processing x requests	\
;**; [124]	CHANGE @ OPRHEL+10	DML	3-AUG-76
;**; [124] INSERT THE "\" DELIMITER AFTER THE "STOP:X..." STRING
;**; [124]	DELETE @ OPRHEL+11	DML	3-AUG-76
;**; [124]	INSERT @ OPRHEL+11	DML	3-AUG-76
OPRHE1:	IFN FILESW,<ASCIZ/
	x=ALL,NONE,FILE,MOUNT/>	;[124]
;END OF IFN FILESW		;[124]
	IFE FILESW,<ASCIZ/
	x=ALL,NONE,MOUNT/>	;[124]
; END OF IFE FILESW		;[124]
OPRHE2: ASCIZ\
DEFER/DEFER:n Defer command where n is hh:mm or mm
WHAT	 Retype the request
HELP	 Type this message
\
;MODE SWITCH COMMAND ARGUMENTS (ORDER IS IMPORTANT)

MODTAB:
IFN FILESW,<
	SIXBIT	/FILE/
>;	END IFN FILESW
	SIXBIT	/MOUNT/
MODALL:	SIXBIT	/ALL/
	SIXBIT	/NONE/
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
MODNXT:	SIXBIT	/NEXT/	;[143]
>;[143] END FTTLAB
>				;[167] REMOVE NEXT COMMAND
	0

;**;[114] INSERT CONDITIONAL @ MODVAL	JNG	8-Sep-75
MODVAL:
IFN FILESW,<			;[114]
	MODEF
>;[114] END IFN FILESW
	MODEM
	MODEF!MODEM
	0
;**; [167] REMOVE NEXT COMMAND
REPEAT	0,<		;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
	MODEF!MODEM	;[143]
>;[143] END FTTLAB
>			;[167] REMOVE NEXT COMMAND
MODNUM==.-MODVAL

MODNAM:
IFN FILESW,<
NAMFIL:	SYSFIL
>;	END IFN FILESW
NAMMNT:	SYSMNT
NAMALL:	SYSALL
NAMNON:	SYSNON
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<		;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
NAMNXT:	SYSALL		;[143]
>;[143] END FTTLAB
>			;[167] REMOVE NEXT COMMAND
DEFINE MT (NAME,TEXT) <
NAME:	XLIST
	ASCIZ \TEXT\
	LIST>

BELMSG:	BYTE (7) 7,177,7,177,7,0
MT CMPMSG,<--Done-->
MT DLYMSG,< Delay was >
MT DRVMSG,<on >
MT FORMSG,< for user [>
MT FREMS1,<Free: >
MT FREMS2,< Blks, >
MT FREMS3,< Files
>
MT MNTMSG,<Mount Tape >
MT WRTMSG,<Write-Enabled >
MT WRLMSG,<Write-Locked >
BADID1:	BYTE	(7) 7,177,7,177,7,7,177,7,177,7  ;BELLS
	ASCIZ	/
Actual Tape ID /			;AND BEGINNING TEXT
MT BADID2,< on >
MT BADID3,<:
  Does not match User-Requested Tape # >
MT BADID4,<Type 'I' to ignore Tape-ID difference
Type 'N' to change tape drives
Type 'C' to cancel this request
Or mount correct tape and type 'Y': >
MT BADID5,<Type I,C,N,Y or H:>
MT BLNKID,<
Tape mounted has a Blank Tape ID
>

MT ENMSG,<
%Please Write-Enable >
MT WLMSG,<
%Please Write-Lock >
MT ENMSG1,<Type 'N' to change tape drives
Type 'C' to cancel this request
Or set write-status correctly and type 'Y': >
MT ENMSG2,<Type I,N,C,Y or H:>
MT ENMSG3,<Type N,C,Y or H:>
SUBTTL	DATA & STORAGE
;FIXED DATA

MFDPPN:	XWD	1,1
PDP:	IOWD	40,PDLIST	;[115]
PCRETM:	POINT	11,C,23	;CREATION TIME
PCREDA:	POINT	12,C,35	;CREATION DATE
SYSPPC==MFDPPN
SYSPPD:	XWD	1,4
FSFPPN:	XWD	1,2

;LITERALS HERE (UNDER XLIST)
XLIST
LIT
LIST

HIEND:
UU(DIRIOW,2)
U(CMDPPN)
U(CMDSTR)
U(SYSPPN)
U(CMDCDA)
U(CMDCHR)
U(CMDCTM)
U(CMDJOB)
U(CMDNAM)
U(CMDTAP)
U(CMDTTY)
U(DIRDEV)
U(DTDRIV)
U(DTNMSG)
U(FILDEV)
U(FILEXT)
U(FILNAM)
U(FILPPN)
U(TSTNAM)
U(TSTEXT)
U(FILMSK)
U(EXTMSK)
U(WLDFND)
UU(XLUBLK,17)
U(NOWMIN)
U(SAVC)
U(SAVD)
U(SAVCNT)
U(STATES)
U(STRPTR)

U(TERMCH)
U(TODAY)
U(USRPPN)

UU(PDLIST,40)			;[115]

UU(DTADIR,200)
DTDBYT=DTADIR+0
DTDFIL=DTADIR+^D83
DTDEXT=DTADIR+^D105
DTDNFI=^D22
UU(DTWTAB,1)	;FILE ACCESS TABLE, BIT 35-N ON IF FILE N PROCESSED
;IMPURE STORAGE

U(JIFFYS)		;STORES JIFFIES/SEC
U(NODEFR)		;NODEFER FLAG
;**; [167] REMOVE NEXT COMMAND	CLRH	28-MAR-79
REPEAT	0,<			;[167] REMOVE NEXT COMMAND
IFN FTTLAB,<
U(NXTFLG)		;[143] NON-ZERO IF DOING NEXT MODE PROCESSING
U(NXTREQ)		;[143] NUMBER IF THE NEXT REQUEST TO BE PROCESSED
U(CURREQ)		;[143] CURRENT REQUEST NUMBER
>;[143] END FTTLAB
>			;[167] REMOVE NEXT COMMAND
IFN OFFLIN,<
U(NCHKFG)
U(OFFDSK)
>;	END IFN OFFLIN
U(FS1PPN)
U(OURJOB)	;OUR JOB NO.
U(OURPPN)	;OUR PPN NO.
U(FSUUNM)	;NUM. DRIVES USER TYPED
U(FSTEMP)	;TEMPORARY
U(FSUPA)	;ADDRESS OF CURRENT UNIT PAR. BLOCK
U(FSLUN)	;CURRENT LOG.UNIT NUM.
U(FSUNM)	;NUM. OF UNITS IN FS.
U(FSUAOB)	;=XWD -NUM.UNITS,0   FOR AOBJ PTRS
U(DVVNAM)
FSNAME==DVVNAM		;6 BIT NAME OF FS.
U(LOGNAM)
U(PHYNAM)
IFE FTTLAB,<
U(REELID)
>
IFN FTTLAB,<
UU(REELID,20)
U(NVOLS)
U(LABTYP)
U(EXPDAT)
U(PROTEC)
U(LABITN)

UU(IPS.DT,MOU.SZ);	;PACKET FOR IPCF SENDS
UU(IPS.BL,4);	;HEADER FOR SENDS
UU(IPR.BL,6);	;HEADER FOR RECEIVES
U(LABPOS)
>
U(DEVMOD)
VIDL==<VIDMAX+4>/5
UU(VID,VIDL)
U(VIDK)
U(TYPENA)			;HAVE TYPED LONG ENABLE MSG
U(TYPBAD)			;HAVE TYPED LONG BAD-ID MSG
U(FSDES)	;BITS FOR UNIDES (SING-ACCESS & WRITE PROT.)
U(FSBPU)	;BLOCKS/UNIT FOR CURRENT UNIT
U(FSCNP)	;PTR. TO RET.PTR. COUNT FIELD
U(FSCLP)	;"""ADDRESS"""
U(FSATPT)	;PTR. TO SAT-RIB PTR.S
U(FSPTAD)	;ADDR. OF CURRENT SPT WORD
U(FSTRY)	;STRTRY (NUM. ERRORRETRIES) VALUE
U(OWNPPN)	;PPN OF F/S OWNER (FROM STRLST.SYS)
FSPPN=USRPPN	;PROG PROG # OF USER REQUESTING MOUNT/DISMOUNT
FSJOB=CMDJOB	;JOB NUM. """
U(NOTDON)	;NON-ZERO IF REQUEST UNSUCESSFUL

IFN DIAGSW, <
UU(DIRFLG,1)	;NON-ZERO IF FILE 'DIR' FILE ENTERED
>;	END OF	IFN DIAGSW
UU(WAITFG,1)	;0 = NOT IN 'WAIT' CONDITION, -1 = IN 'WAIT' CONDITION
UU(CMDLTH,1)	;-1 IF MULTI-BLOCK CMD FILE BEING PROCESSED
		; 0 IF UN-READ 1-BLOCK CMD FILE
		;+N FOR 'N' CHARS IN CMD FILE IN CORE
UU(CMDSBP,1)	;SAVED BUFFER POINTER FOR IN-CORE CMD FILE
;**; [160] INSERT AFTER DEFINITION OF CMDSBP	CLRH	8-DEC-78
UU(CMDDTM,1)	;[160] CREATION DATE/TIME OF CURRENT .CMD FILE
UU(CMFSVD,TYPL);SAVED COMMAND FILE NAMES (1 PER TYPE)
UU(FNDFLG,1)	;NON-ZERO IF SOMETHING FOUND ON CURRENT UFD PASS
UU(PRVFND,1)	;NON-ZERO IF SOMETHING FOUND ON LAST UFD PASS
UU(PRCFLG,1)	;NON-ZERO IF COMMAND BEING PROCESSED
UU(REWFLG,1)	;-1 IF UFD NEEDS REWINDING, .GE. 0 OTHERWISE
UU(INTBLK,4)		;ERROR-INTERCEPTION BLOCK


UU(RH.TTY,3)
UU(WH.TTY,3)
UU(FSASTR,SS.L)	;STR PARAM.BLK FOR STRUUO(.FSDEF)
UU(FSAUNI,<MAXUNI*<SU.L+MAXSPT>>) ;UNI PARAM. & SPT BLKS. FOR STRUUO(.FSDEF)
UU(GOBSTA,5)		;GOBSTR ARG.LIST
FSRDFA==GOBSTA	;STRUUO(.FSRDF) ARG.LIST
UU(FSDSLA,3*MAXFSL+7)	;STRUUO(.FSDSL) ARG.LIST
UU(PDRIVE,MAXUNI)	;PHYS.DRIVE NAMES (IN LOG.UNIT ORDER)
UU(UNITID,MAXUNI)	;CORRESPONDING LIST OF PACK ID'S
UU(UNITCL,MAXUNI)	;   AND PACK CLASS
;**; [163] INSERT AFTER DEFINITION OF UNITCL	CLRH	23-FEB-79
UU(UNICHK,MAXUNI)	;[163] TEMPORARY USED DURING MOUNTING
			;[163] TO CHECK MULTIPACK STRUCTURES
UU(UDRIVE,MAXUNI)	;USER DRIVE REQUESTS
UU(DSKCHA,DSKCHL)	;DSKCHR UUO ARG.LIST
UU(HOME,200)	;HOME BLOCK STORAGE
UU(SATRIB,200)	;SAT-RIB STORAGE
UU(SAT,200)	;SAT BLOCK STORAGE


UU(SAVEAC,20)	;SAVE AC'S ON REENTER


UU(IDFLAG,1)	;0 = DECTAPE NOT VERIFIED, -1 IF VERIFIED
UU(DTCHAN,1)	;CHANNEL # TO USE FOR TAPE CHECKING (IN AC FIELD)
UU(WRTDPF,1)	;0 = DON'T TYPE DEV: & [P,P] ON FILE R ERRORS
		;-1 = DO TYPE THAT INFORMATION
SWPDSP==7		;SWAP TBL. DISPLACEMENT IS NOT RETURNED BY MON
SWPMAX==10		;MAX NO. OF SWAP UNITS
U(SWPAOB)		;AOBJN PTR FOR SWPTAB
UU(SWPTAB,SWPMAX+1)
;**; [122] INSERT @ SWPMAX+3	JULY 27, 1976	DML
U(NOSCAN)	;[122] NO RESCAN FLAG
U(DEVSCN)	;[122] PREVIOUSLY SUGGESTED DEVICE
;I/O BUFFER AREAS

UU(B.CMU,205)
UU(B.CMD,205)
UU(B.USR,205)
UU(B.DTA,2*205)
UU(B.DSK,2*205)
UU(B.TTY,2*30)
UU(B.DIR,205)	;DIRECTORY FILE BUFFER
U(RPTTYB)	;BYTE POINTER
U(RPTTYC)	;BYTE COUNT
UU(RPTTY,RPTSIZ+2)	;COPY OF TTY OUTPUT
U(NOSTAR)		;FLAG FOR START COMMAND

IFN FTFACT, <
UU(FACT,1)	;DAEMON (.FACT) REQUEST CODE (= 3)
UU(F.HEAD,1)	;DAEMON FACT ENTRY - HEADER W/ CODE 251 (SPOOLED ENTRY)
UU(F.PPN,1)	; - USER'S PPN
UU(F.DATE,1)	; - CURRENT DATE & TIME (SUPPLIED BY DAEMON)
UU(F.QUE,1)	; - 0-11 QUEUE NAME (OF,OM,OD), 12-17 STATION #,
		;	  18-35 APR0 SERIAL #
UU(F.TIME,1)	; - CPU TIME USED BY OMOUNT IN MSEC.
UU(F.KCS,1)	; - KILO-CORE-TICKS USED BY OMOUNT
UU(F.RCT,1)	; - DISK BLOCKS READ BY OMOUNT
UU(F.WCT,1)	; - DISK BLOCKS WRITTEN BY OMOUNT
UU(F.DEV,1)	; - DEVICE NAME USED BY THE REQUEST
UU(F.SEQ,1)	; - (SEQUENCE #) NOW ZERO
UU(F.UNIT,1)	; - SPOOLER UNITS - 0 = RQST CANCELLED, 1 = SUCCESSFUL
F.SIZE==F.UNIT-FACT+1	;LTH OF DAEMON PARM BLOCK
UU(FACTFL,1)	; 0 = NO ACCT'G, -1 IF ACCT'G BEING DONE
>;	END OF	IFN FTFACT

	RELOC
	VAR
LOEND:	END	OMOUNT
