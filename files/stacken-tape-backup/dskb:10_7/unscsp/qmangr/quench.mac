	TITLE	QUENCH  --  Queue Entry and Change Program


;
;
;        COPYRIGHT (c) 1975,1976,1977,1978,1979,1980,1981,1982,
;			 1983,1984,1985,1986
;                    DIGITAL EQUIPMENT CORPORATION
;			 ALL RIGHTS RESERVED.
;
;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED
;     AND COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE
;     AND WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS
;     SOFTWARE  OR ANY OTHER COPIES THEREOF MAY NOT BE PROVIDED OR
;     OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON.  NO  TITLE  TO
;     AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY DIGITAL EQUIPMENT CORPORATION.
;
;     DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY
;     OF  ITS  SOFTWARE  ON  EQUIPMENT  WHICH  IS  NOT SUPPLIED BY
;     DIGITAL.


	SEARCH	SCNMAC,ORNMAC

	SEARCH	GLXMAC
	SEARCH	QSRMAC
	SEARCH	UUOSYM

	.REQUE	REL:SCAN		;SYSTEM COMMAND SCANNER
	.REQUE	REL:WILD		;COMMON FILE-SYSTEM MANIPULATOR
	.REQUE	REL:HELPER		;SYSTEM HELP TEXT TYPER


;VERSION INFORMATION

	QUHVER==5			;MAJOR VERSION
	QUHMIN==0			;MINOR VERSION
	QUHWHO==0			;WHO LAST PATCHED
	QUHEDT==525			;EDIT NUMBER

	%%.QUH==VRSN.(QUH)

	LOC	137
	EXP	%%.QUH

	SALL				;SUPPRESS MACRO EXPANSIONS
SUBTTL	TABLE OF CONTENTS

;               TABLE OF CONTENTS FOR QUENCH
;
;
;                        SECTION                                   PAGE
;    1. TABLE OF CONTENTS.........................................   2
;    2. PARAMETERS AND DEFAULTS...................................   3
;    3. Revision History..........................................   6
;    4. QUENCH AC'S...............................................   8
;    5. Message Macros............................................  12
;    6. Initialization............................................  13
;    7. Main Processing Loop......................................  15
;    8. ROUTINES TO HANDLE CALLS FROM TSCAN.......................  17
;    9. FILL IN DEFAULTS AFTER COMMAND SCANNING...................  20
;   10. COMMAND PROCESSING........................................  34
;   11. Command Processing  --  DEFER.............................  36
;   12. COMMAND PROCESSING -- CREATE..............................  37
;   13. LIST - ROUTINE TO PROCESS QUEUE LIST REQUEST..............  44
;   14. LISTR - ROUTINE TO OUTPUT THE QUEUES LIST ANSWER..........  45
;   15. Command Processing Subroutines............................  46
;   16. BLDROB - BUILD REQUESTED OBJECT BLOCK................  54
;   17. SETNODE - ROUTINE TO GENERATE THE CORRECT /NODE: SPEC.....  55
;   18. General Subroutines.......................................  56
;   19. COMMAND SCANNING SUBROUTINES..............................  59
;   20. ACCTSW - SCAN ACCOUNT SWITCH PROCESSING ROUTINE...........  68
;   21. Fatal Error Message Routines..............................  70
;   22. Non-fatal Error Message Routines..........................  71
;   23. STORAGE...................................................  72
SUBTTL	PARAMETERS AND DEFAULTS


;ASSEMBLY PARAMETERS

ND LN$PDL,60		;LENGTH OF PUSH-DOWN LIST
ND LN$ENT,11		;LENGTH OF A LOOKUP/ENTER BLOCK
ND LN$DSK,5		;LENGTH OF DSKCHR BLOCK

ND PUNCDP,0		;-1=NO PUNCH COMMAND
			;0=PUNCH COMMAND TO PTP
			;1=PUNCH COMMAND TO CDP

	;SECONDARY PARAMETER BLOCK FOR QMANGR

		PHASE	0
.LSTYP:! BLOCK	1		;FIRST WORD IS /LIST FLAG BITS
.LSDES:! BLOCK	1		;LIST DESTINATION NODE
.LSPRC:! BLOCK	1		;LIST PROCESSING NODE
.ACCTS:! BLOCK	10		;ASCIZ ACCOUNT STRING (MAX 39 CHARS)
.ROBLK:! BLOCK	ROBSIZ		;REQUESTED OBJECT BLOCK
.DNODE:! BLOCK	1		;/DESTINATION NODE FOR BATCH REQUESTS
.AG2LN:!			;BLOCK LENGTH
		DEPHASE


	TWOSEG				;TWO SEGMENT PROGRAM
	RELOC	400000			;START IN HISEG

;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1971,1986.
;ALL RIGHTS RESERVED.
;DEFAULTS


	RADIX	^D10
DM AFT,  10080,   0,  10	;AFTER CURRENT TIME IN MINUTES
DM CDP,^O777777, 000,2000	;CARD PUNCH LIMIT IN CARDS
DM COP,     63,   1,   0	;NUMBER OF COPIES OF OUTPUT
DM COR,^O777777,25600,40960	;CORE LIMIT FOR JOB
DM DPN,  65535,   0,   0	;INITIAL DEPENDENCY COUNT
DM LIM,^O777777,  00,   0	;OUTPUT LIMIT
DM LPT,^O777777,  00,2000	;LINE PRINT LIMIT IN PAGES
DM NOD,	77,0,0			;NODE NAME
DM NHD,      1,   1,   1	;FILE HEADERS ON OUTPUT
DM NTF,      1,   0,   1	;NOTIFY
DM PLT,^O777777,  00,  60	;PLOT LIMIT IN MINUTES		[1201]
DM PRI,     63,  10,  20	;[510] EXTERNAL PRIORITY
DM PTP,^O777777, 000, 100	;PT PUNCH LIMIT IN FEET
DM RID, ^O377777, 0,   0	;REQUEST ID
DM RST,      1,   0,   1	;RESTART PARAMETER
DM SEQ, 100000,   0,   0	;JOB'S SEQUENCE NUMBER
DM STR, 100000,   1,   1	;STARTING POINT IN FILE
DM TIM,  .INFIN, 300,3600	;TIME LIMIT FOR JOB IN SECONDS
DM UNI,      2,   1,   2	;DEGREE OF FILE NAME UNIQUENESS
DM UNT,	7,0,0			;UNIT NUMBERS


ND AD.LFD,DISPPRESERVE	;LOG FILE DISPOSITION
ND AD.OPN,.QORCR	;STANDARD OPERATION IS /CREATE
	RADIX	8


;THE QUEUES MACRO DEFINES ALL PARAMETERS WHICH NEED TO BE
;	EXPANDED INTO TABLES FOR THE VARIOUS QUEUES.
;
;EACH LINE IN THE QUEUES MACRO IS OF THE FORM:
;
;	QQ	A,B
;
;WHERE:
;	A	IS THE QUEUE NAME
;	B	MONITOR COMMAND FOR THE QUEUE

DEFINE QUEUES,<
	QQ	INP,<SUBMIT>
	QQ	LPT,<PRINT>
	QQ	CDP,<CPUNCH>
	QQ	PTP,<TPUNCH>
	QQ	PLT,<PLOT>
	QQ	PAT,<.PATCH>
>  ;END DEFINE QUEUES


;NOW INSURE THAT INP QUEUE IS FIRST AND DEFINE QUEUE TYPE SYMBOLS
DEFINE	QQ(A,B),<
	IFDIF	<A>,<INP>,<PRINTX  ?FIRST QUEUE MUST BE INP>
	..TMP==0
	QTP'A==..TMP
	DEFINE	QQ(Z,Y),<
		..TMP==..TMP+1
		QTP'Z==..TMP
	>  ;END REDEFINITION OF QQ
>  ;END DEFINE QQ


IF1,<	QUEUES	>
SUBTTL	Revision History

;1	MAKE THIS QUENCH VERSION 1 FROM QUEUE VERSION 6
;2	PUT IN TOPS20 CODE
;3	CODE CLEANUP
;4	PUT IN NEW /OUTPUT STUFF
;5	ALWAYS FORCE JACCT OFF ON TOPS10

;50	MAKE THIS QUENCH VERSION 2
;	CALL QMANGR WIL QUEUE FORMAT VERSION 2 (Q.OPR<QO.VER>)
;51	ALLOW /TAG TO BE FULL 6 CHARACTERS LONG
;52	REMOVE SOME UNUSED ROUTINES
;53	CHANGE ALL CHECKS ON F.STRT AND I.STRT TO NOT USE SKIPL
;	AND SKIPGE SINCE WITH 6 CHARACTER NAMES THE WRONG THING HAPPENS.
;54	DO NOT DEFAULT THE /PRIO FIELD.
;55	REMOVE /PAPER SWITCH, ADD /PRESERVE AS SYNONYM FOR /DI:PRES
;	REMOVE /DI:RENAME, AND CHANGE LISTING FORMAT ON -20 TO PUT
;	USER NAME LAST.
;56	ON -20 IF LOOKUP ON THE FILE SUCCEEDS, SET BIT 15 IN Q.FMOD
;	AND PASS THE FILESPEC BLOCK AS A STRING TO QMANGR.
;57	ADD /USER SWITCH ON -20, PASS Q.PPN AS 0,,ADR WHERE ADR HAS A STRING.
;60	CONDITIONAL OUT LOTS OF CODE ON -20.  REARRANGE QUEUE LISTING FORMAT
;	ON THE -10.
;61	IN QUEUE LISTING, ONLY PRINT THE "CORE" COLUMN IF INPCOR IS NOT 0.
;62	TO GET TIME OF DAY DO APPROPRIATE UUO OR JSYS RATHER THAN CALLING
;	.GTNOW.
;63	CHANGE TEXT FOR INP QUEUE TOTALS TO JUST "RUNTIME".  FIX -20
;	STRUCTURE CHECKING CODE IN LIST ROUTINE.
;64	MORE OF EDIT 63 AND RANDOM CLEANUP.
;65	REMOVE SEARCH JOBDAT.

;;FIRST FIELD-TEST RELEASE OF GALAXY VERSION 2, JANUARY 1977

;66	MAKE CHECK FOR OFF-LINE STRUCTURE (-10) IN THE LISTER THE
;	SAME AS THE ONE IN QUASAR.
;67	MAKE DEFAULT INPUT DEVICE ON -20 ALWAYS "DSK".  MAKE THE
;	LOOKUP OF THE BATCH LOG FILE ALWAYS SPECIFY THE USER'S PATH.
;70	A FEW MORE LOG FILE FIXES.
;71	FIX ERROR MACROS AND CHANGE "ONE" OF THE "QUHPSI" ERRORS TO
;	"QUHPII".  FIX A PROBLEM IN EDIT 70.  MAKE /TIME SWITCH ALLOW
;	ONLY THREE FIELDS AND GIVE AN ERROR IF MORE A SPECIFIED.

;;SECOND FIELD-TEST RELEASE OF GALAXY VERSION 2, MARCH 1977

;72	FIX A NUMBER OF MINOR PROBLEMS (QAR #32 AND 33).
;400	MAKE THIS VERSION 4.  JUNE, 1977.
;401	REMOVE THE /UNPRESERVE SWITCH ON THE -10.  FIX A NUMBER OF
;	PROBLEMS WITH DEFAULT FILE SWITCHES NOT BEING APPLIED CORRECTLY.
;	REMOVE THE /REMOVE SWITCH.
;402	FIX A MINOR PROBLEM WITH EDIT 401.
;403	FIX SOME PROBLEMS DEFAULTING EXTENSIONS.
;404	FIX A NUMBER OF MINOR PROLBEMS.  START PUTTING IN SOME NEW
;	SWITCHES: /LOWER/UPPER/UNIT/NODE.
;405	ADD MORE CODE FOR NEW LISTING FORMAT.
;406	ADD THE /NEWLOG AND /OLDLOG SWITCHES
;407	MORE WORK ON /UNIT/NODE/LOWER/UPPER ...
;410	REMOVE SOME FTJSYS CODE.
;	REMOVE LISTING FORMATTING ROUTINES.
;	LAY FOUNDATION FOR DISP:RENAME
;	MAKE /NODE: RETURN EITHER A SIXBIT NAME OR A BINARY-OCTAL NUMBER
;411	REMOVE MORE FTJSYS CODE
;	PUT IN /DISP:RENAME
;412	MAKE /UNIQUE WORK RIGHT
;413	MAKE /CREATE & /MODIFY USE COMMON CODE FOR /UNIT & /NODE
;414	CORRECT CARD PUNCH QUEUE TO .OTCDP
;415	CORRECT /AFTER: PARAMETER
;416	Fix LL:, LU:, and LPTxxy  so that they work again.
;	Put in warnings if they use LL:, LU:, or LPTxxy.
;417	Add /RDR support so that a user can put input requests into
;	the SPRINT Queue.
;	The Command is : SUB FILE-SPEC/RDR
;420	Fx a QMANGR bug caused by the new /RDR code.
;421	Add /NOTIFY code
;422	Add /REQUESTID code
;423	Delete /NEWLOG & /OLDLOG switches and replace them with
;	/BATLOG:APPEND or SUPERSEDE or SPOOL
;	Add /OPRINT:YES or NO for operator intervention allowed
;424	Change /UNIQUE so that it accepts either :0 or :1
;	or :NO or :YES as possible values.
;425	Make /LOWER /LOWERCASE, Make /UPPER /UPPERCASE,
;	Make /RDR /READER, Delete /DEADLINE
;426	Remove Q.CNO and replace it with Q.RID
;427	Fix /AFT default for /MODIFY requests
;430	Delete the UNI switch definition from the SWTCHS macro.
;	This will force /UNIT and /UNIQUE to be unique 
;431	Delete the PPN check at CREAS2 so that the user name will
;	always be filled in.
;432	Make default print extension .LST not .LPT
;	Don't make the /BATLOG: switch equal SPOOL if SUBMIT/READER.
;	Re-activate /DISP:RENAME
;433	Tell user CANCEL command is not implimented yet
;434	Fix a bug in /GENERIC modify code so that it passes the
;	correct code in the ROB
;435	Change Q.LTYP to Q.FLAG, which will point to a secondary QMANGR
;	argument block. Q.FLAG will contain Address,,0 so that we
;	can check for a possible /DEADLINE parm in QMANGR.
;
;436	Add ACCOUNT switch processing
;
;437	Remove search of MACTEN and change PJSP to JSP
;
;440	Add Account Validation Support to QMANGR 
;	Also fix SPR 10-24534 (PUNCH/PLOT with indirect files)
;
;441	Change /OPRINT to /ASSIST
;
;442	Rework the secondary parm block to contain the ROB and /Destination-node
;	for IBM and batch requests
;	Add /SITGO support
;	Add support for new device attributes
;
;443	Add a new routine CHKATR to validate specified device attributes
;	Fix a bug in modify code
;
;444	Add routine CHKNOD to process/default the node switches.
;	Delete the /NODE switch, and change /PNODE to /PROC and
;	/DNODE to /DEST
;
;445	Default S.PROC to be the host node number and S.DEST to be the
;	users location in CHKNOD.
;
;446	SPR 20-27679 Make ersatz device submits work.
;
;447	Take the definition of the /CORE switch out from under IFN INPCOR
;	conditionals.
;
;450	Modify list to pass new information to QMANGR. This makes list
;	commands such as .PRINT LPT12:,[10,*],FOO?? all work again.
;
;451	Implement /DISP:RENAME in a new fashion, with hooks in QUASAR.
;	We dont do the SPPRM. UUO, nor have any of its side effects,
;	like saying 'Spooled printer file', losing /NOTE, making
;	one request for each file, etc. etc.
;
;452	Fix /DEST /PROC on /MODIFY and /LIST
;
;453	Clean up switch table a bit. Make /DEFER into /DEFERRED at the request
;	documentation people. Remove /MET and /METRES switch, had two too many
;	for such a little used switch. Removed /RID, already have a /REQUESTID
;	switch. Removed /SPACES, /SPACING will do. Changed the definition of
;	/NOTIFY to accept 0, 1, NO, and YES arguments. Put all switches in
;	alphabetical order. Make /MODIFY and /UNIQUE unique to one character.
;
;454	Restore old functionality: Queues can once again be listed to a file.
;
;455	Add .ATR (SIMULA attribute file) and .UNV (macro universal file) to
;	the binary extension table.
;
;456	Make /CHECK imply /LIST:JOBS unless /LIST is also specified.
;	De-implement /LIST:CHECK and remove /LIST:SUMMARY since its not
;	implemented in Galaxy version 4.
;
;457	Clean up the QUEUES macro. All but two of the arguments are no longer
;	used.
;460	Fix up edit 454. It broke wildcard KILL/MODIFY specifications.
;
;461	Don't allow specific files or multiple filespecs on /DEFER.
;
;462	Change /BATLOG definition to dependency word
;
;463	Remove /PUNCH:MNEMONIC since it's not implemented.
;	Make /ACCOUNT:"" (null) work
;
;464	Cleanup (make a macro) list of object types and comment it.
;
;465	Fix bug so that .SUB /PROC:FOO works
;
;466	/CHECK has no counter part. Make it SN so /NOCHECK works
;
;467	Try to check for all the things we cant modify and give errors
;
;470	Make PRINT FOO[3,4]=FOO[,] use logged in PPN not [3,4] for defaults
;	Cleanup handling of /GENERIC/UNIT/LOWER/UPPER/SITGO attributes
;
;471	Fix up switch defaulting a bit.
;
;472	Fix up node name/number validity checking.
;
;473	Fix /Priority defaulting on MODIFY requests
;
;474	Also fix /OUTPUT: and /CORE: defaulting on modify requests
;	Fix LPT2:= so that we go to the right unit number
;
;475	Make /DESTINATION and /PROCESSING work correctly for all flavors
;	of queue listings.
;
;476	Fix a wrong Index accumulator specification in routine GETMDM.
;
;477	Disallow /TIME:HHMMSS since we can't distinguish it from /TIME:seconds.
;
;500	Change max value for /LIMIT from 100000 to 2**18-1
;
;501	Fix /TAG processing so as to make it not part of a file-spec
;
;502	Correct testing for directory device.  GCO 1393
;
;503	Make list requests like .PRINT LPT26: work again.  GCO 1417
;
;504	QUENCH routine INDEF1 is inefficient.
;	SPR # 10-34027	27-JUL-83/CTK
;
;505	The /UNIT switch value for a print request is set to the
;	system default in QUASAR's data base when a /MODIFY is done.
;	SPR # 10-34145	14-SEP-83/CTK
;
;506	QUASAR CRL and RRF crashes when a batch job is submitted
;	with the log file device of NUL: and a /OUTPUT:LOG switch.
;	SPR 10-34200	30-SEP-83/CTK
;
;507	QUEUE does not correctly place batch log files
;	when the user has a UFD on two structures, the user
;	is pathed into an SFD on the second structure, the SFD
;	does not exist on the first structure, and the batch
;	control file is in the first structure's UFD.
;	SPR 10-34208	2-OCT-83/CTK
;
;510	Don't let user specify /PRIORITY:0. Rest of GALAXY abides to
;	1 to 63. Also make sure SCAN lets /PRIORITY:63 get by.
;	SPR 10-34293 16-Nov-83 /LWS
;
;511	Edit 505 to QUENCH is incorrect. The /UNIT switches
;	no longer cleared by /MODIFY but it causes problems
;	with /CREATE when no /UNIT is specified. A garbage
;	value is used for a unit when the reqest is listed.
;	SPR 10-34389	18-JAN-84/CTK
;
;512	Generate a warning error message if /UNIQUE is abbreivated
;	to avoid confusion with the /UNIT switch for print requests etc.
;	SPR 10-34130	14-FEB-84/CTK
;
;513	Remove EDIT 507, it introduced other log file placement problems
;	and incorrect error messages.
;	NO SPR		20-FEB-84/CTK
;
;514	Remove EDIT 512, people don't believe you should be warned
;	when you type a command confusing the /UNIT and /UNIQUE
;	switches.
;	NO SPR		28-FEB-84/CTK
;
;515	EDIT 506 introduced an extraneous error message when
;	the object file does not exist.
;	NO SPR		5-MAR-84/CTK
;
;516	We do not use the /OUTPUT: switch default from GALGEN
;	because we reference the wrong symbol, OUTPLOG,
;	reference the correct symbol, INPLOG, instead.
;	SPR 10-33499	5-MAR-84/CTK
;
;517	SUBMIT on behalf of fails when ERSATZ or PATHOLOGICAL
;	devices are part of the input file spec, for example
;	"SUBMIT [10,10]=CTL:X,NUL:" will fail.
;	SPR 10-34508	15-MAR-84/CTK
;
;520	The /DESTINATION:FOODOO passes the SIXBIT translation
;	of the node name instead of number. So pass the octal
;	node number if possible, monitor knows about node,
;	and SIXBIT node name allowing QUASAR to do the translation.
;	SPR 10-34584,10-34586	20-MAR-84/CTK
;
;521	QUEUE does not properly process the /TAG and /BEGIN
;	switches. We do not use the /BEGIN default when a
;	/TAG switch is omitted. We also do not detect when
;	these two mutually exclusive switches are type on
;	the same command line.
;	SPR 10-34676		7-MAY-84/CTK
;
;522	We do not allow /ASSIST to be modified because we
;	don't have code in QUEUE or QUASAR to support it,
;	we don't even have the bits defined. The QUASAR
;	edit 1214 and QMANGR edit 2255 are required for
;	this edit to be functional if these are not
;	installed the /ASSIST functionality will not work.
;	SPR 10-34294	GCO 10046	14-MAY-84/CTK
;
;523	Edit 517 does not handle the "PRINT REL:FILE.EXT[,,EXAMPLE]"
;	command. When an ERSATZ device is part of the file spec
;	QUEUE can not find any SFD's on it.
;	SPR 10-34921	GCO 10126	3-DEC-84/CTK
;
;524	Implement /FONT and /GRAPHICS switches as part of the
;	laser printer support.
;	15-Feb-85 GCO 10147 /NT
;
;525	SWITCH.INI processing is clobbering /FONT switch. Check if
;	anything has been typed, before BLTing the /FONT switch into
;	the data area.
;	11-Feb-85 GCO 101XX /NT
	SUBTTL	QUENCH AC'S


N==7		;NUMBER/NAME ...  USED BY SCAN
C==10		;CHARACTER FROM COMMAND STRING (READ ONLY AC)

I==11		;POINTS TO INPUT FILE SPEC
J==12		;POINTS TO CURRENT FILE IN QUEUE REQUEST
Q==13		;POINTS TO THE QUEUE REQUEST AREA

M==14		;LISTING MESSAGE POINTER
F==15		;FLAGS (LH==PERMANENT, RH==TEMPORARY)
P==17		;PUSH-DOWN POINTER

;I/O CHANNELS

DC==1		;LOOKUP/RENAME DATA FILES
LC==2		;LISTINGS


..==0		;FLAG FOR FIELDS TO BE FILLED IN LATER
;PERMANENT FLAGS (LH)

L.LOGI==(1B17)	;THIS JOB IS LOGGED IN
L.NSBJ==(1B8)	;NOT LOGGED IN TOP LEVEL			[1177]

;TEMPORARY FLAGS (RH)

R.LTAB==1B35	;TAB NEEDED NEXT ON LISTING FILE
R.OUTL==1B30	;LISTING DEVICE NEEDS OUTPUT EACH LINE
R.NSEC==1B28	;SUPPRESS SECONDS LISTING
R.ANUL==1B27	;ALLOW DEVICE NUL:
;X.MOD LAYOUT DEFINITIONS

X.LOG==1B1	;THIS FILE IS THE JOB LOG FILE
X.NEW==1B2	;/NEW
X.NOHD==1B5	;/HEADER
X.STG==1B15	;STRING		;LOCAL USE ONLY
X.OKBN==1B17	;/OKBINARY		;LOCAL USE ONLY

X.SPAC==7B20	;/SPACING
X.PAPR==7B23	;/PAPER
X.FILE==7B26	;/FILE
X.DISP==7B29	;/DISPOSE
X.COP==77B35	;/COPIES


;QUEUE OPERATIONS
	.QORCR==1		;CREATE
	.QORDF==2		;/CREATE/DEFER (GALAXY ONLY)
	.QORZD==3		;/KILL/DEFER (GALAXY ONLY)
	.QORLS==4		;LIST
	.QORMD==5		;MODIFY
	.QORKL==6		;KILL
;MACROS

DEFINE	SWSEG<
		XLIST
		LIT
		LIST
		RELOC>


;GCORE N	GET N MORE WORDS AT .JBFF

DEFINE	GCORE (A),<
	MOVEI	S1,A
	XLIST
	PUSHJ	P,GCORE.
	LIST
>
SUBTTL	Message Macros

DEFINE N$FATE(A,B,C,%A),<
	IF1,<IFNDEF E.'A,<E.'A:>>
	SKIPA
	XLIST
	JRST	%A
	JSP	S1,NFMSG'B
	SIXBIT	\   A\
	ASCIZ	\C\
%A:
	LIST
	SALL
>  ;END DEFINE N$FATE

DEFINE	N$WARN(A,B,C,%A),<
	IF1,<IFNDEF E.'A,<E.'A:>>
	SKIPA
	XLIST
	JRST	%A
	PUSHJ	P,FWARN'B
	<SIXBIT \A\>+[ASCIZ \C\]
%A:
	LIST
	SALL
>  ;END DEFINE N$WARN

DEFINE	N$INFO(A,B,C,%A),<
	IF1,<IFNDEF E.'A,<E.'A:>>
	SKIPA
	XLIST
	JRST	%A
	PUSHJ	P,FINFO'B
	<SIXBIT \A\>+[ASCIZ \C\]
%A:
	LIST
	SALL
>  ;END DEFINE N$INFO
SUBTTL	Initialization

QUENCH:	PORTAL	.+2		;NORMAL ENTRY
	PORTAL	.+2		;CCL ENTRY
	TDZA	S1,S1		;ALLOW FOR CCL ENTRY POINT
	MOVEI	S1,1		;YES--FLAG CCL ENTRY
	MOVEM	S1,STRTOF	;SAVE FOR ISCAN
	SETZB	F,TYPER		;CLEAR TYPEOUT ROUTINE FLAG
	RESET			;RESET ANY EXTERNAL I/O
	SETZM	ZCOR		;CLEAR CORE
	MOVE	S1,[ZCOR,,ZCOR+1]
	BLT	S1,EZCOR
	MOVE	P,[IOWD LN$PDL,PDLST]  ;ESTABLISH PUSH-DOWN LIST

	PUSHJ	P,GTTABS	;DO ALL NECESSARY GETTABS
	PJOB	S1,		;GET THIS JOB'S NUMBER
	MOVNS	S1		;GET JOB ARG FOR JOBSTS UUO
	JOBSTS	S1,		;GET THIS JOB'S STATUS
	  JRST	.+2		;FAILED--ASSUME LOGGED IN
	TXNE	S1,JB.ULI	;SEE IF LOGGED IN
	TLO	F,L.LOGI	;YES--SET FLAG
	TLNE	F,L.LOGI	;SEE IF LOGGED IN	[1172]
	JRST	QUESS2		;YES--PROCEED			[1172]
	TLO	F,L.NSBJ	;INDICATE NOT LOGGED IN		[1177]
	SETOM	S1		;START AT OUR JOB		[1172]
QUESTL:	CTLJOB	S1,		;GET CONTROLLING NUMBER		[1172]
	  JRST	QUESS2		;NONE--ASSUME OK ANYWAY		[1172]
	JUMPL	S1,QUESS2	;IF NONE, ASSUME OK		[1172]
	MOVN	S2,S1		;GET -JOB			[1172]
	JOBSTS	S2,		;GET ITS STATUS			[1172]
	  SETOM	S2		;ASSUME LOGGED IN		[1172]
	TXNN	S2,JB.ULI	;SEE IF LOGGED IN		[1172]
	JRST	QUESTL		;NO--LOOP ON UP CHAIN		[1172]
	HRLZ	S2,S1		;GET THIS JOB'S NUMBER		[1172]
	HRRI	S2,.GTPPN	;POINT TO PPN TABLE		[1172]
	GETTAB	S2,		;GET PPN FROM MONITOR		[1172]
	  JRST	QUESS2		;NONE!--GIVE UP			[1172]
	MOVEM	S2,.MYPPN##	;OK--USE THAT INSTEAD		[1172]
	TLZ	F,L.NSBJ	;OK AFTER ALL (PROBABLY OPSER CALL)	[1177]
	JRST	QUESS2		;CONTINUE
QUESS2:	MOVE	S1,.JBREL	;SAVE CURRENT CORE
	HRL	S1,.JBFF	;  AND START OF FREE CORE	[1202]
	MOVEM	S1,SAVCOR	;  FOR LATER TO RESTORE

	MOVE	S1,[IOWD QCMLEN,QCOMS]  ;NO--RESCAN FOR POSSIBLE COMMANDS
	MOVEM	S1,ISARG	;SET AS FIRST ARG
	MOVE	S1,[STRTOF,,'QUE']  ;SET START ADDRESS AND TMP FILE
	MOVEM	S1,ISARG+1	;STORE AS SECOND ARG
	SETZB	S1,ISARG+3	;CLEAR INDIRECT BLOCK
	MOVEM	S1,MONRTR	;STORE AS FIFTH ARG

	MOVE	S1,[5,,ISARG]
	PUSHJ	P,.ISCAN##
	MOVEM	S1,COMIDX	;SAVE COMMAND INDEX
	SKIPGE	S1		;SEE IF COMMAND
	TDZA	S1,S1		;NO--CLEAR DEFAULT TYPE
	MOVE	S1,QDEVS(S1)	;YES--GET QUEUE NAME
	MOVEM	S1,DQTYPE	;STORE AS DEFAULT TYPE
SUBTTL	Main Processing Loop

;HERE WHENEVER * TYPED (IE, MAJOR RESTART)

QUELOP:
;**;[522]ADD AND REVAMP CODE AT QUELOP:+0L	14-JUN-84/CTK
	SETOM	S.ASST		;[522]INITIALIZE SWITCH VALUE
	MOVE	S1,[10,,[IOWD SWTCHL,SWTCHN
			SWTCHD,,SWTCHM
			0,,SWTCHP
			'QUEUE '
			CLRANS,,CLRFIL
			INFIL,,OUTFIL
			FILSTK,,APLSTK
			CLRSTK,,0]  ]
	PUSHJ	P,.TSCAN##
	MOVE	S1,S.ASST	;[522]GET THE SWITCH
	MOVEM	S1,T.ASST	;[522]SAVE IT, TO CHECK ORIGIN
	PUSHJ	P,.GTNOW##	;GET NEW TIME OF DAT
	MOVEM	S1,NOW		;REMEMBER IT
	SKIPE	O.MODM		;SEE IF OUTPUT SPEC
	JRST	SOMCMD		;YES--NORMAL HANDLING
	MOVE	S1,I.NXZR	;SEE IF ANY COMMANDS
	MOVE	S2,I.INZR	;GET FIRST INPUT SPEC
	SUB	S1,S2		;GET NUMBER OF SPECS*I.LZER
	JUMPE	S1,NOCMD	;NONE--NULL COMMAND
	CAIN	S1,I.LZER	;SEE IF JUST ONE
	SKIPE	.FXNAM(S2)	;  WITH NULL FILE NAME
	JRST	SOMCMD		;NO--SOMETHING THERE
	HLLZ	S1,.FXEXT(S2)	;GET THE EXTENSION
	JUMPN	S1,SOMCMD	;JUMP IF THERE IS ONE

;HERE ON A NULL MONITOR COMMAND

NOCMD:	PUSHJ	P,DEFAU1	;GO FILL IN MODIFIED DEFAULTS
	JRST	DOCMD		;THEN GO BELOW TO DO THE WORK

;HERE WHEN A NON-NULL COMMAND IS FOUND

SOMCMD:	PUSHJ	P,DEFAUL	;GO FILL IN DEFAULTS

;HERE AFTER DEFAULTS ARE DONE

DOCMD:	PUSHJ	P,COMAND	;DO THE COMMAND
	JRST	QUELOP		;LOOP BACK FOR MORE WORK

;COMMANDS WHICH RUN QUEUE
DEFINE	QQ(A,B),<
	SIXBIT	/B/
>

	SIXBIT	/QUEUE/		;SWITCH.INI LINE ON .RUN ETC
QCOMS:	SIXBIT	/QUEUE/
IFGE PUNCDP,<	SIXBIT	/PUNCH/>
	QUEUES
QCMLEN==.-QCOMS

PATCMD:	BLOCK	1		;PATCH COMMAND DISPATCH ADDRESS

;DEVICES USED BY THOSE COMMANDS
DEFINE	QQ(A,B),<
	SIXBIT	/A/
>

QDEVS:	SIXBIT	/LP/		;QUEUE COMMAND (MUST BE LP NOT LPT) 
IFG	PUNCDP,<SIXBIT /CDP/>
IFE	PUNCDP,<SIXBIT /PTP/>
IFL	PUNCDP,<>
	QUEUES


;DEFINE OBJECT TYPES KNOWN TO QUEUE
;
;FORMAT IS:	OO	A,B,C
;
;WHERE:
;	A=DEVICE NAME
;	B=OBJECT TYPE
;	C=OBJECT ATTRIBUTES

DEFINE OBJECTS,<
	OO	CDP,.OTCDP,0
	OO	INP,.OTBAT,0
	OO	LL ,.OTLPT,%LOWER
	OO	LPT,.OTLPT,0
	OO	LU ,.OTLPT,%UPPER
	OO	PLT,.OTPLT,0
	OO	PTP,.OTPTP,0
>

DEFINE OO(A,B,C),<EXP SIXBIT /A/>

OBJDEV:	OBJECT

DEFINE OO(A,B,C),<EXP B>

OBJOBJ:	OBJECT
OBJDNM==.-OBJOBJ

DEFINE OO(A,B,C),<EXP C>

OBJATR:	OBJECT
	SUBTTL	ROUTINES TO HANDLE CALLS FROM TSCAN

;HERE TO CLEAR OUT A SINGLE FILE SPEC

CLRFIL:	SETZM	F.ZER
	MOVE	S1,[F.ZER,,F.ZER+1]
	BLT	S1,F.EZER
	SETOM	F.MIN
	MOVE	S1,[F.MIN,,F.MIN+1]
	BLT	S1,F.EMIN
	POPJ	P,

;HERE WHEN A SPECIFICATION FOR OUTPUT SIDE IS FOUND

OUTFIL:	SKIPN	F.MOD		;ANY MOD SWITCHES?
	SKIPE	F.MODM		; "   "      "
	JRST	OUTFL1		;YES, GIVE ERROR
	SKIPGE	F.STRT		;/START?
	SKIPL	F.RPT		;OR /REPORT?
OUTFL1:	JRST	E.FMO##		;YES, GIVE ERROR
	MOVEI	S1,O.ZER	;POINT TO OUTPUT AREA
	MOVEI	S2,O.LZER	;INDICATE LENGTH
	POPJ	P,		;RETURN

;HERE WHEN A SPECIFICATION FOR INPUT SIDE FOUND

INFIL:	PUSHJ	P,GTCLIN	;GET AND CLEAR INPUT AREA
	MOVEI	T1,I.MOD(S1)	;POINT TO OUR PART
	HRLI	T1,F.ZER	;POINT TO OUR F AREA
	BLT	T1,I.LZER(S1)	;COPY OUR PART
	POPJ	P,		;RETURN
;HERE TO CLEAR STICKY DEFAULTS

CLRSTK:	SETZM	P.ZER		;ZERO OUT DEFAULTS
	MOVE	S1,[P.ZER,,P.ZER+1]
	BLT	S1,P.EZER
	SETOM	P.MIN
	MOVE	S1,[P.MIN,,P.MIN+1]
	BLT	S1,P.EMIN
	POPJ	P,

;CLRANS -- CLEAR SCANNING ANSWER AREA
;CALL:	PUSHJ	P,CLRANS
;USES S1

CLRANS:	HLLZS	F		;CLEAR TEMPORARY FLAGS
	SETZM	S.ZER		;ZERO OUT COMMAND ACCUMULATORS
	MOVE	S1,[S.ZER,,S.ZER+1]
	BLT	S1,S.EZER
	SETOM	ARGBK2+.ACCTS	;PRESET ACCOUNT STRING
	SETOM	S.MIN		;PRESET SWITCH PARAMETERS
	MOVE	S1,[S.MIN,,S.MIN+1]
	BLT	S1,S.EMIN
	MOVE	S1,SAVCOR	;GET INITIAL START OF FREE CORE	[1202]
	HLRZM	S1,.JBFF	;SET START OF FREE CORE		[1202]
	HLRZM	S1,I.INZR	;ESTABLISH PARAMETER AREA HERE	[1202]
	HLRZM	S1,I.NXZR	;AND OF ZERO LENGTH		[1202]
	TLZ	S1,-1		;CLEAR JUNK			[1202]
	CORE	S1,		;RESTORE REAL CORE ALSO		[1202]
	  JFCL			;OK IF CAN'T			[1202]
	POPJ	P,		;RETURN
;FILSTK -- MEMORIZE STICKY DEFAULTS
;CALL:	PUSHJ	P,FILSTK
;	RETURNS AFTER NON-ZERO F.XXX COPIED TO P.XXX
;USES S1, S2

FILSTK:	MOVE	S1,F.MOD	;COPY SWITCHES
	MOVE	S2,F.MODM
	ANDCAM	S2,P.MOD
	IORM	S1,P.MOD
	IORM	S2,P.MODM
	MOVE	S1,F.STRT	;GET THE STARTING POINT
	CAME	S1,[-1]		;WAS IT SPECIFIED?
	MOVEM	S1,P.STRT	; ..
	SETCM	S1,F.RPT	;MEMORIZE /REPORT
	JUMPE	S1,FILS.1	;Don't store null report
	DMOVE	S1,F.RPT	;GET /REPORT
	DMOVEM	S1,P.RPT	;AND SAVE IT
FILS.1:	MOVE	S1,[XWD F.FONT,P.FONT] ;Prepare to BLT sticky font name
	SKIPE	F.FONT		;Did he type /FONT?
	 BLT	S1,P.FONT+FNMLTH-1 ;Yes, memorize it
	POPJ	P,

;HERE AT END OF SPECIFICATION TO APPLY USER SUPPLIED DEFAULTS

APLSTK:	MOVE	S1,P.MOD	;APPLY ALL FILE SWITCHES
	ANDCM	S1,F.MODM	;MASK HERE USED TO INDICATE WHICH WERE TYPED
	IORM	S1,F.MOD	; ..
	MOVE	S1,P.MODM	; ..
	IORM	S1,F.MODM	; ..
	MOVE	S1,F.STRT	;GET THE STARTING POINT
	CAMN	S1,[-1]		;WAS IT SPECIFIED?
	MOVE	S1,P.STRT	;NO, USE THE GLOBAL DEFAULT
	MOVEM	S1,F.STRT	;NO--SUPPLY DEFAULT
	SETCM	S1,P.RPT	;GET THE REPORT CODE
	JUMPE	S1,APLS.1	;DONE IF NOT DEFAULT
	SETCM	S1,F.RPT	;SKIP IF NO REPORT GIVEN
	JUMPN	S1,APLS.1	;RETURN
	DMOVE	S1,P.RPT	;GET /REPORT
	DMOVEM	S1,F.RPT	;SAVE IT
APLS.1:	MOVE	S1,[XWD P.FONT,F.FONT] ;Prepare to BLT sticky font name
	SKIPN	F.FONT		;Did he specify a file specific /FONT?
	 SKIPN	P.FONT		;Did he type sticky /FONT?
	  TRNA			;File specific or no sticky
	BLT	S1,F.FONT+FNMLTH-1 ;Yes, apply it
	POPJ	P,		;RETURN
SUBTTL	FILL IN DEFAULTS AFTER COMMAND SCANNING

;DEFAUL -- SUBROUTINE TO FILL IN DEFAULTS AND DETECT
;	INCONSISTENCIES AFTER COMMAND SCANNING
;DEFAU1 -- DITTO EXCEPT DEFAULT OPERATION IS /LIST
;USES EVERYTHING

DEFAUL:	MOVEI	S1,AD.OPN	;FIRST DECIDE WHAT TYPE OF REQUEST
	SKIPLE	S.CHK		;HAVE /CHECK ?
	SKIPL	S.LIST		;HAVE /LIST ?
	JRST	DEFAU0		;CONTINUE
	MOVEI	S2,LISTJOBS	;GET DEFAULT /LIST VALUE
	MOVEM	S2,S.LIST	;DEFAULT TO /LIST:JOBS
DEFAU0:	SKIPL	S.LIST		;SEE IF /LIST SHOWED UP
DEFAU1:	MOVEI	S1,.QORLS	;YES--FORCE /LIST AS DEFAULT
	SKIPGE	S.OPN
	MOVEM	S1,S.OPN
	SKIPLE	S.DFR		;WAS /DEFER SPECIFIED?
	POPJ	P,		;YES, RETURN NOW
	MOVE	S1,S.OPN	;FETCH ACTUAL OPERATION		[1171]
	MOVE	S2,O.MODM	;GET INDICATOR OF OUTPUT	[1171]
	CAIE	S1,.QORMD	;SEE IF /MODIFY			[1171]
	CAIN	S1,.QORKL	;OR IF /KILL			[1171]
	SKIPA			;YES, SKIP
	JRST	DEFA1A		;NO, GO ON
	JUMPE	S2,E.SJN	;TYPE "JOB OR SEQ" ON LEFT...
	MOVX	S1,FX.NDV	;GET NULL DEVICE BIT
	TDNN	S1,O.MOD	;WAS IT SET?
	JRST	DEFA1A		;NO, HE SPECIFIED ONE, CONTINUE
	MOVS	S2,DQTYPE	;NO, GET DEFAULT QUEUE TYPE
	SKIPE	DQTYPE		;IS IT IS NULL,
	CAIN	S2,'LP '	; OR JUST  "LP"
	N$FATE	<NQS>,,<No queue specified in /KILL or /MODIFY>

DEFA1A:	SETZM	MADFIL		;CLEAR "MADE FILESPEC"
	PUSHJ	P,QUETYP	;IDENTIFY WHAT TYPE OF QUEUE
	MOVE	J,S1		;SAVE AWAY FOR EASY TESTS LATER
	MOVE	T3,I.INZR	;RESET TO START OF INPUT AREA
	ADDI	T3,I.LZER	;FORCE AT LEAST ONE REQUEST
	SKIPN	J		;SEE IF INPUT QUEUE
	ADDI	T3,I.LZER	;YES--THEREFORE, TWO ENTRIES USED
DEFAU2:	CAMG	T3,I.NXZR	;SEE IF NEED MORE THAN GOT
	JRST	DEFAU3		;NO--OK TO PROCEED
	PUSHJ	P,.CLRFL##	;CLEAR FXXX AREAS
	PUSHJ	P,APLSTK	;APPLY STICKY DEFAULTS
	PUSHJ	P,INFIL		;ALLOCATE SPACE
	PUSHJ	P,.GTSPC##	;COPY SPEC
	SETOM	MADFIL		;WE MADE A FILESPEC
	JRST	DEFAU2		;LOOP BACK TO SEE IF ENOUGH

DEFAU3:	MOVE	I,I.INZR	;START AT BEGINNING OF REQUESTS
	JUMPN	J,DEFAU4	;IF NOT INPUT QUEUE, WE ARE DONE
	CAMN	T3,I.NXZR	;IF INPUT, AND NOT /LIST, SEE IF GT 2 ENTRIES
	JRST	DEFAU4		;NO--OK TO PROCEED
	N$WARN	<OTE>,,<Input queue request uses only two entries>
	MOVEM	T3,I.NXZR	;CHANGE LIMIT TO AGREE
DEFAU4:	PUSHJ	P,CLRFIL	;CLEAR THE F AREA
	PUSHJ	P,CLRSTK	;CLEAR THE P AREAA
	MOVE	S1,[5,,[IOWD SWTCHL,SWTCHN
			SWTCHD,,SWTCHM
			0,,SWTCHP
			0
			2,,OSCNML]  ]
	MOVX	S2,'QUEUE '	;WHAT TO READ
	MOVEM	S2,OSCNML	;STORE IT
	MOVE	S2,COMIDX	;GET THE COMMAND INDEX
	MOVE	S2,QCOMS(S2)	;GET THE COMMAND
	MOVEM	S2,OSCNML+1	;AND SAVE FOR CALL
	MOVE	I,S.OPN		;GET OPERATION WORD
	CLEARM	CREFLG		;ASSUME IT'S CREATE
	CAIE	I,.QORMD	;IS IT MODIFY?
	CAIN	I,.QORKL	;OR KILL?
	  SOSA	CREFLG		;IT'S NOT CREATE!!
	PUSHJ	P,.OSCAN##	;LOOK AT OPTION FILE


	SETOM	PTHFCN		;SET TO READ DEFAULT
	MOVE	S1,[.PTMAX,,PTHFCN]
	PATH.	S1,		;  READ IT
	  SETZM	PTHPPN		;CAN'T--ASSUME DEFAULT
	SKIPN	PTHPPN		;SEE IF SET
	SETZM	PTHPPN+1	;NO--CLEAR SFDS
	MOVE	S1,.MYPPN##	;GET SELF
	SKIPN	PTHPPN		;SEE IF DEFAULT KNOWN
	MOVEM	S1,PTHPPN	;NO--THEN USE SELF

	MOVEI	S1,O.ZER	;SETUP ARGS FOR OSDFS
	MOVEI	S2,O.LZER	; "
	SKIPN	CREFLG		;IS IT CREATE?
	PUSHJ	P,.OSDFS##	;YES, DO SWITCH INI DEFAULTING

	CAIE	I,.QORLS	;SEE IF LISTING DEVICE
	JRST	OUDEF1		;NO--NOT A REAL DEVICE
	MOVSI	S1,'TTY'	;SET DEFAULT DEVICE
	SKIPN	T3,O.DEV	;YES--CHECK DEVICE CHARACTERISTICS
	MOVE	T3,S1		;NO DEVICE--USE DEFAULT
	MOVEM	T3,O.DEV	;SAVE FOR LATER
	MOVE	S1,O.MOD	;GET MOD WORD
	TXNE	S1,FX.PHY	;SEE IF PHYS I/O NEEDED
	DEVCHR	T3,UU.PHY	;YES--TRY IT
	TXNN	S1,FX.PHY	;SEE IF NOT
	DEVCHR	T3,		;NO--USE LOGICAL FROM THE MONITOR
	TXNN	T3,DV.OUT	;SEE IF CAPABLE OF OUTPUT
	JRST	E.NOD		;NO--TELL USER HE BLEW IT
	JRST	OUDEF2		;YES--PROCEED(WARNING--T3 USED BELOW)
OUDEF1:	MOVX	S1,FX.NDV	;CLEAR OUT
	ANDCAM	S1,O.MOD	; NULL DEVICE FLAG
	SKIPE	O.EXT		;SKIP IF EXTENSION IS ZERO
	N$FATE	<OEI>,,<Output Extension is Illegal>

OUDEF2:	CAIN	I,.QORLS	;SEE IF LISTING
	JRST	OUDF2A		;YES--SKIP ONWARD
	MOVE	S1,O.MOD	;GET OUTPUT FLAGS
	TXNE	S1,FX.DIR	;WAS A DIRECTORY SPECIFIED?
	JRST	OUDF2B		;YES, CONTINUE ON
	SETOM	O.DIRM		;NO, SET DIRECTORY MASK
	JRST	OUDF2A		;AND CONTINUE ON
OUDF2B:	MOVE	S1,.MYPPN##	;GET SELF
	MOVSI	S2,-1		;MASK LEFT HALF
	TDNN	S2,O.DIR	;SEE IF SET
	HRROS	O.DIRM		;NO--PUT ON MASK
	TDNN	S2,O.DIR	; ..
	HLLM	S1,O.DIR	;SET IN SELF PROJECT
	MOVEI	S2,-1		;MASK RIGHT HALF
	TDNN	S2,O.DIR	;SEE IF SET
	HLLOS	O.DIRM		;NO--PUT ON MASK
	TDNN	S2,O.DIR	; ..
	HRRM	S1,O.DIR	;SET IN SELF PROGRAMMER
	SKIPE	O.DIR+2		;CHECK FOR SFDS
	JRST	E.QSFD		;ILLEGAL IN QUEUE USER
	JRST	OUDEF4		;SKIP ON

OUDF2A:	CAIE	I,.QORLS	;LISTING THE QUEUES?
	JRST	OUDF3A		;NO
	MOVE	T3,O.DEV	;GET OUTPUT DEVICE
	MOVX	S1,FX.PHY	;GET PHYSICAL FLAG
	SETZ	S2,		;ASSUME NOT PHYSICAL
	TDNE	S1,O.MOD	;IS IT SET?
	MOVX	S2,UU.PHY	;YES
	DEVCHR	T3,(S2)		;GET DEVCHR WORD
	SKIPN	O.NAM		;HAVE A FILE NAME?
	TXNN	T3,DV.DIR	;A DIRECTORY DEVICE?
	JRST	OUDF3A		;NO NEED TO GENERATE A FILE NAME
	MSTIME	S1,		;YES--MANUFACTURE NAME HHMMSS
	IDIVI	S1,^D1000	;GET SECONDS
	MOVE	T2,[POINT 6,O.NAM]  ;SETUP BYTE POINTER
	MOVSI	T1,-6		;INITIALIZE LOOP COUNTER
OUDEF3:	IDIV	S1,[^D36000
		    ^D3600
		    ^D600
		    ^D60
		    ^D10
		    ^D1](T1)	;GET NEXT DIGIT
	ADDI	S1,'0'		;CONVERT TO SIXBIT DIGIT
	IDPB	S1,T2		;STORE INTO NAME
	MOVE	S1,S2		;RESTORE REMAINDER
	AOBJN	T1,OUDEF3	;LOOP
	SETOM	O.NAMM		;CLEAR MASK TO NO WILD-CARDS
OUDF3A:	HRLOI	S1,'LSQ'	;GET DEFAULT EXTENSION
	SKIPN	O.EXT		;ONE SPECIFIED?
	MOVEM	S1,O.EXT	;NO, USE THE DEFAULT

OUDEF4:	SKIPE	CREFLG		;SEE IF MODIFY
	JRST	OUDEF5		;YES--WILD CARDS ARE LEGAL
	MOVE	S1,[O.LZER,,O.ZER] ;SETUP TO CALL .STOPN
	MOVEI	S2,L.OPEN	;OPEN BLOCK
	MOVE	T1,[LN$ENT,,L.LOOK]
	PUSHJ	P,.STOPN##	;CALL .STOPN
	  N$FATE <OWI>,,<Output Wildcards are Illegal>
	JRST	INDEF		;AND CONTINUE
OUDEF5:	SKIPLE	S.SEQ		;WAS /SEQ: SPECIFIED ??
	JRST	INDEF		;YES,,CONTINUE
	SKIPE	O.NAM		;WAS THERE A JOBNAME ??
	JRST	INDEF		;YES,,CONTINUE
	SKIPG	S.RID		;WAS /REQ: SPECIFIED ??
	N$FATE	<NSR>,,<Jobname or /SEQUENCE or /REQUESTID required>
	;HERE TO SUPPLY INPUT SIDE DEFAULTS

INDEF:	MOVE	J,QTYPE			;GET QTYPE IN J
	MOVE	I,I.INZR		;INITIALIZE LOOP

	;LOOP HERE TO DEFAULT NEXT INPUT FILE

INDEF1:	SKIPE	CREFLG			;SEE IF /MODIFY
	JRST	INDEFY			;YES--SKIP TO NAME TESTS
	MOVEI	S1,0(I)			;START SETTING UP TO CALL OSDFS
	MOVEI	S2,.FXLEN		;ADR AND LEN
	PUSHJ	P,.OSDFS##		;CALL IT
	MOVE	S1,F.MOD		;GET MOD WORD
	ANDCM	S1,I.MODM(I)		;TEST
	IORM	S1,I.MOD(I)		;AND SET
	MOVE	S1,F.MODM		;GET GET MOD WORD MASK
	IORM	S1,I.MODM(I)		;AND OR IT IN
	MOVE	S1,I.STRT(I)		;GET START PARAMETER
	CAMN	S1,[-1]			;SET?
	MOVE	S1,F.STRT		;NO, GET DEFAULT
	CAMN	S1,[-1]			;HAVE A TAG?
	SETZ	S1,			;NO
	MOVEM	S1,I.STRT(I)		;STORE IT
;**;[504]REVAMP CODE AFTER INDEF1:+16L	27-JUL-83/CTK
	DMOVE	S1,I.RPT(I)		;[504]GET /REPORT
	CAMN	S1,[-1]			;[504]WAS IT SET?
	DMOVE	S1,F.RPT		;[504]GET DEFAULT
	DMOVEM	S1,I.RPT(I)		;[504]STORE IT
	HRLI	S1,F.FONT		;Get default
	HRRI	S1,I.FONT(I)		;Move font spec
	SKIPN	I.FONT(I)		;DID USER SUPPLY A FONT SWITCH?
	 SKIPN	F.FONT			;NO, DID WE GET ONE FROM SWITCH.INI
	  TRNA
	BLT	S1,I.FONT+FNMLTH-1(I)	;Move it away
	MOVSI	S1,'DSK'		;DEFAULT TO DSK
	CAMN	I,I.INZR		;IS THIS THE FIRST SPEC?
	JRST	INDF1B			;NO,,SKIP THIS
	MOVE	S1,.FXDEV-I.LZER(I)	;NO, USE DEVICE FROM LAST SPEC
	JUMPN	J,INDF1B		;SKIP IF NOT INPUT QUEUE
	MOVEM	S1,PTHBLK+.PTFCN	;SAVE DEVICE IN PATH BLOCK
;**;[506]ADD 4 LINES AT INDEF1:+28L	30-SEP-83/CTK
;**;[515]CHANGE AC USAGE OF EDIT 506	5-MAR-84/CTK
	MOVEI	TF,%EQONL		;[515]LOAD OUTPUT NOLOG BIT
	MOVS	S2,.FXDEV(I)		;[506]GET LOGFILE DEVICE
	CAIN	S2,'NUL'		;[506]IS IT NUL:???
	MOVEM	TF,S.OUT		;[515]YES, SET THE EXPLICIT BIT
	MOVE	S2,[.PTMAX,,PTHBLK]	;GET PATH ARG BLOCK
	PATH.	S2,			;GET INFO ABOUT THE DEVICE
	 JRST	INDF1B			;ASSUME WE ARE OK !!!
	MOVX	S2,PT.IPP		;SEE IF DEVICE IS ERSATZ
	TDNN	S2,PTHBLK+.PTSWT	;IS IT ???
	JRST	INDF1B			;NO,,SKIP THIS
	MOVSI	S1,'DSK'		;YES,,DEFAULT TO DSK

INDF1B:	JUMPGE	J,INDF1A		;JUMP IF NOT /LIST
	MOVE	S1,DQTYPE		;GET DEFAULT QUEUE
	TLNN	S1,(77B17)		;IS IT FROM QUEUE COMMAND?
	SETZ	S1,			;YES--DEFAULT IS ALL:
INDF1A:	MOVX	S2,FX.NDV		;SEE IF
	TDNN	S2,.FXMOD(I)		;  NULL DEVICE
	SKIPN	.FXDEV(I)
	MOVEM	S1,.FXDEV(I)
	JUMPN	J,INDEFF		;IF NOT INPUT QUEUE, PROCEED
	SETOM	S1		;INPUT NOT /LIST, SO NO WILDCARDS
	CAME	S1,.FXNMM(I)	;TEST NAME WILD
	SKIPN	.FXNAM(I)	;YES--SEE IF NAME THERE
	JRST	.+2		;NO--THEN OK
	JRST	E.WCI		;YES--ILLEGAL
	MOVEI	S1,0		;CLEAR DEFAULT
	CAME	I,I.INZR	;IF NOT FIRST FILE,
	MOVE	S1,.FXNAM-I.LZER(I)  ;  DEFAULT TO PREVIOUS FILE
	SKIPN	S2,O.NAM	;GET JOB NAME
	MOVE	S2,S1		;IF NO JOB NAME, DEFAULT IS CTL FILE
	SKIPN	S1,.FXNAM(I)	;SEE IF NAME SUPPLIED
	MOVE	S1,S2		;NO--GET DEFAULT NAME
	JUMPE	S1,E.NNI	;ERROR IF NONE
	MOVEM	S1,.FXNAM(I)	;AND STORE RESULT
	SETOM	.FXNMM(I)	;REMOVE WILDCARD FROM NAME

INDEFF:	SKIPE	.FXNAM(I)	;DEFAULT FILE NAME
	JRST	INDEFX		;NO DEFAULT NEEDED
	CAME	I,I.INZR	;SEE IF FIRST FILE
	SKIPA	S1,.FXNAM-I.LZER(I)  ;NO--USE PREVIOUS FILE NAME
	MOVSI	S1,'*  '	;YES--SUPPLY WILD DEFAULT
	MOVEM	S1,.FXNAM(I)
	CAME	I,I.INZR	;SEE IF FIRST
	SKIPA	S1,.FXNMM-I.LZER(I)  ;NO--USE PREVIOUS MASK
	MOVEI	S1,0		;YES--USE WILD MASK
	MOVEM	S1,.FXNMM(I)	; ..
INDEFX:	SKIPE	.FXEXT(I)	;DEFAULT EXTENSION
	JRST	INDEFY		;NOT NEEDED
	MOVSI	S1,'*  '	;SET DEFAULT FOR /MODIFY
	SKIPE	CREFLG		;SEE IF /MODIFY
	JRST	INDEF2		;YES--GO STORE DEFAULT
	HLLOS	.FXEXT(I)	;SET FULL MASK
	JUMPN	J,INDEFY	;JUMP IF NOT INPUT
	HRLOI	S1,'CTL'	;LOAD THE EXTENSION
	CAMN	I,I.INZR	;SEE IF FIRST FILE
	JRST	INDEF2		;YES--PROCEED BELOW
	HRLOI	S1,'LOG'	;  CHANGE TO LOG
INDEF2:	MOVEM	S1,.FXEXT(I)	;STORE IT
INDEFY:	SKIPE	CREFLG		;SEE IF /MODIFY
	JRST	INDEF3		;YES--SKIP TO DIRECTORY TESTS
	JUMPN	J,INDEF3	;IF NOT INPUT QUEUE, PROCEED
	SETCM	S1,.FXEXT(I)	;INPUT AND NOT /LIST--SEE IF
	TRNE	S1,-1		;  EXTENSION HAS WILDCARD
	JRST	E.WXI		;YES--ILLEGAL

INDEF3:	MOVX	S1,FX.DIR	;GET DIRECTORY BIT
	JUMPGE	J,INDFNL	;JUMP IF NOT /LIST
	SKIPE	.FXDIR+2(I)	;SEE IF LISTING SFDS
	JRST	E.LSFD		;YES--THAT'S WRONG
	SKIPN	S2,O.DIR	;GET OUTPUT DIRECTORY
	MOVE	S2,.MYPPN##	;OR LOGGED IN NUMBER
	TDNE	S1,.FXMOM(I)	;SEE IF DIRECTORY PRESENT
	JRST	INDFTU		;YES--GO SET USER'S DEFAULTS
	SETOM	.FXDIR(I)	;NO--SET FOR ALL USERS
	JRST	INDFNM		;AND INDICATE DIRECTORY SET
INDFNL:	MOVE	S2,.MYPPN##	;GET MY PPN
	TDNE	S1,.FXMOM(I)	;SEE IF USER SPECIFIED DIRECTORY
	 JRST	INDFTU		;YES--DEFAULT [,] FROM MY PPN
	SKIPE	S2,O.DIR	;ACTION REQUEST--SEE IF
	CAMN	S2,.MYPPN##	;  FOR SPECIFIC USER
	JRST	INDEFD		;NO--PROCEED
;**;[517]ADD CODE AT INDFTU:+0L	15-MAR-84/CTK
INDFTU:	MOVE	T1,.FXDEV(I)	;[517]GET DEVICE
	MOVEM	T1,PTHBLK+.PTFCN;[517]STORE FOR PATH. UUO
	MOVE	T1,[.PTMAX,,PTHBLK]	;[517]SET UP THE UUO
	PATH.	T1,		;[517]GET THE BITS
	  SETZM	PTHBLK+.PTSWT	;[517]FAILURE, NOT ERSATZ
	MOVE	T1,PTHBLK+.PTSWT	;[517]GET THE BITS
	TXNN	T1,PT.IPP	;[517]IMPLIED PPN ???
	  JRST	INDFU1		;[517]NO, DEFAULT THE PPN
;**;[523]ADD AND REVAMP CODE INDFU1:-8L	3-DEC-84/CTK
	MOVE	T1,PTHBLK+.PTPPN;[523]YES, GET THE PPN
	SKIPN	.FXDIR(I)	;[523]DID WE SPECIFY ANY ???
	MOVEM	T1,.FXDIR(I)	;[523]YES, STORE IT
	SETOM	.FXDIM(I)	;[523]NO, AND IT'S  NOT WILD ANY MORE
	  JRST	INDEFD		;[523]SET UP DIRECTORY NOW
INDFU1:	MOVSI	T1,-1		;[523]YES--USE HIM FOR DEFAULT
	TDNN	T1,.FXDIR(I)	;CHECK FOR PROJECT
	HRROS	.FXDIM(I)	;BLANK--SET IT
	TDNN	T1,.FXDIR(I)	; ..
	HLLM	S2,.FXDIR(I)	; TO QUEUED USER
	MOVEI	T1,-1		;CHECK FOR
	TDNN	T1,.FXDIR(I)	; PROGRAMMER NUMBER
	HLLOS	.FXDIM(I)	;BLANK--SET IT
	TDNN	T1,.FXDIR(I)	; ..
	HRRM	S2,.FXDIR(I)	; TO QUEUED USER
INDFNM:	IORM	S1,.FXMOD(I)	;INDICATE DIRECTORY
	IORM	S1,.FXMOM(I)	; SPECIFIED
INDEFD:	SKIPE	CREFLG		;SEE IF /MODIFY
	JRST	INDNOK		;YES--SKIP TO SWITCH TESTS
	JUMPN	J,INDEF4	;IF NOT INPUT QUEUE, PROCEED
	MOVE	S1,.FXDIR(I)	;GET DIRECTORY
	SETCM	S2,.FXDIM(I)	;AND COMPLEMENT OF MASK
	TLNN	S1,-1		;SEE IF PROJECT DEFAULT
	TLZ	S2,-1		;YES--CLEAR WILD-CARDS
	TRNN	S1,-1		;SEE IF PROGRAMMER DEFAULT
	TRZ	S2,-1		;YES--CLEAR WILD-CARDS
	JUMPN	S2,E.WDI	;ERROR IF WILD UFD
	SETOM	S1		;INPUT--CHECK FOR WILD DIRECTORY
	MOVEI	S2,2(I)		;SET POINTER TO SPEC
	HRLI	S2,1-.FXLND	;COUNT SFD DEPTH
INDFNN:	SKIPN	.FXDIR(S2)	;SEE IF SPECIFIED
	JRST	INDEF4		;NO--ALL DONE
	CAME	S1,.FXDIM(S2)	;SEE IF NOT WILD
	JRST	E.WDI		;ERROR IF SO
	ADDI	S2,1		;ADVANCE COUNT
	AOBJN	S2,INDFNN	;LOOP OVER SFD DEPTH
INDEF4:	MOVE	S1,INDADS	;ABSENT DEFAULTS FOR SWITCHES
	JUMPN	J,INDEFO	;JUMP IF NOT INPUT
	CAME	I,I.INZR	;IF INPUT AND LOG FILE,
	MOVE	S1,INDADI	; USE SPECIAL SET
INDEFO:	ANDCM	S1,I.MODM(I)	;MASK TO ONLY THE NEEDED ONES
	IORM	S1,I.MOD(I)	;AND INCLUDE

INDNOK:	LDB	S1,[POINTR (I.MOD(I),X.PAPR)]  ;GET /PAPER: SWITCH
	CAIN	J,QTPCDP	;IS IT THE CARD-PUNCH QUEUE?
	CAIE	S1,PUNCBCD	;YES, DID HE SAY /PUNCH:BCD
	  SKIPA			;NOT CDP OR NOT /PUN:BCD
	MOVEI	S1,PUNC026	;YES, BCD=026
	DPB	S1,[POINTR (I.MOD(I),X.PAPR)] ;AND STORE IT

	MOVEI	S1,AD.STR	;GET DEFAULT STARTING POINT
	SKIPE	CREFLG		;SEE IF /MODIFY
	MOVEI	S1,0		;YES--CLEAR DEFAULT
	MOVE	S2,I.STRT(I)	;GET SPECIFIED VALUE
	CAMN	S2,[-1]		;WAS IT SPECFIED?
	MOVEM	S1,I.STRT(I)	;NO--USE DEFAULT
	JUMPGE	J,INDEF7	;JUMP IF NOT /LIST

	SKIPE	N,.FXDEV(I)	;/LIST--GET QUE NAME
	PUSHJ	P,XPNQUE	;EXPAND ABBREVIATION
	MOVEM	N,.FXDEV(I)	;AND STORE RESULT

INDEF7:	ADDI	I,I.LZER	;ADVANCE POINTER
	CAMGE	I,I.NXZR	;SEE IF DONE YET
	JRST	INDEF1		;NO--LOOP BACK
;HERE TO SUPPLY DEFAULTS FOR GLOBAL SWITCHES

	SKIPE	CREFLG		;SEE IF /MODIFY
	JRST	SWDEF2		;YES--SKIP DEFAULT SWITCHES
	MOVSI	S1,-S.EMIN+S.MIN-1  ;INITIALIZE LOOP
SWDEF1:	MOVE	S2,SWDEFT(S1)	;GET DEFAULT
	MOVE	T1,S.MIN(S1)	;GET VALUE ENTERRED
	CAMN	T1,[-1]		;SEE IF ANYTHING TYPED
	MOVEM	S2,S.MIN(S1)	;YES--STUFF DEFAULT
	AOBJN	S1,SWDEF1	;LOOP BACK FOR MORE

	JUMPLE	J,SWDEF2	;JUMP IF /LIST OR INP:
	MOVE	S2,@SWLDT(J)	;GET ALTERNATE LIMIT VALUE
	SKIPG	S.LIM		;WAS /LIM SET?
	MOVEM	S2,S.LIM	;NO, SAVE ALTERNATE VALUE

SWDEF2:	SKIPE	S1,S.JOB	;GET REQUESTED JOB NAME (IF THERE IS ONE)
	CAMN	S1,[-1]		;IF ITS -1,,DONT SAVE IT
	SKIPA			;0 OR -1,,SKIP 
	MOVEM	S1,O.NAM	;SAVE IT FOR LATER
	SKIPGE	S.SEQ		;SEE IF SEQUENCE STILL NOT SET
	SETZM	S.SEQ		; RIGHT--SET IT FOR /MOD/KILL

	SKIPLE	S1,S.COR	;/CORE SPECIFIED ?
	JRST	SWDF2A		;YES,,ADJUST IT
	SKIPN	CREFLG		;/MODIFY ???
	SETZM	S.COR		;NO,,ASSUME DEFAULT
	JRST	SWDF2B		;AND SKIP REST
SWDF2A:	CAIGE	S1,^D256	;SEE IF ALREADY IN WORDS
	LSH	S1,^D10		;NO--ADD K FACTOR
	MOVEM	S1,S.COR	;STORE RESULT

SWDF2B:	SKIPN	DEFFIL+.FXDEV	;SEE IF /PATH
	JRST	SWDEF3		;NO--PROCEED
	SKIPN	DEFFIL+.FXNAM	;SEE IF /PATH:NAME
	SKIPL	DEFFIL+.FXMOD	; OR /PATH:DEV:
	....==FX.NDV
	JRST	E.PTHN		;ERROR IF SO
	SKIPE	DEFFIL+.FXEXT	; OR /PATH:.EXT
	JRST	E.PTHN		;ERROR IF SO
SWDEF3:	SKIPE	CREFLG		;SEE IF /MODIFY
	POPJ	P,		;YES--RETURN
	JUMPL	J,.POPJ		;GO PROCESS IF /LIST
	JUMPN	J,SWDEF4	;PROCEED IF NOT INPUT
	MOVX	S1,FX.DIR	;GET [] BIT
	TDNE	S1,DEFFIL+.FXMOM  ;SEE IF /PATH:[]
	JRST	SWDPTD		;YES--JUST CHECK NOT WILD
	MOVE	S2,.MYPPN##	;NO--GET SELF
	SKIPN	O.DIR+2		;SEE IF NOT OUTPUT SFD
	CAME	S2,O.DIR	;SEE IF MATCHES OUTPUT P,PN
	TDNN	S1,O.MODM	;OR NO OUTPUT P,PN
	JRST	SWDPTS		;RIGHT--USE DEFAULT DIRECTORY
	MOVE	S1,[O.DIR,,DEFDIR] ;NO--COPY
	BLT	S1,DEFDIR+2*.FXLND-1  ;OUTPUT DIRECTORY
	JRST	SWDPTD		;THEN CHECK FOR NO WILD-CARDS
SWDPTS:	MOVSI	S2,-.FXLND	;GET LOOP COUNT
	MOVEI	T1,0		;AND STORE INDEX
SWDPTL:	SKIPN	S1,PTHPPN(S2)	;GET DEFAULT PATH
	SOS	S2		;DEFEAT ADVANCE IF DONE
	MOVEM	S1,DEFDIR(T1)	;STORE IN /PATH
	SETOM	DEFDIR+1(T1)	;CLEAR WILDCARDS
	ADDI	T1,2		;ADVANCE STORE
	AOBJN	S2,SWDPTL	;LOOP UNTIL DONE
SWDPTD:	MOVE	S1,DEFDIR	;GET UFD
	SKIPN	S2,O.DIR	;GET OUTPUT DIRECTORY
	MOVE	S2,.MYPPN##	;DEFAULT TO LOGGED IN DIRECTORY
	TLNN	S1,-1		;SEE IF PROGRAMMER
	HLL	S1,S2		;NO--DEFAULT
	TRNN	S1,-1		;SEE IF PROGRAMMER
	HRR	S1,S2		;NO--DEFAULT
	MOVEM	S1,DEFDIR	;STORE AWAY
	MOVSI	S2,-.FXLND	;SET LOOP COUNT
SWDPTM:	SKIPN	DEFDIR(S2)	;SEE IF NEXT LEVEL SPECIFIED
	JRST	SWDEF4		;NO--ALL OK
	SETCM	S1,DEFDIR+1(S2)	;GET COMPLEMENT OF WILD MASK
	JUMPN	S1,E.PTHW	;ERROR IF WASN'T -1
	ADDI	S2,1		;ADVANCE BY 2
	AOBJN	S2,SWDPTM	;LOOP OVER FULL DEPTH

SWDEF4:	MOVE	I,I.INZR	;DEFAULT JOB NAME IS FIRST FILE NAME
	CAIN	J,0		;UNLESS INPUT QUEUE
	ADDI	I,I.LZER	;FOR WHICH IT IS LOG FILE
	SETCM	S1,.FXNMM(I)	;SEE IF WILDCARD IN FILE
	JUMPN	S1,.POPJ	;YES--JUST PROCESS
	MOVE	S1,.FXNAM(I)	;NO--GET FILE NAME IN CASE
	SKIPN	O.NAM		;SEE IF OUTPUT NAME YET
	MOVEM	S1,O.NAM	;NO--SET THIS ONE
	POPJ	P,		;RETURN
INDADS:	BYTE (6)AD.NHD(12)0(3)SPACSI,0,0,0(6) AD.COP ;DEF. FILE SWITCHES
INDADI:	<BYTE (18)0 (3) SPACSI,0,FILEAS,AD.LFD (6)AD.COP>+X.NEW+X.LOG+AD.NHD  ;INPUT QUEUE LOG FILE

;DEFINITION OF SWITCH ACCUMULATION AREA AND DEFAULT VALUES
;
;EACH ENTRY IN QSM MACRO IS:
;	SMX	SWITCH-LOCATION,DEFAULT

DEFINE QSM,<
	SMX	S.AFT,0
	SMX	S.ALLF,-1
	SMX	S.BATL,BATLAPPEND
	SMX	S.CHK,-1
	SMX	S.COR,-1
	SMX	S.ATTRIB,-1		;ATTRIBUTES
	SMX	S.DFR,-1
	SMX	S.DEST,-1
	SMX	S.DPN,0
	SMX	S.FRM,0
	SMX	S.GRAF,-1		;;GRAPHICS INTERPRETED
	SMX	S.JOB,0
	SMX	S.LCDP,0
	SMX	S.LIM,0
	SMX	S.LIST,-1
	SMX	S.LLPT,0
	SMX	S.LPLT,0
	SMX	S.LPTP,0
	SMX	S.LPAT,0		;PATCH LIMIT
	SMX	S.LTIM,0
	SMX	S.PROC,-1
	SMX	S.NOS1,0
	SMX	S.NOS2,0
	SMX	S.NTF,-1
	SMX	S.NULL,0
	SMX	S.OPN,0
	SMX	S.ASST,ASSTYES
	SMX	S.OUT,-1
	SMX	S.PRI,-1
	SMX	S.RSTR,AD.RST
	SMX	S.RDR,-1
	SMX	S.RID,0
	SMX	S.SEQ,0
;**;[521]DELETE 1 LINE IN QSM MACRO		7-MAY-84/CTK
	SMX	S.UNIQ,-1
	SMX	S.USER,-1
	SMX	S.LOGO,-1
>  ;END DEFINE QSM

	S.LINP==0		;DUMMY

	S.NOT==S.NOS1
;FIRST DEFINE THE TABLE OF DEFAULTS

DEFINE SMX(A,B),<
	XLIST
	EXP	B
	LIST
	SALL
>

	DEFINE	MSC(A)<
	BLOCK	A
>

SWDEFT:	QSM


;NOW DEFINE THE ACCUMULATION TABLE

DEFINE SMX(A,B,C),<
	XLIST
A:	BLOCK	1
	LIST
	SALL
>

	SWSEG				;SWITCH TO LOWSEG
S.MIN:!
	QSM
	S.EMIN==.-1
	SWSEG				;SWITCH BACK TO HISEG
	XALL

;LOCATIONS OF INDIVIDUAL QUEUE LIMITS
DEFINE QQ(A,B),<
	EXP	S.L'A
>
SWLDT:	QUEUES

	SALL
;FILE SCANNING ERRORS

E.NOD:	MOVE	N,O.DEV
	N$FATE	<CDO>,<N>,<Can not do output to device>
E.NDD:	MOVE	N,.FXDEV(I)
	N$FATE	<DND>,<N>,<Input device not a disk>
E.WCI:	MOVE	N,.FXNAM(I)
	N$FATE	<WIQ>,<N>,<Wildcard illegal in input queue file name>
E.WDI:	N$FATE	<WDI>,,<Wildcard illegal in input queue file directory>
E.WXI:	HLLZ	N,.FXEXT(I)
	N$FATE	<WIE>,<N>,<Wildcard illegal in input queue file extension>
E.NNI:	N$FATE	<FRI>,,<Filename required for input queue>
E.QSFD:	N$FATE	<UCI>,,<Queue user cannot include SFDs>
E.LSFD:	N$FATE	<LQU>,,<Listed queue user cannot include SFDs>
E.PTHN:	N$FATE	<FNI>,,<File name illegal in default path>
E.PTHW:	N$FATE	<WID>,,<Wildcard illegal in default path>

E.SJN:	N$FATE	<SJN>,,<Specify jobname left of equal sign>

E.NSD:	MOVE	N,.FXDEV(I)
	N$FATE	<NSD>,<N>,<Input device does not exist>


E.WIN:	N$FATE	<WIN>,,<Wildcards illegal with /NEW>
SUBTTL	COMMAND PROCESSING

;COMAND -- SUBROUTINE TO PROCESS COMMAND
;USES EVERYTHING

;HERE AFTER COMMAND HAS BEEN DECODED AND ALL DEFAULTS SUPPLIED
;DISPATCH TO APPROPRIATE COMMAND PROCESSOR

COMAND:	SKIPLE	I,S.OPN		;FETCH OPERATION CODE, CHECK FOR LEGAL
	CAILE	I,LCDT		;CHECK FOR VALIDITY
	JRST	E.ICMD		;NO--BOMB THE USER
	MOVE	S1,DQTYPE	;GET COMMAND-DEVICE
	MOVEM	S1,COMDEV	;AND SAVE FOR LATER
	SETZM	T.ZER		;ZERO OUT TEMPORARIES
	MOVE	S1,[T.ZER,,T.ZER+1]  ; ..
	BLT	S1,T.EZER	; ..
	MOVE	S1,COMDEV	;GET THE DEVICE BACK
	MOVEM	S1,DQTYPE	;  AND RESTORE IT (ZAP'D BY ABOVE BLT)
	MOVE	Q,.JBFF		;SETUP POINTER TO QUEUE AREA
	GCORE	Q.ILEN		;GRAB MINIMAL AREA AT FIRST
	SETZM	(Q)		;ZERO OUT QUEUE COMMAND AREA
	HRLZI	S1,(Q)		; ..
	HRRI	S1,1(Q)		; ..
	BLT	S1,Q.ILEN-1(Q)	; ..
	MOVS	S1,COMDEV	;GET DEVICE NAME IN RH
	CAIN	S1,'PAT'	;PATCHING?
	SKIPA	S1,PATCMD	;YES
	MOVE	S1,CDTAB-1(I)	;GET ADDRESS AND CONTROL BITS
	SKIPLE	S.DFR		;WAS /DEFER SPECIFIED?
	HRRI	S1,DEFER	;YES, DISPATCH TO DEFER ROUTINE
	TLNE	S1,(NNLGSB)	;SEE IF ERROR AS SUBJOB		[1177]
	TLNN	F,L.NSBJ	;NO--SEE IF TOP IS LOGGED IN	[1177]
	SKIPA			;YES--LEAVE ALONE		[1177]
	TLO	S1,(NNLGI)	;NO--INDICATE ERROR		[1177]
	TLNN	F,L.LOGI	  ;SEE IF LOGGED IN
	TLNN	S1,(NNLGI)	;NO--SEE IF LEGAL IF NOT
	JRST	(S1)		;YES--GO DO IT
	MOVE	N,CMDTAB-1(I)	;ILLEGAL--ABORT
	N$FATE	<LFS>,<N>,<LOGIN please to use switch>

;TABLE OF DISPATCH ADDRESSES FOR VARIOUS COMMANDS
NNLGI==1B1		;NOT LEGAL UNLESS LOGGED IN
NNLGSB==1B2		;NOT LEGAL UNLESS LOGGED IN AT TOP LEVEL	[1177]

CDTAB:
	EXP	CREATE+NNLGI		;1=CREATE ENTRY
	EXP	0			;2 WAS /DEFER
	EXP	0			;3 WAS /ZDEFER
	EXP	LIST			;4=LIST QUEUE
	EXP	MODIFY+NNLGSB		;5=MODIFY EXISTING ENTRY	[1177]
	EXP	KILL+NNLGSB		;6=KILL EXISTING ENTRY	[1177]
LCDT==.-CDTAB
;HERE ON IMPROPER DISPATCH CODE

E.ICMD:	HRRZ	N,I
	N$FATE	<ICC>,<D>,<Improper command code>


CMDTAB:	SIXBIT	/CREATE/
	EXP	0,0
	SIXBIT	/LIST/
	SIXBIT	/MODIFY/
	SIXBIT	/KILL/
SUBTTL	Command Processing  --  DEFER

;/DEFER IS A GALAXY-10 FEATURE WHICH ALLOWS A USER TO MANIPULATE 
;	DEFER'ED SPOOLING REQUESTS.  TWO FUNCTIONS CURRENTLY EXIST:
;		/CREATE/DEFER  --  RELEASES REQUESTS TO THE 
;					PROPER QUEUES
;		/KILL/DEFER    --  KILLS REQUESTS

DEFER:	MOVE	S2,S.OPN		;GET THE OPERATION SPECIFIED
	SETZ	S1,			;CLEAR S1
	CAIN	S2,.QORCR		;/CREATE?
	MOVEI	S1,.QORDF		;YES, PASS DEFER FUNCTION
	CAIN	S2,.QORKL		;/KILL?
	MOVEI	S1,.QORZD		;PASS /ZDEFER
	SKIPN	S1			;MUST BE ONE OR THE OTHER
	N$FATE	<DMI>,,</DEFER request must include /CREATE or /KILL>
	MOVEM	S1,Q.OPR(Q)		;AND STORE IN Q.OPR

	MOVE	S1,I.INZR		;GET POINTER TO FIRST INPUT SPEC
	SKIPE	.FXNMM(S1)		;CHECK MASK FOR * OR ?????? TYPED
	N$FATE	<CDF>,,<Cannot /DEFER specific files>
	ADDI	S1,I.LZER		;POINT TO NEXT
	CAMGE	S1,I.NXZR		;WAS ONLY ONE SPEC SPEFICIED
	N$FATE	<TDR>,,<Too may deferred requests>

	SKIPE	N,O.DEV			;DID HE TYPE A DEVICE?
	PUSHJ	P,XPNQUE		;YES, EXPAND IT
	MOVEM	N,O.DEV			;AND STORE IT BACK
	MOVS	S1,COMDEV		;GET COMMAND-DEVICE
	CAIN	S1,'LP '		;DID HE SAY .QUEUE?
	SETZM	COMDEV			;YES, NO SPECIAL DEVICE
	SKIPN	S1,O.DEV		;GET SPECIFIED DEVICE
	MOVE	S1,COMDEV		;NONE THERE, USE COMMAND-DEVICE
	MOVEM	S1,Q.DEV(Q)		;SAVE DEVICE IN Q.DEV
	MOVSI	S1,ARGBK2		;GET THE SECONDARY ARG BLOCK ADDRESS,,0
	MOVEM	S1,Q.FLAG(Q)		;AND SAVE IT FOR QMANGR
	MOVEI	S1,0(Q)			;GET ADDRESS FOR QMANGR
	HRLI	S1,Q.ILEN		;AND LENGTH
	PJRST	.QUEER##		;AND DO IT
SUBTTL	COMMAND PROCESSING -- CREATE


;HERE TO CREATE A QUEUE ENTRY

MODIFY:	SETOM	MODFLG		;MODIFY AN EXISTING REQUEST.
KILL:	SETOM	CREFLG		;KILL AN EXISTING REQUEST.
CREATE:	IORI	I,2B23		;PUT FORMAT VERSION IN
	MOVEM	I,Q.OPR(Q)	;STORE REQUEST CODE
	MOVNI	S1,I.LZER	;COMPUTE START
	ADD	S1,I.NXZR	; OF LAST SPEC
	MOVEM	S1,I.LSZR	; FOR WILD
	MOVE	S1,O.DEV	;DESTINATION DEVICE IS OUTPUT PARAMETER
	MOVEM	S1,Q.DEV(Q)	;STORE IT
	MOVE	T1,O.DIR	;GET SPECIFIED PPN
	MOVEM	T1,Q.PPN(Q)	;STORE INTO REQUEST

	SKIPE	S1,O.NAM	;GET PROPOSED JOB NAME
	MOVEM	S1,Q.JOB(Q)	;STORE IT
	MOVE	S1,S.SEQ	;GET SEQUENCE NUMBER
	MOVEM	S1,Q.SEQ(Q)	;PLACE INTO REQUEST
	LDB	S1,[POINTR (O.MOD,FX.PRO)]  ;GET USER SPECIFIED PROTECTION
	CAIE	S1,777		;DID HE SAY /PROT:777?
	JRST	CREA1A		;NO, DON'T CHANGE IT
	N$WARN	<PII>,,</PROTECT:777 is illegal, changed to 677>
	MOVEI	S1,677		;AND DO IT
CREA1A:	SKIPE	S1		;NOT SPECIFIED?
	SKIPA			;YES,,CONTINUE ONWARD
	SKIPN	CREFLG		;NOTHING SPECIFIED. IS THIS CREATE?
	SKIPA			;YES,,SEND A 0
	MOVEI	S1,777		;ON /MOD USE 777 TO SHOW NO CHANGE
	LSH	S1,^D9		;POSITION
;**;[510] Change code after CREA1A+5L.  16-Nov-83 /LWS
	SKIPN	S2,S.PRI	;[510] /PRIORITY:0 SPECIFIED?
	N$FATE	<PZR>,,</PRIORITY:0 not in range 1 to 63>	;[510] SEE YA
	JUMPG	S2,CREA1B	;[510] OK IF GREATER THAN ZERO
	SKIPN	CREFLG		;NOT SPECIFIED. IS THIS CREATE ?
	MOVEI	S2,0		;YES,,SET TO 0
CREA1B:	ANDI	S2,77		;[510] MASK TO FIT

	IOR	S1,S2		;COMBINE RESULTS
	SKIPLE	S2,S.NTF	;WAS /NOTIFY:YES SPECIFIED ???
	TRO	S1,400		;YES - GET NOTIFY BIT
	MOVEM	S1,Q.PRI(Q)	;STORE
	SKIPN	CREFLG		;SEE IF /CREATE
	JRST	CREAS2		;YES--SKIP WILD CARDS
	MOVE	S1,O.DIRM	;GET DIRECTORY WILDCARD
	MOVEM	S1,Q.TIME(Q)	;STORE FOR QMANGR
	MOVE	S1,O.NAMM	;GET JOB NAME WILDCARD
	MOVEM	S1,Q.CREA(Q)	;STORE
	SKIPG	S1,S.RID	;GET THE REQUEST ID
	SETZM	S1		;IF NEGATIVE,,SET TO 0
	MOVEM	S1,Q.RID(Q)	;SAVE IT FOR QMANGR
CREAS2:	SKIPLE	S1,S.AFT	;GET AFTER SWITCH
	ADDI	S1,3		;ADD 1 SECOND
	MOVEM	S1,Q.AFTR(Q)	;STORE IN REQUEST
	DMOVE	S1,G$NAM1	;GET USER NAME
	DMOVEM	S1,Q.USER(Q)	;DEFAULT IT ...
CREUSR:	PUSHJ	P,BLDROB	;SETUP REQUESTED OBJECT BLOCK

	MOVE	S1,QTYPE	;SEE WHICH QUEUE WAS REQUESTED
	CAIN	S1,QTPINP	;WAS IT INPUT?
	JRST	CREI		;YES--GO PROCESS IT

CREU.1:	MOVE	S1,S.FRM	;GET SPECIAL FORMS REQUEST
	MOVEM	S1,Q.OFRM(Q)	;STORE INTO OUTPUT HEADER
	SETZB	S1,LOGCNT	;SET LOG FILE COUNTER SO NEVER FOUND
	HRROM	S1,Q.OSIZ(Q)	;CLEAR SIZE OF REQUEST, NO LIMIT YET
	DMOVE	S1,S.NOT	;GET ANNOTATION
	DMOVEM	S1,Q.ONOT(Q)	;AND SAVE IT
	MOVEI	J,Q.FF(Q)	;J=START OF OUTPUT QUEUE REQUEST AREA
	MOVSI	S1,(BYTE (9)Q.FF-Q.ZER-1,Q.FLEN(18)0)
	JRST	CREOLP		;GO LOOP OVER REQUEST
;HERE TO SETUP INP REQUEST

CREI:	HRRZ	S1,S.DPN	;GET DEPENDENCY REQUEST
	SKIPN	CREFLG		;SEE IF /MOD OR /KILL
	TRZ	S1,3B19		;NO--CLEAR +- FLAGS
	SKIPN	S.RSTR		;SEE IF /REST:1
	TLO	S1,(1B0)	;YES--SET /REST:1
	SKIPN	CREFLG		;IS THIS A CREATE AND
	SKIPG	S.RDR		;   WAS /RDR SPECIFIED ???
	SKIPA			;NO,,SKIP THIS
	TLO	S1,(1B9)	;YES,,TURN ON /RDR BIT
	SKIPE	CREFLG		;SEE IF /MOD
	SKIPGE	S.RSTR		;YES--SEE IF /REST
	JRST	.+2		;NO--PROCEED
	TLO	S1,(1B3)	;YES--SET CHANGE FLAG
	SKIPL	S2,S.UNIQ	;GET THE /UNIQUE VALUE
	JRST	CREI.2		;THERE IS ONE,,SO GO PROCESS IT
	SKIPN	CREFLG		;IS THIS A CREATE MESSAGE ???
	SETZM	S2		;YES,,ZERO THE UNIQUE BITS
	JRST	CREI.3		;GO SAVE THE /UNIQUE VALUE
CREI.2:	CAIG	S2,2		;WAS IT :0 OR :NO ???
	MOVEI	S2,%EQUNO	;MAKE IT :NO
	CAILE	S2,2		;OR WAS IT :1 OR :YES ???
	MOVEI	S2,%EQUYE	;MAKE IT :YES
CREI.3:	DPB	S2,[POINT 2,S1,2]  ;STORE IN REQUEST
	SKIPGE	S2,S.OUT	;GET OUTPUT QUEUEING
	SKIPE	CREFLG		;NOT THERE,,IS IT /MODIFY ???
	SKIPA			;SPECIFIED OR /MODIFY,,SAVE IT
;**;[516]CHANGE 1 LINE AT CREI.3:+4L	5-MAR-84/CTK
	MOVEI	S2,INPLOG	;[516]DEFAULT TO /OUTPUT:LOG
	DPB	S2,[POINT 3,S1,8]  ;STORE
	MOVEM	S1,Q.IDEP(Q)	;STORE INTO QUEUE REQUEST
	MOVE	S1,S.DEST	;GET THE /DESTINATION NODE
	PUSHJ	P,SETNODE	;CONVERT/DEFAULT THE NODE NAME/NUMBER
	CAMN	S1,[-1]		;SEE IF NO NETWORK SOFTWARE
	SETZM	S1		;YES--MAKE THE NODE NUMBER 0
	MOVEM	S1,ARGBK2+.DNODE ;SAVE THE RESULT
	MOVSI	T1,-.FXLND	;SET FOR FULL LOOP COUNT
	HRRI	T1,(Q)		;POINT TO REQUEST
	MOVEI	S2,0		;INITIALIZE FETCH POINTER
CREIDD:	SKIPE	S1,DEFDIR(S2)	;GET /PATH:
	ADDI	S2,2		;ADVANCE FETCH UNLESS AT END
	MOVEM	S1,Q.IDDI(T1)	;STORE IN REQUEST
	AOBJN	T1,CREIDD	;LOOP UNTIL DONE
	HRLZ	S1,S.COR	;FETCH CORE LIMIT
	HRR	S1,S.LTIM	;FETCH CPU TIME LIMIT
	HLRZ	S2,S.LTIM	;GET LEFT HALF OF THE LIMIT
	CAIE	S2,-1		;IF -1
	JUMPN	S2,[HRRI S1,-2	;OR 0, IGNORE IT, ELSE LOAD "INFIN"
		    JRST .+1]	;AND CONTINUE
	MOVEM	S1,Q.ILIM(Q)	;STORE

	HLRZ	S1,S1		;GET /CORE VALUE
	MOVE	S2,G$CMAX	;GET SYSTEM CORMAX
	JUMPE	S2,CREI1	;FORGET IT IF ZERO
	JUMPE	S1,CREI2	;IF 0, IGNORE IT
	CAIN	S1,-1		;OR IF UNCHANGED,
	JRST	CREI1		;IGNORE IT
	CAMG	S1,S2		;SEE IF /CORE IS .GT.
	JRST	CREI1		;NO--PROCEED
	PUSH	P,S2		;SAVE CORMAX
	N$WARN	<CLG>,<N>,<Core limit of>
	HLRZ	S1,Q.ILIM(Q)	;GET LIMIT BACK
	PUSHJ	P,.TCORW##	;TYPE IT
	MOVEI	S1,[ASCIZ / is greater than cormax of /]
	PUSHJ	P,.TSTRG	;MORE MESSAGE
	POP	P,S1		;RESTORE CORMAX
	PUSHJ	P,.TCORW##	;TYPE IT
	PUSHJ	P,.TCRLF##	;TYPE A CRLF
	JRST	CREI2		;SKIP MINMAX CHECK, HE'S OBVIOUSLY GREATER
CREI1:	MOVE	S2,G$MNMX	;GET MINMAX
	JUMPE	S2,CREI2	;IGNORE IF ZERO
	CAIN	S1,-1		;IF UNCHANGED,
	JRST	CREI2		;IGNORE IT
	CAML	S1,S2		;IS /CORE LT MINMAX?
	JRST	CREI2		;NO, OK
	PUSH	P,S2		;SAVE MINMAX
	N$WARN	<CLR>,<N>,<Core limit of>
	HLRZ	S1,Q.ILIM(Q)	;GET /CORE BACK
	PUSHJ	P,.TCORW##	;AND TYPE IT
	MOVEI	S1,[ASCIZ / raised to minimum of /]
	PUSHJ	P,.TSTRG##	;TYPE IT
	POP	P,S1		;RESTORE CORMIN
	PUSHJ	P,.TCORW##	;TYPE IT
	PUSHJ	P,.TCRLF##	;AND A CRLF

CREI2:	HRLZ	S1,S.LLPT	;FETCH PAGE LIMIT
	HRR	S1,S.LCDP	;FETCH CARD PUNCH LIMIT
	MOVEM	S1,Q.ILIM+1(Q)	;STORE
	HRLZ	S1,S.LPTP	;FETCH PAPER TAPE LIMIT
	HRR	S1,S.LPLT	;FETCH PLOT LIMIT
	MOVEM	S1,Q.ILIM+2(Q)	;STORE
;**;[522]ADD AND REVAMP CODE CREI2:+60L	14-JUN-84/CTK
	MOVE	S1,S.ASST	;[522]GET THE OPERATOR INTRVN CODE
	LSH	S1,^D30		;[522]SHIFT IT TO THE RIGHT POSITION
	SKIPN	CREFLG		;[522]IS THIS A CREATE ???
	  JRST	CRE2.1		;[522]YES, SKIP THIS AND STORE IT
	SKIPGE	T.ASST		;[522]WAS /ASSIST TYPED BY USER ?
	  JRST	CRE2.2		;[522]NO, SO DON'T DO IT
	TLO	S1,(1B12)	;[522]YES--SET MODIFY FLAG
CRE2.1:	IORM	S1,Q.IDEP(Q)	;[522]SAVE IT FOR QMANGR
CRE2.2:	SKIPE	CREFLG		;[522]IS THIS A CREATE ???
	  JRST	CRE2.3		;[522]NO, SKIP THIS STUFF
	MOVE	S1,S.BATL	;[522]GET THE LOG FILE TYPE CODE
	LSH	S1,^D24		;[522]SHIFT IT TO THE RIGHT POSITION
	IORM	S1,Q.IDEP(Q)	;[522]SAVE IT FOR QMANGR
CRE2.3:	SKIPL	MODFLG		;[522]MODIFING?
	 JRST	CRE2.4		;[522]NO
	SKIPL	S.BATL		;[522]YES, /BATLOG?
	 N$FATE	<CMB>,,<Can't modify /BATLOG switch>
CRE2.4:	MOVEI	S1,2		;[522]SET LOG FILE COUNTER
	MOVEM	S1,LOGCNT	; TO MATCH ON SECOND REQUEST
	MOVEI	J,Q.II(Q)	;J=START OF INPUT FILE AREA
	MOVSI	S1,(BYTE (9)Q.II-Q.ZER-1,Q.FLEN(18)0)
;HERE TO LOOP OVER EACH FILE TO BE QUEUEED AND PREPARE IT

CREOLP:	MOVEI	S2,Q.FLNM	;GET MODIFY PER FILE LENGTH
	SKIPE	CREFLG		;SEE IF CREATE
	DPB	S2,[POINT 9,S1,17]  ;NO--CHANGE LENGTH
	MOVEM	S1,Q.LEN(Q)	;SET PREFIX OF LENGTHS
	MOVEM	J,.JBFF		;RESET .JBFF TO START OF FILE AREA
	SUBI	J,Q.FLEN	;BACK UP TO START RIGHT
	SKIPE	CREFLG		;SEE IF /CREATE
	SUBI	J,Q.FLNM-Q.FLEN ;NO--BACK UP POINTER SOME MORE
	MOVEI	I,0		;I=START OF NEXT REQUEST AREA
CREOFL:	MOVEI	S1,Q.FLEN	;GET CREATE PER FILE LENGTH
	SKIPE	CREFLG		;SEE IF CREATE
	MOVEI	S1,Q.FLNM	;NO--GET MODIFY PER FILE LENGTH
	ADD	J,S1		;ADVANCE POINTER
	PUSHJ	P,GCORE.	;GET ENOUGH CORE
	SOS	LOGCNT		;ADVANCE LOG FILE COUNTER
	SETZM	(J)		;CLEAR NEW AREA
	HRLZI	S1,(J)		; ..
	HRRI	S1,1(J)		; ..
	BLT	S1,Q.FLEN(J)	; ..
	SKIPE	CREFLG		;SEE IF /CREATE
	JRST	CREOMD		;NO--GO BELOW FOR REST OF /MODIFY
	SKIPN	LOGCNT		;IS THIS THE LOG FILE?
	TXO	F,R.ANUL	;YES, ALLOW NUL:
	PUSHJ	P,LOOKFL	;LOOK FOR NEXT FILE
	  JRST	CREODN		;IF NO MORE FILES
	JRST	CREONS		;ELSE CONTINUE

;HERE ON /MODIFY SWITCH

CREOMD:	BLT	S1,Q.FLNM(J)	;CLEAR REST OF AREA
	SKIPL	S.NTF		;DID HE SPECIFY /MOD/NOTIFY ???
	N$FATE	<CMN>,,<Can't modify /NOTIFY switch> ;CANT DO THAT !!!
	PUSHJ	P,GETMOD	;GET MODIFY REQUEST PARAMETERS
	  JRST	CREODN		;ALL DONE
	JRST	CREONT

CREONS:	CLOSE	DC,CL.NMB	;KEEP ACCESS TABLE IN CORE
	RELEAS	DC,		;RELEASE THE CHANNEL
CREONT:	AOS	Q.LEN(Q)	;COUNT OUTPUT FILE
	JRST	CREOFL		;LOOP BACK FOR NEXT FILE
CREODN:	MOVE	I,QTYPE		;SAVE FOR EASE OF TESTS
	JUMPE	I,CREOGI	;IF INPUT, SKIP SIZE STORE
	SKIPLE	S1,S.LIM	;IS IT A REASONABLE LIMIT
	JRST	CRELIM		;YES, CONTINUE ON
	SETZ	S1,		;NO, INSURE ZERO
	SKIPN	CREFLG		;IS THIS CREATE?
	JRST	CRELIM		;YES, ALL IS WELL
	HRROS	Q.OSIZ(Q)	;ELSE SET MODIFY MASK TO NO CHANGE
	JRST	CRESIZ		;AND CONTINUE ON
CRELIM:	CAILE	S1,777776	;CHECK TO LARGE
	MOVEI	S1,777776	;FORCE OK
	HRLOM	S1,Q.OSIZ(Q)	;SAVE FOR SCHEDULING
CRESIZ:	SKIPE	CREFLG		;SEE IF /CREATE
	JRST	CREOGG		;NO--GO ON
	MOVE	S2,NOBLKS	;GET COUNT OF BLOCKS QUEUED
	CAILE	S2,777777	;HANDLE OVERFLOW
	MOVEI	S2,777777	;YES--MAKE MAXIMUM
	HRRM	S2,Q.OSIZ(Q)	;REMEMBER FOR SCHEDULING
	JRST	CREOGG		;GO CONTINUE OUTPUT

CREOGI:	SKIPE	CREFLG		;SEE IF /CREATE
	JRST	CREOGG		;NO--PROCEED
	HRROI	S2,Q.FSTR-Q.FLEN	;NO--USE A DIFFERENT DISTANCE
	ADDI	S2,(J)		;FIX S2 TO POINT TO STR OF LOG
	SKIPE	S1,(S2)		;SEE IF LOG FILE EXISTS YET
	PUSHJ	P,CREOGK	;   BY CHECKING STRUCTURE
	MOVE	S1,Q.FSTR+Q.II(Q) ;NO--USE CTL FILE STRUCTURE
	MOVEM	S1,(S2)		;STORE CONCLUSION

CREOGG:	HRRZ	T2,Q.LEN(Q)	;GET NUMBER OF FILES
	SKIPE	CREFLG		;SEE IF /CREATE
	JRST	CREOGH		;NO--JUST GO OUTPUT REQUEST
	JUMPE	T2,E.NFLS	;YES--ERROR IF NO FILES
	CAIE	T2,2		;SEE IF EXACTLY TWO FILES
	SKIPE	QTYPE		;SEE IF IT'S INP:
	SKIPA			;ALL IS WELL
	N$FATE <INF>,,<Incorrect number of files in input queue request>

CREOGH:	SKIPLE	S.ALLF			;DOES HE WANT ALL HIS FILES?
	SKIPN	NAFFLG			;YES, DOES HE HAVE THEM ALL?
	  SKIPA				;YES, ALL IS FINE
	N$FATE	<NAF>,,<Not All Requested Files Exist>
	MOVE	S1,QTYPE		;GET QUEUE TYPE
	MOVE	S2,S.BATL		;GET THE LOG FILE TYPE CODE
	CAIN	S1,QTPINP		;SKIP IF NOT INPUT
	CAIE	S2,%BSPOL		;INPUT, SKIP IF :SPOOL
	JRST	CREOGJ			;NO, FORGET IT
	MOVEI	S1,1			;LOAD A FILE COUNT
	SKIPE	MADFIL			;SKIP IF WE DIDN'T DUMMY UP A SPEC
	HRRM	S1,Q.LEN(Q)		;WE DID, USE JUST THE CTL FILE

CREOGJ:	MOVSI	S1,ARGBK2		;GET THE SECONDARY ARG BLOCK ADDRESS,,0
	MOVEM	S1,Q.FLAG(Q)		;AND SAVE IT FOR QMANGR
	HRRZ	S1,J		;SET POINTER FOR QMANGR
	SUBI	S1,(Q)		; ..
	HRLZI	S1,1(S1)	; ..
	HRRI	S1,(Q)		; ..
	PJRST	.QUEER##	;GO CREATE REQUEST AND RETURN

CREOGK:	MOVE	TF,S1		;GET THE DEVICE NAME IN TF
	MOVSI	T2,1		;GET DSKCHR BLOCK ARGS
	DSKCHR	T2,		;GET DEVICE CHARACTERISTICS
	 POPJ	P,		;RETURN IF AN ERROR
	JUMPE	T2,.POPJ1	;IF ZERO,,MUST BE NUL:
	TXNE	T2,DC.TYP	;IS THE DEVICE GENERIC ???
	AOS	0(P)		;NO,,THEN TAKE SKIP RETURN
	POPJ	P,		;RETURN
	
;ERRORS

E.OEFE:	CLOSE	LC,CL.RST!CL.ACS!CL.DLL   ;RESET ENTER
	RELEAS	LC,		;CLEAR CHANNEL
	MOVEI	S1,L.LOOK	;POINT TO LOOKUP BLOCK
	MOVEI	S2,LN$ENT-1	;GIVE LENGTH
	MOVEI	T1,O.ZER	;POINT TO SCAN BLOCK
	PUSHJ	P,E.LKEN##	;ISSUE ERROR MESSAGE
	PJRST	NFMSX1		;GO ABORT JOB


E.NFLS:	SKIPLE	S.NULL		;NO FILES--SEE IF MESSAGE SUPPRESSED
	POPJ	P,		;YES--JUST RETURN
	N$FATE	<NFI>,,<No files in request>
SUBTTL	Listing routines -- Open the listing file


LSTOPN:	MOVE	I,I.INZR	;START WITH FIRST REQUEST
	MOVSI	T1,B.LC		;POINT TO BUFFER HEADERS
	MOVEM	T1,L.OPEN+2	;STORE IN OPEN BLOCK
	MOVEI	T1,LN$ENT-1	;SET LENGTH OF BLOCK
	IORM	T1,L.LOOK	;  INTO LOOKUP BLOCK
	MOVS	T1,L.OPEN+1	;GET OUTPUT DEVICE
	MOVE	N,O.DEV		;GET DEVICE NAME IN CASE THIS FAILS
	CAIE	T1,'TTY'	;IF TTY:
	TLNE	F,L.LOGI	; OR LOGGED IN,
	JRST	LSTO.1		;THEN OK TO LIST
	TLNE	F,L.NSBJ	;ARE WE LOGGED IN AT TOP LEVEL?
	N$FATE	<LTL>,<N>,<LOGIN to list on device>

LSTO.1:	OPEN	LC,L.OPEN	;INIT THE DEVICE
	  N$FATE <LOF>,<N>,<Listing OPEN failure on device>
	ENTER	LC,L.LOOK	;ENTER FILE
	  JRST	E.OEFE		;ERROR
	OUTBUF	LC,0		;BUILD BUFFERS BEFORE QMANGR MANGLES FREE CORE
	MOVEI	S1,L.PATH	;POINT TO LISTING PATH BLOCK
	MOVEM	S1,L.LOOK+.RBPPN ;STORE FOR FILESPEC TYPEOUT
	MOVEI	S1,LC		;GET THE CHANNEL NUMBER
	DEVCHR	S1,		;GET DEVICE CHARACTERISTICS
	TXNE	S1,DV.TTY	;SEE IF LINE MODE OUTPUT DEVICE
	TRO	F,R.OUTL	;YES--SET FLAG TO FORCE OUT EACH LINE
	TLC	S1,-1-<(DV.TTA)>;SEE IF NUL:
	TLCN	S1,-1-<(DV.TTA)>; ..
	JRST	LSTDEV		;IT IS - HANDLE LIKE A NON-DIRECTORY DEVICE
	TXNE	S1,DV.TTA	;CONTROLLING TTY ?
	POPJ	P,		;YES - THEN DON'T OUTPUT A MESSAGE
	TXNE	S1,DV.MTA	;A MAGTAPE ?
	JRST	LSTMTA		;YES
	TXNE	S1,DV.DSK	;A DISK ?
	JRST	LSTDSK		;YES
	TXNE	S1,DV.DIR	;DIRECTORY DEVICE ?
	JRST	LSTDIR		;YES - HANDLE DIFFERENTLY
	JRST	LSTDEV		;MUST BE A RANDOM DEVICE
SUBTTL	Listing routines -- Type out listing filespec


LSTMTA:	MOVE	S1,[3,,S2]	;SET UP AC
	MOVX	S2,.TFDEN+.TFSET ;FUNCTION CODE
	MOVEI	T1,LC		;LOAD CHANNEL NUMBER
	LDB	T2,[POINTR (O.MOD,FX.DEN)] ;GET DENSITY
	TAPOP.	S1,		;SET IT
	  JFCL			;IGNORE ERRORS
	MOVE	S1,[3,,S2]	;SET UP AC
	MOVX	S2,.TFPAR+.TFSET ;LOAD FUNCTION CODE
	MOVEI	T1,LC		;LOAD CHANNEL NUMBER
	LDB	T2,[POINTR (O.MOD,FX.PAR)] ;GET PARITY BIT
	TAPOP.	S1,		;SET ODD OR EVEN PARITY
	  JFCL			;IGNORE ERRORS
	N$INFO	<QLF>,<N>,<Queue listing on file>
	MOVEI	S1,LC		;GET CHANNEL NUMBER
	DEVNAM	S1,		;WANT THE REAL NAME
	  MOVE	S1,L.OPEN+.OPDEV ;ASSUME NAME FROM OPEN BLOCK
	PUSHJ	P,.TSIXN##	;TYPE IT
	PUSHJ	P,.TCOLN##	;TYPE COLON
	MOVEI	S1,[ASCIZ |, density = |]
	PUSHJ	P,.TSTRG##	;TYPE TEXT
	MOVE	S1,[3,,S2]	;SET UP AC
	MOVX	S2,.TFDEN	;FUNCTION CODE
	MOVEI	T1,LC		;LOAD CHANNEL NUMBER
	TAPOP.	S1,		;READ DENSITY
	  MOVEI	S1,0		;CAN'T - ASSUME DEFAULT
	CAILE	S1,DENMAX	;GREATER THAN HIGHEST KNOWN DENSITY ?
	  MOVX	S1,-1		;UNKNOWN
	MOVE	S1,DENTAB(S1)	;PICK UP DENSITY TEXT
	PUSHJ	P,.TSTRG##	;TYPE IT
	JRST	LSTEND		;GO TO COMMON ENDING

; DENSITY TABLE
;
	[ASCIZ	|Unknown|]
DENTAB:	[ASCIZ	|Default|]
	[ASCIZ	|200|]
	[ASCIZ	|556|]
	[ASCIZ	|800|]
	[ASCIZ	|1600|]
	[ASCIZ	|6250|]
DENMAX==.-DENTAB
LSTDEV:	N$INFO	<QLF>,<N>,<Queue listing on file>
	MOVEI	S1,LC		;GET CHANNEL NUMBER
	DEVNAM	S1,		;WANT THE REAL NAME
	  MOVE	S1,L.OPEN+.OPDEV ;ASSUME NAME FROM OPEN BLOCK
	PUSHJ	P,.TSIXN##	;TYPE IT
	PUSHJ	P,.TCOLN##	;TYPE COLON
	JRST	LSTEND		;GO TO COMMON ENDING

LSTDSK:	MOVEI	S1,LC		;GET CHANNEL NUMBER
	MOVEM	S1,L.PATH	;STORE IT
	MOVEM	S1,L.DSKC	;STORE IN DSKCHR BLOCK TOO
	MOVE	S1,[.PTMAX,,L.PATH] ;SET UP CALL
	PATH.	S1,		;READ PATH OF CHANNEL
	  JFCL			;IGNORE ERRORS
	MOVE	S1,[LN$DSK,,L.DSKC] ;SET UP DSKCHR UUO
	DSKCHR	S1,		;SEE WHAT THE DEVICE REALLY IS
	  SKIPA	S1,L.OPEN+.OPDEV ; CAN'T
	SKIPE	S1,L.DSKC+.DCSNM ;PICK UP STRUCTURE NAME (GUARD AGAINST NUL:)
	MOVEM	S1,L.OPEN+.OPDEV ;STORE IT
				;FALL INTO LSTDIR

LSTDIR:	N$INFO	<QLF>,<N>,<Queue listing on file>
	MOVEI	S1,L.OPEN	;POINT TO THE OPEN BLOCK
	MOVEI	S2,L.LOOK	;POINT TO THE ENTER BLOCK
	PUSHJ	P,.TOLEB##	;TYPE FILESPEC

LSTEND:	PUSHJ	P,FINFO2	;CLOSE OFF THE MESSAGE
	PUSHJ	P,LSTHDR	;TYPE LISTING HEADER
	POPJ	P,		;RETURN
SUBTTL	Listing routines -- Header generation


LSTHDR:	MOVEI	S1,LSTCHR		;GET OUT ROUTINE TO PUT A CHARACTER
	PUSHJ	P,.TYOCH##		;TELL SCAN ABOUT IT
	MOVEM	S1,L.OTYO		;REMEMBER THE OLD SETTING
	PUSHJ	P,.TCRLF##		;NEW LINE
	MOVEI	S1,[ASCIZ |Listing by QUEUE version |]
	PUSHJ	P,.TSTRG##		;TYPE HEADER INTRO
	MOVE	S1,.JBVER		;GET OUT VERSION NUMBER
	PUSHJ	P,.TVERW##		;TYPE IT
	MOVEI	S1,[ASCIZ | on |]	;SEPERATOR
	PUSHJ	P,.TSTRG##		;TYPE INTRO
	PUSHJ	P,.TDATN##		;TYPE THE CURRENT DATE
	MOVEI	S1,[ASCIZ | at |]	;GET SEPERATOR
	PUSHJ	P,.TSTRG##		;TYPE TEXT
	PUSHJ	P,.TTIMN##		;TYPE THE CURRENT TIME
	PUSHJ	P,.TCRLF##		;NEW LINE
	PUSHJ	P,.TCRLF##		;AND ANOTHER
	MOVE	S1,L.OTYO		;GET OLD TYPE OUT ROUTINE
	PUSHJ	P,.TYOCH##		;TELL SCAN
	POPJ	P,			;RETURN
SUBTTL	Listing routines -- Create list request


LIST:	PUSHJ	P,LSTOPN		;OPEN THE LISTING FILE
	MOVE	I,I.INZR		;GET THE FIRST REQUEST.
	MOVEI	Q,LSTBLK		;AND A PLACE TO PUT SOME DATA.
	MOVE	S1,S.LIST		;GET THE /LIST: BITS.
	SETO	S2,			;INDICATE TYPE OF LIST
	CAIN	S1,LISTFAST		;DOES HE WANT A QUICK LISTING.
	MOVX	S2,LS.FST		;GET THE /L:FAST BITS.
	CAIN	S1,LISTALL		;WAS IT /LIST:ALL ???
	MOVX	S2,LS.ALL		;GET THE RIGHT BITS
	MOVEM	S2,ARGBK2+.LSTYP	;AND SAVE THEM
LIST.1:	CAML	I,I.NXZR		;ARE WE DONE YET ???
	JRST	LIST.2			;YES,,GO FINISH UP.
	MOVE	S1,[LSTTYO,,.QORLS]	;SET UP LIST Q REQUEST.
	MOVEM	S1,Q.OPR(Q)		;AND SAVE IT.
	MOVE	S1,.FXDEV(I)		;GET THE DEVICE
	MOVEM	S1,Q.DEV(Q)		;ABD SAVE IT
	TRZ	S1,-1			;GET JUST GENERIC PART
	CAMN	S1,QUENMA		;IS IT 'ALLXXX' ???
	 HRRZS	Q.DEV(Q)		;YES--MAKE 0,,XXX
	SKIPLE	S.CHK			;SEE IF /CHECK
	 JRST	[MOVE S1,.MYPPN		;YES--GET MY PPN
		 MOVEM S1,.FXDIR(I)	;SAVE AS SPECIFIED
		 SETOM .FXDIM(I)	;FLAG NO WILD CARDS
		 JRST  .+1]		;AND CONTINUE
	MOVE	S1,.FXDIR(I)		;GET PPN REQUESTED
	MOVEM	S1,Q.PPN(Q)		;SAVE
	MOVE	S1,.FXDIM(I)		;GET PPN MASK REQUESTED
	MOVEM	S1,Q.PPNM(Q)		;SAVE
	MOVE	S1,.FXNAM(I)		;GET JOBNAME REQUESTED
	MOVEM	S1,Q.JOB(Q)		;SAVE
	MOVE	S1,.FXNMM(I)		;GET JOBNAME MASK REQUESTED
	MOVEM	S1,Q.JOBM(Q)		;SAVE
	PUSHJ	P,LSTROB		;SETUP ROB FOR LIST REQUEST
	MOVE	S1,S.DEST		;GET /DESTINATION
	PUSHJ	P,SETNOD		;CONVERT IF NECESSARY
	MOVEM	S1,ARGBK2+.LSDES	;STORE IT
	MOVE	S1,S.PROC		;GET /PROCESSING
	PUSHJ	P,SETNOD		;CONVERT IF NECESSARY
	MOVEM	S1,ARGBK2+.LSPRC	;STORE IT
	MOVSI	S1,ARGBK2		;GET THE SECONDARY ARG BLOCK ADDRESS,,0
	MOVEM	S1,Q.FLAG(Q)		;AND SAVE IT FOR QMANGR
	HRLZI	S1,Q.ILEN		;GET THE REQUEST LENGTH.
	HRRI	S1,0(Q)			;GET THE REQUEST ADDRESS.
	PUSHJ	P,.QUEER##		;GET QMANGR TO DO THE DIRTY WORK.
	ADDI	I,I.LZER		;POINT TO THE NEXT REQUEST.
	JRST	LIST.1			;AND GO PROCESS IT.

LIST.2:	CLOSE	LC,			;CLOSE THE CHANNEL
	RELEAS	LC,			;RELEASE THE CHANNEL
	POPJ P,				;RETURN TO MAIN PROCESSOR.
SUBTTL	Listing routines -- Routine to output the list answer


LSTTYO:	MOVEI	S1,.OHDRS(P1)		;POINT TO THE FIRST MESSAGE BLOCK.
	LOAD	S2,ARG.HD(S1),AR.LEN	;GET THE BLOCK LENGTH.
	SOSLE	.OARGC(P1)		;CHECK THE ARGUMENT COUNT.
	ADD	S1,S2			;IF 2 BLOCKS,,GET 2ND BLOCK ADDRESS.
	MOVEI	S1,ARG.DA(S1)		;GET ADDRESS OF STRING
	HRLI	S1,(POINT 7,)		;MAKE A BYTE POINTER
	MOVEM	S1,L.PNTR		;STORE BYTE POINTER

LSTT.1:	ILDB	S1,L.PNTR		;GET A CHARACTER
	PUSHJ	P,LSTCHR		;PUT A CHARACTER
	JUMPE	S1,.POPJ##		;DONE IF WE ENCOUNTER A <NUL>
	CAILE	S1,.CHFFD		;END OF LINE ?
	JRST	LSTT.1			;NO - CONTINUE
	TRNE	F,R.OUTL		;OUTPUT ON EVERY LINE ?
	PUSHJ	P,LSTC.1		;YES - DO IT NOW
	JRST	LSTT.1			;LOOP BACK FOR MORE CHARACTERS
	POPJ	P,			;RETURN.

LSTCHR:	SOSG	B.LC+.BFCNT		;ROOM IN THE BUFFER ?
	PUSHJ	P,LSTC.1		;BUFFER FULL - WRITE IT OUT
	IDPB	S1,B.LC+.BFPTR		;PUT A CHARACTER
	POPJ	P,			;RETURN

LSTC.1:	OUT	LC,			;OUTPUT BUFFER
	  POPJ	P,			;NO ERRORS - RETURN
	PUSHJ	P,.PSH4T##		;SAVE T1 - T4 (S1,S2,T1,T2)
	GETSTS	LC,L.STAT		;GET CHANNEL STATUS
	MOVE	T1,L.STAT		;PREPARE TO CLEAR
	TXZ	T1,IO.ERR		; BY PRESERVING JUST
	SETSTS	LC,(T1)			;  THE CONTROL BITS
	N$WARN	<LDE>,<N>,<Listing device output error, status =>
	HRLZ	S2,L.STAT		;GET STATUS IN LH OF S2
	MOVEI	T1,6			;SET UP COUNTER

LSTC.2:	LSHC	S1,3			;SHIFT IN A DIGIT
	ANDI	S1,7			;NO JUNK
	ADDI	S1,"0"			;MAKE IT ASCII
	PUSHJ	P,.TCHAR##		;TYPE IT
	SOJG	T1,LSTC.2		;LOOP FOR ANOTHER
	PUSHJ	P,.TCRLF##		;NEW LINE
	PUSHJ	P,.POP4T##		;RESTORE T1 - T4 (S1,S2,T1,T2)
	POPJ	P,			;BACK FOR MORE CHARACTERS
SUBTTL	Command Processing Subroutines


;LOOKFL -- ROUTINE TO DO A WILD-CARD LOOKUP
;ENTERRED WITH Q.FXXX ZEROED, INTIALLY WITH NOFILF, ETC. ZEROED.
;CALL:(	MOVEI	I,0	INITIALLY)
;	MOVEI	J,ADDR. OF NEXT RESULT BLOCK
;	PUSHJ	P,LOOKFL
;	  ERROR RETURN IF NO MORE (MESSAGE ISSUED IF APPROPRIATE)
;	SKIP RETURN IF FILE FOUND--4-WORD LOOKUP DONE TO S1-4
;	I WILL BE UPDATED IF NECESSARY TO POINT TO THE NEXT BLOCK
;	MFD, UFD FILES WILL BE POSITIONED FOR NEXT TIME IN.
;	THE Q. FILE LIST AREA WILL BE UPDATED
;USES S1,S2,T1,T2

LOOKFL:!
LOOKFR:	MOVE	S1,[4,,[I.INZR,,I.LSZR
			OPNBLK,,LKBLK
			I.LZER,,LKBLKL
			400000+DC,,I]  ]
	PUSHJ	P,.LKWLD##	;GET NEXT WILD NAME
	  POPJ	P,		;ALL DONE
	JUMPE	S1,[MOVE S1,I.MOD(I)
		    TXNN S1,X.NEW     ;IF NON-EX-DEV, SEE IF /NEW
		    JRST E.NSD	      ;NO SUCH DEVICE
		    MOVSI S1,.FXLEN   ;BLOCK LENGTH
		    HRRI  S1,(I)      ;BLOCK ADDRESS
		    MOVEI S2,OPNBLK   ;OPEN BLOCK
		    MOVE  T1,[LKBLKL,,LKBLK]
		    PUSHJ P,.STOPN##  ;ANY WILD CARDS?
		      JRST   E.WIN
		    MOVE  S1,OPNBLK+1  ;GET ARGUMENT DEVICE
		    MOVEM S1,Q.FSTR(J) ;STORE IT
		    MOVEM S1,RIBDEV    ;AND HERE ALSO
		    MOVE  S1,RIBNAM    ;GET FILENAME
		    MOVEM S1,Q.FNAM(J) ;STORE IN REQUEST
		    MOVE  S1,RIBEXT    ;GET EXTENSION
		    HLLZM S1,Q.FEXT(J) ;STORE IN REQUEST
		    JRST  LOOKND]      ;AND MAKE BELIEVE THE LOOKUP FAILED
	TXNN	S1,DV.DSK	;DOES IT THINK IT'S A DISK?
	JRST	E.NDD		;NO, NOT EVEN CLOSE
	TXNE	S1,DV.TTY	;YES, IF IT THINKS ITS A TTY TOO, IT'S NUL:
	TRZE	F,R.ANUL	;YES, IT'S NUL:, DO WE ALLOW IT?
	JRST	LOOKLK		;YUP, HE'S GOLDEN
	JRST	E.NDD		;NO, LOSE BIG
;HERE WHEN LOOKUP BLOCK PREPARED FOR NEXT FILE
; AND IT IS TIME TO OPEN AND LOOK IT UP

LOOKLK:	MOVE	S1,OPNBLK+1	;GET ARGUMENT DEVICE
	MOVEM	S1,Q.FSTR(J)	;STORE AS STRUCTURE
	MOVE	S1,RIBNAM	;GET FILE NAME
	MOVEM	S1,Q.FNAM(J)	;STORE IN REQUEST
	MOVE	S1,RIBEXT	;GET FILE EXTENSION
	HLLZM	S1,Q.FEXT(J)	;STORE IN REQUEST
	OPEN	DC,OPNBLK	;OPEN CHANNEL
	  JRST	[PUSHJ P,E.DFO##
		 JRST  LOOKFR]

LOOKIE:	MOVEI	T2,PTHFCN	;POINT TO USER PATH
	MOVX	S2,X.NEW	;GET /NEW BIT
	TDNE	S2,I.MOD(I)	;TEST THE FILE (IS IT THE /NEW?)
	SKIPE	RIBPPN		;YES, IS THERE A PPN SPECIFIED?
	MOVE	T2,RIBPPN	;YES, USE IT
	MOVEM	T2,RIBPPN	;USE THE CORRECT ONE
	LOOKUP	DC,LKBLK	;EXTENDED LOOKUP
	  JRST	LOOKER		;IF FAILURE
	MOVEI	S1,DC		;GET CHANNEL NUMBER
	MOVEM	S1,PTFFCN	;SET IN PATH BLOCK
	MOVE	S1,[.PTMAX,,PTFFCN]
	PATH.	S1,		;GET LOCATION FROM MONITOR
	  SETZM	PTFPPN+1	;CLEAR RESULT
	MOVEI	S1,PTFFCN	;POINT TO BLOCK
	SKIPE	PTFPPN+1	;SEE IF SFDS
	MOVEM	S1,RIBPPN	;YES--POINT FROM LOOKUP

	PUSHJ	P,.CHKTM##	;CHECK /BEFORE/SINCE
	  JRST	LOOKFR		;BAD--RECYCLE

	PUSHJ	P,ISBIN		;SEE IF BINARY AND IMPROPER
	  JRST	LOOKBN		;YES--GIVE ERROR
	SKIPE	T2,RIBDEV	;GET UNIT NUMBER
	MOVEM	T2,Q.FSTR(J)	;STORE INTO REQUEST
	MOVE	T2,RIBSIZ	;GET LENGTH IN WORDS
	ADDI	T2,177		;ROUND UP
	ASH	T2,-7		;CONVERT TO BLOCKS
	LDB	T1,[POINTR (I.MOD(I),X.COP)]  ;GET REPEAT COUNT
	SKIPN	T1		;FORCE NON-ZERO
	MOVEI	T1,1		;YES
	IMUL	T1,T2		;COMPUTE COMBINED TOTAL
	ADDM	T1,NOBLKS	;ADD TO ACCUMULATED TOTAL
	MOVX	T1,X.NEW	;GET THE /NEW BIT
	ANDCAM	T1,I.MOD(I)	;AND TURN IT OFF

LOOKND:	SETZM	Q.FDIR(J)	;CLEAR OUT DIRECTORY
	HRLI	S1,Q.FDIR(J)	; ..
	HRRI	S1,Q.FDIR+1(J)	; ..
	BLT	S1,Q.FDIR+.FXLND-1(J) ; ..
	SKIPN	S1,RIBPPN	;GET LOOKUP DIRECTORY
	MOVEI	S1,PTHFCN	;UNKNOWN--GET DEFAULT
	TLNE	S1,-1		;SEE IF SFD
	SKIPA	S2,S1		;NO--GET UFD
	MOVE	S2,.PTPPN(S1)	;YES--GET UFD
	MOVEM	S2,Q.FDIR(J)	;SAVE IN QUEUE REQUEST
	TLNE	S1,-1		;SEE IF SFDS
	JRST	LOOKDD		;NO--DONE WITH DIRECTORY
	MOVEI	S2,Q.FDIR+1(J)	;YES--POINT TO SFDS IN QUEUE REQUEST
	HRLI	S2,1-.FXLND	;COUNT NUMBER OF SFDS
LOOKDL:	SKIPN	T1,.PTPPN+1(S1)	;GET NEXT SFD
	JRST	LOOKDD		;ALL DONE
	MOVEM	T1,(S2)		;STORE IN REQUEST
	AOS	S1		;ADVANCE FETCH
	AOBJN	S2,LOOKDL	;LOOP OVER STORE
LOOKDD:	MOVE	T1,I.MOD(I)	;GET FLAGS AND BITS
	TXZ	T1,X.OKBN	;CLEAR VARIOUS FLAGS
	MOVEI	S1,FILEASCII	;GET DEFAULT /FILE
	HLRZ	S2,Q.FEXT(J)	;GET THE EXTENSION
	CAIN	S2,'DAT'	;.DAT?
	MOVEI	S1,FILEFORTRAN	;YES, USE /FILE:FORT
	TXNN	T1,X.FILE	;WAS IT ALREADY FILLED IN?
	DPB	S1,[POINTR(T1,X.FILE)] ;NO, FILL IT IN
	MOVEI	S1,DISPPRES	;GET DEFAULT DISPOSITION
	CAIN	S2,'LST'	;IS IT A .LST FILE?
	MOVEI	S1,DISPDELE	;YES, LOAD DEFAULT
	TXNN	T1,X.DISP	;WAS /DISP: ALREADY SET?
	DPB	S1,[POINTR(T1,X.DISP)] ;NO, FILL IT IN
	MOVEM	T1,Q.FMOD(J)	;PUT INTO REQUEST
	MOVE	T1,I.STRT(I)	;GET STARTING POINT
;**;[521]REVAMP CODE AT LOOKDD:+15L	7-MAY-84/CTK
	TLNN	T1,770000	;[521]IS IT SIXBIT ???
	  JRST	LKDD.1		;[521]NO, SO LET'S STORE IT AWAY
	MOVE	S1,DQTYPE	;[521]YES, GET THE OBJECT TYPE
				;[521]MAKE SURE IT'S A BATCH REQUEST
	CAXE	S1,SIXBIT /LP/	;[521]"QUEUE foo:=x.x" COMMAND ?
	CAXN	S1,0		;[521]IS IT HERE ???
	MOVE	S1,O.DEV	;[521]NO, MUST BE HERE
	CAXE	S1,SIXBIT /INP/	;[521]IS IT BATCH ??
	SETZ	T1,		;[521]NO ... IGNORE /TAG SWITCH
LKDD.1:	MOVEM	T1,Q.FBIT(J)	;[521]SAVE IN REQUEST
	SETCM	T1,I.RPT(I)	;SEE IF /REPORT
	JUMPE	T1,LKDD.2	;NO--GO MOVE FONT SPEC
	DMOVE	T1,I.RPT(I)	;GET /REPORT
	DMOVEM	T1,Q.FRPT(J)	;AND SAVE IT
LKDD.2:	HRLI	T1,I.FONT(I)	;Now we move away the font spec
	HRRI	T1,Q.FONT(J)	; .  .  .
	BLT	T1,Q.FONT+FNMLTH-1(J) ;Do it
	JRST	.POPJ1		;IF SUCCESS RETURN
;HERE WHEN LOOKUP FAILS--SEE IF .NULL NEEDED OR /NEW SWITCH

LOOKER:	MOVEM	T2,RIBPPN	;RESTORE DIRECTORY
	HRRZ	S2,RIBEXT	;GET LOOKUP ERROR CODE
	JUMPN	S2,LOOKBD	;GO ISSUE ERROR
	MOVE	T1,I.MOD(I)	;GET SWITCHES
	TXNN	T1,X.NEW	;SEE IF /NEW
	JRST	LOOKBD		;NO--ERROR
	SETZM	RIBPRV		;CLEAR PROTECTION, ETC.
	JRST	LOOKND		;AND RETURN RESULTS

LOOKBD:	PUSHJ	P,E.DFL##	;ISSUE ERROR MESSAGE
	SETOM	NAFFLG		;SET A FLAG SAYING A FILE ISN'T THERE
	JRST	LOOKFR		;LOOP BACK TO GET NEXT REQUEST

LOOKBN:	N$WARN	<CPB>,<N>,<Can't print binary>
	PUSHJ	P,.TFILE##
	JRST	LOOKFR		;LOOP FOR NEXT FILE

;ISBIN -- SUBROUTINE TO SEE IF IMPROPERLY TRYING TO PRINT BINARY
;CALL:	PUSHJ	P,ISBIN
;ERROR RETURN IF WRONG
;SKIP RETURN IF OK
;USES S1, S2, T1, T2

ISBIN:	MOVX	S1,X.OKBN	;SEE IF /OKBINARY SWITCH
	TDNE	S1,I.MOD(I)	; ..
	JRST	.POPJ1		;YES--GIVE OK RETURN
	LDB	S1,[POINTR (I.MOD(I),X.PAPR)]  ;GET MODE
	LDB	S2,[POINTR (RIBPRV,RB.MOD)]  ;GET FILE MODE
	CAILE	S2,.IOASL	;IF FILE MODE IS ASCII OR ASCII LINE,
	CAILE	S1,PRINASCII	;OR IF OUTPUT MODE IS NOT ASCII OR ARROW,
	JRST	.POPJ1		;THEN IT IS OK ANYWAY
	MOVE	S1,QTYPE	;GET TYPE OF QUEUE
	CAIE	S1,QTPLPT	;IF NOT LPT,
	JRST	.POPJ1		; THEN IT IS OK

;HERE WHEN NO SPECIAL CASES, JUST LPT OF RANDOM FILE

	HLRZ	S1,RIBEXT	;GET EXTENSION FOR EASE OF TESTING
	MOVSI	T1,-LENBEX	;GET LENGTH OF BINARY EXTENSION TABLE
ISBIN1:	MOVE	S2,BINEXT(T1)	;GET NEXT PAIR
	CAIN	S1,(S2)		;SEE IF IT MATCHES
	POPJ	P,		;YES--ERROR RETURN
	HLRZS	S2		;TRY OTHER ONE
	CAIN	S1,(S2)		;..
	POPJ	P,		;ERROR RETURN
	AOBJN	T1,ISBIN1	;LOOP UNTIL DONE
	JRST	.POPJ1		;NOT BINARY EXTENSION--MUST BE OK

BINEXT:	'BACBIN'	;BASIC OUTPUT,,BINARY
	'BUGCHN'	;PROGRAM SAVED WITH BUG,,CHAIN FILE
	'DAEDCR'	;DAEMON FILE,,DCORE FILE
	'DMPHGH'	;PDP-6 SAVE,,NON-SHAREABLE HIGH SEG SAVE
	'LOWMSB'	;LOW SEGMENT,,MUSIC PROGRAM OUTPUT
	'OVRQUC'	;COBOL OVERLAY,,QUEUE CHANGE
	'QUDQUE'	;QUEUE DATA,,QUEUE REQUEST
	'QUFREL'	;QUEUED REQUEST,,RELOCATABLE BINARY
	'RIMRMT'	;TWO KINDS OF READ IN MODE FILES
	'RTBSAV'	;ANOTHER RIM,,SAVE FILE
	'SFDSHR'	;SUB-FILE DIRECTORY,,SHAREABLE HIGH SEGMENT SAVE
	'SVESYS'	;10/30 SAVE,,SYSTEM BINARY FILE
	'TMPUFD'	;TEMPORARY FILE,,USER'S FILE DIRECTORY
	'XPNVMX'	;EXPANDED SAVE FILE,,VM SPECIAL CORE IMAGE
	'EXEOVL'	;NEW SAVE FILE FORMAT,,OVERLAY
	'DBSSCH'	;DBMS FILE,,ANOTHER DBMS FILE
	'ATRUNV'	;SIMULA ATTRIBUTE FILE,,UNIVERSAL FILE

;ADD MORE HERE--FILL WITH A DUPLICATE--NEVER FILL WITH 0
LENBEX==.-BINEXT
;GETMOD -- ROUTINE TO GET NEXT MODIFY FILE SPECIFICATION

;THE RESULT IS PLACED IN THE QUEUE REQUEST
;THIS SERVES THE SAME FUNCTION AS LOOKFL
;CALL:	MOVEI	I,0	INITIALLY
;	MOVEI	J,ADDR. OF NEXT RESULT BLOCK
;	PUSHJ	P,GETMOD
;	  ERROR RETURN IF END OF REQUESTS
;	SKIP RETURN IF FILE COPIED
;USES S1, S2, T1

GETMOD:	SKIPN	I		;SEE IF FIRST CALL
	SKIPA	I,I.INZR	;YES--GET START OF REQUESTS
	ADDI	I,I.LZER	;NO--ADVANCE TO NEXT REQUEST
	CAML	I,I.NXZR	;SEE IF DONE YET
	POPJ	P,		;YES--RETURN

	SKIPN	S1,.FXDEV(I)	;GET USER SUPPLIED NAME
	JRST	GETMDS		;NONE--SKIP BELOW
	MOVX	S2,FX.PHY	;GET /PHYSICAL BIT
	TDNN	S2,.FXMOD(I)	;SEE IF PHYSICAL REQUESTED
	DEVNAM	S1,		;NO--CONVERT LOGICAL TO PHYSICAL DEVICE
	  JFCL			;NICE TRY
GETMDS:	MOVEM	S1,Q.FSTR(J)	;STORE PHYSICAL NAME AWAY
	MOVE	S1,.MYPPN##	;GET LOGGED IN PPN
	MOVSI	S2,-1		;MASK FOR PROJECT
	TDNN	S2,.FXDIR(I)	;SEE IF PROJECT
	HRROS	.FXDIM(I)	;NO--GIVE SELF
	TDNN	S2,.FXDIR(I)	; ..
	HLLM	S1,.FXDIR(I)	; ..
	MOVEI	S2,-1		;MASK FOR PROGRAMMER
	TDNN	S2,.FXDIR(I)	;SEE IF PROGRAMMER
	HLLOS	.FXDIM(I)	;NO--GIVE SELF
	TDNN	S2,.FXDIR(I)	; ..
	HRRM	S1,.FXDIR(I)	; ..
	MOVEI	S2,.FXDIR(I)	;POINT TO INPUT DIRECTORY
	MOVEI	T1,Q.FDIR(J)	;POINT TO QUEUE REQUEST
	HRLI	T1,-.FXLND	;SET COUNT
GETMDL:	SKIPE	S1,(S2)		;GET REQUEST DIRECTORY
	ADDI	S2,2		;ADVANCE FETCH
	MOVEM	S1,(T1)		;STORE RESULT
	AOBJN	T1,GETMDL	;LOOP FOR FULL DEPTH
	MOVE	S1,.FXNAM(I)	;GET FILE NAME
	MOVEM	S1,Q.FNAM(J)	;STORE
	HLLZ	S1,.FXEXT(I)	;GET EXTENSION NAME
	MOVEM	S1,Q.FEXT(J)	;STORE
	MOVE	S1,I.STRT(I)	;GET STARTING POINT
	MOVEM	S1,Q.FBIT(J)	;STORE
	LDB	S1,[POINTR I.MOD(I),X.DISP];GET /DISPOSE
	CAIN	S1,DISPRENAME	;RENAME?
	 N$FATE	<CMR>,,<Can't modify /DISPOSE:RENAME>
	MOVE	S1,I.MOD(I)	;GET SWITCHES
	MOVEM	S1,Q.FMOD(J)	;STORE
	MOVEI	S2,.FXDIM(I)	;POINT TO USER'S DIRECTORY MASKS
	MOVEI	T1,Q.FDRM(J)	;POINT TO QUEUE REQUEST
	HRLI	T1,-.FXLND	;SET COUNT
GETMDM:	MOVE	S1,(S2)		;FETCH MASK
	MOVEM	S1,(T1)		;STORE
	SKIPE	-1(S2)		;SEE IF AT END
	ADDI	S2,2		;NO--ADVANCE POINTER
	AOBJN	T1,GETMDM	;LOOP UNTIL DONE
	MOVE	S1,.FXNMM(I)	;GET NAME MASK
	MOVEM	S1,Q.FNMM(J)	;STORE
	HRLZ	S1,.FXEXT(I)	;GET EXT. MASK
	MOVEM	S1,Q.FEXM(J)	;STORE
	MOVE	S1,I.MODM(I)	;GET SWITCH MASK
	MOVEM	S1,Q.FMDM(J)	;STORE
	DMOVE	S1,I.RPT(I)	;GET /REPORT SWITCH
	SKIPN	S1		;DID HE CHANGE THE FIRST HALF?
	SETO	S1,		;NO CHANGE
	SKIPN	S2		;DID HE CHANGE THE 2ND HALF?
	SETO	S2,		;NO
	DMOVEM	S1,Q.FRPT(J)	;AND SAVE IT
	SKIPN	I.FONT(I)	;Did he type a font?
	 JRST	.POPJ1		;RETURN
	HRLI	S1,I.FONT(I)	;Transfer the font spec
	HRRI	S1,Q.FONT(J)
	BLT	S1,Q.FONT+FNMLTH-1(J)
	JRST	.POPJ1		;Return good
	SUBTTL	BLDROB - BUILD REQUESTED OBJECT BLOCK.

LSTROB:	TDZA	T1,T1			;FLAG LSTROB ENTRY POINT
BLDROB:	SETOM	T1			;FLAG BLDROB ENTRY POINT
	MOVSI	S1,-OBJDNM		;FIND THE REQUESTED QUEUE TYPE
	HLLZ	S2,Q.DEV(Q)		;GET THE SPECIFIED DEVICE
BLDR.1:	CAMN	S2,OBJDEV(S1)		;MATCH?
	JRST	BLDR.2			;YES,,GO PROCESS IT
	AOBJN	S1,BLDR.1		;NO,,GO TRY THE NEXT
	JUMPE	T1,BLDR.X		;IF LISTING,,CONTINUE
	JRST	E.IQNQ			;ILLEGAL QUEUE NAME

BLDR.2:	HRRZ	S2,OBJOBJ(S1)		;GET THE OBJECT TYPE
	MOVEM	S2,ARGBK2+.ROBLK+.ROBTY	;STORE IN THE ROB
	JUMPE	T1,BLDR.X		;IF LISTING,,SKIP ATTRIBUTES
	SKIPE	S2,OBJATR(S1)		;ANY OBJECT ATTRIBUTES?
	STORE	S2,ARGBK2+.ROBLK+.ROBAT,RO.ATR	;YES,,STORE IN THE ROB
	SKIPN	CREFLG			;SEE IF /MODIFY OR /KILL
	 PUSHJ	P,DFDEST		;NO--DEFAULT /DEST
	SKIPN	CREFLG			;SEE IF /MODIFY OR /KILL
	 PUSHJ	P,DFPROC		;NO--DEFAULT /PROC
BLDR.X:	HRRZ	S1,Q.DEV(Q)		;CHECK NODE AND UNIT
	JUMPE	S1,BLDR.4		;ONWARD IF NOT SPECIFIED
	TRNN	S1,007777		;WAS UNIT ALONE SPECIFIED?
	JRST	BLDR.3			;YES,,GO PROCESS IT
	SETZM	S.DEST			;CLEAR TEMPORARY NODE WORD
	LDB	T1,[POINT 6,S1,23]	;NO,,GET FIRST NODE DIGIT
	CAIN	T1,'S'			;STATION SPECIFICATION?
	 JRST	[LSH	S1,6		;YES--SHIFT IT OFF
		 TLZ	S1,-1		;CLEAR OVERFLOW
		 LDB	T1,[POINT 6,S1,23];GET FIRST NODE DIGIT
		 JRST	.+1]		;AND PROCEED
	CAIL	T1,'0'			;MUST BE NUMERIC
	CAILE	T1,'7'
	 JRST	E.IQNQ			;ELSE SAY ILLEGAL QUEUE
	DPB	T1,[POINT 6,S.DEST,5]
	LDB	T1,[POINT 6,S1,29]	;GET SECOND NODE DIGIT
	CAIL	T1,'0'			;MUST BE NUMERIC
	CAILE	T1,'7'
	 JRST	E.IQNQ			;ELSE SAY ILLEGAL QUEUE
	DPB	T1,[POINT 6,S.DEST,11]	;
	TRZA	S1,777700		;CLEAR ALL EXCEPT UNIT NUMBER
BLDR.3:	LSH	S1,-^D12		;RIGHT JUSTIFY UNIT NUMBER
	JUMPE	S1,BLDR.4		;SKIP IF NO UNIT WAS GIVEN
	CAIL	S1,'0'			;MUST BE NUMERIC
	CAILE	S1,'7'
	 JRST	E.IQNQ			;ELSE ILLEGAL QUEUE
	PUSHJ	P,DFDEST		;DEFAULT /DEST IF NEEDED
	TRZ	S1,777770		;CONVERT TO OCTAL UNIT NUMBER
	TXO	S1,<INSVL.(%PHYCL,RO.ATR)>;MAKE PHYSICAL
	JRST	BLDR.5			;AND STORE THAT
BLDR.4:	MOVE	S1,S.ATTRIB		;GET ATTRIBUTES
	TXNN	S1,RO.ATR		;ANY SPECIFIC ONES?
	 TXO	S1,<INSVL.(%PHYCL,RO.ATR)>;NO--MUST BE FROM /UNIT
;**;[511]REVAMP CODE AT BLDR.4:+2L	18-JAN-84/CTK
	MOVE	S2,CREFLG		;[511]GET CREFLG
	JUMPN	S2,BLD.4A		;[511]CREATE ???
	CAMN	S1,[-1]			;[511]YES ... CHECK FOR ANYTHING
	MOVEI	S1,0			;[511]NOPE
BLD.4A:	SKIPN	ARGBK2+.ROBLK+.ROBAT	;[511]ANYTHING SPECIFIED?
BLDR.5:	MOVEM	S1,ARGBK2+.ROBLK+.ROBAT ;SAVE THE ATTRIBUTES.
	MOVE	S2,ARGBK2+.ROBLK+.ROBTY	;GET OBJECT TYPE
	CAIE	S2,.OTBAT		;BATCH?
	 SKIPA	S1,S.DEST		;NO--LOAD /DEST
	  MOVE	S1,S.PROC		;YES--LOAD /PROC
	PUSHJ	P,SETNODE		;CONVERT IT
	CAMN	S1,[-1]			;NO NETWORK SUPPORT IN THIS MONITOR ???
	SETZM	S1			;YES,,MAKE THE NODE NUMBER 0
	MOVEM	S1,ARGBK2+.ROBLK+.ROBND	;SAVE IT IN THE ROB
	PUSHJ	P,CHKATR		;GO CHECK THE ATTRIBUTES
	POPJ	P,			;RETURN

	SUBTTL	DFDEST - DEFAULT /DEST TO USER LOCATION

DFDEST:	MOVE	T1,S.DEST		;GET /DEST FROM USER
	CAME	T1,[-1]			;SEE IF DEFAULT NEEDED
	 POPJ	P,			;NO--RETURN
	MOVSI	T1,'OPR'		;YES--FIND HIS LOGICAL OPR
	WHERE	T1,			;ASK MONITOR
	 SETOM	T1			;NO NETWORK SUPPORT
	MOVEM	T1,S.DEST		;STORE /DEST
	POPJ	P,			;AND RETURN


	SUBTTL	DFPROC - DEFAULT /PROC TO CENTRAL SITE

DFPROC:	MOVE	T1,S.PROC		;GET /PROC FROM USER
	CAME	T1,[-1]			;SEE IF DEFAULT NEEDED
	 POPJ	P,			;NO--RETURN
	MOVSI	T1,'CTY'		;YES--FIND HIS CENTRAL SITE
	WHERE	T1,			;ASK MONITOR
	 SETOM	T1			;NO NETWORK SUPPORT
	MOVEM	T1,S.PROC		;STORE /PROC
	POPJ	P,			;AND RETURN
	SUBTTL	SETNODE - ROUTINE TO CONVERT/DEFAULT A NODE NAME/NUMBER

SETNOD:	CAME	S1,[-1]			;DID WE DEFAULT IT TO -1.
	TLNN	S1,600000		;   OR IS THE NUMBER BINARY ???
	POPJ	P,			;YES,,RETURN NOW.
	MOVE	T2,S1			;SAVE THE NODE NAME/NUMBER

	SETZ	S2,			;ZERO A WORK AC
	ROTC	S1,6			;GET 6 BITS IN S2
	CAIGE	S2,'0'			;IS IT A NUMBER ???
	JRST	SETN.4			;NO,,SEND THE GUY AN ERROR MSG
	CAILE	S2,'7'			;IS IT OCTAL ???
	JRST	SETN.3			;NO,,GO CHECK FOR ALPHA
	SETZ	T2,			;ZERO ANOTHER WORK AC
SETN.1:	SUBI	S2,'0'			;MAKE THE NUMBER BINARY
	LSH	T2,3			;MAKE ROOM FOR IT IN T2
	ADD	T2,S2			;ADD IT IN
	SETZ	S2,			;ZERO THE AC AGAIN
	ROTC	S1,6			;GET ANOTHER 6 BITS
	JUMPE	S2,SETN.2		;DONE???,,SAVE IT AND RETURN
	CAIL	S2,'0'			;VALIDATE THE
	CAILE	S2,'7'			;NUMBER.......
	JRST	SETN.4			;NO GOOD,,GEN AN ERROR
	JRST	SETN.1			;ELSE CONTINUE ON
SETN.2:	SKIPE	S1,T2			;ANY NUMBER YET?
	 POPJ	P,			;YES--RETURN
	MOVSI	S1,'CTY'		;NO--CONVERT 0
	WHERE	S1,			;INTO CENTRAL SITE
	 SETOM	S1			;LOSE
	POPJ	P,			;AND RETURN

SETN.3:	CAIL	S2,'A'			;IS IT VALID ALPHA ??
	CAILE	S2,'Z'			;HERE ALSO

SETN.4:	N$FATE	<INS>,,<Invalid Node Specified>

SETN.5:	SETZ	S2,			;ZERO THE WORK AC
	ROTC	S1,6			;GET ANOTHER 6 BITS
	JUMPE	S2,SETN.6		;NO MORE,,STOP
	CAIL	S2,'0'			;IS IT LESS THEN 0
	CAILE	S2,'Z'			;OR GREATER THEN Z
	JRST	SETN.4			;YES,,THEN AN ERROR
	CAILE	S2,'9'			;OR IS IT BETWEEN 9
	CAIL	S2,'A'			;AND 'A' ???
	JRST	SETN.5			;NO,,KEEP ON GOING
	JRST	SETN.4			;ELSE THERE IS AN ERROR
;**;[520]ADD 9 LINES AT SETN.6:+0L	20-MAR-84/CTK
SETN.6:	MOVEI	T1,2			;[520]GET ARG BLOCK LENGTH
	MOVE	S1,[XWD	.NDRNN,T1]	;[520]NAME TO NUMBER FUNCTION
	NODE.	S1,			;[520]CONVERT THE NODE NAME
	  JRST	SETN.7			;[520]CAN'T, CHECK FOR ANF SOFTWARE
	POPJ	P,			;[520]RETURN, NODE NUMBER IN S1
SETN.7:	CAMN	S1,[XWD	.NDRNN,T1]	;[520]AC UNCHANGED ???
	N$FATE	<DSI>,,<DESTINATION SWITCH ILLEGAL>	;[520]YES,
					;[520]NO ANF SUPPORT
	MOVE	S1,T2			;[520]SO GET THE NAME IN S1,
					;[520]AND LET QUASAR CONVERT IT
	POPJ	P,			;[520]RETURN

	SUBTTL	CHKATR - ROUTINE TO VALIDATE THE ATTRIBUTES SPECIFIED

CHKATR:	LOAD	S1,ARGBK2+.ROBLK+.ROBAT,RO.ATR ;GET THE SPECIFIED ATTRS
	CAXE	S1,%GENRC		;GENERIC ALWAYS WINS !!!
	CAIN	S1,-1			;SO DOES -1
	POPJ	P,			;RETURN
	MOVE	S2,ARGBK2+.ROBLK+.ROBTY	;GET THE OBJECT TYPE
	CAXE	S2,.OTBAT		;IS IT BATCH ??
	JRST	CHKA.2			;NO,,CHECK FOR PRINTER
	CAXE	S1,%SITGO		;YES,,IS IT SITGO ???
	JRST	CHKA.3			;NO,,MAKE IT GENERIC
	POPJ	P,			;YES,,RETURN
CHKA.2:	CAXE	S2,.OTLPT		;IS THIS PRINTER ???
	JRST	CHKA.3			;NO,,NO ATTRIBUTES IN OTHER QUEUES
	CAXE	S1,%LOWER		;IS IT LOWER CASE ???
	CAXN	S1,%UPPER		;OR UPPER CASE ???
	POPJ	P,			;YES,,HE WINS
CHKA.3:	CAXN	S1,%PHYCL		;IS IT A PHYSICAL UNIT ???
	POPJ	P,			;YES,,HE WINS !!!
	MOVX	S1,%GENRC		;NO,,GET GENERIC ATTRIBUTES
	HRLZM	S1,ARGBK2+.ROBLK+.ROBAT	;SET THEM
	POPJ	P,			;RETURN


	SUBTTL	General Subroutines

;GTTABS IS DRIVEN BY THREE TABLES GENERATED BY THE "TABS" MACRO.
;	THE FIRST TABLE CONTAINS THE ARGUMENT TO GETTAB, THE SECOND,
;	CONTAINS DEFAULTS TO USE ON FAILURE, AND THE THIRD CONTAINS
;	AN INSTRUCTION WHICH IS EXECUTED TO STORE THE RESULTS.

GTTABS:	MOVSI	S2,-.NMTAB		;MAKE AN AOBJN POINTER
GTTAB1:	MOVE	S1,GTAB1(S2)		;GET AN ARGUMENT
	GETTAB	S1,			;DO THE GETTAB
	  MOVE	S1,GTAB2(S2)		;GET THE DEFAULT
	XCT	GTAB3(S2)		;STORE THE RESULT
	AOBJN	S2,GTTAB1		;AND LOOP
	POPJ	P,			;RETURN WHEN DONE

;THE ARGUMENTS TO THE TABS MACRO ARE:
;	1) ARGUMENT TO GETTAB
;	2) DEFAULT VALUE
;	3) INSTRUCTION TO STORE RESULT
;		(NOTE: MACRO EXPANSION GENERATES THE CORRECT AC FIELD
;			THEREFORE IT SHOULD BE BLANK IN THE ARGUMENT)


DEFINE TABS,<
	T	<%NSCMX>,<0>,<MOVEM G$CMAX>
	T	<%CNMMX>,<0>,<MOVEM G$MNMX>
	T	<-1,,.GTNM1>,<0>,<MOVEM G$NAM1>
	T	<-1,,.GTNM2>,<0>,<MOVEM G$NAM2>
>  ;END DEFINE TABS
;NOW GENERATE THE TABLES

DEFINE T(A,B,C),<
	EXP	<A>
>

GTAB1:	TABS
	.NMTAB==.-GTAB1

DEFINE T(A,B,C),<
	EXP	<B>
>

GTAB2:	TABS

DEFINE T(A,B,C),<
	EXP	<C> + <S1>B12
>

GTAB3:	TABS
	SUBTTL	COMMAND SCANNING SUBROUTINES

;GTCLIK -- GET AND CLEAR INPUT PARAM AREA--PRESET TO /OKNONE/UNPRES

;CALL:	PUSHJ	P,GTCLIK
;RETURNS WITH I=START OF AREA, S1=END OF AREA
;USES S2, T1

GTCLIK:	PUSHJ	P,GTCLIN	;GET AND CLEAR AREA
	MOVE	I,S1		;POINT TO REQUEST
	ADDI	S1,-1(S2)	;POINT AT END
	MOVX	S2,FX.NOM	;GET /OKNONE
	IORM	S2,.FXMOD(I)	;SET FLAG ON
	IORM	S2,.FXMOM(I)	;INDICATE FLAG PRESENT
	SETOM	.FXSNC(I)	;CLEAR /SINCE
	SETOM	.FXBFR(I)	;CLEAR /BEFORE
	MOVSI	S2,'*  '	;SET WILD-CARD
	MOVEM	S2,.FXNAM(I)	;IN REQUEST
	POPJ	P,		;RETURN
;GTCLIN -- GET AND CLEAR ONE INPUT FILE PARAMETER STORAGE AREA
;CALL:	PUSHJ	P,GTCLIN
;RETURNS WITH S1=START OF AREA, S2=LENGTH OF AREA
;USES T1

GTCLIN:	MOVE	S2,.JBFF	;START AT .JBFF
	GCORE	I.LZER		;GET ONE AREA
	MOVEI	S1,1(S1)	;ADVANCE ONE AND
	MOVEM	S1,I.NXZR	;SAVE NEW END
	SETZM	(S2)		;CLEAR AREA
	HRLZI	T1,(S2)		; ..
	HRRI	T1,1(S2)		; ..
	BLT	T1,-1(S1)	; ..
	SETOM	.FXBFR(S2)	;CLEAR FIRST SWITCH (-1 MEANS NONE SPYC)
	HRLZI	T1,.FXBFR(S2)	;GET ADR,,0
	HRRI	T1,.FXBFR+1(S2)	;GET ADR,,ADR+1
	BLT	T1,.FXLEN(S2)	;AND RESET ALL SWITCHES
	MOVE	S1,S2		;POSITION RESULT
	MOVEI	S2,I.LZER	;GET LENGTH
	POPJ	P,		;RETURN




;GCORE. -- GET CORE STARTING AT .JBFF
;CALL:	GCORE	N
;RETURN WITH S1=END OF AREA

GCORE.:	ADDB	S1,.JBFF	;ADVANCE .JBFF THE SPACE
GCORE1:	MOVE	S1,.JBFF	;GET NEW CORE SIZE
	CAMG	S1,.JBREL	;SEE IF STILL IN CORE
	SOJA	S1,.POPJ	;RETURN POINTING TO LAST
	CORE	S1,		;NO--ASK MONITOR FOR MORE
	  JRST	.+2		;IF FAIL
	JRST	GCORE1		;IF WON, LOOP BACK TO EXIT
	MOVEI	S1,[ASCIZ /
? Insufficient core in QUEUE
/]
	PUSHJ	P,.TSTRG##
	CLRBFI			;CLEAR TYPEAHEAD
	PUSHJ	P,.MONRT##	;RETURN TO MONITOR
	JRST	GCORE1		;AND LOOP BACK
;HERE TO READ IN SIGNED DECIMAL NUMBER (/DEPENDENCY)

DEPSW:	PUSHJ	P,.TIAUC##	;GET SIGN IF PRESENT
	MOVEI	S2,0		;CLEAR FLAGS
	CAIN	C,"+"		;SEE IF INCREMENT
	TRO	S2,1B19		;YES--SET FLAG
	CAIN	C,"-"		;SEE IF DECREMENT
	TRO	S2,1B18		;YES--SET FLAG
	TRNE	S2,3B19		;SEE IF EITHER SET
	PUSHJ	P,.TIAUC##	;YES--GET ONE MORE CHARACTER
	PUSHJ	P,.DECNC##	;GET NUMBER
	JUMPL	N,E.SVTL	;ERROR IF NEGATIVE
	CAIL	N,3B19		;MAKE SURE IT'S SMALL ENOUGH
	JRST	E.SVTL		;NO--GIVE ERROR
	IOR	N,S2		;COMBINE FLAGS
	PJRST	.SWDPB##	;GO STORE RESULT

E.SVTL:	N$FATE	<SVT>,<D>,<Switch value too large>


;HERE WHEN SWITCH VALUE IS A RADIX-60 SPECIFICATION (/TIME)
TIMESW:	PUSHJ	P,RDX60W	;GET RADIX 60 NUMBER
	PJRST	.SWMAX##	;AND STORE ANSWER


;HERE ON /METERS
METESW:	PUSHJ	P,.SWDEC##	;GET DECIMAL ARGUMENT
	PUSH	P,N+1		;SAVE THE AC FOR THE DIVIDE
	IMULI	N,^D3937	;CONVERT TO CENTI-INCHES
	IDIVI	N,^D1200	;CONVERT TO FEET
	POP	P,N+1		;RESTORE N+1
	PJRST	.SWMAX##	;AND STORE THE ANSWER

DEFINE	SWTCHS,<

	XLIST
	SP ACCOUNT,<*F,ARGBK2+.ACCTS>,ACCTSW,,FS.VRQ
	SP AFTER,S.AFT,.SWDTF##,AFT,FS.VRQ!FS.NFS
	SN ALLFILES,S.ALLF
	SL ASSISTANCE,S.ASST,ASST,ASSTYES
	SL BATLOG,S.BATL,BATL,BATLAPPEND
	SP BEGIN,F.STRT,.SWDEC##,STR,FS.VRQ
	SP CARDS,S.LCDP,.SWDEC##,CDP,FS.VRQ!FS.NFS!FS.LRG
	SN *CHECK,S.CHK,FS.NFS
	SP COPIES,<POINTR(F.MOD,X.COP)>,.SWDEC##,COP,FS.VRQ
	SP CORE,S.COR,.SWCOR##,COR,FS.LRG!FS.VRQ
	SS CREATE,S.OPN,.QORCR
	SN DEFERRED,S.DFR
	SS DELETE,<POINTR (F.MOD,X.DISP)>,DISPDELETE
	SP DEPENDENCY,S.DPN,DEPSW,DPN,FS.VRQ
	SP DESTINATION,S.DEST,.SWSIX##,NOD,FS.VRQ
	SL DISPOSE,<POINTR(F.MOD,X.DISP)>,DISP,DISPPRESERVE
	SS ERBINARY,<POINTR(F.MOD,X.OKBN)>,0
	SS *FAST,S.LIST,LISTFAST
	SP FEET,S.LPTP,.SWDEC##,PTP,FS.LRG
	SL FILE,<POINTR(F.MOD,X.FILE)>,FILE,FILEASCII
	SP FONT,<POINT <^D65-FNMLTH>,F.FONT>,.SWASQ##,,
	SP FORMS,S.FRM,.SWSIX##,,FS.VRQ
	SS GENERIC,S.ATTRIB,<INSVL.(%GENRC,RO.ATR)>,FS.LRG
	SN GRAPHICS,S.GRAF
	SN HEADER,<POINTR(F.MOD,X.NOHD)>
	SP JOBNAME,S.JOB,.SWSIX##,,FS.VRQ
	SS KILL,S.OPN,.QORKL
	SP LIMIT,S.LIM,.SWDEC##,LIM,FS.LRG
	SS LOWERCASE,S.ATTRIB,<INSVL.(%LOWER,RO.ATR)>,FS.LRG
	SL *LIST,S.LIST,LIST,LISTJOBS
	SP METERS,S.LPTP,METESW,PTP,FS.LRG
	SS *MODIFY,S.OPN,.QORMD
	SN NEW,<POINTR(F.MOD,X.NEW)>
	SP NOTES,<POINT 63,S.NOT>,.SWSXQ##,,FS.VRQ
	SN NOTIFY,S.NTF
	SN NULL,S.NULL
	SS OKBINARY,<POINTR(F.MOD,X.OKBN)>,1
;**;[516]CHANGE 1 LINE IN SWTCHS MACRO		5-MAR-84/CTK
	SL OUTPUT,S.OUT,OUTP,INPLOG		;[516]
	SP PAGES,S.LLPT,.SWDEC##,LPT,FS.LRG
	SP PATH,DEFFIL,.SWFIL##,PTH,FS.VRQ
	SL PLOT,<POINTR(F.MOD,X.PAPR)>,PLOT,PLOTIMAGE
	SS PRESERVE,<POINTR (F.MOD,X.DISP)>,DISPPRESERVE
	SL PRINT,<POINTR(F.MOD,X.PAPR)>,PRIN,PRINARROW
	SP PRIORITY,S.PRI,.SWDEC##,PRI
	SP PROCESSING,S.PROC,.SWSIX##,NOD,FS.VRQ
	SL PUNCH,<POINTR(F.MOD,X.PAPR)>,PUNC,PUNCASCII
	SN READER,S.RDR
	SP REPORT,<POINT 63,F.RPT>,.SWSXQ##,,FS.VRQ
	SP REQUESTID,S.RID,.SWDEC##,RID
	SN RESTARTABLE,S.RSTR
	SP SEQUENCE,S.SEQ,.SWDEC##,SEQ
	SS SITGO,S.ATTRIB,<INSVL.(%SITGO,RO.ATR)>,FS.LRG
	SP STREAM,S.ATTRIB,.SWDEC##,UNT
	SL *SPACING,<POINTR(F.MOD,X.SPAC)>,SPAC,SPACSINGLE
;**;[521]CHANGE 1 LINE IN SWTCHS MACRO			7-MAY-84/CTK
	SP TAG,F.STRT,.SWSIX##,,FS.VRQ!FS.NFS		;[521]
	SL TAPE,<POINTR(F.MOD,X.PAPR)>,TAPE,TAPEASCII
	SP TIME,S.LTIM,TIMESW,TIM,FS.LRG
	SP TPLOT,S.LPLT,.SWDEC##,PLT,FS.LRG
	SL *UNIQUE,S.UNIQ,UNIQ,UNIQYES
	SP UNIT,S.ATTRIB,.SWDEC##,UNT
	SS UPPERCASE,S.ATTRIB,<INSVL.(%UPPER,RO.ATR)>,FS.LRG

	LIST
>
;NOW BUILD THE TABLES FROM THE SWTCHS MACRO

	DOSCAN(SWTCH)


;KEY WORD VALUES

KEYS	ASST,<YES,NO>

KEYS	BATL,<APPEND,SUPERSEDE,SPOOL>

KEYS	DISP,<PRESERVE,RENAME,DELETE>

KEYS	FILE,<ASCII,FORTRAN,COBOL,$$,%%,ELEVEN>

KEYS	LIST,<FAST,JOBS,ALL>

KEYS	OUTP,<NOLOG,LOG,ERROR>

KEYS	PLOT,<IMAGE,ASCII,BINARY>

KEYS	PRIN,<ARROW,ASCII,OCTAL,SUPPRESS,GRAPHICS>

KEYS	PUNC,<ASCII,026,BINARY,BCD,IMAGE>

KEYS	SPAC,<SINGLE,DOUBLE,TRIPLE>

KEYS	TAPE,<ASCII,IMAGE,IBINARY,BINARY>

KEYS	UNIQ,<0,NO,1,YES>
;QUETYP -- IDENTIFY WHAT TYPE OF QUEUE HAS BEEN SPECIFIED
;
;CALL:	PUSHJ	P,QUETYP
;	RETURNS S1=-1 IF /LIST REQUEST
;		    0 IF INP:
;		    1+IF OUTPUT QUEUES IN ORDER OF QUEUES MACRO
;
;	ALSO RETURNS O.DEV AND QTYPE UPDATED
;USES S2, T1, T2
;
;WARNING:  THIS ROUTINE IS CALLED BEFORE AND AFTER THE DEFAULTER, SO
;	IT MAY BE LOOKING AT UNDEFAULTED DATA.

QUETYP:	MOVEI	S1,.QORLS	;MAY NEED TO SET /LIST
	SKIPL	S.LIST		;SEE IF /LIST:VALUE
	SKIPLE	S.OPN		;YES--SEE IF SOME OTHER OPERATION
	JRST	.+2		;YES--DO OTHER ONE
	MOVEM	S1,S.OPN	;NO--SET /LIST
	SETOM	S1		;SET ANSWER IF /LIST
	MOVE	S2,S.OPN	;GET OPERATION CODE
	CAIN	S2,.QORLS	;SEE IF /LIST
	JRST	QUETY1		;YES, RETURN THE ANSWER

	PUSH	P,N		;SAVE N
	SKIPGE	O.MOD		;SEE IF NULL DEVICE
	SETZM	O.DEV		;YES--CLEAR IT OUT
	....==FX.NDV
	SKIPN	N,O.DEV		;NO--GET OUTPUT DEVICE
	SKIPE	N,DQTYPE	;USE DEFAULT FROM COMMAND
	SKIPA			;OK
	MOVSI	N,'LPT'		;DEFAULT DEVICE
	PUSHJ	P,XPNQUE	;EXPAND AND MATCH QUEUE NAME
	MOVEM	N,O.DEV		;AND STORE IT
	POP	P,N		;RESTORE NAME
	MOVEI	S1,(S1)		;CHANGE TO INDEX
	SUBI	S1,QUENMT	; ..
QUETY1:	MOVEM	S1,QTYPE	;STORE AWAY THE ANSWER
	POPJ	P,		;AND RETURN
DEFINE	QQ(A,B),<
	SIXBIT	/A/
>

QUENMA:	SIXBIT	/ALL/		;FOR LISTING ONLY
QUENMT:	QUEUES
	QUENML==.-QUENMT
;XPNQUE -- EXPAND QUEUE NAME ABBREVIATION IF ANY
;CALL:	MOVE	N,NAME IN SIXBIT AS TYPED IN
;	PUSHJ	P,XPNQUE
;RETURN WITH UPDATED N
;	AND WITH S1 = ADDRESS OF ENTRY
;USES M, S2, T1, T2

XPNQUE:	MOVS	S1,N		;COPY OVER THE ARGUMENT
	ANDI	S1,777700	;AND TO FIRST TWO CHARS
	CAIE	S1,'LL '	;IS IT LL
	CAIN	S1,'LU '	;OR LU?
	JRST	XPNQU2		;YES, JUMP
	TRNE	N,-1		;IS RIGHT-HALF NULL?
	JRST	XPNQU1		;NO, A BIG NAME
	MOVE	S1,[IOWD QUENML+1,QUENMA]
	PUSHJ	P,.NAME##	;GET LOOK FOR A MATCH
	  JRST	E.IQN		;ILLEGAL QUEUE NAME
	MOVE	N,0(S1)		;GET REAL NAME
	POPJ	P,		;AND RETURN

XPNQU1:	PUSH	P,N		;SAVE THE ARGUMENT
	TRZ	N,-1		;ZAP RH
	MOVE	S1,[IOWD QUENML+1,QUENMA]
	PUSHJ	P,.NAME##	;FIND IT
	  JRST	E.IQN		;ILLEGAL QUEUE NAME
	POP	P,N		;OK, RESTORE REAL NAME
	POPJ	P,		;AND RETURN

XPNQU2:	MOVEI	S1,QTPLPT+QUENMT ;LU AND LL ARE LPTS
	POPJ	P,		;RETURN


E.IQNQ:	MOVE	N,Q.DEV(Q)		;SETUP N
E.IQN:	N$FATE	<IQN>,<N>,<Illegal queue name>

	SUBTTL	ACCTSW - SCAN ACCOUNT SWITCH PROCESSING ROUTINE

ACCTSW:	PUSHJ	P,.SWASQ##
	MOVE	T1,ARGBK2+.ACCTS ;HAS ACCOUNT STRING BEEN SPECIFIED ??
	CAME	T1,[-1]		;IF -1 THEN ITS OK
	POPJ	P,		;IF NOT -1 THEN ALREADY SET !!!
	SETZM	ARGBK2+.ACCTS	;RESET THE ACCOUNT FLAG
	MOVE	T1,[POINT 7,.NMUL##]
	MOVE	T2,[POINT 7,ARGBK2+.ACCTS]
	MOVEI	T3,^D39		;MAXIMUM NUMBER OF CHARACTERS IN ACCOUNT STRING
ACCTS1:	ILDB	T4,T1
	JUMPE	T4,.POPJ1	;NOTE THAT VALIDATION IS DONE LATER
	CAIGE	T4,176		;NO. CHECK FOR ILLEGAL CHARACTERS
	CAIGE	T4," "
ACCTS2:	N$FATE	<ICS>,<N>,<Illegal Character Specified in /ACCOUNT Switch>
	IDPB	T4,T2
	SOJGE	T3,ACCTS1
	JRST	ACCTS2		;TOO MANY CHARACTERS

; Input a time. Legal formats are /TIME:seconds or /TIME:hh:mm:ss
; Call:	PUSHJ	P,RDX60W
;
; On return, N:= time
;
RDX60W:	PUSHJ	P,.SAVE2##		;SAVE SCAN'S P1 AND P2, OUR T3 AND T4
	SETZB	T3,T4			;CLEAR COUNTER, RESULT

RDX6.1:	PUSHJ	P,.DECNW##		;GET A NUMBER
	JUMPL	N,RDX6.2		;CHECK FOR ILLEGAL NUMBERS
	CAILE	N,^D60			;A REASONABLE NUMBER?
	JRST	RDX6.4			;NO - MUST HAVE GIVEN TIME IN SECONDS
	IMULI	T4,^D60			;SHIFT SOME
	ADDI	T4,(N)			;ADD IN FIELD
	CAIE	C,":"			;FIELD SEPARATOR?
	JRST	RDX6.3			;NO - MUST BE END OF TIME SPEC
	CAIG	T3,2			;TOO MANY FIELDS?
	AOJA	T3,RDX6.1		;NO - GET ANOTHER FIELD

RDX6.2:	N$FATE	<IFT>,,<Illegal format in time specification>
RDX6.3:	SKIPA	N,T4			;GET RESULT
RDX6.4:	SKIPN	T3			;CHECK FOR BAD TIME COMPONENT
	POPJ	P,			;RETURN
	N$FATE	<TCT>,<D>,<Time component too large>
SUBTTL	Fatal Error Message Routines


;NFMSG  --  ISSUE FATAL MESSAGE AND RESTART JOB
;	CALLED BY N$FATE MACRO
;
NFMSG:	MOVEI	S2,.POPJ##		;NULL ROUTINE
	JRST	NFMSXE			;GO DO THE REST

;NFMSGN  --  ISSUE FATAL MESSAGE, TYPE N IN SIXBIT, AND RESTART JOB
;	CALLED BY N$FATE MACRO
;
NFMSGN:	MOVEI	S2,.TSIXN##		;THE ROUTINE TO CALL
	JRST	NFMSXE			;GO DO THE REST

;NFMSGD  --  ISSUE FATAL MESSAGE, TYPE N IN DECIMAL, AND RESTART JOB
;	CALLED BY N$FATE MACRO
;
NFMSGD:	MOVEI	S2,.TDECW##		;THE ROUTINE TO CALL
	JRST	NFMSXE			;AND GO FINISH UP

;NFMSGO  --  ISSUE FATAL MESSAGE, TYPE N IN OCTAL, AND RESTART JOB
;	CALLED BY N$FATE MACRO
;
NFMSGO:	MOVEI	S2,.TOCTW##		;THE OCTAL ROUTINE
					;AND FALL INTO NFMSXE

;HERE TO PRINT THE MESSAGE AND CALL THE ROUTINE SETUP ABOVE
;
NFMSXE:	PUSH	P,S2			;SAVE S2 FOR LATER
	MOVE	S2,(S1)			;GET CODE IN S2
	MOVEI	S1,1(S1)		;GET PC+1 INTO S1
	EXCH	S1,S2			;SWAP THEM
	HRLI	S1,'QUE'		;GET A PREFIX
	HRLI	S2,"?"			;GET A QUESTION MARK
	PUSHJ	P,.ERMSG##		;TYPE THE ERROR MESSAGE
	PUSHJ	P,.TSPAC##		;TYPE A SPACE
	POP	P,S2			;GET THE ROUTINE BACK
	MOVE	S1,N			;GET THE ARGUMENT
	PUSHJ	P,(S2)			;CALL IT
NFMSX1:	PUSHJ	P,.CLRBF##		;CLEAR OUT TYPE AHEAD
	PUSHJ	P,.TCRLF##		;TYPE A CRLF
	PUSHJ	P,.TCRLF##		;AND ANOTHER ONE
	MOVE	P,[IOWD LN$PDL,PDLST]	;RESET PDL
	JRST	QUELOP			;AND START OVER
SUBTTL	Non-fatal Error Message Routines


;;;WARNING MESSAGES
FWARNN:	PUSH	P,N			;SAVE N
	HRLI	N,.TSPAC##		;ROUTINE TO CALL
	JRST	FWARN1			;AND CONTINUE

FWARN:	PUSH	P,N			;SAVE N
	HRLI	N,.TCRLF##		;ROUTINE TO CALL
					;AND FALL INTO COMMON CODE


FWARN1:	HRR	N,-1(P)			;GET ADDRESS OF ARGS
	PUSHJ	P,.PSH4T##		;SAVE SOME ACS
	HLRZ	S1,0(N)			;GET CODE
	HRLI	S1,'QUE'		;FILL IN CONSTANT PART
	HRRZ	S2,0(N)			;GET ADR OF MESSAGE
	HRLI	S2,"%"			;GET PREFIX
	PUSHJ	P,.ERMSG##		;TYPE THE MESSAGE
	MOVSS	N			;GET ADR OF ROUTINE IN RH
	PUSHJ	P,(N)			;CALL IT
	PUSHJ	P,.POP4T##		;RESTORE SOME ACS
	POP	P,N			;RESTORE N
	PJRST	.POPJ1##		;AND SKIP BACK OVER ARGS


;;;INFORMATION
FINFON:	PUSH	P,N			;SAVE N
	HRLI	N,.TSPAC##		;GET ADDRESS OF ROUTINE
	JRST	FINFO1			;AND CONTINUE

FINFO:	PUSH	P,N			;SAVE N
	HRLI	N,FINFO2		;ADDRESS OF ROUTINE
					;AND FALL THRU


FINFO1:	HRR	N,-1(P)			;GET ADDRESS OF ARGS
	PUSHJ	P,.PSH4T##		;SAVE SOME ACS
	HLRZ	S1,0(N)			;GET CODE
	HRLI	S1,'QUE'		;FILL IN CONSTANT PART
	HRRZ	S2,0(N)			;GET ADR OF MESSAGE
	HRLI	S2,"["			;GET PREFIX
	PUSHJ	P,.ERMSG##		;TYPE THE MESSAGE
	MOVSS	N			;GET ADR OF ROUTINE IN RH
	PUSHJ	P,(N)			;CALL IT
	PUSHJ	P,.POP4T##		;RESTORE SOME ACS
	POP	P,N			;RESTORE N
	PJRST	.POPJ1##		;AND SKIP BACK OVER ARGS


FINFO2:	MOVEI	S1,"]"			;A CLOSE
	PUSHJ	P,.TCHAR##		;TYPE IT
	PJRST	.TCRLF##		;TYPE A CRLF AND RETURN
SUBTTL	STORAGE

	XLIST		;LITERALS
	LIT
	LIST

			;SWITCH TO LOW SEG
	SWSEG

LOWFWA:!		;START OF LOW DATA AREA
SAVCOR:	BLOCK	1	;INITIAL VALUE OF LOW SEG CORE SIZE
NOW:	BLOCK	1	;CURRENT SYSTEM DATE/TIME
MADFIL:	BLOCK	1	;WE DUMMIED UP A FILESPEC FLAG
STRTOF:	BLOCK	1	;STARTING ADDRESS OFFSET

;**;[522]ADD 1 LINE AFTER STRTOF:+0L		14-JUN-84/CTK
T.ASST:	BLOCK	1	;[522]USER INPUT STATE WORD -1 IF NOT INPUT


ISARG:	BLOCK	2	;FUDGE TO SET UP TYPEOUT ADDRESS   ;;;;;;KEEP
TYPER:	BLOCK	2	;ADDRESS OF TYPE CHARACTER ROUTINE ;;;;;;IN
MONRTR:	BLOCK	1	;ADDRESS OF MONRET ROUTINE	   ;;;;;;ORDER
ZCOR:!			;START OF AREA TO ZERO ON INITIAL LOAD

PDLST:	BLOCK	LN$PDL+1  ;PUSH-DOWN LIST
OPNBLK:	BLOCK	3	;OPEN BLOCK

LKBLK:	BLOCK	1	;EXTENDED LOOKUP BLOCK
RIBPPN:	BLOCK	1	;DIRECTORY
RIBNAM:	BLOCK	1	;FILE NAME
RIBEXT:	BLOCK	1	;FILE EXTENSION
RIBPRV:	BLOCK	1	;PROTECTION WORD
RIBSIZ:	BLOCK	1	;FILE SIZE
	BLOCK	1	;JUNK
RIBSPL:	BLOCK	1	;SPOOLING NAME
	BLOCK	6	;JUNK
RIBDEV:	BLOCK	1	;LOCATION OF FILE (LOGICAL UNIT)
LKBLKL==.-LKBLK


P.ZER:!			;START OF AREA FOR FILE DEFAULTS
P.MOD:	BLOCK	1	;LAST STICKY FILE SWITCHES TYPED BY USER
P.MODM:	BLOCK	1	;LAST STICKY FILE SWITCHES MASK TYPED BY USER
P.FONT:	BLOCK	FNMLTH	;FONT NAME (30 CHARS MAX)
P.EZER==.-1
P.MIN:!
P.STRT:	BLOCK	1	;LAST STICKY FILE STARTING POINT
P.RPT:	BLOCK	2	;REPORT NAME
P.EMIN==.-1

F.ZER:!			;START OF AREA FOR FILE TYPE-INS
F.MOD:	BLOCK	1	;FILE SWITCHES
F.MODM:	BLOCK	1	;FILE SWITCH MASK (ON IF TYPED)
F.FONT:	BLOCK	FNMLTH	;FONT NAME (30 CHARS MAX)
F.EZER==.-1
F.MIN:!
F.STRT:	BLOCK	1	;FILE STARTING POINT
F.RPT:	BLOCK	2	;/REPOR KEY
F.EMIN==.-1


;GETTAB INFO
G$NAM1:	BLOCK	1			;FIRST HALF OF USER'S NAME
G$NAM2:	BLOCK	1			;SECOND HALF OF USER'S NAME
G$CMAX:	BLOCK	1			;SYSTEM CORMAX
G$MNMX:	BLOCK	1			;MINMAX

S.ZER:!

ARGBK2:	BLOCK	.AG2LN		;SECONDARY QMANGR ARGUMENT BLOCK

COMDEV:	BLOCK	1	;COMMAND-DEVICE FOR CURRENT REQUEST
QTYPE:	BLOCK	1	;QUEUE TYPE FOR CURRENT REQUEST
OSCNML:	BLOCK	2	;COMMANDS FOR .OSCAN

DEFFIL:	BLOCK	.FXLEN		;/PATH:[DIRECTORY]
DEFDIR=DEFFIL+.FXDIR
MX.PTH==.FXLEN
PD.PTH==0
O.ZER:!			;START OF OUTPUT SPEC STORAGE
O.DEV:	BLOCK	1	;DEVICE
O.NAM:	BLOCK	1	;NAME
O.NAMM:	BLOCK	1	;NAME MASK
O.EXT:	BLOCK	1	;EXT,,MASK
O.MOD:	BLOCK	1	;SCAN SWITCHES
O.MODM:	BLOCK	1	;SCAN SWITCH MASK
O.DIR:	BLOCK	1	;DIRECTORY
O.DIRM:	BLOCK	2*.FXLND-1	;DIRECTORY MASK
O.BFR:	BLOCK	1	;/BEFORE
O.SNC:	BLOCK	1	;/SINCE
O.ABF:	BLOCK	1	;/ABEFORE
O.ASN:	BLOCK	1	;/ASINCE
O.FLI:	BLOCK	1	;FILE MIN SIZE (WORDS)
O.FLM:	BLOCK	1	;FILE MAX SIZE (WORDS)
O.EST:	BLOCK	1	;/ESTIMATE
O.VER:	BLOCK	1	;/VERSION
O.LZER==.-O.ZER


L.OPEN:	BLOCK	3		;LISTING FILE OPEN BLOCK
L.LOOK:	BLOCK	LN$ENT		;LISTING FILE LOOKUP BLOCK
L.PATH:	BLOCK	.PTMAX		;LISTING FILE PATH BLOCK
L.DSKC:	BLOCK	LN$DSK		;LISTING FILE DSKCHR BLOCK
L.OTYO:	BLOCK	1		;LISTING FILE OLD TYPE OUT ROUTINE
L.STAT:	BLOCK	1		;LISTING FILE CHANNEL STATUS
L.PNTR:	BLOCK	1		;LISTING FILE BYTE POINTER TO LIST MESSAGE

PTHFCN:	BLOCK	.PTMAX	;PATH. ARGS
PTHPPN=PTHFCN+.PTPPN

PTFFCN:	BLOCK	.PTMAX		;FILE PATH BLOCK
PTFPPN=PTFFCN+.PTPPN

PTHBLK:	BLOCK	.PTMAX		;MORE PATH SPACE

I.INZR:	BLOCK	1	;INITIAL INPUT SPEC STORAGE
I.NXZR:	BLOCK	1	;POINTER TO NEXT INPUT SPEC STORAGE
I.LSZR:	BLOCK	1	;POINTER TO LAST INPUT SPEC STORAGE
S.EZER==.-1





	RELOC	QUENCH			;SAVE SPACE

	PHASE	0
	BLOCK	.FXLEN	;SCAN'S AREA
I.MOD:!	BLOCK	1	;SWITCHES
I.MODM:!BLOCK	1	;SWITCH MASK (ON IF USER SUPPLIED)
I.FONT:!BLOCK	FNMLTH	;FONT FILE NAME (30 CHARS MAX)
I.STRT:!BLOCK	1	;FILE STARTING POINT
I.RPT:!	BLOCK	2	;/REPORT SWITCH
I.LZER:!
	PHASE	0	;DEFINE QUEUE AREA (RELOCATABLE)
Q.ZER::!		;START OF QUEUE PARAMETER AREA
Q.MEM::!BLOCK	1	;USED FOR CHARACTER TYPER
Q.OPR::!BLOCK	1	;OPERATION CODE
Q.LEN::!BLOCK	1	;LENGTHS IN AREA
Q.DEV::!BLOCK	1	;DESTINATION DEVICE
Q.PPN::!BLOCK	1	;PPN ORIGINATING REQUEST
Q.JOB::!BLOCK	1	;JOB NAME
Q.SEQ::!BLOCK	1	;JOB SEQUENCE NUMBER
Q.PRI::!BLOCK	1	;EXTERNAL PRIORITY
Q.PDEV::!BLOCK	1	;PROCESSING DEVICE
Q.PPNM::!
Q.TIME::!BLOCK	1	;PROCESSING TIME OF DAY  (PPN MASK ON MODIFY)
Q.JOBM::!
Q.CREA::!BLOCK	1	;CREATION TIME  (JOB NAME MASK ON MODIFY)
Q.AFTR::!BLOCK	1	;AFTER PARAMETER
Q.FLAG::!BLOCK	1	;QMANGR SECONDARY DATA BLOCK ADDRESS
Q.RID::! BLOCK	1	;REQUEST ID
Q.USER::!BLOCK	2	;USER'S NAME

Q.I::!			;START OF INPUT QUEUE AREA
;**;[522]DOCUMENT THE BIT USAGE		14-JUN-84/CTK
Q.IDEP::!BLOCK	1	;DEPENDENCY WORD
			;    0: /RESTARTABLE
			;  1-2: 1+/UNIQUE
			;    3: 1 IF /MODIFY/RESTARTABLE
			;  4-5: /ASSISTANCE
			;  6-8: /OUTPUT
			;    9:	/RDR
			;10-11: /BATLOG
			;   12: 1 IF /MODIFY/ASSISTANCE
			;13-17: (FUTURE)
			;18-19: TYPE OF /DEPENDENCY
			;	0  ABSOLUTE
			;	1  +
			;	2  -
			;	3  NO CHANGE
			;20-35: /DEPENDENCY VALUE
Q.ILIM::!BLOCK	3	;JOB LIMITS
Q.IDDI::!BLOCK	.FXLND	;JOB'S DIRECTORY
Q.II::!			;START OF FILE AREA
Q.ILEN==.-Q.ZER

	PHASE	Q.I
Q.O::!			;START OF OUTPUT QUEUE AREA
Q.OFRM::!BLOCK	1	;FORMS REQUEST
Q.OSIZ::!BLOCK	1	;LIMIT WORD
Q.ONOT::!BLOCK	2	;ANNOTATION
Q.FF::!
	PHASE	0
Q.F::!			;DUPLICATED AREA FOR EACH REQUESTED FILE
Q.FSTR::!BLOCK	1	;FILE STRUCTURE
Q.FDIR::!BLOCK	.FXLND	;ORIGINAL DIRECTORY
Q.FNAM::!BLOCK	1	;ORIGINAL NAME
Q.FEXT::!BLOCK	1	;ORIGINAL EXTENSION
Q.FRNM::!BLOCK	1	;RENAMED FILE NAME (0 IF NOT)
Q.FBIT::!BLOCK	1	;BIT 0=PRESERVED BY QUEUE, REST=STARTING BIT
Q.FMOD::!BLOCK	1	;FILE SWITCHES
Q.FRPT::!BLOCK	2	;/REPORT KEY
Q.FONT::!BLOCK	FNMLTH	;FONT NAME IF ANY

	Q.FLEN==.-Q.F

Q.FDRM::!BLOCK	.FXLND	;DIRECTORY MASK
Q.FNMM::!BLOCK	1	;FILE NAME MASK
Q.FEXM::!BLOCK	1	;FILE EXT MASK
Q.FMDM::!BLOCK	1	;MODIFIER MASK
Q.FLNM==.-Q.F
	DEPHASE
	RELOC	S.EZER+1
T.ZER:!			;START OF TEMPORARY DATA AREA
NOBLKS:	BLOCK	1	;ACCUMULATED NUMBER OF BLOCKS TO BE PROCESSED
MODFLG:	BLOCK	1	;FLAG -1 IF MODIFY, 0 IF NOT.
CREFLG:	BLOCK	1	;FLAG 0 IF CREATE, -1 IF NOT
DQTYPE:	BLOCK	1	;WORD TO STORE OUTPUT QUEUE TYPE
			; FOR SUBMIT,PUNCH ...
COMIDX:	BLOCK	1	;INDEX INTO QCOMS RETURNED BY ISCAN
LOGCNT:	BLOCK	1	;COUNT DOWN TO LOG FILE
NAFFLG:	BLOCK	1	;SET IF SOME FILE DOESN'T EXIST
LSTBLK:	BLOCK	7+STSSIZ	;BLOCK FOR LIST ANSWERS
T.EZER:!


;BUFFER POINTERS
B.LC:	BLOCK	3	;LISTING FILE

SAVEF:	BLOCK	1	;F SAVED HERE DURING LISTING PASSES
SAVEI:	BLOCK	1	;I SAVED HERE DURING LISTING PASSES
SAVEQ:	BLOCK	1	;Q SAVED HERE DURING LISTING PASSES


EZCOR==.-1		;END OF AREA TO ZERO

	END	QUENCH
