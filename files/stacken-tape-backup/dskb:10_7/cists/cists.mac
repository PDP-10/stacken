TITLE	CISTS - Print Status of CI Network
SUBTTL	Joseph A. Dziedzic /JAD		11-Apr-85


	SEARCH	GLXMAC,MSCPAR
	SALL
	PROLOG	(CISTS)


	CISVER==1		;MAJOR VERSION
	CISMIN==0		;MINOR VERSION
	CISEDT==1		;EDIT NUMBER
	CISWHO==0		;WHO LAST EDITTED

	LOC	137
.JBVER::!VRSN.	CIS
	RELOC
	SUBTTL	Parameters


ND	FTPOLL,0		;NON-ZERO TO ENABLE DEVICE POLLING


	MAXNDS==20		;MAXIMUM NUMBER OF NODES ON CI NETWORK

	.SSMAX==100		;SIZE OF SCS. UUO ARGUMENT BLOCK

	BYTE1==BYTE(8)-1,0,0,0
	BYTE2==BYTE(8)0,-1,0,0
	BYTE3==BYTE(8)0,0,-1,0
	BYTE4==BYTE(8)0,0,0,-1
	SUBTTL	Data segment


IB:	$BUILD	IB.SZ		;BUILD IB
	 $SET	(IB.PRG,,%%.MOD)	;PROGRAM NAME
IFN FTPOLL,<
	 $SET	(IB.INT,,VECTOR)	;ADDRESS OF INTERRUPT VECTOR BLOCK
>; END IFN FTPOLL
	$EOB

IFN FTPOLL,<
OURDNM:	ASCII	.T-10$CISTS      .
YURDNM:	ASCII	.MSCP$DISK       .
>; END IFN FTPOLL

	$DATA	PDLIST,100	;PUSH DOWN LIST

	$DATA	CPUPTR		;AOBJN POINTER TO DO CPU'S
	$DATA	CPUSTS,6	;STATUS OF CPU - .LE. ZERO IF OK
	$DATA	CPULNN,6	;LOCAL NODE NUMBER

	$DATA	SCSBLK,.SSMAX	;FOR DOING SCS. UUO

	$DATA	PTHSTS,MAXNDS	;PATH STATUS FOR EACH NODE AND EACH CPU

IFN FTPOLL,<
	$DATA	MSCSRV,MAXNDS	;NON-ZERO IF NODE HAS MSCP SERVER
	$DATA	MSGBUF		;ADDRESS OF MESSAGE BUFFER
	$DATA	MSGSIZ		;SIZE OF MESSAGE BUFFER
	$DATA	VECTOR,4	;INTERRUPT VECTOR BLOCK
	$DATA	OURCID		;OUR CONNECT ID
>; END IFN FTPOLL
	SUBTTL	Initialization


START:	JFCL			;IN CASE CCL ENTRY
	RESET			;RESET ALL I/O

	MOVE	P,[IOWD 100,PDLIST] ;SET UP STACK
	MOVX	S1,IB.SZ	;LENGTH OF IB
	MOVEI	S2,IB		;ADDRESS OF IB
	$CALL	I%INIT		;GET THE GALAXY LIBRARY

IFN FTPOLL,<
	$CALL	ZERSCS		;ZERO THE SCS. UUO BLOCK
	MOVE	S1,[.SQLDG+1,,.SSRBS] ;GET BUFFER SIZES
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	XMOVEI	S1,SCSBLK	;ADDRESS OF BLOCK
	SCS.	S1,		;ASK THE MONITOR
	  JRST	SCSERR		;ERROR
	MOVE	S1,SCSBLK+.SQLMG ;GET MAXIMUM LENGTH OF MESSAGE BUFFER
	ADDI	S1,10		;(.MHUDA)
	MOVEM	S1,MSGSIZ	;STORE SIZE
	$CALL	M%GMEM		;GET A BUFFER
	MOVEM	S2,MSGBUF	;STORE FOR LATER
>; END IFN FTPOLL

	MOVX	T1,%CNCPU	;NUMBER OF CPU'S IN SYSTEM
	GETTAB	T1,		;ASK
	  $STOP	(CDS,Can't determine number of CPUs in system)
	MOVNS	T1		;MAKE AN AOBJN POINTER
	HRLZS	T1		;...
	MOVEM	T1,CPUPTR	;SAVE FOR LATER
	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK
	MOVE	S1,[.SQLNN+1,,.SSGLN] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVE	T1,CPUPTR	;AOBJN POINTER TO CPU DATA

GETCST:	HRRZ	T2,T1		;GET CPU NUMBER
	LSH	T2,1		;TIMES TWO
	ADDX	T2,%CCOKP	;GETTAB FOR CPU OK WORD
	GETTAB	T2,		;ASK MONITOR
	  MOVEI	T2,1		;MONITOR WON'T SAY, ASSUME IT'S DEAD
	MOVEM	T2,CPUSTS(T1)	;SAVE IT
	JUMPG	T2,GETCS2	;JUMP IF CPU IS DOWN
	STORE	T1,SCSBLK+.SQFNC,SS.CPU ;STORE CPU NUMBER
	XMOVEI	S1,SCSBLK	;POINT AT ARGUMENT BLOCK
	SCS.	S1,		;DO THE UUO
	  SKIPA			;ERROR, CHECK IT OUT
	JRST	GETCS1		;PROCEED
	CAXE	S1,SSNPC%	;NO CI PORT ON THIS CPU?
	JRST	SCSERR		;NO, REAL ERROR
	MOVEI	S1,1		;GET A POSITIVE NUMBER
	MOVEM	S1,CPUSTS(T1)	;TO MAKE CPU CHECKS FAIL
	JRST	GETCS2		;SKIP THIS CPU
GETCS1:	MOVE	T2,SCSBLK+.SQLNN ;GET LOCAL NODE NUMBER
	MOVEM	T2,CPULNN(T1)	;SAVE THAT
GETCS2:	AOBJN	T1,GETCST	;LOOP FOR ALL
	SUBTTL	Print Path Status


;Get path status for each CPU for each node

	MOVX	S1,MAXNDS	;LENGTH OF BLOCK
	MOVEI	S2,PTHSTS	;POINT AT BLOCK
	$CALL	.ZCHNK		;ZERO IT

	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK

	MOVE	S1,[.SQRPS+1,,.SSRPS] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVE	P1,CPUPTR	;GET AOBJN POINTER FOR CPU STUFF

GETPTS:	SKIPLE	CPUSTS(P1)	;THIS CPU LOOK OK?
	JRST	GETPT2		;NO
	STORE	P1,SCSBLK+.SQFNC,SS.CPU ;STORE CPU NUMBER
	MOVSI	P2,-MAXNDS	;MAXIMUM NUMBER OF NODES
GETPT1:	HRRZM	P2,SCSBLK+.SQRPN ;STORE NODE NUMBER
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;ASK
	  JRST	SCSERR		;ERROR
	MOVE	T1,SCSBLK+.SQRPS ;GET PATH STATUS
	LSH	T1,(P1)		;SHIFT BY CPU NUMBER
	IORM	T1,PTHSTS(P2)	;STORE ON A PER-NODE BASIS
	AOBJN	P2,GETPT1	;LOOP FOR ALL NODES
GETPT2:	AOBJN	P1,GETPTS	;LOOP FOR ALL CPUS
;Print status

	$TEXT	,<Open Paths:

CI Node  00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
>
	MOVE	P1,CPUPTR	;GET CPU POINTER
TYPPTS:	SKIPLE	CPUSTS(P1)	;CPU LOOK OK?
	JRST	TYPPT3		;NO
	$TEXT	,<CPU^D5L /P1,RHMASK/^A> ;CPU NUMBER
	MOVSI	P2,-MAXNDS	;GET NODE POINTER
TYPPT1:	HRRZ	T1,P2		;GET NODE NUMBER
	CAMN	T1,CPULNN(P1)	;SELF?
	JRST	[MOVE	T2,["-",,"-"] ;YES, GET TEXT
		 JRST	TYPPT2]	;PRINT THAT INSTEAD OF STATUS
	MOVE	T1,PTHSTS(P2)	;GET PATH STATUS
	MOVNI	T2,(P1)		;GET -VE CPU NUMBER
	LSH	T1,(T2)		;RIGHT-JUSTIFY BITS FOR THIS NODE
	SETZ	T2,		;ZERO T2
	TLZE	T1,1		;BIT SET?
	TLOA	T2,"A"		;YES
	TLO	T2," "		;NO
	TRZE	T1,1		;BIT SET?
	TROA	T2,"B"		;YES
	TRO	T2," "		;NO
TYPPT2:	$TEXT	,< ^7/T2,LHMASK/^7/T2,RHMASK/^A> ;PRINT STATUS
	AOBJN	P2,TYPPT1	;LOOP FOR NEXT NODE
	$TEXT	,<>		;CRLF
TYPPT3:	AOBJN	P1,TYPPTS	;LOOP FOR NEXT CPU
	SUBTTL	Print Node Configuration Data


	$TEXT	,<

Configuration Data:>

IFN FTPOLL,<
	MOVX	S1,MAXNDS	;MAXIMUM NUMBER OF NODES
	MOVEI	S2,MSCSRV	;ADDRESS OF BLOCK
	$CALL	.ZCHNK		;ZERO IT
>; END IFN FTPOLL

	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK

	MOVE	S1,[.SQLPN+1,,.SSRCD] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVSI	P2,-MAXNDS	;LOOP FOR ALL NODES

TYPCNF:	SKIPN	T1,PTHSTS(P2)	;ANY OPEN PATHS TO THIS NODE?
	JRST	TYPCN1		;NO
	HLRZ	T2,T1		;GET PATH A STATUS TO RH OF T2
	IOR	T1,T2		;COMBINED STATUS IN RH OF T1
	TLZ	T1,-1		;CLEAR LH JUNK NOW
	JFFO	T1,.+1		;COMPUTE CPU NUMBER TO USE
	MOVEI	P1,^D35		;...
	SUB	P1,T2		;...
	STORE	P1,SCSBLK+.SQFNC,SS.CPU ;STORE CPU NUMBER
	HRRZM	P2,SCSBLK+.SQOND ;STORE NODE NUMBER
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;ASK
	  JRST	SCSERR		;ERROR
	$TEXT	,<
Node ^D/SCSBLK+.SQOND/:>
	LOAD	T1,SCSBLK+.SQVCS,LHMASK ;GET VC STATE
	$TEXT	,<Virtual circuit state: ^T/@VCSTAT(T1)/>
	MOVE	T1,SCSBLK+.SQDST ;SOFTWARE TYPE
	$TEXT	,<Software type: ^I/EBITT1/>
	MOVE	T1,SCSBLK+.SQDSV ;SOFTWARE VERSION
	$TEXT	,<Software version: ^I/EBITT1/>
	MOVE	T1,SCSBLK+.SQDHT ;HARDWARE TYPE
	$TEXT	,<Hardware type: ^I/EBITT1/>
	MOVE	T1,SCSBLK+.SQNNM ;NODE NAME
	$TEXT	,<Node name: ^I/EBITT1/^A>
	MOVE	T1,SCSBLK+.SQNNM+1 ;SECOND WORD
	$TEXT	,<^I/EBITT1/>
	LDB	T1,[POINT 8,SCSBLK+.SQPCW,31] ;GET HARDWARE TYPE
IFN FTPOLL,<
	CAIN	T1,4		;HSC?
	SETOM	MSCSRV(P2)	;YES, REMEMBER MSCP SERVERS (ONLY HSC FOR NOW)
>; END IFN FTPOLL
	MOVEI	T2,[ASCIZ /unknown/] ;ASSUME WORST CASE
	CAIN	T1,4		;HSC?
	MOVEI	T2,[ASCIZ /HSC-50/]
	CAIN	T1,6		;KL-10?
	MOVEI	T2,[ASCIZ /KL-10/]
	$TEXT	,<Port type: ^T/@T2/>
TYPCN1:	AOBJN	P2,TYPCNF	;LOOP FOR NEXT NODE
	SUBTTL	Print Device Configuration


IFN FTPOLL,<			;FEATURE WANTED?
DEVPAT:	JRST	DONE		;FOR NOW
	XMOVEI	S1,SCSINT	;ADDRESS OF INTERRUPT HANDLER
	MOVEM	S1,VECTOR+.PSVNP
	SETZM	VECTOR+.PSVFL	;NO FLAGS
	SETZM	VECTOR+.PSVIS	;NO STATUS
	MOVE	S1,[PS.FAC+[EXP .PCSCS,0,0]] ;ADD SCS EVENT INTERRUPT
	PISYS.	S1,		;DO IT
	 $STOP	(CAC,Can't add interrupt condition)
	$CALL	I%ION		;TURN ON THE INTERRUPT SYSTEM
	MOVSI	P2,-MAXNDS	;LOOP FOR ALL NODES

TYPDEV:	SKIPE	T1,PTHSTS(P2)	;ANY OPEN PATHS TO THIS NODE?
	SKIPN	MSCSRV(P2)	;YES, DOES IT HAVE AN MSCP SERVER?
	JRST	TYPDVN		;NO
	HLRZ	T2,T1		;GET PATH A STATUS TO RH OF T2
	IOR	T1,T2		;COMBINED STATUS IN RH OF T1
	TLZ	T1,-1		;CLEAR LH JUNK NOW
	JFFO	T1,.+1		;COMPUTE CPU NUMBER TO USE
	MOVEI	P1,^D35		;...
	SUB	P1,T2		;...

	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK

	MOVE	T1,[.SQRCI+1,,.SSCON] ;FUNCTION
	MOVEM	T1,SCSBLK+.SQFNC ;STORE IT
	MOVE	T1,[POINT 7,OURDNM] ;POINTER TO OUR PROCESS NAME
	MOVEM	T1,SCSBLK+.SQSPN ;STORE IT
	MOVE	T1,[POINT 7,YURDNM] ;POINTER TO HIS PROCESS NAME
	MOVEM	T1,SCSBLK+.SQDPN ;STORE IT
	SETZM	SCSBLK+.SQAMC	;WE'LL QUEUE MESSAGE BUFFERS AS WE NEED THEM
	SETZM	SCSBLK+.SQADC	;NO NEED FOR DATAGRAMS HERE
	STORE	P1,SCSBLK+.SQFNC,SS.CPU ;STORE CPU NUMBER
	STORE	P2,SCSBLK+.SQSYS,LHMASK ;STORE NODE NUMBER
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;ASK
	  JRST	SCSERR		;ERROR
	MOVE	T1,SCSBLK+.SQRCI ;GET OUR CID
	MOVEM	T1,OURCID	;SAVE IT FOR LATER

	$CALL	SCSWAT		;WAIT FOR SOMETHING TO HAPPEN
	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK
	MOVE	S1,[.SSMAX,,.SSEVT] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVE	S1,OURCID	;OUR CONNECT ID
	MOVEM	S1,SCSBLK+.SQCID ;STORE IT
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;ASK
	  JRST	SCSERR		;SHOULD HAVE A RESPONSE BY NOW
	MOVE	S1,SCSBLK+.SQEVT ;GET TYPE OF EVENT
	CAIN	S1,.SECRR	;REJECTED?
	JRST	TYPDV1		;YES
	CAIN	S1,.SECRA	;ACCEPTED?
	JRST	TYPDV2		;YES
	$STOP	(UET,Unknown event type ^O/S1/)

TYPDV1:	$TEXT	,<%Connection request rejected - code ^O/SCSBLK+.SQDTA/>
	JRST	TYPDVN		;TRY NEXT

TYPDV2:	MOVE	P1,MSGBUF	;COPY ADDRESS HERE FOR A BIT
	MOVX	T1,CF.576	;ONLY USEFUL BIT
	PUSHJ	P,REVFUL	;REVERSE BITS
	MOVEM	T1,P.CNTF(P1)	;STORE IN PACKET
	SETZ	T1,		;NO UNIT NUMBER
	MOVX	T2,OP.SCC	;OPCODE
	MOVX	T3,P%CDPR	;LENGTH
	$CALL	SNDRCV		;SEND THE MESSAGE, WAIT FOR RESPONSE

	MOVE	T1,P.CNTF(P1)	;GET FLAGS
	PUSHJ	P,REVFUL	;MAKE THEM MEANINGFUL
	TXNE	T1,CF.576	;576-BYTE MODE?
	SKIPA	T1,[ASCII .576.]
	MOVE	T1,[ASCII .512.]
	$TEXT	,<  Controller: ^5/T1/-byte sector mode>
	SETZ	P4,		;START WITH UNIT ZERO

TYPDV3:	HRRZ	T1,P4		;GET CURRENT UNIT NUMBER
	MOVE	T2,[MD.NXU+OP.GUS] ;ASK FOR STATUS OF NEXT UNIT
	MOVX	T3,P%OPCD	;LENGTH
	$CALL	SNDRCV		;SEND THE MESSAGE, WAIT FOR RESPONSE

	MOVE	T1,P.UNIT(P1)	;GET UNIT NUMBER
	PUSHJ	P,REVFUL	;REVERSE BYTES
	LSH	T1,-4		;RIGHT-JUSTIFY IT
	ANDI	T1,177777	;KEEP JUST UNIT NUMBER
	HRR	P4,T1		;SAVE A COPY HERE
	JUMPN	P4,TYPDV4	;GO IF NOT UNIT ZERO
	LDB	T1,[POINT PKSEST,P.STS(P1),PKPEST] ;GET STATUS
	CAIN	T3,ST%OFL	;OFFLINE?
	JRST	TYPDV5		;NO DRIVES ON THIS HSC
	TXOE	P4,1B0		;FIRST TIME WE'VE SEEN A ZERO?
	JRST	TYPDV5		;NO, THIS ZERO MEANT NO MORE UNITS
TYPDV4:	TXO	P4,1B0		;SHOW WE'VE PROCESSED UNIT ZERO
	$TEXT	,<    Unit: ^D/P4,RHMASK/>
	JRST	TYPDV3		;TRY NEXT UNIT

TYPDV5:	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK
	MOVE	S1,[.SQDIS+1,,.SSDIS] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVE	S1,OURCID	;GET CONNECT ID
	MOVEM	S1,SCSBLK+.SQCID ;STORE IT
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;DISCONNECT
	  JRST	SCSERR		;ERROR

TYPDVN:	AOBJN	P2,TYPDEV	;LOOP FOR NEXT NODE
>; END IFN FTPOLL
	SUBTTL	All Done


DONE:	$CALL	I%EXIT		;EXIT
	SUBTTL	Miscellaney


IFN FTPOLL,<
SNDRCV:	PUSHJ	P,.SAVE2	;SAVE P1-P2
	MOVE	P1,MSGBUF	;ADDRESS OF MESSAGE BUFFER
	MOVE	P2,T2		;OPCODE FOR LATER CHECKS
	MOVE	S1,MSGSIZ	;SIZE OF PACKET
	MOVE	S2,MSGBUF	;ADDRESS
	$CALL	.ZCHNK		;ZERO IT

	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK
	MOVE	S1,[.SQFLG+1,,.SSSMG] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVE	S1,OURCID	;CONNECT ID
	MOVEM	S1,SCSBLK+.SQCID ;STORE

	LSH	T1,4		;POSITION UNIT NUMBER
	PUSHJ	P,REVFUL	;REVERSE
	MOVEM	T1,P.UNIT(P1)	;STORE
	MOVE	T1,T2		;GET OPCODE/MODIFIERS
	PUSHJ	P,REVFUL	;REVERSE
	MOVEM	T1,P.OPCD(P1)	;STORE
	MOVEM	T3,SCSBLK+.SQLPT ;LENGTH OF PACKET
	MOVEM	P1,SCSBLK+.SQAPT ;ADDRESS OF IT
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;SEND IT
	  JRST	SCSERR		;ERROR

	$CALL	SCSWAT		;WAIT FOR SOMETHING TO HAPPEN

	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK
	MOVE	S1,[.SQAFB+1,,.SSQRM] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVE	S1,MSGBUF	;ADDRESS OF BUFFER
	MOVEM	S1,SCSBLK+.SQAFB ;STORE IT
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;QUEUE IT
	  JRST	SCSERR		;ERROR

	$CALL	ZERSCS		;ZERO SCS. UUO BLOCK
	MOVE	S1,[.SQLRP+1,,.SSRMG] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVE	S1,OURCID	;OUR CONNECT ID
	MOVEM	S1,SCSBLK+.SQCID ;STORE IT
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;RECEIVE IT
	  JRST	SCSERR		;ERROR
	CAME	P1,SCSBLK+.SQARB ;THIS SHOULD CERTAINLY MATCH!
	$STOP	(RWB,Received message in wrong buffer)
	MOVE	T1,P.OPCD(P1)	;GET OPCODE
	PUSHJ	P,REVFUL	;REVERSE IT
	CAME	T1,P2		;SAME AS WE CALLED WITH?
	$STOP	(RWM,Received wrong message - expected opcode ^O/P2/, received opcode ^O/T1/)
	$RETT			;SUCCESS
>; END IFN FTPOLL

REVFUL:	$CALL	.SAVE3		;SAVE P1-P3
	LDB	P1,PBYTE1	;PICK UP THE BYTES
	LDB	P2,PBYTE2	;...
	LDB	P3,PBYTE3	;...
	LSH	T1,^D24		;POSITION LEFT OVER BYTE
	DPB	P3,PBYTE2	;PUT THEM IN BACKWARDS
	DPB	P2,PBYTE3	;...
	DPB	P1,PBYTE4	;...
	POPJ	P,		;RETURN

;BYTE POINTERS USED BY REVFUL

PBYTE1:	POINT	8,T1,7
PBYTE3:	POINT	8,T1,23
PBYTE2:	POINT	8,T1,15
PBYTE4:	POINT	8,T1,31


ZERSCS:	MOVX	S1,.SSMAX	;LENGTH OF BLOCK
	MOVEI	S2,SCSBLK	;ADDRESS OF IT
	$CALL	.ZCHNK		;ZERO IT
	$RETT			;RETURN

SCSWAT:	MOVEI	S1,^D5		;WAIT FOR ABOUT 5 SECONDS
	$CALL	I%SLP		;...
	$RETT			;HOPE WE WERE INTERRUPTED

IFN FTPOLL,<
SCSQMB:	$CALL	ZERSCS		;ZERO SCS. BLOCK
	MOVE	S1,[.SQAFB+1,,.SSQRM] ;FUNCTION
	MOVEM	S1,SCSBLK+.SQFNC ;STORE IT
	MOVE	S1,MSGBUF	;ADDRESS OF MESSAGE BUFFER
	SETZM	(S1)		;ONLY ONE BUFFER
	MOVEM	S1,SCSBLK+.SQAFB ;STORE ADDRESS
	XMOVEI	S1,SCSBLK	;POINT AT BLOCK
	SCS.	S1,		;DO IT
	  JRST	SCSERR		;ERROR
	$RETT			;RETURN
>; END IFN FTPOLL

SCSINT:	$BGINT	1		;BEGIN LEVEL 1 INTERRUPT
	$DEBRK			;JUST GET US OUT OF HIBERNATION

EBITT1:	ITEXT	(<^7/T1,BYTE1/^7/T1,BYTE2/^7/T1,BYTE3/^7/T1,BYTE4/>)

VCSTAT:	[ASCIZ	.closed.]
	[ASCIZ	.START sent.]
	[ASCIZ	.START received.]
	[ASCIZ	.open.]

SCSERR:	HRRZ	S2,S1		;COPY ERROR CODE
	CAIL	S2,SCSETL	;KNOWN ERROR?
	MOVEI	S2,SCSETL	;NO, USE GENERIC CASE
	$STOP	(SCS,<SCS. UUO error (^O/S1/) ^T/@SCSETX(S2)/>)

SCSETX:	[ASCIZ	.not privileged.]
	[ASCIZ	.illegal function code.]
	[ASCIZ	.bad argument list length.]
	[ASCIZ	.address check reading arguments.]
	[ASCIZ	.address check storing data.]
	[ASCIZ	.CPU number out of range.]
	[ASCIZ	.no CI port on specified CPU.]
	[ASCIZ	.CPU's CI node number unknown.]
	[ASCIZ	.invalid CI node number.]
	[ASCIZ	.no free core.]
SCSETL==.-SCSETX
	[ASCIZ	.unknown error code.]
	SUBTTL	The End


	END	START
