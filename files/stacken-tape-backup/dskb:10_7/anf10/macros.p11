.SBTTL	MACROS - SOME USEFUL PDP-11 MACROS 17-MAY-88

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1976,1977,1978,1979,1980,1981,1982,1983,1984,1987,1988.
;ALL RIGHTS RESERVED.

VRMACR=033			;FILE EDIT NUMBER

; THESE MACROS ARE INTENDED TO IMPROVE THE READABILITY
;  OF THE CODE AND MAKE MODEL-INDEPENDENT CODE EASIER
;  TO WRITE.
;
;
;
; MACROS TO LOAD AND STORE PS REGISTER.  THESE ARE SINGLE
;  INSTRUCTIONS ON THE PDP-11/03 AND PDP-11/34.


.MACRO	MTPS	NEWPS
	.IF EQ,<<PDP11-03>*<PDP11-34>>
		XX=.
	CLR	NEWPS
		XXX=.
		.=XX
		.NTYPE	XX,NEWPS
	.WORD	106400+XX
		.=XXX
	.IFF
	MOV	NEWPS,@#PS
	.ENDC ;.IF EQ,<<PDP11-03>*<PDP11-34>>
.ENDM	MTPS



.MACRO	MFPS	DESTI
	.IF EQ,<<PDP11-03>*<PDP11-34>>
		XX=.
	CLR	DESTI
		XXX=.
		.=XX
		.NTYPE	XX,DESTI
	.WORD	106700+XX
		.=XXX
	.IFF
	MOV	@#PS,DESTI
	.ENDC ;.IF EQ,<<PDP11-03>*<PDP11-34>>
.ENDM	MFPS
.SBTTL	MACRO DEFINITIONS

.MACRO COUNT A
	INC	A+2
	BNE	.+6
	INC	A
.ENDM	COUNT


; REGISTER SAVE MACRO

.MACRO	SAVE	A
	.IRP	X,<A>
	MOV	X,-(P)			;PUSH X ON THE STACK
	.ENDM
.ENDM	SAVE



; REGISTER RESTORE MACRO

.MACRO	RESTORE	A
	.IRP	X,<A>
	MOV	(P)+,X			;POP X OFF THE STACK
	.ENDM
.ENDM	RESTORE
;MACRO TO HANDLE QUEUES

; 1ST ARGUMENT IS NAME OF QUEUE
; 2ND ARGUMENT IS MAXIMUM NUMBER OF ENTRIES IN QUEUE
; 3RD ARGUMENT IF PRESENT IS NUMBER OF BYTES IN EACH ENTRY

.MACRO	QUEUE	QUE,SIZ,ESZ
	.IIF B <ESZ>,QUE'.SIZ=<SIZ+1>*2
	.IIF NB <ESZ>,QUE'.SIZ=<SIZ+1>*ESZ
QUE'.PTR:	QUE'.QUE		;QUEUE PUTTER
QUE'.TKR:	QUE'.QUE		;QUEUE TAKER
QUE'.QUE:	.BLKB	QUE'.SIZ
.ENDM	QUEUE


;MACRO TO GIVE OPER MESSAGES

.MACRO	TATTLE	ARG
	.IF NE FT.HLP
	MOV	#ARG'.MSG,LB.CTY(J)
	.ENDC
.ENDM	TATTLE


;MARO TO TRACE THINGS

.MACRO	TRACE	ARG
	Q=	FTRACE
	.IF NB ARG
		.IIF DF FT'ARG'.T, Q=	FT'ARG'.T&FTRACE
		.IIF NDF FT'ARG'.T,.PRINT ;FT'ARG'.T NOT DEFINED
	.ENDC
	.IF NE Q
	JSR	PC,TRACE.
	.ENDC
.ENDM	TRACE
;PJMP IS USED IN PLACE OF THE LAST PAIR OF INSTRUCTIONS IN A SUBROUTINE
; WHEN THEY ARE JSR PC, FOLLOWED BY RTS PC.  PJMP IS USED INSTEAD OF
; JSR PC, SO THAT SOMEONE READING THE CODE WILL UNDERSTAND THAT A
; A SUBROUTINE IS BEING CALLED.


.MACRO	PJMP	WHERE
	JMP	WHERE
.ENDM	PJMP


.MACRO	PBRNCH	WHERE
	BR	WHERE
.ENDM	PBRNCH


.MACRO	PIOFF
	MOV	PS,-(P)			;SAVE PROCESSOR LEVEL
	SPL	7			;DISABLE ALL INTERRUPTS
.ENDM	PIOFF


.MACRO	PION
	MOV	(P)+,PS			;RESTORE OLD PROCESSOR LEVEL
.ENDM	PION


.MACRO	ND	ARG1,ARG2
	.IIF NDF ARG1,ARG1=ARG2
.ENDM
;MACRO FOR BUILDING VARIOUS BLOCK STRUCTURES


.MACRO	BLOCK	TYPE
	$$$OFF=0			;START WITH ZERO OFFSET
	.MACRO ITIS A,B
		.LIST
A=B
		.NLIST
	.ENDM	ITIS
	.MACRO	X	Q,QQ
		$$$OFF=<$$$OFF+1>&177776	;EVEN OFFSET FORCED
		.IF  NB <Q>
			ITIS	TYPE'.'Q,\$$$OFF
		.ENDC
		.IF NB <QQ>
			$$$OFF=$$$OFF+<2*<QQ>>
		.IFF
			$$$OFF=$$$OFF+2
		.ENDC
	.ENDM
	.MACRO	XX	Q,QQ
		.IF NB <Q>
			ITIS	TYPE'.'Q,\$$$OFF
		.ENDC
		.IF NB <QQ>
			$$$OFF=$$$OFF+<QQ>
		.IFF
			$$$OFF=$$$OFF+1
		.ENDC
	.ENDM
.ENDM	BLOCK
;INLINE MACRO TO COUNT OCCURANCES

.MACRO	TWIDDLE	QVAL
	ND	FTWDDL,0
	.IF NE FTWDDL!DEBUG!FT.CHK
	.IF NB <QVAL>
	MOV	QVAL,#0
	.IFF
	INC	#0
	.ENDC
	FTWDDL=FTWDDL+1
	TWLAB.	\FTWDDL
	.ENDC
.ENDM	TWIDDLE

.MACRO	TWLAB.	QI
.LIST
TW.'QI=.-2
.NLIST
.ENDM	TWLAB.


;MACROS FOR CONSISTENCY CHECKING

.MACRO	CHK	X
	.IF NE FT.CHK
		ASSERT	X
	.ENDC
.ENDM	CHK


.MACRO	CNKCHK	Q	;CHECK CHUNK ADR IS PLAUSIBLE
	.IF NE FT.CHK
		ASSERT CHUNK Q
	.ENDC
.ENDM	CNKCHK
;MACROS TO SIMULATE INSTRUCTIONS FOR SIMPLE PDP11'S

.MACRO	SIMMAC
.IF LT <PDP11-30>

;MACRO TO SIMULATE SOB ON SIMPLE PDP11'S

	.MACRO	SOB	CNT,WHERE
		.IIF GT WHERE-., .ERROR	0; SOB FORWARD BRANCH ????
		.IIF NE <.-WHERE>&^C176, .ERROR	WHERE; SOB BRANCH RANGE ????
		.IF NE WHERE-.
	DEC	CNT
	BNE	WHERE
		.IFF
BRLOC=.
	DEC	CNT
	BNE	BRLOC
		.ENDC
	.ENDM	SOB

;MACRO TO DO AN XOR FOR SIMPLE PDP11'S

	.MACRO	XOR2	A02,B02,B12,B22,C02,C12,C22
	MOV	A02,C02
	BIC	B02,C12
	BIC	A02,B12
	BIS	C22,B22
	.ENDM	XOR2

	.MACRO	XOR1	A01,B01,B11,B21
		XOR2	A01,B01,B11,B21,-(SP),(SP),(SP)+
	.ENDM	XOR1

	.MACRO	XORERR	AV,BV,DB
		.IF B DB
			.ERROR	74000; XOR SOURCE ('AV') NOT A REGISTER ???
		.IFF
			.ERROR	<74000+AV*100+BV>; XOR WITH DEST DB IS NOT SUPPORTED ????
		.ENDC
	HALT
	.ENDM	XORERR

	.MACRO	XOR	A,B
	.NTYPE	QA,A
	.IF NE QA&^C7
	XORERR	\QA
	.IFF
	.NTYPE	QB,B
	QC=QB&70
	QD=QB&7
	.IF LE <QD-5>
	.IF LE <QC-10>
	XOR1	A,B,B,B
	.IFF
	.IF GE <QC-60>
	XOR1	A,B,B,B
	.IFF
	.IF EQ <QC-20>
	.IIF EQ QD,	XOR1	A,(R0),(R0),(R0)+
	.IIF EQ QD-1,	XOR1	A,(R1),(R1),(R1)+
	.IIF EQ QD-2,	XOR1	A,(R2),(R2),(R2)+
	.IIF EQ QD-3,	XOR1	A,(R3),(R3),(R3)+
	.IIF EQ QD-4,	XOR1	A,(R4),(R4),(R4)+
	.IIF EQ QD-5,	XOR1	A,(R5),(R5),(R5)+
	.IFF
	.IF EQ <QC-30>
	.IIF EQ QD,	XOR1	A,@(R0),@(R0),@(R0)+
	.IIF EQ QD-1,	XOR1	A,@(R1),@(R1),@(R1)+
	.IIF EQ QD-2,	XOR1	A,@(R2),@(R2),@(R2)+
	.IIF EQ QD-3,	XOR1	A,@(R3),@(R3),@(R3)+
	.IIF EQ QD-4,	XOR1	A,@(R4),@(R4),@(R4)+
	.IIF EQ QD-5,	XOR1	A,@(R5),@(R5),@(R5)+
	.IFF
	.IF EQ	<QC-40>
	.IIF EQ QD,	XOR1	A,-(R0),(R0),(R0)
	.IIF EQ QD-1,	XOR1	A,-(R1),(R1),(R1)
	.IIF EQ QD-2,	XOR1	A,-(R2),(R2),(R2)
	.IIF EQ QD-3,	XOR1	A,-(R3),(R3),(R3)
	.IIF EQ QD-4,	XOR1	A,-(R4),(R4),(R4)
	.IIF EQ QD-5,	XOR1	A,-(R5),(R5),(R5)
	.IFF
	.IIF EQ QD,	XOR1	A,@-(R0),@(R0),@(R0)
	.IIF EQ QD-1,	XOR1	A,@-(R1),@(R1),@(R1)
	.IIF EQ QD-2,	XOR1	A,@-(R2),@(R2),@(R2)
	.IIF EQ QD-3,	XOR1	A,@-(R3),@(R3),@(R3)
	.IIF EQ QD-4,	XOR1	A,@-(R4),@(R4),@(R4)
	.IIF EQ QD-5,	XOR1	A,@-(R5),@(R5),@(R5)
	.ENDC	;40/50
	.ENDC	;30
	.ENDC	;20
	.ENDC	;60/70
	.ENDC	;00,10
.IFF
	.IIF EQ <QB-06>,	XORERR	\QA,\QB,B
	.IIF EQ <QB-07>,	XORERR	\QA,\QB,B
	.IIF EQ <QB-16>,	XOR1	A,2(SP),2(SP),(SP)
	.IIF EQ <QB-17>,	XORERR	\QA,\QB,B
	.IIF EQ <QB-26>,	XORERR	\QA,\QB,B
	.IF EQ <QB-27>
	MOV	B,.+14
	XOR1	A,.+12,.+6,#0
	.ENDC	;27
	.IIF EQ <QB-36>,	XOR1	A,@2(SP),@2(SP),@(SP)+
	.IIF EQ <QB-37>,	XOR1	A,B,B,B
	.IIF EQ <QB-46>,	XORERR	\QA,\QB,B
	.IIF EQ <QB-47>,	XORERR	\QA,\QB,B
	.IIF EQ <QB-56>,	XORERR	\QA,\QB,B
	.IIF EQ <QB-57>,	XORERR	\QA,\QB,B
	.IIF EQ <QB-66>,	XOR1	A,2+B,2+B,B
	.IIF EQ <QB-67>,	XOR1	A,B,B,B
	.IIF EQ <QB-76>,	XORERR	\QA,\QB,B
	.IIF EQ <QB-77>,	XOR1	A,B,B,B
.ENDC
.ENDC
.ENDM	XOR
.ENDC;.IF LT <PDP11-30>


.IF LT <PDP11-45>
;MACRO TO SET PROCESSOR LEVEL
.MACRO	SPL	Q
.IF	NE	Q
	BIS	#BR7,PS	;SET PROCESSOR STATUS TO LEVEL 7
.ENDC
.IF	NE	<Q-7>
	BIC	#40*<7&<^C<Q>>>,PS	;NOW DROP TO LEVEL Q
.ENDC
.ENDM	SPL
.ENDC;.IF LT <PDP11-45>

;MACRO TO SIMULATE EXCH INSTRUCTION
;
.MACRO	EXCH	A,B
	MOV	A,-(P)	;SAVE C(A) ON THE STACK
	MOV	B,A	;PUT C(B) INTO A
	MOV	(P)+,B	;PUT ORIGINAL C(A) INTO B
.ENDM	EXCH

;MACRO TO GENERATE AN .ASCIZ STRING TERMINATED WITH .EVEN
;
.MACRO	ASCIZ	STRING
	.ASCIZ	\STRING\
	.EVEN
.ENDM	ASCIZ
.ENDM	SIMMAC
;MACRO TO PROVIDE CHK11 WITH TTY SERVICE
.MACRO	.CKTTS
;HERE TO TYPE A MESSAGE STRING
;
; CALL	JSR	PC,CKTTXT		;R0 CONTAINS ADDR OF TXT
; ON EXIT R0 POINTS TO THE EVEN LOCATION FOLLOWING THE TEXT
;
CKTTXT:	SAVE	<R1>
10$:	MOVB	(R0)+,R1		;GET THE NEXT CHARACTER
	BEQ	20$			;BRANCH IF END (NULL)
	JSR	PC,CKTCHR		;TYPE CHAR
	BR	10$			;GET NEXT CHAR
20$:	INC	R0			;
	BIC	#B0,R0			;POINT TO EVEN LOC
CKTRR1:	RESTORE	<R1>
	RTS	PC			;RETURN TO CALLER

;HERE TO TYPE A CARRIAGE RETURN AND LINE FEED
;
; CALL	JSR	PC,CKCRLF
;
CKCRLF:	JSR	R0,CKTSTR
	.ASCIZ	<15><12>
	.EVEN
	RTS	PC

;HERE TO TYPE A STRING PRECEEDED BY A CR/LF
;
; CALL	JSR	R0,CKTCRL
;	.ASCIZ	\TEXT\
;	.EVEN
;
CKTCRL:	JSR	PC,CKCRLF		;FIRST TYPE A CR/LF

;HERE TO TYPE A MESSAGE ON THE CTY
; CALL	JSR	R0,CKTSTR		;CALL TYPE ROUTINE
;	.ASCIZ \TEXT\
;	.EVEN
;
CKTSTR:	JSR	PC,CKTTXT		;GO TYPE STRING
	RTS	R0

;TYPE BLANK AND AN OCTAL NUMBER
;
;	SIMILIAR TO CKTOCT
;
CKTBOC:	SAVE	<R1>
	MOV	#040,R1
	JSR	PC,CKTCHR
	BR	CKTOC1

;HERE TO TYPE AN OCTAL NUMBER
;
; CALL	JSR	PC,CKTOCT	;WITH ARG IN R0
;
CKTOCT:	SAVE	<R1>
CKTOC1:	SAVE	<R0>
	JSR	PC,CKTOC2
CKTRR0:	RESTORE	<R0>
	BR	CKTRR1
;RECURSIVE BINARY TO ASCIC CONVERSION
CKTOC2:	SAVE	<R0>
	ROR	R0
	ROR	R0
	ROR	R0
	BIC	#160000,R0
	BEQ	20$
	JSR	PC,CKTOC2
20$:	RESTORE	<R1>
	BIC	#^C7,R1
	BIS	#60,R1

;HERE TO TYPE A SINGLE CHARACTER
;
; CALL	JSR	PC,CKTCHR	;WITH CHAR IN R1
;
CKTCHR:	CMPB	R1,#40			;DOES THIS NEED FILLER ?
	BHIS	20$
	CMPB	R1,#11			;IS CHAR A TAB (11)
	BNE	10$			;BRANCH IF NOT A TAB
	JSR	R0,CKTSTR		;GIVE SPACES FOR IT
	.BYTE	40,40,40,0		;SUBSTITUTE SPACES FOR TAB
	RTS	PC
10$:	JSR	PC,12$			;TYPE CHAR FIRST THEN PAD IT WITH 4 NULLS
12$:	JSR	PC,20$
	CLR	R1
20$:	MOVB	R1,CTOCHR		;TYPE CHAR
30$:	TSTB	CTOSTS			;TEST FOR STILL BUSY
	BPL	30$
	RTS	PC

;HERE TO GET A SINGLE CHAR FROM THE KEYBOARD
;
;	RETURN WITH CHARACTER IN R1
;
CKGCHR:	TST	CTICHR			;CLEAR BUFFER
10$:	TSTB	CTISTS			;WAIT FOR CHAR
	BPL	10$			;
	MOVB	CTICHR,R1		;
	BIC	#^C177,R1		;KEEP ONLY INTERESTING BITS
	BR	CKTCHR			;TYPE IT BACK TO HIM

.ENDM	.CKTTS
	.SBTTL	DEBUGGING MACROS - ASSERT

;	MACROS FOR CREATED LABELS
;
.MACRO SUASRT
.MACRO	C.LAB.	QQI,QQT
QQT'QQI'$:
.ENDM	C.LAB.
.MACRO C..LAB	QI
	.IIF LT CL.TAG,C.LAB.	\.CLAB.,CL
	.IIF GE CL.TAG,C.LAB.	\.CLAB.,\CL.TAG
	.IIF NB <QI>,QI=.CLAB.
	.CLAB.=.CLAB.+1
.ENDM	C..LAB
.CLAB.=1
	ND	CL.TAG,1
;
;
;	MACRO FOR MAKING BRANCHS TO CREATED LABELS
;
.MACRO	CLBR	QINDX,QCOND,QTAG
	.IF NB QTAG
	.IIF B <QCOND>,BR	QTAG'QINDX'$
	.IIF NB <QCOND>,B'QCOND	QTAG'QINDX'$
	.IFF
	.IIF LT CL.TAG,CLBR	QINDX,QCOND,CL
	.IIF GE CL.TAG,CLBR	QINDX,QCOND,\CL.TAG
	.ENDC
.ENDM	CLBR
;
;
.MACRO	SET.CD	QCD
	S.....=S..'QCD
.ENDM	SET.CD
;
S.....=0
;

.IF NE FTASRT
	;
	;
	.MACRO	ASSERT	FRST,SCND,THRD,FRTH
	.IF NB <FRTH>
	.IF IDN <THRD>,<IN>
	.IF IDN <SCND>,<CLEAR>
	BIT	FRST,FRTH
	BEQ	.+4
	TRAP	S.....
	.IFF
	.IF IDN <SCND>,<SET>
	MOV	FRTH,-(P)
	COM	(P)
	ASSERT	(P)+ CLEAR IN FRST
	.ENDC
	.ENDC
	.IFF
	CMP	FRST,THRD
	CLBR	\.CLAB.,LO
	CMP	FRST,FRTH
	BLOS	.+4
	C..LAB
	TRAP	S.....
	.ENDC
	.IFF
	.IF NB <THRD>
	CMP	FRST,THRD
	B'SCND	.+4
	TRAP	S.....
	.IFF
	.IF IDN <FRST>,<CHUNK>
	SET.CD	CNK
	ASSERT	#CNKSIZ-1 CLEAR IN SCND
	.IFF
	.IIF NB <SCND>,	TST	SCND
	B'FRST	.+4
	TRAP	S.....
	.ENDC
	.ENDC
	.ENDC
	S.....=0
	.ENDM	ASSERT
.IFF
	.MACRO ASSERT FRST,SCND,THRD,FRTH
	.ENDM ASSERT
.ENDC
; TO USE ASSERT MACRO
; TO ENFORCE A RANGE OF VALUES
;	ASSERT THING BETWEEN VALUE1 VALUE2
;
; TO ENFORCE BITS CLEARED
;	ASSERT BITS CLEAR IN THING
;
; TO ENFORCE BITS SET
;	ASSERT BITS SET IN THING
;*** IN THIS CASE THING MAY NOT HAVE A R6 (STACK) TYPE MODIFICATION
;*** IE, ON(SP) OR (SP)+ ETC
;
; TO ENFORCE  CONDITION
;	ASSERT  VALUE1 CONDITION VALUE2
; OR	ASSERT CONDITION VALUE
; OR
;	ASSERT CONDITION
;*** IN THIS CASE CONDITION MAY BE ANY BRANCH CONDITION
;
; TO ENFORCE LINK TO CHUNK BOUNDARY
;	ASSERT CHUNK VALUE
.ENDM
	.SBTTL	DEBUGGING MACROS - CPU POKER
;
;
;	DEFINE THE CPU POKER QUEUE
;

.MACRO	MCPQUE
	ND	CP.SIZ,0	;DEFAULT IS NO RANDOM POKE
	.IF NE CP.SIZ
	CP.SIZ=<CP.SIZ+37>&177740
	CP.PTR:	.WORD	CP.QUE
	CP.QUE:	.BLKB	CP.SIZ
;
;	DO THE CPU POKE
;
;	LEAVE TRACE OF ACTIVITY

	CPUQUE:	SAVE	<R1,R0>
	MOV	P,R1
	MOV	CP.PTR,R0
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	R2,(R0)+
	MOV	R3,(R0)+
	MOV	R4,(R0)+
	MOV	J,(R0)+
	TST	(R1)+
	MOV	R1,(R0)+
	MOV	PS,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	CMP	R0,#CP.QUE+CP.SIZ
	BLO	.+6
	MOV	#CP.QUE,R0
	MOV	R0,CP.PTR
	RESTORE <R0,R1>
	RTS	PC
	.ENDC
.ENDM	MCPQUE



.MACRO	CCPQUE
	ND	CP.SIZ,0	;DEFAULT IS NO RANDOM POKE
	.IF NE CP.SIZ
	CP.SIZ=<CP.SIZ+37>&177740
	JSR	PC,CPUQUE
	.ENDC
.ENDM	CCPQUE
	.SBTTL	DEBUGGING MACROS - PROFILER


;	ACTIVITY PROFILER

.MACRO	PROFILE	Q,QQ
	ND	FT.PFL,0
	.IF NE FT.PFL
	ND	PRFL.S,10
	ND	PRFL.H,60000
	ND	PRFL.L,1000
	Z=PRFL.H-PRFL.L
	ZZ=PRFL.S
	.IF LT	Z
	Z=<<Z&77777>/2>!40000
	ZZ=ZZ-1
	.ENDC
	.REPT	ZZ
	Z=Z/2
	.ENDR
	PRFL.Z=1
	.REPT	20
	.IIF NE Z,PRFL.Z=PRFL.Z*2
	.IIF NE Z,Z=Z/2
	.ENDR
	.IF B Q
	MOV	R0,-(P)
	.IIF NB <QQ>,MOV	QQ+2(P),R0
	.IIF B <QQ>,MOV	2(P),R0
	CMP	R0,#PRFL.H
	BHIS	120$
	SUB	#PRFL.L,R0
	BLO	120$
	CLC
	ROR	R0
	.REPT	PRFL.S
	ASR	R0
	.ENDR
	ASL	R0
	INC	PRFL.B(R0)
	120$:	MOV	(P)+,R0
	.IFF
	.IIF IDN <Q>,<BLOCK>,PRFL.B:	.BLKW	PRFL.Z
	.ENDC
	.ENDC
.ENDM	PROFILE

;PRFL.H=HIGH ADR
;PRFL.L=LOW ADR
;PRFL.S=N	;2**N IS INTERVAL

;IS USED TO SET UP PROFILER (INTERVAL IS 2**N)

;PROFILE
;IS USED AT CLOCK OR OTHER INTERRUPT TO DO THE WORK

;PROFILE	BLOCK
;IS USED TO SET UP THE PROFILE BUFFER
	.SBTTL	DEBUGGING MACROS - SINK
;
;
.IIF NDF FT.SNK,FT.SNK=0	;DON'T INCLUDE DATA SINK CODE
.IIF NDF FT.SOU,FT.SOU=0	;DON'T INCLUDE DATA SOURCE CODE
;
;USED TO CONDITIONALLY QUEUE CHUNKS (MSGS) TO SYNCHRONOUS GARBAGE COLLECTOR
;	IE., SINK J <#LBLK0,#LBLK1>
;	SINKS MSGS FOR LINES 0,1 ONLY
;
;	THE THIRD ARGUMENT IS WHERE TO CONTINUE WHEN DONE QUEUEING THE MSG
;	IF THIS ARG IS 'COPY', THE NEXT INTSRUCTION IN SEQ IS EXECUTED
;	AND A COPY (NOT THE ORIGINAL) IS QUEUED
;	IF THE ARG IS NULL, THE MACRO EXITS WITH A 'RTS	PC'
;
;SINK	STORE
;	IS USED TO DEFINE THE SINK QUEUE AND DUMP BUFFER
;
;
;SINK TTYDDB
;	IS USED TO DIRECT THE SINK DUMP TO A TTY
;
;
.IF NE FT.SNK
.MACRO	SINK	QJ,QQ,QC
.IF NB	<QQ>
	SINK00	QJ,<QQ>,QC
.IFF
.IF NB <QJ>
.IF IDN <QJ>,<STORE>
	SINK01
	SINK02
	SINK03
.IFF
	SINK10	QJ
.ENDC
.IFF
	SINK00	,,QC
.ENDC
.ENDC
.ENDM	SINK
.IFF
.MACRO	SINK	QJ,QQ,QC
.ENDM	SINK
.ENDC
;
;
.IF NE FT.SNK
.MACRO	SINK00	QJ,QQ,QC
.IF NB <QJ>
	.IRP	Q,<QQ>
	CMP	QJ,#Q
	CLBR	\.CLAB.,EQ
	.ENDM
	CLBR	\<.CLAB.+1>
	C..LAB
	INC	#0	;COUNT SINKS
.ENDC
.IF NB <QC>
	.IF IDN <QC>,<COPY>
	JSR	PC,CSNKIT
	.IFF
	JSR	PC,SINKIT
	BR	QC
	.ENDC
.IFF
	JMP	SINKIT
.ENDC
	C..LAB
.ENDM	SINK00
;
;
.MACRO	SINK01
SINK.Q:	.WORD	0	;SINK QUEUE HEAD
SINK.T:	.WORD	0	;SINK QUEUE TAIL
SINK.C:	.WORD	0	;SINK QUEUE LENGTH
SINK.0:	.WORD	0	;LAST DUMPED
SINK.S=^D234	;MAX LINE LENGTH
SINK.B:
	.REPT	SINK.S	; THE LINE BUFFER
	.BYTE	0
	.ENDR
	.WORD	0	;EXTRA WORD
.ENDM	SINK01
;
;
.MACRO	SINK02
CSNKIT:	SAVE <R0,R1,R2>
	MOV	R0,R1
	JSR	PC,ERSGET
	SAVE	<R0>
CSNK.T:	MOV	#CNKSIZ/2,R2
	MOV	(R1)+,(R0)+
	SOB	R2,.-2
	SUB	#CNKSIZ,R0
	SUB	#CNKSIZ,R1
	MOV	R0,R2
	MOV	(R1),R1
	BEQ	.+12
	JSR	PC,ERSGET
	MOV	R0,(R2)
	BR	CSNK.T
	RESTORE	<R0,R2,R1>
	JSR	PC,SINKIT
	RESTORE	<R0>
	RTS	PC

SINKIT:
	PIOFF	;SO SINK WORKS EVERYWHERE
	TST	SINK.C
	BLE	10$
	ADD	#CN.MLK,SINK.T
	MOV	R0,@SINK.T
	BR	15$
10$:	MOV	R0,SINK.Q
15$:	MOV	R0,SINK.T
	CLR	CN.MLK(R0)
	INC	SINK.C
	PION
	RTS	PC
.ENDM	SINK02
;
;
.MACRO	SINK03
	;CONVERT BYTE TO OCTAL AND INSERT IN BUFFER
OCT3:	JSR	PC,(PC)	;DO THIS TWICE
10$:	MOVB	(R0)+,R3
	BIC	#^C377,R3	;CLEAR SIGN EXTENSION
	MOV	#4,R2	;SET FIELD LENGTH
	BR	IN2OCT	;AND CONVERT
;
;
	;CONVERT WORD TO OCTAL AND INSERT IN THE BUFFER
OCT6:	MOV	(R0)+,R3
	MOV	#10,R2
;	BR	IN2OCT	; CONVERT
;
;
	;CONVERT TO OCTAL AND INSERT IN THE BUFFER
	;R2 IS FEILD LENGTH
	;R3 IS VALUE
	;ON RETURN R2 IS UNDEFINED VALUE, AND R3 IS UNCHANGED
IN2OCT:	MOV	R3,-(P)	;SAVE THE VALUE
	DEC	R2	;COUNT THIS DIGIT
	CLC	;CLEAR CARRY FOR
	ROR	R3	;LOGICAL RIGHT SHIFT
	ASR	R3
	ASR	R3
	BEQ	I2O.1
	JSR	PC,IN2OCT	;RECURSE IF MORE DIGITS
I2O.1:	DEC	R2	;FILL WITH BLANKS
	BMI	I2O.2
	MOVB	#40,(R4)+
	BR	I2O.1
I2O.2:	MOV	(P),R3	;RESTORE PREVIOUS VALUE
	BIC	#^C7,(P)	;CONVERT DIGIT TO ASCII
	BIS	#60,(P)
	MOVB	(P)+,(R4)+	;AND INSERT
	RTS	PC
;
;
	;CONVERT BYTE TO ASCII AND INSERT IN BUFFER
	;_ PREFIX IMPLIES >200
	;^ PREFIX IMPLIES BITS 5 AND 6 =0
ASC3:	MOVB	#40,R2
	JSR	PC,10$	;DO THIS TWICE
10$:	MOVB	R2,(R4)+
	MOVB	R2,(R4)
	MOVB	(R0)+,R3
	BPL	12$
	MOVB	#137,(R4)
	BIC	#^C177,R3
12$:	INC	R4
	MOVB	R2,(R4)
	CMPB	R3,R2
	BHIS	14$
	MOVB	#136,(R4)
	BIS	#100,R3
14$:	INC	R4
	MOVB	R3,(R4)+
	RTS	PC
;
;
;
	;DEQUEUE THE SUNK MSGS
;
DQSINK:	MOV	SINK.0,R0
	BNE	05$
	TST	SINK.C
	BGT	.+4
	RTS	PC
	PIOFF	;MUST INHIBIT INTERRUPTS TO DEQUEUE
	MOV	SINK.Q,R0
	MOV	CN.MLK(R0),SINK.Q
	DEC	SINK.C
	PION
	MOV	R0,SINK.0
05$:	MOV	R0,R1
	MOV	#SINK.B,R4
	CLR	-(P)
10$:	MOV	#40,(P)
	ADD	#20,R1
20$:	MOV	R1,SINK.0
	BIT	#CNKSIZ-1,R1	;IF LAST LOAD DUMP IT
	BEQ	29$
	MOV	R0,R2
	MOV	#10,R3
30$:	CMP	(R0)+,(R1)+
	BEQ	31$
	MOV	R2,R0
	BR	29$
31$:	SOB	R3,30$
	MOV	#52,(P)
	MOV	R2,R0
	BR	20$
29$:	MOV	R0,R3
	BIT	#CNKSIZ-1,R0
	BNE	.+6	;EXTRA LINE FEED IF NEW BLOCK (CHUNK)
	MOV	#15*400+12,(R4)+
	MOV	#6,R2	;CONVERT AND OUTPUT ADDRESS
	JSR	PC,IN2OCT
	MOVB	(P)+,(R4)+
	MOV	R0,-(P)
	MOV	#OCT6,-(P)
WOFMT:	JSR	PC,SNKFMT
	MOV	#OCT3,(P)
BOFMT:	JSR	PC,SNKFMT
	MOV	#ASC3,(P)
BAFMT:	JSR	PC,SNKFMT
	CMP	(P)+,(P)+
	CLRB	(R4)+
	MOV	SINK.0,R0
	BIT	#CNKSIZ-1,R0
	BNE	07$
	SUB	#CNKSIZ,R0
	MOV	(R0),SINK.0
	CLR	(R0)
	JSR	PC,FRECKS
	CLZ
07$:	RTS	PC
;
;
	;DO FORMATED OUTPUT OF Q WORD FOR SINK
SNKFMT:	CMPB	-1(R4),#12	;BETTER INSERT FILL FOR EXTRA LINES
	BNE	20$
	MOV	#7,R1
10$:	MOVB	#40,(R4)+
	SOB	R1,10$
20$:	MOV	4(SP),R0
	MOV	#10,R1	;FORMAT THE NEXT 8 WORDS
30$:	JSR	PC,@2(SP)
	SOB	R1,30$
	MOVB	#15,(R4)+
	MOVB	#12,(R4)+
NULFMT:	RTS	PC
.ENDM	SINK03
;
;
.MACRO	SINK09	QJ
	MOV	#'QJ,J
	BIT	#DS.ACT,(J)	;GOT TO WAIT  TILL TTY IS NOT BUSY
	BNE	.+22
	JSR	PC,DQSINK	;GET THE NEXT BUFFER LOAD FROM THE SINK
	BEQ	.+14
	MOV	#SINK.B,DB.STR(J)
	JSR	PC,BEGXMT	;IF THERE IS ONE START IT TYPING
.ENDM	SINK09
;
;
.MACRO	SINK10	QJ
.IF EQ LPTSNK
	SINK09	QJ
.IFF
	MOV	SINK.0,J
	BIS	SINK.C,J
	BEQ	126$	;NOTHING TO DUMP
	MOV	#'QJ,J
	MOV	DB.HDW(J),R3
	;STEAL THE LINE PRINTER
	BIC	#100,(R3)
	CLR	DB.TIM(J)
120$:	BIT	#100200,(R3)
	BLE	126$	;JUST WAITING OUR TURN
121$:	MOV	#0,R4
	BNE	122$	;IF WE HAVE A BUFFER, JUST FEED THE PRINTER
	SAVE	<R3>
	JSR	PC,DQSINK	;GET A BUFFER
	BEQ	125$	;WASN'T ANY, SO GIVE THE PRINTER BACK
	RESTORE	<R3>
	MOV	#SINK.B,R4
	MOV	R4,121$+2
122$:	INC	121$+2
	CMPB	(R4),#12	;IF <LF>, MAY WANT TO CHANGE IT TO <FF>
	BNE	124$
123$:	DEC	#0
	BPL	124$
	MOV	#77,123$+2
	MOVB	#14,(R4)
124$:	MOVB	(R4),2(R3)
	BR	121$
125$:	RESTORE	<R3>
	MOVB	#-3,DB.TIM(J)
	BIS	#100,(R3)
126$:
.ENDC
.ENDM	SINK10
.ENDC
;
;CLRCNK	ZEROS OUT A CHUNK
;
.MACRO	CLRCNK	QREG
.IF NE FT.SNK!FT.SOU
	MOV	#CNKSIZ/2,-(P)
	CLR	(QREG)+
	DEC	(P)
	BNE	.-4
	TST	(P)+
	SUB	#CNKSIZ,QREG
.IFF
	CLR	(QREG)
	CLR	2(QREG)
.ENDC
.ENDM	CLRCNK
	.SBTTL	DEBUGGING MACROS - SOURCE
;
;
;SOURCE	N,I,L,M,P
;
;WILL ORIGINATE N MSGS WITH A DELAY OF I SECONDS BETWEEN THEM
;OVER LINE (SCB) (RDE DEV) L
;THE MSG IS AT M
;AND THE PROCEDURE P IS CALLED TO SEND IT
;
.IIF NE FT.SOU,SOULAB=0
;
.MACRO	SOURCE	QN,QI,QL,QM,QP
.IF NE FT.SOU
	C.LAB.	\SOULAB,SOU
SOULAB=SOULAB+1
	TST	#'QN
100$:	BEQ	103$
	DEC	#'QI
101$:	BNE	103$
	MOV	#'QI,101$-2
	DEC	100$-2
.IIF NB	<QM>,	MOV	#'QM,R4
.IIF B <QM>,	MOV	#SOU.M,R4
	JSR	PC,ERSGET
	MOV	R0,-(P)
	MOV	(R4),R1
	ADD	#CN.NCT-CN.LEN,R1
	INC	R1
	ASR	R1
	CMP	(R0)+,(R0)+
102$:	MOV	(R4)+,(R0)+
	ADVCNK	R0 EXTEND
	SOB	R1,102$
	MOV	(P)+,R0
.IF IDN	<QP>,<DDQDAT>
	MOV	#'QL,SB
.IFF
.IF IDN <QP>,<DDQBOO>
	MOV	#'QL,SB
.IFF
	MOV	#'QL,J
	MOV	#SOH,R2
.ENDC
.ENDC
.IIF B <QP>,	JSR	PC,DDQ.01
.IIF NB <QP>,	JSR	PC,QP
103$:
.ENDC
.ENDM	SOURCE
;
;
;SOUMSG	LAB,LEN,DDB,SCB,DDC,CNT,NCN,DATA
;
;DEFINES A DATA MESSAGE FOR THE SOURCE MACRO
;LAB IS THE MSG NAME
;THE OTHER ARGS ARE THE HEADER WORDS
;
;DATA IS <D,D,...>	WHERE D IS
;BYTE VALUE, <LENGTH,VALUE>
;IF LENGTH =1 VALUE IS BYTE
;IF LENGTH =2 VALUE IS WORD
;IF LENGTH >2 VALUE IS BYTE,BYTE+1,... WITH WRAPAROUND AT =177
;
.MACRO	SOUMSG	QLAB,QLEN,QDDB,QSCB,QDDC,QCNT,QNCN,QDAT
.IF NE FT.SOU
.IIF B <QLAB>,SOU.M:
.IIF NB <QLAB>,QLAB':
	.WORD	QLEN,0
	.WORD	QDDB,QSCB,QDDC,QCNT,QNCN,0
	.MACRO	X	QQA,QQB
	.IF B <QQB>
	.BYTE	QQA
	.IFF
	.IIF EQ QQA-1,	.BYTE	QQB
	.IF EQ QQA-2
	.EVEN
	.WORD	QQB
	.ENDC
	.IF GT QQA-2
	Z=QQB
	.REPT	QQA
	.BYTE	Z
	Z=Z+1
	.IIF GE Z-177,Z=QQB
	.ENDR
	.ENDC
	.ENDC
	.ENDM
	.IRP	QQC,<QDAT>
	X	QQC
	.ENDM
	.EVEN
.ENDC
.ENDM	SOUMSG
;
;
	.SBTTL	QUEUE ACCESS AND CHUNK HANDLING MACROS



;
;
.MACRO	ADVCNK	QREG,QFUN
.IF B QFUN
	.IF IDN QREG,SB
	BIT	#CNKSIZ-1,SB
	BNE	1$
	MOV	-CNKSIZ(SB),SB
	TST	(SB)+
1$:
	.IFF
	JSR	PC,AVCK'QREG
	.ENDC
.IFF
	.IF IDN <QFUN>,<EXTEND>
	JSR	PC,GTCK'QREG
	.IFF
	.IF IDN <QFUN>,<FREE>
	JSR	PC,FRCK'QREG
	.IFF
.ERROR	227;	ADVCNK	QREG QFUN	?????
	.ENDC
	.ENDC
.ENDC
.ENDM	ADVCNK
;TO FETCH AN ENTRY FROM THE QUEUES


.MACRO	QUEGET	QQUE,QFAIL
	.IF IDN <QQUE>,<TI>
	MOV	TI.TKR,R1
	CMP	R1,TI.PTR
	BEQ	QFAIL
	CMP	R1,#<TI.QUE+TI.SIZ>
	BLO	.+6
	MOV	#TI.QUE,R1
	MOVB	(R1)+,R0
	BIC	#^C<377>,R0
	MOVB	(R1)+,J
	BIC	#^C<377>,J
	ASL	J
	MOV	DLATAB-2(J),J
	MOV	R1,TI.TKR
	.IFF
	.MACRO	Q..GET	QREG,QFLAG
	CMP	QQUE'.TKR,QQUE'.PTR
	BEQ	QFAIL
	PIOFF
	CMP	QQUE'.TKR,#<QQUE'.QUE+QQUE'.SIZ>
	BLO	.+10
	MOV	#QQUE'.QUE,QQUE'.TKR
	MOV	@QQUE'.TKR,QREG
	ADD	#2,QQUE'.TKR
	BIC	#QFLAG,(QREG)
	PION
	.ENDM	Q..GET
	.IIF IDN <QQUE>,<NC>,	Q..GET	SB,SBF.NQ
	.IIF IDN <QQUE>,<DV>,	Q..GET	J,DS.QUE
	.IIF IDN <QQUE>,<QO>,	Q..GET	J,LS..XQ
	.IIF IDN <QQUE>,<QI>,	Q..GET	J,LS..RQ
	.ENDC
.ENDM	QUEGET
;TO INSERT AN ENTRY ON THE QUEUES


.MACRO	QUEPUT	QQUE,QPROC
	.IF IDN <QQUE>,<TI>
	MOV	TI.PTR,R0
	CMP	R0,#<TI.QUE+TI.SIZ>
	BLO	.+6
	MOV	#TI.QUE,R0
	MOVB	R1,(R0)+
	MOV	DB.OLA(J),R1
	ASR	R1
	MOVB	R1,(R0)+
	CMP	R0,TI.TKR
	BEQ	.+6
	MOV	R0,TI.PTR
	.IFF
	.MACRO	Q..PUT	QREG,QFLAG,QQFAIL
	.IIF IDN <QPROC>,<CODE>,QQUE'.PUT:
	PIOFF
	BIT	#QFLAG,(QREG)
	BNE	QQFAIL
	BIS	#QFLAG,(QREG)
	CMP	QQUE'.PTR,#<QQUE'.QUE+QQUE'.SIZ>
	BLO	.+10
	MOV	#QQUE'.QUE,QQUE'.PTR
	MOV	QREG,@QQUE'.PTR
	ADD	#2,QQUE'.PTR
QQFAIL:	PION
	.IIF IDN <QPROC>,<CODE>	RTS PC
	.ENDM	Q..PUT
	.IIF IDN <QQUE>,<NC>	Q..PUT	SB,SBF.NQ,QPROC
	.IF IDN <QQUE>,<QO>
	.IF IDN <QPROC>,<CODE>
	Q..PUT	J,LS..XQ,10$
	.IFF
	JSR	PC,QO.PUT
	.ENDC
	.ENDC
	.IF IDN <QQUE>,<QI>
	.IF IDN <QPROC>,<CODE>
	Q..PUT	J,LS..RQ,10$
	.IFF
	JSR	PC,QI.PUT
	.ENDC
	.ENDC
	.IIF IDN <QQUE>,<DV>	Q..PUT	J,DS.QUE,QPROC
	.ENDC
.ENDM	QUEPUT
; MACRO TO DO INDEXED BRANCH
;
;	NEEDS SCRATCH AC

.MACRO	JINDEX	TYP,INDEX,AC,TABLAB
.IIF DIF <INDEX>,<AC>,	MOVB	INDEX,AC
	.IIF IDN <TYP>,<JSR>,JSR PC,@TABLAB(AC)
	.IIF IDN <TYP>,<JMP>,JMP @TABLAB(AC)
.ENDM
	.SBTTL	DDCMP HEADER DEBUGGING LOG
.IF DF DMPHDR

.IIF NDF DMPHIN,DMPHIN=DMPHDR	;NUMBER OF INPUT HEADERS TO COLLECT
.IIF NDF DMPHOU,DMPHOU=0	;NUMBER OF OUTPUT HEADERS TO COLLECT
.IIF NDF DMPHLN,DMPHLN=LBLK0	;LINE TO MONITOR

.MACRO	HDRDMP	QIO,QLINE,QN

.IF IDN <QIO>,<STORE>

ICHK.B:	.BLKW	DMPHDR*4
ICHK.E:	.WORD	ICHK.B

.IFF

	CMP	J,#QLINE
QIO'CHK.L=.-2
	BNE	104$
	TST	#QN
QIO'CHK.C=.-2
	BEQ	104$
.IIF IDN <QIO>,<O>,	SAVE	<R1>
	MOV	ICHK.E,R1
	CMP	#ICHK.E,R1
	BHI	102$
	MOV	#ICHK.B,R1
102$:
.IF IDN <QIO>,<O>
	SUB	#10,R0
.IFF
	ADD	J,R0
.ENDC
	MOV	(R0)+,(R1)+
	MOV	(R0)+,(R1)+
	MOV	(R0)+,(R1)+
	MOV	(R0)+,(R1)+
	DEC	QIO'CHK.C
	BNE	103$
	MOV	#ICHK.B,R1
103$:	MOV	R1,ICHK.E
.IF IDN <QIO>,<O>
	RESTORE	<R1>
.IFF
	MOV	LB.ITK(J),R0
.ENDC
104$:
.ENDC	;.IF IDN <QIO>,<STORE>
.ENDM	HDRDMP
.IFF

DMPHIN=0
DMPHOU=0
DMPHLN=0

.MACRO	HDRDMP	QIO,QLINE,QN
.ENDM	HDRDMP
.ENDC	;.IF DF DMPHDR
	.SBTTL	SYNCHRONOUS LINE DEBUGGING MACROS


.IF DF SLSDMP
SLINDX=0	;MACRO CALL INDEX
.IIF LT SLSDMP-100,SLSDMP=100

.MACRO	DMPSLS	STORE

SLRCT:	.WORD	SLSDMP
SLRBF:	.BLKW	SLSDMP
SLRBE:	.WORD	SLRBF

SLXCT:	.WORD	SLSDMP
SLXBF:	.BLKW	SLSDMP
SLXBE:	.WORD	SLXBF

	SSSSQU	SLR
	SSSSQU	SLX
.ENDM	DMPSLS

.MACRO	SLX	QQA
	SLRX	SLX,QQA,\SLINDX
	SLINDX=SLINDX+1
.ENDM	SLX
.MACRO	SLR	QQA
	SLRX	SLR,QQA,\SLINDX
	SLINDX=SLINDX+1
.ENDM	SLR
.MACRO	SLRX	SQQ,QA,QB
	MOV	#SL..'QB,-(P)
	MOV	QA,-(P)
	JMP	SQQ'SPC
SL..'QB':
.ENDM	SLRX
.MACRO	SSSSQU	SQQ
SQQ'SPC:TST	SQQ'CT
	BEQ	SQQ'QB
	DEC	SQQ'CT
	CMP	SQQ'BE,#SQQ'BE
	BLO	.+10
	MOV	#SQQ'BF,SQQ'BE
	MOV	(P)+,@SQQ'BE
	ADD	#2,SQQ'BE
	RTS	PC
SQQ'QB:	TST	(P)+
	RTS	PC
.ENDM	SSSSQU

.IFF
.MACRO	DMPSLS	STORE
.ENDM	DMPSLS
.MACRO	SLR	QQA
.ENDM	SLR
.MACRO	SLX	QQA
.ENDM	SLX

.ENDC	;.IF DF SLSDMP
	.SBTTL	MSGDMP DEBUGGING MACRO
;	CODE BY	LAD	10/75


.IF DF DMPMSG
DMPMSG=0
.MACRO	D$M	QTAG,QINDX,QOP
.IF B <QOP>
	QTAG'QINDX=.-2
.IFF
	.IF IDN <QOP>,<LOAD>
	MOV	QTAG'QINDX,R0
	.IFF
	.IF IDN <QOP>,<STORE>
	MOV	R0,QTAG'QINDX
	.IFF
	QOP	QTAG'QINDX
	.ENDC
	.ENDC
.ENDC
.ENDM	D$M
.MACRO	MSGDMP	QQN,QQW,QQB
.IF NE FT.SNK
.IIF NB <QQW>,	CMP	#'QQW,J
.IIF B <QQW>,	CMP	#0,J
	D$M	MD.B,\DMPMSG	;DEFINE	MD.B??=.-2
	BNE	79$
.IIF NB <QQN>,	TST	#'QQN
.IIF B <QQN>,	TST	#0
	D$M	MD.C,\DMPMSG	;DEFINE	MD.C??=.-2
	BEQ	79$
	SAVE	<R0>
	D$M	MD.S,\DMPMSG,TST	;	TST	MD.S??
	BNE	69$
	JSR	PC,ERSGET
	BEQ	78$
	CMP	(R0)+,(R0)+
	BR	68$
69$:
	MOV	#0,R0	;	MOV	MD.S??,R0
	D$M	MD.S,\DMPMSG	;DEFINE	MD.S??=.-2
	BEQ	78$
68$:
.IF IDN <QQB>,<R0>
	MOVB	(P),(R0)+
.IFF
.IF NB <QQB>
	MOVB	QQB,(R0)+
.IFF
	MOVB	R1,(R0)+
.ENDC
.ENDC
	D$M	MD.S,\DMPMSG,STORE	;	MOV	R0,MD.S??
	BIT	#CNKSIZ-1,R0
	BNE	78$
	SUB	#CNKSIZ,R0
	JSR	PC,SINKIT
	D$M	MD.S,\DMPMSG,CLR	;	CLR	MD.S??
	D$M	MD.C,\DMPMSG,DEC	;	DEC	MD.C??
78$:
	RESTORE	<R0>
79$:
.ENDC
	DMPMSG=DMPMSG+1
.ENDM	MSGDMP
.IFF
.MACRO	MSGDMP	QQN,QQW,QQB
.ENDM	MSGDMP
.ENDC	;.IF DF DMPMSG
	.SBTTL	EXECUTION TRACE DEBUGGING MACROS
.MACRO NULL ARG
.IF NE,DEBUG
.IF NB,<ARG>
 .MACRO NULLBL
NUL...=.-ARG
	NULL..	ARG,\NUL...
 .ENDM NULLBL
.IFF;.IF NB,<ARG>
	NULLBL
.ENDC;.IF NB,<ARG>
.IF NE,FTETR
	JSR	PC,ETRACE
.ENDC;.IF NE,FTETR
.ENDC;.IF NE,DEBUG
.ENDM NULL

.MACRO NULL.. ADR,DISP
	.LIST
;ADR+DISP
	.NLIST
.ENDM NULL..

.MACRO	ETRACE	NUMENT
ETRACE:	PIOFF
	TST	ETRFLG
	BPL	100$
	SAVE	R0
	MOV	4(SP),R0
	SUB	#4,R0
	MOV	R0,@EPNT
	ADD	#2,EPNT
	CMP	EPNT,#EBUFE
	BLO	10$
	MOV	#EBUF,EPNT
	BIT	#40000,ETRFLG
	BEQ	10$
	BIC	#100000,ETRFLG
10$:	RESTORE	R0
100$:
	PION
.IF DF,ETRSUB
	PJMP	ETRSUB		;subroutine to execute on trace
.IFF;.IF DF,ETRSUB
	RTS	PC
.ENDC;.IF DF,ETRSUB

ETRON:	BIS	#100000,ETRFLG
	RTS	PC

ETROFF:	BIC	#100000,ETRFLG
	RTS	PC

ETRFLG:	.WORD	100000
EPNT:	.WORD	EBUF
EBUF:	.BLKW	NUMENT
EBUFE=.
.ENDM ETRACE
	.SBTTL	NCL TRACE MACRO

.IIF NDF NCL.LG,NCL.LG=0
.IF NE NCL.LG
.MACRO	NCLLOG	LOGSIZ
.IF NB <LOGSIZ>
  .IF IDN <LOGSIZ>,<ALL>
	.IIF NE NCL.LG&1,	JSR	PC,NCLLOG	;LOG ALL ROUTED MSGS
  .IFF
    .IF IDN <LOGSIZ>,<DATA>
	.IIF NE NCL.LG&2,	JSR	PC,NCLLOG	;LOG DATA MSGS FOR US
    .IFF
BUGBF:
	.REPT	LOGSIZ*24
	.WORD	0
	.ENDR
BUGQ:	.WORD	BUGBF
    .ENDC ;.IF IDN <LOGSIZ>,<DATA>
  .ENDC ; .IF IDN <LOGSIZ>,ALL
.IFF
;
	; SAVE 1ST WORDS OF MSG, AND TOP OF STACK
NCLLOG:
	MOV	R2,-(P)
	MOV	P,R2
	TST	(R2)+
	MOV	R3,-(P)
	MOV	BUGQ,R3
	CMP	R3,#BUGQ-23
	BLO	2$
	MOV	#BUGBF,R3
2$:	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	R0,R2
	CMP	(R2)+,(R2)+
	MOV	(R2)+,(R3)+
	ADD	#CN.NCT-6,R2
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	R3,BUGQ
	MOV	(P)+,R3
	MOV	(P)+,R2
	RTS	PC
.ENDC	;.IF NB <NCLSIZ>
.ENDM	NCLLOG
.IFF
.MACRO	NCLLOG	LOGSIZ
.ENDM	NCLLOG
.ENDC	;.IF NE NCL.LG
	.SBTTL	CONFIG MACRO

.MACRO	confg	OPT,PDP,IFDL1,IFDT2,DV,NLN,CTY,IFDH,IFDZ,NCR,NLP,NLP2,NPR,NPP,NPL,IFKG,TITLE
.IIF NDF FT.'OPT,FT.'OPT=0
.IF NE FT.'OPT
	.TITLE	TITLE

	.IF EQ PASS-1			; ONLY ON PASS 1

	.IIF NDF FTDL10,FTDL10=IFDL1	;IF NONZERO WE HAVE A DL10
	.IIF NDF FT.DTE,FT.DTE=IFDT2	;IF NONZERO WE HAVE A DTE20
	DV'OP=NLN			;DEFAULT TYPE & NUMBER OF LINES
	.IIF NDF FT.CTY,FT.CTY=CTY	;IF NONZERO HANDLE CTY AS TTY
	.IIF NDF FTDH11,FTDH11=IFDH	;IF NONZERO WE HAVE DH11(S)
	.IIF NDF FTDZ11,FTDZ11=IFDZ	;IF NONZERO WE HAVE DZ11(S)
	.IF DF TTYN
	    .IF GT TTYN
		.IF EQ FTDH11!FTDZ11
		    FTDZ11=1		;DEFAULT DZ11 IF TTYN SET
		.ENDC
	    .ENDC
	.ENDC
	.IIF NDF,FTKG11,FTKG11=IFKG	;WHETHER OR NOT WE NEED KG11
	.IIF NDF CDRN,CDRN=NCR		;NUMBER OF CARD READERS
	.IIF NDF LP11N,LP11N=NLP	;NUMBER OF LINE PRINTERS
	.IIF NDF LP20N,LP20N=NLP2	;NUMBER OF LP20 LINE PRINTERS
	.IF NDF LPTN			;IF USER GAVE ONLY LP11N AND LP20N
	LPTN=LP11N+LP20N		;SET NUMBER OF LINE PRINTERS
	.IFF;.IF NDF,LPTN
	  .IF NE,<LPTN-<LP11N+LP20N>>	;IF LPTN IS NOT THE SUM OF LP11N AND LP20N
	    .IF EQ,PDP-34		;IF IT IS AN 11/34
	      LP20N=LPTN
	      LP11N=0
	    .ENDC;.IF EQ,PDP-34
	    .IF EQ,PDP-40
	      LP11N=LPTN
	      LP20N=0
	    .ENDC;.IF EQ,PD-40
	  .ENDC;.IF NE,<LPTN-<LP11N+LP20N>>
	.ENDC;.IF NDF,LPTN
	.IIF NDF PTRN,PTRN=NPR		;NUMBER OF PAPER TAPE READERS
	.IIF NDF PTPN,PTPN=NPP		;NUMBER OF PAPER TAPE PUNCHES
	.IIF NDF PLTN,PLTN=NPL		;NUMBER OF PLOTERS
	.ENDC	;.IF EQ PASS-1
	ZZ=ZZ+1
.IFF
    .IIF NDF DV'OP,DV'OP=0
.ENDC;.IF NE FT.D'OPT
.ENDM CONFG
.MACRO	SYNDEV	Q
	.IRP	QQ,<Q>
		.IIF NDF QQ'N,QQ'N=0
		NLIN=NLIN+QQ'N
	.ENDR
	.IRP	QQ,<Q>
		.IIF NDF QQ'OP,QQ'OP=0
		.IF NE QQ'OP
			.IF DF NLINES
				.IF GE <NLINES-NLIN>
					QQ'N=QQ'N+<NLINES-NLIN>
				.IFF
					.PRINT ;IMPOSSIBLE TO BUILD THE SYSTEM
					.PRINT	; BAD SYNC LINE DEFINITIONS
					QQ'N=QQ'N-<NLINES-NLIN>
					NLINES=NLIN
				.ENDC
			.IFF
				.IF EQ NLIN
					NLIN=QQ'OP
					QQ'N=QQ'OP
				.ENDC
				NLINES=NLIN
			.ENDC
		.ENDC
		.IIF NE QQ'N,FT'QQ'11=1
		.IIF NDF FT'QQ'11,FT'QQ'11=0
	.ENDR
.ENDM
; DATE DEFINITION MACRO

.MACRO	DATE	DAY,MONTH,YEAR
	.MACRO	SWDATE
    .=OURSCB+SB.DAT
    EASCII	DATESZ,<DAY'-'MONTH'-'YEAR>
	.ENDM SWDATE
	.MACRO	DATEIS
    .ASCII	\'DAY'-'MONTH'-'YEAR'\
	.ENDM DATEIS
.ENDM DATE


; VERSION DEFINITION MACRO
.MACRO	ISVER	VNUMB,EDITNM,VMIN,VWHO
  .MACRO ISVER0 VMAJ,E,W
	.ASCII \ V'VMAJ'\
    .IF NE <VMIN>
      .IIF GT <<VMIN>-26.>, .BYTE <<<VMIN>-1>/26.>+'A
	.BYTE	<<<VMIN>-1>-<<<<VMIN>-1>/26.>*26.>>+'A
    .ENDC 	;NE <VMIN>
	.ASCII	\('E')\
    .IIF NE <W>, .ASCII \-'W'\
	.BYTE	<' >
  .ENDM ISVER0
	ISVER0	\<VNUMB>,\<EDITNM>,\<VWHO>
.ENDM 	ISVER
	.SBTTL	ASYNC (DH & DZ) LINE MACROS

;	SYMB: NTLINE -> TOTAL NUMBER OF LINE BLOCKS (NODES) CONFIGURED
;	SYMB: NALINE -> NUMBER OF ASYNC DDCMP P-P DH11/DZ11LINES
;	SYMB: DHLNNN -> ASSIGNMENT FOR DH11 LINE NNN
;	SYMB: DZLNNN -> ASSIGNMENT FOR DZ11 LINE NNN
;		(=0 IF UNASSIGNED, =1 IF TTY, =2 IF POINT TO POINT
;		 DDCMP, =3 IF MULTIPOINT DDCMP MASTER, =4 IF MULTIPOINT
;		 DDCMP TRIBUTARY, =5 IF PTP RDE, =6 IF ASCII RDE
;		 =7 IF EMPTY)
;	SYMB: DHCNNN -> DM11 CONTROL FOR DH11 LINE NNN
;	SYMB: DHSNNN -> LINE SPEED FOR DH11 LINE NNN
;	SYMB: DZSNNN -> LINE SPEED FOR DZ11 LINE NNN
;	SYMB: AL..SPD -> DEFAULT SPEED FOR ASYNC PTP DDCMP LINES
;	SYMB: RA.SPD -> DEFAULT SPEED FOR ASYNC RDA LINES
;	SYMB: RP.SPD -> DEFAULT SPEED FOR ASYNC PTP RDE LINES
;	SYMB: MP.SPD -> DEFAULT SPEED FOR MULTIPOINT ASYNC LINES
;	SYMB: NMPTL -> NUMBER OF ASYNC DDCMP MULTIPOINT LINES
;	SYMB: NN$MMM -> MULTIPOINT ADDRESS FOR DH11 LINE NN, NODE DEF MMM
;	SYMB: M$NNN -> MAX # MULTIPOINT DROPS ON DH LINE NNN
;	SYMB: M$MAX -> MAX # MULTIPOINT DROPS ON ANY DH LINE
;	SYMB: DHINDX -> LINE # OF LAST DH LINE ASSIGNED
;	SYMB: DZINDX -> LINE # OF LAST DZ LINE ASSIGNED
;
;
;	MACRO: DHSET LINE,TYPE,SPEEDX,SPEEDR
;		SET PARAMETERS FOR A DH11 LINE (MUST PRECEDE DHUSE
;		INVOCATION IN DHCNFG MACRO)
;		LINE = THE DH11 LINE (PHYSICAL LINE NUMBER)
;		TYPE = THE LINE TYPE TO BE ASSIGNED:
;			TTY= TERMINAL
;			PTP= POINT TO POINT DDCMP
;			MPT= MULTIPOINT DDCMP
;			TRIB=TRIBUTARY
;			RDP= P-P RDE
;			RDA= ASCII RDE
;		SPEEDX = TRANSMIT SPEED
;		SPEEDR = RECEIVE SPEED
;
;
;	MACRO: DHUSE NTT,NAL,NMPT,TRIB,NRDP,NRDA
;		DEFINE DH11 LINE USAGE
;		NTT = NUMBER OF TTY LINES
;		NAL = NUMBER OF ASYNC DDCMP LINES
;		NMPT = NUMBER OF MULTIPOINT DDCMP ASYNC LINES
;		TRIB = NUMBER OF MULTIPOINT TRIBUTARY DDCMP ASYNC LINES
;		NRDP = NUMBER OF P-P RDE DEVICES
;		NRDA = NUMBER OF ASCII RDE DEVICES
;
;
;	MACRO: MPTA LINE,ADDRESS,NSEQ
;		ASSIGN THE MULTIPOINT ADDRESS TO A LINE DROP
;		(ACTUALLY NSEQ SEQUENTIAL ADDRESSES FROM ADDRESS)
;
;
;	MACRO: TRIBA LINE,ADDRESS
;		ASSIGN THE MULTIPOINT ADDRESS TO A TRIBUTARY
;
;
;	MACRO:	TDEF	INDEX,PARAMETERS
;		DEFINE TTY + TTY PARAMETERS
;		INDEX = TTY # (THIS MUST BE A VARIABLE - IT WILL BE INCREMENTED)
;		PARAMETERS IS A LIST OF THE FORM <ITEM,ITEM,...>
;		IF ALL THE PARAMETERS ARE DEFAULTED OMIT THIS ARGUMENT
;
;			THE ITEMS ARE OF THE FORM ??? OR <???,VALUE>
;			THESE DEFINE THE SYMBOLS T'INDEX'???
;			SETTING THE VALUE TO 1 (DEFAULT) OR TO VALUE
;
;
;	MACRO: DHSPD INDEX,TYPE,SPEEDX,SPEEDR
;		SET THE SPEED FOR A DH11 LINE
;		INDEX = THE DH11 LINE INDEX FOR THE SPECIFIED TYPE
;		TYPE = THE LINE ASSIGNED TYPE:
;			TTY= TERMINAL
;			PTP= POINT TO POINT DDCMP
;			MPT= MULTIPOINT DDCMP
;			TRIB=TRIBUTARY
;			RDP= P-P RDE
;			RDA= ASCII RDE
;
;
;	MACRO: .NXTDH	TYPE
;		SET THE VALUE OF THE SYMBOL NXTDH TO THE NEXT DH LINE
;		ASSIGNED THIS TYPE (SPECIFIED AS IN DHSPD)
;
;		TO GET THE FIRST, START WITH NXTDH = -1
;
;
;	MACRO: .NXTDZ	TYPE
;		SET THE VALUE OF THE SYMBOL NXTDZ TO THE NEXT DZ LINE
;		ASSIGNED THIS TYPE (SPECIFIED AS IN DZSPD)
;
;		TO GET THE FIRST, START WITH NXTDZ = -1
;LINE SPEED NUMBERS FOR DH11 AND DZ11

; CODE		SPEED		DHCODE		DZCODE

; 0		0		0		NONE
; 1		50		1		0
; 2		75		2		1
; 3		110		3		2
; 4		134.5		4		3
; 5		150		5		4
; 6		200		6		NONE
; 7		300		7		5
; 10		600		10		6
; 11		1200		11		7
; 12		1800		12		10
; 13		2000		NONE		11
; 14		2400		13		12
; 15		3600		NONE		13
; 16		4800		14		14
; 17		7200		NONE		15
; 20		9600		15		16
; 21		ILLEGAL(19.2K)	NONE		17
; 22		EXT A		16		NONE
; 23		EXT B		17		NONE
.MACRO	SPD	XSPD,RSPD
A=0
B=0
.IF B XSPD
	.IF NB RSPD
		A=RSPD
	.IFF
		A=^D300
	.ENDC
.IFF
	A=XSPD
.ENDC
.IF B RSPD
	B=A
.IFF
	B=RSPD
.ENDC
	QQA=-1
	QQB=-1

	.IIF EQ <A-0>,QQA=0
	.IIF EQ <A-^D50>,QQA=1
	.IIF EQ <A-^D75>,QQA=2
	.IIF EQ <A-^D110>,QQA=3
	.IIF EQ <A-^D134>,QQA=4
	.IIF EQ <A-^D150>,QQA=5
	.IIF EQ <A-^D200>,QQA=6
	.IIF EQ <A-^D300>,QQA=7
	.IIF EQ <A-^D600>,QQA=10
	.IIF EQ <A-^D1200>,QQA=11
	.IIF EQ <A-^D1800>,QQA=12
	.IIF EQ <A-^D2200>,QQA=13
	.IIF EQ <A-^D2400>,QQA=14
	.IIF EQ <A-^D3600>,QQA=15
	.IIF EQ <A-^D4800>,QQA=16
	.IIF EQ <A-^D7200>,QQA=17
	.IIF EQ <A-^D9600>,QQA=20
	.IIF EQ <A-^D19200>,QQA=21
	.IIF EQ <A-1>,QQA=22
	.IIF EQ <A-2>,QQA=23
	.IF LT QQA
		.ERROR A ;ILLEGAL TRANSMIT SPEED
		QQA=0
	.ENDC;.IF LT QQA

	.IIF EQ <B-0>,QQB=0
	.IIF EQ <B-^D50>,QQB=1
	.IIF EQ <B-^D75>,QQB=2
	.IIF EQ <B-^D110>,QQB=3
	.IIF EQ <B-^D134>,QQB=4
	.IIF EQ <B-^D150>,QQB=5
	.IIF EQ <B-^D200>,QQB=6
	.IIF EQ <B-^D300>,QQB=7
	.IIF EQ <B-^D600>,QQB=10
	.IIF EQ <B-^D1200>,QQB=11
	.IIF EQ <B-^D1800>,QQB=12
	.IIF EQ <B-^D2200>,QQB=13
	.IIF EQ <B-^D2400>,QQB=14
	.IIF EQ <B-^D3600>,QQB=15
	.IIF EQ <B-^D4800>,QQB=16
	.IIF EQ <B-^D7200>,QQB=17
	.IIF EQ <B-^D9600>,QQB=20
	.IIF EQ <B-^D19200>,QQB=21
	.IIF EQ <B-1>,QQB=22
	.IIF EQ <B-2>,QQB=23
	.IF LT QQB
		.ERROR B ;ILLEGAL RECEIVE SPEED
		QQB=0
	.ENDC;.IF LT QQB

	QQ=QQB*400+QQA
.ENDM	SPD
DHINDX=-1
DZINDX=-1


.MACRO	.NXTDH	TYPE
	.MACRO	NXTDH$	NNN
		.IF EQ DHL'NNN-DHXXXX
			NXTDH=NNN
			DHXXXX=-1
		.ENDC
		DHYYYY=DHYYYY+1
	.ENDM	NXTDH$
	DHXXXX=-1
	.IIF IDN <TTY>,<TYPE>	DHXXXX=1
	.IIF IDN <PTP>,<TYPE>	DHXXXX=2
	.IIF IDN <MPT>,<TYPE>	DHXXXX=3
	.IIF IDN <TRIB>,<TYPE>	DHXXXX=4
	.IIF IDN <RDP>,<TYPE>	DHXXXX=5
	.IIF IDN <RDA>,<TYPE>	DHXXXX=6
	.IIF IDN <NONE>,<TYPE>	DHXXXX=7
	.IF GT	DHXXXX
		DHYYYY=NXTDH+1
		.REPT	<NDH11*20>-DHYYYY
			.IIF GT DHXXXX, NXTDH$ \DHYYYY
		.ENDR
	.ENDC
.ENDM	.NXTDH


;
.MACRO	.NXTDZ	TYPE
	.MACRO	NXTDZ$	NNN
		.IF EQ DZL'NNN-DZXXXX
			NXTDZ=NNN
			DZXXXX=-1
		.ENDC
		DZYYYY=DZYYYY+1
	.ENDM	NXTDZ$
	DZXXXX=-1
	.IIF IDN <TTY>,<TYPE>	DZXXXX=1
	.IIF IDN <PTP>,<TYPE>	DZXXXX=2
	.IIF IDN <MPT>,<TYPE>	DZXXXX=3
	.IIF IDN <TRIB>,<TYPE>	DZXXXX=4
	.IIF IDN <RDP>,<TYPE>	DZXXXX=5
	.IIF IDN <RDA>,<TYPE>	DZXXXX=6
	.IIF IDN <NONE>,<TYPE>	DZXXXX=7
	.IF GT	DZXXXX
		DZYYYY=NXTDZ+1
		.REPT	<NDZ11*10>-DZYYYY
			.IIF GT DZXXXX, NXTDZ$ \DZYYYY
		.ENDR
	.ENDC
.ENDM	.NXTDZ
.MACRO	DHSET	LIN,TYP,SPX,SPR

	.IIF IDN <TYP>,<TTY>	DHL'LIN=1
	.IIF IDN <TYP>,<PTP>	DHL'LIN=2
	.IIF IDN <TYP>,<MPT>	DHL'LIN=3
	.IIF IDN <TYP>,<TRIB>	DHL'LIN=4
	.IIF IDN <TYP>,<RDP>	DHL'LIN=5
	.IIF IDN <TYP>,<RDA>	DHL'LIN=6
	.IIF IDN <TYP>,<NONE>	DHL'LIN=7

	SPD	SPX,SPR
	DHS'LIN=QQ

.ENDM	DHSET



.MACRO	DZSET	LIN,TYP,SPX,SPR

	.IIF IDN <TYP>,<TTY>	DZL'LIN=1
	.IIF IDN <TYP>,<PTP>	DZL'LIN=2
	.IIF IDN <TYP>,<MPT>	DZL'LIN=3
	.IIF IDN <TYP>,<TRIB>	DZL'LIN=4
	.IIF IDN <TYP>,<RDP>	DZL'LIN=5
	.IIF IDN <TYP>,<RDA>	DZL'LIN=6
	.IIF IDN <TYP>,<NONE>	DZL'LIN=7

	SPD	SPX,SPR
	DZS'LIN=QQ

.ENDM	DZSET
.MACRO	DHUSE	NTT,NAL,NMP,NTR,NRP,NRA

	.IIF NDF NLINES,NLINES=0
	.IIF NDF TTYDHN,TTYDHN=NTT
	.IIF NDF NADHLN,NADHLN=NAL
	.IIF NDF NDHMPT,NDHMPT=NMP
	.IIF NDF NDHTRB,NDHTRB=NTR
	.IIF NDF RDPDHN,RDPDHN=NRP
	.IIF NDF RDADHN,RDADHN=NRA

	DHLINE=NDHMPT+NADHLN+TTYDHN+NDHTRB+RDPDHN+RDADHN	; # DH11 LINES ASSIGNED
	NDH11=<DHLINE+17>/20		; # DH11S

	.MACRO X
		.MACRO XXX M
			Z'M=Z'M+1
		.ENDM
		.MACRO	XX N
			.IF DF DHL'N
				.IIF LT 7-DHL'N, DHL'N=0
				 XXX \DHL'N
			.ENDC
			.IIF NDF DHL'N, DHL'N=0
		.ENDM
		Z0=0
		Z1=-TTYDHN
		Z2=-NADHLN
		Z3=-NDHMPT
		Z4=-NDHTRB
		Z5=-RDPDHN
		Z6=-RDADHN
		Z7=0
		Z=0
		.REPT	NDH11*20
			XX	\Z
			Z=Z+1
		.ENDR
		.MACRO	XXX	N,M
			.IF EQ	DHL'N
				.IF LT Z'M
					Z'M=Z'M+1
					DHL'N=M
				.ENDC
			.ENDC
		.ENDM
		.MACRO	XX	MM
			.IF LT Z'MM
				Z=0
				.REPT	NDH11*20
					XXX	\Z,MM
					Z=Z+1
				.ENDR
			.ENDC
		.ENDM
		XX	1
		XX	2
		XX	3
		XX	4
		XX	5
		XX	6
		XX	7
		Z=0
		.IIF LT Z1,Z=Z-Z1
		.IIF LT Z2, Z=Z-Z2
		.IIF LT Z3, Z=Z-Z3
		.IIF LT Z4, Z=Z-Z4
		.IIF LT Z5, Z=Z-Z5
		.IIF LT Z6, Z=Z-Z6
		.IIF LT Z7, Z=Z-Z7
		.IF NE Z
			NDH11=NDH11+1	;FILL THE QUOTA WITH ANOTHER DH11
			X
		.ENDC
	.ENDM
	X
	DH.MAX=NDH11
	.MACRO XXXX NNN
		M$'NNN=0		; MAX # LINE DROPS ON LINE N
	.ENDM
	NXTDH=-1
	.REPT	NDHMPT
		.NXTDH MPT
		XXXX \NXTDH
	.ENDR
.ENDM	DHUSE
.MACRO	DZUSE	NTT,NAL,NMP,NTR,NRP,NRA

	.IIF NDF NLINES,NLINES=0
	.IIF NDF TTYDZN,TTYDZN=NTT
	.IIF NDF NADZLN,NADZLN=NAL
	.IIF NDF NDZMPT,NDZMPT=NMP
	.IIF NDF NDZTRB,NDZTRB=NTR
	.IIF NDF RDPDZN,RDPDZN=NRP
	.IIF NDF RDADZN,RDADZN=NRA

	DZLINE=NDZMPT+NADZLN+TTYDZN+NDZTRB+RDPDZN+RDADZN	; # DZ11 LINES ASSIGNED
	NDZ11=<DZLINE+7>/10		; # OF DZ11'S

	.MACRO X
		.MACRO XXX M
			Z'M=Z'M+1
		.ENDM
		.MACRO	XX N
			.IF DF DZL'N
				.IIF LT 7-DZL'N, DZL'N=0
				 XXX \DZL'N
			.ENDC
			.IIF NDF DZL'N, DZL'N=0
		.ENDM
		Z0=0
		Z1=-TTYDZN
		Z2=-NADZLN
		Z3=-NDZMPT
		Z4=-NDZTRB
		Z5=-RDPDZN
		Z6=-RDADZN
		Z7=0
		Z=0
		.REPT	NDZ11*10
			XX	\Z
			Z=Z+1
		.ENDR
		.MACRO	XXX	N,M
			.IF EQ	DZL'N
				.IF LT Z'M
					Z'M=Z'M+1
					DZL'N=M
				.ENDC
			.ENDC
		.ENDM
		.MACRO	XX	MM
			.IF LT Z'MM
				Z=0
				.REPT	NDZ11*10
					XXX	\Z,MM
					Z=Z+1
				.ENDR
			.ENDC
		.ENDM
		XX	1
		XX	2
		XX	3
		XX	4
		XX	5
		XX	6
		XX	7
		Z=0
		.IIF LT Z1,Z=Z-Z1
		.IIF LT Z2, Z=Z-Z2
		.IIF LT Z3, Z=Z-Z3
		.IIF LT Z4, Z=Z-Z4
		.IIF LT Z5, Z=Z-Z5
		.IIF LT Z6, Z=Z-Z6
		.IIF LT Z7, Z=Z-Z7
		.IF NE Z
			NDZ11=NDZ11+1	;FILL THE QUOTA WITH ANOTHER DZ11
			X
		.ENDC
	.ENDM
	X
	DZ.MAX=NDZ11
	.MACRO XXXX NNN
		M$'NNN=0		; MAX # LINE DROPS ON LINE N
	.ENDM
	NXTDZ=-1
	.REPT	NDZMPT
		.NXTDZ MPT
		XXXX \NXTDZ
	.ENDR
.ENDM	DZUSE
.MACRO	MPTA	LINE,ADDRESS,NSEQ
	MPTADH	LINE,ADDRESS,NSEQ
.ENDM



.MACRO	MPTADH	LINE,ADDRESS,NSEQ
	NXTDH=-1
	.REPT	LINE+1
		.NXTDH	MPT
	.ENDR
	.MACRO XX N,M,A
		Y'N'$'M=A
	.ENDM
	.MACRO X N,A
		Z=M$'N
		XX N,\Z,A
		.IIF EQ M$MAX-M$'N,M$MAX=M$MAX+1
		M$'N=M$'N+1
	.ENDM
	.IIF NB <NSEQ>,Q=NSEQ
	.IIF B <NSEQ>,Q=1
	.IIF NB <ADDRESS>,QQ=ADDRESS
	.IIF B <ADDRESS>,QQ=1
	.REPT Q
		X \NXTDH,\QQ
		NTLINE=NTLINE+1
		QQ=QQ+1
	.ENDR
.ENDM



.MACRO	MPTADZ	LINE,ADDRESS,NSEQ
	NXTDZ=-1
	.REPT	LINE+1
		.NXTDZ	MPT
	.ENDR
	.MACRO XX N,M,A
		Y'N'$'M=A
	.ENDM
	.MACRO X N,A
		Z=M$'N
		XX N,\Z,A
		.IIF EQ M$MAX-M$'N,M$MAX=M$MAX+1
		M$'N=M$'N+1
	.ENDM
	.IIF NB <NSEQ>,Q=NSEQ
	.IIF B <NSEQ>,Q=1
	.IIF NB <ADDRESS>,QQ=ADDRESS
	.IIF B <ADDRESS>,QQ=1
	.REPT Q
		X \NXTDZ,\QQ
		NTLINE=NTLINE+1
		QQ=QQ+1
	.ENDR
.ENDM



.MACRO	TRIBA	LINE,ADDRESS
	NXTDH=-1
	.REPT	LINE+1
		.NXTDH	TRIB
	.ENDR
	.MACRO	X N,A
		Y'N'$0=A
	.ENDM
	.IIF NB <ADDRESS>,	X \NXTDH,ADDRESS
.ENDM
.MACRO	TRIBDZ	LINE,ADDRESS
	NXTDZ=-1
	.REPT	LINE+1
		.NXTDZ	TRIB
	.ENDR
	.MACRO	X N,A
		Y'N'$0=A
	.ENDM
	.IIF NB <ADDRESS>,	X \NXTDZ,ADDRESS
.ENDM



.MACRO	DHSPD	LINE,TYPE,SPEEDX,SPEEDR
	.MACRO X N,S
		DHS'N=S
	.ENDM
	NXTDH=-1
	.REPT	LINE+1
		.NXTDH	TYPE
	.ENDR
	.IF GE NXTDH
		SPD SPEEDX,SPEEDR
		X	\NXTDH,\QQ
	.ENDC
.ENDM	DHSPD



.MACRO	DZSPD	LINE,TYPE,SPEEDX,SPEEDR
	.MACRO X N,S
		DZS'N=S
	.ENDM
	NXTDZ=-1
	.REPT	LINE+1
		.NXTDZ	TYPE
	.ENDR
	.IF GE NXTDZ
		SPD SPEEDX,SPEEDR
		X	\NXTDZ,\QQ
	.ENDC
.ENDM	DZSPD



.MACRO	TDEF	QTN,QTA
	.MACRO	TDEF0	QT1,QT2,QT3
		.IF B <QT3>
		T'QT1'QT2=1
		.IFF
		T'QT1'QT2=QT3
		.ENDC
	.ENDM	TDEF0
	.IRP	QTT,<QTA>
		TDEF0	\QTN,QTT
	.ENDM
	QTN=QTN+1
.ENDM	TDEF
	.SBTTL	DEVICE DATA BLOCK GENERATOR

;MACRO TO MAKE DEVICE DATA BLOCKS

.MACRO	DDBLBL	QLAB
DDB'QLAB:
	DDBIDX=DDBIDX+1
.ENDM	DDBLBL



DDBIDX=0



.MACRO	DDBGEN	DEV,DV,NUM,DRQ,QBITS
  .IIF NDF DRESET,DRESET=0
  .IF EQ DRESET
    DEV'DDB:
    ZZ=0
  .ENDC

  .REPT	NUM
    DX.GEN	DEV,DV,NUM,DRQ,QBITS,\ZZ	;INDEPENDENT PORTION
    DDXGEN	DEV,DV,DRQ,QBITS,\ZZ		;DEPENDENT PORTION
    ZZ=ZZ+1
  .ENDR
.ENDM	DDBGEN




.MACRO	DX.GEN	DEV,DV,NUM,DRQ,XBITS,XZZ
  DDBLBL \DDBIDX
DV'XZZ'DDB:	.WORD	XBITS		;STATUS WORD

.IF NE <NUM-1-ZZ>
  .WORD	DV'XZZ'DDB+DV'1DDB-DV'0DDB	;DB.LNK
.IFF
  .WORD	DDBLINK		;DB.LNK
  DDBLINK=DEV'DDB
.ENDC;.IF NE <NUM-1-ZZ>

Z=0
.IIF  IDN <DEV>,<CTY>,Z=CTISTS
.IF IDN <DV>,<T>
  .IIF NDF ASYDEV,ASYDEV=0
  .IF EQ ASYDEV-ASY.DH
    .NXTDH TTY
    Z=DH0BLK+<<NXTDH/20>*DHB.SZ>
  .ENDC

  .IF EQ ASYDEV-ASY.DZ
    .NXTDZ TTY
    Z=DZ0BLK+<<NXTDZ/10>*DZB.SZ>
  .ENDC
.ENDC

.IF IDN <DV>,<D>
  .IIF NDF ASYDEV,ASYDEV=0
  .IF EQ ASYDEV-ASY.DH
    .NXTDH	RDA
    Z=DH0BLK+<<NXTDH/20>*DHB.SZ>
  .ENDC

  .IF EQ ASYDEV-ASY.DZ
    .NXTDZ	RDA
    Z=DZ0BLK+<<NXTDZ/10>*DZB.SZ>
  .ENDC
.ENDC

.IIF EQ <XBITS&DS.TTY>!Z,Z=DV'XZZ'STS
.WORD	Z		;DB.HDW
.WORD	DEV'SER		;DB.RPC
.WORD	DEV'TIM		;DB.TPC

Z=0
.IF IDN <T><DV>

  ND T'XZZ'DSL,TTYDSL		;DEFAULT THIS LINE
  .IIF NE T'XZZ'DSL,Z=Z!TT.DSL	;SET DATASET THIS LINE IF DESIRED

  ND T'XZZ'ABD,TTYABD		;DEFAULT THIS LINE
  .IIF NDF T'XZZ'XS,T'XZZ'ABD=1	;FORCE AUTOBAUD IF NO SPEED ASSIGNED
  .IIF NE T'XZZ'ABD,Z=Z!TT.ABD	;AUTOBAUD LINE
  Z=Z!TT.CSB!TT.ABR		;CAN SET BAUD RATE & AUTOBAUD
  .IF DF T'XZZ'XS
    .IF EQ <T'XZZ'XS-^D134>
     .ERROR	134.;NO SUPPORT FOR 2741 TERMINALS
    .ENDC
  .ENDC
  .IF NE FTDN11
    .IF DF T'XZZ'801	;IS THIS AN AUTO DIAL LINE ?
      T'XZZ'DSL=1	;IT MUST HAVE A DATASET
      Z=Z!TT.801!TT.DSL	;MAKE A NOTE THAT IT IS AUTO DIAL/DATASET
      T'XZZ'DSP=T'XZZ'801
    .IFF
      T'XZZ'DSP=0
    .ENDC
  .ENDC
  Z=Z!TT.CSH			;SET THE "CAN SET HOST" BIT
  ND T'XZZ'INI,TTYINI		;DEFAULT THE "RUN INITIA" BIT
  .IIF NE  T'XZZ'INI,Z=Z!TT.RIC	;SET THE "RUN INITIA" ATTRIBUTE
  ND T'XZZ'8BT,TTY8BT		;DEFAULT THE "8-BIT" VALUE
  .IIF NE  T'XZZ'8BT,Z=Z!TT.8BL	;SET THE "8-BIT-LINE" ATTRIBUTE
.ENDC;.IF IDN <T>,<DV>

.IF IDN <CT>,<DV>
  Z=Z!TT.CSH			;CTY CAN SET HOST TOO!
  ND CTY8BT,0			;CTY IS 7-BIT BY DEFAULT
  .IIF NE  CTY8BT,Z=Z!TT.8BL	;SET THE "8-BIT-LINE" ATTRIBUTE
.ENDC;.IF IDN <CT>,<DV>
.IF IDN <D><DV>
  ND D'XZZ'DSL,0
  .IIF NE D'XZZ'DSL,Z=Z!TT.DSL
  .IF NE FTDN11
    .IF DF D'XZZ'801
      D'XZZ'DSL=1		;MUST BE DATA SET
      Z=Z!TT.801!TT.DSL		;AUTO DIAL/DATASET BIT(S)
      D'XZZ'DSP=D'XZZ'801
    .IFF
      D'XZZ'DSP=0
    .ENDC
  .ENDC
.ENDC

.IF IDN <LP><DV>
  Z=2020
  ND LP'XZZ'.LC,LPT.LC
  .IIF NE LP'XZZ'.LC,Z=Z!DLP.LL	;SET "LOWER CASE"
  ND LP'XZZ'FCS,LPTFCS
  .IIF NE LP'XZZ'FCS,Z=Z!DLP.FC	;SET "FULL CHARACTER SET"
  ND LP'XZZ'DAV,LPTDAV
  .IIF NE LP'XZZ'DAV,Z=Z!400	;SET "DAVFU" (I.E., LOADABLE VFU)
  ND LP'XZZ'8BT,LPT8BT
  .IIF NE LP'XZZ'8BT,Z=Z!DLP.8B	;SET "EIGHT-BIT"
.ENDC

.IIF IDN <R><DV>,Z=<<FTSLCT&1>*2+1>	;SET MULTIPLEXED DEV
					; + POLLING LIST IF REQUIRED
.WORD	Z		;DB.DVT

ND DV'XZZ'DVU,0
.BYTE	DV'XZZ'DVU	;DB.DVU
.BYTE	0		;DB.DVV (SET BY DEVICE SERVICE ROUTINE)

ND DEV'WID,72.		;SET DEFAULT CLASS WIDTH
ND DV'XZZ'WID,DEV'WID
.WORD	DV'XZZ'WID		;DB.WID & DB.RLN

Z=ZZ
.IF IDN <T><DV>
  .IIF NE FT.CTY,Z=Z+1
.ENDC
.BYTE	0		;DB.ACR
.BYTE	Z		;DB.UNI
.BYTE	OBJ'DEV		;DB.OBJ
.BYTE	0		;DB.ROT
.BYTE	DRQ		;DB.MDR

Z=DRQ
.IIF DF DV'XZZ'CHK,Z=DV'XZZ'CHK
.BYTE	Z		;DB.CHK

Z=0
.IF IDN <T><DV>
  .BYTE	ASYDEV		;DB.TYP
  Z=1
.ENDC

.IF IDN <D><DV>
  .BYTE	ASYDEV		;DB.TYP
  Z=1
.ENDC

.IIF EQ Z,.BYTE	0		;DB.TYP
.IF NE FT.RNN
  Z=0
  .IF DF DV'XZZ'RNN
    Z=DV'XZZ'RNN
  .IFF
    .IIF DF DEV'RNN,Z=DEV'RNN
  .ENDC
  .BYTE	Z		;DB.RNN
.ENDC

.IF NE FT.PFH
  Z=0
  .IF DF DV'XZZ'PFH
    Z=DV'XZZ'PFH
  .IFF
    .IIF DF DEV'PFH,Z=DEV'PFH
  .ENDC
  .BYTE	Z		;DB.PFH
.ENDC

.IIF NE FTHOST,.BYTE	0	;DB.RCN

.EVEN
.WORD	DDBIDX*2		;DB.OLA
.IF NE FT.RDM!FT.RDP!FT.RDA
  W.WORD=0
  .IIF IDN <RDM><DEV>,W.WORD=RDEMPT
  .IIF IDN <RDP><DEV>,W.WORD=RDEPTP
  .IIF IDN <RDA><DEV>,W.WORD=RDEASC
  .WORD	W.WORD			;DB.RDT
.ENDC

.IIF NE FT.TSK,.WORD	0,0,0,0	;DB.TSK

.WORD	0,0,0			;DB.DFT

.IIF NE DV'XZZ'DDB+DB.ZER-.,.ERROR DV'XZZ'DDB+DB.ZER-. ;DDB LENGTH MISMATCH

.BLKB	DB.SIZ-DB.ZER

.ENDM	DX.GEN





.MACRO	DDXGEN	DEV,DV,DRQ,XBITS,XZZ	;DEVICE DEPENDENT PORTION
.ENDM	DDXGEN
	.SBTTL	MACRO TO DEFINE DEVICE INTERRUPT ENTRIES
.MACRO	DVINT	X,Y
X'VA'Y:	SAVE	<J>			;SAVE DDB POINTER
	MOV	#X'Y'DDB,J		;POINT TO RIGHT DEVICE BLOCK
.ENDM	DVINT



.MACRO	DEVINT	DEV,DV
	Z=DEV'N-1
	.REPT	DEV'N
		DVINT	DV,\Z
		.IIF NE Z,BR	DEV'INT
		Z=Z-1
	.ENDR
.ENDM	DEVINT
.MACRO	TTSPXX


	QQQ=0
	SPD	QQQ,QQQ
B.0=QQ
	QQQ=<^D50>
	SPD	QQQ,QQQ
B.50=QQ
	QQQ=<^D75>
	SPD	QQQ,QQQ
B.75=QQ
	QQQ=<^D110>
	SPD	QQQ,QQQ
B.110=QQ
	QQQ=<^D134>
	SPD	QQQ,QQQ
B.134=QQ
	QQQ=<^D150>
	SPD	QQQ,QQQ
B.150=QQ
	QQQ=<^D200>
	SPD	QQQ,QQQ
B.200=QQ
	QQQ=<^D300>
	SPD	QQQ,QQQ
B.300=QQ
	QQQ=<^D600>
	SPD	QQQ,QQQ
B.600=QQ
	QQQ=<^D1200>
	SPD	QQQ,QQQ
B.1200=QQ
	QQQ=<^D1800>
	SPD	QQQ,QQQ
B.1800=QQ
	QQQ=<^D2200>
	SPD	QQQ,QQQ
B.2200=QQ
	QQQ=<^D2400>
	SPD	QQQ,QQQ
B.2400=QQ
	QQQ=<^D3600>
	SPD	QQQ,QQQ
B.3600=QQ
	QQQ=<^D4800>
	SPD	QQQ,QQQ
B.4800=QQ
	QQQ=<^D7200>
	SPD	QQQ,QQQ
B.7200=QQ
	QQQ=<^D9600>
	SPD	QQQ,QQQ
B.9600=QQ
	QQQ=<^D19200>
	SPD	QQQ,QQQ
B.1900=QQ
	QQQ=1
	SPD	QQQ,QQQ
B.1=QQ
	QQQ=2
	SPD	QQQ,QQQ
B.2=QQ

B.LSPD=B.300
B.HSPD=B.2400
.ENDM
; THIS MACRO WILL CAUSE OTHER MACROS TO GET BUILT
;THAT DEPEND UPON CPU TYPE, OR OTHER SUCH STUFF
.MACRO	SETUP

	SIMMAC
	TTSPXX
	SUASRT

.ENDM
;A MACRO TO ASSEMBLE AN EVEN PARITY ASCII STRING
;NOTE THAT WE NO LONGER DO PARITY, SO THIS IS REALLY ONLY A SLOW VERSION
; OF .ASCII
.MACRO EPASCI STR
.IRPC CHR,<STR>
	PB==0			;;PARITY BIT INITIALLY ZERO
;;	CH==''CHR		;;GET THE VALUE OF THE CHAR
;;	.REPT 8.		;;FOR ALL EIGHT BITS
;;		PB==200&<PB+CH>	;;XOR THE TOP BIT INTO PB
;;		CH==CH*2	;; AND SHIFT TO THE NEXT BIT
;;	.ENDR
	.BYTE	PB+''CHR	;;STORE THE BYTE WITH THE PARITY BIT
.ENDM				;;END THE IRPC
.ENDM				;;END THE MACRO
