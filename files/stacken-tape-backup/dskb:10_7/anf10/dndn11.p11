.SBTTL	DNDN11 - DN11 ROUTINES  09 SEP 80

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1976,1977,1978,1979,1980,1981,1984,1988.
;ALL RIGHTS RESERVED.

VRDN11=015			;FILE EDIT NUMBER

.IF NE FTDN11

;	DN11 DATA FIELDS
;
; IN DDB:
;
;	DB.DNS	DN11 SOFTWARE STATUS BITS
	DNDIAL=B7		;1=MEANS WE ARE DIALING
	DNDISP=B0+B1+B2+B3+B4+B5;DISPLACEMENT OF THIS DN11 (0-63)
;
;
;	DB.DNT	DN11 TIMER AND TIMER CODE BITS
	DNTIME=B0+B1+B2+B3+B4+B5	;TIMER (MAX 63 SECS)
	DNCODE=B6+B7			;TIMER CODE

;
;	DN11 PARAMETERS
;
; TIMER VALUES (IN SECONDS)
;
	.IIF NDF DN.TDG,DN.TDG=10.	;TIME FOR DIGIT
	.IIF NDF DN.TCL,DN.TCL=20.	;TIME FOR END OF CALL
	.IIF NDF DN.TDL,DN.TDL=20.	;TIME FOR DLO TO CLEAR

;TIMER CODES. THESE ARE 0,1,2,3 FOR PAUSE,END OF CALL, DIGIT AND DLO WAIT
	TMPAUS=0		;TIME FOR PAUSE (CODE 16)
	TMEOC=1			;TIME FOR END OF CALL
	TMDGT=2			;TIME FOR DIGIT
	TMDLO=3			;TIME FOR DLO TO CLEAR
; DNTAB:		12(10) WORD TABLE OF DN11 DATA
;
;			;1ST WORD IS ADR OF HDW STATUS REGISTER
;			;2ND WORD IS ADR OF DDB ASSOCIATED WITH ACU
	DNPTR=4		;3RD WORD IS POINTER TO LAST DIGIT DIALED
;			;NEXT 18 BYTES ARE DIGITS TO DIAL
;			;FIRST DIGIT IS NULL
;			;LAST IS ALWAYS 17
	DNTABL=^D24	;NUMBER OF BYTES IN A BLOCK

.MACRO	X	Q
DN'Q'BLK:
	.REPT	4
	ZZ		;HDW ADR
	.WORD	0	;DDB ADR
	.WORD	0	;POINTER TO NUMBER
	.BLKB	^D18	;NUMBER TO DIAL
	ZZ=ZZ+2
	.ENDR
.ENDM	X
	Z=0
	ZZ=DNBASE
.REPT	DN11N
	X	\Z
	Z=Z+1
.ENDR
	.WORD	0
;	DEFINE INTERRUPT VECTOR ROUTINES
;
.MACRO	X	A
DNVA'A':	MOV	R0,-(P)
	MOV	#DN'A'BLK,R0		;ADDRESS OF DN11 BLOCK
.ENDM	X
	Z=DN11N-1
.REPT	DN11N
	X	\Z
.IIF NE Z,	BR	DNINT
	Z=Z-1
.ENDR	;.REPT DN11N
;	DN11 INTERRUPT SERVICE ROUTINE
;
;	REGISTER USAGE
;
;	R3	DNTAB ENTRY FOR THIS 801 CONTROLLER
;	R2	ADDRESS OF HARDWARE STATUS REGISTER
;	J	POINTER TO TTYDDB FOR THIS LINE
;
DNINT:	SAVE	<R1,R2,R3,J>		;SAVE REGS
	CLR	-(P)			;CLEAR COUNT OF CONDITIONS HANDLED
	MOV	R0,R3			;POINT TO ITS DNTAB ENTRY
DNLOOP:	MOV	@R3,R2			;GET HARDWARE ADDRESS
	BEQ	20$			;IF DOESN'T EXIST TRY NEXT ONE
	MOV	2(R3),J			;GET DDB ADDRESS
	BIT	#DN..IE,@R2		;IS INTERRUPT ENABLE SET FOR THIS ONE ?
	BEQ	20$			;BECAUSE IF NOT DON'T CARE ABOUT IT
	BIT	#DN.DNE,@R2		;SEE IF DONE IS SET FOR THIS ONE
	BEQ	20$			;NO, TRY NEXT
	INC	(P)			;COUNT IT
	JSR	PC,DNFUNC		;AND HANDLE IT
20$:	ADD	#DNTABL,R3		;POINT TO NEXT DNTAB ENTRY
	BIT	#6,@R3
	BNE	DNLOOP			;AND CONTINUE
40$:	TST	(P)+			;CHECK COUNTER
	BNE	90$			;SKIP IF NON-ZERO
	TWIDDLE				;NO INTERRUPT CONDITION FOUND???
90$:	RESTORE	<J,R3,R2,R1,R0>
	RTI				;DISMISS
;SUBROUTINE TO DETERMINE CAUSE OF INTERRUPT AND DO APPROPRIATE DN FUNCTION
DNFUNC:	BIC	#DN.DGT!DN.DNE,@R2	;CLEAR DONE AND DIGIT
	BIT	#DN.PWI!DN.ACR,@R2	;POWER LOSS OR 801 TIMEOUT?
	BNE	DNFAIK			;YES, ABORT CALL FUNCTION
	BIT	#DN.PND,@R2		;IS IT TIME TO GIVE NEXT DIGIT
	BEQ	DNINT9			;NO, RETURN
	MOVB	@DNPTR(R3),R0		;GET LAST DIGIT DIALED
	CMP	#17,R0			;WAS IT END OF CALL?
	BEQ	DNINT9			;YES, DON'T PRESENT ANOTHER
DNEXTD:	INC	DNPTR(R3)		;POINT TO NEXT DIGIT
	MOVB	@DNPTR(R3),R0		;GET IT
	CMP	R0,#16			;SEE IF 5 SEC DELAY
	BNE	30$			;NO,CONTINUE
	MOVB	#<100*TMPAUS+5>,DB.DNT(J)	;SET TIME
	BR	DNINT9			;DONE
30$:	CMP	R0,#17			;END OF CALL?
	BNE	40$			;NO, CONTINUE LOOKING
	MOVB	#<100*TMEOC+DN.TCL>,DB.DNT(J)	;SET END OF CALL TIME
	BR	DNINT9			;CHECK FOR SUCCESS
40$:	MOVB	#<100*TMDGT+DN.TDG>,DB.DNT(J)	;SET DIGIT TIME
	MOVB	R0,1(R2)		;PUT CHARACTER TO 801
	BISB	#DN..DP,@R2		;SET DIGIT PRESENT
DNINT9:	BIT	#DN.DSS,@R2		;DID WE WIN ?
	BEQ	99$			;NOT YET
	BIC	#DN..IE,@R2		;DON'T NEED INTERRUPT ENABLE
	BICB	#DNTIME,DB.DNT(J)	;CLEAR END OF CALL TIMER
	MOV	DB.LCB(J),R0		;ADDRESS OF LCB
	MOVB	#LCS.DS,LC.STA(R0)	;SET TO DIAL SUCCEEDED STATE
99$:	RTS	PC			;RETURN
;HERE ON RECEIPT OF DIAL MESSAGE

DNSTRT:	MOV	DB.LCB(J),R3		;POINT TO LCB
	MOVB	#LCS.DL,LC.STA(R3)	;SET TO DIALING INITIATE
	BIS	#TS.RNG,DB.DCS(J)	;SET RING AND
	BIC	#TS.DTR,DB.DCS(J)	;CLEAR DTR TO TELL -10 WE'RE TRYING
	JSR	PC,QUEXDS		;ENSURE STATUS GETS SENT
	BIT	#40,DB.DVT(J)		;AUTO-DIAL LINE?
	BEQ	94$			;IF NOT STOP NOW
.IF NE FT.CHK
	BIT	#LCB.DS,@DB.LCB(J)	;DATASET LINE?
	ASSERT	NE			;BETTER BE
.ENDC;.IF NE FT.CHK
	CMP	DB.OCN(J),#16.		;NUMBER OF CHARACTERS GREATER THAN 16?
	BGT	94$			;YES, ERROR
	JSR	PC,DNADDR		;GET R1=DNTAB,R2=HDW
	BIT	#DN.PWI,@R2		;POWER ON & HEALTHY ?
	BNE	94$			;NO GOOD
	MOV	#6,R3			;DISPLACEMENT INTO DNTAB
	ADD	R1,R3			;OF FIRST DIGIT
	MOV	R3,4(R1)		;INITIALIZE POINTER
	CLRB	(R3)+			;FIRST BYTE IS 0
20$:	JSR	PC,DVGDBY		;GET NEXT NUMBER
70$:	BIC	#^C17,R0		;STRIP EXTRA BITS
	MOVB	R0,(R3)+		;STASH
	TST	DB.OCN(J)		;MORE LEFT ?
	BNE	20$			;IF SO GET IT
	MOVB	#17,(R3)+		;TRAILING FLAG
	BISB	#DNDIAL,DB.DNS(J)	;MARK THIS LINE AS CONTROLLED BY DN11/801
	BIT	#DN..CR!DN.DLO,@R2	;CALL REQUEST UP?
	BEQ	DNBEGN			;IF READY BEGIN AT ONCE

;HERE BECAUSE WANT TO DIAL BUT DN11 STILL IS BUSY

	BIC	#^CDN..ME,@R2		;CLEAR CALL REQUEST
	MOVB	#<100*TMDLO+DN.TDL>,DB.DNT(J)	;SET TIMER
	RTS	PC			;RETURN
;HERE IF DIAL REQUEST CAN'T BE HONOURED.

93$:	JSR	PC,DVGDBY		;EAT NEXT BYTE
94$:	TST	DB.OCN(J)		;MORE LEFT IN MESSAGE?
	BGT	93$			;YES, EAT REST OF MESSAGE
;	BR	DNFAIL			;NO, TELL -10 WE FAILED

;DN11 CLEAR ROUTINES

DNFAIK:	
DNFAIL:	MOV	DB.LCB(J),R3		;POINT TO LCB
	MOVB	#LCS.DF,LC.STA(R3)	;SET TO DIAL FAIL STATE
DNCLR:	BITB	#DNDIAL,DB.DNS(J)	;THIS LINE CONTROLLED BY US?
	BEQ	99$			;NO
	JSR	PC,DNADDR		;YES, GET DNTAB AND HDW ADDRESS
	BIC	#^CDN..ME,@R2		;CLEAR CALL REQUEST
	BICB	#DNDIAL,DB.DNS(J)	;LINE NO LONGER UNDER OUR CONTROL
	CLRB	DB.DNT(J)		;SO WE SHOULDN'T HAVE A TIMER EITHER
99$:	RTS	PC
;DISPATCH TABLE FROM SECDEV WHEN TIMER IN DB.DNT EXPIRES

DNTDSP:	DNTM5S				;5 SECOND DELAY
	DNTMEC				;END OF CALL
	DNTMDG				;DIGIT
	DNTMDL				;DLO CLEAR

;HERE WHEN END OF 5 DIGIT DELAY EXPIRES

DNTM5S:	JSR	PC,DNADDR		;GET DNTAB ADDR IN R1, HWD IN R2
	MOV	R1,R3			;PUT DNTAB IN R3 FOR DNFUNC
	PIOFF				;DON'T ALLOW INTERRUPTS
	JSR	PC,DNFUNC		;PND SHOULD STILL BE ON
	PION				;ENABLE INTERRUPTS
	RTS	PC			;RETURN

;HERE WHEN END OF CALL DELAY EXPIRES

DNTMEC:	JSR	PC,DNADDR		;GET DNTAB AND HDW ADDRESSES
	BR	DNFAIL			;CALL FAILED

;HERE WHEN DIGIT TIMER EXPIRES
;	ONLY HAPPENS IF DIALER NOT WORKING

DNTMDG:	JSR	PC,DNADDR		;SETUP R1 &R2 TO POINT TO DNTAB & HDW
	BR	DNFAIL			;CALL FAILED

;HERE WHEN DLO CLEAR TIMER EXPIRES

DNTMDL:	JSR	PC,DNADDR		;GET HARDWARE AND DNTAB
	BIT	#DN.DLO,@R2		;DATA LINE OCCUPIED STILL ON?
	BNE	DNFAIL			;YES, MUST BE BROKEN
DNBEGN:	MOVB	#<100*TMDGT+DN.TDG>,DB.DNT(J)	;START DIGIT TIMER
	BIS	#DN..CR!DN..IE,@R2	;SET CALL REQUEST
	RTS	PC			;EXIT

;SUBROUTINE TO GET DNTAB ADDRESS IN R1, DN STATUS REG ADDRESS IN R2
; DESTROYS R0

DNADDR:	MOVB	DB.DNS(J),R0		;DNTAB DISPLACEMENT
	BIC	#177700,R0		;CLEAR UNWANTED BITS
	ASL	R0			;TIMES 2.
	ASL	R0			;TIMES 4.
	ASL	R0			;TIMES 8.
	MOV	R0,R1			;SAVE FOR LATER
	ASL	R0			;TIMES 16.
	ADD	R0,R1			;TIMES 24.
	ADD	#DN0BLK,R1		;PLUS ADDRESS OF FIRST
	MOV	@R1,R2			;GET HARDWARE ADDRESS
	RTS	PC

.ENDC;.IF NE FTDN11
