.SBTTL	DNLBLK - LINE BLOCKS  23-OCT-87

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1976,1977,1978,1979,1980,1981,1984,1987,1988.
;ALL RIGHTS RESERVED.

VRLBLK=023			;FILE EDIT NUMBER

.IF NE NTLINE

;		*** CAUTION ***
;	UNUSED LINE BLOCKS MAY BE INTENTIONALLY OVERWRITTEN

;
;NOTE THE FOLLOWING - TO HELP UNDERSTAND THIS MACRO
;
;Q IS THE DDCMP LINE INDEX (INCREMENTED FOR EACH NEW LINE)
;ITS VALUE IS ALSO CALLED 'Z'. Q MUST BE SPECIFIED.
;FOR SYNCH POINT TO POINT LINES QQ,QQQ,QQA ARE ALL BLANK
;
;QQ IS THE MULTIPOINT DH LINE # (QQ IS  BLANK FOR POINT TO POINT LINES)
;THE VALUE OF QQ IS 'ZZZ' (THE PHYSICAL LINE INDEX)
;
;QQQ IS THE MULTIPOINT STATION INDEX (FOR EACH LINE THE FIRST STATION HAS QQQ=0,
;THE SECOND HAS QQQ=2, ETC.)
;QQQ IS ALSO CALLED 'ZZW'.
;QQQ IS 0 FOR TRIBUTARY LINES AND BLANK FOR POINT TO POINT LINES
;
;QQA IS MULTIPOINT LINE INDEX (=0 FOR FRIST LINE =1 FOR SECOND ETC.)
;QQA IS ALSO CALLED 'ZZX'.
;QQA IS BLANK FOR ALL BUT MULTIPOINT MASTER LINES
;
;ZZ IS THE BIT MASK FOR THE PHYSICAL LINE
;AND ZZY IS THE DH DEF BLOCK ADR, OR 0
;
;
;
;	COUNT THE TOTAL NUMBER OF LINE BLOCKS
	LBTOT=0

	.MACRO	TOTLB	QTOT,QINDX
		QTOT=QTOT+M$'QINDX
	.ENDM	TOTLB
	NXTDZ=-1
	.REPT	NDZMPT
		.NXTDZ	MPT
		TOTLB	LBTOT,\NXTDZ
	.ENDR

	NXTDH=-1
	.REPT	NDHMPT
		.NXTDH	MPT
		TOTLB	LBTOT,\NXTDH
	.ENDR
	LBTOT=LBTOT+NLINES+NALINE+NTRIB-1
;
;
;
.MACRO	X	Q,QQ,QQQ,QQA
.IF NDF L'Q'LVL
	.IIF EQ ZZY,L'Q'LVL=SLNLVL	;DEFAULT SYNC LINE "COST"
	.IIF NE ZZY,L'Q'LVL=ALNLVL	;DEFAULT ASYNC LINE "COST"
.ENDC;NDF L'Q'LVL
.IIF NE,<<OLDLB+LB.SIZ>-.>,.PRINT .-OLDLB;LINE BLOCK GENERATION ERROR
OLDLB=.
.IF B,QQ
LBLK'Q:
.IF NE,FTDCP1!FTDCP3!FTDCP4
	.MACRO	NSP,A,B,C,D,E,F,G,H
		.IF EQ,<Z-A>		;IF SAME AS THIS LINE
			NSPTHS=1	;INDICATE THIS IS NSP LINE
		.ENDC
	.ENDM	NSP
	.MACRO	NSP3,A,B,NOD
		.IF EQ,<Z-A>
			NSPTHS=1
		.ENDC
	.ENDM
	.MACRO	DCP4LN,QLN,QOB,QVN,QVS,QHN,QHS,QCN
		.IF EQ,<Z-QLN>
			NSPTHS=1
		.ENDC
	.ENDM

	NSPTHS=0			;SET NSP LINE FLAG TO 0
	NSPLST				;IF THIS IS NSP LINE, NSPTHS WILL BE 1

	.IF NE,NSPTHS
		.WORD	LS.NSP				;LB.STS
	.IFF
		.WORD	0				;LB.STS
	.ENDC
.IFF
	.WORD	0					;LB.STS
.ENDC; NE,FTDCP1!FTDCP3!FTDCP4
.IFF; B,QQ
 .IF EQ,QQQ
LBLK'Q:
  .IF NB,<QQA>
   .IIF NE FT.RDM!FT.RDP,R'QQA'STS:
  .ENDC; NB, <QQA>
 .ENDC; EQ,QQQ
 .IF NB,<QQA>
L'QQA'.'QQQ:						;LABEL TO HELP WITH DDT
 .ENDC; NB,<QQA>
	.WORD	LS.MPT					;LB.STS
.ENDC; B,QQ
	ZZ2=0
.IF NE FT.DDP
  .IF DF L'Q'DDP
    .IIF NE L'Q'DDP,ZZ2=ZZ2!L2.DDP			;DDP LINE IF LnDDP SET
  .ENDC; DF L'Q'DDP
.ENDC; NE FT.DDP
	.WORD	ZZ2					;LB.ST2
.IF NE,LBTOT
	LBTOT=LBTOT-1
	.+LB.SIZ-LB.LNK					;LB.LNK
.IFF; NE,LBTOT
	.WORD	0					;LB.LNK
.ENDC; NE,LBTOT
.IF NE FT.DDP
	.WORD	DP'Q'DDB				;LB.DDB
.ENDC ;.IF NE FT.DDP
	ZZ						;LB.BIT
	.BYTE	ZZZ					;LB.LNU
.IF EQ,ZZY
  .IF LT <DQNU-DQN>
    .IIF EQ,DQNU,FLBDQ=OLDLB
    .BYTE LS..DQ
    DQNU=DQNU+1
  .IFF
    .IF LT <DMCNU-DMCN>
      .IIF EQ,DMCNU,FLBDMC=OLDLB
      .BYTE LS..DM
      DMCNU=DMCNU+1
    .IFF
      .IF LT <DUPNU-DUPN>
        .IIF EQ,DUPNU,FLBDUP=OLDLB
        .BYTE LS..UP
        DUPNU=DUPNU+1
      .IFF
        .IF LT <DSNU-DSN>
          .IIF EQ,DSNU,FLBDS=OLDLB
          .BYTE LS..DS
          DSNU=DSNU+1
        .IFF
          .IF LT <DUNU-DUN>
            .IIF EQ,DUNU,FLBDU=OLDLB
            .BYTE LS..DU
            DUNU=DUNU+1
          .IFF
            .IF LT <DPNU-DPN>
	      .IIF EQ,DPNU,FLBDP=OLDLB
              .BYTE LS..DP
              DPNU=DPNU+1
            .IFF
              .IF LT <DVNU-DVN>
                .IIF EQ,DVNU,FLBDV=OLDLB
                .BYTE LS..DV
                DVNU=DVNU+1
              .IFF
                .PRINT ;LINE BLOCK DEVICE TYPE ERROR: DQ USED
                .BYTE LS..DQ
              .ENDC
            .ENDC
          .ENDC
        .ENDC
      .ENDC
    .ENDC
  .ENDC
.IFF; EQ,ZZY
  .IF EQ ASYDEV-ASY.DH
	.BYTE	LS..DH
    .IFF
	.BYTE	LS..DZ
    .ENDC
.ENDC; EQ,ZZY
	L'Q'LVL						;LB.LVL
	ZZY						;LB.DHB OR LB.SLA
.IF EQ,ZZY
	.WORD	0					;LB.SLA
.IFF; EQ,ZZY
	.IF EQ ASYDEV-ASY.DH
		.WORD ZZZ&17				;LB..LN
	.IFF
		.WORD	ZZZ&7
	.ENDC
.ENDC; EQ,ZZY
.IF NE,NALINE!NMPTL!NTRIB
 .IF NE,ZZY
    .IF EQ ASYDEV-ASY.DH
	ZZY+DHB.LC+<<ZZZ&17>*LC..SZ>			;LB.LCB
     .IFF
	ZZY+DZB.LC+<<ZZZ&7>*LC..SZ>
    .ENDC
 .IFF; NE,ZZY
	.WORD	0					;LB.LCB
 .ENDC;NE,ZZY
.ENDC; NE,NALINE!NMPTL!NTRIB
.IF NE,FT.MPT
 .IF NB,QQ
  .IF NB,QQA
   .IF EQ,QQQ-M$'QQ+1
	.-LB.MPL-<LB.SIZ*QQQ>				;LB.MPL
   .IFF; EQ,QQQ-M$'QQ+1
	.+LB.SIZ-LB.MPL					;LB.MPL
   .ENDC; EQ,QQQ-M$'QQ+1
  .IFF; NB,QQA
	.WORD	0					;LB.MPL
  .ENDC; NB,QQA
	.WORD	0					;LB.MPN
	.BYTE	Y'QQ'$'QQQ				;LB.MPA
  .IF NB,<QQA>
   .IF EQ,QQQ-M$'QQ+1
	.BYTE	MP.STV					;LB.MPT
   .IFF; EQ,QQQ-M$'QQ+1
	.BYTE	0					;LB.MPT
   .ENDC; EQ,QQQ-M$'QQ+1
  .IFF; NB,<QQA>
	.BYTE	0					;LB.MPT
  .ENDC; NB,<QQA>
  .IF NE,FT.RDM
   .IIF NB <QQA>, .WORD MP.OFF  			;LB.MPS
   .IIF B <QQA>, .WORD <MP.RTS!MP.CMS*400>+MP.SNM 	;LB.MPS
  .IFF; NE,FT.RDM
   .IF NB,<QQA>
    .IF EQ,QQQ-M$'QQ+1
	.WORD	MP.SEL!MP.SNM!MP.SFC			;LB.MPS
    .IFF; EQ,QQQ-M$'QQ+1
	.WORD	MP.SFC					;LB.MPS
    .ENDC; EQ,QQQ-M$'QQ+1
   .IFF; NB,<QQA>
	.WORD	<MP.RTS!MP.CMS*400>+MP.SNM		;LB.MPS
   .ENDC; NB,<QQA>
  .ENDC; NE,FT.RDM
 .IFF; NB,QQ
	.WORD	0					;LB.MPL
	.WORD	0					;LB.MPN
	.BYTE	A0					;LB.MPA
	.BYTE	0					;LB.MPT
	.WORD	0					;LB.MPS
 .ENDC; NB,QQ
.ENDC; NE,FT.MPT
.IF NE,FTDCP1
	.MACRO	NSP,LIN,VNNM,VSNM,VSID,VDAT,VDNA,VMML,VCNF
		.IF EQ,<Z-LIN>
			.WORD	0			;LB.NSS
			.BYTE	VNNM			;LB.NNM
			.BYTE	VDNA			;LB.DNA
			.WORD	VMML			;LB.MML
			EASCII	SNMSIZ,<VSNM>,FILL	;LB.SNM
			EASCII	SIDSIZ,<VSID>,FILL	;LB.SID
			EASCII	DATESZ,<VDAT>,FILL	;LB.DAT
			.IF NE,NSPCFS	;IF THERE IS A CONFIGURATION FIELD
				NSPZZ=0	;COUNT OF CONFIG BYTES USED BY THIS LINE
				.IRP	ENTRY,<VCNF>;REPEAT FOR EACH CONFIGURATION
					.IF NB,<ENTRY>
						.BYTE	ENTRY	;OBJECT TYPE, NUMBER
						NSPZZ=NSPZZ+2	;COUNT THIS ENTRY
					.ENDC; NB,<ENTRY>
				.ENDM;	.IRP ENTRY,VCNF
			.ENDC; NE,NSPCFS
			NSPZZ=NSPCFS-NSPZZ	;GET UNUSED SPACE
			.REPT	NSPZZ		;FILL OUT CONFIG FIELD WITH 0
				.BYTE	0	;ZERO UNUSED CONFIG ENTRY
			.ENDR;	NSPZZ
			.EVEN
		.ENDC; EQ,<Z-LIN>
	.ENDM	NSP
	.MACRO	NSP3,A,B,NOD
	.ENDM
	.MACRO	DCP4LN,QLN,QOB,QVN,QVS,QHN,QHS,QCN
	.ENDM
	NSPLST					;WILL GENERATE DATA IF NSP LINE
	.IF EQ,NSPTHS				;IF IT WASN'T NSP LINE
		.REPT	<<6+SNMSIZ+SIDSIZ+DATESZ+NSPCFS>+1>&177776;SIZE OF NSP AREA
			.BYTE	0			;FILL WITH ZEROS
		.ENDR;	.REPT <<SNMSIZ+SIDSIZ+DATESZ+6>+1>&177776
	.ENDC; NE,NSPTHS
.ENDC; NE,FTDCP1

.IF NE FTDCP3!FTDCP4
	.MACRO	NSP,A,B,C,D,E,F,G,H
	.ENDM

	.MACRO	NSP3,QAZ,QBZ,NOD
		.IF EQ,<QAZ-Z>
			.BYTE	NOD			;LB.VNN
			NSPZZ=0
			.IRP	OPT,<QBZ>
				.BYTE	OPT		;LB.CNF+?
				NSPZZ=NSPZZ+2
			.ENDM
			NSPZZ=NSP$MX-NSPZZ+1
			.REPT	NSPZZ
				.BYTE	-1
			.ENDR
		.ENDC
	.ENDM

	.MACRO	DCP4LN,QLN,QOB,QVN,QVS,QHN,QHS,QCN
		.IF EQ,<Z-QLN>
			.BYTE	QVN			;LB.VNN
			EASCII	SNMSIZ,<QVS>,0		;LB.VNM
			.BYTE	QHN			;LB.HNN
			EASCII	SNMSIZ,<QHS>,0		;LB.HNM
			.BYTE	QCN			;LB.CNN
			NSPZZ=0
			.IRP	OPT,<QOB>
				.BYTE	OPT		;LB.CNF+?
				NSPZZ=NSPZZ+2
			.ENDM
			NSPZZ=NSP$MX-NSPZZ+1
			.REPT	NSPZZ
				.BYTE	-1
			.ENDR
		.ENDC
	.ENDM

	NSPLST

	.IF EQ,NSPTHS
		.REPT NSP$MX+1+SNMSIZ+1+SNMSIZ+1
			.BYTE	0
		.ENDR
	.ENDC
.ENDC	;NE FTDCP3!FTDCP4

.EVEN
.REPT <LB.SIZ-LB.OCN>
	.BYTE	0
.ENDR
.ENDM	X

	Z=0
	ZZ=1
	ZZZ=0
	ZZY=0
	ZZX=0
	DUPNU=0
	DQNU=0
	DMCNU=0
	DSNU=0
	DUNU=0
	DVNU=0
	DPNU=0
	OLDLB=.-LB.SIZ
.REPT	NLINES
	X	\Z
	Z=Z+1
	ZZ=ZZ*2
	ZZZ=ZZZ+1
.ENDR; NLINES
LBLIM:
.IF NE NALINE!NMPTL!NTRIB
	.MACRO XX	TYPE
		.NXTDH	TYPE
		ZZZ=NXTDH
		ZZ=1
		.REPT	ZZZ&17
			ZZ=ZZ*2
		.ENDR
		ZZY=DH0BLK+<<ZZZ/20>*DHB.SZ>
	.ENDM	XX
	NXTDH=-1
	.MACRO XXDZ	TYPE
		.NXTDZ	TYPE
		ZZZ=NXTDZ
		ZZ=1
		.REPT	ZZZ&7
			ZZ=ZZ*2
		.ENDR
		ZZY=DZ0BLK+<<ZZZ/10>*DZB.SZ>
	.ENDM	XXDZ
	NXTDZ=-1
	ASYDEV=ASY.DH
	.REPT	NADHLN
		XX	PTP
		X \Z
		Z=Z+1
		DHINDX=DHINDX+1
	.ENDR
	ASYDEV=ASY.DZ
	.REPT	NADZLN
		XXDZ	PTP
		X	\Z
		Z=Z+1
		DZINDX=DZINDX+1
	.ENDR
	.MACRO	XXX	QN
		ZZW=0
		.REPT	M$'QN
			X	\Z,\ZZZ,\ZZW,\ZZX
			ZZW=ZZW+1
		.ENDR
	.ENDM	XXX
	NXTDZ=-1
	NXTDH=-1
LBAMPT:
	ASYDEV=ASY.DH
	.REPT	NDHMPT
		XX	MPT
		XXX	\ZZZ
		DHINDX=DHINDX+1
		ZZX=ZZX+1
		Z=Z+1
	.ENDR
	ASYDEV=ASY.DZ
	.REPT	NDZMPT
		XXDZ	MPT
		XXX	\ZZZ
		DZINDX=DZINDX+1
		ZZX=ZZX+1
		Z=Z+1
	.ENDR
	NXTDZ=-1
	NXTDH=-1
LBATRB:
	ASYDEV=ASY.DH
	.REPT	NDHTRB
		XX	TRIB
		X	\Z,\ZZZ,0
		DHINDX=DHINDX+1
		Z=Z+1
	.ENDR
	ASYDEV=ASY.DZ
	.REPT	NDZTRB
		XXDZ	TRIB
		X	\Z,\ZZZ,0
		DZINDX=DZINDX+1
		Z=Z+1
	.ENDR
.ENDC

.ENDC ; .IF NE NTLINE

.IF DF FIRZER
Q=<FIRZER+3777>
.IF LT Q
	Q=<<Q&77777>/4000>+20
.IFF
	Q=Q/4000
.ENDC
.PRINT	Q	;size of program in octal K words
.ENDC
	.EVEN
FIRZER:			;FIRST LOCATION TO ZERO ON A RESTART
.IF NE NDH11

;HERE FROM CHK11 WHEN HAVE FOUND ANOTHER DH11
CKADH1:	SAVE	<R3>
	MOV	#DH0BLK,R3		;GET ADDRESS OF 1ST DH11 BLOCK
10$:	CMP	@R0,@R3
	BEQ	20$
	TST	@R3			;DOES THIS BLOCK HAVE ANDDRESS YET ?
	BEQ	20$			;IF NOT WE ARE DONE
	ADD	#DHB.SZ,R3		;ADVANCE TO NEXT DH11 BLOCK
	CMP	#DHBLIM,R3		;IS THAT TOO FAR ?
	BNE	10$
	BR	30$
20$:	MOV	@R0,@R3			;SAVE ADDRESS OF DH11
	MOV	2(R0),DHB.VC(R3)	;SAVE VECTOR ALSO
30$:	RESTORE	<R3>
	RTS	PC

.IF NE FTDM11
CKADM1:	SAVE	<R3>
	MOV	#DH0BLK,R3		;POINT TO FIRST DH11 BLOCK
10$:	CMP	@R0,DHB.DM(R3)		;THIS WILL MATCH ON A RESTART
	BEQ	20$
	TST	DHB.DM(R3)		;DOES THIS BLOCK HAVE DM11 YET ?
	BEQ	20$			;IF NOT THIS IS THE PLACE
	ADD	#DHB.SZ,R3		;POINT TO NEXT DH11 BLOCK
	CMP	#DHBLIM,R3		;EXCEEDED GOOD TASTE ?
	BNE	10$			;NOT YET
	BR	90$			;IGNORE
20$:	MOV	@R0,DHB.DM(R3)		;SAVE DM11 HDW ADR
	;MOV	2(R0), ???		;SAVE DM11 VECTOR ADR
90$:	RESTORE	<R3>
	RTS	PC
.ENDC;.IF NE FTDM11

.ENDC;.IF NE NDH11
.IF NE NDZ11

;HERE FROM CHK11 WHEN HAVE FOUND ANOTHER DZ11
CKADZ1:	SAVE	<R3>
	MOV	#DZ0BLK,R3		;GET ADDRESS OF 1ST DZ11 BLOCK
10$:	CMP	@R0,@R3
	BEQ	20$
	TST	@R3			;DOES THIS BLOCK HAVE ANDDRESS YET ?
	BEQ	20$			;IF NOT WE ARE DONE
	ADD	#DZB.SZ,R3		;ADVANCE TO NEXT DZ11 BLOCK
	CMP	#DZBLIM,R3		;IS THAT TOO FAR ?
	BNE	10$
	BR	30$
20$:	MOV	@R0,@R3			;SAVE ADDRESS OF DZ11
	MOV	2(R0),DZB.VC(R3)	;SAVE VECTOR ALSO
30$:	RESTORE	<R3>
	RTS	PC
.ENDC;.IF NE NDZ11
.IF NE NLINES
.IF NE FTDP11

CKADP1:	SAVE	<R1,R2,R3,J>
	MOV	#FLBDP,J		;point to first possible line block
	MOV	#FLBDP+<LB.SIZ*DPN>,R2	;and to limit
	JSR	PC,CKADEV		;GO TO COMMON CODE
	  NOP
	BR	CKARET
.ENDC;IF NE,FTDP11
.IF NE FTDQ11

CKADQ1:	SAVE	<R1,R2,R3,J>
.IIF NDF SPCVFY,SPCVFY=0
.IF NE SPCVFY
	MOV	6(R0),R1		;GET NUMBER OF SPECIAL CHARS
	BPL	10$
	JSR	R0,80$			;COMPLAIN ABOUT PROBLEM
	.ASCIZ	\	int for sync char\
	.EVEN
10$:	BIC	#^C7,R1			;FIND HOW MANY SPECIAL CHARS
	CMP	#3,R1
	BEQ	12$
	JSR	R0,80$
	.ASCIZ	\	wrong num spec char\
	.EVEN
	BR	20$
12$:	MOV	#SOH,R1			;CHAR TO MATCH
	JSR	PC,30$			;TRY TO
	MOV	#ENQ,R1
	JSR	PC,30$
	MOV	#DLE,R1
	JSR	PC,30$
.IFTF
20$:
	MOV	#FLBDQ,J
	MOV	#FLBDQ+<DQN*LB.SIZ>,R2
	JSR	PC,CKADEV		;GO TO COMMON CODE
	  NOP
	BR	CKARET
.IFT
30$:	MOV	R0,R3			;COPY BLOCK POINTER
	ADD	#10,R3			;POINT TO SPECIAL CHARS
	CMP	R1,(R3)+		;IS CHAR RIGHT ?
	BEQ	70$
	CMP	R1,(R3)+		;TRY NEXT SLOT
	BEQ	70$
	CMP	R1,(R3)+
	BEQ	70$
;HERE WHEN SPECIAL CHARACTERS ARE NOT RIGHT
40$:	MOV	R0,-(P)			;SAVE BLOCK POINTER
	JSR	R0,80$			;FLAG DQ11 IS BUM
	.ASCIZ	\	spec char must be 201 5 220 but are \
	.EVEN
	MOV	@P,R3			;GET BLOCK POINTER
	ADD	#10,R3			;POINT TO SPEC CHARS
	MOV	(R3)+,R0		;GET 1ST SPEC CHAR
	JSR	PC,60$
	MOV	(R3)+,R0		;GET 2ND SPEC CHAR
	JSR	PC,60$
	MOV	(R3)+,R0		;GET THIRD SPEC CHAR
	JSR	PC,60$
	MOV	(P)+,R0			;GET BLOCK POINTER BACK
	TST	(P)+			;CLEAN OF RETURN ADDRESS
	BR	20$
60$:	JSR	PC,CKTOCT
	JSR	R0,CKTSTR
	.ASCIZ	\ \
	.EVEN
70$:	RTS	PC

;HERE TO COMPLAIN ABOUT A BUM DQ11
80$:	BIS	#CKFERR,CHKFLG		;REMEMBER THIS IS A BUM DQ11
	SAVE	<R0,R1>
	JSR	PC,CKDIDT
	RESTORE	<R1,R0>
	PJMP	CKTCRL			;THEN TYPE MSG

.ENDC;.IF NE SPCVFY
.ENDC;.IF NE FTDQ11

.IF NE,NTLINE
CKARET:	RESTORE	<J,R3,R2,R1>
	RTS	PC
.ENDC;.IF NE,NTLINE

.IF NE FTDS11

CKADS1:	SAVE	<R1,R2,R3,J>
	MOV	#FLBDS,J
	MOV	#FLBDS+<LB.SIZ*DSN>,R2
	JSR	PC,CKADEV		;GO TO COMMON CODE
	  NOP
	BR	CKARET

.ENDC;.IF NE FTDS11
.IF NE,DMCN
CKAMC1:
	SAVE	<R1,R2,R3,J>
	MOV	#FLBDMC,J
	MOV	#FLBDMC+<LB.SIZ*DMCN>,R2
	JSR	PC,CKADEV
	  BR	10$
20$:
	MOV	SELBLK,J
	MOVB	#LS..DM,LB.DVS(J)
	TST	DMCLB0
	BNE	21$
	MOV	J,DMCLB0
21$:
	MOV	DMCBS,LB.BAS(J)
	ADD	#256.,DMCBS
10$:
	RESTORE	<J,R3,R2,R1>
	RTS	PC
DMCBS:	.WORD	DMBAS0
.ENDC;.IF NE,DMCN
.IF NE FTDUP11
CKAUP11:
	SAVE	<R1,R2,R3,J>
	MOV	#FLBDUP,J
	MOV	#FLBDUP+<LB.SIZ*DUPN>,R2
	JSR	PC,CKADEV
	  BR	CKARET
	BR	CKARET
.ENDC ;IF NE FTDUP11


;Subroutine to assign synchronous line to line block
;call
;	MOV	#FLBxxx,J	;point to first line block
;	MOV	#FLBxxx+<xxxN*LB.SIZ>,R2;limit of this type of line block
; 	JSR	PC,CKADEV
;	error return		(too many lines)
;	normal return

CKADEV:					;here to select proper line block
10$:	TST	LB.SLA(J)		;DOES THE BLOCK POINT TO A UNIT ?
	BEQ	20$			;IF NOT USE IT
	CMP	0(R0),LB.SLA(J)		;OR IS THE SAME AS ONE WE SAW BEFORE ?
	BEQ	20$
	JSR	R1,40$			;SKIP TO NEXT LINE BLOCK
	BR	10$			;LOOP IF ONE FOUND
	NOP				;NEEDED AS FILL
15$:	MOV	#NOP,CKDON3		;COMPLAIN LATER
	BR	99$			;TOO MANY UNITS(IGNORE EXTRA)
20$:	MOV	0(R0),LB.SLA(J)		;SAVE ADR OF HDW
	MOV	2(R0),LB.SLV(J)		;SAVE VECTOR ADR
	MOV	J,SELBLK		;SAVE BLOCK ADDRESS
	JSR	R1,40$			;SKIP TO NEXT LINE BLOCK
	  CLR	LB.SLA(J)		;CLEAR HARDWARE ADDRESS IN CASE CHK11 IS RESTARTED
	ADD	#2,(SP)			;SKIP RETURN
99$:					;restore regs and return
	RTS	PC
;
;
;HERE TO SKIP TO NEXT LINE BLOCK
40$:	MOV	LB.LNK(J),J		;GET ADR OF NEXT LINE BLOCK
	BEQ	41$			;SKIP ON EXIT IF NONE
	CMP	J,#LBLIM		;DON'T CHECK DH LINES
	BHIS	41$			;GO TAKE SKIP RETURN FOR DH HINES
	CMP	J,R2			;REACHED LIMIT OF THIS TYPE?
	BLO	42$			;NO, WE ARE OK
41$:	CMP	(R1)+,(R1)+		;SO SKIP IF FOUND A DH LINE OR RAN OUT
42$:	RTS	R1
SELBLK:	.WORD	0
.ENDC;.IF NE NLINES
;HERE TO SET UP INTERRUPT VECTORS FOR DQ11
CKDONE:

.IF NE FTDL10
	TST	DL10AD			; SEE IF WE FOUND DL10
	BNE	1$			; GOOD
	JSR	R0,CKTCRL		; TYPE ERROR
	.ASCII	/??No DL10 found by CHK11??/
	.BYTE	15,12,0
	.EVEN
	TRAP
1$:
.ENDC
;DELINK TTY DDB'S FOR WHICH THERE IS NO DH11 HDW
.IF NE NDH11
	MOV	#DH0BLK,R3		;GET FIRST DH11 BLOCK ADR
	MOV	#DHI0IN,R0		;ADDRESS OF 1ST DH11 INT LOC
	MOV	#DHO0IN,-(P)
10$:	TST	@R3			;IS THERE ANOTHER DH11 ?
	BEQ	40$
	MOV	DHB.VC(R3),R1		;GET INPUT VECTOR ADDRESS
	MOV	R0,(R1)+		;SET INPUT VECTOR
	MOV	#DH.LVL*40,(R1)+	;SET PS FOR INPUT INTERRUPT
	MOV	(P),(R1)+		;SET TRAP LOCATION
	MOV	#DH.LVL*40,(R1)+	;SET PS FOR TRANSMIT FLAGS
.IF GT NDH11-1
	ADD	#DHI1IN-DHI0IN,R0	;INPUT INT ROUT ADR FOR NXT LINE
	ADD	#DHO1IN-DHO0IN,(P)	;INPUT INT ROUT ADR FOR NXT LINE
.ENDC
	ADD	#DHB.SZ,R3		;POINT TO NEXT DH11 BLOCK
	CMP	#DHBLIM,R3		;IS THAT END OF DH11 BLOCKS ?
	BNE	10$
40$:	TST	(P)+			;POP INT LOC FROM STACK

90$:
.ENDC;.IF NE NDH11

DLNKDZ:
;DELINK TTY DDB'S FOR WHICH THERE IS NO DZ11 HDW
.IF NE NDZ11
	MOV	#DZ0BLK,R3		;GET FIRST DZ11 BLOCK ADR
	MOV	#DZI0IN,R0		;ADDRESS OF 1ST DZ11 INT LOC
	MOV	#DZO0IN,-(P)
10$:	TST	@R3			;IS THERE ANOTHER DZ11 ?
	BEQ	40$
	MOV	DZB.VC(R3),R1		;GET INPUT VECTOR ADDRESS
	MOV	R0,(R1)+		;SET INPUT VECTOR
	MOV	#DZ.LVL*40,(R1)+	;SET PS FOR INPUT INTERRUPT
	MOV	(P),(R1)+		;SET TRAP LOCATION
	MOV	#DZ.LVL*40,(R1)+	;SET PS FOR TRANSMIT FLAGS
.IF GT NDZ11-1
	ADD	#DZI1IN-DZI0IN,R0	;INPUT INT ROUT ADR FOR NXT LINE
	ADD	#DZO1IN-DZO0IN,(P)	;INPUT INT ROUT ADR FOR NXT LINE
.ENDC
	ADD	#DZB.SZ,R3		;POINT TO NEXT DZ11 BLOCK
	CMP	#DZBLIM,R3		;IS THAT END OF DZ11 BLOCKS ?
	BNE	10$
40$:	TST	(P)+			;POP INT LOC FROM STACK

90$:
.ENDC;.IF NE NDZ11

;DELINK DDBS WHICH DON'T HAVE HARDWARE
CKDON1:
.IF NE DEVN
	MOV	#30$,NXMVEC		;IN CASE DEVICE DOESN'T EXIST
	MOV	#FIRDDB-DB.LNK,J	;FAKE DDB
	BR	80$
26$:	CMP	-(P),-(P)		;PUSH TWO WORDS TO FAKE INTERRUPT
30$:	MOV	DB.LNK(J),DB.LNK(R0)	;DELINK LOSING DDB
	CMP	(P)+,(P)+		;POP PC, AND PS
	BR	82$			;AND CONTINUE WITH NEXT DDB
70$:	MOV	DB.HDW(J),R1		;GET HDW ADDRESS (NOTE DB.HDW=DB.DHB)
	BEQ	26$			;IF NO HDW, SIMULATE BUS TRAP
.IF NE TTYN
	BIT	#DS.TTY,@J		;IS THIS A TTY ?
	BEQ	77$
.IF NE FT.CTY
	CMP	J,#CTYDDB		;IS THIS THE CTY ?
	BEQ	80$
.ENDC;.IF NE FT.CTY
	MOV	@DB.DHB(J),R1		;GET ADDRESS OF DH11 HDW
	BEQ	26$			;IF NO DH11, SIMULATE BUS TRAP
.ENDC;.IF NE TTYN

77$:

.IF NE FT.RDM!FT.RDP!FT.RDA
	CMPB	#OBJRDE,DB.OBJ(J)	;IF RDE PSEUDO DEV
	BNE	78$
	MOV	DB.HDW(J),R1		;GET LINE BLOCK LIST
	MOV	@R1,R1			;GET THE DH11 HDW
	BEQ	26$			;IF NO DH11, SIMULATE BUS TRAP
.ENDC;.IF NE FT.RD?

78$:	TST	@R1			;DOES HDW EXIST ?
80$:	MOV	J,R0			;REMEMBER THE PREVIOUS DDB IN
					;CASE WE GET A BAD DDB
82$:	MOV	DB.LNK(J),J		;GET NEXT DEVICE BLOCK
	BNE	70$
	MOV	#NXMINT,NXMVEC		;RESTORE BUS TRAP ;HERE TO SET UP INTERRUPT VECTORS FOR DQ11

.ENDC;.IF NE DEVN
CKDON0:
.IF NE NLINES
	TST	LBLK0+LB.SLA		;IS THERE A SYNCH LINE ?
	BNE	CKDON3
	JSR	R0,CKTCRL
	.ASCII	\ ?? no synchronous lines ??\
	.BYTE	015,012,0
	.EVEN
CKDON3:	BR	1$
	JSR	R0,CKTCRL
	.ASCII	\hdw has more sync lines than software\
	.BYTE	015,012,0
	.EVEN
1$:
.ENDC ; .IF NE NLINES
.IF NE NTLINE

.MACRO	X	Q
	MOV	#D'Q'A.0,R0
	MOV	#D'Q'.LVL*40,R2
5$:	MOV	LB.SLV(J),R1
	MOV	R0,(R1)+
	MOV	R2,(R1)+
	ADD	#D'Q'B.0-D'Q'A.0,R0
	MOV	R0,(R1)+
	MOV	R2,(R1)+
.IF DF D'Q'C.0
	ADD	#D'Q'C.0-D'Q'B.0,R0
	MOV	R0,(R1)+
	MOV	R2,(R1)+
	ADD	#D'Q'D.0-D'Q'C.0,R0
	MOV	R0,(R1)+
	MOV	R2,(R1)+
.IIF DF D'Q'A.1, ADD	#D'Q'A.1-D'Q'D.0,R0
.IFF
.IIF DF D'Q'A.1, ADD	#D'Q'A.1-D'Q'B.0,R0
.ENDC;.IF DF D'Q'C.0
.ENDM	X
.IF NE FTDS11
	MOV	#FLBDS,J		;GET 1ST DS11 LINE BLOCK
	MOV	#DSN,R3			;GET NO OF DS11 LINES
	X	S			;GENERATE VECTOR
	MOV	LB.LNK(J),J		; POINT TO NEXT LINE
	SOB	R3,5$			;LOOP FILL DONE
.ENDC ; .IF NE FTDS11
10$:	MOV	#LBLK0,R1		;GET ADR OF FIRST LINE BLOCK
	MOV	R1,J			;AND COPY INTO J
.ENDC ; .IF NE NTLINE
.IF NE NLINES

40$:	MOV	R1,J
.ENDC ;.IF NE NLINES
.IF NE NTLINE
50$:	MOV	LB.LNK(J),R1
	BEQ	60$
.IF NE NALINE!NMPTL!NTRIB
	CMP	R1,#LBLIM		;BETTER CHECK SYNC LINES ONLY
	BHIS	51$
.ENDC
.IF NE NLINES
	TST	LB.SLA(R1)		;IS THERE A SYNCH LINE FOR BLOCK ?
	BNE	40$
.ENDC ; .IF NE NLINES

.IF NE NALINE!NMPTL!NTRIB
	BR	55$
51$:	MOV	LB.DHB(R1),R0		;GET DH BLOCK ADR
	BEQ	55$			;IF NONE,UNLINK BLOCK
	TST	(R0)			;IF HDW
	BEQ	55$
	MOV	R1,J			;TRY NEXT LINE BLOCK
	BR	50$
55$:	MOV	LB.LNK(R1),LB.LNK(J)	;UNLINK THE BLOCK
	BR	50$			;AND TRY NEXT ONE
.IFF
	BR	70$
.ENDC
60$:	MOV	J,R1
	ADD	#LB.SIZ,R1
70$:	CLR	LB.LNK(J)		;NO SO CLEAR LINK TO EMPTY BLOCK
.IFF
	MOV	#FIRZER,R1
.ENDC;.IF NE NTLINE
;LOCATE THE DYNAMIC STORAGE
	ADD	#CNKSIZ-1,R1		;PREPARE FOR ROUND OFF
	BIC	#CNKSIZ-1,R1		;MAKE ADR OF FIRST CHUNK
	MOV	R1,PRGEND		;SAVE IT


;	NOW START EVERY THING GOING
	JMP	BEGIN
