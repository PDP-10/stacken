.SBTTL	DNDL10 - PDP-10/PDP-11 INTERFACE  21 JUL 82

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
; 1976,1977,1978,1979,1980,1981,1984,1988.
;ALL RIGHTS RESERVED.

VRDL10=012			;FILE EDIT NUMBER

.IF NE FTDL10			;DON'T ASSEMBLE IF NO DL IS CONFIGURED

.SBTTL DL10 WINDOW

	BLOCK	DL		;THIS IS THE DL-10 WINDOW

	X	STS		;DL10 STATUS REGISTER
	X	,2		;UNUSED
	X	NAM		;PROGRAM NAME BYTE POINTER (SIXBIT)
	X	,1		;NOT USED
	X	11A		;PDP-11 ALIVE INDICATOR. INCREMENTED BY
				;  BY THE TEN ONCE/SECOND, SET TO 0 BY
				;  THE 11.  IF <2 THEN 11 IS ALIVE.
	X	STP		;STOP CODE (FOR WHEN -11 DIES)
	X	DWN		;3 STATE SWITCH
				;  1 => UP AND RUNNING
				;  0 => DOWN, COMPLAIN TO THE OPERATOR
				; -1 => DOWN BUT DON'T COMPLAIN
	X	UPT		;NOT USED?
	X	STA		;GLOBAL STATE WORD
	    DLS.DP=1			;DEPOSIT 11 CORE
	    DLS.EX=2			;EXAMIN 11 CORE
	    GBADDR=4			; DL.ADR IS BAD
	    GHOLD=10			; HOLD EVERYTHING

	X	ADR		;ADDRESS FOR EXAMINE/DEPOSITE IN 11 MEMORY
	X	DAT		;CONTENTS OF THE EXAMINE/DEPOSITE
	X	RLN		;MAXIMUM MESSAGE LENGTH 11 WILL ACCEPT
	X	MOD		;DL-10 MODIFICATION NUMBER
	    WINVER=1		;WINDOW VERSION NUMVER
	X	10A		;PDP-10 ALIVE INDICATOR.  INCREMEMTED BY
				;  THE 11 ONCE/SECOND, SET -1 BY THE 10.
				;  IF <= 1, THE 10 IS ALIVE
	X	10S		;STATUS OF THE 10
				;  0 => INITIAL VALUE.  NOTHING GOING ON
				;  1 => STARTED INITIALIZATION
				; -1 => UP AND RUNNING
	X	11S		;STATUS OF THE 11.
				;  0 => INITIAL VALUE.  NOTHING GOING ON
				;  1 => STARTED INITIALIZATION
				; -1 => UP AND RUNNING
	X	IST		;INPUT STATUS FLABS
				;  B1 = FIRST PART
				;  B2 = SECOND PART
	X	ICT		;INPUT COUNT (10'S POINT OF VIEW)
	X	IDT		;INPUT DATA APPEARS HERE
	X	,1		;SECOND INPUT POINTER'S COUNT
	X	,1		;SECOND INPUT POINTER'S DATA


	X	OST		;OUTPUT FLAGS
				;  B0 SAYS OUTPUT READY TO TO
				;  B1-B4 SPECIFY THE CONVERSION
				;      1 => LPT COMPRESSION
				;      2 => BINARY (12 BIT) CONVERSION
	X	OCT		;FIRST OUTPUT BUFFER'S LENGTH
	X	ODT		;FIRST OUTPUT BUFFER'S DATA
	X	,1		;SECOND BUFFERS COUNT
	X	,1		;SECOND BUFFERS DATA
	X	,1		;THIRD BUFFERS LENGTH
	X	,1		;THIRD BUFFERS DATA

;END OF DL-10 WINDOW

T10QUE:	.WORD	0		;FIRST WORD IS HEAD OF THE LIST
	.WORD	0		;SECOND WORK IS POINTER TO THE TAIL

DL10AD:	.WORD	100000		;THE DEFAULT DL10 ADDRESS
				; REAL VALUE PUT IN BY CHK11

.SBTTL DL10 PROTOCOL - QUEUE DATA OUT

;HERE TO QUEUE A MESSAGE TO THE 10

.IIF EQ NTLINE, DDQDAT:
DLQDAT:	MOV	#2,CN.TIM(R0)		;GIVE HIM UP TO 2 SEC TO GET SENT.
					;  (SHORT, BUT DL-10 IS FAST)
	TST	T10QUE			;IS THERE A FIRST ENTRY ?
	BNE	10$
	MOV	#1,DL.FLG		;SO WE LOOK AT DL10
	MOV	R0,T10QUE		;THIS IS IT
	BR	20$
10$:	MOV	T10QUE+2,R1		;GET ADR OF LAST MESSAGE IN QUEUE
	MOV	R0,CN.MLK(R1)		;LINK THIS MESSAGE TO LAST
20$:	MOV	R0,T10QUE+2		;THIS MESSAGE IS NOW LAST
	RTS	PC

;HERE FROM LOOP LEVEL TO SEE IF THE DL-10 WOULD LIKE ANY SERVICE
;  (INTERRUPTS FROM THE -10 DON'T DO ANYTHING EXCPET SET DL.FLG)

LOOPDL:	TST	#0			;IF 10 DIDN'T INTERRUPT,
DL.FLG=.-2
	BNE	LOPDL1
LOPDL0:	RTS	PC			;EXIT
LOPDL1:	CLR	DL.FLG			;HAVE RESPONDED TO INTERRUPT
	MOV	DL10AD,R4		;GET DL10 ADDRESS
	BIT	#DL.PEN,@R4		;IS WINDOW ENABLED ?
	BEQ	LOPDL0
	MOV	T10QUE,R3		;IS THERE STUFF TO GO TO THE 10 ?
	BEQ	LOPDL3
	MOV	DL.IST(R4),R1		;GET INPUT STATUS
	BEQ	LOPDL3			;IF TEN NOT READY DON'T BOTHER HIM
	MOV	CN.LEN(R3),R2		;GET MESSAGE SIZE
	MOV	R2,DL.ICT(R4)		;SO TEN KNOWS HOW MANY BYTES
	ADD	#CN.NCT,R3		;MAKE ADR OF 1ST DATA BYTE
12$:	ADVCNK	R3			;MOVE TO NEXT CHUNK IF NECESSARY
	MOVB	(R3)+,DL.IDT(R4)	;GIVE TEN A BYTE
14$:	SOB	R2,12$
	CLR	DL.IST(R4)		;FLAG WE GAVE IT TO HIM
	BIS	#DL.10I,@R4		;INTERRUPT THE 10
	MOV	T10QUE,R0		;GET ADR OF MSG WE JUST GAVE 10
	MOV	CN.MLK(R0),T10QUE	;REMOVE IT FROM THE QUEUE
	TRACE	NC
	JSR	PC,NCLODN		;GIVE MESSAGE BACK TO 10
	MOV	DL10AD,R4		;GET THE DL10 ADDRESS

;HERE TO SEE IF TEN WANTS TO OUTPUT
; REGISTER USAGE IN FOLLOWING IS:
;	@P = ADR OF 1ST CHUNK
;	R0 = CURRENT CHAR
;	R0 = POINTER TO FIRST CHUNK
;	R1 = COUNT OF BYTES LEFT IN DL10
;	R2 = POINTER TO NEXT BYTE IN MSG
;	R3 =
;	R4 = POINTER TO THE DL10 THEN LATER STATUS WORD
;	R5 = POINTER TO DL10 WINDOW
LOPDL3:	MOV	R4,R5			;COPY DL10 ADDRESS TO R5		
	MOV	DL.OST(R4),R4		;DOES 10 HAVE STUFF FOR US?
	BEQ	LOPDL0			;IF NOTHING WE ARE DONE
	MOV	#1,DL.FLG
	JSR	PC,GETCNK		;GET A CHUNK TO GET A MESSAGE FROM 10
	BEQ	LOPDL0			;IF NO CHUNKS TRY AGAIN LATER
	MOV	DL.OCT(R5),R1		;GET COUNT FOR HEADER
	ASSERT	NE			;BETTER BE NONZERO - ELSE 10 GOOFED
	CLR	CN.LEN(R0)		;INITIALIZE COUNT OF DATA
	MOV	R0,R2			;COPY ADR OF CHUNK
	ADD	#CN.NCT,R2		;POINT TO WHERE NCL HEADER WILL GO
	ADD	#DL.ODT,R5		;GET ADR OF DL10 POINTER
LOPDLX:	JSR	PC,DLCOPY		;COPY NCL HEADER TO CHUNK
	MOV	(R5)+,R1		;GET COUNT FOR USER PORTION
	BEQ	10$			;IF NONE WE HAVE ALL OF MESSAGE
	BIC	#^C06,R4		;WAS THIS FANCY DATA ?
	JSR	PC,@20$(R4)		;DISPATCH ON CODE TYPE
10$:	MOV	DL10AD,R5		;GET DL10 ADDRESS AGAIN
	CLR	DL.OST(R5)		;FLAG WE GOT IT
	BIS	#DL.10I,(R5)		;TELL 10 WE GOT IT BY INTERRUPTING HIM
	TRACE	NC
	MOV	TENSCB,SNA		;SOURCE IN CASE THIS WAS A NODEID
	JSR	PC,NCLIN0		;GIVE MSG TO NCL FOR DISPOSITION
	RTS	PC			;AND EXIT
20$:	50$				;CODE 0 = PLAIN VANILLA
	CMPRSL				;CODE 1 = LPT COMPRESSION
.IF NE FT.ANF
	COPBIN				;CODE 2 = BINARY (12 BITS TO 8)
.IFF
	23$				;CODE 2 = BINARY (12 BITS TO 8)
.ENDC ;.IF NE FT.ANF
	23$				;CODE 3 =
	23$				;CODE 4 =
	23$				;CODE 5 =
	23$				;CODE 6 =
	23$				;CODE 7 =
23$:	STOPCD	BDT			;BAD DATA TYPE FROM THE 10

;HERE TO GET UNCOMPRESSABLE DATA FROM 10
50$:	JSR	PC,DLCOPY		;GO DO 1ST HALF OF USER DATA
	MOV	(R5)+,R1		;GET COUNT FOR 2ND PORTION
	BEQ	54$			;BRANCH IF ALL DONE
	JSR	PC,DLCOPY		;TRANSFER NEXT PORTION
54$:	RTS	PC
;HERE TO COPY BINARY FROM 10 TO 11
; DATA IS READ WITH 12BIT DL10 BYTE POINTER, COUNT IN WINDOW IS 12 BIT BYTES
.IF NE FT.ANF
COPBIN:	JSR	PC,32$			;COPY FIRST PORTION
	ADD	#2,R5			;ADVANCE TO NEXT COUNT
	MOV	(R5)+,R1		;GET COUNT FOR OTHER SEGMENT
	BEQ	12$			;IF NONE JUST CLEAN UP
	JSR	PC,30$			;COPY 2ND PORTION
12$:	TST	R4			;WAS THERE A PARTIAL ?
	BNE	40$			;IF SO PUT INTO MSG ALSO
	RTS	PC			;ELSE DONE

30$:	TST	R4			;WAS THERE A PARTIAL ?
	BNE	36$
32$:	MOV	@R5,R3			;GET NEXT 12 BITS
	ASL	R3			;WANT TO GET HIGH ORDER 8 BITS
	ASL	R3
	ASL	R3
	ASL	R3
	JSR	PC,40$			;PUT HIGH ORDER BITS INTO MSG
	BIC	#^C170000,R3		;STRIP EXTRA BITS
	DEC	R1			;COUNT LAST 12-BITS OUT OF 10
	BNE	36$
	INC	R4			;FLAG HAD PARTIAL LEFT
	RTS	PC
36$:	ADD	@R5,R3			;GET NEXT 12 BITS
	JSR	PC,40$			;PUT NEXT BYTE INTO MSG
	JSR	PC,40$			;PUT NEXT BYTE INTO MSG
	DEC	R1			;COUNT LAST 12 BITS OUT OF 10
	BNE	32$
	CLR	R4			;FLAG NO PARTIAL
	RTS	PC

;HERE TO PUT NEXT BYTE INTO MSG
40$:	INC	CN.LEN(R0)		;COUNT BYTE INTO MSG
	SWAB	R3
	ADVCNK	R2 EXTEND		;GET ANOTHER CHUNK IF NECESSARY
	MOVB	R3,(R2)+		;PUT NEXT BYTE INTO MSG
42$:	RTS	PC			;RETURN
.ENDC ; .IF NE FT.ANF

;HERE TO GET LPT DATA FROM 10 AND COMPRESS IT
CMPRSL:	MOV	R0,-(P)			;SAVE POINTER TO 1ST CHUNK
	CLR	-(P)			;COUNT SO FAR
	MOV	R2,-(P)			;SAVE POINTER TO DATA
	CLR	R4			;NOTHING COMPRESSED YET
	JSR	PC,30$			;GO DO 1ST PORTION
	MOV	(R5)+,R1		;GET COUNT FOR NEXT PORTION
	BEQ	25$			;BRANCH IF DONE
	JSR	PC,30$			;DO NEXT PORTION
25$:	TST	R4			;ANY DATA COMPRESSED ?
	BEQ	26$
	TST	-(P)			;SO COUNT WORKS
	JSR	PC,40$			;PUT INTO MESSAGE
	TST	(P)+			;CLEAN STACK
26$:	MOV	(P)+,R2			;GET POINTER TO DATA OFF STACK
	MOV	(P)+,R1			;GET COUNT OFF STACK
	MOV	(P)+,R0			;GET POINTER TO MESSAGE
	ADD	R1,CN.LEN(R0)		;ACCUMULATE LENGTH
	INC	R1
	SUB	#2,R2			;POINT TO COUNT
27$:	TSTB	-(R2)			;GET MESSAGE TYPE
	BMI	27$			;LOOK FOR DLA
	INC	R2			;BACK TO COUNT FIELD
	TSTB	@R2			;CHECK FOR EXTENSIBLE
	BPL	29$
	MOV	R1,R3			;COPY MESSAGE LENGTH
	BIS	#200,R3			;PUT EXTENSIBLE BIT ON
	MOVB	R3,(R2)+		;PUT INTO MESSAGE
	ASL	R1
	SWAB	R1
29$:	MOVB	R1,@R2			;PUT LENGTH INTO MESSAGE
	RTS	PC			;NOW AT LAST PASS OFF MESSAGE
;LOOP TO GET LPT DATA FROM 10 AND COMPRESS IT
30$:	MOVB	@R5,R0			;GET NEXT BYTE
	TST	R4			;ANY COMPRESSED YET ?
	BEQ	35$			;IF NOT THIS IS FIRST
	CMP	R0,R3			;IS THIS CHAR SAME AS LAST ?
	BEQ	36$			;YES SO JUST COUNT IT
	JSR	PC,40$			;PUT OLD CHAR INTO MSG
35$:	MOV	R0,R3			;REMEMBER WHAT WE ARE COMPRRESSING
36$:	INC	R4			;COUNT IT
	CMP	R4,#37			;CHECK FOR TOO MANY
	BMI	39$
	CMP	R3,#40			;IS CHAR A BLANK ?
	BNE	38$			;IF NOT THIS IS IT
	CMP	R4,#77			;THIS IS LIMIT FOR BLANKS
	BMI	39$
38$:	JSR	PC,40$			;MUST GO INTO MESSAGE NOW
39$:	SOB	R1,30$			;LOOP FOR REST OF DATA
	ADD	#2,R5			;POINT TO NEXT PORTION OF DATA
	RTS	PC

;HERE TO PUT COMPRESSED CHAR INTO MESSAGE
40$:	CMP	R4,#1			;SINGLE OCCURANCE ?
	BEQ	46$			;IF SO JUST PUT IN AS IS
	CMP	#40,R3			;IS CHARACTER A BLANK ?
	BNE	44$			;NO
	BIS	#100,R4			;FLAG THIS IS BLANK COUNT
	ADVCNK	R2 EXTEND		;EXTEND THE ALLOCATION IF REQUIRED
	MOVB	R4,(R2)+		;PUT INTO THE MESSAGE
	BR	47$			;THEN DONE
44$:	BIS	#40,R4			;FLAG THIS IS REPITION COUNT
	ADVCNK	R2 EXTEND		;EXTEND THE ALLOCATION IF REQUIRED
	MOVB	R4,(R2)+		;PUT COUNT INTO MESSAGE
	INC	6(P)			;COUNT CHAR
46$:	BIS	#200,R3			;FLAG THIS IS CHAR
	ADVCNK	R2 EXTEND		;EXTEND THE ALLOCATION IF REQUIRED
	MOVB	R3,(R2)+		;PUT INTO MSG
47$:	INC	6(P)			;COUNT CHAR INTO MESSAGE
48$:	CLR	R4			;CLEAR COMPRESSION COUNT
	RTS	PC
;HERE TO COPY FROM 10 TO 11 WITHOUT BENEFIT OF TRANSLATION
DLCOPY:	ADD	R1,CN.LEN(R0)		;ACCUMULATE TOTAL LENGTH
65$:	ADVCNK	R2 EXTEND		;EXTEND THE ALLOCATION IF REQUIRED
	MOVB	@R5,(R2)+		;PUT DATA INTO MESSAGE
62$:	SOB	R1,65$
	ADD	#2,R5			;POINT TO NEXT WINDOW COUNT FIELD
	RTS	PC

.SBTTL		CLOCK ROUTINE

TENSEC:	BIT	#DL.PEN,@DL10AD	;IS PORT ENABLE UP
	BNE	TENUP		;IF SO, GO SEE IF WE REMEMBERED IT THAT WAY
	MOV	TENSCB,SB	;DID WE THINK DL WAS UP?
	BNE	TENDWN		; IF WE DID, THEN WE MUST CLEAN UP
	BIS	#DL.10I!DL.ERE!DL.INE,@DL10AD ;LET THE -10 KNOW WE'RE HERE
	RTS	PC		;AND JUST WAIT

;HERE IF THE DL-10 WENT AWAY (WE CAN'T JUST ASSUME THAT THE -10 IS
;  GONE. THIS MAY BE A SMP SYSTEM AND SOME OTHER CPU MAY STILL BE UP)

TENDWN:	CLR	TENSCB		;CLEAR OUR "DL IS UP" FLAG
;	CLR	SB.LBA(SB)	;CLEAR ROUTING THROUGH DL (ROUTE WILL CLEAR IT)
	BIS	#SBF.NK,(SB)	;FORCE A NAK
	BIT	#SF.HID,(SB)	;DID I HAVE HIS ID?
	BNE	10$		;IF SO, CAN'T KILL THE SCB (MAY BE MULTIPATH)
	CLR	(SB)		;IF NO ID, THEN NO CHANCE OF MULTIPATH

10$:	MOV	T10QUE,R0	;NOW QUEUE ALL UNSENT MSGS ON MSGRSQ
	BEQ	20$		;  THEY WILL BE RE-ROUTED NEXT JIFFY
	MOV	CN.MLK(R0),T10QUE ;  IFF THERE IS A PATH TO THE NODE
	JSR	PC,MSGREQ	;REQUEUE THE MESSAGE FOR NEXT TICK
	BR	10$		;LOOP UNTIL ALL MSGS REQUEUED

20$:	JSR	PC,ROUTE	;RECOMPUTE THE TOPOLOGY
	PJMP	SNDNGH		;TELL EVERYONE THE -10 IS GONE, RETURN TO LOOP.


;HERE IF THE DL-10 IS UP.  SEE IF WE REMEMBERED IT THAT WAY
TENUP:	MOV	TENSCB,SB	;DID WE THINK THE DL WAS UP?
	BNE	TENINI		;IF SO, MAKE SURE WE FINISHED INITIALIZATION

;HERE WE HAVE DISCOVERED THAT THE DL HAS JUST COME UP. 
;  FIRST WE CHECK IT A LITTLE, THEN WE MAKE AN SCB AND TRY TO INITIALIZE.
	MOV	DL10AD,R2	;GET THE ADDRES OF THE WINDOW
	ADD	#DL.DAT,R2	;  NOW GET ADDRESS OF THE DATA AREA
	MOV	#-1,(R2)	;STORE A -1 IN THE WINDOW
	INC	(R2)		;INCREMENT IT
	BEQ	10$		;NOW MAKE SURE THAT IT'S ZERO
.IIF EQ DGUTS,TRAP		;DL-10 IS ILL
5$:	RTS	PC		;RETURN AND HOPE IT GET'S BETTER.

10$:	JSR	PC,MAKSCB	;NEW NEIGHBOR!! MAKE HIM A FRESH SCB
	BCS	5$		;NO SCB'S. QUIT NOW (BUT TRY NEXT SECOND)
	MOV	SB,TENSCB	;REMEMBER THAT WE THINK DL-10 IS UP
	MOV	SB,SB.LBA(SB)	;SET UP THE INCESTUOUS ROUTING
	MOV	#SBF.IU,(SB)	;MARK THE SCB AS IN USE


;NOW TELL THE -10 THAT WE'RE UP TOO!

	ADD	#DL.NAM-DL.DAT,R2 ;RELOCATE R2 TO POINT TO THE NAME WORD
	MOVB	#'D-40,(R2)	;SEND OUR NAME TO THE -10
	MOVB	#'C-40,(R2)
	MOVB	#'7-40,(R2)
	MOVB	#'5-40,(R2)	
	CLRB	(R2)
	CLRB	(R2)

	MOV	DL10AD,R2	;RESET OUR DL-10 POINTER
	MOV	#MSGMAX,DL.RLN(R2) ;SET THE MAX RECORD LENGTH
	MOV	#WINVER,DL.MOD(R2) ;SET THE MODIFICATION NUMBER
	MOV	#1,DL.11S(R2)	;TELL THE -10 THAT WE ARE INITIALIZING
	BIS	#DL.10I,(R2)	;INTERRUPT THE 10



;HERE AFTER WE HAVE GIVEN NAME TO 10.  CHECK HOW INITIALIZATION IS PROGRESSING
TENINI:	MOV	DL10AD,R0	;GET DL10 ADDRESS
	TST	DL.11S(R0)	;ARE WE RUNNING ?
	BMI	10$		;IF SO JUST LEAVE
	TST	DL.10S(R0)	;CHECK 10 STATE
	BGE	10$		;IF STILL INITIALIZING WE ARE DONE
	MOV	#-1,DL.11S(R0)	;SET RUNNING FLAG
	JSR	PC,NCLRS9	;MAKE A NODE-ID FOR HIM
	MOV	DL10AD,R0	;GET DL10 ADDRESS BACK AGAIN

10$:	CLR	DL.11A(R0)	;FLAG DAS85 STILL ALIVE
	MOV	#T10QUE-CN.MLK,R0 ;GET ADDRESS OF TO-10 MSG QUEUE
	JSR	PC,TIMQUE	;CHECK FOR DEAD ENTRIES
	.WORD	20$		;WHERE TO GO IF DEAD ENTRY
	RTS	PC

;HERE IF FOR SOME REASON A MESSAGE DIDN'T GET SENT IN 2 SECONDS.
;  MOST LIKELY THE 10 IS AT A BREAK-POINT.  RE-QUEUE THE MSGS TO BE
;  SENT NEXT JIFFY.  THEY WILL TAKE A BETTER PATH IF THAT IS AVAILABLE.

20$:	TWIDDLE			;COUNT THE NUMBER MESSAGES NOT SENT
	JSR	PC,MSGREQ	;REQUEUE THE MESSAGE NEXT TICK
	RTS	PC		;ALL DONE, JIFFY CODE WILL RESEND

.SBTTL		INTERRUPT ROUTINE

DL.INT:	SAVE	<R0,R1>			;SAVE SOME REGISTERS
	MOV	@DL10AD,-(P)		;GET INTERRUPTING STATUS
	BIT	#DL.NXM!DL.WCO!DL.PAR,@P	;CHECK FOR ERROR STATUS
	BEQ	20$
.IF NE FT.HLP
	JSR	R0,CKTCRL
	.ASCIZ	\DL10 \
	.EVEN
	BIT	#DL.NXM,@P		;CHECK FOR NXM
	BEQ	12$
	JSR	R0,CKTSTR
	.ASCIZ	\NXM\
	.EVEN
12$:	BIT	#DL.PAR,@P		;CHECK FOR PARITY
	BEQ	14$
	JSR	R0,CKTSTR
	.ASCIZ	\PAR\
	.EVEN
14$:	BIT	#DL.WCO,@P		;CHECK FOR WCOV
	BEQ	16$
	JSR	R0,CKTSTR
	.ASCIZ	\WCO\
	.EVEN
16$:
	JSR	R0,CKTSTR
	.ASCIZ	\ ERROR\
	.EVEN
	MOV	6(P),R0			;GET ERROR PC
	JSR	PC,CKTYPC		;AND TYPE " @PC=<VALUE><CR><LF>"
.ENDC
	STOPCD	DL10
20$:	MOV	#1,DL.FLG		;FLAG 10 INTERRUPTED
	MOV	DL10AD,R0		;GET ADDRESS OF DL10
	BIS	#DL.11C,@R0		;CLEAR INTERRUPT
	MOV	NXMVEC,-(P)		;SAVE BUS TRAP VECTOR
	MOV	#60$,NXMVEC
	BIT	#DLS.EX,DL.STA(R0)	;WANT TO EXAMINE 11 CORE ?
	BEQ	30$
	MOV	@DL.ADR(R0),DL.DAT(R0)	;DO IT
	BIC	#DLS.EX,DL.STA(R0)	;FLAG WE DID IT
30$:	BIT	#DLS.DP,DL.STA(R0)	;WANT TO DEPOSIT ?
	BEQ	40$
	TWIDDLE	DL.ADR(R0)		;REMEMBER LAST DEPOSIT ADDRESS
	MOV	DL.DAT(R0),@DL.ADR(R0)	;DO IT
	BIC	#DLS.DP,DL.STA(R0)	;FLAG WE DID IT
40$:	MOV	(P)+,NXMVEC		;RESTORE BUS TRAP VECTOR
	TST	(P)+			;DROP STATUS FROM STACK
	RESTORE	<R1,R0>
	RTI

;HERE IF EXAMINE OR DEPOSIT RATES A BUS TRAP
60$:	BIS	#GBADDR,DL.STA(R0)	;TELL TEN HE'S DUMB
	BIC	#DLS.DP!DLS.EX,DL.STA(R0);AND WE HAVE DONE ALL WE WILL
	MOV	#40$,@P
	RTI

.ENDC;.IF NE FTDL10
