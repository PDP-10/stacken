.SBTTL	1.0 DNNSP 0.0 -- DECNET COMPATIBLE CODE  28 MAR 79
.IF NE,FTDCP1

VRNSP==011				;FILE EDIT NUMBER

;***********************************************************************
;
;
;	DNNSP 0.0 10-MAY-76 -- DECNET COMPATIBLE CODE	  
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979,1980,1981,1984 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;***********************************************************************


	.SBTTL	    1.1  NSPDEF 0.0 12-MAY-76 -- SYMBOL DEFINITIONS


;***********************************************************************
;
;	NSPDEF 0.0 12-MAY-76 -- SYMBOL DEFINITIONS	  
;
;***********************************************************************


	.SBTTL	         1.1.1  LEDEF 0.0 12-MAY-76 -- LINK ENTRY DEFS


;***********************************************************************
;
;	LEDEF 0.0 12-MAY-76 -- LINK ENTRY DEFS	  
;
;***********************************************************************


	BLOCK	LE
	XX	NSP			;NSP LINK ADDRESS
	XX	CON			;CONVERTED NCL LINK ADDRESS
	X	NCL			;NCL LINK ADDRESS
	XX	STS			;STATUS BITS
		LES.DV=B7		;DEVICE CONNECTION
		LES.WD=B6		;WAITING FOR DISCONNECT CONFIRM
		LES.FL=B5		;FLUSH OUTPUT TO NSP
		LES.SD=B4		;SEND DISCONNECT CONFIRM TO NSP
		LES.SL=B3		;SEND 0 LINK STATUS
	X	SIZ,0			;SIZE OF LINK TABLE ENTRY

LEPCNK=CNKSIZ/LE.SIZ			;NUMBER OF LINK ENTRIES PER CHUNK
NSPINT=B3				;INTERRUPT BIT IN MSGFLG
NSPCM=B1				;MESSAGE IS CM IF 1

	.SBTTL	    1.2  NSPDAT 0.0 10-MAY-76 -- DATA AREAS


;***********************************************************************
;
;	NSPDAT 0.0 10-MAY-76 -- DATA AREAS	  
;
;***********************************************************************



NSPCNT:	.WORD	0			;COUNT OF NCL SUBMESSAGE
NSPCVL:	.WORD	0			;VALUE OF COUNT (FOR LATER FILL-IN)
NSPMSG:	.WORD	0			;ADDRESS OF MESSAGE FOR NSP
NSPLB:	.WORD	0			;ADDRESS OF LINE BLOCK FOR DCP LINE
NSPMML:	.WORD	0			;MAXIMUM NSP DATA LENGTH
NSPFLG:	.BYTE	0			;FLAG BITS
NSPREA:	.BYTE	0			;STORAGE FOR REASON CODE

	NSP.ST=B7			;A ONE INDICATES WE ARE STRIPPING COUNT/TYPE FROM NCL DATA

NSPNCT:	.BYTE	0			;NCL NCT STORED HERE
NSPSRC:	.BYTE	0			;NSP SOURCE LINK ADDRESS
NSPDST:	.BYTE	0			;NSP DESTINATION LINK ADDRESS
NSPOPT:	.BYTE	0			;OPTIONAL DATA

	.EVEN

	.SBTTL	    1.3  NSPRSS 0.0 12-MAY-76 -- START ON LINE


;***********************************************************************
;
;	NSPRSS 0.0 12-MAY-76 -- START ON LINE	  
;
;***********************************************************************


; STACK LOOKS LIKE:
;	0	DDCMP RETURN ADDR

NSPRSS:					;HERE FROM DDCMP WHEN IT STARTS LINE
	MOV	LB.SCB(J),SB		;IS AN SCB ALREADY ATTACHED TO LINE?
	BEQ	10$			;NO, BRANCH
	CLR	LB.LCT(J)		;CLEAR LINK COUNT
	CLR	LB.LLE(J)		;CLEAR LAST POINTER ALSO
	MOV	LB.LKT(J),R0		;GET CHUNK ADDRESS
	BEQ	8$			;IF NONE, DONE
	JSR	PC,FRECKS		;FREE CHUNKS
	CLR	LB.LKT(J)		;CLEAR POINTER TO LINK TABLE
8$:					;HERE WHEN DONE CLEANING OUT LINK TABLE
	CLR	LB.SCB(J)		;YES, DETACH IT
	JSR	PC,ROUTE		;RE-ROUTE WITH THIS STATION MISSING
	JSR	PC,SNDNGH		;TELL EVERYONE HE IS NOW GONE
10$:
	JSR	PC,MAKSCB		;FIND A FREE SCB
.IF NE,DGUTS
	BCC	20$			;CONTINUE IF SUCCESSFUL
30$:
	BIC	#LS.XRP!LS.NRP!LS.STK,(J);CLEAR  ALL THE BITS DDCMP JUST SET
	BIS	#LS..ST,(J)		;MAKE LINE DO STARTS AGAIN
	RTS	PC			;AND RETURN TO TRY AGAIN LATER
20$:
.ENDC; NE,DGUTS
	MOVB	LB.NNM(J),R0		;GET NODE NUMBER TO USE FOR LIST LINE
	BIC	#177400,R0		;CLEAR HIGH ORDER BITS
	MOV	SB,-(SP)		;SAVE SCB ADDRESS
	JSR	PC,FNDSCB		;SEE IF A NODE WITH THIS NUMBER ALREADY EXISTS
	BEQ	40$			;NO, BRANCH; PHEW!
;HERE WHEN A NODE ALREADY EXISTS WITH THE NODE NUMBER ASSEMBLED FOR THIS DCP LINE
.IF NE,DGUTS
	TWIDDLE				;COUNT HOW OFTEN IT HAPPENDS
	BR	30$			;AND GO BACK TO STARTING THE LINE
.IFF; NE,DGUTS
	TRAP				;SOMEBODY GOOFED!
.ENDC; NE,DGUTS
40$:					;HERE IF NODE NUMBER OK
	MOV	(SP)+,SB		;GET BACK SCB ADDRESS
	MOV	SB,LB.SCB(J)		;POINT TO IT IN THE LINE BLOCK
	MOV	R0,SB.NNM(SB)		;SAVE NODE NUMBER IN THE SCB
	SAVE	<R0,R1,R2,R3>		;SAVE SOME REGISTERS
.IF NE,SNMSIZ				;IF LENGTH OF FIELD IS NOT ZERO
	JSR	PC,NSPCPY		;COPY STATION NAME
	.WORD	LB.SNM			;LINE BLOCK DISPLACEMENT
	.WORD	SB.SNM			;STATIONC CONTROL BLOCK DISPLACEMENT
	.WORD	SNMSIZ			;NUMBER OF BYTES TO COPY
.ENDC; NE,SNMSIZ
.IF NE,SIDSIZ				;IF FIELD LENGTH NOT ZERO
	JSR	PC,NSPCPY		;COPY STATION IDENTIFICATION TO SCB
	.WORD	LB.SID
	.WORD	SB.SID
	.WORD	SIDSIZ
.ENDC; NE,SIDSIZ
.IF NE,DATESZ				;IF FIELD LENGTH IS NOT ZERO
	JSR	PC,NSPCPY		;COPY DATA FROM LINE BLOCK TO SCB
	.WORD	LB.DAT
	.WORD	SB.DAT
	.WORD	DATESZ
.ENDC; NE,DATESZ
	RESTOR	<R3,R2,R1,R0>		;RESTORE THE REGISTERS
	BIS	#<SF.HID!SF.NSP!SBF.IC!SBF.IU!SBF.SQ>,(SB);SET BITS IN SCB: IN CONTACT, HAVE ID, IN USE, NSP LINE, AND SEQUENTIAL NODE
;	MOV	J,SB.LBA(SB)		;SAVE LINE FOR ROUTING
	CLR	LB.NSS(J)		;NO STATUS BITS YET
	JSR	PC,ADDSQN		;ADD A SEQUENTIAL NODE
	JSR	PC,ROUTE		;DO ROUTING
	JSR	PC,SNDNGH		;TELL EVERYONE ABOUT NEW NODE
	RTS	PC			;EXIT

	.SBTTL	    1.4  NSPOUT 0.0 10-MAY-76 -- SEND MSG TO NSP


;***********************************************************************
;
;	NSPOUT 0.0 10-MAY-76 -- SEND MSG TO NSP	  
;
;***********************************************************************


; STACK LOOKS LIKE:
;	0	DDQDAT + ? (DDCMP RETURN)
;	2	#JRSTR
;	4	J VALUE
;	6	NCR.10 + ? (NCL RETURN)
;	10	SB VALUE

; REGISTERS
;	R0	ADDRESS OF FIRST CHUNK OF NCL MESSAGE
;	R2	THE CHARACTER SOH (DDCMP PUT IT THERE)
;	SB	CONTAINS DNA VALUE (I.E. THE DCP SCB)
;	J	CONTAINS LINE BLOCK FROM SB.LBA(SB)

NSPOUT:					;DO OUTPUT TO NSP
	SAVE	<R5,R4,R2,R0>		;SAVE SOME REGISTERS

; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

	MOV	J,NSPLB			;SAVE LINE BLOCK ADDRESS
	MOV	CN.NCT(R0),R1		;GET NCT
	MOVB	R1,NSPNCT		;SAVE IT FOR LATER
	BIC	#^C7,R1			;CLEAR ALL BUT MESSAGE TYPE
	BNE	NSPBAD			;IF NOT NUMBERED CONTROL OR DATA, BRANCH
	MOV	CN.CNT(R0),R2		;RESTORE MESSAGE COUNT FOR NCL MESSAGE
	JSR	PC,GETEXN		;GET DLA
	TST	R0			;TEST FOR ZERO
	BEQ	NSPOCM			;YES, SEND A CONTROL MESSAGE
	BR	NSPODM			;NO, MUST BE DATA


; NCL SHOULD NEVER SEND START/STACK/ACK/NAK/REP/NODEID 
; TO A SEQUENTIAL NODE WITH HID ON. WE SHOULD NEVER GET HERE.

	.SBTTL	         1.4.1  NSPBAD 0.0 10-MAY-76 -- BAD MESSAGE


;***********************************************************************
;
;	NSPBAD 0.0 10-MAY-76 -- BAD MESSAGE	  
;
;***********************************************************************


NSPBAD:					;NCL SENT A MESSAGE WE CANNOT HANDLE
.IF NE,DGUTS
	TWIDDLE				;COUNT OCCURENCE
	BR	NSPOFL			;FLUSH MESSAGE
.IFF; NE,DGUTS
	TRAP				;HALT
.ENDC; NE,DGUTS

;HERE TO DECREMENT NCL'S RECEIVED MESSAGE COUNT, SO THIS
; NUMBERED MESSAGE WILL EVENTUALLY APPEAR AGAIN.

NSPORT:					;CAUSE RETRANSMISSION (BY SENDER) OF MESSAGE

; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

	MOV	20(SP),SB		;RESTORE WINDOW POINTER
	DECB	SB.RMN(SB)		;DE-COMMIT THIS MESSAGE

;HERE TO FLUSH A MESSAGE FROM NCL

	.SBTTL	         1.4.2  NSPOFL 0.0 10-MAY-76 -- FLUSH OUTPUT MESSAGE


;***********************************************************************
;
;	NSPOFL 0.0 10-MAY-76 -- FLUSH OUTPUT MESSAGE	  
;
;***********************************************************************


NSPOFL:					;FLUSH OUTPUT MESSAGE

; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

	MOV	(SP)+,R0		;RESTORE START OF NCL MESSAGE
	JSR	PC,NCLODN		;GIVE THE MESSAGE BACK TO NCL
	MOV	(SP)+,R2		;RESTORE R2
.IF NE,FT.CHK
	CMP	R2,#SOH			;IT BETTER BE SOH
	BEQ	10$			;YES, BRANCH
	TRAP				;NO, HALT
10$:					;HERE WHEN R2 CONTENTS OK
.ENDC; NE,FT.CHK
	MOV	(SP)+,R4		;RESTORE R4
	MOV	(SP)+,R5		;RESTORE R5
	ADD	#4,SP			;SKIP OVER DDCMP RETURN, AND #JRSTR
	MOV	(SP)+,J			;RESTORE J
	RTS	PC			;GO BACK TO NCL

	.SBTTL	         1.4.3  NSPODM 0.0 10-MAY-76 -- OUTPUT A DATA MESSAGE


;***********************************************************************
;
;	NSPODM 0.0 10-MAY-76 -- OUTPUT A DATA MESSAGE	  
;
;***********************************************************************


; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

NSPODM:					;WRITE OUT A DATA MESSAGE
	JSR	PC,NSPFDL		;FIND DLA (RETURNS LINK ENTRY POINTER IN R1)
	BEQ	NSPBAD			;DATA MESSAGE WHEN NO LINK?
	MOVB	LE.NSP(R1),NSPDST	;SAVE DESTINATION LINK ADDRESS
	MOVB	LE.CON(R1),NSPSRC	;SAVE SOURCE LINK ADDRESS
	MOV	LB.MML(J),NSPMML	;GET MAX MESSAGE LENGTH
	JSR	PC,NSPFST		;SET STRIP BIT IN NSPFLG
	JSR	PC,NSPBMG		;START OUTPUT MESSAGE
	CLR	R0			;MAKE MSGFLG FIELD
	BITB	#NCFINT,NSPNCT		;WAS NCL MESSAGE AN INTERRUPT MESSAGE?
	BEQ	10$			;NO, CONTINUE
	BIS	#NSPINT,R0		;SET INTERRUPT BIT IN MSFLG
	MOV	#11.,NSPMML		;SHORTEN MAX DATA LENGTH
10$:					;MSGFLG IN R0
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	NSPDST,R0		;GET DESTINATION LINK ADDRESS
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	NSPSRC,R0		;GET SOURCE LINK ADDRESS
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	CLR	NSPCNT			;CLEAR COUNTER (FOR STRIPPING)
20$:					;DATA COPYING LOOP
	TST	R2			;ANY MORE DATA IN NCL MESSAGE?
	BEQ	NSPOQU			;NO, BRANCH WHEN DONE
	BITB	#NSP.ST,NSPFLG		;ARE WE STRIPPING COUNT AND TYPE FIELDS?
	BEQ	25$			;NO, CONTINUE
	TST	NSPCNT			;CHECK COUNT OF SUB-MESSAGE
	BNE	25$			;IF MORE TO GO, BRANCH
	JSR	PC,GETEXN		;GET NEXT COUNT FIELD
	DEC	R0			;SUBTRACT ONE FOR TYPE BYTE
	MOV	R0,NSPCNT		;SAVE COUNT
	JSR	PC,GETBYT		;THROW AWAY TYPE
	BR	20$			;AND TRY AGAIN (IN CASE NO DATA)
25$:					;HERE FOR REAL DATA BYTE
	CMP	R4,NSPMML		;HAVE WE PUT ENOUGH INTO NSP MESSAGE YET?
	BHIS	NSPOVF			;YES, HANDLE MESSAGE OVERFLOW
	JSR	PC,GETBYT		;GET DATA BYTE
	DEC	NSPCNT			;DECREMENT SUB-MESSAGE BYTE COUNTER
	JSR	PC,NSPPBY		;STORE BYTE IN NSP MESSAGE
	BCS	NSPOFF			;IF NO MORE ROOM, BRANCH
	BR	20$			;CONTINUE LOOPING ON DATA

	.SBTTL	         1.4.4  NSPOQU 0.0 12-MAY-76 -- QUEUE OUTPUT TO DDCMP


;***********************************************************************
;
;	NSPOQU 0.0 12-MAY-76 -- QUEUE OUTPUT TO DDCMP	  
;
;***********************************************************************


NSPOQU:					;HERE WHEN DONE COPYING DATA INTO NSP MESSAGE
	MOV	NSPMSG,R0		;POINT TO BEGINNING OF MESSAGE
	MOV	R4,CN.LEN(R0)		;STORE LENGTH IN 1ST CHUNK
	MOV	(SP)+,R0		;GET NCL MESSAGE START BACK
	JSR	PC,NCLODN		;GIVE IT BACK TO NCL (HE WILL THROW AWAY UNLESS FROM SEQUENTIAL NODE)
	MOV	(SP)+,R2		;RESTORE R2
.IF NE,FT.CHK
	CMP	#SOH,R2			;MAKE SURE IT'S GOOD
	BEQ	36$			;OK, CONTINUE
	TRAP				;PROGRAMMING ERROR
36$:					;HERE AFTER R2 CHECKED
.ENDC; NE,FT.CHK
	MOV	(SP)+,R4		;RESTORE R4
	MOV	(SP)+,R5		;RESTORE R5
	MOV	NSPMSG,R0		;POINT TO NEW MESSAGE
	RTS	PC			;RETURN TO DDCMP
NSPOVF:					;HERE WHEN MESSAGE OVERFLOWS NSP MAX DATA LENGTH
	TRAP

NSPOFF:					;HERE WHEN WE RUN OUT OF CHUNKS BUILDING MESSAGE
	MOV	NSPMSG,R0		;GET START OF MESSAGE
	JSR	PC,FRECKS		;FREE THE CHUNKS
	JMP	NSPORT			;GET MESSAGE RETRANSMITTED LATER

	.SBTTL	         1.4.5  NSPOCM 0.0 17-MAY-76 -- OUTPUT A CONTROL MESSAGE


;***********************************************************************
;
;	NSPOCM 0.0 17-MAY-76 -- OUTPUT A CONTROL MESSAGE	  
;
;***********************************************************************


NSPOCM:					;SEND A CONTROL MESSAGE TO NSP
; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

;  REGISTERS:
;
;	R2	CONTAINS COUNT FOR NCL MESSAGE
;	R3	CONTAINS BYTE POINTER FOR NCL MESSAGE (AFTER DLA)
;	J	CONTAINS LINE BLOCK ADDRESS ON ENTRY
;	SB	CONTAINS SCB FOR DCP ON ENTRY
;
;  USAGE
;
;	R1	POINTER TO LINK ENTRY
;	R4	COUNT FOR OUTPUT MESSAGE
;	R5	BYTE POINTER FOR OUTPUT MESSAGE
	JSR	PC,GETEXN		;GET COUNT
	DEC	R0			;SUBTRACT ONE FOR TYPE
	MOV	R0,NSPCNT		;SAVE IT FOR LATER
	JSR	PC,GETBYT		;GET TYPE
	CMP	R0,#1			;CONNECT?
	BEQ	NSPOCN			;YES, SEND CONNECT
	CMP	R0,#2			;DISCONNECT?
	BNE	.+6			;SKIP AROUND JMP
	JMP	NSPODC			;SEND DISCONNECT MESSAGE OR DUMMY DATA
	CMP	R0,#4			;REQUEST CONFIGURATION?
	BNE	10$			;NO, CONTINUE LOOKING
	BIS	#NS.CNF,LB.NSS(J)	;YES, SET NEED TO SEND CONFIG BIT
	JSR	PC,NSPQ			;WAKE NSP LOW LEVEL
	BR	20$			;AND FLUSH MESSAGE
10$:					;HERE IF NOT REQUEST CONFIGURATION
	CMP	R0,#6			;DATA REQUEST?
	BNE	20$			;SKIP AROUND JUMP
	JMP	NSPOLS			;SEND LINK STATUS MESSAGE
20$:					;HERE TO SEE IF NEIGHBORS MESSAGE
	CMP	R0,#3			;IS IT NEIGHBORS?
	BNE	30$			;NO, FLUSH IT
22$:					;YES, HAVE TO CHECK IF OUR BUDDY DISAPPEARED
	TST	R2			;ANY MORE LEFT IN MESSAGE?
	BEQ	25$			;NO, HE WENT AWAY
	JSR	PC,GETEXN		;GET NODE NUMBER
	CMPB	R0,LB.DNA(J)		;IS IT OUR FRIEND?
	BEQ	30$			;YES, FLUSH REST OF MESSAGE
	JSR	PC,GETBYT		;GET LINK LVL TO THROW AWAY
	BR	22$			;KEEP LOOKING
25$:					;HERE WHEN OUR PARTNER HAS DISAPPEARED
	TST	LB.LCT(J)		;ANY LINKS?
	BEQ	30$			;NO, DOESN'T MATTER
	BIS	#LS..ST,@J		;YES, RESTART LINE SO HE KNOWS
;HERE IF A CONTROL TYPE SENT WHICH SHOULD BE IGNORED (LIKE CONFIGURATION)
30$:					;FLUSH MESSAGE
	JMP	NSPOFL			;FLUSH MESSAGE

	.SBTTL	         1.4.6  NSPOCN 0.0 12-MAY-76 -- SEND A CONNECT MESSAGE


;***********************************************************************
;
;	NSPOCN 0.0 12-MAY-76 -- SEND A CONNECT MESSAGE	  
;
;***********************************************************************


NSPOCN:					;SEND A CONNECT MESSAGE
; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

;  REGISTERS:
;
;	R2	CONTAINS COUNT FOR NCL MESSAGE
;	R3	CONTAINS BYTE POINTER FOR NCL MESSAGE (AFTER DLA)
;	J	CONTAINS LINE BLOCK ADDRESS ON ENTRY
;	SB	CONTAINS SCB FOR DCP ON ENTRY
;
;  USAGE
;
;	R1	POINTER TO LINK ENTRY
;	R4	COUNT FOR OUTPUT MESSAGE
;	R5	BYTE POINTER FOR OUTPUT MESSAGE

	JSR	PC,NSPBMG		;START A MESSAGE
	MOV	#NSPCM,R0		;MSGFLG WITH CM BIT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#1,R0			;TYPE FOR CONNECT MESSAGE
	JSR	PC,NSPPBY		;STORE IN MESSAGE
	JSR	PC,GETEXN		;GET DLA
	TST	R0			;CHECK FOR ZERO (I.E. INITIATE)
	BNE	NSPCNC			;NO, MUST BE CONFIRM; BRANCH
	JSR	PC,GETEXN		;GET SLA
	JSR	PC,NSPCLE		;CREATE A LINK ENTRY (R1 CONTAINS ADDRESS)
	MOV	R0,LE.NCL(R1)		;PUT NCL ADDRESS INTO IT
	JSR	PC,NSPBCO		;BUILD ONE-BYTE LINK FOR NSP
	CLR	R0			;SUB-TYPE (INITIATE)
	JSR	PC,NSPPBY		;STORE IN MESSAGE
	MOVB	LE.NSP(R1),R0		;GET DESTADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.CON(R1),R0		;GET SRCADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JSR	PC,GETBYT		;GET OBJECT TYPE
	CMP	#11,R0			;TASK?
	BEQ	40$			;YES, GO COPY IN NAME
	MOV	R0,-(SP)		;SAVE OBJECT TYPE FOR LATER
	CLR	R0			;OBJECT TYPE FOR TASK
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	BIS	#LES.DV,LE.STS(R1)	;SET DEVICE BIT IN LINK ENTRY
	MOV	#'O!200,R0		;PUT TASK NAME OBJOON INTO MESSAGE
					;WHERE "OO" IS OBJECT TYPE, "N" IS NUMBER
	JSR	PC,NSPPBY		;PUT "O" INTO MESSAGE
	MOV	#'B!200,R0		;GET "B"
	JSR	PC,NSPPBY		;PUT "B" INTO MESSAGE
	MOV	#'J!200,R0		;GET "J"
	JSR	PC,NSPPBY		;PUT "J" INTO MESSAGE
	MOV	(SP),R0			;GET OBJECT TYPE
	ROR	R0			;SHIFT
	ROR	R0			; SECOND DIGIT
	ROR	R0			;  TO CORRECT PLACE
	BIC	#177770,R0		;CLEAR EXTRA BITS
	ADD	#260,R0		;MAKE INTO EXTENDED ^^ASCII\\ NUMBER
	JSR	PC,NSPPBY		;PUT 1ST DIGIT OF OBJECT TYPE INTO NAME
	MOV	(SP)+,R0		;GET OBJECT TYPE BACK
	BIC	#177770,R0		;CLEAR EXTRANEOUS BITS
	ADD	#260,R0			;MAKE INTO NUMBER
	JSR	PC,NSPPBY		;STORE IN MESSAGE
	JSR	PC,GETBYT		;GET UNIT NUMBER
	BIC	#177770,R0		;CLEAR EXTRA
	ADD	#60,R0			;MAKE INTO NUMBER
	JSR	PC,NSPPBY		;PUT UNIT NUMBER INTO MESSAGE
	CLR	R0			;ZERO 
	JSR	PC,NSPPBY		; GROUP
	JSR	PC,NSPPBY		;  AND USER
	BR	43$			;CONTINUE

40$:					;HERE WHEN DESTINATION IS TASK
	JSR	PC,NSPEXC		;COPY TASK NAME AND PUT 0 GROUP AND USER ON
43$:					;HERE FOR SECOND NAME
	JSR	PC,GETBYT		;GET SOURCE OBJECT TYPE (TO THROW AWAY)
	JSR	PC,NSPEXC		;COPY REST OF SOURCE
	BIT	#LES.DV,LE.STS(R1)	;WAS THIS A DEVICE?
	BEQ	47$			;NO, DON'T PUT OPTIONAL DATA IN
45$:					;HERE TO PROCESS MML AND FEA FIELDS
	JSR	PC,GETEXN		;PROCESS MML FIELD (TO SKIP OVER IT)
46$:					;LOOP FOR COPYING FEATURES
	TST	R2			;ANY MORE LEFT IN MESSAGE?
	BEQ	47$			;NO, STOP
	JSR	PC,GETBYT		;GET NEXT BYTE
	JSR	PC,NSPPBY		;PUT INTO OPTIONAL DATA
	BR	46$			;CONTINUE LOOKING
47$:					;HERE WHEN DONE BUILDING NSP CONNECT
	JMP	NSPOQU			;QUEUE IT TO DDCMP

NSPCNC:					;HERE TO HANDLE CONNECT CONFIRM
	JSR	PC,NSPFDL		;FIND LINK ENTRY FROM DLA
	JSR	PC,GETEXN		;GET SLA
	MOV	R0,LE.NCL(R1)		;SAVE IN LINK ENTRY TABLE
	JSR	PC,NSPBCO		;MAKE A UNIQUE ADDRESS TO USE FOR NSP
	MOV	#1,R0			;CODE FOR CONFIRM
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.NSP(R1),R0		;DESTADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.CON(R1),R0		;SRCADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JSR	PC,GETBYT		;GET OBJECT TYPE
	CMP	R0,#11			;SHOULD BE TASK
	BEQ	55$			;YES, CONTINUE
	TRAP				;BAD!!!!
55$:					;HERE IF OBJECT TYPE OK
	JSR	PC,NSPEXC		;COPY PROCESS NAME
	JSR	PC,GETBYT		;GET SOURCE OBJECT TYPE
	CMP	R0,#11			;IS IT TASK?
	BNE	56$			;NO, HANDLE DEVICE CASE
	JSR	PC,NSPEXC		;YES, COPY IT
	BR	57$			;CONTINUE
56$:					;HERE TO HANDLE NON-TASK SRCNAME
	JSR	PC,NSPPBY		;PUT OBJECT TYPE
	JSR	PC,GETBYT		;GET UNIT
	JSR	PC,NSPPBY		;PUT IT INTO MESSAGE AS WELL
57$:					;HERE WHEN DONE WITH CONNECT CONFIRM
	JMP	NSPOQU			;GO QUEUE IT TO DDCMP

	.SBTTL	         1.4.7  NSPODC 0.0 12-MAY-76 -- SEND DISCONNECT


;***********************************************************************
;
;	NSPODC 0.0 12-MAY-76 -- SEND DISCONNECT	  
;
;***********************************************************************


NSPODC:					;
; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

;  REGISTERS:
;
;	R2	CONTAINS COUNT FOR NCL MESSAGE
;	R3	CONTAINS BYTE POINTER FOR NCL MESSAGE (AFTER DLA)
;	J	CONTAINS LINE BLOCK ADDRESS ON ENTRY
;	SB	CONTAINS SCB FOR DCP ON ENTRY
;
;  USAGE
;
;	R1	POINTER TO LINK ENTRY
;	R4	COUNT FOR OUTPUT MESSAGE
;	R5	BYTE POINTER FOR OUTPUT MESSAGE

	JSR	PC,NSPBMG		;START MESSAGE
	JSR	PC,GETEXN		;GET DLA
	JSR	PC,NSPFDL		;FIND LINK ENTRY FOR IT
	BITB	#LES.DV,LE.STS(R1)	;IS THIS A DEVICE?
	BNE	NSPODD			;YES, DO SPECIAL HANDLING
NSPOD1:					;START OF DISCONNECT MESSAGE
	MOV	#NSPCM,R0		;MSGFLG WITH CM BIT ON
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#2,R0			;TYPE FOR DISCONNECT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JSR	PC,GETEXN		;GET SLA
	MOV	LE.NCL(R1),R0		;
	MOV	#4,-(SP)		;ASSUME INITIATE SUB-TYPE
	TST	R0			;WAS SLA 0?
	BNE	12$			;NO, OUR ASSUMPTION WAS GOOD
	MOV	#33,(SP)		;ASSUME REJECT SUBTYPE
	BR	13$			;AND CONTINUE
12$:					;HERE TO TEST FOR POSSIBLILITY OF DISCONNECT CONFIRM
	BITB	#LES.WD,LE.STS(R1)	;WERE WE WAITING FOR DISCONNECT CONFIRM
	BEQ	13$			;NO, WE WERE RIGHT BEFORE
	MOV	#5,(SP)			;YES, SO IT SHOULD BE DISCONNECT CONFIRM
13$:					;HERE WHEN WE HAVE DECIDED TYPE OF DISCONNECT
	MOVB	(SP),R0			;GET SUBTYPE AND REASON
	JSR	PC,NSPPBY		;STORE IN MESSAGE
	JSR	PC,GETBYT		;GET REASON (THROW IT AWAY)
	MOVB	LE.NSP(R1),R0		;GET DESTADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.CON(R1),R0		;GET SRCADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	CMP	(SP)+,#4		;WAS IT INITIATE?
	BEQ	15$			;YES, BRANCH
	JSR	PC,NSPDLE		;NO, DELETE LINK ENTRY
14$:					;HERE TO QUEUE MESSAGE OUT
	JMP	NSPOQU			;SEND IT TO DDCMP
15$:					;HERE WHEN DISCONNECT INITIATE
	BISB	#LES.WD,LE.STS(R1)	;SET WAITING FOR DISCONNECT CONFIRM BIT
	BR	14$			;GO QUEUE MESSAGE

	.SBTTL	         1.4.10  NSPODD 0.0 02-JUN-76 -- OUTPUT DUMMY DISCONNECT


;***********************************************************************
;
;	NSPODD 0.0 02-JUN-76 -- OUTPUT DUMMY DISCONNECT	  
;
;***********************************************************************


NSPODD:					;FOR DEVICES, SEND DATA MESSAGE WITH NO DATA INSTEAD OF DISCONNECT
; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

	TST	LE.NCL(R1)		;IS SOURCE NOT DEFINED?
	BEQ	NSPOD1			;YES, SEND REGULAR DISCONNECT REJECT
	BISB	#LES.WD,LE.STS(R1)	;SHOW WE ARE WAITING
	MOV	#NSPINT,R0		;MSGFLG FOR INTERRUPT DATA MESSAGE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.NSP(R1),R0		;DESTADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.CON(R1),R0		;SRCADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JSR	PC,NSPFST		;SET STRIP BIT IF STRIPPING DESIRED
	BITB	#NSP.ST,NSPFLG		;ARE WE STRIPPING?
	BNE	10$			;YES, LEAVE OFF COUNT AND TYPE
	MOV	#1,R0			;COUNT = 1
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#2,R0			;TYPE = DATA WITH EOR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
10$:					;HERE WHEN DONE CONSTRUCTING DUMMY MESSAGE
	JMP	NSPOQU			;SEND MESSAGE OUT

	.SBTTL	         1.4.11  NSPOLS 0.0 12-MAY-76 -- SEND LINK STATUS


;***********************************************************************
;
;	NSPOLS 0.0 12-MAY-76 -- SEND LINK STATUS	  
;
;***********************************************************************


NSPOLS:					;SEND A LINK STATUS FOR DATA REQUESTS
; STACK LOOKS LIKE:
;	0	R0
;	2	R2
;	4	R4
;	6	R5
;	10	DDQDAT + ? (DDCMP RETURN)
;	12	#JRSTR
;	14	J VALUE
;	16	NCR.10 + ? (NCL RETURN)
;	20	SB VALUE

;  REGISTERS:
;
;	R2	CONTAINS COUNT FOR NCL MESSAGE
;	R3	CONTAINS BYTE POINTER FOR NCL MESSAGE (AFTER DLA)
;	J	CONTAINS LINE BLOCK ADDRESS ON ENTRY
;	SB	CONTAINS SCB FOR DCP ON ENTRY
;
;  USAGE
;
;	R1	POINTER TO LINK ENTRY
;	R4	COUNT FOR OUTPUT MESSAGE
;	R5	BYTE POINTER FOR OUTPUT MESSAGE

	JSR	PC,GETEXN		;GET DLA
	JSR	PC,NSPFDL		;FIND LINK ENTRY
	JSR	PC,GETEXN		;GET DATA REQUEST COUNT
	MOV	R0,-(SP)		;SAVE DATA REQUEST COUNT
	JSR	PC,NSPBMG		;START MESSAGE
	MOV	#NSPCM,R0			;MSGFLG WITH CM BIT ON
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#3,R0			;TYPE IS LINK STATUS
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.NSP(R1),R0		;DESTADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.CON(R1),R0		;SRCADDR
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	(SP)+,R0		;GET REQUEST COUNT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JMP	NSPOQU			;QUEUE MESSAGE OUT

	.SBTTL	    1.5  NSPINP 0.0 15-MAY-76 -- NSP INPUT ROUTINES


;***********************************************************************
;
;	NSPINP 0.0 15-MAY-76 -- NSP INPUT ROUTINES	  
;
;***********************************************************************


NSPINP:					;HERE WHEN WE RECEIVE NSP MESSAGE
; REGISTERS
;
;	R0	POINTER TO FIRST CHUNK OF MESSAGE
;	J	POINTER TO LINE BLOCK FOR DCP
; STACK LOOKS LIKE:
;	0	RETURN TO DDCMP
	MOV	J,NSPLB			;SAVE POINTER TO LINE BLOCK
	MOV	R0,-(SP)		;SAVE START OF MESSAGE
; STACK LOOKS LIKE:
;	0	START OF MESSAGE (R0)
;	2	RETURN TO DDCMP
	MOV	CN.LEN(R0),R2		;GET LENGTH
	MOV	R0,R3			;POINT TO FIRST CHUNK
	ADD	#CN.NCT,R3		;NOW MAKE THAT FIRST DATA
	JSR	PC,NSPBMG		;START A MESSAGE
	CLRB	NSPNCT			;ZERO NCT
	JSR	PC,GETBYT		;GET NCT
	BIT	#NSPCM,R0		;WAS THIS A CONTROL MESSAGE?
	BNE	NSPICM			;YES, HANDLE CONTROL MESSAGE
	BIT	#NSPINT,R0		;WAS THIS INTERRUPT MESSAGE?
	BEQ	10$			;NO, CONTINUE
	BISB	#NCFINT,NSPNCT		;YES, SET INTERRUPT BIT IN NCT
10$:					;
	JSR	PC,NSPBNC		;PUT NCL HEADER IN MESSAGE
	JSR	PC,GETEXN		;GET DESTADDR
	JSR	PC,NSPFDA		;FIND IT
	JSR	PC,GETEXN		;GET SR(CADDR
	CMPB	LE.NSP(R1),R0		;COMPARE WITH LINK ENTRY
	BEQ	15$			;BRANCH IF EQUAL
	TRAP				;ERROR SOMEWHERE!
15$:					;HERE TO PUT DLA INTO NCL MESSAGE
	MOV	LE.NCL(R1),R0		;GET DLA
	JSR	PC,NSPPEX		;PUT INTO MESSAGE
	JSR	PC,NSPFST		;SET STRIP BIT
	BIT	#NSP.ST,NSPFLG		;ARE WE STRIPPING?
	BEQ	20$			;NO, JUST COPY DATA
	MOV	R2,R0			;GET LENGTH
	INC	R0			;AUGMENT FOR TYPE
	JSR	PC,NSPPEX		;STORE COUNT
	MOV	#2,R0			;TYPE IS DATA  [mco 9695]
	JSR	PC,NSPPBY		;STORE TYPE
20$:					;HERE TO COPY DATA BYTES
	TST	R2			;ANY MORE TO COPY?
	BEQ	30$			;NO, FINISH UP
	JSR	PC,GETBYT		;GET NEXT BYTE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	BR	20$			;KEEP LOOKING FOR DATA
30$:					;HERE TO PUT LENGTH INTO MESSAGE
	MOV	NSPMSG,R0			;PUT TO FIRST CHUNK OF NCL MESSAGE
	MOV	R4,CN.LEN(R0)		;PUT COUNT INTO APPROPRIATE PLACE
	BR	NSPNCL
NSPNCL:					;HERE WHEN DONE BUILDING DATA MESSAGE
	MOV	(SP)+,R0		;GET START OF NCL MESSAGE
	JSR	PC,FRECKS		;FREE ITS CHUNKS
	MOV	NSPMSG,R0		;GET START OF NCL MESSAGE
	PJMP	NCLIN1			;PASS IT TO NCL  [mco 9696]

	.SBTTL	         1.5.1  NSPICM 0.0 15-MAY-76 -- RECEIVED NSP CONTROL MSG


;***********************************************************************
;
;	NSPICM 0.0 15-MAY-76 -- RECEIVED NSP CONTROL MSG	  
;
;***********************************************************************


NSPICM:					;HERE TO HANDLE NSP CONTROL MESSAGE
	JSR	PC,GETBYT		;GET MESSAGE TYPE
	CMP	R0,#4			;IS IT BIGGER THAN MAX?
	BGT	20$			;YES, ERROR BRANCH
	ASL	R0			;SHIFT LEFT FOR DISPATCH
	JMP	@10$(R0)		;GO TO RIGHT ROUTINE
10$:					;DISPATCH TABLE FOR MESSAGE TYPES
	.WORD	20$			;0 SHOULDN'T HAPPEN
	.WORD	NSPICN			;WHERE TO GO FOR CONNECT
	.WORD	NSPIDC			;DISCONNECT
	.WORD	NSPILS			;LINK STATUS
	.WORD	NSPIER			;ERROR
20$:					;HERE WHEN ILLEGAL MESSAGE TYPE IS FOUND
	TRAP				;BUT IT CAN'T BE ANYTHING ELSE!

	.SBTTL	         1.5.2  NSPICN 0.0 15-MAY-76 -- NSP CONNECT MESSAGE


;***********************************************************************
;
;	NSPICN 0.0 15-MAY-76 -- NSP CONNECT MESSAGE	  
;
;***********************************************************************


NSPICN:					;HERE TO PROCESS CONNECT MESSAGE
	JSR	PC,GETBYT		;GET SUB-TYPE
	CMP	R0,#2			;IS IT GREATER THAN MAX?
	BGT	20$			;YES, BRANCH ON ERROR
	ASL	R0			;SHIFT FOR DISPATCH
	JMP	@10$(R0)		;GO TO PROPER ROUTINE
10$:					;DISPATCH TABLE FOR CONNECT SUB-TYPES
	.WORD	NSPICI			;CONNECT INITIATE
	.WORD	NSPICC			;CONNECT CONFIRM
	.WORD	NSPLMB			;CONNECT REJECT IS LIKE DISCONNECT REJECT
20$:					;HERE IF BAD CONNECT SUB-TYPE
	TRAP				;WHAT ELSE?

	.SBTTL	         1.5.3  NSPICI 0.0 15-MAY-76 -- NSP CONNECT INITIATE


;***********************************************************************
;
;	NSPICI 0.0 15-MAY-76 -- NSP CONNECT INITIATE	  
;
;***********************************************************************



NSPICI:					;HERE ON CONNECT INITIATE
	JSR	PC,GETBYT		;GET DESTADDR
	TST	R0			;CHECK RESULTS
	BEQ	5$			;BETTER NOT BE ANY
	TRAP				;BAD CONNECT INITIATE MESSAGE
5$:					;HERE IF DESTADDR OK
	JSR	PC,GETBYT		;GET SRCADDR
	JSR	PC,NSPFDA		;SEARCH FOR IT IN LINK TABLE
	BEQ	10$			;BETTER NOT BE THERE!
	TRAP				;WE HAVE THIS LINK ALREADY.
10$:					;HERE IF SRCADDR IS KOSHER
	JSR	PC,NSPCLE		;CREATE A LINK TABLE ENTRY
	MOVB	R0,LE.NSP(R1)		;STORE NSP LINK ADDRESS
	JSR	PC,NSPBNC		;PUT NCL HEADER INTO MESSAGE
	JSR	PC,NSPPBY		;PUT 0 DLA
	MOV	R5,NSPCNT		;SAVE POINTER TO COUNT
	JSR	PC,NSPPEX		;2-BYTE COUNT (TO BE FILLED IN LATER)
	MOV	R4,NSPCVL		;SAVE CURRENT COUNT VALUE
	MOV	#1,R0			;CONNECT TYPE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	CLR	R0			;DLA IS ZERO
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
NSPIC1:					;COMMON CODE FOR INITIATE AND CONFIRM
	MOVB	LE.NSP(R1),R0		;GET SLA
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JSR	PC,GETBYT		;GET DESTINATION OBJECT TYPE
	TST	R0			;SEE IF IT IS TASK
	BNE	20$			;NO, PUT IT INTO MESSAGE
	MOV	#11,R0			;YES, PUT TASK NCL OBJECT TYPE
20$:					;PUT DEST OBJ TYPE INTO MESSAGE
	JSR	PC,NSPPBY		;PUT DEST OBJ TYPE INTO MESSAGE
30$:	JSR	PC,GETBYT		;GET PID BYTE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	BIT	#200,R0			;WAS THAT LAST?
	BNE	30$			;NO, CONTINUE
	JSR	PC,GETEXN		;THROW AWAY GROUP
	JSR	PC,GETEXN		;AND USER
	JSR	PC,GETBYT		;GET SOURCE OBJECT TYPE
	TST	R0			;CHECK IF TASK
	BNE	40$			;NO, CONTINUE
	BIT	#LES.DV,LE.STS(R1)	;IS THIS DEVICE ? (CONFIRM ONLY)
	BEQ	35$			;NO, PROCEED NORMALLY
	JSR	PC,GETBYT		;YES, GET "O"
	JSR	PC,GETBYT		;GET "B"
	JSR	PC,GETBYT		;GET "J"
	JSR	PC,GETBYT		;GET HIGH ORDER DIGIT OF OBJECT TYPE
	BIC	#177770,R0		;CLEAR EXTRA BITS
	ROL	R0			;SHIFT
	ROL	R0			; INTO CORRECT
	ROL	R0			;  POSITION
	MOV	R0,-(SP)		;SAVE FOR LATER
	JSR	PC,GETBYT		;GET LOW ORDER DIGIT OF OBJECT TYPE
	BIC	#177770,R0		;CLEAR EXTRA BITS
	ADD	(SP)+,R0		;MAKE OBJECT TYP
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JSR	PC,GETBYT		;GET UNIT NUMBER
	BIC	#177770,R0		;CLEAR EXTRA BITS
	JSR	PC,NSPPBY		;PUT UNIT NUMBER INTO MESSAGE
	BR	42$			;GO THROW AWAY GROUP AND USER
35$:					;HERE IF IT REALLY WAS A TASK
	MOV	#11,R0			;NCL OBJECT TYPE FOR TASK
40$:					;HERE IF SOURCE OBJ TYPE IS GOOD
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
41$:					;LOOP TO COPY PID EXTENSIBLE STRING
	JSR	PC,GETBYT		;GET NEXT BYTE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	BIT	#200,R0			;WAS THAT LAST?
	BNE	41$			;NO, KEEP GOING
42$:					;HERE TO FLUSH GROUP AND USER
	JSR	PC,GETEXN		;YES, GET GROUP
	JSR	PC,GETEXN		;AND USER (FOR WASTEBASKET)
	MOV	J,-(SP)			;SAVE J
	MOV	NSPLB,J			;GET LINE BLOCK ADDRESS
	MOV	LB.MML(J),R0		;GET MAXIMUM MESSAGE LENGTH FOR LINE
	MOV	(SP)+,J			;RESTORE J
	JSR	PC,NSPPEX		;PUT INTO MESSAGE
50$:					;LOOP PUTTING IN OPTIONAL DATA
	TST	R2			;ANY MORE IN SOURCE MESSAGE
	BEQ	NSPICX			;NO, EXIT
	JSR	PC,GETBYT		;GET NEXT BYTE
	JSR	PC,NSPPBY		;COPY INTO TARGET MESSAGE
	BR	50$			;AND KEEP LOOKING
NSPICX:					;HERE WHEN DONE BUILDING NCL MESSAGE
	MOV	NSPMSG,R0		;PUT TO START OF MESSAGE
	MOV	R4,CN.LEN(R0)		;PUT COUNT INTO CHUNK
	SUB	NSPCVL,R4		;GET COUNT FOR NCL
	MOV	R4,R0			;COPY INTO CORRECT REGISTER
	MOV	NSPCNT,R5		;PUT POINTER BACK
	JSR	PC,NSPPEX		;2-BYTE COUNT INTO MESSAGE
	JMP	NSPNCL			;GIVE MESSAGE TO NCL

	.SBTTL	         1.5.4  NSPICC 0.0 15-MAY-76 -- NSP CONNECT CONFIRM


;***********************************************************************
;
;	NSPICC 0.0 15-MAY-76 -- NSP CONNECT CONFIRM	  
;
;***********************************************************************


NSPICC:					;HERE WHEN WE RECEIVE AN NSP CONNECT CONFIRM
	JSR	PC,GETBYT		;GET DESTADDR
	BEQ	10$			;ERROR IF ZERO
	JSR	PC,NSPFDA		;FIND LINK IN TABLE
	BEQ	10$			;ERROR IF NOT THERE
	JSR	PC,GETBYT		;GET SRCADDR
	MOVB	R0,LE.NSP(R1)		;SAVE IT IN LINK TABLE
	CLRB	NSPNCT			;INITIALIZE NCT
	JSR	PC,NSPBNC		;START MESSAGE
	JSR	PC,NSPPBY		;DLA OF 0
	MOV	R5,NSPCNT		;SAVE POINTER FOR COUNT
	JSR	PC,NSPPEX		;PUT A ZERO COUNT FOR NOW
	MOV	R4,NSPCVL		;SAVE COUNT ALSO
	MOV	#1,R0			;CONNECT TYPE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	LE.NCL(R1),R0		;GET DLA
	JSR	PC,NSPPEX		;PUT INTO MESSAGE
	BIS	#LES.SL,LE.STS(R1)	;INDICATE WE NEED TO SEND LINK STATUS
	JSR	PC,NSPQ			;QUEUE LINE BLOCK
	JMP	NSPIC1			;AND CONTINUE
10$:					;HERE ON ERROR
	TRAP				;PROTOCOL ERROR

	.SBTTL	         1.5.5  NSPIDC 0.0 17-MAY-76 -- NSP DISCONNECT


;***********************************************************************
;
;	NSPIDC 0.0 17-MAY-76 -- NSP DISCONNECT	  
;
;***********************************************************************


NSPIDC:					;HERE WHEN WE RECEIVE NSP DISCONNECT
	JSR	PC,GETBYT		;GET SUB-TYPE
	MOVB	R0,NSPREA		;SAVE FOR REASON
	JSR	PC,GETBYT		;GET DESTADDR
	MOVB	R0,NSPDST		;SAVE IT
	JSR	PC,NSPFDA		;FIND LINK TABLE ENTRY
	BNE	9$			;IF THERE, CONTINUE
	JMP	NSPIBD			;ELSE, FLUSH MESSAGE
9$:					;HERE WHEN LINK TABLE ENTRY FOUND
	JSR	PC,GETBYT		;GET SRCADDR
	MOVB	R0,NSPSRC		;SAVE FOR LATER
	MOVB	NSPREA,R0		;GET BACK SUB-TYPE AND REASON
	BIC	#177770,R0		;MASK OUT REASON
	SUB	#3,R0			;MAKE ZERO ORIGIN
	BMI	20$			;IF NEGATIVE, CODE WAS TOO LOW
	CMP	R0,#3			;SEE IF TOO HIGH
	BGT	20$			;YES, ERROR
	ASL	R0			;SHIFT FOR DISPATCH
	JMP	@10$(R0)		;DISPATCH ON TYPE TO PROPER ROUTINE
10$:					;DISPATCH TABLE FOR NSP DISCONNECT TYPES
	.WORD	NSPDCR			;DISCONNECT REJECT
	.WORD	NSPDCI			;DISCONNECT INITIATE
	.WORD	NSPDCC			;DISCONNECT CONFIRM
	.WORD	NSPDCI			;DISCONNECT ABORT (HANDLED EXACLTLY LIKE INITIATE)
20$:					;HERE IF BAD DISCONNECT TYPE
	TRAP				;BETTER STOP

	.SBTTL	         1.5.6  NSPDCR 0.0 17-MAY-76 -- NSP DISCONNECT REJECT


;***********************************************************************
;
;	NSPDCR 0.0 17-MAY-76 -- NSP DISCONNECT REJECT	  
;
;***********************************************************************


NSPLMB:	JSR	PC,GETBYT		;GET DEST ADDR
	TST	R0			;CHECK RESULTS
	BNE	10$			;BETTER HAVE DEST ADDR
	TRAP				;ERROR IF ZERO
10$:	JSR	PC,NSPFDA		;FIND LINK IN TABLE
	BNE	20$			;CHECK RESULTS
	TRAP				;ERROR IF ZERO
20$:	CLRB	NSPREA			;USE 0 ERROR CODE
NSPDCR:					;HERE WHEN WE HAVE DISCONNECT REJECT FROM NSP
	TSTB	LE.NSP(R1)		;WAS CONNECTION COMPLETED?
	BEQ	NSPDCO			;NO, BRANCH
	BISB	#LES.FL!LES.WD,LE.STS(R1);YES, WE'LL HAVE TO WAIT FOR DISCONNECT FROM NCL
NSPDCO:					;HERE AFTER DETERMINING IF CONNECTION COMPLETE
	CLRB	NSPNCT			;ZERO NCT
	JSR	PC,NSPBNC		;START MESSAGE
	JSR	PC,NSPPBY		;PUT IN 0 DLA
	MOV	R5,NSPCNT		;SAVE POINTER
	JSR	PC,NSPPEX		;PUT A ZERO COUNT FOR NOW
	MOV	R4,NSPCVL		;SAVE COUNT
	MOV	#2,R0			;DISCONNECT TYPE = 2
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	LE.NCL(R1),R0		;DLA
	JSR	PC,NSPPEX		;PUT INTO MESSAGE
	MOVB	LE.NSP(R1),R0		;SLA
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	NSPREA,R0		;GET REASON AND SUBTYPE
	ASR	R0			;SHIFT
	ASR	R0			; OUT
	ASR	R0			;  SUB-TYPE BITS
	CLR	-(SP)			;START WITH DEFAULT 0 REASON CODE
	BITB	#LES.DV,LE.STS(R1)	;IS THIS A DEVICE CONNECTION?
;	BEQ	15$			;NO, LEAVE 0 DEFAULT
	INC	(SP)			;YES, MAKE 1 DEFAULT
15$:					;HERE AFTER DECIDING DEFAULT REASON
	CMP	R0,#3			;WAS IT NO SUCH PROCESS?
	BNE	20$			;NO, TRY NEXT
	BITB	#LES.DV,LE.STS(R1)	;IS IT A DEVICE?
	BNE	22$			;YES, USE DEFAULT
	MOV	#4,(SP)			;PUT PROCESS NOT THERE REASON CODE INTO MESSAGE
	BR	22$			;DONE
20$:					;HERE TO TRY ANOTHER CODE
	CMP	R0,#6			;WAS IT NODE SHUTTING DOWN?
	BNE	22$			;NO, PUT INTO MESSAGE
	MOV	#2,(SP)			;USE NCL TOO MANY CONNECTS TO NODE
22$:					;HERE WHEN DONE DECIDING NCL REASON
	MOV	(SP)+,R0		;GET REASON
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
30$:					;HERE TO COPY OPTIONAL DATA INTO NCL MESSAGE
	TST	R2			;ANY LEFT?
	BEQ	40$			;NO, DONE
	JSR	PC,GETBYT		;YES, GET A BYTE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	BR	30$			;AND LOOK FOR NEXT
40$:					;HERE WHEN DONE BUILDING NCL DISCONNECT
	BITB	#LES.WD,LE.STS(R1)	;ARE WE WAITING FOR A RESPONSE?
	BNE	45$			;YES, BRANCH
	JSR	PC,NSPDLE		;NO, DELETE LINK TABLE ENTRY
45$:					;HERE TO FINISH UP AND GIVE TO NCL
	JMP	NSPICX			;PUT IN COUNT AND GIVE TO NCL

	.SBTTL	         1.5.7  NSPDCI 0.0 17-MAY-76 -- NSP DISCONNECT INITIATE


;***********************************************************************
;
;	NSPDCI 0.0 17-MAY-76 -- NSP DISCONNECT INITIATE	  
;
;***********************************************************************


NSPDCI:					;HERE TO PROCESS NSP DISCONNECT INITIATE
	BITB	#LES.DV,LE.STS(R1)	;IS THIS A DEVICE?
	BNE	10$			;YES, GO HANDLE IT
5$:					;HERE WHEN NOT DEVICE LINK, OR WHEN NOT IN DUMMY DISCONNECT STATE
	TSTB	LE.NSP(R1)		;IS LINK COMPLETED?
	BNE	6$			;YES, CONTINUE
	TRAP				;PROTOCOL ERROR
6$:					;HERE ON VALID DISCONNECT INITIATE
	BISB	#LES.WD,LE.STS(R1)	;INDICATE WE SHOULD WAIT FOR CONFIRM
	BR	NSPDCO			;AND HANDLE AS DISCONNECT REJECT
10$:					;HERE IF LINK IS A DEVICE
	BITB	#LES.WD,LE.STS(R1)	;HAVE WE SENT DUMMY DISCONNECT?
	BEQ	5$			;NO, GO DO NORMAL THINGS
	BISB	#LES.SD,LE.STS(R1)	;YES, INDICATE THAT WE MUST SEND DISCONNECT CONFIRM OURSELVES
	JSR	PC,NSPQ			;WAKE UP NSP LOW LEVEL
					;IT WILL SEND IT, AND THEN DELETE LINK TABLE ENTRY
	BR	NSPDCO			;AND SEND DISCONNECT TO NCL

	.SBTTL	         1.5.10  NSPDCC 0.0 17-MAY-76 -- NSP DISCONNECT CONFIRM


;***********************************************************************
;
;	NSPDCC 0.0 17-MAY-76 -- NSP DISCONNECT CONFIRM	  
;
;***********************************************************************


NSPDCC:					;HERE ON NSP  DISCONNECT CONFRIM
	BITB	#LES.WD,LE.STS(R1)	;WERE WE WAITING FOR A CONFIRM?
	BNE	10$			;YES, CONTINUE
	TRAP				;NO, THAT IS BAD
10$:					;HERE ON VALID DISCONNECT CONFIRM
	BICB	#LES.WD,LE.STS(R1)	;CLEAR WAITING BIT (TO CAUSE LINK ENTRY TO DISAPPEAR)
	BR	NSPDCO			;AND GO TO COMMON CODE

	.SBTTL	         1.5.11  NSPILS 0.0 17-MAY-76 -- NSP LINK STATUS


;***********************************************************************
;
;	NSPILS 0.0 17-MAY-76 -- NSP LINK STATUS	  
;
;***********************************************************************


NSPILS:					;HERE ON NSP LINK STATUS
	JSR	PC,GETBYT		;GET DESTADDR
	JSR	PC,NSPFDA		;FIND A LINK TABLE ENTRY
	BEQ	NSPIBD			;NONE!! BAD MESSAGE
	JSR	PC,GETBYT		;GET SRCADDR
	CMPB	R0,LE.NSP(R1)		;BETTER BE THE SAME
	BNE	NSPIBD			;IT WASN'T, SO BRANCH
	JSR	PC,GETBYT		;GET REQUEST COUNT
	TST	R0			;CHECK FOR 0
	BNE	10$			;NON-ZERO, SO BRANCH
;HERE WHEN WE GET A NULL LINK STATUS MESSAGE
NSPIBD=.				;FLUSH INPUT AND OUTPUT MESSAGES
	MOV	NSPMSG,R0		;POINT TO BEGINNING OF NCL MESSAGE
	JSR	PC,FRECKS		;FREE IT
	MOV	(SP)+,R0		;GET START OF NSP MESSAGE
	JSR	PC,FRECKS		;FREE IT ALSO
	RTS	PC			;AND RETURN TO DDCMP

10$:					;HERE ON REAL LINK STATUS
	MOV	R0,-(SP)		;SAVE DATA REQUEST COUNT
	CLRB	NSPNCT			;ZERO  NCT
	JSR	PC,NSPBNC		;START MESSAGE
	JSR	PC,NSPPBY		;PUT IN 0 DLA
	MOV	#4,R0			;COUNT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#6,R0			;TYPE = DATA REQUEST
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	LE.NCL(R1),R0		;GET DLA
	JSR	PC,NSPPEX		;PUT INTO MESSAGE
	MOV	(SP)+,R0		;GET REQUEST COUNT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	NSPMSG,R0		;GET START OF NCL MESSAGE
	MOV	R4,CN.LEN(R0)		;PUT LENGTH INTO CHUNK
	JMP	NSPNCL			;AND SEND IT ON ITS WAY

	.SBTTL	         1.5.12  NSPIER 0.0 17-MAY-76 -- NSP ERROR MESSAGE


;***********************************************************************
;
;	NSPIER 0.0 17-MAY-76 -- NSP ERROR MESSAGE	  
;
;***********************************************************************


NSPIER:					;HERE ON NSP ERROR MESSAGE
	TRAP				;SHOULDN'T HAPPEN

	.SBTTL	    1.6  NSPODN 0.0 12-MAY-76 -- OUTPUT DONE ROUTINE


;***********************************************************************
;
;	NSPODN 0.0 12-MAY-76 -- OUTPUT DONE ROUTINE	  
;
;***********************************************************************


NSPODN:					;HERE WHEN OUTPUT DONE
	JSR	PC,FRECKS		;THROW MESSAGE AWAY
	RTS	PC			;RETURN


	.SBTTL	    1.7  NSPCHK 0.0 19-MAY-76 -- CHECK FOR ACTION


;***********************************************************************
;
;	NSPCHK 0.0 19-MAY-76 -- CHECK FOR ACTION	  
;
;***********************************************************************


NSPCHK:					;HERE TO CHECK NSP QUEUE
	CMP	NS.PTR,NS.TKR		;ANYTHING IN QUEUE?
	BEQ	NSPCHR			;NO, RETURN
	CMP	NS.TKR,#<NS.QUE+NS.SIZ>	;TAKER PAST END?
	BLO	.+10			;NO, SKIP NEXT INSTRUCTION
	MOV	#NS.QUE,NS.TKR		;POINT IT BACK TO BEGINNING
	MOV	@NS.TKR,J		;GET LINE BLOCK ADDRESS
	ADD	#2,NS.TKR		;ADVANCE TAKER
	BIC	#NS.NSQ,LB.NSS(J)	;CLEAR QUEUED BIT
	SAVE	<SB>			;SAVE POINTER TO SCB
	MOV	LB.SCB(J),SB		;GET OUR SCB
	BIT	#NS.CNF,LB.NSS(J)	;DO WE HAVE TO SEND CONFIGURATION?
	BEQ	10$			;NO, TRY INDIVIDUAL LINKS
	JSR	PC,NSPSCF		;YES, SEND CONFIGURATION
10$:					;HERE TO LOOP OVER LINKS
	MOV	LB.LKT(J),R1		;GET POINTER TO LINK TABLE
	ADD	#2,R1			;ADJUST TO FIRST LINK
	MOV	LB.LCT(J),R3		;GET COUNT OF LINKS
	BEQ	30$			;IF NONE, WE ARE DONE
15$:					;LOOP THROUGH LINKS
	BITB	#LES.SL,LE.STS(R1)	;NEED TO SEND ZERO LINK STATUS TO NSP?
	BEQ	20$			;NO, KEEP LOOKING
	JSR	PC,NSPSLS		;YES, DO IT
20$:					;CHECK OTHER ACTIVITY
	BITB	#LES.SD,LE.STS(R1)	;DO WE NEED TO SEND DISCONNECT CONFIRM TO NSP?
	BEQ	25$			;NO, ADVANCE TO NEXT LINK
	JSR	PC,NSPSDC		;YES, DO IT
25$:					;COUNT OUT LINKS
	ADD	#LE.SIZ,R1
	SOB	R3,15$			;KEEP LOOPING TILL ALL LINKS EXHAUSTED
30$:					;HERE WHEN FINISHED WITH LINE
	RESTOR	<SB>			;RESTOR REGISTER
NSPCHR:					;RETURN TO CALLER
	RTS	PC

	.SBTTL	         1.7.1  NSPSCF 0.0 17-MAY-76 -- SEND CONFIG


;***********************************************************************
;
;	NSPSCF 0.0 17-MAY-76 -- SEND CONFIG	  
;
;***********************************************************************


NSPSCF:					;SEND CONFIGURATION
	SAVE	<R1,R3,J>		;SAVE REGS
	MOV	#NSPCFS,R2		;SIZE OF CONFIGURATION SECTION IN LINE BLOCK
	CLRB	NSPNCT			;ZERO NCT
	JSR	PC,NSPBMG		;START A MESSAGE
	JSR	PC,NSPBNC		;AND PUT HEADER INTO IT
	JSR	PC,NSPPBY		;PUT DLA=0
	MOV	R5,NSPCNT		;SAVE POINTER
	JSR	PC,NSPPEX		;PUT 0 EXTENSIBLE COUNT
	MOV	R4,NSPCVL		;SAVE COUNT VALUE
	MOV	#5,R0			;TYPE = CONFIG
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	NSPLB,R3		;GET ADDRESS OF LINE BLOCK
	ADD	#LB.CNF,R3		;POINT TO CONFIG AREA
10$:					;HERE TO COPY CONFIGURATION
	TST	R2			;ANY MORE LEFT?
	BEQ	20$			;NO, DONE
	MOVB	(R3)+,R0		;GET OBJECT TYPE
	BEQ	20$			;IF ZERO, DONE
	JSR	PC,NSPPBY		;PUT OBJECT TYPE IN
	MOVB	(R3)+,R0		;GET COUNT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	CLR	R0			;ZERO PID
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	SUB	#2,R2			;WE HAVE USED UP TWO BYTES IN AREA
	BR	10$			;KEEP LOOKING
20$:					;HERE WHEN DONE COPYING CONFIG
	MOV	NSPMSG,R0		;POINT TO MESSAGE
	MOV	R4,CN.LEN(R0)		;STORE LENGTH
	MOV	NSPCNT,R5		;POINT BACK TO COUNT
	MOV	R4,R0			;GET CURRENT COUNT
	SUB	NSPCVL,R0		;SUBTRACT PREVIOUS
	JSR	PC,NSPPEX		;PUT INTO MESSAGE
	MOV	NSPMSG,R0		;GET MESSAGE POINTER
	JSR	PC,NCLIN1		;GIVE TO NCL  [mco 9696]
	RESTOR	<J>			;GET LINE BLOCK POINTER BACK
	BIC	#NS.CNF,LB.NSS(J)	;NO LONGER NEED TO SEND CONFIGURATION
	RESTOR	<R3,R1>			;RESTORE REST OF THE REGS
	RTS	PC			;AND RETURN

	.SBTTL	         1.7.2  NSPSDC 0.0 17-MAY-76 -- SEND DISCONNECT TO NSP


;***********************************************************************
;
;	NSPSDC 0.0 17-MAY-76 -- SEND DISCONNECT TO NSP	  
;
;***********************************************************************


NSPSDC:					;SEND DISCONNECT CONFIRM TO NSP
	SAVE	<J,R3,R1>		;SAVE REGS
	JSR	PC,NSPBMG		;START A MESSAGE
	MOV	#NSPCM,R0		;MSGFLG
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#2,R0			;TYPE = DISCONNECT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#5,R0			;SUBTYPE = 5 (CONFIRM),  REASON = 0
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JSR	PC,NSPSAD		;PUT ADDRESSES INTO MESSAGE
	JSR	PC,NSPDLE		;DELETE LINK TABLE ENTRY
	MOV	(SP),R1			;GET LINK ENTRY POINTER BACK
	BICB	#LES.SD,LE.STS(R1)	;WE HAVE SENT IT, SO CLEAR BIT
NSPSND:					;HERE TO SEND MESSAGE TO NSP
	MOV	NSPMSG,R0		;POINT TO BEGINNING OF MESSAGE
	MOV	R4,CN.LEN(R0)		;STORE LENGTH IN CHUNK
	MOV	NSPLB,J			;POINT TO LINE BLOCK
	MOV	LB.SCB(J),SB		;ALSO SCB
	MOV	SB,DNA			;STORE DESTINATION WHERE DDCMP WANTS IT
	MOV	#SOH,R2			;DDCMP WANTS STARTING CHAR IN R2
	JSR	PC,DDQNSP		;QUEUE IT UP
	RESTOR	<R1,R3,J>		;RESTORE REGS
	RTS	PC			;AND RETURN

	.SBTTL	         1.7.3  NSPSLS 0.0 17-MAY-76 -- SEND LINK STATUS


;***********************************************************************
;
;	NSPSLS 0.0 17-MAY-76 -- SEND LINK STATUS	  
;
;***********************************************************************


NSPSLS:					;SEND 0 LINK STATUS TO NSP
	SAVE	<J,R3,R1>		;SAVE REGS
	JSR	PC,NSPBMG		;START MESSAGE
	MOV	#NSPCM,R0		;MSGFLG
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#3,R0			;TYPE = LINK STATUS
	JSR	PC,NSPPBY		;PUT INTO MESSGE
	JSR	PC,NSPSAD		;PUT LINK ADDRESSES INTO MESSAGE
	CLR	R0			;ZERO FOR DATA REQUEST COUNT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	(SP),R1			;GET LINK ENTRY POINTER BACK
	BICB	#LES.SL,LE.STS(R1)	;WE HAVE SENT IT, SO CLEAR BIT
	PBRNCH	NSPSND			;AND SEND IT OFF

	.SBTTL	         1.7.4  NSPSAD 0.0 17-MAY-76 -- SEND ADDRESSES TO NSP


;***********************************************************************
;
;	NSPSAD 0.0 17-MAY-76 -- SEND ADDRESSES TO NSP	  
;
;***********************************************************************


NSPSAD:					;SEND DESTADDR AND SRCADDR
	MOVB	LE.NSP(R1),R0		;GET DESTINATION (NSP) ADDRESS
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOVB	LE.CON(R1),R0		;GET SOURCE (NCL CONVERTED) ADDRESS
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	RTS	PC

	.SBTTL	    1.10  NSPSUB 0.0 10-MAY-76 -- SUBROUTINES


;***********************************************************************
;
;	NSPSUB 0.0 10-MAY-76 -- SUBROUTINES	  
;
;***********************************************************************


	.SBTTL	         1.10.1  NSPCPY 0.0 10-MAY-76 -- COPY FROM LB TO SCB


;***********************************************************************
;
;	NSPCPY 0.0 10-MAY-76 -- COPY FROM LB TO SCB	  
;
;***********************************************************************


NSPCPY:					;COPY FROM LINE BLOCK TO SCB

; THIS SUBROUTINE DESTROYS R0, R1, R2, AND R3
;
; IT IS CALLED BY
;
;	JSR	PC,NSPCPY
;	.WORD	LBDISP			;LINE BLOCK DISPLACEMENT
;	.WORD	SCBDSP			;STATION CONTROL BLOCK DISPLACEMENT
;	.WORD	COUNT			;NUMBER OF BYTES TO COPY
;   --> ONLY RETURN

	MOV	@SP,R0			;GET RETURN PC INTO R0
	MOV	(R0)+,R1		;GET LINE BLOCK DISPLACEMENT
	ADD	J,R1			;MAKE INTO ADDRESS
	MOV	(R0)+,R2		;GET SCB DISPLACEMENT
	ADD	SB,R2			;MAKE INTO ADDRESS
	MOV	(R0)+,R3		;GET COUNT
	MOV	R0,@SP			;UPDATE RETURN PC
10$:					;LOOP TO COPY BYTES
	MOVB	(R1)+,(R2)+		;COPY BYTE FROM LB TO SCB
	SOB	R3,10$			;DECREMENT COUNTER, AND LOOP IF NOT DONE
	DEC	R2			;BACK UP DESTINATION POINTERONE
	BICB	#200,@R2		;CLEAR EXTENSIBLE BIT (IN CASE SOMEONE FORGOT)
	RTS	PC			;RETURN


	.SBTTL	         1.10.2  NSPEXC 0.0 15-MAY-76 -- COPY PROCESS NAME INTO MSG


;***********************************************************************
;
;	NSPEXC 0.0 15-MAY-76 -- COPY PROCESS NAME INTO MSG	  
;
;***********************************************************************


NSPEXC:					;WILL PUT OBJ-TYPE=0, PROCESS NAME, GROUP=0, USER=0 INTO OUTPUT MESSAGE
	CLR	R0			;OBJECT-TYPE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	MOV	#20$,10$+2		;POINT TO CHARACTER GET SUBROUTINE
	CLR	-(SP)			;ZERO COUNTER
10$:					;LOOP PUTTING IN BYTES OF EXTENSIBLE FIELD
	JSR	PC,20$			;GET NEXT BYTE
	CMP	(SP),#6			;CHECK IF ENOUGH
	BEQ	11$			;YES, JUST SKIP BYTES
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	INC	(SP)			;INCREMENT COUNTER
11$:					;HERE TO CHECK IF END OF EXTENSIBLE STRING
	BIT	#200,R0			;WAS EXTENSIBLE BIT ON?
	BNE	10$			;YES, KEEP LOOKING FOR MORE
	TST	(SP)+			;CLEAN UP STACK
	BICB	#200,-1(R5)		;CLEAR EXTENSIBLE BIT IN STRING
	CLR	R0			;GROUP=0
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	JSR	PC,NSPPBY		;PUT ZERO USER CODE INTO MESSAGE ALSO
	RTS	PC			;RETURN TO CALLER
20$:					;HERE TO GET NEXT CHARACTER TO PUT INTO STRING
	JSR	PC,GETBYT		;GET BYTE FROM MESSAGE
	MOV	R0,-(SP)		;SAVE IT ON STACK
	BIC	#177600,R0		;CLEAR EXTENSIBLE BIT
	CMP	#133,R0			;WAS IT "["?
	BNE	30$			;NO, SKIP
	MOV	(SP),R0			;YES, GET REAL CHARACTER BACK,
	MOV	#240,(SP)		;REPLACE WITH BLANK,
	MOV	#40$,10$+2		;AND POINT TO NEW CHARACTER GET ROUTINE
25$:					;LOOP TO FLUSH EXTRA CHARACTERS
	BIT	#200,R0			;WAS EXTENSIBLE BIT ON?
	BEQ	30$			;NO, DONE
	JSR	PC,GETBYT		;GET NEXT CHARACTER
	BR	25$			;AND CHECK IT TOO
30$:					;HERE TO PASS CHARACTER TO CALLER
	MOV	(SP)+,R0		;GET CHARACTER BACK
	RTS	PC			;AND RETURN
40$:					;HERE AFTER "[" SEEN
	MOV	#240,R0			;GET AN EXTENDED BLANK
	CMP	2(SP),#6		;HAS COUNT REACHED LIMIT YET?
	BLT	45$			;NO, BRANCH
	BIC	#200,R0			;YES, CLEAR EXTENSIBLE BIT
45$:					;HERE TO PASS CHARACTER BACK
	RTS	PC			;RETURN


	.SBTTL	         1.10.3  NSPFST 0.0 12-MAY-76 -- SET STRIP BIT


;***********************************************************************
;
;	NSPFST 0.0 12-MAY-76 -- SET STRIP BIT	  
;
;***********************************************************************


NSPFST:					;SEE IF THIS LINK WANTS STRIP COUNT/DATA
	CLRB	NSPFLG			;CLEAR FLAG BITS
	BIT	#LES.DV,LE.STS(R1)	;IS THIS A DEVICE?
	BNE	5$			;YES, DON'T STRIP
	BISB	#NSP.ST,NSPFLG		;NO, SET STRIP BIT
5$:					;HERE WHEN STRIP BIT OK
	RTS	PC			;RETURN

	.SBTTL	         1.10.4  NSPBMG 0.0 10-MAY-76 -- START OUTPUT MESSAGE


;***********************************************************************
;
;	NSPBMG 0.0 10-MAY-76 -- START OUTPUT MESSAGE	  
;
;***********************************************************************


NSPBMG:					;BEGIN AN OUTPUT MESSAGE
; THIS SUBROUTINE STARTS AN OUTPUT MESSAGE BY GETTING A CHUNK,
; AND INITIALIZING THE BYTE POINTER REGISTER (R5) AND THE
; COUNT REGISTER (R4).
;
; DESTROYS R0, R4, AND R5.
;
; CALL IS:
;
;	JSR	PC,NSPBMG
;   --> ONLY RETURN
;
; IF RETURN IS UNSUCCESSFUL, CARRY BIT IS SET.; ELSE CLEAR.
; UPON SUCCESSFUL RETURN, R4 CONTAINS 0 AND R5 POINTS TO FIRST
; BYTE OF MESSAGE.
	SEC				;ASSUME BAD RETURN
	JSR	PC,GETCNK		;GET A CHUNK
	BEQ	10$			;IF NONE, RETURN
	CLC				;SET GOOD RETURN CODE
	MOV	R0,NSPMSG		;SAVE START OF MESSAGE
	CLR	R4			;CLEAR COUNT REGISTER
	MOV	R0,R5			;PUT START ADDRESS INTO BYTE POINTER REGISTER
	CLR	CN.MLK(R5)		;CLEAR MESSAGE LINK
.IIF NE,DEVN,	CLR	CN.DDB(R5)	;AND DDB LINK
	ADD	#CN.NCT,R5		;POINT TO FIRST DATA BYTE
10$:					;HERE TO EXIT
	RTS	PC			;RETURN

	.SBTTL	         1.10.5  NSPPEX 0.0 10-MAY-76 -- PUT EXTENSIBLE FIELD INTO MSG


;***********************************************************************
;
;	NSPPEX 0.0 10-MAY-76 -- PUT EXTENSIBLE FIELD INTO MSG	  
;
;***********************************************************************


NSPPEX:					;SUBROUTINE TO PUT EXTENSIBLE NUMBER IN OUTPUT MESAGE
	MOV	R0,-(SP)		;SAVE VALUE
	JSR	PC,NSPEXB		;PUT BYTE WITH EXTENSIBLE BIT ON
	MOV	(SP)+,R0		;GET VALUE BACK
	ASL	R0			;SHIFT HIGH ORDER BIT OF LOW BYTE INTO HIGH BYTE
	SWAB	R0			;SWITCH BYTES
	BIC	#200,R0			;CLEAR EXTENSIBLE BIT
	PBRNCH	NSPPBY			;PUT BYTE INTO MESSAGE

NSPEXB:					;TURN ON EXTENSIBLE BIT AND PUT INTO MESSAGE
	BIS	#200,R0			;TURN ON EXTENSIBLE BIT
;	PJMP	NSPPBY			;PUT INTO MESSAGE

	.SBTTL	         1.10.6  NSPPBY 0.0 10-MAY-76 -- PUT BYTE INTO OUTPUT MESSAGE


;***********************************************************************
;
;	NSPPBY 0.0 10-MAY-76 -- PUT BYTE INTO OUTPUT MESSAGE	  
;
;***********************************************************************


NSPPBY:					;PUT A BYTE INTO OUTPUT MESSAGE
	CLC				;CLEAR ERROR INDICATOR
	MOVB	R0,(R5)+		;PUT BYTE AT POINTER AND ADVANCE POINTER
	INC	R4			;INCREMENT BYTE COUNT
	BIT	#CNKSIZ-1,R5		;IS IT NOW POINTING PAST END?
	BNE	20$			;NO, EXIT
	MOV	R0,-(SP)		;SAVE DATA ON STACK
	SEC				;ASSUME BAD RETURN
	JSR	PC,GETCNK		;GET A CHUNK
	BEQ	10$			;NONE, SO EXIT
	CLC				;CLEAR BAD RETURN INDICATOR
	MOV	R0,-CNKSIZ(R5)		;LINK NEW CHUNK TO OLD
	MOV	R0,R5			;POINT TO NEW CHUNK
	CLR	(R5)+			;CLEAR ITS FOWARD LINK
10$:					;HERE TO CLEAN STACK AND EXIT
	MOV	(SP)+,R0		;RESTORE DATA
20$:					;HERE TO EXIT
	RTS	PC			;RETURN

	.SBTTL	         1.10.7  NSPCLE 0.1 20-MAY-76 -- CREATE LINK ENTRY


;***********************************************************************
;
;	NSPCLE 0.1 20-MAY-76 -- CREATE LINK ENTRY	  
;
;***********************************************************************


NSPCLE:					;CREATE A LINK ENTRY
;  THIS SUBROUTINE CREATES A NEW LINK ENTRY, LEAVING
; THE ADDRESS OF THE ZEROED ENTRY IN R1.
;
;  IT EXPECTS THAT THE LINE BLOCK ADDRESS BE IN NSPLB.
;  IT ONLY MODIFIES R1 TO RETURN THE ADDRESS OF THE
; LINK ENTRY, OR 0 IF NO ENTRIES WERE AVAILABLE.
;
; CALL IS:
;
;	JSR	PC,NSPCLE
;	BEQ	FAIL
;
	SAVE	<R4,R3,R2,R0>		;SAVE SOME REGISTERS
	MOV	#LE.SIZ,R3		;GET SIZE OF LINK ENTRY
	MOV	NSPLB,R2		;GET LINE BLOCK ADDRESS
	MOV	R2,R0			;COPY IT
	ADD	#LB.LKT,R0		;POINT TO ADDRESS OF TABLE
	MOV	LB.LLE(R2),R1		;GET LAST USED ENTRY
	BEQ	5$			;NONE, SO GET ONE
	MOV	R1,R0			;COPY ENTRY ADDRESS
	BIC	#CNKSIZ-1,R0		;GET BEGINNING OF CHUNK
	ADD	#LE.SIZ*2,R1		;POINT TO PAST END OF NEW ENTRY
	ADD	#CNKSIZ,R0		;POINT PAST END OF CHUNK
	CMP	R1,R0			;COMPARE THE TWO
	BLOS	10$			;BRANCH IF IT WILL FIT
	SUB	#CNKSIZ,R0		;ELSE POINT TO BEGINNING OF CHUNK AGAIN
5$:					;HERE TO GET A CHUNK, CHAIN TO PREVIOUS
	MOV	R0,R4			;SAVE CURRENT CHUNK ADDRESS
	CLR	R1			;ASSUME THE WORST
	JSR	PC,GETCNK		;GET ANOTHER
	BEQ	20$			;EGADS, NO CHUNKS!
	MOV	R0,@R4			;POINT  LAST ONE AT THIS ONE
	CLR	@R0			;MAKE SURE NEW ONE POINTS NOWHERE
	MOV	R0,R1			;COPY CHUNK ADDRESS
	ADD	#LE.SIZ+2,R1		;ADD 2 FOR LINK PLUS ENTRY SIZE
10$:					;R1 POINTS TO NEW ENTRY + 1
	SUB	R3,R1			;BACK TO START OF ENTRY
	MOV	NSPLB,R0		;GET LINE BLOCK ADDRESS
	INC	LB.LCT(R0)		;INCREMENT COUNT OF LINKS ACTIVE
	MOV	R1,LB.LLE(R0)		;SAVE LAST ENTRY ADDRESS
	MOV	R1,R0			;COPY START OF ENTRY
15$:					;LOOP TO CLEAR OUT LINK ENTRY
	CLRB	(R0)+			;CLEAR THIS BYTE
	SOB	R3,15$			;LOOP TILL DONE
20$:					;HERE TO RESTORE REGS AND EXIT
	RESTOR	<R0,R2,R3,R4>		;CLEAN UP STACK
	TST	R1			;SET CONDITION FOR RETURN
	RTS	PC			;RETURN TO CALLER

	.SBTTL	         1.10.10  NSPDLE 0.0 20-MAY-76 -- DELETE LINK ENTRY


;***********************************************************************
;
;	NSPDLE 0.0 20-MAY-76 -- DELETE LINK ENTRY	  
;
;***********************************************************************


NSPDLE:					;DELETE LINK TABLE ENTRY
	SAVE	<R3,R2,R0>		;SAVE SOME REGISTERS
	MOV	NSPLB,R2		;GET LINE BLOCK ADDRESS
	MOV	LB.LLE(R2),R0		;GET LAST ENTRY
	ASSERT	NE			;BETTER NOT BE 0
	TST	LB.LCT(R2)		;GET COUNT OF ENTRIES
	ASSERT	NE			;BETTER BE SOME
	MOV	#LE.SIZ,R3		;GET SIZE OF ENTRY
10$:					;HERE TO COPY LAST INTO  DELETE ENTRY
	MOVB	(R0)+,(R1)+		;COPY ONE BYTE
	SOB	R3,10$			;LOOP TILL COUNT EXHAUSTED
	SUB	#LE.SIZ+2,R0		;CHECK IF THIS WAS FIRST ONE IN CHUNK
	BIT	#CNKSIZ-1,R0		;BEGINNING OF CHUNK?
	BNE	30$			;NO, JUST DECREMENT
	MOV	R2,R1			;POINT TO
	ADD	#LB.LKT,R1		;AND ADDRESS OF FIRST CHUNK
20$:					;LOOP LOOKING FOR NEXT TO LAST CHUNK
	TST	@(R1)			;IS NEXT CHUNK'S LINK 0?
	BEQ	21$			;YES, DONE
	MOV	@R1,R1			;NO, GET NEXT CHUNK
	BR	20$			;AND KEEP LOOKING
21$:					;HERE WITH R1 = NEXT TO LAST CHUNK
					;(OR POINTER IN LINE BLOCK IF ONLY 1)
	ASSERT	R0,EQ,@R1		;MAKE SURE IT IS CONSISTENT
	CLR	@R1			;DE-LINK FROM PREVIOUS
	JSR	PC,FRECKS		;FREE CHUNK
	MOV	#<LE.SIZ-2>,R0		;IN CASE NO MORE CHUNKS EXIST
	TST	LB.LKT(R2)		;DID WE FREE LAST CHUNK?
	BEQ	30$			;YES, DECREMENT COUNT (TO 0) AND EXIT
	MOV	R1,R0			;NO, COPY BEGINNING OF NEW LAST CHUNK
	ADD	#<<LEPCNK+1>*LE.SIZ>,R0	;POINT 2 BEFORE ENTRY AFTER LAST ENTRY
30$:					;HERE WHEN ENTRY MOVED
	DEC	LB.LCT(R2)		;ONE LESS ENTRY
	SUB	#<LE.SIZ-2>,R0		;ADJUST TO START OF LINK ENTRY
	MOV	R0,LB.LLE(R2)		;POINT TO NEW LAST ENTRY
	RESTOR	<R0,R2,R3>		;RESTORE REGISTERS
	RTS	PC			;RETURN TO CALLER

	.SBTTL	         1.10.11  NSPLES 0.1 20-MAY-76 -- SEARCH LINK ENTRIES


;***********************************************************************
;
;	NSPLES 0.1 20-MAY-76 -- SEARCH LINK ENTRIES	  
;
;***********************************************************************


NSPLES:					;SEARCH LINK ENTRIES
;  THIS SUBROUTINE SEARCHES THROUGH THE LINK ENTRIES THAT
; ARE ACTIVE FOR A DCP LINE.
;
;  IT RETURNS THE ADDRESS OF THE LINK ENTRY MATCHING
; THE CRITERION IN R1, OR 0 IF NONE IS FOUND.
;  IT MODIFIES NO OTHER REGISTER.
;
;
;  IT IS EXPECTED THAT THE VALUE TO BE COMPARED AGAINST IS IN R0,
; AND THAT THE COMPARING INSTRUCTION IS THEREFORE ONLY 2 WORDS
; LONG.
;
; THE CALL IS:
;
;	JSR	PC,NSPLES		;CALL ROUTINE
;	CMP	R0,LE.XXX(R1)		;THIS IS THE COMPARE INSTRUCTION
;	RTS	PC			;EVENTUAL RETURN IS TO HERE

	SAVE	<R3,R2,J>		;SAVE SOME REGISTERS
	MOV	NSPLB,J			;GET LINE BLOCK ADDRESS
	MOV	LB.LCT(J),R3		;GET COUNT OF ACTIVE ENTRIES
	MOV	LB.LKT(J),R2		;GET POINTER TO START OF ENTRIES
	BEQ	16$			;NONE, SO WE ARE FINISHED
	INC	R3			;ADD ONE TO COUNT
	BR	12$			;DO INITIAL CHUNK ADJUSTMENTS
10$:					;LOOP TO EXAMINE ENTRIES
	JSR	PC,@6(SP)		;DO COMPARISON
	BEQ	20$			;IF EQUAL, WE HAVE FOUND IT
	ADD	#LE.SIZ,R1		;OTHERWISE, POINT TO NEXT
	CMP	R1,R2			;ARE WE PAST END?
	BLO	15$			;NO, CONTINUE
	SUB	#CNKSIZ,R2		;YES, POINT TO BEGINNING OF CHUNK
	MOV	@R2,R2			;GET LINK
12$:					;ADJUST REG VALUES AT BEGINNING OF CHUNK
	MOV	R2,R1			;COPY START OF CHUNK
	ADD	#CNKSIZ,R2		;POINT TO END OF CHUNK IN R2
	ADD	#2,R1			;POINT TO FIRST ENTRY WITHIN CHUNK IN R1
15$:					;COUNT OUT LINK ENTRIES
	SOB	R3,10$			;DECREMENT COUNT AND TRY AGAIN
16$:					;HERE IF NOT FOUND
	CLR	R1			;ZERO RETURN REGISTER
20$:					;HERE TO RETURN
	RESTOR	<J,R2,R3>		;RESTORE REGISTERS
	ADD	#4,@SP			;UPDATE PC FOR RETURN
	TST	R1			;SET CONDITION
	RTS	PC			;RETURN

	.SBTTL	         1.10.12  NSPFDL 0.1 20-MAY-76 -- FIND NSP DLA


;***********************************************************************
;
;	NSPFDL 0.1 20-MAY-76 -- FIND NSP DLA	  
;
;***********************************************************************


NSPFDL:					;FIND DLA AS NSP ADDRESS
	JSR	PC,NSPLES		;DO SEARCH
	CMPB	R0,LE.NSP(R1)		;WITH THIS COMPARE ROUTINE
	RTS	PC			;RETURN (BOTH FOR COMPARE ROUTINE AND FINAL EXIT)

	.SBTTL	         1.10.13  NSPFDA 0.1 20-MAY-76 -- FIND NCL DESTADDR


;***********************************************************************
;
;	NSPFDA 0.1 20-MAY-76 -- FIND NCL DESTADDR	  
;
;***********************************************************************


NSPFDA:					;FIND DESTADRR AS CONVERTED NCL ADDRESS
	JSR	PC,NSPLES		;DO SEARCH
	CMPB	R0,LE.CON(R1)		;WITH THIS COMPARE ROUTINE
	RTS	PC			;RETURN (BOTH FOR COMPARE ROUTINE AND FINAL EXIT)

	.SBTTL	         1.10.14  NSPBCO 0.0 15-MAY-76 -- MAKE UNIQUE NCL LINK ADDR


;***********************************************************************
;
;	NSPBCO 0.0 15-MAY-76 -- MAKE UNIQUE NCL LINK ADDR	  
;
;***********************************************************************


NSPBCO:					;BUILD CONVERTED NCL LINK ADDRESS
	MOV	R1,-(SP)		;SAVE LINK ENTRY ADDRESS
	MOV	LE.NCL(R1),R0		;PICK UP NCL LINK ADDRESS
	BIC	#^C277,R0		;CLEAR UPPER BYTE
	JSR	PC,NSPFDA		;SEARCH FOR THIS IN TABLE
	BNE	20$			;WAS ALREADY THERE, WE HAVE TO LOOP
10$:					;HERE WHEN WE FOUND A UNIQUE VALUE FOR LE.CON
	MOV	(SP)+,R1		;RESTORE LINK ENTRY POINTER
	MOVB	R0,LE.CON(R1)		;SAVE VALUE
	RTS	PC			;RETURN TO CALLER
20$:					;HERE TO LOOP THROUGH POSSIBLE VALUES
	MOV	#1,R0			;INITIAL VALUE
30$:					;LOOP TO CHECK IF VALUE ALREADY IN TABLE
	BIT	#277,R0			;HAVE WE PAST ONE BYTE?
	BEQ	10$			;YES, NO UNIQUE VALUE
	JSR	PC,NSPFDA		;CHECK THIS VALUE
	BEQ	10$			;NO ENTRY, SO WE ARE DONE
	INC	R0			;MAKE NUMBER ONE HIGHER
	BR	30$			;AND CONTINUE LOOP

	.SBTTL	         1.10.15  NSPBNC 0.0 16-MAY-76 -- MAKE NCL HEADER


;***********************************************************************
;
;	NSPBNC 0.0 16-MAY-76 -- MAKE NCL HEADER	  
;
;***********************************************************************


NSPBNC:					;SUBROUTINE TO PUT NCL HEADER INTO MESSAGE
	MOV	#NCFSEQ+NCFSNA,R0	;PROTOTYPE NCT
	MOVB	NSPNCT,-(SP)		;GET NCT SKELETON
	ADD	(SP)+,R0		;ADD SKELETON BITS TO R0 VALUE
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	ADD	#LB.DNA,NSPLB		;POINT TO DESTINATION NODE ADDRESS
	MOVB	@NSPLB,R0		;GET IT
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	DEC	NSPLB			;POINT TO LB.NNM (WHICH IMMEDIATELY PRECEDS LB.DNA)
	MOVB	@NSPLB,R0		;AND GET NSP NODE NUMBER
	JSR	PC,NSPPBY		;PUT INTO MESSAGE
	SUB	#LB.NNM,NSPLB		;RESTORE THIS TO LINE BLOCK ADDRESS
	CLR	R0			;ZERO FOR NCA AND NCN
	JSR	PC,NSPPBY		;PUT NCA INTO MESSAGE
	JSR	PC,NSPPBY		;PUT NCN INTO MESSAGE
	RTS	PC			;RETURN TO CALLER

	.SBTTL	         1.10.16  NSPQ 0.0 17-MAY-76 -- WAKE NSP UP


;***********************************************************************
;
;	NSPQ 0.0 17-MAY-76 -- WAKE NSP UP	  
;
;***********************************************************************


NSPQ:					;QUEUE A REQUEST TO NSP
	SAVE	<J,R2>			;SAVE REGS
	MOV	NSPLB,J			;POINT TO LINE BLOCK
	PIOFF				;TURN OFF INTERRUPTS
	BIT	#NS.NSQ,LB.NSS(J)	;ALREADY SOMETHING QUEUED?
	BNE	10$			;YES, EXIT
	BIS	#NS.NSQ,LB.NSS(J)	;NO, INDICATE THAT NOW THERE IS
	CMP	NS.PTR,#<NS.QUE+NS.SIZ>	;IS PUTTER PAST END?
	BLO	5$			;NO, BRANCH
	MOV	#NS.QUE,NS.PTR		;YES, RESET TO BEGINNING
5$:					;HERE TO ACTUALLY PUT DATA INTO QUEUE
	MOV	J,@NS.PTR		;LINE BLOCK ADDRESS AT PUTTER
	ADD	#2,NS.PTR		;ADVANCE PUTTER
10$:					;HERE WHEN DONE
	PION				;ALLOW INTERRUPTS AGAIN
	RESTOR	<R2,J>			;RESTORE REGS
	RTS	PC			;RETURN

.ENDC; NE,FTDCP1
