.SBTTL	CHK11 -  ONCE ONLY SYSTEM DIAGNOSTIC  18 AUG 82

.REPT 0

COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1977,1978,1979,1980,1981,1984,1988.
ALL RIGHTS RESERVED.


THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
TRANSFERRED.

THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
CORPORATION.

DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.ENDR




; Version 3(71)  18 AUG 82	DMCC/EGF/JBS/LAD/KR/EJW/MM/DRL/KR/DRL/KR/DRL
;	Revision History

; 1(13)	08-Sep-76 JBS	Started revision history
; 1(14)	19-Oct-76 KR	Added DZ11 code and support to count devices below it
;			Also added more timing before RESET, and CPU type
;			checking
;			as well as fixing bug in core reporting on 11/34
; 1(15)	03-Nov-76 KR	fixed bug in 11/05 CPU determination
; 1(16)	04-NOV-76 JBS	INCLUDED EJW'S DTE CHECKING
; 1(17)	29-DEC-76 JBS	INCLUDED SOME DN61-S CODE
; 1(20)	21-JAN-77 JBS	REMOVED USE OF SPL INSTRUCTION
; 1(21) 25-JAN-77 JBS	STARTED ADDING DN20 CODE (INCOMPLETE)
; 1(22) 28-JAN-77 JBS	SUPPORT DS11 ONLY ON DC75 (CONFLICT WITH LP20)
; 1(23) 31-JAN-77 JBS	ASSUME NOT DN20 ADDRESSING UNLESS REQUESTED
; 1(24) 01-FEB-77 JBS	MINOR LISTING CLEANUP
; 1(25) 14-FEB-77 JBS	UPDATED LEGAL NOTICE AS PER 005-003-286-03
; 1(26)	09-MAR-77 JBS	STORE DTE20 ADDRESSES AND VECTORS
;			 AND DO SOME LISTING CLEANUP
; 1(27) 21-MAR-77 JBS	REMOVE KGLOAD MACRO
;
; 1(30) 01-APR-77 JBS	CHANGE NAME TO DN61
; 1(31)	06-APR-77 MM	SAVE INTERRUPT VECTOR LOCATION
;			IN A DIFFERENT GLOBAL CELL DTEDTO
; 1(32) 12-APR-77 JBS	FIX SUPPRESSION OF KG11-A MESSAGE
; 1(33)	14-APR-77 JBS	FIX DUP11 VECTOR CALCULATION
;			 AND ADD KMC11
; 1(34) 17-MAY-77 JBS	REMOVE EXPLICIT REFERENCES TO PS REGISTER AND
;			 FILL VECTOR SPACE TO 1200 INSTEAD OF 1000.
; 1A(35) 27-JUN-77 JBS	IMPROVE KMC11 CHECKING AND START IT
;			 IF REQUESTED.
; 1A(36) 30-JUN-77 JBS	IMPROVE KMC11 CHECKING AGAIN AND LOAD ITS
;  TO 1A(37)		 CRAM IF REQUESTED.
; 2(40)	18-JUL-77 JBS	CHANGE VERSION NUMBER TO 2, DONT LOAD
;			 KMC11 CRAM IF SIZE11 DID.
; 2(41)	12-SEP-77 JBS	DONT LOAD MORE THAN 2000 OCTAL
;			 WORDS OF KMC11 CRAM (I.E., DONT LOAD
;			 THE VERSION NUMBER).
; 2(42)	13-SEP-77 JBS	REMOVE ALL REFERENCES TO REGISTER 'P'.
; 2(43)	14-OCT-77 JBS	FIX KMC11 STARTING LOOP TO START MORE
;			 THAN ONE KMC11
; 2(44) 16-JAN-78 DRL	FILL ONLY TO 1000 NOT 1200 FOR VECTORS
;			 (THIS PREVENTS SCREWING DDT.P11)
; 3(45) 16-JAN-78 DRL	CORRECT DC75 CONDITIONALS
;			 UPDATA VERSION NUMBER
;			 TAKE OUT EXTRA DC75 CODE
;			 FIX DL10 TESTS
; 3(46) 23-JAN-78 DRL	RESTRUCTURE DEVICE MACROS, AND
;			 FIX WAY CODE IS INCLUDED OR NOT
; 3(47) 2-Mar-78 KR	Add code to check all of memory, using
;			 memory management if present
; 3(50) 5-Mar-78 KR	Add code to distinguish types of KMC11's on DN20
; 3(51) 21-JUN-78 DRL	Fix timing problems for dz11's
; 3(52) 7-jul-78 drl	Add LP20 code
; 3(53) 3-AUG-78 DRL	Make the LP20 code a little smarter
; 3(54) 5-Sep-78 KR	Add DMC11 code, and make DZ11 code skip echo test
;			if interrupt didn't occur (since it will
;			always fail as well)
; 3(55) 12-Sep-78	Allow DL10 on other than 100000
; 3(57) 26-Sep-78	Put back .BLKB at CKBLK
; 3(60) 27-NOV-78 DRL	FEATURE TEST THE CONTINUE ON ERROR STUFF
; 3(64) 26-JUN-79 DRL	FIX DMC BUG (MR NOT SET AT RIGHT TIME)
;			FIX TYPO FOR DL11 CODE
;	22-jun-84	Add plotter entry vectors for remote station [CCS-001]


VRCHK1=071
; THIS CODE IS EXECUTED ONCE AND THEN OVERLAID WITH TABLES
;
; CALL TO CHK11 IS AS FOLLOWS:
;	JSR	PC,CHK.11
;	.ASCIZ	\PROGRAM NAME\
;	RETURNS BY JUMP TO 'BEGIN'
;	OR TO  'CKDONE' IF THIS IS DEFINED
;
;	CHK11 WILL DETERMINE WHAT HARDWARE IS PRESENT
;	  AND WILL PERFORM A FEW SIMPLE DIAGNOSTIC TESTS OF THE HDW
;
;	FOR DEV = < DH11, DM11BB, DP11, DQ11, DS11, DU11>
;	CHK11 WILL:	JSR PC,CKA'DEV
;			WITH (R3) = DEVICE VECTOR
;			AND (R4) = DEVICE ADR
;			AND (R1) = DEVICE ADR
;	ONCE FOR EACH DEVICE AND A FINAL:
;			JSR	PC,CKA'DEV WITH (R4)=0
;
; ALL SYMBOLS BEGINING CHK OR CK ARE RESERVED FOR CHK11
;	DEFINE CONDITIONALS WE USE, IF THE ARE NOT YET DEFINED


;	DO NODE TYPED FIRST

	ND	FT.D75,0	; NO DC75 IN SYSTEM
	ND	FT.D80,0	; NO DN80 IN SYSTEM
	ND	FT.D81,0	; NO DN81 IN SYSTEM
	ND	FT.D82,0	; NO DN82 IN SYSTEM
	ND	FT.D85,0	; NO DN85 IN SYSTEM
	ND	FT.D87,0	; NO DN87 IN SYSTEM
	ND	FT.87S,0	; NO DN87S IN SYSTEM
	ND	FT.D20,0	; NO DN20 IN SYSTEM
	ND	FT.D22,0	; NO DN22 IN SYSTEM
	ND	FT.200,0	; NO DN200 IN SYSTEM


; NOW DO DEVICES

	ND	FT.KMC,0	;0 TO NOT START KMC11

;OTHER DEFAULTS
	ND	FLOATV,300	;FIRST FLOATING VECTOR
	ND	FLOATD,160000	;FLOATING DEVICES BEGIN HERE + 10 [1(14)]

	ND	CKDONE,BEGIN
	ND	DL10AD,.
	.BLKW	1		;PUT DL10 ADR HERE IF NOWHERE ELSE

.SBTTL		CHK11 MACRO'S

;THIS MACRO IS USED FOR TYPING TEXT AND/OR FOR
;ERROR REPORTING.
;
;	ARG	BITS	;WHAT TO DO ON A TRAP
		CKEFAT=	B0	;FATAL ERROR - HALT
		CKEPC=	B1	;PRINT ADDRESS OF ERROR TRAP
		CKEMSG=	B2	;PRINT THE MESSAGE FOLLOWING CK11SC
		CKEDID=	B3	;PRINT DEVICE ID AND REG
		CKEMSE=	B4	;PRINT THE MESSAGE POINTED TO BY
				; THE ADDRESS FOLLOWING THE TRAP.
		CKENCL=	B5	;PRINT TEXT WITH OUT CR+LF
		CKEGB=	B6	;PRINT ADR/REG=XXXXX GD=XXXXX  BD=XXXXX XOR=XXXXX
		CKADPH=B7	;address is virtual, print physical [3(47)]
;
;	ARG	MSG	;TEXT TO BE OUTPUT
;
;	ARG	COMENT	;ADD A COMMENT TO TRAP
;
;	ARG	STOPCD	;ON A FATAL ERROR VALUE TO BE PUT IN R0
;
.MACRO	CK11SC	BITS,MSG,COMENT,STOPCD
.NCHR	CKZZZX,<MSG>
.IIF NB,STOPCD,	MOV	#STOPCD,CKSPCD	;VALUE TO DISPLAY IN R0,
					;AND DATA LIGHTS ON FATAL ERROR
.IIF	EQ,CKZZZX,	TRAP	BITS		;COMENT
.IF	NE,CKZZZX
.IF	EQ,<BITS&CKEMSE>
	TRAP	BITS!CKEMSG		;COMENT
;	ASCIZ	<MSG>
.ENDC
.IF	NE,<BITS&CKEMSE>
	TRAP	BITS&<^CCKEMSG>		;COMENT
	.WORD	MSG			;ADR OF MESSAGE
.ENDC
.ENDC
.ENDM	CK11SC



;THIS MACRO IS USED TO CHECK INTERRUPT CONDITIONS
;
;	ARG	ENBADR		;DEVICE ADR TO ENABLE INTERRUPTS
;
;	ARG	INTADR		;DEVICE ADR TO GENERATE AN INTERRUPT
;
;	ARG	ENLBIT		;BIT TO ENABLE INTERRUPTS
;
;	ARG	INTBIT		;BITS TO CHECK INTERRUPT CONDITIONS
;
;	ARG	BITCLR		;BITS TO CLEAR INTERRUPT CONDITIONS
;				;IF CLEARING INTERRUPT BITS WON'T CLEAR
;				;THEM.  [EXAMPLE - DL10]
;
;	ARG	INTSUB		;subroutine to cause interrupt, if normal bit
;				;setting doesnt work. Otherwise 0.
;
.MACRO	$CKINT	ENBADR,INTADR,ENLBIT,INTBIT,BITCLR,INTSUB
.IIF	NB,ENBADR,	MOV	ENBADR,R1			;LOAD ENABLE ADR
.IIF	NB,INTADR,	MOV	INTADR,R2			;LOAD INTERRUPT ADR
	JSR	R5,CKINT		;GO CHECK INTERRUPTS
	.WORD	ENLBIT			;ENABLE BITS -  ENLBIT
	.WORD	INTBIT			;INTERRUPT BITS -  INTBIT
.IIF	B,BITCLR,	.WORD	0			;NO SPECIAL CLEAR BITS
.IIF	NB,BITCLR,	.WORD	BITCLR			;BITS TO CLEAR DEVICE - BITCLR
.IIF	B,INTSUB,	.WORD	0			;no interrupt SUB,routine needed
.IIF	NB,INTSUB,	.WORD	INTSUB			;subroutine to generate interrupt
.ENDM	$CKINT

;THIS MACRO IS USED TO TO CALL THE ROUTINE TO CHECK A DEVICE
;AND ASSIGN THE FLOATING ADDRESS AND VECTORS IF THE DEVICE
;IS THE TYPE THAT REQUIRES IT.
;
;	ARG	A		;DEVICE ADDRESS OR 0 IF FLOATING DEVICE
;
;	ARG	MAXN		;MAXIMUM NUMBER OF DEVICES
;
;	ARG	VI		;VECTOR INCREMENT
;
;	ARG	HI		;HARDWARE INCREMENT
;
;	ARG	VM		;VECTOR MULTIPLE
;
;	ARG	NAM		;ADDRESS OF DEVICE NAME
;
;	ARG	FV		;FIRST VECTOR ADR (FIXED DEV ONLY)
;
.MACRO	DEVICE	A,MAXN,VI,HI,VM,NAM,FV

;DETERMINE HOW MANY NAM'11S IN SYSTEM

	JSR	R5,CHKDEV		;ADJUST FLOATING VECTOR FOR NAM'11
	.WORD	A			;1ST NAM'11 ADR IS A
	.BYTE	<MAXN>,<VI>		;MAXIMUM NUMBER OF NAM'11 IS MAXN,
					; VECTOR INCREMENT IS VI
	.BYTE	<HI>,<VM>		;HARDWARE INCREMENT IS HI,
					; 1ST VECTOR MULTIPLE IS VM
	.WORD	0			;WILL BECOME NUMBER OF DEVICES
	.WORD	CKN'NAM'11			;ADDRESS OF ASCIZ \NAM'11\
	.IIF NDF CK..'NAM,CK..'NAM=1
	.IIF DF CK'NAM'11,CK'NAM'$$=CK'NAM'11	;IF DEFINED, USE THE PROC
	.IIF NDF CK'NAM'11,CK'NAM'$$=CKPOPJ	;ELSE JUST EXIT
	.WORD	CK'NAM'$$			;ADDRESS OF ROUTINE TO CHECK
						; DEVICE (CK'NAM'11)
	.IIF DF CKA'NAM'11,CKA'NAM'$$=CKA'NAM'11 ;IF PROGRAM ENTRY DEFINED, USE IT
	.IIF NDF CKA'NAM'11,CKA'NAM'$$=CKPOPJ	;ELSE JUST EXIT
	.WORD	CKA'NAM'$$			;CALL FOR MAIN PROGRAM (CKA'NAM'11)
	.WORD	CKV'NAM'11			;POINTS TO VECTOR SETUP TABLE
	.WORD	0			;WILL CONTAIN NUMBER OF NAM'11 FOUND
	.WORD	0			;WILL CONTAIN FIRST NAM'11 VECTOR ADR
.IIF NDF,NAM'.LVL,NAM'.LVL=0
	.WORD	NAM'.LVL*40		;CONTAINS NAM'11 PI LEVEL
	.WORD	FV			;DEVICE FIRST VECTOR (FIXED DEV ONLY)
.ENDM	DEVICE


.MACRO	NODEV	TYPE
	.IRP	TYPX,<TYPE>
		.IIF NDF CK..'TYPX,CK..'TYPX=0
	.ENDR
.ENDM
;THIS MACRO IS USED FOR SETTING CHARACTERISTICS TABLE
;
;	ARG	DA		;DEVICE ADDRESS TO PUT IN CHARACTERISTICS TABLE
;
;	ARG	DV		;DEVICE VECTOR ADDRESS TO PUT IN TABLE
;
;	ARG	PI		;DEVICE PI LEVEL TO PUT IN TABLE
;
.MACRO	CHKCHR	DA,DV,PI
.IIF	NB,<DA>,	MOV	DA,CHKCHR+CKDA		;PUT DA IN DEVICE ADR SLOT
.IIF	NB,<DV>,	MOV	DV,CHKCHR+CKDV		;PUT DV IN DEVICE VEC SLOT
.IIF	NB,<PI>,	MOV	PI,CHKCHR+CKPI		;PUT PI IN DEVICE INT LVL SLOT
.ENDM	CHKCHR

;THIS MACRO CALLS MACRO "CKVEC1" WHICH BUILDS A TABLE
;FOR EACH DEVICE.  THE INFORMATION IN THE TABLE IS OF THE FOLLOWING FORM:
;
;	CKV'NAM'11:.BYTE	NUMBER OF MAIN ROUTINES,NUMBER OF VECTOR PER DEV
;		.WORD	NAM'VA'NUM
;
;	EXAMPLE:
;
;	1.	MAIN PROGRAM HAS 1 DQ11
;
;		THE MAIN PROGRAM MUST GIVE DQ #0 VECTOR A THE TAG:  DQVA0
;
;					   DQ #0 VECTOR B THE TAG:  DQVB0
;
;	THE RESULTING TABLE WILL BE:
;
;	CKVDQ11:.BYTE	1,2
;		DQAV0
;		DQBV0
;
;	2.	MAIN PROGRAM HAS 2 DQ11'S
;
;		THE MAIN PROGRAM MUST GIVE DQ #0 VECTOR A THE TAG:  DQVA0
;					   DQ #0 VECTOR B THE TAG:  DQVB0
;					   DQ #1 VECTOR A THE TAG:  DQVA1
;					   DQ #1 VECTOR B THE TAG:  DQVB1
;
;	THE RESULTING TABLE WILL BE:
;
;	CKVDQ11:.BYTE	2,2
;		DQVA0
;		DQVB0
;		DQVA1
;		DQVB1
;
;
;	ARG	NAM		;NAME (2 CHARACTERS)
;
;	ARG	NUMV		;NUMBER OF VECTORS PER DEVICE
;
;	ARG	MAXN		;MAXIMUM NUMBER OF DEVICES OF A TYPE
;
.MACRO	CKVECT	NAM,NUMV,MAXN
	.IF NE CK..'NAM
		CKZQZQ=0
		CKV'NAM'11:.BYTE	NAM'QQQ,NUMV			;NUM OF VEC FOR EACH NAM'11 IS NUMV
		NAM'QQQ=0				;DEFINE AND SET TO 0
		.REPT	MAXN
			CKVEC1	NAM,NUMV,\CKZQZQ
			CKZQZQ=CKZQZQ+1
		.ENDR
	.ENDC ;.IF NE CK..'NAM
.ENDM	CKVECT
;
.MACRO	CKVEC1	NAM,NUMV,NUM
.IF	DF,NAM'VA'NUM
	NAM'QQQ=NAM'QQQ+1		;COUNT NUMBER IN MAIN
.IIF	GE,<NUMV-1>,	.WORD	NAM'VA'NUM			;VECTOR A FOR DEV NAM'11
.IIF	GE,<NUMV-2>,	.WORD	NAM'VB'NUM			;VECTOR B FOR DEV NAM'11
.IIF	GE,<NUMV-3>,	.WORD	NAM'VC'NUM			;VECTOR C FOR DEV NAM'11
.IIF	GE,<NUMV-4>,	.WORD	NAM'VD'NUM			;VECTOR D FOR DEV NAM'11
.ENDC
.ENDM	CKVEC1

;THIS MACRO IS USED FOR SAVING GOOD, BAD, AND ADR ON THE STACK
;PRIOR TO CALLING "CHKERR".
;
;	ARG	GD		;GOOD DATA
;
;	ARG	BD		;BAD DATA
;
;	ARG	ADR		;ADDRESS WHERE IT HAPPENED
;
.MACRO	CKSERR	GD,BD,ADR
	MOV	GD,-(SP)			;SAVE GOOD (GD) ON STACK
	MOV	BD,-(SP)			;SAVE BAD (BD) ON STACK
	MOV	ADR,-(SP)		;SAVE ADDRESS (ADR) ON STACK
.ENDM	CKSERR

	.SBTTL		DEFINE DEVICE BLOCKS FOR EACH NODE TYPE

;	THE CHOICES ARE:
;		1	DC75
;		2	DN80/81/82
;		3	DN85/87
;		4	DN87S
;		5	DN20/21/22/200
;
;	EACH OF THESE ASSIGNS VECTORS AND CSR'S IN A DIFFERENT MANNER.

CKCDEV:		;NOTHING BUT DEVICE MACROS MAY EXIST BETWEEN THE LABELS
		;CKCDEV AND CKCEND, AS THESE MACROS CAUSE CODE & TABLES
		;TO BE BUILD. ALSO, THE SYMBOL CKCADD MUST BE DEFINED
		; TO BE .-CKCDEV AFTER THE FIRST DEVICE MACRO FOR EACH
		; TYPE OF SYSTEM (I.E. THE LENGTH OF THE DEVICE MACRO).
.SBTTL		DEVICE MACROS FOR ALL POSSIBLE CONFIGURATIONS
.REPT 0

DEVICE	CTISTS,1,0,0,0,KL,CTOVEC	;OPR TTY (DL11-A)
DEVICE	CR.STS,1,0,0,0,CR,CR.VEC	;CARD READER (CR11)
DEVICE	LP.STS,2,<-10>,10,0,LP,LP.VEC	;LINE PRINTER (LP11)
DEVICE	PP.STS,1,0,0,0,PP,PP.VEC	;PAPER TAPE PUNCH (PP11)
DEVICE	PR.STS,1,0,0,0,PR,PR.VEC	;PAPER TAPE READER (PR11)
DEVICE	XY.STS,1,0,0,0,XY,XY.VEC	;PLOTTER (XY11)
DEVICE	TC.STS,1,0,0,0,TC,TC.VEC	;DEC TAPE CONTROL (TC11)
DEVICE	TM.STS,1,0,0,0,TM,TM.STS	;MAG TAPE CONTROL (TM11)
DEVICE	177446,1,0,0,0,RC,210		;OLD SMALL DISK (RC11)
DEVICE	177460,1,0,0,0,RF,204		;FIXED HEAD DISK (RF11)
DEVICE	176700,1,0,0,0,RH,254		;FANCY DISK CONTROLER (RH11)
DEVICE	176710,1,0,0,0,RP,254		;DISK PACK CONTROL (RP11-C)
DEVICE	177500,1,0,0,0,TA,260		;CASSETTE TAPE (TA11)
DEVICE	177404,1,0,0,0,RK,220		;DISK CARTRIDGE CONTROL (RK11)
DEVICE	172540,1,0,0,0,KP,104		;REAL TIME CLOCK (KW11-P)
DEVICE	DS.DVA,1,20,10,0,DS,DS.VEC	;SYNC I/O (DS11)
DEVICE	174400,1,0,0,0,TE,774		;TEN/ELEVEN INTERFACE (DTE20-#0)
DEVICE	174440,1,0,0,0,TE,770		;TEN/ELEVEN INTERFACE (DTE20-#1)
DEVICE	174500,1,0,0,0,TE,764		;TEN/ELEVEN INTERFACE (DTE20-#2)
DEVICE	174540,1,0,0,0,TE,760		;TEN/ELEVEN INTERFACE (DTE20-#3)
;
;	DN87S/DN61S NON FLOATING HARDWARE
;
DEVICE	176000,1,0,0,0,DL,300		;TTY INTERFACE (DL11-E)
DEVICE	160020,10,20,20,0,DH,330	;MULTIPLEX TTY INTERFACE (DH11)
DEVICE	170500,10,20,10,0,DM,320	;MODEM CONTROL INTERFACE (DM11)
DEVICE	175200,20,4,10,0,DN,660		;AUTO CALL UNIT (DN11)
DEVICE	160230,14,10,10,0,DQ,520	;DMA SYNC I/O (DQ11)
;
;	END DN87S/DN61S
;
;	DN20/DN21 NON FLOATING HARDWARE
;
DEVICE	160540,3,10,10,0,MH,540		;INTERFACE PROCESSOR (KMC11) for DUP11
DEVICE	160640,3,10,10,0,ME,300		;KMC11 for DZ
DEVICE	160740,20,10,10,0,MC,670	;DMC11
DEVICE	160300,14,10,10,0,UP,570	;INTERUPT SYNC I/O WITH BIT STUFFER (DUP11)
DEVICE	160010,20,10,10,0,DZ,340	;ASYNC MULTIPLEX I/O (DZ11)
DEVICE	L20STS,2,<-4>,<-20>,0,L2,L2.VEC	;LP20 CONTROLLER
;
;	END DN20/DN21
;
DEVICE	174770,40,10,<-10>,10,DP,0	;INTERUPT SYNC I/O (DP11)
DEVICE	172600,20,4,10,4,R6,0		;TYPESET PAPER TAPE READER (PA611)
DEVICE	172700,20,4,10,4,P6,0		;TYPESET PAPER TAPE PUNCH (PA611)
DEVICE	175200,100,4,10,4,DN,0		;AUTO CALL UNIT (DN11)
DEVICE	170500,20,4,10,10,DM,0		;MODEM CONTROL INTERFACE (DM11)
DEVICE	175000,4,14,40,14,DV,0		;SYNC PREPROCESSOR (DV11)
DEVICE	175610,20,10,10,10,DL,0		;ASYNC I/O (DL11-E)
DEVICE	0,20,10,10,10,DJ,0		;MULTIPLEXED ASYNC I/O (DJ11)
DEVICE	0,20,10,20,10,DH,0		;MULTIPLEXED DMA ASYNC I/O (DH11)
DEVICE	0,20,10,10,10,DQ,0		;DMA SYNC I/O (DQ11)
DEVICE	0,20,10,10,4,DU,0		;SYNC I/O WITH SYNC FILL (DU11)
DEVICE	0,20,10,10,4,UP,0		;SYNC I/O WITH BIT STUFFER (DUP11)
DEVICE	0,1,10,10,4,LK,0		;SPACEWAR BUTTONS ON GT40 (LK11)
DEVICE	0,20,10,10,4,MC,0		;DDCMP SYNC I/O (DMC11)
DEVICE	0,10,10,10,4,DZ,0		;MULTIPLEXED ASYNC I/O WITH FIFO (DZ11)
DEVICE	0,3,10,10,4,MD,0		;INTERFACE PROCESSOR (KMC11)
.ENDR
.SBTTL		DC75 DEVICE VECTORS
.IF NE FT.D75
DEVICE	CTISTS,1,0,0,0,KL,CTOVEC	;OPR TTY (DL11-A)
CKCADD=.-CKCDEV
DEVICE	172540,1,0,0,0,KP,104		;REAL TIME CLOCK (KW11-P)
DEVICE	DS.DVA,1,20,10,0,DS,DS.VEC	;SYNC I/O (DS11)
.ENDC	;.IF NE FT.D75
.SBTTL		DN80,DN81,DN82 VECTOR TABLES
.IF NE FT.D80!FT.D81!FT.D82
DEVICE	CTISTS,1,0,0,0,KL,CTOVEC	;OPR TTY (DL11-A)
CKCADD=.-CKCDEV
DEVICE	CR.STS,1,0,0,0,CR,CR.VEC	;CARD READER (CR11)
DEVICE	LP.STS,2,<-10>,10,0,LP,LP.VEC	;LINE PRINTER (LP11)
DEVICE	PP.STS,1,0,0,0,PP,PP.VEC	;PAPER TAPE PUNCH (PP11)
DEVICE	PR.STS,1,0,0,0,PR,PR.VEC	;PAPER TAPE READER (PR11)
DEVICE	XY.STS,1,0,0,0,XY,XY.VEC	;PLOTTER (XY11)
DEVICE	172540,1,0,0,0,KP,104		;REAL TIME CLOCK (KW11-P)
DEVICE	174770,40,10,<-10>,10,DP,0	;INTERUPT SYNC I/O (DP11)
DEVICE	172600,20,4,10,4,R6,0		;TYPESET PAPER TAPE READER (PA611)
DEVICE	172700,20,4,10,4,P6,0		;TYPESET PAPER TAPE PUNCH (PA611)
DEVICE	175200,100,4,10,4,DN,0		;AUTO CALL UNIT (DN11)
DEVICE	170500,20,4,10,10,DM,0		;MODEM CONTROL INTERFACE (DM11)
DEVICE	175610,20,10,10,10,DL,0		;ASYNC I/O (DL11-E)
DEVICE	0,20,10,10,10,DJ,0		;MULTIPLEXED ASYNC I/O (DJ11)
DEVICE	0,20,10,20,10,DH,0		;MULTIPLEXED DMA ASYNC I/O (DH11)
DEVICE	0,20,10,10,10,DQ,0		;DMA SYNC I/O (DQ11)
DEVICE	0,20,10,10,4,DU,0		;SYNC I/O WITH SYNC FILL (DU11)
DEVICE	0,20,10,10,4,UP,0		;SYNC I/O WITH BIT STUFFER (DUP11)
DEVICE	0,1,10,10,4,LK,0		;SPACEWAR BUTTONS ON GT40 (LK11)
DEVICE	0,20,10,10,4,MC,0		;DDCMP SYNC I/O (DMC11)
DEVICE	0,10,10,10,4,DZ,0		;MULTIPLEXED ASYNC I/O WITH FIFO (DZ11)
DEVICE	0,3,10,10,4,MD,0		;INTERFACE PROCESSOR (KMC11)
.ENDC ;.IF NE FT.D80!FT.D81!FT.D82
.SBTTL		DN85,DN87 VECTOR TABLES
.IF NE FT.D85!FT.D87
DEVICE	CTISTS,1,0,0,0,KL,CTOVEC	;OPR TTY (DL11-A)
CKCADD=.-CKCDEV
DEVICE	CR.STS,1,0,0,0,CR,CR.VEC	;CARD READER (CR11)
DEVICE	LP.STS,2,<-10>,10,0,LP,LP.VEC	;LINE PRINTER (LP11)
DEVICE	PP.STS,1,0,0,0,PP,PP.VEC	;PAPER TAPE PUNCH (PP11)
DEVICE	PR.STS,1,0,0,0,PR,PR.VEC	;PAPER TAPE READER (PR11)
DEVICE	XY.STS,1,0,0,0,XY,XY.VEC	;PLOTTER (XY11)
DEVICE	172540,1,0,0,0,KP,104		;REAL TIME CLOCK (KW11-P)
DEVICE	174770,40,10,<-10>,10,DP,0	;INTERUPT SYNC I/O (DP11)
DEVICE	172600,20,4,10,4,R6,0		;TYPESET PAPER TAPE READER (PA611)
DEVICE	172700,20,4,10,4,P6,0		;TYPESET PAPER TAPE PUNCH (PA611)
DEVICE	175200,100,4,10,4,DN,0		;AUTO CALL UNIT (DN11)
DEVICE	170500,20,4,10,10,DM,0		;MODEM CONTROL INTERFACE (DM11)
DEVICE	175610,20,10,10,10,DL,0		;ASYNC I/O (DL11-E)
DEVICE	0,20,10,10,10,DJ,0		;MULTIPLEXED ASYNC I/O (DJ11)
DEVICE	0,20,10,20,10,DH,0		;MULTIPLEXED DMA ASYNC I/O (DH11)
DEVICE	0,20,10,10,10,DQ,0		;DMA SYNC I/O (DQ11)
.ENDC ;.IF NE FT.D85!FT.D87
.SBTTL		DN87S,DN61S DEVICE VECTOR TABLES
.IF NE FT.87S
DEVICE	CTISTS,1,0,0,0,KL,CTOVEC	;OPR TTY (DL11-A)
CKCADD=.-CKCDEV
DEVICE	CR.STS,1,0,0,0,CR,CR.VEC	;CARD READER (CR11)
DEVICE	LP.STS,2,<-10>,10,0,LP,LP.VEC	;LINE PRINTER (LP11)
DEVICE	PP.STS,1,0,0,0,PP,PP.VEC	;PAPER TAPE PUNCH (PP11)
DEVICE	PR.STS,1,0,0,0,PR,PR.VEC	;PAPER TAPE READER (PR11)
DEVICE	XY.STS,1,0,0,0,XY,XY.VEC	;PLOTTER (XY11)
DEVICE	172540,1,0,0,0,KP,104		;REAL TIME CLOCK (KW11-P)
DEVICE	174400,1,0,0,0,TE,774		;TEN/ELEVEN INTERFACE (DTE20-#0)
DEVICE	174440,1,0,0,0,TE,770		;TEN/ELEVEN INTERFACE (DTE20-#1)
DEVICE	174500,1,0,0,0,TE,764		;TEN/ELEVEN INTERFACE (DTE20-#2)
DEVICE	174540,1,0,0,0,TE,760		;TEN/ELEVEN INTERFACE (DTE20-#3)
;
;	DN87S/DN61S NON FLOATING HARDWARE
;
DEVICE	176000,1,0,0,0,DL,300		;TTY INTERFACE (DL11-E)
DEVICE	160020,10,20,20,0,DH,330	;MULTIPLEX TTY INTERFACE (DH11)
DEVICE	170500,10,20,10,0,DM,320	;MODEM CONTROL INTERFACE (DM11)
DEVICE	175200,20,4,10,0,DN,660		;AUTO CALL UNIT (DN11)
DEVICE	160230,14,10,10,0,DQ,520	;DMA SYNC I/O (DQ11)
DEVICE	160740,20,10,10,0,MC,670	;DMC11
;
;	END DN87S/DN61S
;


.IF NE FTGLOM				; BIGLIST SWITCH AND ALL DEVICES
DEVICE	177446,1,0,0,0,RC,210		;OLD SMALL DISK (RC11)
DEVICE	177460,1,0,0,0,RF,204		;FIXED HEAD DISK (RF11)
DEVICE	176700,1,0,0,0,RH,254		;FANCY DISK CONTROLER (RH11)
DEVICE	176710,1,0,0,0,RP,254		;DISK PACK CONTROL (RP11-C)
DEVICE	TC.STS,1,0,0,0,TC,TC.VEC	;DEC TAPE CONTROL (TC11)
DEVICE	TM.STS,1,0,0,0,TM,TM.STS	;MAG TAPE CONTROL (TM11)
DEVICE	177500,1,0,0,0,TA,260		;CASSETTE TAPE (TA11)
DEVICE	177404,1,0,0,0,RK,220		;DISK CARTRIDGE CONTROL (RK11)
DEVICE	DS.DVA,1,20,10,0,DS,DS.VEC	;SYNC I/O (DS11)
DEVICE	174770,40,10,<-10>,10,DP,0	;INTERUPT SYNC I/O (DP11)
DEVICE	172600,20,4,10,4,R6,0		;TYPESET PAPER TAPE READER (PA611)
DEVICE	172700,20,4,10,4,P6,0		;TYPESET PAPER TAPE PUNCH (PA611)
DEVICE	0,20,10,10,10,DJ,0		;MULTIPLEXED ASYNC I/O (DJ11)
DEVICE	0,20,10,10,4,DU,0		;SYNC I/O WITH SYNC FILL (DU11)
DEVICE	0,20,10,10,4,UP,0		;SYNC I/O WITH BIT STUFFER (DUP11)
DEVICE	0,1,10,10,4,LK,0		;SPACEWAR BUTTONS ON GT40 (LK11)
DEVICE	0,20,10,10,4,MC,0		;DDCMP SYNC I/O (DMC11)
DEVICE	0,10,10,10,4,DZ,0		;MULTIPLEXED ASYNC I/O WITH FIFO (DZ11)
DEVICE	0,3,10,10,4,MD,0		;INTERFACE PROCESSOR (KMC11)
.ENDC ;.IF NE FTGLOM


.ENDC ;.IF NE FT.87S
.SBTTL		DN20, DN22, DN200 DEVICE VECTOR TABLES
.IF NE FT.D20!FT.D22!FT.200
DEVICE	CTISTS,1,0,0,0,KL,CTOVEC	;OPR TTY (DL11-A)
CKCADD=.-CKCDEV
DEVICE	CR.STS,1,0,0,0,CR,CR.VEC	;CARD READER (CR11)
DEVICE	LP.STS,2,<-10>,10,0,LP,LP.VEC	;LINE PRINTER (LP11)
DEVICE	PP.STS,1,0,0,0,PP,PP.VEC	;PAPER TAPE PUNCH (PP11)
DEVICE	PR.STS,1,0,0,0,PR,PR.VEC	;PAPER TAPE READER (PR11)
DEVICE	XY.STS,1,0,0,0,XY,XY.VEC	;PLOTTER (XY11)
DEVICE	172540,1,0,0,0,KP,104		;REAL TIME CLOCK (KW11-P)
DEVICE	174400,1,0,0,0,TE,774		;TEN/ELEVEN INTERFACE (DTE20-#0)
DEVICE	174440,1,0,0,0,TE,770		;TEN/ELEVEN INTERFACE (DTE20-#1)
DEVICE	174500,1,0,0,0,TE,764		;TEN/ELEVEN INTERFACE (DTE20-#2)
DEVICE	174540,1,0,0,0,TE,760		;TEN/ELEVEN INTERFACE (DTE20-#3)
;
;	DN20/DN21 NON FLOATING HARDWARE
;
DEVICE	160540,3,10,10,0,MH,540		;INTERFACE PROCESSOR (KMC11) for DUP
DEVICE	160300,14,10,10,0,UP,570	;INTERUPT SYNC I/O WITH BIT STUFFER (DUP11)
DEVICE	160640,3,10,10,0,ME,300		;KMC11 for DZ
DEVICE	160740,20,10,10,0,MC,670	;DMC11
DEVICE	160010,20,10,10,0,DZ,340	;ASYNC MULTIPLEX I/O (DZ11)
DEVICE	L20STS,2,<-4>,<-20>,0,L2,L2.VEC	;LP20 CONTROLLER
;
;	END DN20/DN21
;
.ENDC ;.IF NE FT.D20!FT.D22!FT.200








CKCEND:		; END OF DEVICE TABLES
	RTS	PC

;FORCE THESE DEVICES (MAYBE)
	ND	CK..VR,0	;don't print version unless asked
.IIF EQ FT.D75,CK..MM=1	;MF11-UP
CK..KG=0			;assume we don''t need KG11
.IIF EQ,FTKG11,CK..KG=1	;KG11-A if we need it
CK..KW=1	;KW11-L
CK..CI=1	;CTY I
CK..CO=1	;CTY O
.IIF NE FTDL10!FTGLOM,CK..D1=1	;DL10


NODEV	<L2,ME,MH,CI,CO,MM,D1,KW,KG>
NODEV	<KL,CR,LP,PP,PR,TC,TM,RC,RF,RH,RP,TA,RK,KP,DS,TE>
NODEV	<DL,DH,DM,DN,DQ,MD,UP,DZ,DP,R6,P6,DJ,DU,LK,MC,DV>
;
; GLOBAL CELLS FOR CHECK11
;
CHKFLG:	.BLKW	1		;CHK11 FLAGS
	CKFERR=	B0		;ERROR DETECTED
	CHKMMO=	B1		;memory management on [3(47)]
	CKFIDT=	B15		;ID ALREADY TYPED
CKDEVN:	.BLKW	1		;UNIT # CURRENTLY BEING TESTED
CKDNAM:	.BLKW	1		;ADR OF DEVICE NAME(.ASCIZ)

.MACRO DEVTXT	DEV,LAB,TEXTX
.IF NB,<DEV>
	.IF NE CK..'DEV
		LAB:	.ASCIZ	\TEXTX\
	.ENDC
.IFF;.IF NB,<DEV>
LAB:	.ASCIZ	\TEXTX\
.ENDC;.IF NB,<DEV>
.ENDM DEVTXT
.MACRO DEVEQ	OLD,NEW
.IF DF,CKA'OLD'11
CKA'NEW'11==CKA'OLD'11
.IFF;.IF DF,CKA'OLD'11
CKA'NEW'11=CKPOPJ
.ENDC;.IF DF,CKA'OLD'11
NEW'.LVL='OLD'.LVL
.ENDM DEVEQ
DEVTXT	CI,CKNCI1,<CTY I>
DEVTXT	CO,CKNCO1,<CTY O>
DEVTXT	CR,CKNCR1,<CR11>
DEVTXT	DH,CKNDH1,<DH11>
DEVTXT	DJ,CKNDJ1,<DJ11>
DEVTXT	D1,CKND10,<DL10>
DEVTXT	KL,CKNKL1,<DL11-A>
DEVTXT	DL,CKNDL1,<DL11-E>
DEVTXT	DM,CKNDM1,<DM11-BB>
DEVTXT	MC,CKNMC1,<DMC11>
DEVTXT	MD,CKNMD1,<KMC11>
DEVTXT	ME,CKNME1,<KMC11-DZ>
DEVTXT	MH,CKNMH1,<KMC11-DUP>
DEVTXT	DN,CKNDN1,<DN11>
DEVTXT	DP,CKNDP1,<DP11>
DEVTXT	DQ,CKNDQ1,<DQ11>
DEVTXT	DS,CKNDS1,<DS11>
DEVTXT	TE,CKNTE1,<DTE20>
DEVTXT	DU,CKNDU1,<DU11>
DEVTXT	UP,CKNUP1,<DUP11>
DEVTXT	DV,CKNDV1,<DV11>
DEVTXT	DZ,CKNDZ1,<DZ11>
DEVTXT	,CKNKG1,<KG11-A>
DEVTXT	KW,CKNKW1,<KW11-L>
DEVTXT	LK,CKNLK1,<LK11>
DEVTXT	LP,CKNLP1,<LP11>
DEVTXT	L2,CKNL21,<LP20>
DEVTXT	MM,CKNMM1,<MF11-UP>
DEVTXT	PP,CKNPP1,<PP11>
DEVTXT	PR,CKNPR1,<PR11>
DEVTXT	XY,CKNXY1,<XY11>
DEVTXT	P6,CKNP61,<PA611-P>
DEVTXT	R6,CKNR61,<PA611-R>
DEVTXT	RC,CKNRC1,<RC11>
DEVTXT	RF,CKNRF1,<RF11>
DEVTXT	RK,CKNRK1,<RK11>
DEVTXT	RH,CKNRH1,<RH11>
DEVTXT	RP,CKNRP1,<RP11-C>
DEVTXT	TA,CKNTA1,<TA11>
DEVTXT	TC,CKNTC1,<TC11>
DEVTXT	TM,CKNTM1,<TM11>
DEVTXT	KP,CKNKP1,<KW11-P>
	.EVEN
CK.CAL:	.BLKW	1		;ADR OF JSR PC,CHK.11 IN MAIN PROGRAM

CHK.11:	RESET				;CLEAR THE WORLD
	MTPS	#BR7			;PROCESSOR LEVEL TO 7
	MOV	(SP)+,CK.CAL		;SAVE CALLING ADDRESS
	MOV	#FLOATV,CHKFLV		;FLOATING INT VEC BEGIN HERE
	MOV	#FLOATD,CHKFLD		;FLOATING DEV ADR'S BEGIN HERE
	CLR	CHKFLG			;CLEAR CHK11 FLAGS
	CLR	CKSPCD			;CLEAR STOP CODE; NON 0 ON FATAL
					; ERROR PUTS C(CKSPCD) IN R0.

;INITIALIZE VECTOR SPACE
;
CKINTS:	MOV	14,R3			;SAVE ODT ADDRESS
	CLR	R0			;START LOADING AT ADR 0
	MOV	#CHKINT,R1		;WHERE TO GO ON INTERRUPT
	MOV	#BR7,R2			;INTERRUPT PS
11$:	MOV	R1,(R0)+		;SET INTERRUPT VECTOR
	MOV	R2,(R0)+		;SET INTERRUPT LEVEL
	INC	R2
	BIT	#77,R0			;HAVE WE HIT A LIMIT ?
	BNE	12$
	ADD	#CHKITL,R1		;YES SO CHANGE VECTOR
	MOV	#BR7,R2			;RESET PS
12$:
.IF GE PDL-1000
	CMP	R0,#1000		;FILL VECTORS UP TO 1000
.IFF
	CMP	R0,#PDL-2		;OR UP TO START OF PROGRAM
.ENDC
	BLT	11$			;MORE TO DO.
	MOV	#CHKERR,TRPVEC		;WHERE TO GO ON ERROR TRAP
	MOV	R3,14			;RESTORE ODT ADDRESS

;NOW CHECK THE CTY
;
	MOV	#13$,NXMVEC		;WHERE TO TRAP IF NO CTY
	BIC	#CKFIDT,CHKFLG		;SO WE PRINT DEV ID
	TST	CTOSTS			;CHECK CTY TRANSMIT STATUS REGISTER
	TST	CTOCHR
	TST	CTISTS
	TST	CTICHR
	MOV	#CKBUST,NXMVEC		;WHERE TO GO ON ILLEGAL NXM TRAP
	BR	14$
13$:	MOV	#S..CTY,R0		;NO CTY STOP CODE
	HALT
	MOV	#13$,R0			;ADR OF ERROR
	HALT				;DISPLAY ADDRESS
	JMP	BEGIN			;DO TEST AGAIN IF HE CONTINUES

14$:	MOV	#CTOSTS,R4		;CTY PUN STATUS
	MOV	R4,CHKCHR+CKDA		;DEV ADR
	MOV	R4,R1			;CHKBIT NEEDS ADR IN R1
	MOV	#CTOVEC,CHKCHR+CKDV	;CTY PUN VECTOR
	MOV	#CKNCO1,CKDNAM		;NAME ADDRESS
	CLR	CKDEVN			;DEVICE 0
	JSR	R5,CHKBIT		;CHECK THE FOLLOWING BITS FOR R/W
	CO.INE!CO..MM			;BITS TO CHECK FOR R/W
	MOV	#CO.INE,(R4)		;ENABLE INTERRUPTS
	JSR	R5,CHKINL		;CHECK INTERRUPT AND FIND DEV LEVEL
	-1				;TIME LOOP CONSTANT
	CLR	(R4)			;CLR DEV OUT

;NOW CHECK THE KBRD SECTION
;
CHKBRD:	BIC	#CKFIDT,CHKFLG		;SO WE PRINT DEV ID
	MOV	#CTISTS,R4		;KBRD STATUS REG
	MOV	R4,CHKCHR+CKDA		;DEV ADR
	MOV	R4,R1			;CHKBIT NEEDS ADR IN R1
	MOV	#CTIVEC,CHKCHR+CKDV	;VECTOR ADR
	MOV	#CKNCI1,CKDNAM		;ADR OF DEV NAME
	JSR	R5,CHKBIT		;CHECK THE FOLLOWING BITS
	CI.INE				;BITS TO CHECK R/W

11$:	CK11SC	<0>,<Initializing >
	.ASCIZ	\Initializing \
	.EVEN
	MOV	@CK.CALL,R0		;GET ADDR OF .ASCIZ \PROG NANME\
	JSR	PC,CKTTXT		;TYPE PROGRAM NAME
.IF NE,CK..VR
	CK11SC	<CKENCL>,< v>
	.ASCIZ	\ v\
	.EVEN
	MOV	JOBVER,R0		;GET SOFTWARE VERSION NUMBER
	JSR	PC,CKTOCT
	MOV	JOBVER+2,R1	;MINOR VERSION NUMBER
	BEQ	12$		;NONE.
	ADD	#'A-1,R1	;MAKE A LETTER
	JSR	PC,CKTCHR
12$:	MOV	#'(,R1		;() AROUND EDIT NUMBER
	JSR	PC,CKTCHR
	MOV	JOBVER+4,R0	;EDIT NUMBER
	JSR	PC,CKTOCT
	MOV	#'),R1
	JSR	PC,CKTCHR
	MOV	JOBVER+6,R0	;WHO LAST EDITED
	BEQ	13$
	MOV	#'-,R1
	JSR	PC,CKTCHR
	JSR	PC,CKTOCT
13$:
.ENDC;.IF NE,CK..VR

.IF NE FTGLOM
;Determine CPU type [1(14)]
	MOV	#CKWRD,R0		;point to word
;	MOV	R0,(R0)+		;see behavior of CPU
	.WORD	10020			;so we don't get assembly error
	CMP	CKWRD,#CKWRD		;see what got stored
	BNE	CK4020			;incremented, go distinguish 11/40 and 11/20
;here if 11/05, 11/04, 11/34, or 11/45
	MOV	#CKJMP,R0		;point to dispatch table
;	JMP	(R0)+			;go to appropriate place [1(15)]
	.WORD	120			;the above instruction (so we don't get Z error) [1(15)]
;here if 11/04, 11/34, or 11/45
CK0434:					;here to distinguish 04 from 34
	MOV	4,-(SP)			;save NXM routine address on stack
	MOV	#12$,4			;point to NXM handler
	MOV	#177770,R0		;starting address
11$:					;loop to look for NXM
	TST	(R0)			;check this address
	SUB	#2,R0			;wasn't NXM, try previous word
	BNE	11$			;keep looking
	CK11SC	<CKEFAT!CKEPC>,<no NXM??>,<no memory address caused NXM>
	.ASCIZ	/no NXM??/
	.EVEN
12$:					;here when NXM address found
	ADD	#4,SP			;adjust stack
	MOV	#13$,4			;next NXM address
	MOV	R0,R1			;copy address
	MOV	R2,(R0)+		;do it
	HALT				;can never happen
13$:					;here on second NXM
	ADD	#4,SP			;adjust stack
	CMP	R0,R1			;check values
	BEQ	CK04			;if equal, it's an 11/04
	MOV	(SP)+,4			;restore NXM trap
	MOV	10,-(SP)		;save bad instruction trap
	MOV	#14$,10			;point to us
	.WORD	106700			;execute 11/34 only instruction
	MOV	(SP)+,10		;restore trap
	BR	CK34
14$:					;here if 11/45
	ADD	#4,SP			;adjust stack
	MOV	(SP)+,10		;restore trap
	BR	CK45
CK4020:					;here to distinguish 11/40 from 11/20
	MOV	#CKJMP2,R0		;point to dispatch
;	JMP	(R0)+			;branch [1(15)]
	.WORD	120			;the above instruction (so we don't get Z error) [1(15)]
CKJMP:	BR	CK0434			;here if doesn't increment [1(15)]
	BR	CK05			;here if it does [1(15)]
CKJMP2:	BR	CK40			;here if doesn't increment [1(15)]
	BR	CK20			;here if it does [1(15)]
CK04:					;here if 11/04
	JSR	R0,CKTCRL		;print message
	.ASCIZ	%     KD11-D (11/04)%
	.EVEN
	BR	CKCPUE			;done
CK05:					;here if 11/05
	JSR	R0,CKTCRL		;print message
	.ASCIZ	%     KD11-B (11/05 or 11/10)%
	.EVEN
	BR	CKCPUE
CK20:					;here if 11/20
	JSR	R0,CKTCRL		;print message
	.ASCIZ	%     KA11 (11/20) or KC11 (11/15)%
	.EVEN
	BR	CKCPUE			;exit
CK34:					;here if 11/34
	JSR	R0,CKTCRL		;print message
	.ASCIZ	%     KD11-E (11/34)%
	.EVEN
	BR	CKCPUE
CK40:					;here if 11/40
	JSR	R0,CKTCRL		;print message
	.ASCIZ	%     KD11-A (11/35 or 11/40)%
	.EVEN
	BR	CKCPUE
CK45:					;here if 11/45
	JSR	R0,CKTCRL		;print message
	.ASCIZ	%     KB11-A (11/45)%
	.EVEN
	BR	CKCPUE
CKWRD:	.WORD	0			;word for checking CPU

CKCPUE:					;continue

.ENDC
	CLR	DL10AD
.IF NE CK..D1
;DETERMINE THE DL10 BASE ADDRESS
;


	ND	DL10SR,164000		;STOP ADDRESS TO CHECK FOR DL10
CKDLXB:
.IF EQ,<CHKFFA&3777>
	MOV	#CHKFFA,R0		;SET ADDRESS TO START LOOKING FOR A DL10
.ENDC
.IF NE,<CHKFFA&3777>
	MOV	#<CHKFFA!3777>+1,R0	;SET ADDRESS TO START LOOKING FOR A DL10
.ENDC
	CLR	DL10AD			;SET FOR NO DL10

	MOV	#16$,NXMVEC		;WHERE TO GO ON A NXM
11$:	MOV	#DL.CNX!DL.CPE!DL.CWC!DL.11C,R1	;BITS TO SET IN DL10
	MOV	(R0),R2			;SAVE CONTENTS AS IT MAY BE CORE
	BIS	R1,(R0)			;CLEAR THESE CONDITIONS IF DL10
					; OR IF MEMORY BITS WILL BE SET
	ASL	R1			;POSITION BITS FOR SETTING CONDITIONS
	CLR	(R0)			;SEE IF SOMETHING THERE AND CLEAR IF IT IS THERE
	TST	(R0)			;MAKE SURE ITS CLEAR SINCE ITS THERE
	BEQ	12$			;BRANCH IF IT CLEARED
	CLR	-(SP)			;RESULT SHOULD BE 0
	MOV	(R0),-(SP)		;SAVE WHAT IT WAS
	MOV	R0,-(SP)			;SAVE THE ADDRESS WHERE IT HAPPENED
	CK11SC	<CKEFAT!CKEPC!CKEGB>,<Can't Clear DL10 or MEM>,<CLR @R0 DIDN'T CLEAR @R0>,<S..DL10>
	.ASCIZ	\Can't Clear DL10 or MEM\
	.EVEN
12$:	BIS	R1,(R0)			;NOW SET DL10 BITS
	CMP	R1,(R0)			;SEE IF THEY SET BE IT MEMORY OR DL10
	BEQ	13$			;BRANCH IF THE SET OK
	CKSERR	R1,<(R0)>,R0		;SAVE GD,BD,ADR
	CK11SC	<CKEFAT!CKEPC!CKEGB>,<DL10 or Mem Err>,<EITHER DL10 IS BAD OR MEMORY IS BAD>,<S..DL10>
	.ASCIZ	\DL10 or Mem Err\
	.EVEN
13$:	CLC				;CARRY MUST BE CLR
	ROR	R1			;SHIFT TO CLEAR BITS JUST SET
	BIS	R1,(R0)			;SET BITS, IF DL10 ALL BITS SHOULD BE 0
	TST	(R0)			;SEE IF ALL 0
	BEQ	17$			;BRANCH IF SO
14$:	MOV	R2,(R0)			;RESTORE MEMORY
15$:	ADD	#4000,R0		;GO TO NEXT POSSIBLE DL10 ADR
	CMP	R0,#DL10SR		;TIME TO STOP CHECKING FOR DL10?
	BLOS	11$			;BRANCH IF NOT
	BR	18$			;NEVER FOUND A DL10
16$:	ADD	#4,SP			;FLUSH NXM TRAP
	BR	15$			;GO CHECK NEXT POSSIBLE ADR
17$:	MOV	R0,DL10AD		;PUT DL10 BASE ADDR WE FOUND AWAY
18$:


.ENDC ;.IF NE CK..D1
;
;HERE TO SEE HOW MUCH CORE IS PRESENT
;
CHKCOR:	CLR	R0			;START SMALL
	MOV	#12$,NXMVEC		;SET BUS TRAP VECTOR
11$:	TST	(R0)			;check this location [1(14)]
	ADD	#2,R0			;point to next location [1(14)]
	CMP	R0,DL10AD		;SEE IF NEXT WORD IS DL10
	BNE	11$
	BR	13$
12$:	ADD	#4,SP			;FLUSH STACK
13$:	MOV	R0,PHYLIM		;SAVE ADR OF 1ST NXM LOCATION
.IIF DF,CKAMEM,JSR PC,CKAMEM		;PRINT LAST MEM LOCATION
;
;			; CONTINUED ON NEXT PAGE
;
.SBTTL		CHECK MEMORY - SLIDING BIT PATTERN

;HERE TO PERFORM A SIMPLE TEST ON FREE CORE.
;THE PATTERN USED IS A SLIDING BIT, WITH THE
;BIT IN EACH OF THE 16 BIT POSITIONS AND THE
;LAST PATTERN BEING ALL 0'S.
;
CKCOR:
	CLR	R0			;FIRST ADR TO CHECK
	MOV	#11$,R1			;LIMIT TO CHECK
	JSR	PC,11$			;CHECK LOW CORE
	MOV	#CKMPAR,R0		;BEGIN CHECKING HERE NOW
	MOV	PHYLIM,R1		;AND STOP HERE
	JSR	PC,11$
	JSR	R0,CKTCRL		;PRINT AMOUNT OF CORE
	.ASCIZ	\   \
	.EVEN
	MOV	PHYLIM,R0		;GET AMOUNT
	JSR	PC,CKTOCT		;PRINT IT
	JSR	R0,CKTSTR		;FOLLOWED BY MSG:
	.ASCIZ	\ bytes of memory\
	.EVEN
	BR	CKMPAR			;ALL OK

11$:	MOV	#1,R2			;FIRST PATTERN
	MOV	@R0,R3			;SAVE CURRENT DATA
12$:	MOV	R2,@R0			;PUT PATTERN IN MEMORY
	COM	@R0			;COMPLEMENT IT
	COM	@R0			; AND AGAIN
	CMP	R2,@R0			;DID IT GO ?
	BEQ	13$			;YES.
	CKSERR	R2,<(R0)>,R0		;SAVE GD,BD,ADR
	CK11SC	<CKEMSE!CKEFAT!CKEPC!CKEGB!CKADPH>,<CKMG01>,<MEMORY ERROR>,<S..MEM>
13$:	ASL	R2			;SHIFT PATTERN
	BNE	12$
	BCS	12$
	MOV	R3,@R0			;RESTORE DATA
	COM	@R0			;COMPLEMENT IT
	COM	@R0			; AND AGAIN
	CMP	R3,(R0)+		;BE SURE IT WENT
	BEQ	14$
	CKSERR	R3,<-(R0)>,R0		;SAVE GD,BD,ADR
	CK11SC	<CKEMSE!CKEFAT!CKEPC!CKEGB>,<CKMG01>,<MEMORY ERROR>,<S..MEM>
14$:	CMP	R0,R1
	BNE	11$			;LOOP BACK FOR REST OF MEMORY
CKPOPJ:	RTS	PC
;HERE TO CHECK THE MEMORY PARITY OPTION
CKMPAR:					;START CHECKING CORE HERE
.IF NE FT.D20
       	;** in case cache option KK11 is installed
     	MOV	#10$,NXMVEC		;Incase there is no cache
      	MOV	#1000,177746		;turn off cache
10$:
.ENDC;.IF NE FT.D20
.IF EQ FT.D75
	MOV	#CKNMM1,CKDNAM		;SAVE NAME OF "DEVICE"
	CLR	CKDEVN			;"UNIT" IS 0
	MOV	#MP.REG,R1		;OPTION REGISTER
	MOV	R1,CHKCHR+CKDA		;SAVE ADR IN CASE NEED TO TYPE IT
	MOV	NXMVEC,-(SP)
	MOV	#MP.VEC,CHKCHR+CKDV	;VECTOR FOR INTERRUPTS
	CLR	CHKCHR+CKPI		;NO PRIORITY LEVEL
	MOV	#14$,NXMVEC		;IN CASE PARITY OPTION NOT INSTALLED
	CLR	MP.REG			;TRY TO CLEAR MEMORY PARITY REGISTER
	MOV	(SP),NXMVEC		;RESTORE TRAP VECTOR
	JSR	R5,CHKBIT		;CHECK READ/WRITE BITS
	107745
;NOW CHECK INTERRUPTS FROM PARITY CONTROL
; THIS IS DIFFICULT CUZ SETTING MP.ENB & MP.ERR WON'T CAUSE INTERRUPT
	CLR	R0			;VECTOR WE TOOK WILL APPEAR HERE
	MOV	#MP.WWP,@R1		;WE WANT TO WRITE WRONG PARITY
	MOV	CKMPAR,CKMPAR		;WRITE A BAD WORD

	CLR	@R1			;BUT ONLY ONE WORD !
	TST	CKMPAR			;TRY FOR AN INTERRUPT
	NOP				;IN CASE SLOW
	TST	R0			;SEE IF WE GOT ONE
	BEQ	11$
	CK11SC	<CKEMSE!CKEDID!CKEPC>,CKMG07,<INTERRUPTED WHEN NOT ENABLED>
11$:	MOV	#MP.ENB,@R1		;NOW LETS GET THE INTERRUPT
	TST	CKMPAR
	CLR	@R1			;DISABLE FURTHER INTERRUPTS
	MOV	CKMPAR,CKMPAR		;WRITE BACK RIGHT
	TST	R0			;DID WE GET THE INTERRUPT ?
	BNE	12$
	CK11SC	<CKEDID!CKEMSE!CKEPC>,CKMG04,<INTERRUPT DID NOT OCCUR>
	BR	15$

12$:	CMP	R0,CHKCHR+CKDV		;WAS INTERRUPT RIGHT?
	BEQ	13$			;YES.
	CKSERR	<CHKCHR+CKDV>,R0,<#CKMPAR>	;GD,BD,ADR
	CK11SC	<CKEMSE!CKEDID!CKEPC!CKEGB>,CKMG05,<interrupted to wrong vector>
	BR	15$			;DONE.

; COME HERE IF PARITY OPTION IS PRESENT AND WORKING

13$:	JSR	R0,CKTCRL		;PRINT MESSAGE ABOUT IT
	.ASCIZ	\     MF11-UP\
	.EVEN
	MOV	#MP.ENB,MP.REG		;ENABLE PARITY ERRORS
.IIF DF,CKAMF1,JSR PC,CKAMF1		;DO MAIN LINE CHECKING
.IF NE FT.D20
;Re-enable the KK11 cache option if installed
     	MOV	#100$,NXMVEC		;Incase there is no cache
     	MOV	#0,177746		;Turn the cache back on
       	JSR	R0,CKTCRL		;Say the cache is there and up
     	.ASCIZ	\     KK11-UP\
     	.EVEN
100$:
.ENDC;.IF NE FT.D20
	BR	15$			;ALL DONE.

;HERE IF WE GET A BUS TRAP WHILE ACCESSING THE PARITY CONTROL REG
14$:	MOV	(SP)+,(SP)+		;CLEAN OFF STACK
	CK11SC	<CKEDID!CKEPC!CKEMSE>,CKMG06,<not found>

15$:	MOV	(SP)+,NXMVEC

.ENDC ;.IF EQ FT.D75
;HERE TO SEE IF ROM = BM873 OR M9301 IS PRESENT

.IF DF FT.ROM
.IF NE FT.ROM
CK.ROM:	MOV	NXMVEC,-(SP)		;SAVE BUSTRAP VECTOR
	MOV	#11$,NXMVEC
	TST	ROMADR			;IS ROM REALLY HERE ?
	BR	12$			;YES

;HERE BECAUSE ROM NOT PRESENT
11$:	CLR	GO.ROM			;MAKE JMP ROMADR = HALT
	MOV	(SP)+,(SP)+		;CLEAN OFF STACK

12$:	MOV	(SP)+,NXMVEC
.ENDC;.IF NE FT.ROM
.ENDC;.IF DF FT.ROM
.SBTTL		CHECK KW11-L HDW

;HERE TO BE SURE CLOCK IS PRESENT AND TICKS

CHKCLK:	MOV	#CKNKW1,CKDNAM		;SET UP FOR NAME
	BIC	#CKFIDT,CHKFLG		;SO WE PRINT DEV ID
	MOV	#CLKWRD,R4		;SET UP DEV ADR
	MOV	R4,CHKCHR+CKDA		;SET UP DEVICE ADR
	MOV	#CLKVEC,CHKCHR+CKDV	;SET UP VECTOR ADR
	CLR	CKDEVN			;DEVICE NUMBER
	MOV	#13$,NXMVEC		;SET BUS TRAP IN CASE CLOCK IS NOT PRESENT
	TST	(R4)			;TRAP IF NOT INSTALLED
	MOV	#CKBUST,NXMVEC		;WHERE TO GO ON BUS TRAP
	MOV	CLKVEC,-(SP)		;SAVE WHERE TO GO ON INT
	MOV	#14$,CLKVEC		;SETUP INTERRUPT VECTOR
	MOV	#3,CHKTIM		;TIME 3 TICKS
	MTPS	#0			;LET INTERRUPTS HAPPEN
	MOV	#KW.INE,(R4)		;ENABLE THE CLOCK
	BEQ	12$			;IF COUNTED OUT ALREADY EVIL
	CLR	R0			;INITIALIZE WATCHDOG COUNTER
	TST	CHKTIM			;see if count expired now [1(14)]
	BEQ	12$			;yes, too fast [1(14)]
11$:	TST	CHKTIM
	BEQ	CKCLK9			;BRANCH IF TIMED OUT ALREADY
	SOB	R0,11$
	CK11SC	<CKEFAT!CKEPC!CKEDID>,<Slow>,<NO RESPONSE FROM KW11>,<S..KW1>
	.ASCIZ	\Slow\
	.EVEN
12$:	CK11SC	<CKEFAT!CKEPC!CKEDID>,<Fast>,<KW11 TICKING TO FAST>,<S..KW1>
	.ASCIZ	\Fast\
	.EVEN
13$:	CK11SC	<CKEFAT!CKEPC!CKEDID>,<Not Present>,<CAN' ACCESS KW11>,<S..KW1>
	.ASCIZ	\Not Present\
	.EVEN

;HERE ON A KW11 INTERRUPT
14$:	DEC	CHKTIM			;COUNT OUT TIMER
	BNE	15$
	CLR	(R4)			;TURN OFF CLOCK
15$:	RTI				;DISMISS INTERRUPT

CHKTIM:	.WORD	0
;
;
CKCLK9:	MTPS	#BR7			;SET TO LEVEL 7
	MOV	#KW.INE,(R4)		;ENABLE INT
	MOV	(SP)+,CLKVEC		;RESTORE WHERE TO GO ON INT
	JSR	R5,CHKINL		;FIND THE INT LEVEL
	-1				;DELAY TO WAIT FOR INT
	BIC	#KW.INE,CLKWRD		;DISABLE CLK INTS
	JSR	R0,CKTCRL		;INDICATE CLOCK PRESENT
	.ASCIZ	\     KW11-L\
	.EVEN
.IIF DF,CKAKW1,JSR PC,CKAKW1		;CALL TO MAIN FOR CLOCK

.SBTTL		CHECK KG11

;HERE TO CHECK THE KG11 IS PRESENT AND FUNCTIONING PROPERLY

CHKG11:	MOV	#17$,NXMVEC		;SET BUS TIMEOUT VECTOR
	BIC	#CKFIDT,CHKFLG		;SO WE PRINT DEV ID
	CHKCHR	<#KG.STS>,<#0>,<#0>
	MOV	#CKNKG1,CKDNAM		;FOR NAME
	CLR	CKDEVN			;DEVICE #
	TST	KG.STS			;CHECK STATUS
	TST	KG.BCC			;CHECK BCC
	TST	KG.DTA			;CHECK DATA REG
	MOV	#CKBUST,NXMVEC
	CLR	R0
11$:	MOV	#KG.SEN!KG.CLR!KG.DDB!3,KG.STS ;CLEAN OUT KG11-A
	MOV	R0,KG.DTA	;LOAD WITH DATA FROM R0
	MOV	#KG.SEN!1,KG.STS ; AND SET TO CRC-16
	CMP	R0,KG.BCC		;CHECK IT LOADED
	BEQ	12$			;BRANCH IF OK
	CKSERR	R0,KG.BCC,<#KG.BCC>	;GD,BD,ADR
	CK11SC	<CKEPC!CKEDID!CKEGB>,<Can't load BCC Correctly>,<CAN'T LOAD BCC CORRECTLY>
	.ASCIZ	\Can't load BCC Correctly\
	.EVEN
12$:	SOB	R0,11$

;HERE TO CHECK CRC PORTION
;
	MOV	#777,R0			;FIRST ENTRY FOR CRC
	MOV	#KG.SEN!KG.CLR!1,KG.STS ;CLEAR KG11 AND SET TO CRC-16
	CLR	R3			;CLEAR SOFTWARE COPY
13$:	MOV	R0,-(SP)
	BIC	#^C377,R0		;STRIP EXTRA BITS
	MOV	#^D8,R1			;COUNTER
	XOR	R0,R3
	MOV	#120001,R0
15$:	CLC				;CLEAR CARRY BIT
	ROR	R3
	BCC	16$
	XOR	R0,R3
16$:	SOB	R1,15$
	MOV	(SP)+,R0
	MOVB	R0,KG.DTA		;INCLUDE CHAR IN HDW BCC
	CMP	R3,KG.BCC
	BEQ	14$
	CKSERR	R3,KG.BCC,<#KG.BCC>
	CK11SC	<CKEPC!CKEGB!CKEDID>,<Incorrect CRC>,<INCORRECT CRC>
	.ASCIZ	\Incorrect CRC\
	.EVEN
14$:	SOB	R0,13$
	JSR	R0,CKTCRL	;PRINT MSG ABOUT KG11
	.ASCIZ	\     KG11-A\
	.EVEN
.IIF DF,CKAKG1,JSR PC,CKAKG1		;CALL MAIN FOR KG11
	BR	18$
; COME HERE IF KG11 IS NOT PRESENT.  PRINT ERROR MESSAGE IF
; IT IS REQUIRED (I.E., NOT DC76).

17$:
.IIF EQ,CK..KG,BR 18$
.IF NE CK..KG
	CK11SC	<CKEPC!CKEDID>,<Not present >
	.ASCIZ	\Not present \
	.EVEN
.ENDC
18$:
.IF NE CK..D1
.SBTTL		CHECK DL10 HDW
;

CKDL10:

	MOV	DL10AD,R4		;IF "DL10AD" IS NON 0 A DL10 IS PRESENT
					; AND R4 WILL BE LOADED WITH BASE ADR
	BEQ	12$			;BRANCH IF WE DO NOT
	BIC	#CKFIDT,CHKFLG		;SO WE PRINT DEV ID
	MOV	#CKND10,CKDNAM		;DEVICE NAME
	CLR	CKDEVN			;DEVICE NUMBER
	MOV	R4,R1			;PUT DEVICE ADDR FOR CHKBIT
	MOV	R4,CHKCHR+CKDA		;PUT IN CHARACTERISTICS TABLE FOR ERROR REPORTING
	JSR	R5,CHKBIT		;CHECK THE FOLLOWING BITS
	DL.B00!DL.B01!DL.INE!DL.ERE
	JSR	R5,CHKDLX		;CHECK SET/CLEAR OF
	DL.WCO				;WORD COUNT OVERFLOW
	JSR	R5,CHKDLX		;CHECK SET/CLEAR OF
	DL.PAR				;PARITY ERROR
	JSR	R5,CHKDLX		;CHECK SET/CLEAR OF
	DL.NXM				;NON EX MEM
	JSR	R5,CHKDLX		;CHECK SET/CLEAR OF
	DL.11I
11$:	MOV	#DL.B01,(R4)		;SET DL10 FOR LEVEL 5
	MOV	#DL.VEC,CHKCHR+CKDV	;PUT DEVICE VECTOR IN TABLE FOR CKINT
	$CKINT	R4,R4,DL.INE,DL.11I,DL.11C
	$CKINT	R4,R4,DL.ERE,<DL.PAR!DL.NXM!DL.WCO>,<DL.CNX!DL.CPE!DL.CWC>
	JSR	R0,CKTCRL		;NOTE PRESENCE OF DL10
	.ASCIZ	\     DL10\
	.EVEN
.IIF DF,CKADLX,JSR PC,CKADLX		;DO MAIN LINE CHECKING
12$:
.ENDC ;.IF NE CK..D1
	JSR	PC,CKCDEV		;check devices
;HERE WHEN CHK.11 IS ALL DONE
CHK.90:
	ND	FT.ASK,0
.IF NE FT.ASK
	TST	CHKFLG			;DID ALL FLAGS GET CLEARED ?
	BEQ	CHK.96			;IF SO MAY CONTINUE
	JSR	R0,CKTCRL
	.ASCIZ	<12><7><40><7><40><7>\?  Errors detected - Proceed (Y OR N)? \
	.EVEN
	JSR	PC,11$			;GET HIS YEH OR NAY
	JSR	R0,CKTCRL
	.ASCIZ	\	Are you SURE? \
	.EVEN
	JSR	PC,11$
	JSR	PC,CKCRLF
	BR	CHK.96
11$:	TST	CTICHR			;CLEAR BUFFER
	MOV	#2*^D60*^D60+1,R0	;CLOCK TICKS IN 2 MINUTES
12$:	TSTB	CTISTS			;WAIT FOR A CHAR
	BMI	13$			;GOT A CHARACTER
	BIT	#KW.TIC,CLKWRD		;CLOCK TICKED YET?
	BEQ	12$			;BRANCH IF NO TICK
	CLR	CLKWRD			;CLOCK WENT TICK, SO CLR IT
	SOB	R0,12$			;WAITING TIME EXPIRED YET?
	BR	16$			;GIVE A 'N'
					; QUESTION.
13$:	MOVB	CTICHR,R1		;GET CHAR
14$:	CMP	R1,#040			;IGNORE CONTROL CHARS
	BLO	12$
	BIC	#^C177,R1 		;RETAIN CHAR ONLY
	BIS	#040,R1			;AND CONVERT TO LOWER CASE
15$:	CMPB	#171,R1			;ANSWERING YES ?
	BEQ	17$
16$:	MOV	#156,R1			;IF NOT Y TYPE A 'N'
	JSR	PC,CKTCHR		;TYPE A 'N'
	JSR	R0,CKTCRL
	.ASCIZ	\	Execution Deleted\
	.EVEN
	MOV	#TRPINT,TRPVEC		;YES, SET UP FOR A STOPCD
	MOV	#TRPLVL,TRPVEC+2	;
	STOPCD	CHK
17$:	JMP	CKTCHR			;TYPE 'Y' AND DO A RTS PC

.ENDC
;
;HERE BECAUSE EVERYTHING LOOKS OK
;
; WAIT A WHILE, THEN DO A UNIBUS RESET.
;
CHK.96:					;TIMER BEFORE RESET
	MOV	#10,R1			;second half of timer [1(14)]
11$:	CLR	R0			;TIMER BEFORE RESET
12$:	SOB	R0,12$			;ON EXIT R0 IS 0 WHICH POINTS TO ADDR 0
	SOB	R1,11$			;added timing [1(14)]
	RESET
;
; NOW FILL IN LOW CORE IN CASE WE GET AN UNKNOWN INTERRUPT
;
	MOV	@#14,R3			;SAVE BREAKPOINT PROCESSOR
	MOV	#BR7,R1			;INTERRUPT PS
13$:	MOV	#ERRINT,(R0)+		;PUT WHERE TO GO ON ILLEGAL INT
	MOV	R1,(R0)+		;PUT PI LEVEL IN
14$:	INC	R1			;INCREMENT PI LEVEL
	BIC	#20,R1			;KEEP IN THE RANGE OF 340-357
.IF GE PDL-1000
	CMP	R0,#1000		;FILL VECTORS UP TO 1000
.IFF
	CMP	R0,#PDL-2		;OR UP TO START OF PROGRAM
.ENDC
	BLT	13$			;BRANCH IF MORE TO FILL
	MOV	R3,@#14			;RESTORE BREAKPOINT PROCESSOR
.IF NE,FT.KMC			;START KMC11 IF REQUESTED
;
; HERE TO START EACH KMC11 AT LOCATION 2.
;
	CLR	R0		;KMC11 NUMBER * 2
15$:	MOV	MDCSR(R0),R3	;GET ADDRESS OF KMC11 CSR
	BEQ	16$		;NONE, DON'T DO ANYTHING.
	MOV	#MD.CLR,(R3)	;CLEAR KMC11
	MOV	#MD.RMI,(R3)	;SET ROM I
	MOV	#<B15+B8+2>,6(R3) ;BRANCH TO 2
	BIS	#MD.SMP,(R3)	;EXECUTE THE INSTRUCTION
	CLR	(R3)		;CLEAR SEL 0
	CLR	2(R3)		;CLEAR SEL 2
	CLR	4(R3)		;CLEAR SEL 4
	CLR	6(R3)		;CLEAR SEL 6
	MOV	#MD.RUN,(R3)	;START MICROPROCESSOR
16$:	ADD	#2,R0		;INCREMENT KMC11 NUMBER * 2
	CMP	#<NLINES/4>*2,R0 ;DONE ENOUGH?
	BNE	15$		;NO, DO THE REST. [2(43)]
.ENDC ;.IF NE,FT.KMC
;
;				; CONTINUED ON NEXT PAGE
;
;
; HERE TO FILL IN THE VECTORS FOR DEVICES WE KNOW ABOUT
;
.MACRO	X	DEV
.IF DF DEV'INT
.IFT
	MOV	#DEV'INT,DEV'VEC		;SET DEV TO GO TO DEV'VEC
	MOV	#DEV'LVL*40,DEV'VEC+2		; AND SET THE LEVEL.
.IFF
	MOV	#ERRINT,DEV'VEC		;SET DEV TO GO TO ERRINT
	MOV	#DEV'LVL*40,DEV'VEC+2	; AND SET THE LEVEL.
.ENDC
.ENDM	X
;
	X	NXM			;BUS-TIMEOUT INTERRUPT
	X	ILS			;ILLEGAL INSTRUCTION INTERRUPT
	X	IOT			;IOT INSTRUCTION
	X	PWF			;POWER FAIL INT'S
	X	EMT			;EMT CALL'S
	X	TRP			;TRAP INSTRUCTION
	X	DL.			;DL10 INTERRUPT
	X	CLK			;KW11 INTERRUPT
	X	MP.			;MF11-LP PARITY CONTROL
	X	CTO			;CTY OUTPUT INTERRUPT
	X	CTI			;CTY INPUT INTERRUPT
.IF DF,DT.INT
	MOV	DTEDTO,R1		;SET UP PTR TO INTP VEC [1(26)]
	MOV	#DT.INT,(R1)+		;SET UP INTP VEC ADR [1(26)]
	MOV	#TE.LVL*40,(R1)		;SET UP THE LEVEL [1(26)]
.ENDC	;.IF DF,DT.INT
;
CKSETV:	MOV	#CKCDEV+4+16,R0		;POINT TO DEVICE CHECK VECTOR TABLE ENTRY
11$:	MOV	R0,R3			;R3 WILL BE USED TO LOOK AT EACH DEVICE
	MOV	(R3)+,R5		;GET VECTOR TABLE ADR
	BEQ	15$			;BRANCH IF NONE
	TST	(R3)			;SEE IF ANY DEVICES FOUND
	BEQ	15$			;BRANCH IF NONE FOUND
	MOVB	(R5)+,R2		;GET # OF MAIN ROUTINES
	BEQ	15$			;BRANCH IF NO MAIN ROUTINES
	MOVB	(R5)+,-(SP)		;GET NUMBER OF VECTORS FOR THE DEV
	CMP	R2,(R3)+		;SEE IF MORE MAIN THAN DEVICES
	BLE	12$			;BRANCH IF #OF DEV >= # OF MAIN ROUTINES
	MOV	-2(R3),R2		;SET NUMBER OF DEVICES
12$:	MOV	(R3)+,R4		;SET VECTOR
13$:	MOVB	(SP),R1			;SET NUMBER OF VECTORS
14$:	MOV	(R5)+,(R4)+		;PUT MAIN VECTOR ADR IN VECTOR SPACE
	MOV	(R3),(R4)+		;PUT PI LEVEL IN
	SOB	R1,14$			;ALL VECTOR SET FOR A DEV (1)
	SOB	R2,13$			;ALL DEV OF A KIND DONE?
	CLR	(SP)+			;CLEAN STACK
15$:	ADD	#CKCADD,R0		;GO TO NEXT DEVICE
	CMP	R0,#CKCEND		;ALL DEV DONE?
	BLO	11$			;BRANCH IF ANOTHER TO DO
CHK.99:	MOV	CK.CAL,R0		;GET ADR OF PROGRAM CALL
	MOV	11$,-4(R0)
	CLR	R0
	SOB	R0,.
	JMP	CKDONE			;RESTART
11$:	BR	.+6
.SBTTL		CHECK SYSTEM FOR EXISTENCE OF OPTIONS

;HERE TO CHECK SYSTEM FOR EXISTENCE OF OPTIONS
; CALL	JSR	R5,CHKDEV
;	(0)	.WORD	1ST DEVICE ADR
;	(2)	.BYTE	MAX #,VECTOR INC
;	(4)	.BYTE	HDW INC,1ST VEC MULTIPLE
;	(6)	.WORD	<ADR OF NUMBER OF DEVICES OR ZERO>
;	(10)	.WORD	<ADR OF .ASCIZ \NAME\>
;	(12)	.WORD	<ADR OF ROUTINE TO VERIFY OPERATION>
;	(14)	.WORD	<ADR OF MAIN PROGRAM ROUTINE FOR DEVICE>
;	(16)	.WORD	<ADR OF TABLE WHICH CONTAINS MAIN PROG VECTORS OR 0>
;	(20)	.WORD	<# OF DEVICES FOUND>
;	(22)	.WORD	<FIRST VECTOR FOUND>
;	(24)	.WORD	<PI LEVEL>
;	(26)	.WORD	<FIRST DEV VECTOR FOR FIXED TYPE DEV>
;	RETURN

CHKDEV:	MOV	10(R5),CKDNAM		;REMEMBER DEVICE NAME
	CLR	R2			;INITIALIZE COUNTER FOR DEVICES
	MOV	CHKFLV,R3		;COPY FOR USE
	TSTB	5(R5)			;SEE IF FIXED TYPE DEV
	BNE	11$			;BRANCH IF NOT
	MOV	26(R5),R3		;VECTOR TO USE
11$:	MOV	@R5,R4			;GET HDW ADR FOR 1ST DEVICE
	BNE	12$			;BRANCH IF NOT A FLOATING DEVICE
	ADD	#10,CHKFLD		;ADVANCE TO NEXT FLOAT DEVICE SLOT
	MOV	CHKFLD,R4		;COPY FOR USE
12$:	MOV	#15$,NXMVEC		;SET BUS TRAP VECTOR
13$:	TST	(R4)			;CHECK TO SEE IF DEVICE IS PRESENT
	MOV	#CKBUST,NXMVEC		;SET FOR ILLEGAL BUS TRAP
	TST	R2			;IS THIS THE FIRST OF ITS KIND ?
	BNE	14$			;BRANCH IF NOT FIRST
	CLR	20(R5)			;CLEAR NUMBER OF DEV FOUND
	CLR	22(R5)			;CLEAR FIRST VECTOR ADR
;	CLR	24(R5)			;CLEAR PI LEVEL
	MOVB	5(R5),R1		;GET MULTIPLE VECTOR BEGINS ON
	BEQ	14$			;BRANCH IF FIXED DEV (LPT)
	DEC	R1
	ADD	R1,R3
	BIC	R1,R3
14$:	INC	R2			;COUNT DEVICE
	INC	20(R5)			;COUNT DEVICE AND REMEMBER IT
	MOVB	3(R5),R1		;GET VECTOR INCREMENT
	ADD	R1,R3
	MOVB	4(R5),R1		;GET HDW INCREMENT
	ADD	R1,R4			;ADVANCE FLOATING DEVICE ADR POINTER
	CMPB	R2,2(R5)		;HAVE WE CHECK ALL POSSIBLE ?
	BNE	12$			;IF NOT LOOP BACK FOR REST
	BR	16$
15$:	MOV	#CKBUST,NXMVEC
	CMP	(SP)+,(SP)+		;POP OFF ADR AND STATUS
16$:	TST	6(R5)			;DO WE HAVE ADR FOR NUMBER ?
	BEQ	17$			;IF NOT DON'T STUFF
	MOV	R2,@6(R5)		;PUT NUMBER FOR SOMEONE TO FIND
17$:	TST	R2			;WERE THERE ANY OF THESE ?
	BEQ	CHKD02
	CK11SC	0,<	>		;TYPE CR/LF/TAB
	.ASCIZ	\	\
	.EVEN
	MOV	R2,R0			;NUMBER OF DEVICES WE FOUND
	JSR	PC,CKTOCT		;TYPE OUT THE NUMBER
	JSR	R0,CKTSTR		;TYPE A BLANK
	.BYTE	040,0
	MOV	CKDNAM,R0		;GET ADR OF ASCIZ STRING
	JSR	PC,CKTTXT		;TYPE DEVICE NAME
	BIT	#76,R2			;HOW MANY ?
	BEQ	CHKDV1
	CK11SC	<CKENCL>,<'s>
	.ASCIZ	\'s\
	.EVEN
CHKDV1:	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	R2,-(SP)
	CLR	CKDEVN			;CHECK UNIT 0 FIRST
	MOV	26(R5),R3		;GET FIRST VECTOR FOR POSSIBLE FIXED
	MOVB	5(R5),R0		;GET VECTOR MULTIPLE
	BEQ	11$			;BRANCH IF FIXED
	MOV	CHKFLV,R3		;GET VECTOR FOR 1ST UNIT
	DEC	R0
	ADD	R0,R3
	BIC	R0,R3
11$:	MOV	(R5),R4			;GET HDW ADR FOR FIRST UNIT
	BNE	12$
	MOV	CHKFLD,R4		;FLOATING DEVICE
12$:	CLR	CHKCHR+CKPI		;ROUTINE WILL SET PI LEVEL
	MOV	12(R5),R0		;ADR OF ROUTINE TO VERIFY DEVICE
	BEQ	13$			;BRANCH IF NO ROUTINE TO VERIFY
	BIC	#CKFIDT,CHKFLG		;HAVEN'T TYPED ID YET
	MOV	R4,CHKCHR+CKDA		;SAVE DEVICE ADDRESS
	MOV	R3,CHKCHR+CKDV		;SAVE VECTOR ADDRESS IN CHARACTERISTICS TABLE
	MOV	R4,R1			;PUT DEV ADR IN R1 SINCE MOST
					; ROUTINES WILL USE IT.
	CLR	CHKCHR+CKFLG		;CLEAR FLAGS AND LET DEVICE CHECK ROUTINE SET THEM
	MTPS	#BR7			;MAKE SURE WE'RE AT LEVEL 7
	JSR	PC,(R0)			;CALL TO DEVICE CHECK
	TST	22(R5)			;SEE IF VECTOR ADR SET YET
	BNE	13$			;BRANCH IF SET
	MOV	CHKCHR+CKDV,22(R5)	;SET FIRST VECTOR FOUND
;	MOV	CHKCHR+CKPI,24(R5)	;SET FIRST PI LEVEL FOUND
13$:	CMP	(R5),#DS.DVA		;DS11 ARE SPECIAL SO DON'T CALL MAIN HERE
	BEQ	14$			;BRANCH IF DS11
	MOV	#CHKCHR,R0		;POINT TO THE CHARACTERISTIC TABLE
	JSR	PC,@14(R5)		;CALL TO MAIN PROGRAM
14$:	MOVB	3(R5),R0		;GET VECTOR INCREMENT
	ADD	R0,R3
	MOVB	4(R5),R0		;HDW INCREMENT
	ADD	R0,R4
	INC	CKDEVN			;ON TO NEXT DEVICE NUMBER
	CMP	(SP),CKDEVN
	BNE	12$
	MOV	(SP)+,R2
	MOV	(SP)+,R4
	MOV	(SP)+,R3

CHKD02:	;SAVE	<R3,R4>
	;CLR	R4			;FLAG NO MORE DEVICES
	;JSR	PC,@14(R5)		;CALL MAIN PROGRAM
	;RESTORE	<R4,R3>

;HERE WHEN DONE CHECKING DEVICE
	TSTB	5(R5)			;SEE IF FIXED DEV
	BEQ	CHKD01			;BRANCH IF FIXED  (LIKE LPT)
	MOV	CHKFLV,-(SP)		;RESET FLOATING VECTOR
	MOV	R3,CHKFLV
	MOV	(SP)+,R3
	MOV	(R5),R0			;WAS THIS A FLOATING DEVICE ?
	BNE	CHKD01			;BRANCH IF NOT
	MOV	CHKFLD,R0		;COPY ADR OF FIRST DEVICE
	MOV	R4,CHKFLD
CHKD01:	ADD	#CKCADD-4,R5
	RTS	R5

.SBTTL		BIT SET/BIT CLEAR TEST

;HERE TO CHECK WE CAN SET/CLEAR VARIOUS BITS
;
; CALL	MOV	#<ADR OF ASCIZ \NAME\>,CKDNAM
;	MOV	<DEVICE NUMBER>,CKDEVN
;	MOV	<DEVICE REGISTER ADDRESS>,R1
;	JSR	R5,CHKBIT
;	<ALL BITS TO TEST>
;
CHKBIT:	MOV	R0,-(SP)
	MTPS	#BR7			;DISABLE INTERRUPTS
	MOV	(R5),R0			;GET BITS TO CHECK
	BIC	R0,(R1)			;TRY AND CLEAR ALL OF THEM
	BIT	R0,(R1)			;SEE IF ALL OF THEM CLEARED?
	BEQ	11$			;BRANCH IF ALL CLEAR
	CLR	-(SP)			;WHAT THE RESULT SHOULD BE
	MOV	(R1),-(SP)		;PUT C(DEV REG) ON STACK
	MOV	R0,-(SP)			;BUT ONLY CERTAIN BITS ARE BAD CANDIDATES
	COM	(SP)			;GET RID OF ONES
	BIC	(SP)+,(SP)		; THAT WE'RE NOT INTERESTED IN
	MOV	R1,-(SP)			;SAVE THE DEVICE ADR
	CK11SC	<CKEMSE!CKEPC!CKEDID!CKEGB>,<CKMG02>,<BITS WOULD NOT CLEAR>
11$:	MOV	#1,R0			;START WITH B0 AND GO UNTIL B15 IS DONE
12$:	BIT	(R5),R0			;WANT THIS BIT CHECKED?
	BEQ	14$			;BRANCH IF NOT, AND MAKE NEW BIT
	BIS	R0,(R1)			;TRY TO SET THE BIT
	BIT	R0,(R1)			;SEE IF THE BIT SET
	BNE	13$			;BRANCH IF IT SET
	MOV	R0,-(SP)			;SAVE GOOD
	CLR	-(SP)			;GOOD SHOUD BE 0 FOR THAT BIT
	MOV	R1,-(SP)			;DEV ADR WHERE IT HAPPENED
	CK11SC	<CKEMSE!CKEPC!CKEDID!CKEGB>,<CKMG03>,<BIT WOULD NOT SET>
13$:	BIC	R0,(R1)			;NOW THAT ITS SET TRY TO CLEAR IT
	BIT	R0,(R1)			;SEE IF IT CLEARED
	BEQ	14$			;BRANCH IF IT CLEARED AND GET NEW BIT
	CLR	-(SP)			;GOOD SHOUD BE 0
	MOV	R0,-(SP)			;SINCE IT DIDN'T CLEAR THIS BIT IS BAD
	MOV	R1,-(SP)			;DEV ADR THAT FAILED
	CK11SC	<CKEMSE!CKEPC!CKEDID!CKEGB>,<CKMG02>,<BIT WOULD NOT CLEAR>
14$:	ASL	R0			;MAKE NEW BIT POSITION
	BNE	12$			;BRANCH IF THERE IS A BIT
	MOV	(SP)+,R0
	TST	(R5)+			;GO OVER BITS FOLLOWING JSR
	RTS	R5			;EXIT

.IF NE CK..D1
.SBTTL		BIT SET/BIT CLEAR TEST FOR DL10

;ROUTINE TO CHECK DL10 BITS
;
CHKDLX:	MOV	(R5)+,R0		;GET BIT TO CHECK
	BIS	R0,(R1)			;SET THE BIT IN THE DL10
	CMP	(R1),R0			;DID IT SET AND ONLY IT SET?
	BEQ	11$			;BRANCH IF OK
	CKSERR	R0,<(R1)>,R1		;GD, BD, ADR
	CK11SC	<CKEMSE!CKEPC!CKEDID!CKEGB>,<CKMG03>,<SET BIT BUT ITS NOT SET>
11$:	ASR	R0			;SHIFT RIGHT TO GET IT IN CLEAR POSITION
	BIS	R0,(R1)			;SET BIT TO CLEAR BIT
	TST	(R1)			;ALL BITS SHOULD BE CLEAR NOW
	BEQ	12$			;BRANCH IF THEY ARE
	CLR	-(SP)			;THE GOOD
	MOV	(R1),-(SP)		;THE BAD
	MOV	R1,-(SP)		;THE BAD ADR
	CK11SC	<CKEMSE!CKEPC!CKEDID!CKEGB>,<CKMG02>,<SETTING BIT DID NOT CLEAR BIT>
12$:	RTS	R5			;EXIT
.ENDC ;.IF NE CK..D1
.SBTTL		PRINT DEVICE ID ROUTINE

CKDIDT:	BIT	#CKFIDT,CHKFLG		;HAVE WE ALREADY TYPE DEVICE ID ?
	BNE	11$
	JSR	PC,CKCRLF		;EXTRA CR + LF
	JSR	R0,CKTCRL
	.BYTE	007,0
	CK11SC	CKENCL,<? >
	.ASCIZ	\? \
	.EVEN
	MOV	CKDNAM,R0		;GET ASCIZ \DEVICE NAME\
	JSR	PC,CKTTXT		;TYPE DEVICE NAME
	CK11SC	<CKENCL>,< #>
	.ASCIZ	\ #\
	.EVEN
	MOV	CKDEVN,R0		;GET UNIT NUMBER
	JSR	PC,CKTOCT		;TYPE UNIT NUMBER
	CK11SC	<CKENCL>,<(Adr = >
	.ASCIZ	\(Adr = \
	.EVEN
	MOV	CHKCHR+CKDA,R0		;GET DEVICE ADDR
	JSR	PC,CKTOCT		;TYPE IT
	CK11SC	<CKENCL>,<)>
	.ASCIZ	\)\
	.EVEN
	BIS	#CKFIDT,CHKFLG		;REMEMBER WE TYPED DEVICE ID
11$:	RTS	PC

.SBTTL		ROUTINE TO FIND DEVICE INTERRUPT LEVEL
;
;CALL	JSR R5,CHKINL			;WITH DEVICE READY TO INT BUT
;					; WITH THE PS SET TO LEVEL 7.
;
CHKINL:	MOV	R0,-(SP)		;SAVE R0
	MOV	R1,-(SP)		;SAVE R1
	MOV	R2,-(SP)		;SAVE R2
	MOV	#300,R2			;START BY CHECKING LEVEL 6.
11$:	MOV	(R5),R1			;GET TIME TO WAIT
	CLR	R0			;WILL BE SET BY INT ROUTINE IF INT
	MTPS	R2			;LOWER PS LEVEL
12$:	TST	R0			;SEE IF INT YET
	BNE	13$			;NON 0 SAYS INTERRUPT
	SOB	R1,12$			;TIME AND WAIT
	MTPS	#BR7			;TIMED OUT SO SET LEVEL 7 AND LOWER AND TRY AGAIN
	SUB	#40,R2			;MAKE LEVEL LOWER BY 1
	BGE	11$			;BRANCH IF LEVEL 0 NOT CHECKED YET
	CK11SC	<CKEMSE!CKEDID!CKEPC>,<CKMG04>,<DEVICE NEVER INTERRUPTED>
	BR	15$			;EXIT
13$:	CMP	R0,CHKCHR+CKDV		;SEE IF SAME AS WHAT IT SHOULD BE
	BEQ	14$			;BRANCH IF CORRECT VECTOR
	CKSERR	<CHKCHR+CKDV>,<R0>,<R4>
	CK11SC	<CKEMSE!CKEPC!CKEDID!CKEGB>,<CKMG05>,<Device INTERRUPTED to WRONG VECTOR>
14$:	ADD	#40,R2			;MAKE THE DEVICE LEVEL
	MOV	R2,CHKCHR+CKPI		;SAVE LEVEL DEVICE INTERRUPTED AT
15$:	MOV	(SP)+,R2		;RESTORE R2
	MOV	(SP)+,R1		;RESTORE R1
	MOV	(SP)+,R0		;RESTORE R0
	TST	(R5)+			;SKIP OVER TIME DELAY CONSTANT
	RTS	R5			;RETURN WITH DEVICE LEVEL SAVED IN CHARACTERISTICS TABLE

.SBTTL		CHECK INTERRUPTS AND FIND DEVICE LEVEL

;ROUTINE TO CHECK INTERRUPTS AND FIND DEVICE LEVEL
;
; CALL	MOV	ENABLE ADR,R1
;	MOV	INT ADR,R2
;	JSR	R5,CKINT
;	ENABLE BIT
;	INTERRUPT BITS
;	SPECIAL CLEAR BITS
;	0 if BIS sufficient to generate interrupt, else address
;		of subroutine
;
CKINT:	MOV	R3,-(SP)
	MOV	R4,-(SP)
	CLR	CHKCHR+CKPI		;START WITH PI OF 0 (NO DEV)
	CLR	CKFLAG			;0 = PI LEVEL FOUND MUST BE PUT IN TABLE
					; NON 0 = CHECK PI LEVEL FOUND WITH TABLE
	MOV	#1,R4			;STARTING POSITION OF SLIDING INT BIT
CKINT1:	MOV	#BR7,R3			;START CHECKING AT THIS LEVEL
CKINT2:	MTPS	R3			;SET PS
	CLR	R0			;SET TO 0 SO IF INT HAPPENS WE KNOW IT
CKINT3:	BIT	R4,2(R5)		;IS THERE A BIT TO TEST?
	BNE	11$			;BRANCH IF BIT IN POSITION
	JMP	CKINT7			;MAKE NEW BIT POSITION
11$:	TST	6(R5)			;subroutine supplied?
	BEQ	12$			;no, do normal
	JSR	PC,@6(R5)		;yes, use it
	BR	13$			;and continue
12$:	BIS	(R5),(R1)		;SET INTERRUPT ENABLE
	BIS	R4,(R2)			;SET INTERRUPT BIT
	NOP				;ALLOW 1 EXTRA INST TIME FOR INT
13$:
	MTPS	#BR7			;LET NO INT HAPPEN
	BIC	(R5),(R1)		;CLEAR INT ENABLE
	TST	4(R5)			;SEE IF SPECIAL CLEAR
	BEQ	14$			;BRANCH IF NOT
	BIS	4(R5),(R2)		;SPECIAL CLEAR
	BR	15$			;CONTINUE
14$:	BIC	2(R5),(R2)		;CLEAR INT BITS
15$:	TST	R0			;IF R0 IS NON 0 IT SHOULD BE THE
					; VECTOR ADR. IF 0 NO INT HAPPENED.
	BNE	16$			;BRANCH IF INTERRUPT
	SUB	#40,R3			;MAKE PS VALUE 1 LEVEL LESS
	BGE	CKINT2			;BRANCH IF NEW LEVEL OK
	CK11SC	<CKEMSE!CKEPC!CKEDID>,<CKMG04>,<DEVICE NEVER INTERRUPTED>
	BR	CKINTF			;EXIT WITH FAILURE RETURN
;
;
; HERE WHEN THE DEVICE HAS INTERRUPTED
;
16$:	TST	CKFLAG		;FIRST TIME THROUGH?
	BNE	17$		;NO.
	DEC	CKFLAG		;YES, DON'T DO THIS AGAIN.
	MOV	R3,CHKCHR+CKPI	;STORE PRIORITY INTERRUPT LEVEL
	ADD	#40,CHKCHR+CKPI
	TST	CHKCHR+CKDV	;VECTOR SPECIFIED?
	BNE	17$		;YES, IT BETTER BE RIGHT.
	MOV	R0,CHKCHR+CKDV	;NO, SPECIFY IT NOW.
17$:	CMP	R0,CHKCHR+CKDV	;IS VECTOR RIGHT?
	BEQ	18$		;YES.
	MOV	R0,-(SP)	;SAVE RIGHT ADDR
	CKSERR	<CHKCHR+CKDV>,R0,<R2> ;GD,BD,ADR
	CK11SC	<CKEMSE!CKEPC!CKEDID!CKEGB>,<CKMG05>,<DEVICE INTERRUPTED TO WRONG VECTOR>
	MOV	(SP)+,CHKCHR+CKDV ;SET VECTOR RIGHT
	BR	CKINTE		;EXIT
;
18$:	MOV	R3,R0			;GET PRESENT LEVEL
	ADD	#40,R0			;MAKE IT THE DEVICE LEVEL
	CMP	R0,CHKCHR+CKPI		;CHECK LEVEL AGAINST LAST TIME
	BEQ	CKINT6			;BRANCH IF LEVEL CHECKS
	CKSERR	<CHKCHR+CKPI>,R0,R4
	CK11SC	<CKEPC!CKEDID!CKEGB>,<Interrupt to Different PI Level>,<INTERRUPT TO DIFFERENT PI LEVEL>
	.ASCIZ	\Interrupt to Different PI Level\
	.EVEN
	BR	CKINTE			;EXIT
;
;
CKINT6:	MTPS	#0			;CHECK WITH LEVEL 0 AND
	CLR	R0			; NO INT ENABLE BITS SET
	BIS	R4,(R2)			;  AND INT BIT SET THAT NO INT OCCURRS
	NOP				;PAUSE
	NOP				;PAUSE
	MTPS	#BR7			;DON'T LET AN INT HAPPEN
	TST	R0			;SEE IF ONE HAPPENED
	BEQ	11$			;BRANCH IF NO INT
	CK11SC	<CKEMSE!CKEDID!CKEPC>,CKMG07,<INTERRUPT WHEN NOT ENABLED>
	BR	CKINTF			;EXIT WITH FAILURE RETURN
11$:	TST	4(R5)			;SEE IF SPECIAL CLEAR
	BEQ	12$			;BRANCH IF NOT
	BIS	4(R5),(R2)		;SPECIAL CLEAR  (DL10 FOR ONE)
	BR	13$			;CONTINUE
12$:	BIC	R4,(R2)			;CLEAR INT BITS
13$:	ASL	R4			;MAKE NEW BIT POSITION
	BEQ	CKINTE			;BRANCH IF DONE
	JMP	CKINT1			;TEST NEW BIT
CKINT7:	ASL	R4			;MAKE NEW INT BIT POSITION
	BEQ	CKINTE			;BRANCH IF NO NEW BIT POSITION
	JMP	CKINT3			;BRANCH IF NEW BIT POSITION
CKINTE:	ADD	#10,R5			;FOR CORRECT RETURN
	CLC				;FLAG SUCCESS
CKINTG:					;COMMON RETURN CODE
	MOV	(SP)+,R4
	MOV	(SP)+,R3
	RTS	R5			;RETURN

CKINTF:	ADD	#10,R5			;FOR CORRECT RETURN ADDRESS
	SEC				;TO INDICATE FAILURE
	BR	CKINTG			;GO TO COMMON RETURN CODE

CKFLAG:	0
.SBTTL		HERE ON AN INTERRUPT WHILE IN CHK11

;HERE FROM AN INTERRUPT WHILE IN CHK11
; WILL RETURN VECTOR ADDRESS IN R0 (RANGE 0 TO 1174)
;
CHKINT:	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$			;COMPUTE INTERRUPT ADDRESS
	.WORD	0000			;THESE INTERRUPTS ARE 0000-0074
CHKITL=.-CHKINT				;LENGTH OF INTERRUPT BLOCK
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	0100
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	0200
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	0300
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	0400
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	0500
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	0600
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	0700
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	1000
	MFPS	R0			;GET PROCESSOR STATUS
	JSR	PC,11$
	.WORD	1100
;
; HERE AFTER AN INTERRUPT TO COMPUTE THE ADDRESS FROM THE THE LOW
;  FOUR BITS OF THE PS AND THE WORD AFTER THE JSR ABOVE.
;
11$:	BIC	#^C17,R0		;STRIP EXTRA BITS
	ASL	R0			;MULTIPLY BY 4
	ASL	R0
	ADD	@(SP)+,R0		;MAKES VECTOR ADR
	MOV	#BR7,2(SP)		;SO DON'T TRAP BACK AGAIN
	RTI

CHKFLV:	.BLKW	1			;CURRENT FLOATING DEVICE VECTOR
CHKFLD:	.BLKW	1			;CURRENT FLOATING DEVICE ADR
.IF NE CK..DH
.SBTTL		CHECK DH11 HDW

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKDH11
CKDH11:	MOV	R3,-(SP)	;SAVE REGISTER
	JSR	R5,CHKBIT	;CHECK RD/WRT BITS
	131177			;READ/WRITE BITS
	TST	(R1)+		;ADVANCE TO NXT REC CHAR REG
	TST	(R1)+		;ADVANCE TO LINE PARAMETER REG(XX4)
	JSR	R5,CHKBIT	;CHECK RD/WRT BITS
	177767			;READ/WRITE BITS
	TST	(R1)+		;ADVANCE TO CURRENT ADR REG(XX6)
	CLR	R2		;START CHECK AT LINE 0
11$:	MOV	R2,(R4)		;SELECT THE LINE
	JSR	R5,CHKBIT	;CHECK RD/WRT BITS
	-1			;READ/WRITE BITS
	INC	R2		;NEXT LINE TO CHECK
	CMP	R2,#17		;DONE
	BLE	11$		;CHECK LINES 0-17
	TST	(R1)+		;ADVANCE TO BYTE COUNT REG(X10)
	CLR	R2		;START CHECK AT LINE 0
12$:	MOV	R2,(R4)		;SELECT THE LINE
	JSR	R5,CHKBIT	;CHECK RD/WRT BITS
	-1			;READ/WRITE BITS
	INC	R2		;NEXT LINE TO CHECK
	CMP	R2,#17		;ALL LINES CHECKED?
	BLE	12$		;CHECK ALL 20 LINES
	TST	(R1)+		;ADVANCE TO BAR REG(XX12)
	TST	(R1)+		;ADVANCE TO BREAK REG(X14)
	JSR	R5,CHKBIT	;CHECK BITS
	-1			;READ/WRITE BITS
	TST	(R1)+		;ADVANCE TO SILO STATUS REG(X16)
	JSR	R5,CHKBIT	;CHECK READ/WRITE BITS
	77
	$CKINT	R4,R4,<DH.RIE!DH..MM>,<DH..RI>
	$CKINT	,,<DH.SIE!DH..MM>,<DH..SI>
	ADD	#4,CHKCHR+CKDV		;MAKE EXPECTED VECTOR FOR XMIT
	$CKINT	,,<DH.TIE>,<DH..TI>
	MOV	R3,CHKCHR+CKDV		;PUT VECTOR ADDRESS IN TABLE

CKDH1A:
	MOV	R3,DHXMII		;ADR TO COME TO ON XMIT INT
	ADD	#4,DHXMII		;
	MOV	#CKBLK,R0		;LOAD A BUFFER WITH COUNT PATTERN
	MOV	#400,R1			;LOAD 400 CHARACTERS
	CLR	R2			;START WITH 0
11$:	MOVB	R2,(R0)+		;STORE THE COUNT PATTERN
	INCB	R2			;NEW PATTERN
	SOB	R1,11$			;BUFFER LOADED?
	CLR	R3			;START WITH LINE 0
	MOV	#1,R2			;LINE BIT  (LINE 0)
CKDH1B:	CLR	DHDATA			;FIRST RCV'D SHOULD BE 0
	ND	NTRIB,0
.IF NE NTRIB
					;IF TRIBUTARY LINES IN USE
					;USE MINIMAL TEST TO AVOID INTERFERRENCE
					;WITH THE FUNCTIONAL STATIONS ON LINE
					;THE PROBLEM ARISES BECAUSE MAINTAINANCE
					;MODE ON THE DH11 DRIVES THE MODEM LINES!!!
	MOV	#-1,R1
	DEC	DHDATA
	MOVB	R1,CKBLK
.IFF
	MOV	#-400,R1
.ENDC	;.IF NE NTRIB
	BIS	#DH..MC,(R4)		;CLEAR THE DH
	BIS	#DH..MM!DH.SIE!DH.TIE!DH.RIE,(R4)	;ENABLE INTS
	BIS	R3,(R4)			;LOAD THE LINE NUMBER
	MOV	#B6!B8!B9!B10!B12!B13!DH.2SB!DH.CL8!DH.PEN!DH..OP,DH.LPR(R4) ;SEL 8BIT,9600,PAR,ODD
	MOV	R1,DH.BCR(R4)		;LENGTH TO XMIT
	MOV	#CKBLK,DH.CAR(R4)	;ADR WHERE THE DATA IS
	MOV	#4,DH.SSR(R4)		;ALARM LEVEL TO 4
CKDH1E:	CLR	R0			;INT RETURNS ADR IN HERE
	CLR	R1			;TIMER
	MOV	R2,DH.BAR(R4)		;SET LINE ACTIVE
11$:	MTPS	#0			;LEVEL TO 0 FOR INTS
	NOP				;LET AN INTERRUPT HAPPEN
	MTPS	#BR7			;DON'T LET ONE HAPPEN
	CMP	R0,CHKCHR+CKDV		;SEE IF RCV INT YET
	BEQ	16$			;BRANCH IF RCV INT
	CMP	R0,DHXMII		;SEE IF XMIT INT
	BEQ	13$			;BRANCH IF XMIT INT
	TST	R0			;SEE IF ANY INTERRUPT
	BEQ	12$			;BRANCH IF NO INTERRUPT
	CKSERR	<CHKCHR+CKDV>,R0,R3
	CK11SC	<CKEPC!CKEGB!CKEDID>,<Ill Int>,<ILLEGAL INT WHILE WAITING FOR DH11 INT>
	.ASCIZ	\Ill Int\
	.EVEN
	JMP	CKDH1D			;DON'T TEST ANY MORE
12$:	SOB	R1,11$			;TIME-OUT
	CK11SC	<CKEPC!CKEDID>,<No Int>,<NO DH11 INTERRUPT>
	.ASCIZ	\No Int\
	.EVEN
	JSR	PC,CKDHPL		;REPORT LINE NUMBER
	JMP	CKDH1D			;DON'T TEST ANY MORE
13$:	BIT	#DH.NXM,(R4)		;SEE IF NXM
	BEQ	14$			;BRANCH IF NO NXM
	CK11SC	<CKEPC!CKEDID>,<Xmit Nxm>,<TRANSMIT NXM ON DH>
	.ASCIZ	\Xmit Nxm\
	.EVEN
	JSR	PC,CKDHPL		;REPORT LINE NUMBER
	BR	CKDH1D			;DON'T TEST ANY MORE
14$:	BIT	#DH..TI,(R4)		;BETTER HAVE XMIT INT
	BNE	15$			;BRANCH IF WE DO
	CK11SC	<CKEPC!CKEDID>,<Ill Xmit Int>,<INT TO XMIT BUT FOR NO REASON>
	.ASCIZ	\Ill Xmit Int\
	.EVEN
	JSR	PC,CKDHPL		;REPORT LINE NUMBER
	BR	CKDH1D			;DON'T TEST ANY MORE
15$:	BIC	#DH..TI,(R4)		;CLEAR XMIT INT
	BR	CKDH1E			;
16$:	BIT	#DH..SI,(R4)		;SEE IF SILO OVERFLOW
	BEQ	CKDH1C			;BRANCH IF SILO HAD ROOM
	CK11SC	<CKEPC!CKEDID>,<Silo Full>,<SILO OVERFLOW>
	.ASCIZ	\Silo Full\
	.EVEN
	JSR	PC,CKDHPL		;REPORT LINE NUMBER
	BR	CKDH1D			;DON'T TEST ANY MORE
CKDH1C:	BIC	#DH..RI,(R4)		;CLEAR RCV INT (MUST FOR MAINT MODE)
	MOV	DH.NRC(R4),R0		;GET STUFF FROM SILO
	BIT	#DH.DOV!DH..FE!DH..PE,R0	;SEE IF ANY ERROR BITS WITH DATA
	BEQ	11$			;BRANCH IF NO ERRORS WITH THE DATA
	MOV	DHDATA,-(SP)		;MAKE THE GOOD
	MOV	R3,-(SP)			;PUT LINE # IN
	SWAB	(SP)			;GET IT IN THE (LB)
	BIS	(SP)+,(SP)		;LINE # NOW IN GOOD
	BIS	#DH.VDP,(SP)		;GOOD INCLUDES VALID DATA PRESENT
	MOV	R0,-(SP)			;THE BAD
	MOV	R3,-(SP)			;THE LINE UNDER TEST
	CK11SC	<CKEGB!CKEPC!CKEDID>,<Data Err Bit Set>,<ERROR BITS WITH THE DATA>
	.ASCIZ	\Data Err Bit Set\
	.EVEN
	BR	CKDH1D			;DON'T TEST ANY MORE
11$:	BIT	#DH.VDP,R0		;SEE IF VALID DATA
	BNE	12$			;BRANCH IF VALID DATA
	CK11SC	<CKEPC!CKEDID>,<Not Valid Data>,<NOT VALID DATA BIT SET>
	.ASCIZ	\Not Valid Data\
	.EVEN
	JSR	PC,CKDHPL		;REPORT LINE NUMBER
	BR	CKDH1D			;DON'T TEST ANY MORE
12$:	BIC	#B15!B14!B13!B12,R0	;CLEAR DATA ERROR BITS
	SWAB	R0			;FOR CHECKING LINE #
	CMPB	R0,R3			;SEE IF LINE #OK
	BEQ	13$			;BRANCH IF IT IS
	MOV	R3,-(SP)			;LEGAL LINE NUMBER
	CLR	-(SP)			;0 FOR BYTE MOVE
	MOVB	R0,(SP)			;THE ILLEGAL LINE NUMBER
	MOV	R3,-(SP)			;LINE UNDER TEST
	CK11SC	<CKEGB!CKEPC!CKEDID>,<Ill Line Num>,<ILLEGAL LINE NUMBER>
	.ASCIZ	\Ill Line Num\
	.EVEN
	BR	CKDH1D			;DON'T TEST ANY MORE
13$:	SWAB	R0			;FOR CHECKING THE DATA
	CMPB	R0,DHDATA		;SEE IF CORRECT DATA
	BEQ	14$			;BRANCH IF DATA OK
	MOV	DHDATA,-(SP)		;GOOD DATA
	CLR	-(SP)			;FOR BYTE MOVE
	MOVB	R0,(SP)			;THE BAD DATA
	MOV	R3,-(SP)			;THE LINE #
	CK11SC	<CKEGB!CKEPC!CKEDID>,<Data Err>,<DATA ERROR>
	.ASCIZ	\Data Err\
	.EVEN
	BR	CKDH1D			;DON'T TEST ANY MORE
14$:	INCB	DHDATA			;NEW PATTERN EXPECTED
	BEQ	15$			;BRANCH IF LINE DONE
	JMP	CKDH1E			;

15$:
CKDH1D:	INC	R3			;NEW LINE NUMBER
	ASL	R2			;NEW BIT FOR NEXT LINE
	BEQ	CKDH1F			;BRANCH IF TEST ALL DONE
	JMP	CKDH1B			;

CKDHPL:	CK11SC	0,<		Line #>
	.ASCIZ	\		Line #\
	.EVEN
	MOV	R3,R0			;LINE NUMBER TO R0 FOR CALL
	JSR	PC,CKTOCT		;PRINT LINE NUMBER
	RTS	PC			;RETURN

CKDH1F:	BIS	#DH..MC,(R4)		;MASTER CLEAR
	MOV	(SP)+,R3	;GET R3 BACK
	RTS	PC			;DH CHARACTER TEST DONE
DHDATA:	0
DHXMII:	0
.ENDC ;.IF NE CK..DH
.IF NE CK..DL
.SBTTL		CHECK DL11-E HDW

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKDL11
;
CKDL11:	MOV	R3,-(SP)
	JSR	R5,CHKBIT		;CHECK READ/WRITE BITS
	000156
	TST	(R1)+			;ADVANCE TO RECEIVE DATA REGISTER
	TST	(R1)+			;ADVANCE TO TRANSMIT STATUS REGISTER
	JSR	R5,CHKBIT
	000105
	MOV	(SP)+,R3
	RTS	PC
.ENDC ;.IF NE CK..DL
.IF NE CK..KL
.SBTTL		CHECK DL11-A HDW

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKKL11
;
CKKL11:	MOV	R3,-(SP)
	JSR	R5,CHKBIT		;CHECK READ/WRITE BITS
	.WORD	000100
	TST	(R1)+			;ADVANCE TO RECEIVE DATA REGISTER
	TST	(R1)+			;ADVANCE TO TRANSMIT STATUS REGISTER
	JSR	R5,CHKBIT
	.WORD	000104
	MOV	#CO.INE,4(R4)	;ENABLE PENDING OUTPUT INTERRUPT
	JSR	R5,CHKINL	;TEST INTERURPTS
	.WORD	-1		;TIMEOUT COUNTER
	BIC	#CO.INE,4(R4)	;DISABLE THAT INTERRUPT
	MOV	(SP)+,R3
	RTS	PC
.ENDC ;.IF NE CK..KL
.IF NE CK..DM
.SBTTL		CHECK DM11-BB HDW

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKDM11
CKDM11:	JSR	R5,CHKBIT		;CHECK FOLLOWING BITS
	DM.ALI!DM.DNE!DM..MM!DM.ENB!DM.IEN
	$CKINT	,R4,<DM.IEN>,<DM.DNE>
	JSR	PC,CKDMCS		;CLEAR SCAN AND CHECK IT CLEARED
	BIS	#DM.ENB,(R4)		;ENABLE SCAN
	BIT	#DM.BSY,(R4)		;SEE IF BSY SET
	BNE	11$			;BRANCH IF IT DID
	CK11SC	<CKEPC!CKEDID>,<Busy did not Set>,<BUSY DID NOT SET>
	.ASCIZ	\Busy did not Set\
	.EVEN
11$:	JSR	PC,CKDMCS		;CLEAR SCAN AND CHECKED IT CLEARED
	RTS	PC

CKDMCS:	MOV	#DM.DNE!DM..MM!DM.IEN!DM.ENB!DM.ALI,R2	;BITS WHICH SHOULD GET CLEARED
	MOV	#100,R0			;TIME OUT FOR BUSY
	BIS	#DM.SCN,(R4)		;CLEAR SCAN
11$:	BIT	#DM.BSY,(R4)		;SEE IF BUSY CLEAR YET
	BEQ	12$			;BRANCH IF IT IS
	SOB	R0,11$			;TIME OUT WAITING FOR BSY TO CLEAR
	CK11SC	<CKEPC!CKEDID>,<Busy did not Clear>,<CLEARING SCAN FAILED TO CLEAR BUSY>
	.ASCIZ	\Busy did not Clear\
	.EVEN
12$:	BIT	R1,(R4)			;SEE IF THEY ARE ALL CLEAR
	BEQ	14$			;BRANCH IF THEY ARE ALL CLEAR
	MOV	(R4),R0			;GET DM11 STATUS
	COM	R2			;MASK OUT NON INTERESTING BITS
	BIC	R2,R0			;
	CLR	-(SP)			;GOOD
	MOV	R0,-(SP)			;BAD
	MOV	R4,-(SP)			;ADR
	CK11SC	<CKEGB!CKEPC!CKEDID>,<Clear Scan Error>,<CLR SCAN FAILED TO CLEAR A BIT>
	.ASCIZ	\Clear Scan Error\
	.EVEN
14$:	RTS	PC
.ENDC ;.IF NE CK..DM
.IF NE CK..DN
.SBTTL		CHECK DN11 HDW

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKDN11
CKDN11:	JSR	R5,CHKBIT		;CHECK BITS
	007714				;READ/WRITE BITS
	$CKINT	,R4,<DN..IE!DN..ME>,<DN.DNE>
	RTS	PC
.ENDC ;.IF NE CK..DN
.IF NE CK..DP
.SBTTL		CHECK DP11 HDW

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKDP11
CKDP11:	JSR	R5,CHKBIT		;CHECK BITS
	3707				;READ/WRITE BITS
	TST	(R1)+			;ADV TO REC BUF/SYN REG
;	JSR	R5,CHKBIT		;CHECK BITS
;	000000				;READ/WRITE BITS
	TST	(R1)+			;ADV TO XMT STATUS REG
	JSR	R5,CHKBIT
	000143				;READ/WRITE BITS
;	TST	(R1)+			;ADV TO XMT BUFFER
;	JSR	R5,CHKBIT
;	000000				;READ/WRITE BITS
	$CKINT	R4,R4,B6,B7
	RTS	PC
.ENDC ;.IF NE CK..DP
.IF NE CK..DQ
.SBTTL		CHECK DQ11 HDW

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKDQ11
CKDQ11:
	JSR	R5,CHKBIT		;CHECK WE CAN SET BITS
	110373				;READ/WRITE BITS
	TST	(R1)+			;ADVANCE TO XMT REGISTER
	JSR	R5,CHKBIT		;CHECK WE CAN SET BITS
	101772				;READ/WRITE BITS
	TST	(R1)+			;ADVANCE TO ERR REGISTER
	JSR	R5,CHKBIT		;CHECK WE CAN SET BITS
	017477				;READ/WRITE BITS
	TST	(R1)+			;ADVANCE TO SHADOW REGISTERS
	JSR	R5,CHKBIT
	-1

;DETERMINE DQ11 INTERRUPT LEVEL
;
11$:	$CKINT	R4,R4,DQ.RIE,<DQ.RDP!DQ.RDS>
	MOV	CHKCHR+CKDV,-(SP)	;SAVE VECTOR
	ADD	#4,CHKCHR+CKDV		;MAKE VECTOR B
	CMP	(R1)+,(R2)+		;POINT TO XMIT REG
	$CKINT	,,<DQ.XIE>,<DQ.XDS!DQ.XDP>
	TST	(R2)+			;ADVANCE INT BIT POINTER TO ERR REG
	$CKINT	,,<DQ.EIE>,<DQ.VRC!DQ.XLE!DQ.RLE!DQ.XNX!DQ.RNX!DQ.XCL!DQ.RCL>
	MOV	(SP)+,CHKCHR+CKDV		;RESTORE VECTOR A VECTOR

;HERE BECAUSE DQ11 TRAPED TO RIGHT LOCATION
; CHECK WE CAN CLEAR THE DATASET FLAG
12$:	MOV	#5,R0			;PATIENCE COUNTER ON DATASET FLAG
13$:	BIC	#DQ.DSF,2(R4)		;CLEAR DATASET FLAG
	CMP	(SP),(SP)			;TIME WASTER ONLY
	BIT	#DQ.DSF,2(R4)		;CHECK TO SEE IF DATASET FLAG STILL OFF
	BEQ	CHKDQE
	SOB	R0,13$
	CK11SC	<CKEDID!CKEPC>,<Can't Clr Dataset Flg>,< CAN'T CLEAR DATASET FLAG>
	.ASCIZ	\Can't Clr Dataset Flg\
	.EVEN
;CHECK ERROR BITS WORK
;
CHKDQE:	JSR	PC,CKDQCL		;CLEAR ENTIRE DQ
	MOV	#40,R2			;FIRST BIT TO TRY
11$:	BIS	R2,4(R4)		;SET AN ERROR BIT
	MOV	4(R4),R0		;GET ERR REG
	BPL	12$			;BRANCH IF B15 ERR NOT SET
	BIT	R2,R0			;SEE IF THE BIT SET
	BNE	13$			;BRANCH IF B15 SET AND ERR BIT SET
12$:	MOV	R2,-(SP)			;SAVE GOOD
	BIS	#B15,(SP)		; ALSO MUST INCLUDE BIT 15.
	JSR	PC,CKDQES		;PUT BAD AND REG # ON STACK
	CK11SC	<CKEDID!CKEPC!CKEGB>,<Bit not Set>,<CAN'T SET BIT>
	.ASCIZ	\Bit not Set\
	.EVEN
13$:	BIC	R2,4(R4)		;CLEAR BIT JUST SET, SHOULD ALSO CLEAR B15.
	MOV	4(R4),R0		;SAVE RESULTS
	BMI	14$			;BRANCH IF B15 SET (IT SHOULDN'T BE)
	BIT	R2,R0		;SEE IF THE BIT IS CLEAR
	BEQ	15$			;BRANCH IF ITS 0
14$:	CLR	-(SP)			;WHAT GOOD SHOULD BE
	JSR	PC,CKDQES		;SAVE BD, AND REG # ON STACK
	CK11SC	<CKEDID!CKEPC!CKEGB>,<Bit not Clear>,<COULDN'T CLEAR BIT>
	.ASCIZ	\Bit not Clear\
	.EVEN
15$:	ASR	R2			;ALL DONE?
	BNE	11$			;BRANCH BACK IF ANOTHER BIT TO TEST
	BR	CHKDQS		;GO CHECK SECONDARY REGS

CKDQES:	MOV	(SP)+,R1			;SAVE RETURN PC
	MOV	R0,-(SP)			;PUT C(ERR REG) ON STACK
	MOV	R2,-(SP)			;BIT WE TESTED
	BIS	#B15,(SP)		;INCLUDE ERROR BIT
	COM	(SP)			;
	BIC	(SP)+,(SP)		;KEEP ONLY THE INTERESTING BITS
	MOV	R4,-(SP)			;SAVE REG ADR
	ADD	#4,(SP)			;MAKE IT THE ERROR REG
	JMP	(R1)			;RETURN
;HERE TO CHECK WE CAN LOAD VARIOUS DQ11 SECONDARY REGISTERS

CHKDQS:	CLR	R0			;1ST TRY TO CLEAR ALL SECONDARY REGISTERS
	JSR	PC,16$			;GO DO IT
	MOV	#-1,R0			;NOW TRY TO SET ALL SECONDARY REGISTERS
	JSR	PC,16$
	MOV	#1,R0			;BIT TO LOAD
11$:	JSR	PC,16$			;TRY TO LOAD BIT
	ASL	R0			;SHIFT BIT
	BNE	11$			;BRANCH IF STILL HAVE BITS TO TEST
	MOV	#RG.SYN,R1		;NOW TRY TO LOAD REG WITH REG #
12$:	MOV	R1,R0			;DATA = REGISTER NUMBER
	JSR	PC,CKDQSL		;TRY TO LOAD REGISTER
	CMP	#RG.SYN,R1
	BNE	13$
	DEC	R1			;SKIP REG 10
13$:	DEC	R1			;ON TO NEXT REGISTER
	BPL	12$
	MOV	#RG.SYN,R1		;NOW CHECK IT LOADED
14$:	MOV	R1,R0			;DATA SHOULD BE SAME
	JSR	PC,CKDQSR		;CHECK DATA STILL THERE
	CMP	#RG.SYN,R1		;WAS THIS THE FIRST REG ?
	BNE	15$
	DEC	R1			;YES SO SKIP REG 10
15$:	DEC	R1			;ON TO NEXT REGISTER
	BPL	14$			;DO REST IF ANY
	MOV	#RG.MSC,R1		;NOW TEST MISC REG
	CLR	R0			;TRY TO CLEAR REGISTER
	JSR	PC,CKDQSL		;TRY TO LOAD IT
	MOV	#2,R0			;TEST STEP-MODE BIT
	JSR	PC,CKDQSL
	MOV	#10,R0			;TEST TEST-LOOP BIT
	JSR	PC,CKDQSL
	CLR	R0
	JSR	PC,CKDQSL		;CLEAR MISC REG
	BR	CHKDQL			;DO A LOOP BACK TEST

16$:	MOV	#RG.SYN,R1		;1ST REGISTER TO LOAD
17$:	JSR	PC,CKDQSL
	CMP	#RG.SYN,R1		;DID WE JUST CHECK THE SYN REG ?
	BNE	18$
	DEC	R1			;YES SO SKIP A REG
18$:	DEC	R1			;ON TO THE NEXT REG
	BPL	17$
	RTS	PC			;YES

;HERE TO LOAD A DQ11 2NDARY REGISTER
; CALL	MOV	#DATA,R0
;	MOV	#REG,R1
;	JSR	PC,CKDQSL
CKDQSL:	BIS	#DQ.MBM,R1
	MOVB	R1,5(R4)		;SELECT THE REGISTER
	MOV	R0,6(R4)		;LOAD THE DATA
CKDQSR:	BIS	#DQ.MBM,R1
	MOVB	R1,5(R4)		;SELECT THE REGISTER
	BIC	#DQ.MBM,R1
	CMP	R0,6(R4)		;CHECK TO SEE IF WE LOADED IT
	BNE	11$
	RTS	PC
11$:	MOV	R0,-(SP)			;SAVE GOOD DATA
	MOV	6(R4),-(SP)		;SAVE BAD DATA
	MOV	R1,-(SP)			;SAVE 2ND REG #
	CK11SC	<CKEDID!CKEPC!CKEGB>,<Secondary Reg Err>,<SECONDARY REG ERROR>
	.ASCIZ	\Secondary Reg Err\
	.EVEN
	RTS	PC			;RETURN
.SBTTL		FIND THE DQ11 SPECIAL CHARACTERS

;HERE TO DISCOVER WHAT THE SPECIAL
;CHARACTERS ARE IN THE DQ11.
;
CHKDQL:
.IF NE SPCVFY			;CHECK FOR SPECIAL CHARS ONLY IF USED
	CLR	CHKCHR+CKFLG		;CLEAR WHERE WE COUNT SPECIAL CHARS
	MOV	R2,-(SP)		;SAVE R2
	MOV	R3,-(SP)		;SAVE R3 (VECTOR)
	MOV	R5,-(SP)		;SAVE R5
	MOVB	#255,CHKXBF+2		;SOMETHING OTHER THAN SYNC (226)
	CLR	R3			;START WITH CHARACTER 0
CKDQLP:
11$:	JSR	PC,CKDQCL		;CLEAR DQ
	MOV	#CHKRBF,R5		;ADDRESS TO LOAD
	MOV	#<<CHKRBF-CHKXBF>/2>,R1	;LENGTH TO LOAD
	CLR	R2			;DATA TO LOAD
	JSR	PC,CKLDBF		;LOAD BUFFER
	MOV	#226*401,CHKXBF		;SYNC CHAR WE USE
	MOVB	R3,CHKXBF+3		;PUT CHAR IN XMIT BUFFER
	DQREGS	SYN,(R4)		;SYNC REG
	MOV	#226*401,6(R4)		;PUT SYNC CHAR IN REG
	DQREGS	MSC,(R4)		;MISC REG
	MOV	#4010,6(R4)		;LOAD MISC REG
	DQREGS	PTA,(R4)		;PRI XMIT ADDR REG
	MOV	#CHKXBF,6(R4)		;LOAD XMIT PRI ADDR REG
	DQREGS	STA,(R4)		;SEC XMIT ADR REG
	MOV	#CHKXBF,6(R4)		;LOAD XMIT SEC ADDR REG
	DQREGS	PRA,(R4)		;PRIMARY RECEIVE ADDR REG
	MOV	#CHKRBF,6(R4)		;LOAD REC ADDR REG PRI
	DQREGS	SRA,(R4)		;SEC REC ADR REG
	MOV	#CHKRBF,6(R4)		;LOAD REC ADDR REG SEC
	DQREGS	PTC,(R4)		;PRI XMIT CC
	MOV	#-4,6(R4)		;LOAD PRI XMIT CC
	DQREGS	STC,(R4)		;SEC XMIT CC
	MOV	#-2,6(R4)		;LOAD SEC XMIT CC
	DQREGS	PRC,(R4)		;PRI REC CC
	MOV	#-2,6(R4)		;LOAD PRI REC CC
	DQREGS	SRC,(R4)		;SEC REC CC
	MOV	#-2,6(R4)		;LOAD SEC REC CC
	CLR	R1			;CLEAR SAVED STATUS
	MOV	#DQ.RGO!DQ.CIE!DQ.RIE,(R4)	;TELL REC TO GO WITH IE
	MOV	#DQ.XGO,2(R4)		;TELL XMIT TO GO
CKDQWA:	CLR	R5			;FOR TIME-OUT
	CLR	R0			;UPON INT R0 WILL GET VECTOR
	MTPS	#0			;LET INT HAPPEN
11$:	TST	R0			;SEE IF AN INTERRUPT
	BNE	12$			;BRANCH IF ONE (R0 IS NON 0)
	SOB	R5,11$			;TIME OUT
	CK11SC	<CKEPC!CKEDID>,<Timed Out>,<TIMED OUT WHILE WAITING FOR AN INT>
	.ASCIZ	\Timed Out\
	.EVEN
	BR	CKDQOT		;DON'T CHK THIS DQ ANY MORE
12$:	CMP	R0,CHKCHR+CKDV		;SEE IF WE CAME TO THE RIGH VECTOR
	BEQ	CKDQGI			;BRANCH IF WE DID
	CKSERR	<CHKCHR+CKDV>,R0,R4	;SAVE GD,BD,DEV ADR
	CK11SC	<CKEPC!CKEDID!CKEGB>,<Interrupted to Wrong Vector>,<INTERRUPTED TO WRONG VECTOR>
	.ASCIZ	\Interrupted to Wrong Vector\
	.EVEN
	BR	CKDQOT			;DON'T CHK ANY MORE OF THIS DQ
CKLDBF:	MOV	R2,(R5)+		;PUT DATA IN ADDR
	SOB	R1,CKLDBF		;FILLED?
	RTS	PC			;YES.

CKDQGI:	MOV	(R4),R5			;GET STATUS
	TSTB	R5			;SEE IF DONE YET?
	BMI	11$			;BRANCH IF SO
	BIT	#DQ.RDS,R5		;SEE IF SEC INT
	BNE	14$			;BRANCH IF IT IS
	BIT	#DQ.VCH,R5		;SEE IF SPECIAL CHAR INT
	BNE	12$			;BRANCH IF SO
	CK11SC	<CKEDID!CKEPC>,<Illegal Interrupt>,<SOME BIT OTHER THAN SPEC CHAR INT'ED US>
	.ASCIZ	\Illegal Interrupt\
	.EVEN
	BR	CKDQOT			;DON'T CHECK ANY MORE OF THIS DQ
11$:	BIT	#DQ.VCH,R5		;SEE IF SPECIAL CHAR INT
	BEQ	13$			;BRANCH IF NOT
	MOV	R5,R1			;SAVE REC STATUS FOR PRINT
	BIC	#DQ.VCH!DQ.RDP!DQ.CIE,(R4)	;DISMISS INT
	BR	CKDQWA			;GO WAIT FOR ANOTHER INT
12$:	BIC	#DQ.VCH,(R4)		;CLEAR FOR EXIT
	BR	CKDQWA			;GO WAIT FOR ANOTHER INT
13$:	BIC	#DQ.RDP,(R4)		;
	BR	CKDQWA			;GO WAIT FOR ANOTHER INT
14$:	BIT	#DQ.VCH,R1		;WAS IT A SPECIAL CHAR?
	BEQ	20$			;NO, SO JUST UPDATE PATTERN
	BIT	#DQ.CHR,R1		;WAS THERE CAUSE FOR VCH ?
	BNE	15$			;MUST BE NON 0 OR WHY ARE WE HERE
	CK11SC	<CKEDID!CKEPC>,<Spec Char Code Fld 0>,<SPECIAL CHAR CODE FIELD 0>
	.ASCIZ	\Spec Char Code Fld 0\
	.EVEN
	BR	CKDQOT			;DON'T CHECK ANY MORE OF THIS DQ
15$:	BIT	#DQ.ETB!DQ.ETX!DQ.ENQ,R1 ;WAS IT INTERESTING SPECIAL CHAR ?
	BNE	17$			;IF SO FIND WHICH
	BIS	#B15,CHKCHR+CKFLG	;SET FLAG THAT SYNC INTERRUPTS
	BR	20$
16$:	.WORD	B10
	.WORD	B9
	.WORD	B8
17$:	MOV	#4,R5			;INDEX FOR SPECIAL CHAR TABLE
	INC	CHKCHR+CKFLG		;COUNT SPECIAL CHARACTER
18$:	BIT	16$(R5),R1		;CHECK FOR SPECIAL CHAR FLAG
	BEQ	19$
	MOV	R3,CHKCHR+CKSPC(R5)	;PUT INTO THE TABLE
19$:	SUB	#2,R5
	BGE	18$			;LOOK FOR ANOTHER MAYBE
20$:	INCB	R3			;NEXT CHAR TO CHECK
	BEQ	21$			;BRANCH IF ALL DONE
	BIC	#DQ.RDS!DQ.VCH!DQ.CIE!DQ.RIE,(R4)	;
	JMP	CKDQLP			;
CKDQOT=.
21$:	MOV	(SP)+,R5
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	CMPB	CHKCHR+CKFLG,#4		;SHOULD BE NO MORE THAT 4
	BLE	23$			;CHECK IF SO
	CK11SC	<CKEDID!CKEPC>,<More than 4 Spec Char Det>,<MORE THAN 4 SPEC CHAR WERE DETECTED>
	.ASCIZ	\More than 4 Spec Char Det\
	.EVEN
	BR	CKDQOT			;DON'T CHECK ANY MORE OF THIS DQ
.IFF
22$:	JSR	R0,CKTSTR
	.ASCIZ	\	SKIPPING SPEC CHAR TEST\
	.EVEN
	MOV	#377+<<.+6-22$>/2>,22$	;SHUT OFF SKIPPING COMMENT
.ENDC ; .IF NE SPCVFY
23$:	RTS	PC			;RETURN
.SBTTL		CLEAR THE DQ11

;ROUTINE TO CLEAR THE ENTIRE DQ
;
CKDQCL:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	DQREGS	MSC,(R4)		;SELECT MISC REG
	MOV	#DQ.MC,6(R4)		;MASTER CLEAR
	DQREGS	MSC,(R4)		;SELECT MISC REG AGAIN
	MOV	#DQ.MC,6(R4)		;MASTER CLEAR AGAIN
	MOV	#17,R0			;CLEAR ALL SEC REG
	MOV	#B12,R2			;CLEAR BITS 13+14 IN ERR
11$:	MOV	R2,4(R4)		;SELECT A SEC REG
	CLR	6(R4)			;CLEAR THAT SEC REG
	ADD	#B8,R2			;SELECT NEXT SEC REG TO CLEAR
	SOB	R0,11$			;ALL SEC CLEARED?
	MOV	(SP)+,R2		;RESTORE REGS USED
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	PC			;RETURN

	ND	CHKBSZ,10
CHKXBF:	.BLKB	CHKBSZ
CHKRBF:	.BLKB	CHKBSZ

.ENDC ;.IF NE CK..DQ
.IF NE CK..DS
.SBTTL		CHECK DS11 HDW [1(22)]

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKDS11
;
CKDS11:
	MOV	DS.AUX,R1		;GET AUX REG TO SEE HOW MANY GROUPS
	MOV	#DS.AD1,R2		;FOR CHECKING GROUP NUMBER
	MOV	#4,R0			;ALWAYS 1 GROUP IF DS11
11$:	BIT	R2,R1			;GROUP EXIST?
	BEQ	12$			;BRANCH IF NO GROUP
	ADD	#4,R0			;COUNT 4 LINES FOR EACH GROUP
	ASL	R2			;POSITION TO CHECK NEXT GROUP BIT
	BNE	11$			;BRANCH IF WE CAN CHECK ANOTHER
12$:	JSR	PC,CKTBOC		;PRINT NUMBER OF LINES
	CK11SC	CKENCL,< Lines>
	.ASCIZ	\ Lines\
	.EVEN
	MOV	#DS.AUX,R1		;CHECK THE AUX REG
	JSR	R5,CHKBIT		;CHECK FOLLOWING BITS
	1700				;BITS TO CHECK
	MOV	#DS.DVA-2,R1		;SET TO CHECK LINES
	MOV	#DS.VEC,CHKCHR+CKDV	;VECTOR TO START AT
	MOV	26(R5),CHKCHR+CKPI	;PI LEVEL FOR ALL DS11
	MOV	R0,R2			;NUMBER OF LINES TO CHECK
	MOV	#CHKCHR,R0		;POINT TO BLOCK FOR MAIN CALL
13$:	ADD	#2,R1			;LINE ADR TO CHECK
	MOV	R1,CHKCHR+CKDA		;MAIN NEEDS THIS INFO
	JSR	R5,CHKBIT		;CHK RECEIVE STATUS REG
	6477				;BITS TO CHECK
	TST	(R1)+			;ADVANCE TO REC DATA REG
	JSR	R5,CHKBIT		;CHK RECEIVE DATA REG
	7777				;BITS TO CHECK
	TST	(R1)+			;ADVANCE TO XMIT STATUS REG
	JSR	R5,CHKBIT		;CHK XMIT STATUS REG
	476				;BITS TO CHECK
	TST	(R1)+			;ADVNACE TO XMIT DATA REG
	JSR	R5,CHKBIT		;CHK XMIT DATA REG
	7777				;BITS TO CHECK
	JSR	PC,@14(R5)		;CALL THE MAIN PROGRAM
	ADD	#20,CHKCHR+CKDV		;ADVANCE VECTOR ADR FOR NEXT LINE
	ADD	#10,CHKCHR+CKDA		;ADVANCE DEVICE ADR FOR NEXT LINE
	SOB	R2,13$			;ALL LINES CHECKED?
	MOV	#DS.VEC,CHKCHR+CKDV	;SO "CHKDEV" WILL FILL OUT BLOCK
	RTS	PC
.ENDC ;.IF NE CK..DS
.IF NE CK..UP
.SBTTL		CHECK DUP11 HDW

;CALL	MOV	#<VECTOR ADR OF DUP11>,R3
;	MOV	#<HDW ADR OF DUP11>,R4
;	MOV	#<HDW ADR OF DUP11>,R1
;	JSR	PC,CKUP11
;
CKUP11:	MOV	R5,-(SP)	;SAVE R5
	MOV	R4,-(SP)	; AND R4
	MOV	R3,-(SP)	; AND R3
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	UP.DTR!UP.RTS!UP.STD!UP.REN!UP.DIE!UP.SSY
	ADD	#4,R1		;TEST OTHER CSR
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	UP.HDX!UP.SND!UP.XIE
	MOV	#3,R0		;BE SURE INIT BIT CLEARS ITSELF
	MOV	#UP.INI,UP.XSR(R4) ;INIT THE DUP11
11$:	MOV	UP.XSR(R4),R1	;GET THE CSR
	BIT	#UP.INI,R1	;HAS BIT CLEARED ITSELF?
	BEQ	13$		;YES, GO ON.
	SOB	R0,11$		;NO, GIVE IT 2 MICROSECONDS
	CKSERR	#0,R1,R4	;SAVE VALUES
	CK11SC	<CKEPC!CKEGB>,<DUP11 CLEAR FAILED>,<DUP11 CLEAR FAILED>
	.ASCIZ	/DUP11 clear failed/
	.EVEN
12$:	MOV	#UP.INI,UP.XSR(R4) ;BE SURE DUP11 IS CLEAR
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R4	; AND R4
	MOV	(SP)+,R5	; AND R6
	RTS	PC		;RETURN.
;
; COME HERE IF THE DUP11 PASSES THE PRELIMINARY TESTS.  CHECK ITS
;  INTERRUPTS.
;
13$:	MOV	R4,R1		;POINT TO TRANSMIT CSR
	ADD	#4,R1
	MOV	R1,R2
	ADD	#4,CHKCHR+CKDV		;MOVE XMIT VECTOR TO TRANSMIT
	$CKINT	,,<UP.XIE>,<UP.XDN>,<UP.INI>
	SUB	#4,CHKCHR+CKDV		;RESTORE BASE VECTOR
	CMP	#UP.LVL*40,CHKCHR+CKPI	;SEE IF WE GOT RIGHT PI LEVEL
	BEQ	12$			;IF WE DID, THEN OK
	CKSERR	#UP.LVL*40,CHKCHR+CKPI,CHKCHR+CKDV ;GOOD, BAD, ADDRESS
	CK11SC	<CKEGB!CKEDID!CKEMSG>,<Wrong PI assignment.>,<Bad pi>
	.ASCII	/DUP-11 at wrong PI assignment./<15><12>
	.ASCII	/Field Service note!  Your print set is wrong./<15><12>
	.ASCIZ	/The BR card should be PI 6./
	.EVEN
	BR	12$		;ALL DONE.
.ENDC ;.IF NE CK..UP
.IF NE CK..MD
.SBTTL		CHECK KMC11 HDW

;CALL	MOV	#<VECTOR ADR OF KMC11>,R3
;	MOV	#<HDW ADR OF KMC11>,R4
;	MOV	#<HDW ADR OF KMC11>,R1
;	JSR	PC,CKMD11
;
CKMD11:	MOV	#MD.CLR,(R4)	;INITIALIZE THE KMC11
	MOV	R5,-(SP)	;SAVE R5
	MOV	R4,-(SP)	; AND R4
	MOV	R3,-(SP)	; AND R3
	CLR	(R4)		;CLEAR THE CSRS
	CLR	2(R4)
	CLR	4(R4)
	CLR	6(R4)
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	377		;ALL BITS OF BSEL 0
	ADD	#2,R1		;LOOK AT SEL 2
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	-1		;ALL BITS OF SEL 2
	ADD	#2,R1		;LOOK AT SEL 4
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	-1		;ALL BITS OF SEL 4
	ADD	#2,R1		;LOOK AT SEL 6
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	-1		;ALL BITS OF SEL 6
.IF NE,FT.KMC
	TST	MDCODB+2	;IF WE ARE RETAINING THE CRAM...
	BEQ	CKMDCC		; DON'T CHECK INTERRUPTS (CLOBBERS CRAM 0)
.ENDC ;.IF NE,FT.KMC
;
; CHECK INTERRUPTS
;
	$CKINT	R4,R4,0,-1,MD.CLR,11$
	BR	CKMDCC		;CONTINUE TESTING THE KMC11
;
; SUBROUTINE TO CAUSE A KMC11 INTERRUPT
;
; R1 = ENABLE ADDRESS
; R2 = INTERRUPT ADDRESS
; R4 = CURRENT INTERRUPT BIT
; 0(R5) = INTERRUPT ENABLE BIT, CLEARED ON RETURN
; 4(R5) = INTERRUPT CLEAR BIT, SET ON RETURN
;
11$:	MOV	#MD.RMI,(R2)	;SET ROM I
	MOV	#<B8+B7>,6(R2)	;LOAD 200 INTO BRG
	BIS	#MD.SMP,(R2)	;EXECUTE THE INSTRUCTION
	CLR	(R2)		;TURN OFF STEP AND ROM I
	MOV	#MD.RMI,(R2)	;SET ROM I
	MOV	#<B14+B13+B9+B7+B4+11>,6(R2)
	BIS	#MD.SMP,(R2)	;STORE BRG INTO OUT* REG 11
	CLR	(R2)		;TURN OFF ROM I
	RTS	PC		;RETURN.
;
; IF WE HAVE A VALID COPY OF THE MICROCODE, WE CAN TEST
;  THE CRAM.  OTHERWISE BYPASS MOST OF THE TESTING.
;
CKMDCC:
.IF NE,FT.KMC
	TST	MDCODB+2	;IS MICROCODE IMAGE INVALID?
	BNE	17$		;NOT OBVIOUSLY
	JSR	PC,CKMDEX	;YES, BE SURE WE CAN CYCLE THE CRAM
	JMP	CKMDXT		; BUT LEAVE ITS CONTENTS ALONE.
17$:
.ENDC ;.IF NE,FT.KMC
	CLR	R1		;START AT CRAM ADDRESS 0
11$:	CLR	R0		;DATA IS ZERO
	JSR	PC,CKMDWR	;WRITE 0 AND CHECK IT
	INC	R1		;NEXT CRAM LOCATION
	CMP	#2000,R1	;REACHED THE END OF THE CRAM?
	BNE	11$		;NO, DO THE REST.
	JSR	PC,CKMDEX	;COMPLEMENT THE CRAM TWICE
	CLR	R1		;START AT THE BEGINNING AGAIN
12$:	JSR	PC,CKMDRD	;READ A WORD FROM THE CRAM
	TST	R0		;IS IT ZERO?
	BEQ	13$		;YES, THAT IS OK.
	CKSERR	<#0>,R0,R1	;GOOD, BAD, CRAM ADDRESS
	CK11SC	<CKEPC!CKEGB!CKEDID>,<CRAM CLEAR FAILED>,<CRAM CLEAR FAILED>
	.ASCIZ	/ CRAM clear failed /
	.EVEN
13$:	INC	R1		;NEXT CRAM ADDRESS
	CMP	#2000,R1	;REACHED THE END OF THE CRAM?
	BNE	12$		;NO, DO THE REST.
;
; NOW SET EACH CRAM LOCATION TO ITS OWN ADDRESS.  THIS CHECKS FOR
;  ADDRESSING FAILURES.
;
	CLR	R1		;START AT LOCATION ZERO
14$:	MOV	R1,R0		;GET ADDRESS
	ASL	R0		; * 2 (WE ARE PUTTING THE 10-BIT
	ASL	R0		; * 4  CRAM ADDRESS IN THE MIDDLE
	ASL	R0		; * 8  OF THE 16-BIT WORD.)
	JSR	PC,CKMDWR	;WRITE ADDRESS INTO CRAM
	INC	R1		;NEXT CRAM ADDRESS
	CMP	#2000,R1	;REACHED END OF CRAM YET?
	BNE	14$		;NO, GO DO THE REST.
	JSR	PC,CKMDEX	;COMPLEMENT THE CRAM TWICE
	CLR	R1		;START AT BEGINNING OF CRAM AGAIN
15$:	JSR	PC,CKMDRD	;READ WORD FROM CRAM
	MOV	R1,R2		;GET CRAM ADDRESS
	ASL	R2		; * 2
	ASL	R2		; * 4
	ASL	R2		; * 8
	CMP	R0,R2		;IS THE CRAM OK?
	BEQ	16$		;YES.
	CKSERR	R2,R0,R1	;GOOD, BAD, CRAM ADDRESS
	CK11SC	<CKEPC!CKEGB!CKEDID>,<CRAM ERROR>,<CRAM ERROR>
	.ASCIZ	/ CRAM data = address error /
	.EVEN
16$:	INC	R1		;NEXT CRAM ADDRESS
	CMP	#2000,R1	;REACHED THE END OF THE CRAM?
	BNE	15$		;NO, GO DO THE REST.
;
; NOW LOAD THE APPLICATION CODE INTO THE CRAM, IF REQUESTED.
;
CKMDCL:
.IF NE,FT.KMC
	CLR	R1		;START AT THE BEGINNING OF THE CRAM
	MOV	#MDCODB,R2	;POINT TO APPLICATION CODE
11$:	MOV	(R2)+,R0	;GET WORD TO LOAD
	JSR	PC,CKMDWR	;WRITE IT INTO THE CRAM
	INC	R1		;POINT TO NEXT CRAM LOCATION
	CMP	R1,#2000	;REACHED END OF CRAM? [2(41)]
	BNE	11$		;NO, LOAD THE REST.
	JSR	PC,CKMDEX	;COMPLEMENT THE CRAM TWICE
	CLR	R1		;START AT BEGINNING OF CRAM AGAIN
	MOV	#MDCODB,R2	;POINT TO APPLICATION CODE AGAIN
12$:	JSR	PC,CKMDRD	;READ A WORD FROM THE CRAM
	MOV	(R2)+,R3	;GET WORD THAT SHOULD BE THERE
	CMP	R3,R0		;IS IT RIGHT?
	BEQ	13$		;YES.
	CKSERR	R3,R0,R1	;GOOD, BAD, CRAM ADDRESS
	CK11SC	<CKEPC!CKEGB!CKEDID>,<CRAM LOAD ERROR>,<CRAM LOAD ERROR>
	.ASCIZ	/ CRAM load error /
	.EVEN
13$:	INC	R1		;NEXT CRAM ADDRESS
	CMP	R1,#2000	;REACHED END OF CRAM? [2(41)]
	BNE	12$		;NO, DO THE REST.
.ENDC ;.IF NE,FT.KMC
;
; HERE WHEN WE ARE DONE CHECKING THE KMC11
;
CKMDXT:	MOV	#MD.CLR,0(R4)	;BE SURE THE KMC11 IS CLEAR
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R4	; AND R4
	MOV	(SP)+,R5	; AND R5
	RTS	PC		;RETURN.
;
; SUBROUTINE TO COMPLEMENT THE DATA IN THE KMC11'S CRAM TWICE.
;  IF THE KMC11 IS WORKING PROPERLY THIS WILL LEAVE THE CRAM
;  UNCHANGED.
;
CKMDEX:	CLR	R1		;START AT BEGINNING OF CRAM
11$:	JSR	PC,CKMDRD	;READ WORD FROM CRAM
	COM	R0		;COMPLEMENT IT
	JSR	PC,CKMDWR	;WRITE IT BACK (AND CHECK IT)
	INC	R1		;NEXT CRAM LOCATION
	CMP	#2000,R1	;REACHED END OF CRAM?
	BNE	11$		;NO, DO THE REST.
;
; NOW COMPLEMENT CRAM THE SECOND TIME
;
	CLR	R1		;BEGINNING OF THE CRAM
12$:	JSR	PC,CKMDRD	;READ A WORD FROM THE CRAM
	COM	R0		;COMPLEMENT IT
	JSR	PC,CKMDWR	;WRITE IT BACK
	INC	R1		;NEXT CRAM LOCATION
	CMP	#2000,R1	;REACHED THE END OF THE CRAM?
	BNE	12$		;NO, DO THE REST.
	RTS	PC		;YES, ALL DONE.
;
; SUBROUTINE TO WRITE A WORD INTO THE KMC11'S CRAM
;
; R0 = WORD TO WRITE
; R1 = CRAM ADDRESS
; R4 = POINTER TO KMC11 CSR
;
CKMDWR:	CLR	(R4)		;CLEAR BSEL 1
	MOV	R1,4(R4)	;SET ADDRESS INTO SEL 4
	MOV	R0,6(R4)	;LOAD DATA INTO SEL 6
	BIS	#MD.RMO,(R4)	;SET ROM O
	BIS	#MD.RMO!MD.CWR,(R4) ;SET CRAM WRITE ALSO
	CLR	(R4)		;CLEAR ROM O AND CRAM WRITE
	MOV	R1,4(R4)	;SET ADDRESS AGAIN
	BIS	#MD.RMO,(R4)	;SET ROM O
	MOV	6(R4),-(SP)	;GET DATA FROM CRAM
	CLR	(R4)		;CLEAR ROM O
	CMP	R0,(SP)		;DATA SAME AS WRITTEN?
	BEQ	11$		;YES.
	MOV	R2,-(SP)	;NO, SAVE R2
	MOV	2(SP),R2	;GET BAD DATA FROM CRAM
	CKSERR	R0,R2,R1	;GOOD, BAD, CRAM ADDRESS
	CK11SC	<CKEPC!CKEGB!CKEDID>,<CRAM DATA ERROR>,<CRAM DATA ERROR>
	.ASCIZ	/ CRAM data error in write check /
	.EVEN
	MOV	(SP)+,R2	;RESTORE R2
11$:	MOV	(SP)+,R0	;DELETE DATA FROM STACK
	RTS	PC		;RETURN.
;
; SUBROUTINE TO READ A WORD FROM THE KMC11'S CRAM.
;
; R1 = ADDRESS
; R4 = POINTER TO KMC11 CSR
;
; ON RETURN:
;
;  R0 = DATA FROM CRAM
;
CKMDRD:	CLR	(R4)		;CLEAR BSEL 1
	MOV	R1,4(R4)	;SET ADDRESS INTO BSEL 4
	BIS	#MD.RMO,(R4)	;SET ROM O
	MOV	6(R4),R0	;FETCH DATA
	CLR	(R4)		;CLEAR ROM O
	RTS	PC		;RETURN.
.ENDC ;.IF NE CK..MD
.IF NE,CK..MC
.SBTTL		CHECK DMC11 HDW

;CALL	MOV	#<VECTOR ADR OF DMC11>,R3
;	MOV	#<HDW ADR OF DMC11>,R4
;	MOV	#<HDW ADR OF DMC11>,R1
;	JSR	PC,CKMC11
;
CKMC11:	MOV	#MC.MCL,(R4)	;INITIALIZE THE DMC11
	MOV	R5,-(SP)	;SAVE R5
	MOV	R4,-(SP)	; AND R4
	MOV	R3,-(SP)	; AND R3
	CLR	(R4)		;CLEAR THE CSRS
	CLR	2(R4)
	CLR	4(R4)
	CLR	6(R4)
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	377		;ALL BITS OF BSEL 0
	ADD	#2,R1		;LOOK AT SEL 2
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	-1		;ALL BITS OF SEL 2
	ADD	#2,R1		;LOOK AT SEL 4
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	-1		;ALL BITS OF SEL 4
	ADD	#2,R1		;LOOK AT SEL 6
	JSR	R5,CHKBIT	;VERIFY THESE BITS WORK
	.WORD	-1		;ALL BITS OF SEL 6
;
; CHECK INTERRUPTS
;
	$CKINT	R4,R4,0,1,MC.MCL,11$
	BR	CKMCCC		;CONTINUE TESTING THE DMC11
;
; SUBROUTINE TO CAUSE A DMC11 INTERRUPT
;
; R1 = ENABLE ADDRESS
; R2 = INTERRUPT ADDRESS
; R4 = CURRENT INTERRUPT BIT
; 0(R5) = INTERRUPT ENABLE BIT, CLEARED ON RETURN
; 4(R5) = INTERRUPT CLEAR BIT, SET ON RETURN
;
11$:	MOV	#MC.RMI,(R2)	;SET ROM I
	MOV	#<B8+B7>,6(R2)	;LOAD 200 INTO BRG
	BIS	#MC.SMP,(R2)	;EXECUTE THE INSTRUCTION
	CLR	(R2)		;TURN OFF STEP AND ROM I
	MOV	#MC.RMI,(R2)	;SET ROM I
	MOV	#<B14+B13+B9+B7+B4+11>,6(R2)
	BIS	#MC.SMP,(R2)	;STORE BRG INTO OUT* REG 11
	CLR	(R2)		;TURN OFF ROM I
	RTS	PC		;RETURN.
;
; TEST CONTENTS OF CROM
;
CKMCCC:
	JSR	PC,CKMCEX	;YES, BE SURE WE CAN CYCLE THE CROM
;
; HERE WHEN WE ARE DONE CHECKING THE DMC11
;
CKMCXT:	MOV	#MC.MCL,0(R4)	;BE SURE THE DMC11 IS CLEAR
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R4	; AND R4
	MOV	(SP)+,R5	; AND R5
	RTS	PC		;RETURN.
;
; SUBROUTINE TO MAKE SURE WE CAN READ CROM
;
CKMCEX:	CLR	R1		;START AT BEGINNING OF CROM
11$:	JSR	PC,CKMCRD	;READ WORD FROM CROM
	INC	R1		;NEXT CROM LOCATION
	CMP	#2000,R1	;REACHED END OF CROM?
	BNE	11$		;NO, DO THE REST.
	RTS	PC		;YES, ALL DONE.
;
; SUBROUTINE TO READ A WORD FROM THE DMC11'S CROM.
;
; R1 = ADDRESS
; R4 = POINTER TO DMC11 CSR
;
; ON RETURN:
;
;  R0 = DATA FROM CROM
;
CKMCRD:	CLR	(R4)		;CLEAR BSEL 1
	MOV	R1,4(R4)	;SET ADDRESS INTO BSEL 4
	BIS	#MC.RMO,(R4)	;SET ROM O
	MOV	6(R4),R0	;FETCH DATA
	CLR	(R4)		;CLEAR ROM O
	RTS	PC		;RETURN.
.ENDC ;.IF NE CK..MC
.IF NE CK..DZ
.SBTTL		Check DZ11 Hardware [1(14)]

;Call:
;
;	MOV	#<vector address>,R3
;	MOV	#<hardware address>,R4
;	MOV	#<hardware address>,R1
;	JSR	PC,CKDZ11
;

CKDZ11:					;check DZ11 hardware
	MOV	R5,-(SP)		;save register
	MOV	R4,-(SP)		; ditto
	MOV	R3,-(SP)		;save vector address
	JSR	R5,CHKBIT		;test CSR read/write bits
	.WORD	DZ.MAI!DZ.MSE!DZ.RIE!DZ.SAE!DZ.TIE ;all read/write bits
	ADD	#4,R1			;point to transmit control register
	JSR	R5,CHKBIT		;test TCR read/write bits
	.WORD	-1			;all bits are read/write
	MOV	#5,R0			;timer
	MOV	#DZ.CLR,(R4)		;start clear going
11$:					;beginning of timing loop
	MOV	(R4),R1			;get CSR value
	BEQ	CKDZ00			;if zero, continue test
	SOB	R0,11$			;else, decrement count and loop
;here if DZ11 clear bit takes too long
	CKSERR	#0,R1,R4		;save values
	CK11SC	<CKEPC!CKEGB>,<DZ11 clear failed or slow>,<clear bit failed to zero CSR in 5 passes through loop>
	.ASCIZ	/DZ11 clear failed or slow/
	.EVEN
CKDZE:					;end of DZ11 checking code
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	MOV	(SP)+,R5
	MOV	#DZ.CLR,(R4)		;clear DZ11
	RTS	PC			;return to caller
CKDZ00:					;here to check transmit ready bit
	MOV	#DZ.MSE!DZ.MAI,(R4)	;set maintenance and start scan
	MOV	#377,R5			;bit map of lines
	MOV	R5,DZ.TCR(R4)		;enable all output lines
11$:					;here to wait for transmit ready flag
	MOV	#3,R0			;set up counter
12$:					;loop looking for flag
	MOV	(R4),R1			;check CSR
	BMI	13$			;if minus, flag is on so branch
	SOB	R0,12$			;loop till count expires
	CK11SC	<CKEPC>,<DZ11 transmit flag didn't set>,<after enabling all lines for output, DZ..TI bit didn't come up>
	.ASCIZ	/DZ11 transmit flag didn't set/
	.EVEN
	BR	CKDZE
13$:					;here when transmit ready flag up
	MOV	#1,R0			;assume line 0
	SWAB	R1			;get bits into right half
	BIC	#177770,R1		;turn off unwanted bits
	BEQ	15$			;if zero, done
14$:					;loop to shift bits
	ASL	R0			;shift
	SOB	R1,14$			; the right number of times
15$:					;here when we have bit in R0
	MOV	#0,DZ.TDR(R4)		;send out a character on this line
	BIC	R0,R5			;clear line bit
	BNE	11$			;if not all done, wait for next
	ADD	#4,CHKCHR+CKDV		;point to right vector
	$CKINT	R4,R4,<DZ.MSE!DZ.MAI!DZ.TIE>,<377>,<DZ.CLR>,16$ ;check output interrupts
	BCS	CKDZE			;if interrupt didn't occur, skip rest of test
	SUB	#4,CHKCHR+CKDV		;point to input vector again
	$CKINT	R4,R4,<DZ.MSE!DZ.MAI!DZ.RIE>,<377>,<DZ.CLR>,17$ ;check input interrupts
	BCS	CKDZE			;if interrupt didn't occur, skip rest of test
	JMP	CKDZ01			;go perform loopback check
16$:					;subroutine to cause output interrupt
	JSR	PC,21$			;clear DZ11
	MOV	(R5),(R1)		;set enables
	MOVB	R4,DZ.TCR(R1)		;enable the current line
	TST	(R1)			;check status
	BPL	.-2			;wait till bit comes up
	RTS	PC			;return to caller

17$:					;subroutine to generate input interrupt
	JSR	PC,16$			;clear DZ11 and get ready to output character
	MOV	R4,-(SP)		;save bit for line
	MOV	R4,-(SP)		;save counter
	CLR	R4			;line number
18$:
	ASR	(SP)			;shift out a bit
	BEQ	19$			;done, exit loop
	INC	R4			;count bit
	BR	18$			;and continue
19$:					;here with bit converted to line number
	BIS	#17400,R4		;code for highest speed + turn receiver on
	MOV	R4,DZ.LPR(R1)		;set speed
	MOV	#377,DZ.TDR(R1)		;send a character out
	CLR	DZ.TCR(R1)		;disable further output
	TST	(SP)+			;clean up stack
	MOV	#700,R4			;timer
20$:	SOB	R4,20$			;wait appropriate time
	MOV	(SP)+,R4		;restore bit
	RTS	PC			;return to caller

21$:					;subroutine to clear DZ11 and wait
	MOV	#DZ.CLR,(R1)		;clear DZ11
	TST	(R1)			;check for completion
	BNE	.-2			;loop till done
	RTS	PC			;return to caller


CKDZ01:					;here to do data loopback check
	MOV	#CKDZTR,R5		;point to character tables
	MOV	#10,R2			;get count of lines to load
11$:					;loop to load parameters
	DEC	R2			;decrement count
	MOV	R2,R1			;copy into parameter data register
	BMI	12$			;if negative, exit loop
	ADD	#DZ.RON!DZ.SPD!DZ.CL8,R1 ;add bits to line number
	MOV	R1,DZ.LPR(R4)		;and set parameters for the line
	CLR	40(R5)			;clear error table entry
	CLR	20(R5)			;initialize output character
	CLR	(R5)+			;and input character
	BR	11$			;and continue looping
12$:					;here when line parameters and initial conditions set
	MOV	#DZ.MSE!DZ.MAI,(R4)	;start DZ11 going
	MOV	#377,DZ.TCR(R4)		;enable all lines
	MOV	#10,-(SP)		;get count
13$:					;loop to send and get characters
	TST	(R4)			;check output status
	BPL	14$			;if not ready, branch
	JSR	PC,16$			;else, output next character
	CLR	R2			;reset timer
14$:					;here to test input
	BIT	#DZ..RI,(R4)		;any input ready?
	BEQ	15$			;no, branch
	JSR	PC,18$			;yes, check it
	CLR	R2			;reset timer
15$:					;here to see if time to quit
	TST	(SP)			;any more lines left to output to?
	BNE	13$			;yes, unconditionally loop back
	SOB	R2,13$			;NO, DECREMENT COUNT AND BRANCH
	TST	(SP)+			;clean up stack
	BR	CKDZ02			;go print errors, if any
16$:					;subroutine to send character
	MOV	(R4),R1			;get CSR contents
	SWAB	R1			;swap bytes
	BIC	#177770,R1		;and leave only line number
	MOV	R1,R3			;copy it
	ASL	R1			;shift left to become index into table
	ADD	#CKDZTX,R1		;make absolute address
	CMP	#400,(R1)		;have we sent last character?
	BNE	17$			;no, branch
	JSR	PC,22$			;yes, turn line number into a bit
	BIC	R3,DZ.TCR(R4)		;and turn of that line's transmit enable
	DEC	2(SP)			;one less line to worry about
	INC	(R1)			;and up character so we don't get here again
	RTS	PC
17$:					;here to send character
	MOV	(R1),DZ.TDR(R4)		;copy to output buffer
	INC	(R1)			;and increment for next time
	RTS	PC

18$:					;subroutine to receive character
	MOV	DZ.RBF(R4),R0		;get receive buffer
	MOV	R0,R1			;copy it for determining line
	SWAB	R1			;swap bytes
	BIC	#177770,R1		;and leave only line number
	MOV	R1,R3			;copy line number
	ASL	R1			;make into displacement in table
	ADD	#CKDZTR,R1		;and make absolute
	TST	R0			;check for valid data
	BMI	20$			;yes, branch
	MOV	R0,40(R1)		;no, copy error work into table
19$:	MOV	R3,DZ.LPR(R4)		;clear input enable
	MOV	#400,20(R1)		;and store final character for output
	RTS	PC
20$:					;here to check data character
	BIC	#177400,R0		;clear junk
	CMP	R0,0(R1)		;is it what we expected?
	BEQ	21$			;yes, branch
	MOVB	R0,1(R1)		;save what we got instead
	BR	19$			;and clear input
21$:					;here if character right
	INC	(R1)			;figure out next character
	RTS	PC

22$:					;subroutine to convert line number to bit
	MOV	#1,-(SP)		;initial bit value
	TST	R3			;check line number
	BEQ	24$			;if zero, we are done
23$:					;loop to shift bits
	ASL	(SP)			;shift bit left
	SOB	R3,23$			;until count exhausted
24$:					;here to put bit value in return reg
	MOV	(SP)+,R3		;copy into register and clean up stack
	RTS	PC

;Here to check for errors
;  if all OK on a line, will have 400 as expected receive character
;   or expected receive character will contain good in RH  and
;   bad received character in LH.
;   If the error was an error bit on receive, the
;   CKDZTE table entry will be non-zero.
CKDZ02:					;print error messages on appropriate lines
	MOV	#CKDZTR,R5		;point to beginning of table
11$:					;loop checking for errors
	CMP	R5,#CKDZTR+20		;have we checked all lines?
	BEQ	18$			;yes, exit
	CMP	(R5),#400			;check if all received OK
	BEQ	17$			;yes, continue looking
	TST	40(R5)			;no, error bit detected?
	BNE	13$			;yes, branch to report it
	JSR	PC,12$			;get line number into R0
	MOVB	(R5),R2			;get expected char
	MOVB	1(R5),R3		;get received char
	BIC	#177400,R2		;clear extra
	BIC	#177400,R3		; bits
	CKSERR	R2,R3,R0		;save good, bad and line as address
	CK11SC	<CKEPC!CKEGB!CKEDID>,<WRONG CHARACTER RECEIVED>;report error
	.ASCIZ	\Wrong character received\
	.EVEN
	BR	17$			;and advance to next line
12$:					;subroutine to get line number
	MOV	R5,R0			;copy address of entry
	SUB	#CKDZTR,R0		;make displacement into table
	ASR	R0			;make into line number
	RTS	PC
13$:					;here to check error bits
	BIT	#DZ.DOV,40(R5)		;overrun?
	BEQ	14$			;no, branch
	CK11SC	<CKEPC>,<RECEIVE OVERRUN>;type message
	.ASCIZ	\Receive overrun\
	.EVEN
14$:					;here to check for framing error
	BIT	#DZ..FE,40(R5)		;framing error?
	BEQ	15$			;no, branch
	CK11SC	<CKEPC>,<FRAMING ERROR>;report error
	.ASCIZ	\Framing error\
	.EVEN
15$:					;here to check for parity error
	BIT	#DZ..PE,40(R5)		;parity error?
	BEQ	16$			;no, branch
	CK11SC	<CKEPC>,<PARITY ERROR>;report error
	.ASCIZ	\Parity error\
	.EVEN
16$:					;here to print line number
	CK11SC	<CKENCL>,< ON LINE >
	.ASCIZ	\ on line \
	.EVEN
	JSR	PC,12$			;get line number
	JSR	PC,CKTOCT		;print as octal number
17$:					;here to advance to next line
	ADD	#2,R5			;advance table pointer
	BR	11$			;and go back
18$:					;here when done printing error messages
	JMP	CKDZE
.ENDC ;.IF NE CK..DZ
.IF NE CK..TE
.SBTTL		CHECK DTE20 HARDWARE
;
;	JSR	PC,CKTE11
CKTE11:
				; [1(17)]
.IIF DF,DTEBAD,MOV R1,DTEBAD	;SAVE DTE20 BASE ADR [1(26)]
	JSR	R5,CHKBIT	;CHECK DLYCNT IN DTE'S RAM
	177777			; SINCE WE CAN ACCESS ALL THE BITS
	ADD	#TE.STW-TE.DYC,R1 ;POINT TO STATUS REGISTER
.IIF DF,DTPSTA,MOV R1,DTPSTA	;SAVE THE POINTER TO STAT REG [1(26)]
	MOV	#TS.EEE,@R1	;ENABLE INTERRUPTS
	BIT	#TS.IEN,@R1	;DOES DTE AGREE?
	BNE	11$		;YEP
	CK11SC	<CKEPC!CKEDID>,<Setting TS.EEE didn't set TS.IEN>
	.ASCIZ	\Setting TS.EEE didn't set TS.IEN\
	.EVEN
11$:	MOV	#TS.RES,@R1	;NOW SEE IF IT WILL INTERRUPT US
	JSR	R5,CHKINL
	-1			;TIME DELAY COUNT
	MOV	#TS.DEI,@R1	;TRY TO MAKE IT GO AWAY
	BIT	#TS.IEN,@R1	;WHICH SHOULD TURN THIS OFF
	BEQ	12$		;OKAY
	CK11SC	<CKEPC!CKEDID>,<Setting TS.DEI didn't clear TS.IEN>
	.ASCIZ	\Setting TS.DEI didn't clear TS.IEN\
	.EVEN
12$:	BIT	#TS.RM,@R1	;WE SHOULD BE RESTRICTED
	BNE	13$		;WE ARE, FINE
	CK11SC	<CKEPC!CKEDID>,<DTE20 is not restricted>
	.ASCIZ	\DTE20 is not restricted\
13$:	MOV	#TS.RST,-(R1)	;REALLY INITIALIZE DTE20
.IIF DF,DTEDTO,MOV R3,DTEDTO	;SAVE PTR TO INTP VECTOR ADR [1(26)]
				;DTEDTO GLOBAL CELL IS
				; ALSO USED TO HOLD
				; DEPOSIT/EXAMINE TIMEOUTS
	RTS	PC
.ENDC ;.IF NE CK..TE
.IF NE CK..CR
.SBTTL		CHECK CR11 HARDWARE
;
;	JSR	PC,CKCR11
;
CKCR11:
	JSR	R5,CHKBIT		;CHECK HARDWARE BITS
	CR.EJT!CR.INE
	BIT	#CR.BSY,(R4)		;SEE IF BUSY (MAYBE POWER OFF)
	BEQ	11$			;BRANCH IF COMMAND CAN BE GIVEV
	CK11SC	0,< CR11 not Rdy>
	.ASCIZ	\ CR11 not Rdy\
	.EVEN
	MOV	#CR.LVL,CHKCHR+CKPI	;GIVE DEFAULT LEVEL
	RTS	PC
11$:	MOV	#CR.INE!CR.CFD,(R4)	;SET INT ENABLE AND READ
					; TO FORCE ANY KIND OF INT
	CLR	R0			;FOR TIMING OUT
12$:	BIT	#CR.ERR!CR.CDN,(R4)	;SEE IF AN INT CONDITION EXISTS
	BNE	13$			;IF NOT, THEN WAIT.
	SOB	R0,12$			;START TIMING OUT
	BIC	#CR.INE,(R4)		;DISABLE CR11 INT ENABLE
	CK11SC	<CKEPC!CKEDID>,<CR11 Timed Out>,<CR11 NOT RESPONDING>
	.ASCIZ	\CR11 Timed Out\
	.EVEN
	RTS	PC
13$:	JSR	R5,CHKINL		;FIND INT LEVEL
	-1				;FOR TIME-OUT LOOP
	BIC	#CR.INE,(R4)		;DISABLE INT FOR CR11
	RTS	PC
.ENDC ;.IF NE CK..CR
.IF NE CK..LP
.SBTTL		CHECK LP11 HARDWARE
;
;	JSR	PC,CKLP11
;
CKLP11:
	BIT	#LP.ERR,(R4)		;SEE IF DEV READY
	BEQ	11$				;BRANCH IF RDY
	CK11SC	<CKEMSG>,< LP11 #>
	.ASCIZ	\ LP11 #\
	.EVEN
	MOV	CKDEVN,R0			;DEV NUMBER
	JSR	PC,CKTOCT			;PRINT DEV NUM
	CK11SC	CKENCL,< Not ready.>
	.ASCIZ	\ Not ready.\
	.EVEN
11$:	JSR	R5,CHKBIT			;CHECK HDW BITS
	LP.INE
	$CKINT	,R4,<LP.INE>,<LP.DNE>
	RTS	PC
.ENDC ;.IF NE CK..LP
.IF NE CK..L2
.SBTTL		CHECK THE LP20 HARDWARE


CKL211:	BIT	#L2.ERR,(R4)		; IS THE DEVICE OK ?
	BEQ	11$			;  YES
	CK11SC	CKEMSG,< LP20 # >
	.ASCIZ	\ LP20 #\
	.EVEN
	MOV	CKDEVN,R0		; GET DEVICE NUMBER
	JSR	PC,CKTOCT		; OUTPUT IT
	CK11SC	CKENCL,< Not ready.>
	.ASCIZ	\ Not ready.\
	.EVEN
11$:	RTS	PC

.ENDC
.IF NE CK..PP
.SBTTL		CHECK PP11 HARDWARE
;
;	JSR	PC,CKPP11
;
CKPP11:	JSR	R5,CHKBIT
	PP.INE
	$CKINT	,R4,<PP.INE>,<PP.RDY>
	RTS	PC
.ENDC ;.IF NE CK..PP
.IF NE CK..PR
.SBTTL		CHECK PR11 HARDWARE

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKPR11
;
CKPR11:
	JSR	R5,CHKBIT		;CHECK HARDWARE BITS
	PR.INE
	CLR	R0			;FOR TIME OUT
	BIS	#PR..RE!PR.INE,(R4)	;TELL READER TO DO SOMETHING
					; TO FORCE ANY INTERRUPT COND
11$:	BIT	#PR.DNE!PR.ERR,(R4)	;SEE IF AN INT CONDITION IS THERE
	BNE	12$			;IF NOT, THEN WAIT FOR ONE.
	SOB	R0,11$			;TIME OUT TO CATCH NO RESPONSE
	CK11SC	<CKEDID!CKEPC>,<Timed Out>,<NO RESPONSE>
	.ASCIZ	\Timed Out\
	.EVEN
	BIC	#PR.INE,(R4)		;DISABLE INT ENABLE
	RTS	PC			;EXIT
12$:	JSR	R5,CHKINL		;FIND INT LEVEL
	-1				;FOR TIME-OUT
	BIC	#PR.INE,(R4)		;DISABLE INTS
	RTS	PC
.ENDC ;.IF NE CK..PR
.IF NE CK..RH
.SBTTL		CHECK RH11 HARDWARE

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKRH11
;
CKRH11:;BIS	#1,CHKRP+4+0	;GROSS KLUDGE TO PREVENT CHKDEV FROM
	RTS	PC		; FINDING WHAT LOOKS LIKE AN RP.
				; (THE DEVICE REGISTERS OVERLAP)

.ENDC ;.IF NE CK..RH
.IF NE CK..TC
.SBTTL		CHECK TC11 HARDWARE

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKTC11
;
CKTC11:
	JSR	R5,CHKBIT	;TEST FOLLOWING BITS
	TC.D17!TC.D16
	TST	(R1)+		;ADVANCE TO COMMAND REGISTER
	JSR	R5,CHKBIT		;TEST FOLLOWING BITS
	TC..MM!TC..DI!TC.REV!TC.US7!TC.INE!TC.A17!TC.A16
	TST	(R1)+		;ADVANCE TO WORD COUNT REG
	JSR	R5,CHKBIT	;TEST FOLLOWING BITS
	-1
	TST	(R1)+		;ADVANCE TO BUS ADDR REG
	JSR	R5,CHKBIT		;TEST THE FOLLOWING BITS
	-1
	TST	(R1)+		;ADVANCE TO DATA REGISTER
	JSR	R5,CHKBIT	;CHECK FOLLOWING BITS
	-1
	MOV	R4,R1		;SET UP ADR FOR INT CHK
	TST	(R1)+		;ADVANCE TO COMMAND REG
	MOV	R1,R2		;SET UP FOR INT CHK
	$CKINT	,,<TC.INE>,<TC.RDY>
	RTS	PC

.ENDC ;.IF NE CK..TC
.IF NE CK..TM
.SBTTL		CHECK TM11 HARDWARE

;CALL	MOV	#<VECTOR ADR>,R3
;	MOV	#<HDW ADR>,R4
;	MOV	#<HDW ADR>,R1
;	JSR	PC,CKTM11
;
CKTM11:	RTS	PC
.ENDC ;.IF NE CK..TM

;HERE ON A UNEXPECTED BUS TRAP
;
CKBUST:	CK11SC	<CKEDID!CKEPC>,<Trap from>
	.ASCIZ	\Trap from\
	.EVEN
	MOV	(SP),R0			;GET PC OF NEXT INST
	SUB	#2,R0			;MAKE PC WITHIN BAD INST
	JSR	PC,CKTBOC		;PRINT THE PC WHERE WE WERE DID IN
	CK11SC	<CKENCL!CKEFAT>,< to Adr 4>,<ILLEGAL BUS TRAP>,<S..NXM>
	.ASCIZ	\ to Adr 4\
	.EVEN
.SBTTL		CK11SC ROUTINE

;HERE ON ERROR IN CHK11
;
;AT HALT TIME R0 CONTAINS ADDRESS OF TRAP
;
CHKERR:					;here on error trap
	MOV	NXMVEC,-(SP)		;save NXM vector [3(47)]
	MOV	#2$,NXMVEC		;where to go if MM doesn't exist [3(47)]
	BIC	#CHKMMO,CHKFLG		;clear indicator [3(47)]
	BIT	#1,MM.SR0		;see if memory management on [3(47)]
	BEQ	3$			;skip if not [3(47)]
	BIS	#CHKMMO,CHKFLG		;remember it [3(47)]
3$:	CLR	MM.SR0			;turn it off [3(47)]
	BR	4$			;continue [3(47)]
2$:	ADD	#4,SP			;adjust stack [3(47)]
4$:	MOV	(SP)+,NXMVEC		;restore previous state [3(47)]
	MOV	R0,-(SP)
	MOV	2(SP),-(SP)		;GET ADDRESS OF
	SUB	#2,(SP)			; THE TRAP INSTRUCTION.
	BIT	#CKEDID,@(SP)		;PRINT DEVICE ID+REG MSG
	BEQ	11$			;BRANCH IF NOT
	BIS	#CKFERR,CHKFLG		;REMEMBER WE HAD AN ERROR
	JSR	PC,CKDIDT		;
11$:	BIT	#CKEPC,@(SP)		;TYPE PC MESSAGE?
	BEQ	12$			;NO, SEE IF SOMETHING ELSE
	CK11SC	0,<	 Error detected at PC>	;
	.ASCIZ	\	 Error detected at PC\
	.EVEN
	BIS	#CKFERR,CHKFLG		;REMEMBER WE HAD AN ERROR
	MOV	(SP),R0			;GET ADDRESS
	JSR	PC,CKTBOC		;PRINT SPACE AND ADDRESS
12$:	BIT	#CKEMSG,@(SP)		;PRINT INLINE ERROR MESSAGE
	BEQ	15$			;BRANCH IF NO
	BIT	#CKENCL,@(SP)		;SEE IF NO CRLF
	BNE	13$			;BRANCH IF NO CRLF
	JSR	PC,CKCRLF		;CR+LF
13$:	BIT	#CKEDID!CKEGB,@(SP)	;IF DEV ID OR GD BD GIVE SPACES FOR FORMAT
	BEQ	14$			;
	CK11SC	CKENCL,<		>
	.ASCIZ	\		\
	.EVEN
14$:	MOV	4(SP),R0			;GET ADDRESS OF MESSAGE
	JSR	PC,CKTTXT		;RETURN R0 POINTS TO LOC
					; FOLLOWING MESSAGE
	MOV	R0,4(SP)			;PUT RETURN PC ON STACK
15$:	BIT	#CKEMSE,@(SP)		;PRINT MSG AT END
	BEQ	18$			;BRANCH IF NOT
	BIT	#CKENCL,@(SP)		;SEE IF NO CRLF
	BNE	16$			;BRANCH IF NO CRLF
	JSR	PC,CKCRLF		;CR+LF
16$:	BIT	#CKEDID!CKEGB,@(SP)	;SEE IF CKEDID OR CKEGB SET, IF SO GIVE SPACES FOR FORMAT
	BEQ	17$			;BRANCH IF JUST TEXT
	CK11SC	CKENCL,<		>	;2 TAB
	.ASCIZ	\		\
	.EVEN
17$:	MOV	@4(SP),R0		;GET ADDRESS OF THE MESSAGE
	JSR	PC,CKTTXT		;PRINT THE MESSAGE
	ADD	#2,4(SP)			;MAKE RETURN PC
18$:	BIT	#CKEGB,@(SP)		;SEE IF GOOD BAD PRINT OUT
	BEQ	CHKER0			;BRANCH IF NOT THIS
	CK11SC	0,<		Adr/Reg =>
	.ASCIZ	\		Adr/Reg =\
	.EVEN
	MOV	10(SP),R0		;GET ADR OFF THE STACK
	BIT	#CKADPH,@(P)		;see if virtual [3(47)]
	BEQ	20$			;no, do it normally [3(47)]
	BIT	#CHKMMO,CHKFLG		;was memory management on? [3(47)]
	BEQ	20$			;no, old style address [3(47)]
	ROL	R0			;shift [3(47)]
	ROL	R0			; high order [3(47)]
	ROL	R0			;  three bits [3(47)]
	ROL	R0			;   to test [3(47)]
	BIC	#177770,R0		;which register [3(47)]
	ASL	R0			;word index [3(47)]
	ADD	#KPAR0,R0		;right PAR [3(47)]
	MOV	@R0,-(SP)		;get physical block [3(47)]
	MOV	12(SP),R0		;get address back [3(47)]
	BIC	#160000,R0		;make displacement in block [3(47)]
	CLR	CHKX			;clear extended digit [3(47)]
	CLC				;clear carry [3(47)]
	ROL	(SP)			;shift bits off end [3(47)]
	ROL	(SP)
	ROL	(SP)
	ROL	(SP)
	ADC	CHKX			;save high order unibus address bit [3(47)]
	ROL	CHKX			;make room for next bit [3(47)]
	ROL	(SP)			;get next extra bit [3(47)]
	ADC	CHKX			;save it as well [3(47)]
	ADD	R0,(SP)			;make real address (low 16 bits) [3(47)]
	CLC				;clean out carry [3(47)]
	ROL	CHKX			;make room for next bit [3(47)]
	ROL	(SP)			;get sign bit [3(47)]
	ADC	CHKX			;put into extension [3(47)]
	ROR	(SP)			;clear sign bit [3(47)]
	MOV	CHKX,R0			;get uppermost octal digit [3(47)]
	JSR	PC,CKTBOC		;print it [3(47)]
	MOV	(SP)+,R0		;get rest [3(47)]
	JSR	PC,CKTOCT		;print it too [3(47)]
	BR	25$			;continue [3(47)]
20$:					; [3(47)]
	JSR	PC,CKTBOC		;PRINT ADR
25$:					;%
	CK11SC	<CKENCL>,<  GD =>
	.ASCIZ	\  GD =\
	.EVEN
	MOV	14(SP),R0		;GET "GOOD"
	JSR	PC,CKTBOC		;PRINT IT
	CK11SC	<CKENCL>,<  BD =>
	.ASCIZ	\  BD =\
	.EVEN
	MOV	12(SP),R0		;PRINT BAD STUFF
	JSR	PC,CKTBOC		;PRINT BAD
	CK11SC	CKENCL,<  XOR =>
	.ASCIZ	\  XOR =\
	.EVEN
	MOV	14(SP),-(SP)		;GET GOOD
	XOR	R0,(SP)			;LEAVE ONLY QUESTIONABLE BITS
	MOV	(SP)+,R0			;PRINT THEM
	JSR	PC,CKTBOC		;
CHKER0:	BIT	#CKEFAT,@(SP)		;FATAL ERROR - HALT REQUIRED?
	BEQ	CHKER2			;BRANCH IN NOT FATAL
	BIS	#CKFERR,CHKFLG		;REMEMBER WE HAD AN ERROR
	CK11SC	0,<		Fatal Error>
	.ASCIZ	\		Fatal Error\
	.EVEN
	MOV	CKSPCD,R0		;PUT STOPCODE IN R0, IF 0 ITS NOT A STOPCODE TO BE DISPLAYED
	BEQ	CHKER3			;IF 0
	HALT				;STOP CODE IN R0, PRESS CONTINUE
					; GIVES ADR WE CAME FROM
CHKER3:	MOV	(SP)+,R0			;ADDRESS OF TRAP IN R0
	HALT				;FATAL ERROR - R0 CONTAINS ERROR ADDRESS
	JMP	BEGIN			;IF CONTINUE DO PROGRAM AGAIN.
CHKER2:	BIT	#CKEGB,@(SP)+		;SEE IF THERE WAS A GD-BD PRINT
	BNE	CHKER1			;IF YES, CLEAR STACK
	MOV	(SP)+,R0
	BR	CHKER9			;go exit [3(47)]
CHKER1:	MOV	(SP)+,R0
	MOV	(SP)+,4(SP)		;PC
	MOV	(SP)+,4(SP)		;PS
	TST	(SP)+			;CLEAN THE STACK
CHKER9:					;here to exit CHKERR [3(47)]
	BIT	#CHKMMO,CHKFLG		;was memory management on? [3(47)]
	BEQ	10$			;no, skip [3(47)]
	INC	MM.SR0			;yes, turn it back on [3(47)]
10$:					;dismiss trap [3(47)]
	RTI				;return

CHKX:	.WORD	0			;extension for address [3(47)]
CKSPCD:	.WORD	0			;CONTAINS STOPCODE ON FATAL ERROR
	CKDA=	0			;DEVICE ADDRESS OFFSET
	CKDV=	2			;DEVICE VECTOR OFFSET
	CKPI=	4			;DEVICE PI LEVEL OFFSET
	CKFLG=	6			;DEVICE FLAGS OFFSET
	CKSPC=	10			;SPECIAL CHAR OFFSET
CHKCHR:	.BLKW	1			;DEVICE ADDRESS
	.BLKW	1			;DEVICE VECTOR
	.BLKW	1			;DEVICE PI LEVEL
	.BLKW	1			;DEVICE FLAGS
					; B0-B5 = # OF DQ11 SPECIAL CHAR
					; B15 = INTERRUPTED ON SYNC
	.BLKW	4			;SPECIAL CHARACTERS

	CKVECT	KL,1,1			;DL11-A VECTOR SETUP
	CKVECT	CR,1,1			;CR11 VECTOR SETUP
	CKVECT	DH,2,<^D16>		;DH11 VECTOR SETUP
	CKVECT	DL,2,<^D16>		;DL11-E VECTOR SETUP
	CKVECT	DM,1,<^D16>		;DM11-BB VECTOR SETUP
	CKVECT	DN,1,<^D64>		;DN11 VECTOR SETUP
	CKVECT	DP,2,<^D32>		;DP11 VECTOR SETUP
	CKVECT	DQ,2,<^D16>		;DQ11 VECTOR SETUP
	CKVECT	DS,4,<^D16>		;DS11 VECTOR SETUP
	CKVECT	TE,1,1			;DTE20 VECTOR SETUP
	CKVECT	L2,1,2			;LP20 VECTOR SETUP
	CKVECT	LP,1,2			;LP11 VECTOR SETUP
	CKVECT	PP,1,1			;PP11 VECTOR SETUP
	CKVECT	PR,1,1			;PR11 VECTOR SETUP
	CKVECT	XY,1,1			;XY11 VECTOR SETUP
	CKVECT	P6,1,<^D16>		;PA611-P VECTOR SETUP
	CKVECT	R6,1,<^D16>		;PA611-R VECTOR SETUP
	CKVECT	TC,1,1			;TC11 VECTOR SETUP
	CKVECT	TM,1,1			;TM11 VECTOR SETUP
	CKVECT	RC,1,1			;RC11 VECTOR SETUP
	CKVECT	RF,1,1			;RF11 VECTOR SETUP
	CKVECT	RH,1,1			;RH11 (RJP04) VECTOR SETUP
	CKVECT	RP,1,1			;RP11-C VECTOR SETUP
	CKVECT	TA,1,1			;TA11 VECTOR SETUP
	CKVECT	RK,1,1			;RK11 VECTOR SETUP
	CKVECT	KP,1,1			;KW11-P VECTOR SETUP
	CKVECT	DJ,2,<^D16>		;DJ11 vector setup [1(14)]
	CKVECT	UP,2,<^D16>		;DUP11 vector setup [1(14)]
	CKVECT	MC,2,<^D16>		;DMC11 vector setup [1(14)]
	CKVECT	MD,2,3			;KMC11 VECTOR SETUP [1(33)]
	CKVECT	MH,2,3			;KMC11 FOR DUP [3(50)]
	CKVECT	ME,2,3			;KMC11 FOR DZ [3(50)]
	CKVECT	LK,2,1			;LK11-A vector setup [1(14)]
	CKVECT	DZ,2,<^D8>		;DZ11 vector setup [1(14)]
	CKVECT	DU,2,<^D16>		;DU11 vector setup [1(14)]

CKMG01:	.ASCIZ	\Mem Err\
CKMG02:	.ASCIZ	\Bit did not Clear\
CKMG03:	.ASCIZ	\Bit did not set\
CKMG04:	.ASCIZ	\Interrupt did not Occur\
CKMG05:	.ASCIZ	\Interrupted to Wrong Vector\
CKMG06:	.ASCIZ	\not found\
CKMG07:	.ASCIZ	\interrupted when not enabled\

	.EVEN
CKBLK:	.BLKB	400			;Buffer for DH11 and DZ11 tests
CKDZTR=CKBLK				;address of receive expected character table for DZ11
CKDZTX=CKDZTR+20				;address of next char to transmit
CKDZTE=CKDZTX+20				;address of error table

; PRINT SIZE OF PROGRAM.

	CHKEND=	.-2			;EQUALS LAST ADDRESS
.IF	DF,CHKFFA
CHKSIZ=<CHKFFA-2+3777>
.IF LT CHKSIZ
	CHKSIZ=<<CHKSIZ&77777>/4000>+20
.IFF
	CHKSIZ=CHKSIZ/4000
.ENDC
.PRINT CHKSIZ	;Size of program in octal K words.
.ENDC
	CHKFFA:				;FIRST FREE ADDRESS

.LIST ME
DEVEQ	MD,ME
DEVEQ	MD,MH
	.END	BEGIN
