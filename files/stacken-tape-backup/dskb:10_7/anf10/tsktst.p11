.SBTTL	DNTASK  28 MAR 79
.IF NE FT.TSK

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
;  OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1978,1979,1980,1981,1984,1988.
;ALL RIGHTS RESERVED.

;THIS MODULE IS USED TO TEST THE USER TASK INTERFACE
;IT CONSISTS OF 4 TASKS WHICH EXERCISE THE USER
;MACRO S IN VARIOUS WAYS TO INSURE THAT THE INTERFACE IS WORKING
;IT REQUIRES A CONSOLE TTY, A DH TTY LINE, AND DEFAULTS
;TO USING DH LINE 5 FOR AN RDA DEVICE IF THE DIAL MACRO IS BEING TESTED.
;THE USER SHOULD EXAMINE THE LISTING FOR MORE INFORMATION ON
;DNTASK MODULE.  EACH TASK MACRO IS CALLED AT LEAST ONCE BY THIS DIAGNOSTIC.
;THE TASKS RUN AT DIFFERENT PRIORITY LEVELS TO CHECK THE SCHEDULING 
;SCHEME.  A BRIEF SUMMARY FOLLOWS WHICH EXPLAINS BRIEFLY WHAT EACH
;TASK IS DOING.
;
;TK4 TASK ALLOWS INTERACTION WITH THE USER.  IT DEFAULTS TO RUN OFF DH
;LINE 4 WHICH MUST BE ASSEMBLED AS A TTY LINE WITH A DEFINED BAUD RATE.
;IT SIMULATES A NORMAL TTY LINE.  THE TASK INTERCEPTS AND PASSES THE
;CHARACTERS FROM THE KEYBOARD AND THE HOST.  ERRORS ARE OUTPUT ON THE
;CONSOLE TERMINAL.
;TO TRY THE DIAL MACRO TYPE A SIMPLE "?"
;WHEN THE TASK INTERPRETS THIS CHARACTER, IT EXPECTS THE NEXT
;RESPONSE TO BE ONE OF THREE THINGS:
;	(1)Y FOLLOWED BY A PHONE NUMBER AND CARRIAGE RETURN
;	(2)N EVENTUALLY FOLLOWED BY A CARRIAGE RETURN
;  OR   (3)A SIMPLE CARRIAGE RETURN
;IF A PHONE NUMBER IS GIVEN, THE TK4 TASK TELLS TASK TK3 TO CALL THE NUMBER.
;TK3 REPORTS THE DIAL STATUS TO THE DRIVER TTY LINE IF THE
;DIAL MACRO IS SUCCESSFUL AND THEN TERMINATES THE CALL. IF AN
;ERROR RETURN IS GIVEN BY THE DIAL MACRO, AN ERROR MESSAGE IS
;PRINTED OUT ON THE DRIVER TTY LINE.  WHEN THE DIAL LOGIC IS
;COMPLETE THE TK3 TASK SENDS A MESSAGE TO THE TK4 DRIVER TASK AND
;THE TK4 TASK RESUMES.  IT PRINTS A MESSAGE TO TELL THE USER TO
;TRY THE RESTART LOGIC IN THE TASK INTERFACE.  THE TK4 TASK
;THEN JUMPS BACK TO ITS BEGINNING ADDRESS.
;
;THE TK2 TASK PERFORMS A FEW EXTRA FUNCTIONS WHEN IT IS RESTARTED.
;IT PRINTS A MESSAGE ON THE CTY TO INDICATE IT WAS RESTARTED AND
;ALSO TRIES TO OPEN THE DRIVER TTY LINE WHICH THE TK4 TASK MODULE OWNS.
;IT CHECKS TO BE SURE THE DEVICE CAN NOT BE OWNED BY 2 TASKS
;SIMULTANEOUSLY.  IT THEN GOES TO ITS NORMAL STARTING LOGIC AND HIBERNATES 
;UNTIL IT RECEIVES A DATA MESSAGE OF 2 FROM TK4.  WHEN THE MESSAGE
;IS RECEIVED, TK2 TRIGGERS THE TIMER TASK TK1 AND THEN SLEEPS FOR 
;60 SECONDS.  THE TK1 MODULE GETS ACTIVATED IN THIS MANNER EVERY MINUTE.
;THE TK1 TASK REPORTS ON THE CTY THE 32 BIT UP TIME RETURNED BY THE TIMER MACRO
;AND THEN EXITS.
;THE TK3 MODULE IN ADDITION TO TRYING THE DIAL MACRO ALSO CHECKS
;THE GETBIT, SETBIT,AND CLRBIT MACROS.  IT DEFAULTS TO DH LINE 5
;AND CHECKS THAT THE LINE IS A DATASET LINE AND CONNECTED TO
;A HOST.

;THE FOLLOWING ENTRIES SHOULD BE IN THE CONFIGURATION FILE
;IN WHICH DNTASK IS TO BE ASSEMBLED:
;
;	TTYN=5	THIS NUMBER OF TTYS AND RDAS SETS DH LINE 5
;		TO BE THE FIRST RDA DEVICE AND DH LINE 4 TO BE A TTY LINE
;	RDAN=1
;	T4XS=2400.	;DEFINE BAUD RATE ON DRIVER TTY LINE
;	T4RS=150.	;DEF BAUD RATE ON DRIVER TTY LINE
;	D0DSL=1	;RDA LINE FOR DIAL MACRO NEEDS TO BE A DATA SET
;	D0XS=300.	;300 BAUD RATE
;	D0RS=300.
;	D0801=0		;AUTO DIALER 0 DN11  ASSIGNED TO D0DDB
;	DN11N=1		;NEED AUTO DIALER TO TRY DIAL MACRO
;	DRIVER=4	;THIS IS NOT NEEDED BUT IS NEEDED IF ANOTHER
;			DH LINE IS GOING TO BE USED TO DRIVE TK4
TSKGEN	TK4,TK4BEG,TK4RST,1,40
;THIS TASK IS THE CONTROLLING TASK WHICH DRIVES THE DIAGNOSTIC
;FROM DH LINE 4.  THE DH LINE NO CAN BE CHANGED BY SETTING
;THE PARAMETER DRIVER=X IN THE CONFIGURATION FILE.
;CHUNK LAYOUT 0-LINK TO NEXT CHUNK
;	2-BYTE COUNT OF NUMBER OF BYTES IN MESSAGE
;	4-BEGINNING OF DATA
CNKCT=2
CNKDAT=4
;
BUF:	.WORD	0	;CURRENT BUFFER POINTER
BUFMX:	.WORD	0	;MAX ADDRESS FOR DATA MINUS A WORD FOR CR IF NEEDED
DRIVEL:
.IIF NDF DRIVER,DRIVER=4
DRIVER
TK4ER0:	MOV	#TK4EM0,R2
	JMP	TK4EMD
TK4ER1: MOV	#TK4EM1,R2
	JMP	TK4EMD
TK4ER2:	MOV	#TK4EM2,R2
	JMP	TK4EMD
SLPTM:	.WORD	3
TK4BEG:
TK4RST:
	MOV	DRIVEL,R1	;SET DH LINE 
	OPEN	R1,PRINTER
	BMI	TK4ER0		;OPEN FAILED 
	OPEN	R1,KEYBOARD
	BMI	TK4ER1		;OPEN FAILED ON KEYBOARD
	MOV	CTINS,R3	;BYTE COUNT OF INSTRUCTION MESSAGE
	IMGPUT	R1,PRINTER,BLOCKING,R3,INSTR	;OUTPUT INSTR TO USER ON DH LINE
	BMI	TK4ER2		;FAILED REPORT ERROR AND TRAP
15$:	SLEEP	SLPTM		;SLEEP SO OTHER TASKS CAN START UP
	MOV	#2,R0
	SEND	TK2,R0		;SEND MESSAGE TO TK1 TASK SO IT WILL START TIMER TASK
	BMI	15$
	BR	31$
30$:	HIBER			;WAIT FOR INPUT
31$:	GET	R1,KEYBOARD,NONBLOCKING,R0
	BMI	50$		;NO INPUT YET FROM USER KB
	BIC	#^C177,R0	;CLEAR PARITY BIT FROM CHAR IF ANY
	CMPB	#'?,R0		;TERMINATE DIALOGUE WITH MONOTOR?
	BEQ	TK4DN0		;YES
	PUT	R1,KEYBOARD,NONBLOCKING,R0	;GIVE IT TO THE 10
	br	50$		;no need to echo by task put to kb
				; will echo if needed
35$:	PUT	R1,PRINTER,NONBLOCKING,R0	;ECHO IT ALSO ON KB
50$:	GET	R1,PRINTER,NONBLOCKING,R0	;ANY CHAR FROM HOST TO ECHO
	BMI	30$		;NO GO CHECK USER AT KB
	BR	35$		;YES ECHO IT TO THE USER 
;
;USER DONE SENDING INFO TO THE MONITOR 
;CHECK TO SEE IF HE WANTS TO TRY THE DIAL MACRO
TK4DN0:	CNKGET	R4	;GET A CHUNK FOR KB INPUT
	MOV	R4,BUFMX
	ADD	#CNKSIZ-1,BUFMX	;SET UP FINAL ADDRESS
	MOVB	#0,CNKCT(R4)	;ZERO BYTE COUNT
	MOV	R4,BUF		;SET UP DATA POINTER
	ADD	#CNKDAT,BUF
	MOV	MSG4CT,R2	;NO OF BYTES IN  MESSAGE
	IMGPUT	R1,PRINTER,BLOCKING,R2,TK4MS1	;OUTPUT MESSAGE TO USER
	GET	R1,KEYBOARD,BLOCKING,R0	;CHECK BLOCKING MODE
	BMI	TK4ER3		;SHOULD NEVER GET ERROR RETURN
	BR	20$	;ONLY USE BLOCKING FOR 1ST CHARACTER
17$:	HIBER
	GET	R1,KEYBOARD,NONBLOCKING,R0
	BMI	17$		;NO CHAR YET
20$:	BIC	#^C177,R0	;STRIP EXTRANEOUS BITS
21$:	MOVB	R0,@BUF		;STORE IN CHUNK BUFFER
	INC	BUF		;INCRE POINTER
	INCB	CNKCT(R4)	;CHUNK HAS BYTE COUNTER OF NO OF DATA BYTES
	PUT	R1,PRINTER,NONBLOCKING,R0
	CMP	#15,R0	;CHAR A CR?
	BEQ	25$		;YES
	CMP	BUF,BUFMX	;IS CHUNK FULL?
	BLO	17$		;NO GO BACK FOR MORE CHAR
	MOV	#15,R0
	BR	21$		;FORCE A CR AS LAST CHAR IN BUFFER
;DECODE INPUT FROM USER TO SEE IF HE WANTS TO TRY DIAL MACRO
;
25$:
	CMPB	#'N,CNKDAT(R4)	;DID HE KEY N TO SIGNIFY NO
	BEQ	TK4DN
	CMPB	#'Y,CNKDAT(R4)	;YES? PH NUMBER SHOULD FOLLOW
	BEQ	TK4DL		;START DIAL MODULE
	CMPB	#15,CNKDAT(R4)	;LONE CR DEFAULTS TO NO
	BEQ	TK4DN
	CNKFRE	R4		;GIVE CHUNK BACK TO 11
	MOV	MSG2CT,R2	;NO OF BYTES IN MESSAGE
	IMGPUT	R1,PRINTER,BLOCKING,R2,TK4MS2	;TELL HIM TO TYPE CORRECT INFO
	BR	TK4DN0		;GO BACK AND WAIT FOR ANSWER
TK4DN:	CNKFRE	R4		;GIVE CHUNK BACK TO 11
TK4DN1:	MOV	MSG3CT,R2
	IMGPUT	R1,PRINTER,BLOCKING,R2,TK4MS3	;MESSAGE TO TELL USER TO RESTART
	JMP	TK4BEG		;BEGIN ALL OVER
;DIALER LOGIC
;
TK4DL:	SEND 	TK3,R4		;SEND TASK ADDRESS OF CHUNK PHONE IS STORED IN
	RECEIVE	R0,BLOCKING	;WAIT FOR TASK TO SEND MESSAGE TO SIGNAL COMPLETEION
	CMP	#1,R0		;IS IT EXPECTED RESPONSE
	BEQ	TK4DN1		;YES CONTINUE WITH DIAG
	MOV	#TK4EM4,R2	;ADDRESS OF MESSAGE
TK4EMD:	MOV	CTYLIN,R1	;OUTPUT TO CTY
	JSR	PC,STROT
	JMP	TK4BEG
TK4ER3:	MOV	#TK4EM3,R2
	BR	TK4EMD
TK4EM0:	.ASCIZ	<15><12>/OPEN PRINTER FAILED/
TK4EM1:	.ASCIZ	<15><12>/OPEN KEYBOARD FAILED/
TK4EM2:	.ASCIZ	<15><12>/IMGPUT FAILED IN BLOCKING MODE/
TK4EM3:	.ASCIZ	<15><12>/GET KEYBOARD BLOCKING FAILED./
TK4EM4:	.ASCIZ	<15><12>/WRONG DATA RECEIVED./
.EVEN
;
MSG3CT:	.WORD	EM3-TK4MS3
TK4MS3:	.ASCII	<15><12>/YOU SHOULD RESTART THE NODE TO CHECK THAT THE FOLLOWING PRINTS ON THE CONSOLE:/<15><12>
	.ASCII	/TK2 TASK MODULE RESTARTING!/
EM3:
.EVEN
MSG2CT:	.WORD	EM2-TK4MS2
TK4MS2:.ASCII <15><12>/INCORRECT INPUT - TRY AGAIN./
EM2:
CTINS:	.WORD	EMS-INSTR
INSTR:	.ASCII	<15><12>/THIS TASK MODULE SHOULD SIMULATE A NORMAL TTY.  THE TASK ECHOES THE CHARACTERS TYPED/
	.ASCII	/ AND SENDS THEM TO THE MONITOR./<15><12>/IT WILL INTERCEPT THE DATA SENT BY THE MONITOR AND PRINT IT AT THE TERMINAL/
	.ASCII	<15><12>/EX. IF YOU TYPE SYS CR/<15><12>/THE STATUS OF THE SYSTEM SHOULD PRINT OUT./
	.ASCII	<15><12>/TO GET OUT OF THIS MODE AND TRY THE DIAL MACRO TYPE "?"./<15><12>
EMS:
MSG4CT:	.WORD	EM4-TK4MS1
TK4MS1:	.ASCII	<15><12>/IF YOU WANT TO TRY THE DIAL MACRO TYPE :/<15><12>/Y FOLLOWED DIRECTLY BY THE PHONE NUMBER AND A CR./
	.ASCII	<15><12>/OTHERWISE, TYPE N FOLLOWED BY CR, OR SIMPLY, CR./<15><12>
EM4:
.EVEN
;
;
	TSKGEN	TK1,TK1BEG,TK1RST,3,20
;
;THIS TASK EXERCISES THE TIMER MACRO,TRIGGER MACRO, AND THE EXIT MACRO
;THE TASK WRITES A MESSAGE ON THE CONSOLE REPORTING THE 32 BIT
;UPTIME RETURNED FROM  THE TIMER MACRO
;AND THEN EXITS
;
CTYLIN:	.WORD	-1	;CTY IS DESIGNATED VIA -1
TK1DAT:	.WORD	0	;32 BITS RETURNED VIA TIMER MACRO
	.WORD	0
TK1BEG:
TK1RST:	MOV	CTYLIN,R1	;CTY LINE NO
	MOV	#STRADR,R2	;ADDRESS OF STRING TO OUTPUT
	JSR	PC,STROT		;ROUTINE OUTPUTS STRING
	TIMER	TK1DAT
	MOV	TK1DAT,R0
	JSR	PC,TK13		;OUTPUT BIT PATTERN TO LINE R1
	MOV	TK1DAT+2,R0
	JSR	PC,TK13		;OUTPUT NEXT 16 BITS
	EXIT
TK13:	MOV	#-20,R2	;16 BITS PER WORD
TK133:	TST	R0		;TEST SIGN BIT
	BMI	TK131		;OUTPUT ZERO TO CONSOLE
	MOV	#'0,R3
TK134:	PUT	R1,PRINTER,BLOCKING,R3
	ASL	R0	;POSITION NEXT BIT TO LOOK AT
	INC	R2		;ARE WE DONE YET?
	BNE	TK133		;LOOP BACK FOR MORE
	RTS	PC		;RETURN TO CALLER
TK131:	MOV	#'1,R3
	BR	TK134		;OUTPUT 1 TO LINE R1
STRADR:	.BYTE	15,12
	.ASCIZ	/THE UPTIME IS: /
TSKGEN	TK2,TK2BEG,TK2RST,3,20
;ON START UP THIS TASK DOES A RECEIVE IN NONBLOCKING MODE AND
;HIBERS IF NOTHING HAS BEEN SENT.  IT WILL BE ACTIVATED WHEN 
;TK3 SENDS IT A "2" AS A DATA MESSAGE.  IT CHECKS TO BE
;SURE THE DATA IS CORRECT AND WILL TRIGGER THE TK1 TASK. IT WILL
;THEN GO TO SLEEP FOR 60 SECONDS. IT WILL CONTINUE TO LOOP
;SO THAT TK1 SHOULD BE EXECUTED ONCE PER MINUTE.  THE RESTART
;FEATURE IS TESTED IN THIS MODULE.  WHEN THE STATION IS RESTARTED
;THE TASK WILL PRINT THE FOLLOWING ON THE CONSOLE:
; "TK2 TASK MODULE RESTARTED"
;THIS STATEMENT WILL NOT BE PRINTED ON NORMAL START UP.
;
;
SIXY:	.WORD	60.*60.
TK2BEG:	RECEIVE	R3,NONBLOCKING	;WAIT TIL RECEIVE VALUE OF 2
	BPL	TK21		;CHAR RECEIVED GO CHECK IT
	HIBER			;WAIT FOR SOMETHING TO DO
	BR	TK2BEG
TK21:	CMP	#2,R3		;WAS IT 2?
	BNE	TK2ER1		;NO OUTPUT ERROR MESSAGE
TK22:	TRIGER	TK1		;START TIMER TASK
	SLEEP	SIXY
	BR	TK22		;LOOP
TK2RST:	MOV	#TK2ADR,R2	;OUTPUT RESTART MESSAGE
	MOV	CTYLIN,R1
	JSR	PC,STROT
	MOV	DRIVEL,R1	;TRY TO GET DEVICE ALREADY ASSIGNED
	OPEN	R1,PRINTER
	BMI	TK2BEG			;SHOULD GET ERROR AS ASSIGNED TO TK4
	MOV	#TK2EM2,R2
	MOV	CTYLIN,R1
	BR	TK23
TK2ER1:	MOV	#TK2EM1,R2
	MOV	CTYLIN,R1
TK23:	JSR	PC,STROT	;OUTPUT "RECEIVED RETURNED ERRONEOUS DATA"
	BR	TK2BEG
TK2ADR:	.BYTE	15,12
	.ASCIZ	/TK2 TASK MODULE RESTARTED/
TK2EM1:	.BYTE	15,12
	.ASCIZ	/RECEIVE RETURNED ERRONEOUS DATA/
TK2EM2:	.BYTE	15,12
	.ASCIZ	/OPEN ALLOWED TWO TASKS TO OWN SAME DEVICE/
;
;
;STROT	SUBROUTINE OUTPUTS STRING OF ASCII CHARACTERS
;	THE STRING MUST CONTAIN A NULL AS LAST CHAR
;	CALLING SEQUENCE
;	MOV	#DHLINE,R1	;R1 CONTAINS DHLINE TO OUTPUT TO
;	MOV	#STRADR,R2	;R2 HOLDS ADDRESS OF FIRST CHAR TO BE PRINTED
;	JSR	PC,STROT
;
;
;
STROT:	MOVB	(R2)+,R3
	BEQ	STROT1		;NULL TERMINATES OUTPUT
STROT2:	PUT	R1,PRINTER,NONBLOCKING,R3
	BPL	STROT
	INC	#0
	BR	STROT2
STROT1:	RTS	PC

TSKGEN	TK3,TK3BEG,TK3RST,2,40
;THIS TASK CHECKS THE GETBIT, CLRBIT, SETBIT AND DIAL MACROS
;IN ORDER TO EXERCISE THE DIAL MACRO, IT REQUIRES DH LINE 5
;TO BE ASSEMBLED AS AN RDA LINE.  THE OPERATOR HAS THE OPTION
;TO EXERCISE THE DIAL MACRO OR NOT.  THE GETBIT, SETBIT, AND
;CLRBIT MACROS WILL BE TESTED ON START UP USING LINE 5.
;THE DIAL MACRO WILL ONLY BE EXERCISED IF THE CONTROL TASK SENDS IT
;A PHONE NUMBER.
;
;
HTIM:	.WORD 20
DRTS=4	;RTS LINE ON DM11BB IS 4
DH5:	5	;DH LINE NO. ASSEMBLE DAS RDA LINE
TK3BEG:
TK3RST:
	HIBER	HTIM	;GIVE SYSTEM TIME TO START ITSELF
	MOV	DH5,R4	;TASK DEFAULTS TO LINE 5
	GETBIT	R4,R0	;GET RESULT IN R0
	BPL	10$
	JMP	TK3ER1	;ERROR RESULT ON GETBIT
10$:	TST	R0	;SEE IF IT IS CONNECTED
	BPL	TK30
	JMP	TK3MS1	;REPORT THAT IT IS NOT CONNECTED AND CONTINUE
TK30:	BIT	#1,R0	;SEE IF A LINE IS A DATASET
	BEQ	TK30A
	JMP	TK3MS2	;PRINT LINE IS A DTASET AND CONTINUE
TK30A:	BIT	#DRTS,R0	;DETERMINE RTS STATUS ON ENTRY
;			;SO AS TO LEAVE IT AS IT WAS
	BNE	TK31	;RTS IS ON SO DO CLR THEN SET
;RTS IS OFF SO DO SET THEN CLR
	MOV	#DRTS,R2	;SET UP MASK
	SETBIT	R4,R2,R2	;SET RTS ON DHLINE SPECIFIED IN R4
	BPL	20$
	JMP	TK3ER2	;ERR ON SETBIT!
20$:	BIT	#DRTS,R2
	BNE	30$
	JMP	TK3ER3	;DIDNT SET BIT PROPERLY
30$:	MOV	#DRTS,R2
	CLRBIT	R4,R2,R2	;SET BIT OFF AS IT WAS ON ENTRY
	BPL	25$
	JMP	TK3ER4	;ERROR ON RETURN FROM CLRBIT
25$:	BIT	#DRTS,R2
	BEQ	TK32
	JMP	TK3ER5	;DIDNT CLEAR BIT PROPERLY
;LEAVE RTS AS IS ON ENTRY  RTS IS ON SO CLR IT THEN SET IT
TK31:	MOV	#DRTS,R2
	CLRBIT	R4,R2,R2	;CLEAR RTS ON LINE SPECIFIED IN R4
	BMI	TK3ER4	;ERROR ON CLRBIT
	BIT	#DRTS,R2	;CHECK BIT CLEARED
	BNE	TK3ER5	;BIT NOT CLEARED
	MOV	#DRTS,R2	;SET BIT ON AGAIN
	SETBIT	R4,R2,R2
	BMI	TK3ER2	;SETBIT ERROR RETURN
	BIT	#DRTS,R2	;BE SURE IT WAS SET
	BEQ	TK3ER3	;BIT WASNT SET
;COMMON ENTRY TO SEE IF USER WANTS TO TEST DIAL LOGIC
TK32:
	RECEIVE	R0,BLOCKING	;WAIT FOR SOMETHING TO DO
	BMI	TK3ER6		;RECEIVE BLOCKING NOT WORKING PROPERLY
	MOV	DH5,R1		;HERE IF RECIEVE A DIAL REQUEST
	MOV	R0,R4		;SAVE CHUNK ADDRESS WHERE PHONE NO STORED
	ADD	#CNKDAT+1,R0	;POINT TO FIRST DIGIT IN PHONE NO
	GETBIT	R1,R2
	TST	R2
	BMI	TK3MS3		;OUTPUT LINE IS NOT CONNECTED MUST ASSIGN
				;LINE FOR DIAL TO WORK
	OPEN	R1,PRINTER,PUT
	BMI	TK3ER8		;PRINTER SIDE NOT AVAILABLE
	MOV	#2,R2		;INITIATE A CALL
	DIAL	R1,BLOCKING,R2,R0
	BMI	TK3ER9		;ERROR RETURN
	MOV	#1,R2
	DIAL	R1,BLOCKING,R2,DIALST	;GET DIAL STATUS IN LOC DIALST
	BMI	TK3ERA		;ERROR RETURN
	JSR	PC,STATXX	;OUTPUT STATUS TO CONSOLE
	MOV	#0,R2		;TERMINATE THE CALL
	MOV	DH5,R1
	DIAL 	R1,BLOCKING,R2
	RELEASE	R1,PRINTER,PUT
TK3XT:	CNKFRE	R4	;FREE CHUNK 
	MOV	#1,R0
	SEND	TK4,R0		;TELL TASK PHONE LOGIC DONE
	BR	TK32		;WAIT FOR ANOTHER CALL
DIALST:	.WORD	0
STATXX:	MOV	#DSTR,R2	;OUTPUT "DIAL STATUS IS "
	MOV	DRIVEL,R1
	JSR	PC,STROT
	MOV	DIALST,R0
	JSR	PC,TK13		;OUTPUT PATTERN
	RTS	PC
DSTR:	.BYTE	15,12
	.ASCIZ	/DIAL STATUS IS: /
	.EVEN
;ERROR MESSAGES TO CONSOLE 
;
TK3ER1:	MOV	#TK3EM1,R2
TK3ER:	MOV	CTYLIN,R1
TK33:	JSR	PC,STROT
	EXIT
TK3ER2:	MOV	#TK3EM2,R2
	BR	TK3ER
TK3ER3:	MOV	#TK3EM3,R2
	BR TK3ER
TK3ER4:	MOV	#TK3EM4,R2
	BR 	TK3ER
TK3ER5:	MOV	#TK3EM5,R2
	BR 	TK3ER
TK3ER6:	MOV	#TK3EM6,R2
	BR	TKMB
TK3ER8:	MOV	#TK3EM8,R2
	BR	TKMB
TK3ER9:	MOV	#TK3EM9,R2
	BR	TKMB
TK3ERA:	MOV	#TK3EMA,R2
	BR	TKMB
TK3MS1:	MOV	#TK3S1,R2
	MOV	DRIVEL,R1
	JSR	PC,STROT
	JMP	TK30
TK3MS2:	MOV	#TK3S2,R2
	MOV	DRIVEL,R1
	JSR	PC,STROT
	JMP	TK30A
TK3MS3:	MOV	#TK3S3,R2
TKMB:	MOV	DRIVEL,R1
	JSR	PC,STROT
	JMP	TK3XT
TK3EM1:	.BYTE	15,12
	.ASCIZ	/ERROR RETURN GETBIT/
TK3EM2:	.BYTE	15,12
	.ASCIZ	/ERROR RETURN SETBIT/
TK3EM3:	.BYTE	15,12
	.ASCIZ	/BIT NOT SET BY SETBIT MACRO/
TK3EM4:	.BYTE	15,12
	.ASCIZ	/ERROR RETURN CLRBIT/
TK3EM5:	.BYTE	15,12
	.ASCIZ	/BIT NOT CLEARED BY CLRBIT MACRO/
TK3EM6:	.BYTE	15,12
	.ASCIZ	/RECEIVE BLOCKING FAILED/
TK3EM8:	.BYTE	15,12
	.ASCIZ	/PRINTER PUT SIDE NOT AVAILABLE/
TK3EM9:	.BYTE	15,12
	.ASCIZ	/ERROR DIAL MACRO INITIATING A CALL/
TK3EMA:	.BYTE	15,12
	.ASCIZ	/ERROR DIAL MACRO STATUS CHECK/
TK3S1:	.BYTE	15,12
	.ASCIZ	/LINE NOT ASSIGNED/
TK3S2:	.BYTE	15,12
	.ASCIZ	/LINE ASSEMBLED AS A DATASET/
TK3S3:	.BYTE	15,12
	.ASCIZ	/LINE FOR DIAL MACRO UNASSIGNED/
	.EVEN
	.ENDC ;IF NE FT.TSK
