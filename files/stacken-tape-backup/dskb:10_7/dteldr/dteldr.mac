TITLE	DTELDR BOOTSTRAP/DUMP PDP-11 CONNECTED VIA DTE20
SUBTTL  E. SOCCI/EJW/SMM/WRS/JMF/STU/RCB  3 Nov 83

;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1972,1979,1980,1984,1986,1988.
;ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

	SEARCH	UUOSYM,MACTEN	;GET SYSTEM SYMBOLS
	.REQUIRE REL:HELPER	;NEED FOR /HELP SWITCH
	.CNTDT==:.POPJ##	;PREVENT UNDEFINED GLOBAL FROM .TOUTS

	.TEXT	|DTELDR/SSAVE=/ERR:5 REL:SCAN/SEARCH/INCLUD:(.TOUTS)/GO
|

;LOADING INSTRUCTIONS:
;.LOAD DTELDR

;TAKEN FROM BOOT11 %4A(44) ON 20-JUN-76

	SALL			;CLEAN LISTINGS

.EDTR==0	;DEC DEVELOPMENT
.MAJV==5	;MAJOR VERSION
.MINV==1	;MINOR VERSION
.EDIT==54	;EDIT NUMBER

%%DTLD==.EDTR*1B2+.MAJV*1B11+.MINV*1B17+.EDIT

	LOC	137
	%%DTLD
	TWOSEG 400000


COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1972,1988. ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO

;Revision
; 54	Establish protocol type NOBODY and use it as the default for reloads.
;
; Start of version 5A
;
; 53	Re-install two instructions that were removed in 51 or 52, in order to
;	make doorbells work correctly.
;
; 52	Don't check for input in the master DTE's console (usually known as the
;	CTY).
;
; 51	Prevent random garbage on OPR ttys when starting DTELDR.
;
; 50	Allow /PROTOCOL to be used with /INITIALIZE.
;
; 47	Add code so that DTELDR can run detached.  Use the QUEUE. UUO to write
;	to OPR instead of TTY if we are running detached.  Also add the /DETACH
;	switch.  This switch will cause DTELDR to detach when it goes into
;	automatic mode.
;
; 46	Add /PROTOCOL and /APROTOCOL switch.  Arguments are ANF, IBM, or
;	DECNET.  For /APROTOCOL args are fe:prottyp.  This will
;	indicate the type of protocol to run on the line (via .DTESU).  The
;	default	protocol is ANF.
;
; 45	Make all TTY I/O in DTELDR be redirectable, for future developments.
;	Remove edit 44.  TWOSEG DTELDR successfully.  DTELDR must be saved
;	shareably so that only low seg needs to lock.
;
; Start of version 5
;
; 44	Make DTELDR register itself as the line's user in PROGAm mode
;	by doing DTE. .DTESU (set user) function.
;
; 43	Twoseg DTELDR. This gives the monitor a few extra pages of EVM back.
;
; 42	Dteldr screws up when the load crossed mid-night.  It
;	times out too early...
;
; 41	Changed many of the error messages to print in lower case.
;
; 40	Dteldr now looks at ST%NDL in %CNSTS and does not reload
;	Front ends if it is set.
SUBTTL MACRO DEFINITIONS

	DEFINE	WARNC	(STRING,AC)<
	PUSHJ	P,WRNRTN
	SKIP	AC,[ASCIZ \STRING\]
	>

	DEFINE	TELL	(STRING)<
	PUSHJ	P,[MOVEI T1,[ASCIZ\ STRING\]
		   JRST TELLCX]
	>

	DEFINE	TELLCR	(STRING)<
	PUSHJ	P,[MOVEI T1,[ASCIZ\ STRING
\]
		   JRST TELLCX]
	>

	DEFINE	WARN	(STRING)<
	PUSHJ	P,WRNRTN
	JUMP	1,[ASCIZ\STRING\]
	>

	DEFINE	WARNCR	(STRING)<
	PUSHJ	P,WRNRTN
	JUMP	[ASCIZ \STRING\]
	>

	DEFINE	JWARN	(ADDR,STRING)<
	PUSHJ	P,WRNRTN
	JUMP	3,[ADDR,,[ASCIZ \STRING\]]
	>
	DEFINE	ERROR	(STRING)<
	PUSHJ	P,ERRRTN
	JUMP	[ASCIZ \STRING\]
>

	DEFINE	LERROR	(STRING,BIT,AUTO)<
	JRST	[WARNCR(STRING)
		 MOVE	T1,[BIT]
		IFNB <AUTO> <SKIPL ATOFLG>
		 JRST	RETRY
		 IFNB <AUTO> <JRST ERRXIT>]
	>

	DEFINE	ERRORC	(STRING,AC)<	;DISPLAYS UUO FAILURE, INCLUDING CODE
	PUSHJ	P,ERRRTN
	SKIP	AC,[ASCIZ \STRING\]
>

	DEFINE	USEROR	(STRING)<
	PUSHJ	P,ERRRTN
	JUMP	1,[ASCIZ \STRING\]
>

	OPDEF	RETURN	[POPJ	P,]
		.NODDT	RETURN
SUBTTL DEFINITIONS

;DTE DEVICE CODES

	DTE0==200
	DTE1==204
	DTE2==210
	DTE3==214

;DTE20 CONO BITS (NAMES FROM KL10 EFS CHAP 4.3)


	TO11DB==1B22		;TO -11 DOOR BELL
	CR11B==1B23		;CLEAR RELOAD -11 BUTTO0
	SR11B==1B24		;SET RELOAD -11 BUTTON
	CL11PT==1B26		;CLEAR -11 REQUESTING A 10 INTERRUPT BIT
	TO11ER==1B27		;TO -11 ERROR
	CLTO11==1B29		;CLEAR TO -11 NORMAL TERMINATION FLAG (TO11DN)
	CLTO10==1B30		;CLEAR TO -10 NORMAL TERMINATION FLAG (TO10DN)
	PILDEN==1B31		;ENABLE LOADING PIA
	PI0ENB==1B32		;PI0 ENABLE
	PIA==7B35		;PIA

;DTE20 CONI BITS 
	RM==1B20		;RESTRICTED MODE 11
	DEAD11==1B21		;11 POWER FAILURE
	TO11DB==1B22		;TO -11 DOORBELL PRESSED
	TO10DB==1B26		;TO -10 DOORBELL
	TO11ER==1B27		;ERROR OCCURRED DURING TO-11 XFER (CLEARED BY CLTO11)
	TO11DN==1B29		;TO -11 NORMAL TERMINATION
	TO10DN==1B30		;TO -10 NORMAL TERMINATION
	TO10ER==1B31		;TO -10 ERROR
	PI0ENB==1B32		;PI0 ENABLE
	PIA==7B35		;PIA


;DTE20 DATAO DEFINITIONS

	TO10IB==1B23		;"I" BIT, SAYS INTERRUPT 11 AFTER XFER
	TO10BC==7777B35		;TO-10 BYTE COUNT FIELD

	CLRDTE==CR11B+CL11PT+CLTO11+CLTO10 ;CLEAR OUT A DTE WITH CONO THESE BITS
;ERROR.SYS DEFINITIONS

	.DMERR==5		;DAEMON UUO CODE TO APPEND TO ERROR.SYS

	.ERRTR==3		;NUMBER OF RETRIES TO TRY

	.ERERL==31		;11 RELOAD ERROR CODE IN ERROR.SYS ENTRY

	.ERNUM==0		;CPU#,,DTE#
	  ER.MAS==1B0		;MASTER DTE BIT
	.ERSTS==1		;STATUS WORD
	  ER.LOG==1B0		;**DEPEND ON THIS BIT BEING RESERVED FOR
				;  TOPS20 - SAYS TO WRITE AN ERROR LOG
				;  ENTRY JUST FOR THE RELOAD (NO OTHER 
				;  ERRORS ENCOUNTERED
	  ER.DPF==1B2		;DUMP FAILED
	  ER.10E==1B3		;TO-10 ERROR DURING DUMP
	  ER.11E==1B4		;TO-11 ERROR PASSING BOOTSTRAP PROGRAM OVER
	  ER.RLF==1B6		;RELOAD FAILED
	  ER.NPF==1B7		;POWER FAIL FAILED TO COME UP
	  ER.PUF==1B8		;POWER FAIL FAILED TO CLEAR
	  ER.RMF==1B9		;ROM DID NOT SEND DOORBELL TO 10 AFTER IT STARTED
	  ER.BSF==1B10		;BOOT PROGRAM DIDN'T MAKE IT TO 11
	  ER.NRL==1B11 		;11 ROM NEVER CLEARED TO-11 DOORBELL
				;(TEMP BIT ASSIGNMENTS)
	  ER.DHG==1B12		;TO-10 BYTE XFER FOR DUMP HUNG
	  ER.ENF==1B13		;ENTER FAILURE FOR DUMP FILE
	  ER.OPE==1B14		;OPEN FAILURE FOR DUMP OUTPUT DEVICE
	  ER.OUF==1B15		;OUTPUT FAILURE FOR DUMP FILE
	  ER.TT1==1B16		;TO-11 BYTE XFER TIMED OUT
	  ER.PTF==1B17		;PATH. UUO TO READ FILE SPEC FAILED.
	  ER.RTC==7B35		;RETRY COUNT
	.ERFNM==2		;FILE NAME POINTER WORD
	.ERSIZ==3		;SIZE OF FILE NAME STRING

	.ERLEN==^D20	;ALLOW 100 CHAR STRING

;RELOAD CONDITION PARAMETERS
DT.LSB==3B34		;RELOAD STATE FIELD
	.DTLCR==0	;COMPLETE RELOAD
	.DTLRD==1	;RELOAD, KL10 ASSUMED DOWN
	.DTLRU==2	;RELOAD, KL10 ASSUMED UP
	.DTLDQ==3	;RELOAD, ASK DIALOG QUESTIONS

;PARAMETERS
	DTEBSZ==200*10	;8 DISK BLOCK BUFFER
IFG DTEBSZ*2-TO10BC,<PRINTX BUFFER SIZE TOO BIG FOR DTE DATAO>
	DTEMAX==3	;MAXIMUM DTE NUMBER TO LOOK AT ON AUTO RELOADS
	CPUMAX==5	;MAXIMUM CPU NUMBER TO LOOK AT ON AUTO RELOADS
	INDEV==1	;INPUT CHANNEL
	INMODE==17	;INPUT FROM INDEV
	OUTDEV==2	;OUTPUT FOR DUMP
	OUMODE==17	;OUTPUT FROM OUTDEV
	TTY==3		;TTY IO CHANNEL FOR /TALK SWITCH
	MPX==4		;MPX CHANNEL USED TO LOG ALL TTYS
	TTX==5		;USED WHEN MANUALLY LOADING FRONT ENDS
	WATIME==^D20	;SECONDS TO "HIBER" WHEN IN AUTO MODE.
	JPERDA==^D24*^D60*^D60*^D1000 ;JIFFYS PER DAY

	PDSIZ==50	;SIZE OF PUSH DOWN LIST

	ONES11==177777	;=ALL ONES AS FAR AS THE 11 CAN SEE
	TXTLEN==^D150/5	;-11S SHOULDN'T SEND US MORE THAN THIS

;DEFINITIONS FOR DAEMON ERROR-LOGGING CALLS

;FILE SPEC BLOCK FOR ERROR LOGGING (USED TO REPORT LOAD/DUMP FILES)
	ERFSFN==0		;FILE NAME
	ERFSEX==1		;EXTENSION
	ERFSDV==2		;DEVICE
	ERFSXX==3		;PATH. BITS
	ERFSPN==4		;PPN
	ERFSSF==5		;SFD #1
	ERFSLN==ERFSSF+6	;LENGTH OF A FILE-SPEC BLOCK

;DEVCHR BIT DEFINITIONS
	DEVPTR==200,,0	;PAPER TAPE READER
;AC'S
	F=0		;FLAGS
	 F.MOPN==1B0	;ON WHEN MPX CHANNEL IS OPEN
	 F.CTYP==1B1	;ON WHEN LAST CHAR. TYPED IN TALK MODE WAS CR
	 F.TOPN==1B2	;ON WHEN MANUAL RELOAD HAS THE DL11 TTY OPEN
	 F.FTYP==1B3	;SET IF A FILENAME HAS BEEN TYPED
	T1=1		;SCRATCHED IN SUBROUTINES
	T2=2
	T3=3
	T4=4

	P1=5		;PRESERVED IN SUBROUTINES
	P2=6
	P3=7
	P4=10

	DT=11		;POINTER TO DTB FOR CURRENT FE (SET BY COMMAND SCANNER
			; AND DTBALL, DTBSOM ROUTINES)
	BC=12		;BYTE COUNT OF DATA IN GROUP
	BA=13		;OUTPUT BYTE ADDRESS
	BYTE=14		;LAST -11 BYTE READ FROM FILE
	FB=15		;MOD 4 POSITION IN INPUT WORD
	RB=16		;RELOCATION FOR -11 BUFFER

	P=17		;CALL STACK

;DTBFLG DEFNS:
	DTFIGN==1B0	;IGNORE THE DTB ON AUTO RELOADS
	DTFNXS==1B1	;THIS CPU,,DTE PAIR DOESN'T EXIST
	DTFMST==1B2	;THIS IS MASTER DTE
	DTFTRB==1B3	;SET IF CAN'T ACCESS DL11 FOR IF THIS IS COMM FE
	DTFCTD==1B4	;SET IF DL11 IS CONNECTED TO MPX DEVICE
	DTFOPD==1B5	;SET IF WE HAVE SOME DATA FROM THE DL11 TO PRINT
	DTFCRR==1B6	;SET IF LAST CHARACTER FROM DL11 LINE WAS CR
	DTFNLS==1B7	;SET IF /AUTO DOESN'T PUT THIS DTB ON THE MPX CHANNEL
	;DESCRIPTION OF OUTPUT FROM MACX11/P GENERATED ASSEMBLY
	;THAT IS, WHAT INPUT SHOULD LOOK LIKE
	;APPROXIMATELY

;-----------------------------------------------------------------------
;[(0-1)/8-BIT BYTE#2/8-BIT BYTE #1,,(18-19)/8-BIT BYTE #4/8-BIT BYTE #3]
;-----------------------------------------------------------------------

;THE ABOVE IS SO-CALLED PACKED MODE.  IN IMAGE MODE, THEY APPEAR
;ONE BYTE PER WORD IN ASCENDING BYTE ORDER.

;	THE BYTES IN -11 ORDERING (IE, AFTER ABOVE UNTANGLING) ARE:
;		ANY NUMBER OF 0 BYTES (DISCARD)
;		CONSTANT 1
;		CONSTANT 0
;		BCL
;		BCU
;		AL
;		AU
;		BC-6 BYTES OF DATA IN ORDER STARTING WITH THE BYTE FOR A
;		C
;			WHERE BC=BCU*400+BCL	THE BYTE COUNT
;			      A =AU *400+AL	THE FIRST BYTE ADDRESS
;			      C =          	THE CHECKSUM
;	THE ABOVE CAN BE REPEATED INDEFINITELY.
;	THE LAST SUCH GROUP HAS BC=6 AND THE STARTING ADDRESS IS A.

;THE CHECKSUM IS A SIMPLE ADD OF THE BYTES STARTING WITH CONSTANT 1 AND
;INCLUDING THE CHECKSUM--THE RESULT IS 0 IN 8 BITS.
	SUBTTL	LOAD PROGRAM

USTART:	JFCL			;IN CASE SOMEONE TRIES CCL
	RESET			;WIPE OUT ALL IO
	MOVE	P,[IOWD PDSIZ,PDLST]
	MOVEI	F,0		;NO FLAGS YET
	PUSHJ	P,DTBINI	;FILL DTBS WITH AVAILABLE DATA
	SETZM	MPXCTD		;HAVE TO MANUALLY CLEAR THESE
	SETZM	MPXBUF		; SINCE THEY ONLY WANT TO BE CLEARED ONCE PER RESET
	OPEN	TTY,[EXP .IOASC,<SIXBIT\TTY\>,TTXIHD]
	 WARNCR	<Can't OPEN TTY, don't use /TALK>
	INBUF	TTY,0		;CREATE BUFFER FOR THIS CHANNEL, BUT WE WILL NOT
				; USE THEM FOR IO. INSTEAD, WE WILL USE THEM FOR
				; THE TTX CHANNEL WHICH IS OPENED AFTER DTELDR LOCKS
				; ITSELF IN MEMORY. TOPS-10 WILL GIVE US AN ADDRESS
				; CHECK IF IT HAS TO EXPAND MEMORY TO ALLOCATE BUFFERS.
	MOVE	T1,TTXIHD	;GET POINTER TO BUFFERS
	MOVEM	T1,TTXBUF	;SAVE FOR DTBGDL
	MOVEI	T1,REENTR	;OKAY TO ALLOW REENTER COMMAND NOW
	HRRM	T1,.JBREN##
	SETZM	ATOFLG		;CLEAR THE PERMANENT FLAG
	JRST	START		;GO START
REENTR:	SETZM	ATOFLG		;NO LONGER WANT TO BE IN AUTO MODE
STARTE:	CLRBFI			;CLEAR TTY INPUT IF ERROR
	MOVE	P,[IOWD PDSIZ,PDLST]
	SETSTS	TTY,.IOASC	;MAKE SURE ECHO IS BACK ON
	RELEASE	INDEV,		;CLEAN UP AFTER RELOAD/DUMP
	RELEASE	OUTDEV,
START:	PUSHJ	P,WTOFLS	;FLUSH OUT THE "WRITE TO OPERATOR" BUFFER
	PUSHJ	P,RLDCLR	;CLEANUP IF WE RELOADED SOMETHING
	SETZM	FWAZER		;CLEAR TEMPORARY STORAGE
	MOVE	T1,[FWAZER,,FWAZER+1]
	BLT	T1,LWAZER
	SETOM	FWAONE		;PRESET SWITCH ANSWERS TO -1
	MOVE	T1,[FWAONE,,FWAONE+1]
	BLT	T1,LWAONE
	SKIPE	ATOFLG		;JUST FINISHED AUTOMATIC RELOAD?
	JRST	START1		;YES, DON'T CLEAR PERMANENT DATABASE
	SETZM	FPDZER		;CLEAR THE FIRST "PERMANENT" WORD
	MOVE	T1,[XWD FPDZER,FPDZER+1] ;GET A BLT POINTER TO THE REST
	BLT	T1,LPDZER	;  AND CLEAR THE REST
START1:	MOVE	P,[IOWD	PDSIZ,PDLST]

	SKIPE	ATOFLG		;IF NOT DOING /AUTO, GET COMMAND, ELSE
	JRST	ATOWAT		;GO WAIT FOR A FRONT END THAT NEEDS RELOADING
	MOVE	T1,['DSKDSK']	;IN MANUAL MODE, USE DSK AS DEFAULT FOR
	MOVEM	T1,DEFDEV	; LOADING AND DUMPING DEFAULT DEVICES
	PUSHJ	P,GETCOM	;GO GET COMMAND
	SKIPL	A.TERM		;/TERMINATE?
	JRST	IGNORE		;YES
	SKIPL	A.INIT		;/INITIALIZE?
	JRST	STARTP		;YES
	SKIPL	A.RELD		;/RELOAD?
	JRST	RELOAD		;YES
	SKIPL	A.AUTO		;/AUTOMATIC?
	JRST	ATOWAT		;GO DO /AUTO FOR THE FIRST TIME. SET ATOFLG.
	SKIPL	A.TALK		;/TALK (NOT IN CONJUNCTION WITH /RELOAD OR /AUTO)
	JRST	TALK		;YES, DO TALK
	SKIPN	NUMSWT		;CATCH CASE OF FILE SPEC BUT NO SWITCHES
	TXNN	F,F.FTYP
	JRST	START		;EITHER SWITCH OR NO FILE SPEC, OKAY
	WARNCR	Each command needs at least one switch
	JRST	START
SUBTTL /AUTO PROCESSING

ATOWAT:	PUSHJ	P,ATOINI	;INITIALIZE IF WE HAVE TO
	MOVEI	DT,DTB00	;HAVE TO POINT AT SOME RANDOM DTB
ATOWT1:	PUSHJ	P,WTOFLS	;FLUSH THE WTO BUFFER
	SETZM	FWAZER		;FIRST ZERO THE TEMPORARY DATABASE
	MOVE	T1,[XWD FWAZER,FWAZER+1] ;GET A BLT POINTER TO THE REST
	BLT	T1,LWAZER	;  AND CLEAR IT ALL
	PUSHJ	P,ATOSRC	;SEE IF THERE'S A FE TO RELOAD.
	PUSHJ	P,DTBCHK	;SEE IF WE WOKE UP DUE TO TTY ACTIVITY
	PUSHJ	P,DTBTIM	;SERVICE ACTIVE DL11S
	CLRBFI			;DISCARD TYPEAHEAD SO HIBER CAN HIBER
	SKIPN	T1,HIBTIM	;SEE IF ANYONE SPECIFIED A MINIMUM
	MOVEI	T1,WATIME*^D1000;  HIBER TIME. IF NO MINIMUM, USE THE DEFAULT
	CAIL	T1,WATIME*^D1000;IF THE SPECIFIED TIME WAS LONGER THAN
	MOVEI	T1,WATIME*^D1000;  THE DEFAULT, THEN USE THE DEFAULT.
	HRLI	T1,(HB.RIO!HB.RTC) ;ALWAYS WAKE UP IF ASYNC IO HAPPENS
	HIBER	T1,
	  ERROR HIBER failure
	JRST	ATOWT1		;WE WOKE UP, SEE WHAT NEEDS TO BE DONE

ATOSRC:	MOVE	T1,[%CNSTS]	;GET THE SYSTEM STATES
	GETTAB	T1,		;  WORD TO SEE IF RELOADS ARE ALLOWED
	  SETZ	T1,		;IF ERROR, DEFAULT TO "RELOAD"
	TRNE	T1,ST%NDL	;IF THE "NO RELOAD" BIT IS SET
	POPJ	P,		;  THEN DON'T CLOBBER THE DEBUGGER
	PUSHJ	P,DTBSOM	;LOOK AT DTES WE'RE INTERESTED IN
	MOVE	T1,[.DTEGS,,T2]
	MOVE	T2,DTBDSC(DT)	;GET STATUS OF THIS DTE
	DTE.	T1,
	  POPJ	P,		;TRY THE NEXT
	TLNN	T1,(DT.RLD)	;RELOAD THIS ONE?
	JRST	CPOPJ		;NO
	HLRZM	T2,A.CPU	;YES, SETUP CPU NUMBER AND
	HRRZM	T2,A.DTE	;DTE NUMBER
	MOVEM	DT,A.DTB	;THIS IS DTB FOR THIS COMMAND
	MOVEM	T2,DTUBLK	;IN CASE SOMEONE NEEDS THIS
	MOVE	T1,DMPFLG	;GET STATE OF DUMP, -1 MEANS DUMP
	MOVEM	T1,A.NDMP	;SET /NODUMP FLAG ACCORDINGLY
	PUSHJ	P,ATORLD	;AND GO DO AN AUTO RELOAD.
	PUSHJ	P,RLDCLR	;CLEANUP AFTER IT
	SETZM	A.DTB		;NO ACTIVE DTB NOW
	POPJ	P,		;WAIT FOR ANOTHER
ATOINI:	SKIPE	ATOFLG		;FIRST TIME THROUGH?
	RETURN			;NO, SKIP INITIAL STUFF
	SETOM	ATOFLG		;SET THE PERMANENT AUTO FLAG,
				; ONLY CLEARED WHEN PROGRAM IS MANUALLY
				; RESTARTED
	SKIPE	A.DETA		;SHOULD WE DETACH?
	 JRST	 ATOIN3		; NO, SKIP ALL THIS
	MOVSI	T1,-1		;GET ARG FOR ATTACH UUO
	ATTACH	T1,		;GOODBYE TTY
	 ERROR	 Can't detach DTELDR
	PUSHJ	P,WTOSET	;SET UP FOR DOING WTO'S
ATOIN3:	MOVE	T1,['SYSXPN']	;FOR AUTOMATIC MODE USE SYS AND XPN AS
	MOVEM	T1,DEFDEV	; DEVICE FOR LOADING AND DUMPING
	SETZM	DMPFLG		;ASSUME NO DUMP
	SKIPGE	A.NDMP		;DID HE TYPE /NODUMP?
	SETOM	DMPFLG		;NO, DO A DUMP
	SETOM	A.SEL		;INDICATE THAT SOURCE IS TO COME FROM
				; DEFAULT PLACE.
	SETOM	DTUBLK		;INDICATE THIS JOB IS TO
	MOVE	T1,[.DTERJ,,DTUBLK] ;BE THE AUTO RELOAD JOB
	DTE.	T1,		;DO
	  ERROR	DTE. UUO failed to set reload job
	PUSHJ	P,ATOMPX	;OPEN THE MPX DEVICE IF NECESSARY
ATOIN1:	PUSHJ	P,DTBSOM	;CHECK ALL THE DTBS WE'RE INTERESTED IN
	MOVE	T1,DTBFLG(DT)	;GET DTB FLAG BITS
	TXNN	T1,DTFNLS	;IF /NOLISTEN WAS TYPED,
	TXNE	T1,DTFMST!DTFCTD ; OR IF MASTER OR ALREADY CONNECTED,
	POPJ	P,		; THEN NO NEED TO CONNECT DL11 TTY
	PUSHJ	P,DTBSDL	;TRY TO SET PARAMETERS FOR THAT TTY LINE
	DMOVE	T1,[EXP T2,<.CNCCN,,MPX>]
	HRRZ	T3,DTBUDX(DT)	;NEED UDX
	JUMPE	T3,CPOPJ	;CAN'T CONNECT IF NO UDX
	CNECT.	T1,		;TRY TO CONNECT DL11 TTY
	  JRST	ATOIN2		;SIGH
	AOS	MPXCTD		;NOTE THAT AT LEAST ONE DEVICE IS CONNECTED
	MOVX	T1,DTFCTD	;OKAY TO REMEMBER IT'S CONNECTED
	IORM	T1,DTBFLG(DT)
	MOVE	T1,[2,,T2]	;TURN OFF ECHOING ON DL11 LINES
	HRRZ	T2,DTBUDX(DT)	;GET UDX FOR DL11
	MOVX	T3,IO.SUP!.IOPIM ;ALSO USE IMAGE MODE SO WE CAN SEE PROMPTS
	CLRST.	T1,		;POOF
	  JWARN	TYPFEC,<Couldn't turn off echoing from >
	POPJ	P,

ATOIN2:	WARN	<Cannot open DL11 TTY from >
	PJRST	TYPFEC		;PRINT WHICH ONE
ATOMPX:	TXNE	F,F.MOPN	;HAVE WE OPENED THE MPX DEVICE YET?
	POPJ	P,		;YES, NO NEED TO DO IT NOW
	OPEN	MPX,[EXP UU.AIO!IO.SUP!.IOPIM,<SIXBIT\MPX\>,MPXIHD]
	  JWARN	.TCRLF##,<Cannot open MPX device (for CHK11 output)>
	SKIPE	T1,MPXBUF	;DID WE ALLOCATE BUFFERS BEFORE?
	JRST	ATOMP1		;YES, REUSE THEM
	INBUF	MPX,		;BUILD BUFFERS
	MOVE	T1,MPXIHD	;GET VIRGIN POINTER TO THEM
	MOVEM	T1,MPXBUF	;SAVE FOR REUSE
ATOMP1:	MOVEM	T1,MPXIHD	;HERE WHEN REUSING BUFFERS, POINT HEADER TO THEM
	TXO	F,F.MOPN	;DON'T HAVE TO TRY THAT AGAIN
	PUSHJ	P,DTBALL	;WE COULD HAVE GOTTEN HERE WITH DTFCTD BITS SET
	MOVX	T1,DTFCTD	; SO CLEAR THEM ALL
	ANDCAM	T1,DTBFLG(DT)
	POPJ	P,
SUBTTL /RELOAD

RELOAD:	SKIPL	A.AUTO		;DID HE TYPE /AUTO?
	USEROR	Cannot use /AUTOMATIC with /RELOAD
	SKIPL	A.TERM		;OR /TERMINATE?
	USEROR	Cannot use /TERMINATE with /RELOAD
	SKIPL	A.INIT		;DID HE TYPE /INITIALIZE?
	USEROR	Cannot use /INITIALIZE with /RELOAD
	PUSHJ	P,ATORLD	;RELOAD FRONT END
	JRST	START		;RESTART


;HERE ON /AUTO TO BYPASS SYNTAX CHECKING

ATORLD:	PUSHJ	P,SETCOD	;SETUP I/O CODES AND OTHER STUFF
	PUSHJ	P,DTECLR	;TELL DTESER TO CLEAN UP THE -10'S DATABASE.
	MOVSI	T1,(ER.RLF+ER.DPF) ;ASSUME DUMP AND RELOAD FAILED - IF
				; THEY SUCCEED, TURN OFF THE BITS
	IORM	T1,ERRWRD
	MOVE	T1,[ATORL1,,JSTRLD] ;SET RETRY AND FAIL ROUTINES
	PUSHJ	P,SETRTY	; TO USE DURING DUMPING
ATORL1:	PUSHJ	P,STRROM	;START ROM
	PUSHJ	P,DODUMP	;DO A DUMP, IF NECESSARY
	JRST	JSTRL0		;DON'T START ROM UP AGAIN
JSTRLD:	PUSHJ	P,STRROM	;START ROM
JSTRL0:	MOVE	T1,[JSTRLD,,ERRXIT] ;CHANGE ROUTINES FOR RELOAD
	PUSHJ	P,SETRTY
JSTRL1:	SKIPL	T1,A.SEL	;/SELECT:SOMETHING?
	JRST	[CAIN	T1,10
		 JRST	FROM10
		 CAIN	T1,11
		 JRST	FROM11
		RETURN]		;NOT SUPPOSED TO HAPPEN


;HERE IF NO /SELECT. IF MASTER, GET RELOAD PROG FROM THE 11
; IF NOT MASTER, GET IT FROM THE 10

	SKIPN	MASTER		;IS THE SPECIFIED FRONT END THE MASTER?
	JRST	FROM10		;NO, GET THE CODE FROM THE 10 VIA DTE
	;...			;YES, FALL INTO FROM11
	;...
FROM11:	SKIPN	DEV		;MAKE SURE NO FILESPEC WAS TYPED
	SKIPE	NAME
	USEROR	Cannot specify filespec if /SELECT:11 used
	SKIPN	EXT
	SKIPE	DIRECT
	USEROR	Cannot specify filespec if /SELECT:11 used
	TELLCR	Loading from -11 disk.
	MOVE	P1,[POINT 18,RP4PRG]	;POINT TO RP04 PORT CONTENTION CODE
	PUSHJ	P,GETROM	;GET 11 ROM WORD FROM MONITOR
	TRNN	T1,DT.RP4	;IS CODE TO BE GOTTEN FROM RP04?
	MOVE	P1,[POINT 18,DTAPRG] ;NO, DECTAPE OR FLOPPY.
	HRRM	T1,(P1)		;PUT ROM WORD INTO PROGRAM.
	MOVE	T1,P1		;GET ARG IN T1
	PUSHJ	P,MSGT11	;SEND IT TO ROM WHICH WILL START PROGRAM
	MOVEI	T1,TO11DB	;WAKE UP THE LITTLE PROGRAM
	XCT	DTECNO		;DONG
	PJRST	LDDONW		;GO WAIT FOR PRIMARY PROTOCOL AND
				;  LOG THE RELOAD
FROM10:	SKIPL	A.SWIT		;DID HE TRY TO SPECIFY SWITCHES?
	WARNCR	<Reload source is -10, /SWITCH ignored>
	MOVEI	T1,INMODE	;SHOULD BE DUMP MODE (BECAUSE WE'RE LOCKED)
	SKIPN	T2,DEV		;GET DEVICE
	HLLZ	T2,DEFDEV	;GET PRESENT DEFAULT (DSK OR SYS)
	SETZ	T3,		;NO BUFFERS IN DUMP MODE
	OPEN	INDEV,T1	;OPEN FILE
	  USEROR	Can't OPEN the input device
	SETZM	INHDR+2		;SIMULATE OLD BUFFERED MODE IO

	SKIPN	T1,NAME		;GET THE FILE NAME
	JRST	[MOVE T1,A.CPU	;IF NO FILE NAME SPECIFIED, BUILD
		 IMULI T1,100	; DEFAULT FROM CPU AND
		 ADD T1,A.DTE	; DTE NUMBER
		 ADD T1,['DTEL00']
		 JRST .+1]	;BACK TO MAIN FLOW, T1 := FILENAME
	SKIPN	T2,EXT		;GET EXTENSION
	JRST	[MOVSI T2,'BIN'	;IF NO EXTENSION GIVEN, DEFAULT IS "BIN"
		 SKIPL A.A11	; UNLESS "/A11" SPECIFIED IN WHICH CASE
		 MOVSI T2,'A11'	; WE MUST USE "A11" AS AN EXT
		 JRST .+1]	;BACK TO MAIN FLOW WITH T2 := EXT
	TRZ	T2,-1		;CLEAR NULL FLAG
RELOOK:	MOVEI	T3,0		;CLEAR WORD
	MOVE	T4,DIRECT	;GET DIRECTORY
	LOOKUP	INDEV,T1	;LOOKUP FILE
	  JRST	[SKIPE	EXT	;CHECK ARGUMENT
		 TLZ	T2,-1	;ALL DONE IF NON-ZERO
		 TLZE	T2,-1	;SEE IF DEFAULT EXT AND NO DOT
		 JUMPE	T2,RELOOK  ;YES--IF NOT FOUND TRY NULL EXT.
		 USEROR	LOOKUP failed
		]

;NOW STORE THE FILENAME & DEVICE FOR DAEMON TO READ.
	MOVEM	T1,LODFIL+ERFSFN;STORE THE FILENAME WE JUST GOT
	HLLZM	T2,LODFIL+ERFSEX;  AND THE EXTENSION
	MOVEI	T1,INDEV	;GET OUR INPUT CHANNEL NUMBER
	MOVEM	T1,LODFIL+ERFSDV;  AND STORE IT IN THE PATH. BLOCK
	MOVE	T1,[XWD ERFSLN-ERFSDV,LODFIL+ERFSDV]
	PATH.	T1,		;LET PATH WRITE DEVICE, PPN & SFDS
	  WARNCR Path UUO failed to read loadfile parameters.

;NOW TELL THE USER WHAT FILE WE'RE LOADING
	TELL	<Loading from file: >
	MOVEI	T1,LODFIL		;GET THE ADDRESS OF THE SPEC
	PUSHJ	P,TYPFIL		;  AND TYPE IT OUT
	PUSHJ	P,.TCRLF##		;CLOSE OFF THE LINE.

STRTLD:	MOVE	T1,[POINT 18,DTEPRG] ;POINT TO DTE LOADER
	PUSHJ	P,MSGT11	;AND GIVE TO ROM

	MOVEI	T1,TO11DB	;RING DOORBELL TO START IT UP
	XCT	DTECNO
	SETOM	FB		;PRESET FILE BYTE POSITION

	;..
	;..
LDGRPL:	SKIPL	A.A11		;A11 FORMAT?
	JRST	LDA11		;YES, GO DO A11 FILE LOAD
	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF at start of file group
	JUMPE	BYTE,LDGRPL	;LOOP THROUGH NULLS
	CAIN	BYTE,377	;DISCARD DELETES
	JRST	LDGRPL		; ..
	CAIE	BYTE,1		;VERIFY CONSTANT 1
	ERROR	File group has junk instead of constant 1
	MOVEM	BYTE,CHKSUM	;INITIALIZE CHECKSUM
	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF after file constant 1
	SKIPE	BYTE		;VERIFY CONSTANT 0
	ERROR	file group has junk instead of constant 0
	PUSHJ	P,GETWRD	;GET WORD
	SKIPGE	A.IMAG		;SEE IF IMAGE MODE
	SKIPE	T1		;NO--SEE IF 0
	JRST	LDGRP2		;OK
	WARNCR	File zero byte count--trying again in /IMAGE mode
	SETZM	A.IMAG		;SET /IMAGE SWITCH
	USETI	INDEV,1		;RESTART AT BLOCK 1
	SETZM	INHDR+2		;FORCE REREAD
	JRST	LDGRPL		;LOOKUP FILE AND TRY AGAIN

LDGRP2:	MOVEI	BC,-6(T1)	;GET DATA BYTE COUNT
	SKIPGE	BC		;SEE IF ACCEPTABLE
	ERROR	File group byte count less than 6
	PUSHJ	P,GETWRD	;GET WORD
	MOVEM	T1,ADDRES	;SAVE AS STARTING ADDRESS
	JUMPE	BC,THATAL	;JUMP IF THIS IS THE START BLOCK
;LOOP GETTING DATA AND TRANSFERRING IT TO THE -11
;MESSAGES TRANSFERRED TO THE -11HAVE A 4 BYTE HEADER CONTAINING
;THE BYTE COUNT OF THE THE DATA AFTER THE HEADER AND THE ADDRESS OF
;WHERE TO PUT IT IN THE SECOND 2 BYTES. WHEN THE START BLOCK IS
;READ FROM THE FILE, A 4 BYTE MESSAGE CONSISTING OF 2 ZERO BYTES
;AND 2 BYTES OF START ADDRESS.

DTEMML==DTEBSZ*4-4		;MAXIMUM LOAD MESSAGE WE CAN TRANSFER

LDDATL:	MOVEI	P1,DTEMML	;DO AN LONG A PIECE AS WE CAN
	CAIGE	BC,DTEMML	;MAKE SURE FILE HAS THAT MANY
	MOVE	P1,BC		;NO--USE WHAT IS IN FILE
	MOVE	P2,P1		;SET COUNT FOR FETCH

	MOVE	P3,[POINT 8,DTEBUF] ;START TO ASSEMBLE LOAD MESSAGE
	IDPB	P1,P3		;STORE LOW BYTE OF BYTE COUNT
	ROT	P1,-^D8		;POSITION TO HIGH BYTE
	IDPB	P1,P3		;AND STORE THAT TOO
	ROT	P1,^D8		;RESTORE BYTE COUNT
	MOVE	T1,ADDRES	;GET ADDRESS TO STORE DATA
	IDPB	T1,P3		;AGAIN, LOW BYTE
	LSH	T1,-^D8	
	IDPB	T1,P3		;AND HIGH BYTE

;LOOP FILLING BUFFER FOR ONE TRANSFER TO THE -11
LDDATM:	PUSHJ	P,GETBYT	;GET BYTE
	  ERROR	EOF during data in file group
	IDPB	BYTE,P3		;STORE DATA BYTE
	SOJG	P2,LDDATM	;LOOP FILLING BUFFER
LDDOIT:	MOVE	T1,[POINT 8,DTEBUF] ; POINT TO MESSAGE AGAIN
	PUSHJ	P,MSGT11	;AND SEND TO 11
LDIDIT:	MOVEI	T1,DTEMML	;ADVANCE ADDRESS
	ADDM	T1,ADDRES	; ..
	SUBI	BC,DTEMML	;DECREMENT COUNT TO GO
	JUMPG	BC,LDDATL	;LOOP UNTIL DONE

	PUSHJ	P,GETCHK	;VERIFY CHECKSUM
	JRST	LDGRPL		;GO LOOK FOR NEXT GROUP
;A11 FILE PROCESSOR - THIS IS FOR DIAGNOSTICS

LDA11:	SETZM	CHKSUM		;ZERO CHECKSUM
	PUSHJ	P,A11BYT	;GET FIRST CHAR OF LINE
	  ERROR	Unexpected EOF
	CAIN	BYTE,";"	;IS THIS A COMMENT LINE?
	JRST	A11SKP		;YES, GO SKIP THIS LINE
	CAIE	BYTE,"E"	;NOT COMMENT, IS IT AN E?
	  ERROR	Bad A11 format
	PUSHJ	P,A11BYT	;GET WHAT SHOULD BE A BLANK
	  ERROR	Unexpected EOF
	CAIE	BYTE," "	;IS IT A BLANK?
	  ERROR	Bad A11 format

;THIS IS A REAL DATA LINE

	PUSHJ	P,A11WRD	;GET -11 WORD COUNT
	MOVE	P1,T1		;SAVE
	PUSHJ	P,A11WRD	;NOW GET ADDRESS
	MOVEM	T1,ADDRES	;SAVE
	JUMPN	P1,LDA111	;JUMP IF NOT START BLOCK

;ZERO WORD COUNT SPECIFIES START BLOCK

	PUSHJ	P,A11WRD	;GET CHECKSUM
	MOVE	T1,CHKSUM	; FOR TEST
	TRNE	T1,177777	;IS 16-BIT CHECKSUM = 0?
	  ERROR	START BLOCK Checksum failure
	JRST	LDDONE		;YES, GO FINISH PROCESS
;NOT START BLOCK, SO GET BLOCK OF DATA AND SEND TO -11

LDA111:	LSH	P1,1		;DOUBLE WORD COUNT FOR BYTE COUNT
	MOVE	P3,[POINT 8,DTEBUF]
	IDPB	P1,P3
	ROT	P1,-^D8
	IDPB	P1,P3
	ROT	P1,^D8
	MOVE	T1,ADDRES
	IDPB	T1,P3
	LSH	T1,-^D8
	IDPB	T1,P3
	LSH	P1,-1		;MAKE P1 BE WORD COUNT AGAIN

LDA112:	PUSHJ	P,A11WRD	;GET -11 WORD FROM A11 FILE
	IDPB	T1,P3
	LSH	T1,-^D8
	IDPB	T1,P3
	SOJG	P1,LDA112	;LOOP WHILE THERE'S ANOTHER DATA WORD

;LINE COMPLETE NOW SEND TO -11 IF CHECKSUM IS OKAY

	PUSHJ	P,A11WRD	;GET CHECKSUM WORD
	MOVE	T1,CHKSUM	; FOR TEST
	TRNE	T1,177777	;IS 16-BIT CHECKSUM = 0?
	  ERROR	DATA Checksum failure
	MOVE	T1,[POINT 8,DTEBUF] ;OK,SETUP TO SEND TO -11
	PUSHJ	P,MSGT11	;SEND THE DATA BUFFER
	PUSHJ	P,A11BYT	;CLEAR <LF>
	  JFCL			;IGNORE THIS ONE AS WE'LL FIND IT LATER
	JRST	LDA11		;GO GET NEXT LINE OF DATA
THATAL:	PUSHJ	P,GETCHK	;VERIFY CHECKSUM
	MOVEI	T1,^D10		;TAPE SHOULD HAVE AT LEAST 10 TRAILING NULLS
SKPEND:	SOJL	T1,LDDONE	;IF 10 NULLS THERE, TAPE END IS OK
	PUSHJ	P,GETBYT	;GET NEXT BYTE
	  JRST	LDDONE		;EOF IS OK
	JUMPE	BYTE,SKPEND	;SKIP TRAILING NULLS
	ERROR	Junk after start group

LDDONE:	MOVE	P3,[POINT 8,DTEBUF,23] ;POINT TO LOW BYTE OF START ADDR
	SETZM	DTEBUF		;CLEAR DATA LENGTH TO MARK START MESSAGE
	SKIPGE	T1,A.STRT	;GET ADDRESS USER SUPPLIED IF ANY
	MOVE	T1,ADDRES	;GET STARTING ADDRESS FROM PROGRAM
	DPB	T1,P3		;STORE LOW BYTE
	LSH	T1,-^D8
	IDPB	T1,P3		;AND HIGH BYTE
	MOVE	T1,[POINT 8,DTEBUF]
	PUSHJ	P,MSGT11	;SEND TO -11
	CLOSE	INDEV,		;CLOSE INPUT FILE
	RELEAS	INDEV,		;RELEASE IT
	SKIPGE	T1,A.STRT	;DID USER SAY /LOAD OR /START?
	JRST	LDDON1		;NO, DON'T NEED TO TELL HIM START ADDRESS
	TRNN	T1,1		;DID HE SAY /LOAD?
	JRST	LDDON1		;NO, HE DOESN'T NEED START ADDRESS
	MOVE	T1,ADDRES	;DOES THE PROGRAM HAVE ONE?
	TRNE	T1,1		;ODD SAYS NONE
	JRST	LDDON1		;NO ADDRESS, CAN'T TELL HIM START
	MOVE	T2,T1		;PUT START ADDRESS IN A SAFE PLACE
	MOVEI	T1,[ASCIZ\" Start address is \]
	PUSHJ	P,.TSTRG##	;TYPE OUT BANNER
	MOVE	T1,T2		;GET BACK START ADDRESS
	PUSHJ	P,.TOCTW##	;PRINT IT
	PUSHJ	P,.TCRLF##	;PRINT A CRLF
LDDON1:	SKIPGE	T1,A.STRT	;DID WE START -11?
	MOVE	T1,ADDRES	;USER DIDN'T SPECIFY - GET PROGRAM'S
	TRNN	T1,1		;IF IT DIDN'T START, DON'T WAIT FOR IT

;HERE TO WAIT FOR THE FE TO COME UP AND THEN LOG RELOAD
LDDONW:	PUSHJ	P,DBWAIT	;WAIT FOR PROGRAM TO INITIALIZE
				;AND START PRIMARY PROTOCOL
	SKIPE	A.DTE		;IF THIS IS A NETWORK FRONT END,
	PJRST	ERRLOA		;  GO LOG THE LOAD AND RETURN
	MOVSI	T1,(ER.LOG)	;IF IT'S A CONSOLE-FRONT-END
	IORM	T1,ERRWRD	;  SET THE BIT SAYING WE LOADED IT
	PJRST	ERRLOG		;  AND LOG THE CFE RELOAD
	SUBTTL	LOADER SUBROUTINES

;ROUTINE TO GET AND VERIFY CHECKSUM

GETCHK:	PUSHJ	P,GETBYT	;GET CHECKSUM
	  ERROR	EOF found when looking for checksum
	MOVE	T1,CHKSUM	;GET RESULT
	TRNN	T1,377		;SEE IF OK
	RETURN			;YES
	ERROR	Checksum failure

;ROUTINE TO GET ONE -11 WORD INTO T1

GETWRD:	PUSHJ	P,GETBYT	;GET RH BYTE
	  ERROR	EOF during first byte of a word
	PUSH	P,BYTE		;SAVE AWAY
	PUSHJ	P,GETBYT	;GET LH BYTE
	  ERROR	EOF during second byte of a word
	MOVE	T1,BYTE		;MOVE TO ANSWER
	LSH	T1,8		;POSITION LH BYTE
	IOR	T1,(P)		;INCLUDE RH BYTE
	POP	P,(P)		;DISCARD SAVED BYTE
	RETURN

;ROUTINE TO GET ONE -11 WORD FROM AN A11 FILE TO T1

A11WRD:	SETZ	T1,		;CLEAR WORD
A11WR1:	PUSHJ	P,A11BYT	;GET NEXT BYTE
	  ERROR	Unexpected EOF
	CAIGE	BYTE,75		;IS CHARACTER VALID "ASCII-IZED"
	  RETURN		;NO, MUST BE DONE
	LSH	T1,6		;MOVE -11 WORD OVER FOR NEXT BITS
	TRZ	BYTE,100	;STRIP OFF "ASCII-IZING" BIT
	OR	T1,BYTE		;INSERT BITS
	JRST	A11WR1		;GO GET NEXT BITS

;ROUTINE TO SKIP A COMMENT LINE IN AN A11 FILE

A11SKP:	PUSHJ	P,A11BYT	;GET A CHARACTER
	  RETURN		;JUST RETURN ON EOF,WE'LL CATCH IT LATER
	CAIE	BYTE,12		;LOOK FOR A <LF>
	JRST	A11SKP		;NOT YET, LOOP
	RETURN			;GOT IT, RETURN
;ROUTINE TO GET ONE -11 BYTE FROM FILE INTO BYTE

GETBYT:	SKIPL	A.IMAG		;SEE IF /IMAGE MODE
	JRST	GETBYW		;YES--GET NEXT WORD
	AOS	FB		;ADVANCE FILE BYTE
	ANDI	FB,3		; (MOD 4)
	JUMPN	FB,GETBYC	;IF NOT NEW WORD, JUST FETCH BYTE
GETBYW:	SOSL	INHDR+2		;COUNT DOWN WORDS
	JRST	GETBYA		;STILL SOME THERE SO PROCEED
	MOVE	BYTE,[INLEN,,INBUF-1] ;FIXUP BUFFER HEADER
	HLRZM	BYTE,INHDR+2	;FIRST THE BYTE COUNT
	HRRZM	BYTE,INHDR+1	;AND THEN THE ADDRESS
	IN	INDEV,INIOWD	;GET NEXT BLOCK
	  JRST	GETBYW		;OK--GO TRY AGAIN
	STATZ	INDEV,740000	;SEE IF ERROR
	  ERROR	Input file read error
	RETURN

GETBYA:	AOS	INHDR+1		;ADVANCE TO NEXT WORD
	MOVE	BYTE,@INHDR+1	;GET WORD
	SKIPL	A.IMAG		;SEE IF /IMAGE
	JRST	GETBYI		;YES--GO GET IMAGE WORD
	TLNN	BYTE,(6B2)	;NO--TEST FOR NO JUNK
	TRNE	BYTE,6B20	; IN EITHER HALF
	ERROR	Junk bits in input file
GETBYC:	LDB	BYTE,PTRTAB(FB)	;GET BYTE
	JRST	GETBYR		;GO RETURN DATA
GETBYI:	TDNE	BYTE,[-1-377]	;SEE IF ANY JUNK
	ERROR	Junk in input file--may not be /IMAGE mode
GETBYR:	ADDM	BYTE,CHKSUM	;ACCUMULATE IN CHECKSUM
	AOS	(P)		;SKIP RETURN
RETRET:	RETURN

PTRTAB:	POINT	8,@INHDR+1,17
	POINT	8,@INHDR+1,9
	POINT	8,@INHDR+1,35
	POINT	8,@INHDR+1,27

INIOWD:	IOWD	200,INBUF
	0
;ROUTINE TO GET A BYTE FROM AN A11 FILE TO AC BYTE

A11BYT:	SOSG	INHDR+2		;DECREMENT COUNT
	  JRST	A11BY1		;COUNT NOT +, GET NEW BLOCK
	ILDB	BYTE,INHDR+1	;ELSE, GET NEXT BYTE
CPOPJ1:	AOS	(P)		;INCREMENT RETURN PC ON STACK
	RETURN			;AND MAKE SKIP RETURN

A11BY1:	MOVEI	BYTE,1200	;NUMBER OF 7-BIT BYTES IN NORMAL BLOCK
	MOVEM	BYTE,INHDR+2	;PUT INTO "HEADER"
	MOVE	BYTE,[POINT 8,INBUF] ;GET BYTE POINTER
	MOVEM	BYTE,INHDR+1	;ALSO PUT INTO "HEADER"
	IN	INDEV,INIOWD	;GET NEXT BUFFER
	  JRST	A11BYT		;ALL'S WELL
	STATZ	INDEV,740000	;CHECK FOR ERROR CONDITIONS
	  ERROR	Input file read error
	RETURN			;EOF IS NOT ERROR, JUST GIVE NON-SKP RET
	SUBTTL	/TERMINATE AND /INITIALIZE  PROCESSING

IGNORE:	MOVE	T1,NUMSWT	;MAKE SURE NO MORE SWITCHES
	SOJE	T1,.+2
	USEROR	Illegal switch or switches used with /TERMINATE
	PUSHJ	P,DTECLR	;CLEAR OUT DTE
	TELLCR	shut down
	JRST	START		;LOOP AROUND FOR MORE TO DO.


;HERE TO START PRIMARY PROTOCOL ON A DTE

STARTP:	MOVE	T1,NUMSWT	;MAKE SURE ONLY ONE SWITCH
	SKIPE	A.PROT		;/PROTOCOL ???
	 SOJ	 T1,		; YES, FAKE OUT /INITIALIZE
	SOJE	T1,.+2
	USEROR	Illegal switch or switches used with /INITIALIZE
	PUSHJ	P,STRDTE	;GO START PRIMARY PROTOCOL
	TELLCR	primary protocol started
	JRST	START		;VOILE'
	SUBTTL	DUMP ROUTINE

DODUMP:	SKIPL	A.NDMP		;DUMP?
	JRST	DMPEND		;SKIP THE DUMP
	MOVEI	T1,OUMODE	;SET OUTPUT MODE
	HRLZ	T2,DEFDEV	;GET PRESENT DEFAULT (DSK OR XPN)
	MOVSI	T3,OUTHDR	;POINT TO BUFFER HEADER
	OPEN	OUTDEV,T1	;OPEN FILE
	  LERROR <Can't OPEN the output device>,<ER.OPE>

	PUSHJ	P,FNDNAM	;FIND CORRECT NAME TO USE
	SETZB	T3,T4		;CLEAR OUT OTHER STUFF
	ENTER	OUTDEV,T1	;ENTER FILE
	  LERROR	<ENTER failed>,<ER.ENF>

;SAVE THE DUMP FILESPEC FOR DAEMON TO READ
	MOVEM	T1,DMPFIL+ERFSFN;REMEMBER THE FILE NAME
	HLLZM	T2,DMPFIL+ERFSEX;  AND THE EXTENSION
	MOVEI	T1,OUTDEV	;GET THE CHANNEL NUMBER OF THE FILE
	MOVEM	T1,DMPFIL+ERFSDV;  AND PUT IT WHERE PATH. CAN FIND IT
	MOVE	T1,[XWD ERFSLN-ERFSDV,DMPFIL+ERFSDV]
	PATH.	T1,		;READ THE DEV, PPN AND SFD'S
	  WARN	PATH. UUO to read dump filespec failed.

	TELL	<Dumping to file: >
	MOVEI	T1,DMPFIL	;GET THE ADDRESS OF THE DUMP FILE
	PUSHJ	P,TYPFIL	;  AND TYPE OUT THE NAME
	PUSHJ	P,.TCRLF##	;TYPE A CRLF TO MAKE THINGS NEAT
	SETZ	P4,		;CLEAR NUMBER OF 11 WORDS DUMPED

DMPLUP:	MOVE	T1,[POINT 18,DTEBUF]	;PUT DATA HERE, 18 BIT BYTES
	ADD	T1,BASEAD	;ADD EVM ADDRESS
	PUSHJ	P,SETTBP	;SETUP TO-10 BYTE POINTER TO THAT
	MOVEI	P3,DTEBSZ*2	;ASSUME WHOLE BUFFER
	MOVE	T1,DMPSIZ	;COPY NUMBER OF WORDS XFERRED SO FAR
	SUB	T1,P4		;GET # WORDS LEFT
	CAILE	T1,DTEBSZ*2	;IF # WORDS LEFT IS GREATER THAN BUFFER SIZE,
	JRST	DMPLP1		;NOTHING SPECIAL

;HERE ON LAST DATAO. BYTE COUNT MAY BE LESS THAN BUFFER SIZE, AND
; MUST GIVE THE 11 TO-10 DONE.

	MOVE	P3,T1		;GET THE LAST COUNT IN P3
	TLO	P3,(1B0)	;SET SIGN BIT SAYING ITS THE LAST BUFFER
DMPLP1:				; SIZE IS INTEGRAL NUMBER OF DISK BLOCKS)
	MOVEI	T1,CLTO10	;CLEAR TO-10 DONE
	XCT	DTECNO
	HRRZ	T1,P3		;GET 11 WORD COUNT AGAIN
	MOVNS	T1
	MOVE	T2,T1		;GET COPY OF NEGATIVE COUNT
	ASH	T2,-1		;DIVIDE BY 2
	HRLM	T2,DTEIOW	;SAVE AS DUMP IO WORD
	ANDI	T1,TO10BC	;JUST THE RIGHT BITS
	SKIPGE	P3		;LAST BUFFER?
	TRO	T1,TO10IB	;YES, SET TO-10 DONE FOR 11
	XCT	DTEDTO		;DO THE DATAO TO START XFER
	MOVEI	T1,TO10DN!TO10ER ;DONE OR ERROR
	MOVEI	T3,^D60000	;WAIT ONE MINUTE
	PUSHJ	P,SETIME
DMPLP2:	XCT	DTECSZ		;BITS SET YET?
	JRST	DMPLP3		;YES, SEE WHAT THEY ARE
	PUSHJ	P,ISTIME	;TIME OUT YET?
	  JRST	DMPLP2		;NO, KEEP GOING
	LERROR	<Timeout while waiting for dump transfer to complete>,<ER.DHG>

DMPLP3:	MOVEI	T1,TO10ER	;TO-10 ERROR?
	XCT	DTECSZ		;?
	LERROR	<To-10 error while dumping.>,<ER.10E>
	MOVSI	T1,400000	;FLAG BIT 0 TO DISTINGUISH DTELDR DUMPS
	IORM	T1,DTEBUF	;FROM REAL .BIN FILES
	OUT	OUTDEV,DTEIOW	;OUTPUT DUMP INFO TO FILE
	  JRST	DMPLP4		;OK
	LERROR <Output error for dump file >,<ER.OUF>
DMPLP4:	ADDI	P4,(P3)		;ADD TO NUMBER OF 11 WORDS XFERRED
	JUMPG	P3,DMPLUP	;GO XFER MORE, IF NOT FINISHED.
	CLOSE	OUTDEV,		;CLOSE THE FILE
	RELEAS	OUTDEV,

	PUSHJ	P,ERRDMP	;CALL THE ERROR-REPORTING ROUTINES
				;  TO LOG THE DUMP

;HERE AFTER DUMP IS FINISHED, OR NO DUMP IS DONE.

DMPEND:	MOVSI	T1,(ER.DPF)	;DUMP DIDN'T FAIL AFTER ALL, YOU PESSIMIST
	ANDCAM	T1,ERRWRD
	RETURN			;FINISHED.
;ROUTINE CALLED BY DODUMP TO FIND FILE NAME FOR DUMP FILE.
; CALL WITH OUTDEV I/O CHANNEL OPENED.  RETURN WITH
; FILE NAME IN T1, EXTENSION (BIN, B00, B01, . . . , B99)
; IN T2.  IDEA IS TO GENERATE NEW EXTENSIONS TO AVOID DELETING
; EXISTING DUMPS. IF ALL 100 BIN FILES EXIST, THE .B99
; FILE ALWAYS GETS THE NEW DUMP.

FNDNAM:	MOVE	T1,['DTED00']	;FILE NAME USED FOR DUMPS
	ADD	T1,A.DTE	;MAKE DEFAULT NAME INCLUDE DTE#
	MOVE	T2,A.CPU	;GET CPU NUMBER SPECIFIED
	LSH	T2,6		;MOVE TO NEXT TO LAST SIXBIT CHAR
	ADD	T1,T2		;DTEDXY, X=CPU#, Y=DTE#
	MOVSI	T2,'BIN'	;START WITH BIN
	MOVEI	T4,0		;USE JOB'S PPN
	LOOKUP	OUTDEV,T1	;LOOKUP BIN FILE
	  JRST	FNAMOK		;OK, GO CLOSE CHANNEL AND RETURN
	MOVSI	T2,'B00'	;ALREADY EXISTS, START WITH B00
	SETZB	T3,T4

FNDNLP:	LOOKUP	OUTDEV,T1	;B?? EXIST?
	  JRST	FNAMOK		;NO, USE IT
	TRZ	T2,-1		;CLEAR OUT JUNK
	MOVSI	T3,1		;YES, STEP TO NEXT
	ADDB	T2,T3		;EXTENSION
	TLZ	T3,7700		;CLEAR 2ND CHAR AND CHECK FOR
	CAME	T3,[SIXBIT/B :/];OVERFLOW
	JRST	FNDNLP		;EXTENSION STILL OK, CHECK NEW NAME
	ADD	T2,[100,,0]	;OVERFLOWED. CARRY INTO NEXT CHAR
	CAMN	T2,[SIXBIT/B::/];THAT OVERFLOW TOO?
	JRST	[MOVSI	T2,'B99';YES, USE B99 OVER
		 JRST	FNAMOK]	;
	TLZ	T2,77		;NO OVERFLOW. 3RD CHAR HAD CHANGED TO :,
	TLO	T2,'0'		;RESET IT TO 0
	JRST	FNDNLP		;GO LOOK UP

FNAMOK:	CLOSE	OUTDEV,		;CLOSE SO ENTER WILL NOT BE UPDATING
	RETURN
SUBTTL	TALK COMMAND

;THE TALK COMMAND IS USED TO CROSSPATCH THE TERMINAL CONTROLLING DTELDR
;TO THE DL11 LINE ASSOCIATED WITH A COMM. FRONT END (A DN87S, FOR EXAMPLE).
;EVERY CHARACTER TYPED ON THE CONTROLLING TERMINAL WILL NOT BE
;ECHOED BUT WILL BE TRANSMITTED OUT THE DL11 LINE. LIKEWISE, EVERY CHARACTER
;RECEIVED FROM THE DL11 WILL NOT BE ECHOED BUT WILL BE PRINTED ON THE
;CONTROLLING TERMINAL. THIS WAY A USER RUNNING DTELDR MAY TALK TO ODT OR
;DIAGNOSTICS RUNNING ON ANY COMMUNICATIONS FRONT END.

TALK:	SKIPGE	A.CPU		;IF WE GET HERE, BETTER HAVE A FRONT END IN MIND
	USEROR	Front end must be specified for /TALK
	PUSHJ	P,TLKTTY	;PUT CONTROLLING TTY IN TALK MODE (NO ECHO)
	PUSHJ	P,DTBGDL	;GET DL11 TTY WE'RE TALKING TO
	PUSHJ	P,DTBSDL	;SET ALL TTY PARAMETERS
TALK1:	PUSHJ	P,DTBCHK	;PRINT ANY DATA FROM LINE
	PUSHJ	P,DTBTIM	;PRINT OUTPUT BUFFERS IF TIME TO
	PUSHJ	P,TLKCHK	;TRANSMIT ANY TYPEIN
	PUSHJ	P,HIBSEC	;WAIT A SEC
	JRST	TALK1		;DO SOME MORE
SUBTTL -11 HANDLER SUBROUTINES

SP.CR0==1			;SPECIFY CPU 0
.STCPU==14			;SET CPU


;ROUTINE TO COMPUTE DTE I/O CODES, GET INTO
; IOT MODE, LOCK AND SET CONTROL C INTERCEPT.

SETCOD:	MOVEI	T1,DTE0		;PLUS FIRST DEVICE CODE = DEVICE CODE
	LSH	T1,-2		;RIGHT JUSTIFY THE DEVICE CODE IN AC FOR DPB
	ADD	T1,A.DTE	;ADD IN DTE NUMBER

DEFINE X(A)<DPB	T1,[POINT 7,A,9]>	;SET DEVICE CODE MACRO

	X(DTECNO)
	X(DTEDTO)
	X(DTECNI)
	X(DTECSO)
	X(DTECSZ)

;NOW SETUP CONTROL C INTERCEPT, LOCK IN CORE, AND REMEMBER EVA

	MOVEI	T1,SP.CR0	;BIT FOR CPU0
	LSH	T1,@A.CPU	;POSITION FOR REQUESTED CPU
	HRLI	T1,.STCPU	;RUN ONLY ON THAT CPU
	SETUUO	T1,		;ASK FOR IT
	JFCL			;AND IGNORE A FAILURE

	MOVE	T1,[4,,EXITX]	;GET FIRST WORD OF .JBINT BLOCK
	MOVEM	T1,CCINT+.ERNPC	;INSTALL IT
	MOVEI	T1,ER.ICC	;GET BIT TO TRAP ^C'S
	MOVEM	T1,CCINT+.ERCLS	;INSTALL THAT TOO
	SETZM	CCINT+.EROPC	;CLEAR OLD PC
	MOVEI	T1,CCINT	;SET FOR
	HRRM	T1,.JBINT##	;  ^C TRAP

	MOVEI	T4,LK.LNP!LK.LLS ;REQUEST LOCK IN EVM (DONT BOTHER PHYSICALLY)
	LOCK	T4,		;NOW LOCK THAT LOW SEGMENT
	 JRST	[MOVEI T4,LK.LLS ;REQUEST LOCK IN PHYSICAL EVM THIS TIME
		LOCK T4,	;NAIL US!
		 ERRORC	LOCK Failure, T4	;GRRR.
		JRST .+1]	;SUCCESS, LOCKED SLIGHTLY DIFFERENT NOW.
	ANDI	T4,777		;JUST VIRTUAL PAGE NUMBER
	LSH	T4,^D9		;TURN INTO BASE ADDRESS
	MOVEM	T4,BASEAD	;STORE
	SETZB	T4,CCINTP	;KEEP TIMESHARING ON
	TRPSET	T4,		; BUT GIVE SELF IOT
	  ERROR	TRPSET failed

	PUSHJ	P,ISMAST	;IS THIS DTE THE MASTER?
	  JRST	.+2		;NO, LEAVE MASTER FLAG ZERO
	SETOM	MASTER		;YES, SET MASTER FLAG
	RETURN			;RETURN


;ROUTINE TO CLEANUP AFTER A DTE RELOAD. THIS UNDOES ALL THE EFFECT
;OF SETCOD AND DTBGDL

RLDCLR:	HLLZS	.JBINT##	;DON'T INTERCEPT CTRL/C
	MOVEI	T1,1		;UNLOCK US
	UNLOK.	T1,
	  JFCL			;BIG DEAL?
	MOVE	T1,[XWD .STCPU,-1] ;SET FOR RUNNABLE ON ALL CPU'S
	SETUUO	T1,		; SO IF A CPU DIES, WE DON'T
	 JFCL			;IGNORE ERROR
	JRSTF	@[DTBDDL]	;TURN OFF USER IO AND GO FREE THE DL11
;SUBROUTINE TO CLEAR THE DTE, START THE ROM UP, AND ENABLE PI0
; SO THAT BYTE XFERS CAN PROCEED.

STRROM:	PUSHJ	P,DTECLR	;CLEAR THE DTE
	PUSHJ	P,DTEPRB	;PRESS RELOAD BUTTON TO START THINGS UP
	MOVEI	T1,PILDEN!PI0ENB ;TELL DTE IT'S OKAY TO TRANSFER DATA
	XCT	DTECNO
	RETURN
;SUBROUTINE TO SEND A DATA MESSAGE TO -11. 
;THIS WILL:
;1)	SETUP BYTE POINT IN EPT SO DTE CAN ACCESS DATA
;2)	RING -11'S DOORBELL TO SAY WE'RE READY
;	[PDP-11 SHOULD TRANSFER MESSAGE AT THIS POINT]
;4)	WAIT FOR TO11DN TO SET
;5)	RETURN WITH DTE CLEARED
;THIS WILL ALSO CHECK FOR TRANSFER ERRORS
;CALL:
;T1/	BYTE POINTER TO MESSAGE TO SEND

MSGT11:	ADD	T1,BASEAD	;ADD EVM ADDRESS
	PUSHJ	P,SETEBP	;SET TO-11 BYTE POINTER
	MOVEI	T1,CLTO11	;CLEAR TO-11 DONE
	XCT	DTECNO		; . .
	MOVEI	T1,TO11DB	;RING DOORBELL
	XCT	DTECNO		;DONG
	MOVEI	T3,^D5000	;SET T2 TO 5000 MS FROM NOW
	PUSHJ	P,SETIME	; ACCOUNTING FOR MIDNITE
	MOVEI	T1,TO11DN!TO11ER;LOOK FOR TERMINATION OF SOME SORT

MSGT12:	XCT	DTECSZ
	JRST	MSGT13		;TERMINATION HAS ARRIVED
	PUSHJ	P,ISTIME	;IS IT TIME YET?
	  JRST	MSGT12		;NO, LOOP
	LERROR	<Timeout while doing To-11 byte transfer>,<ER.TT1>

MSGT13:	MOVEI	T1,TO11ER	;WAS IT ERROR?
	XCT	DTECSZ		;?
	LERROR	<To-11 error after To-11 byte transfer>,<ER.11E>
	MOVEI	T1,CLRDTE	;CLEAR OUT DTE
	XCT	DTECNO
	RETURN			;ALL DONE, PDP-11 HAS DATA
;SUBROUTINE CALLED TO WAIT FOR THE -11 TO INITIALIZE ITSELF AND SET THE TO10
;DOORBELL TO REQUEST ENTERING PRIMARY PROTOCOL. WHEN THE DOORBELL IS RUNG,
;DBWAIT TELLS THE MONITOR TO ENTER PRIMARY PROTOCOL THEN TELLS THE WORLD
;THAT THE -11 IS RUNNING.

DBWAIT:	SKIPE	A.TALK		;LET USER KNOW HE CAN TALK
	  JRST	[TELLCR	initializing
		 JRST DBWAI0]
	TELLCR	initializing in talk mode
	SKIPN	A.AUTO		;IF AUTOMATIC, THERE MAY BE ACCIDENTAL TYPEIN
	CLRBFI			; SO CLEAR IT
DBWAI0:	MOVEI	T3,^D180000	;WAIT THREE MINUTES
	PUSHJ	P,SETIME	;SET TIME TO STOP
	HLLZS	.JBINT##	;OKAY TO LET PEOPLE CTRL/C NOW
	PUSHJ	P,TLKTTY	;USE CONTROLLING TTY IN TALK MODE
	PUSHJ	P,DTBGDL	;ACCESS DL11 TTY IF IN MANUAL MODE
DBWAI1:	PUSHJ	P,HIBSEC	;WAIT FOR A SECOND OR SO
	PUSHJ	P,DTBCHK	;CHECK FOR DL11 TTY ACTIVITY
	PUSHJ	P,DTBTIM	;FLUSH BUFFERS IF IT'S TIME TO
	PUSHJ	P,TLKCHK	;TRANSMIT TYPEIN IF /TALK WAS USED
	MOVEI	T1,TO10DB	;NOW CHECK FOR TO-10 DOORBELL
	XCT	DTECSZ		;WAIT FOR DOORBELL TO SET
	JRST	DBWAI2		;IT HAS
	SKIPE	A.AUTO		;IF MANUAL RELOAD WITH /TALK,
	SKIPE	A.TALK		;THEN DON'T SECOND GUESS USER
	PUSHJ	P,ISTIME	;IS IT TIME YET?
	  JRST	DBWAI1		;NO, KEEP GOING FOR NOW
	ERROR	Timeout waiting for 11 program to start

DBWAI2:	PUSHJ	P,STRDTE	;START DTE DOING ITS PROTOCOL
	PUSHJ	P,.TCRLF##	;IN CASE CHK11 DOESN'T FINISH THE LINE
	TELLCR	started
	SKIPL	ATOFLG		;IF IN MANUAL MODE,
	PUSHJ	P,DTBDDL	;FREE DL LINE IF NOT ON MPX
	MOVSI	T1,(ER.RLF)	;SAY RELOAD WON
	ANDCAM	T1,ERRWRD	;CLEAR THE BIT
	RETURN			;ALL DONE. RETURN
SUBTTL	TALK ROUTINES (CONTROLLING TTY INPUT SIDE)

TLKTTY:	SKIPE	A.TALK		;IF /TALK WASN'T TYPED,
	POPJ	P,		;NOTHING TO DO
	SETSTS	TTY,IO.SUP!.IOASC ;TURN OFF ECHOING
	OUTCHR	[0]		;THIS PRODS SCNSER TO MAKE SETSTS TAKE EFFECT (HONEST!)
	POP	P,T1		;DON'T LET CALLER ESCAPE WITHOUT TURNING ECHO BACK ON
	PUSHJ	P,(T1)		;CALL CALLER
	SETSTS	TTY,.IOASC	;ALLOW ECHOING
	OUTCHR	[0]		;MAKE IT TAKE EFFECT
	POPJ	P,


;ROUTINE TO HANDLE ANY TYPEIN WHILE A FRONTEND IS INITIALIZING OR WHEN A
;TALK COMMAND IS IN EFFECT. NOTE THAT DATA IS READ BEFORE THE /TALK SWITCH
;IS CHECKED. THIS IS DONE BECAUSE OTHERWISE THE HIBERNATES IN TALK AND DBWAIT
;WILL NOT BLOCK IF TYPEIN IS AVAILABLE.

TLKCHK:	TXNN	F,F.TOPN	;IF NEITHER TTX CHANNEL
	SKIPE	MPXCTD		; OR MPX CHANNEL ARE IN USE,
	JRST	.+2
	POPJ	P,		;THEN SKIP LISTENING FROM TTY
	SKIPE	A.TALK		;IF WE'RE NOT "TALKING", THEN
	POPJ	P,		;  DON'T TRY TO READ FROM THE TTY
	INCHRS	T4		;ANY INPUT?
	  POPJ	P,		;NO, LOOK NO FURTHER
;	SKIPE	A.TALK		;TYPEIN HAD BETTER BE FOR TALK
;	JWARN	.TCRLF##,<Sorry, type ahead doesn't work while front ends are initializing>
	TXZE	F,F.CTYP	;WAS LAST CHARACTER CR?
	CAIE	T4,"J"&37	;YES, IS THIS A LF?
	JRST	TLKCH1		;NO TO EITHER
	POPJ	P,		;DISCARD LFS AFTER CR

TLKCH1:	DMOVE	T1,[EXP <3,,T2>,.TOOUC]
	HRRZ	T3,DTBUDX(DT)	;TRANSMIT IT TO THE TARGET DL11 LINE
	JUMPN	T3,TLKCH2	;ASSUMING THERE IS ONE
	WARNCR	No DL11 TTY on that FE!
	POPJ	P,		;CAN'T DO ANYTHING ELSE

TLKCH2:	TRMOP.	T1,		;TRANSMIT IT
	 WARNCR	Output to the DL11 TTY failed
	CAIN	T4,"M"&37	;WAS THAT A CARRIAGE RETURN?
	TXO	F,F.CTYP	;YES, DISCARD LF IF IT FOLLOWS (CONSIDER TAPE MODE)
	POPJ	P,
SUBTTL	DTB CONTROL ROUTINES

.DTEDL==21

;ROUTINE TO FILL DTE DATA BASE WITH AVAILABLE DATA. DATA PRESENTLY SET UP
;INCLUDES FLAGS FOR MASTER, NONEXISTANT, AND WHETHER OR NOT THE UDX
;FOR THE DL11 IS KNOWN. ALSO, IF THE UDX IS KNOWN, THAT IS STORED.

DTBINI:	PUSHJ	P,DTBALL	;LOOK AT ALL DTBS
	PUSHJ	P,DTBLSP	;SETUP LINE BUFFER
	PUSHJ	P,DTBLTG	;INITIALLY TAG ALL LINE BUFFERS
	SETZM	DTBFLG(DT)	;NOTHING TO IT RIGHT NOW
	MOVE	T1,[.DTEGS,,T2]
	MOVE	T2,DTBDSC(DT)
	DTE.	T1,		;GET DTE STATUS
	  JRST	DTBIN1		;ASSUME IT DOESN'T EXIST
	MOVX	T3,DTFMST	;SET MASTER BIT IF DTE IS A MASTER
	TLNE	T1,(DT.DTM)
	IORM	T3,DTBFLG(DT)	;IT IS
	MOVE	T1,[.DTEDL,,T2]	;GET UDX OF FE TTY OR CTY
	DTE.	T1,
	  JRST	DTBIN2		;THERE ISN'T ONE??
	MOVEM	T1,DTBUDX(DT)	;SAVE FOR RELOAD AND TALK MECHANISMS
	POPJ	P,		;ALL WE NEED TO DO

DTBIN1:	MOVX	T1,DTFNXS!DTFIGN
	IORM	T1,DTBFLG(DT)	;SAY IT DOESN'T EXIST AND THAT WE SHOULD IGNORE IT
	POPJ	P,

DTBIN2:	MOVX	T1,DTFTRB	;SAY WE WILL HAVE TROUBLE WITH THIS ONE
	IORM	T1,DTBFLG(DT)
	SETZM	DTBUDX(DT)	;AND SAY WE HAVE NO IDEA WHAT THE UDX IS
	POPJ	P,
;ROUTINE TO GRAB A DL11 LINE NOT ALREADY CONTROLLED BY THE MPX CHANNEL.
;THIS ROUTINE IS MEANT TO ALLOW US TO ACCESS DL11S ASSOCIATED WITH FRONT ENDS
;BEING MANUALLY RELOADED. CONCEPTUALLY IT MIGHT BE ATTRACTIVE TO PUT THE DL11
;ON THE MPX CHANNEL, BUT THAT WOULD MEAN COMM FRONT ENDS WOULD HAVE TO RELY
;ON MPX, ASYNCHRONOUS IO, AND THE PSI SYSTEM JUST TO GET LOADED! THIS MECHANISM
;REQUIRES ONLY A COUPLE STRANGE TRMOPS WORK. IMAGE MODE IS USED HERE (AND ON
;THE MPX CHANNEL) MAINLY TO PREVENT SEND MESSAGES FROM BEING SENT OUT TO
;THE DL11S SINCE THEY WOULD BE INTERPRETED AS COMMANDS IF THE -11 CODE
;RUNNING USED ITS CTY.

DTBGDL:	PUSHJ	P,DTBLSP	;RESET POINTER TO LINE BUFFER TO WIPE OUT POSSIBLE TAG
	MOVE	T1,DTBFLG(DT)	;GET FLAGS FOR THIS DTB
	TXNE	T1,DTFCTD!DTFMST ;IF DL11 TTY IS ALREADY CONNECTED
				; OR THIS IS THE MASTER (NO LINE TO LISTEN ON)
	POPJ	P,		; THEN NOTHING TO GET
	MOVX	T1,UU.AIO!IO.SUP!.IOPIM ;TRY TO ACCESS LINE IN IMAGE MODE
	HRRZ	T2,DTBUDX(DT)	;GET UDX OF DL11 LINE
	JUMPE	T2,CPOPJ	;IF THERE ISN'T ANY, NOT MUCH WE CAN DO
	MOVEM	T2,TTXIHD+.BFUDX ;CHEAT A BIT AND MAKE BUFFER HEADER LOOK LIKE MPX
	DEVNAM	T2,		;OPEN UUO NEEDS NAME
	  JWARN	.TCRLF##,Cannot convert DL11 TTY UDX to TTY name
	MOVEI	T3,TTXIHD	;BUFFER HEADER
	OPEN	TTX,T1		;GET IT
	  JWARN	.TCRLF##,Cannot open DL11 TTY
	TXO	F,F.TOPN	;OKAY TO USE TTX
	MOVE	T1,TTXBUF	;GET POINTER TO TTY BUFFERS
	MOVEM	T1,TTXIHD	;HERE WHEN REUSING BUFFERS, POINT HEADER TO THEM
	POPJ	P,


;ROUTINE TO UNDO DTBGDL

DTBDDL:	TXZN	F,F.TOPN	;CAN'T USE THIS ANY MORE
	POPJ	P,		;WASN'T IN USE
	PUSHJ	P,DTBLOU	;FORCE OUT BUFFER
	RELEAS	TTX,		;FREE CHANNEL
	POPJ	P,		;EASY ENOUGH
;ROUTINE TO SETUP DL11 LINE
DTBSDL:	HRRZ	T3,DTBUDX(DT)	;GET DL11 UDX
	JUMPE	T3,CPOPJ	;IF WE DON'T KNOW UDX, CAN'T BE DONE
	PUSHJ	P,SAVE1		;NEED ANOTHER AC
	MOVSI	P1,-TRMOPN	;AOBJN POINTER TO TRMOP TABLE
DTBSD1:	MOVE	T1,[3,,T2]	;GIVE TRMOP 3 WORDS STARTING AT T2
	HLRZ	T2,TRMOPT(P1)	;GET FUNCTION TO DO
	HRRZ	T4,TRMOPT(P1)	;GET VALUE TO SET
	TRMOP.	T1,		;TELL MONITOR
	  JFCL			;PROBABLY SHOULD COMPLAIN
	AOBJN	P1,DTBSD1	;DO REST
	POPJ	P,


;TABLE OF TRMOPS DONE TO DN20 DL11 LINES. MOST OF THESE ARE NOT NEEDED
;SINCE WE DO EVERYTHING IN IMAGE MODE. HOWEVER, THAT DIDN'T WORK SO
;WELL WHEN THIS CODE WAS WRITTEN AND THIS MADE DEBUGGING EASIER.

TRMOPT:	.TOSLV+.TOSET,,1	;SLAVE SO MONITOR DOESN'T TREAT DL11 OUTPUT AS COMMANDS
	.TOTSP+.TOSET,,15	;SET TO-DN20 SPEED T0 9600 (ON A DL11 ALL THESE DO IS
				; TELL RSX-20F TO LISTEN TO THE LINE
	.TORSP+.TOSET,,7	;SET TO-20F SPEED TO 300
	.TOFLC+.TOSET,,0	;WE DON'T WANT -10 OUTPUT TO INCLUDE SPURIOUS RUBOUTS
	.TOLCT+.TOSET,,0	;WE WANT TO SEE LOWER CASE
	.TOFRM+.TOSET,,0	;AND FORM FEEDS (ACTUALLY LET DN20 SEE THEM)
	.TOTAB+.TOSET,,1	;LIKEWISE WITH TABS
	.TOWID+.TOSET,,0	;DON'T INSERT EXTRA CRLFS INTO DN20 DATA
	.TOPAG+.TOSET,,0	;MAYBE THIS SHOULD BE ON
	.TOXON+.TOSET,,1	;PUT IN TAPE MODE TO PREVENT CRLF FROM BECOMING CRLFLF
TRMOPN==.-TRMOPT
;THIS ROUTINE READS A BUFFERFUL OF DATA FROM A DL11 LINE AND
;PUTS IT IN THE LINE BUFFER FOR THE ASSOCIATED DTB (WHICH MUST HAVE BEEN SET
;UP BY THE TIME THE CODE GETS HERE.

DTBCHK:	MOVE	T1,DTBFLG(DT)	;GET THE FLAGS
	TXNE	T1,DTFMST	;IS THIS THE MASTER DTE?
	 POPJ	 P,		; YES, DON'T BOTHER THE CTY
	DMOVE	T1,[EXP <2,,T2>,.TOSIP] ;THIS CODE GETS AROUND A 6.03 MONITOR BUG, I. E.
				;INPUTS ON TTYS OPENED IN PIM AND ASYNC IO MODE
				; ALWAYS GIVE A SUCCESSFUL RETURN TO IN UUOS, EVEN
				; IF THERE IS NO DATA AVAILABLE! THIS TRMOP
				; CHECKS TO SEE IF ANY INPUT IS AVAILABLE BEFORE
				; DOING THE INPUT.
	HRRZ	T3,DTBUDX(DT)	;LAST OF TRMOP PARAMS
	TRMOP.	T1,		;IS INPUT AVAILABLE?
	  JRST	DTBCH1		;NO, DON'T TRY TO GET IT
	TXNN	F,F.TOPN	;IS THE TTX CHANNEL OPEN?
	JRST	DTBCH1		;ALSO TRY MPX CHANNEL
	IN	TTX,		;BUFFER AVAILABLE?
	  SKIPA	T1,[TTXIHD]	;YES, PASS HEADER TO DTBLBF
	JRST	DTBCH1		;TRY MPX CHANNEL
	PUSHJ	P,DTBLBF	;LOG THE BUFFER CONTENETS
	JRST	DTBCHK		;SEE IF MORE TO DO

DTBCH1:	SKIPN	MPXCTD		;ANYTHING CONNECTED TO MPX CHANNEL?
	POPJ	P,		;NO, DON'T TRY IT
	IN	MPX,		;TRY TO GET A BUFFER
	  SKIPA	T1,[MPXIHD]	;GET ADDR OF MPX BUFFER HEADER
	POPJ	P,		;NO DATA, RETURN
	HRRZ	T2,MPXIHD+.BFCTR ;MONITOR CAN RETURN EMPTY BUFFERS CONTINUALLY
	JUMPE	T2,CPOPJ	;SO STOP IF IT TRYS THAT
	PUSHJ	P,DTBLBF	;LOG THIS BUFFER
	JRST	DTBCHK		;DARE TRY FOR ANOTHER
;ROUTINE TO TAKE A BUFFERFUL OF DATA AND PUT IT IN THE DTB'S
;LINE BUFFER. THE BUFFER IS OUTPUT WHENEVER A LF IS STORED, WHENEVER IT
;FILLS, AND IF DATA IN THE BUFFER ISN'T PRINTED IN A COUPLE OF SECONDS
;(SEE DTBTIM).

DTBLBF:	PUSHJ	P,SAVE1		;NEED A SAFE PLACE FOR THE ADDRESS OF THE BUFFER HEADER
	MOVE	P1,T1
	PUSHJ	P,DTBALL	;HAVE TO SEARCH FOR DTB ASSOCIATED WITH UDX
	HRRZ	T1,DTBUDX(DT)	;GET UDX FOR THIS DTB
	CAME	T1,.BFUDX(P1)	;COMPARE WITH UDX IN BUFFER HEADER
	POPJ	P,		;NO MATCH, LOOK AT NEXT
	HRRZS	.BFCTR(P1)	;MPX TTYS SEEM TO HAVE UDX IN LEFT HALF
DTBLB1:	SOSGE	.BFCTR(P1)	;ANOTHER BYTE?
	PJRST	DTBSTP		;NO, STOP DTBALL AND RETURN TO DTBLBF CALLER
	ILDB	T1,.BFPTR(P1)	;GET NEXT CHARACTER
	PUSHJ	P,DTBLCH	;STUFF IN LINE BUFFER
	JRST	DTBLB1		;DO REST OF BUFFER
;CHARACTERS ARE STORED IN A LINE BUFFER
;IN CASE DTELDR IS RUNNING UNDER OPSER. THAT WAY OUTPUT WILL LOOK MUCH NEATER
;THAN IF DTELDR OUTPUT CHARACTERS AS IT RECEIVED THEM. DTBTIM SHOULD BE CALLED
;EVERY SO OFTEN TO SEE IF NO DATA HAS BEEN RECEIVED RECENTLY IN WHICH CASE
;THE LINE BUFFER SHOULD BE OUTPUT ANYWAY SINCE IT MAY CONTAIN A PROMPT NOT
;TERMINATED BY A CARRIAGE RETURN. ALSO, IF TWO DL11S ARE ACTIVE AT ONCE,
;THIS WILL PROVIDE SOME SEPARATION OF THE DATA INSTEAD OF THOROUGHLY MIXING
;THEM.

DTBLCH:	CAMN	DT,A.DTB	;IF WE ARE NOT TALKING TO THIS DTB
	SKIPE	A.TALK
	JRST	DTBLC0		;THEN LET THE CHARACTER SIT IN THE BUFFER FOR A WHILE
	OUTCHR	T1		;TALKING TO THIS DTB, HAVE TO OUTPUT RIGHT AWAY
	POPJ	P,		; SINCE THIS MIGHT BE ECHO DATA

DTBLC0:	ANDI	T1,177		;ASCII BITS ONLY
	JUMPE	T1,CPOPJ	;IGNORE NULLS
	MOVX	T2,DTFOPD	;SAY WE NOW HAVE PENDING OUTPUT FOR DTBTIM
	IORM	T2,DTBFLG(DT)
	MOVX	T2,%CVUPT	;GET UPTIME ON CPU0 (SMP PROBLEMS)
	GETTAB	T2,
	  MOVEI	T2,0		;DON'T TIME IF THIS FAILS
	MOVEM	T2,DTBUTM(DT)	;IS WHEN WE WILL FORCE OUTPUT
	SOSG	DTBCTR(DT)	;SPACE LEFT IN LINE BUFFER?
	PUSHJ	P,DTBLOU	;NO, FORCE OUTPUT
	IDPB	T1,DTBPTR(DT)	;STORE CHARACTER IN BUFFER
	MOVX	T2,DTFCRR	;GET CARRIAGE RETURN RECEIVED LAST FLAG
	CAIE	T1,"M"&37	;LAST CHARACTER A CR?
	JRST	DTBLC1		;NO, MAYBE IT WAS A LF
	IORM	T2,DTBFLG(DT)	;REMEMBER WE SAW A CR IN CASE NEXT IS LF
	POPJ	P,

DTBLC1:	CAIE	T1,"J"&37	;WAS IT LF?
	JRST	[ANDCAM T2,DTBFLG(DT) ;LAST CHARACTER NO LONGER CR
		 POPJ	P,]
	PUSHJ	P,DTBLOU	;FORCE OUT LINE
	MOVE	T1,DTBFLG(DT)	;SEE IF LAST CHARACTER WAS A CR
	TXNN	T1,DTFCRR	;IF IT WAS, THEN WE SHOULD ADD A TAG TO NEXT LINE
	POPJ	P,
	;..
	;..
;ROUTINE TO TAG FIRST FEW CHARACTERS OF A LINE BUFFER WITH IDENTIFICATION TO
;LET USER KNOW WHAT FRONT END DATA IS COMING FROM

DTBLTG:	CAMN	DT,A.DTB	;IS THIS THE FRONT END REFERENCED IN THE CURRENT COMMAND?
	POPJ	P,		;YES, NO NEED TO TELL USER WHERE LINE IS COMING FROM
	MOVEI	T1,"["		;PUT A TAG ON IN A BRUTE FORCE A MANNER AS POSSIBLE
	PUSHJ	P,DTBLCH	;PUT IN ONE
	LDB	T1,[POINT 7,DTBID(DT),6]
	PUSHJ	P,DTBLCH
	LDB	T1,[POINT 7,DTBID(DT),13]
	PUSHJ	P,DTBLCH
	MOVEI	T1,"]"
	PUSHJ	P,DTBLCH
	MOVEI	T1," "
	PUSHJ	P,DTBLCH
	MOVX	T1,DTFOPD	;DON'T LET DTBTIM PUSH THIS OUT EARLY
	ANDCAM	T1,DTBFLG(DT)
	POPJ	P,
;ROUTINE TO FIND DL11 LINES THAT HAVE GONE IDLE AND FORCE OUT ANY TEXT IN THEIR
;LINE BUFFERS. (ESPECIALLY USEFUL TO GET OUT THINGS LIKE PROMPTS.)

DTBTIM:	PUSHJ	P,DTBALL	;LOOK AT ALL DTBS
	MOVE	T1,DTBFLG(DT)	;SEE IF THERE IS PENDING OUTPUT
	TXNN	T1,DTFOPD
	POPJ	P,		;NOPE.
	MOVX	T1,%CVUPT	;NOW SEE IF IT'S BEEN THERE TOO LONG
	GETTAB	T1,		;GET CPU0 UPTIME
	  PJRST	DTBLOU		;DON'T TIME IF THIS FAILS
	SUBI	T1,^D<3*55>	;BACKUP TIME ABOUT 3 SECONDS IN USA AND EUROPE
	CAML	T1,DTBUTM(DT)	;HAS IT BEEN THAT LONG SINCE WE LAST GOT A CHARACTER?
	PJRST	DTBLOU		;YES, PRINT BUFFER
	MOVEI	T1,^D4000	;ARRANGE TO HAVE ATOWAT SLEEP LONG ENOUGH TO
	MOVEM	T1,HIBTIM	; LET US FLUSH THE DATA WE CAN'T NOW
	POPJ	P,		;NO, LEAVE FOR A BETTER DAY


;ROUTINES TO PRINT LINE BUFFER FROM A DL11 AND TO INITIALIZE LINE BUFFER

DTBLOU:	MOVEI	T2,0		;MARK END OF STRING
	IDPB	T2,DTBPTR(DT)
	PUSH	P,T1		;SAVE T1
	MOVEI	T1,DTBTXT(DT)	;GET ADDRESS OF TEXT
	PUSHJ	P,.TSTRG##	;PRINT IT
	POP	P,T1		;RESTORE T1
DTBLSP:	DMOVE	T2,[EXP <POINT 7,DTBTXT>,TXTLEN*5-1]
	ADDI	T2,(DT)		;MAKE ACTUAL POINTER TO START OF TEXT
	MOVEM	T2,DTBPTR(DT)	;SAVE THAT
	MOVEM	T3,DTBCTR(DT)	;AND COUNT
	MOVX	T2,DTFOPD	;CLEAR PENDING OUTPUT FLAG SINCE THERE IS NONE
	ANDCAM	T2,DTBFLG(DT)
	POPJ	P,		;LET BUFFER FILL AGAIN
;ROUTINE TO CALL CALLER WITH EVERY DTB, EVEN IF THERE IS NO DTE ASSOCIATED
;WITH IT. CALLER MAY NOT CHANGE DT OR REFERENCE DATA PUSHED ON THE STACK BEFORE
;THE CALL. AFTER THE LAST DTB IS PROCESSED, THE PROGRAM WILL CONTINUE WITH THE
;CALLER'S CALLER. (GRANDCALLER?) DT WILL BE UNCHANGED.

DTBALL:	PUSH	P,DT		;EVENTUALLY RETURN ORGINAL VALUE
	MOVEI	DT,DTBSTR	;GET ADDRESS OF FIRST DTB
DTBAL1:	PUSHJ	P,@-1(P)	;CALL CALLER
	ADDI	DT,DTBLEN	;STEP TO NEXT
	CAIGE	DT,DTBEND	;TOO FAR?
	JRST	DTBAL1		;NOT YET
	POP	P,DT		;RECOVER ORIGINAL VALUE
	PJRST	T1POPJ		;DO RETURN FOR THE CALLER


;ROUTINE ANALOGOUS TO DTBALL BUT ONLY DTBS WITH THE IGNORE BIT OFF
;WILL BE RETURNED.

DTBSOM:	PUSH	P,DT
	MOVEI	DT,DTBSTR	;ALMOST LIKE THE ABOVE
DTBSO1:	SKIPL	DTBFLG(DT)	;EXCEPT WE DON'T RETURN DTBS WITH DTFIGN SET
	PUSHJ	P,@-1(P)	;CALL REST OF CALLER
	ADDI	DT,DTBLEN	;STEP TO NEXT
	CAIGE	DT,DTBEND
	JRST	DTBSO1
	POP	P,DT
	PJRST	T1POPJ


;ROUTINE THAT MAY BE CALLED (VIA PJRST) TO STOP THE ACTION OF DTBALL AND
;DTBSOM. BY SETTING DT TO BE AFTER THE DTBS, COMPARES ABOVE WILL
;THINK THAT ALL DTBS HAVE BEEN PROCESSED.

DTBSTP:	MOVEI	DT,DTBEND
	POPJ	P,
SUBTTL	DTE. UUO INTERFACE ROUTINES

;ROUTINE TO SKIP IF THE SPECIFIED DTE IS THE MASTER

ISMAST:	MOVE	T1,DTBFLG(DT)	;GET FLAG BITS
	TXNE	T1,DTFMST	;MASTER?
	AOS	(P)		;YES, GIVE SKIP
	RETURN

;ROUTINE TO STOP PROTOCOL FROM RUNNING ON AN 11

DTECLR:	MOVE	T1,[.DTECL,,DTUBLK]
	JRST	DODTEU		;[45]DO DTE CLEAR

;ROUTINE TO PRESS RELOAD BUTTON ON A DTE

DTEPRB:	MOVE	T1,[.DTEPR,,DTUBLK]
	JRST	DODTEU		;DO DTE UUO AND RETURN

;START PROTOCOL ON A DTE/11

STRDTE:	MOVE	T1,DTBDSC(DT)	;GET CPU,,DTE FOR THIS DTB
	MOVEM	T1,DTUBLK	;PUT INTO BLOCK

	SKIPE	T1,A.PROT	;ANY PARTICULAR PROTOCOL SPECIFIED?
	 JRST	 STRDT1		; YES, GO USE IT
	SKIPE	T1,DTBPRO(DT)	;IS THERE A DEFAULT PROTOCOL FOR THIS DTE
	 JRST	 STRDT1		; YES, USE IT
	MOVE	T1,PROTAB	;USE 'NOBODY' FOR A DEFAULT (AUTOCONFIGURE)
STRDT1:	MOVEM	T1,DTUDAT	;INSTALL PROTOCOL TYPE IN DTE. BLOCK
	MOVE	T1,[.DTESU,,DTUBLK] ;GET ARG FOR DTE. UUO
	DTE.	T1,		;SET THE PROTOCOL TYPE
	 JRST	 [CAIN T1,DTEUF% ;UNKNOWN FUNCTION?
		  JRST .+1	; YES, NO PROBLEM, MAYBE OLD MONITOR
		  PUSHJ	P,DTUERR];NO, BAD ERROR.  OK TO PUSHJ, NEVER RETURNS
	MOVE	T1,[.DTEST,,DTUBLK]
	JRST	DODTEU		;GO DO IT

;SET TO-10 BYTE POINTER

SETTBP:	MOVEM	T1,DTUDAT	;PUT IN DTUBLK+1
	MOVE	T1,[.DTETB,,DTUBLK]
	JRST	DODTEU

;GET ROM WORD IN T1

GETROM:	SKIPL	T1,A.SWIT	;USE VALUE FOR /SWITCH?
	RETURN			;YES, RETURN WITH IT
	MOVE	T1,A.CPU	;IF NO "/SWITCH" SPECIFIED, SEE IF "/ASWITCH"
	IMULI	T1,DTEMAX+1	; WAS SPECIFIED FOR THIS FE. CALCULATE
	ADD	T1,A.DTE	; OFFSET INTO DEFAULT SWITCH TABLE
	SKIPE	T1,SWTBLK(T1)	;IF /ASWITCH IS SPECIFIED,
	RETURN			; RETURN IT
	MOVE	T1,[.DTERW,,DTUBLK] ;NO, USE WHAT FRONT END TOLD US
	PUSHJ	P,DODTEU	;DO IT, GET RESULT IN T1, RETURN
	TXZ	T1,DT.LSB	;CLEAR RELOAD CONDITION
	TXO	T1,.DTLRU_ALIGN.(DT.LSB) ;SET CORRECT CONDITION
	POPJ	P,
;SET TO-11 BYTE POINTER

SETEBP:	MOVEM	T1,DTUDAT
	MOVE	T1,[.DTEEB,,DTUBLK]
DODTEU:	MOVE	T4,DTBDSC(DT)	;GET CPU,,DTE FOR THIS DTB
	MOVEM	T4,DTUBLK	;PUT INTO BLOCK
	DTE.	T1,		;DO IT
	  JRST	DTUERR		;GIVE ERROR WITH DTUERR
	RETURN
;HERE TO PRINT A MESSAGE ACCORDING TO WHAT DTE. ERROR CODE
; HAPPENED.  CALL WITH ERROR CODE IN T1. NEVER RETURN.

DTUERR:	HRLZ	P1,T1		;PUT ERROR CODE IN A SAFE PLACE
	CAIG	T1,DTUEMX	;IS ERROR CODE IN RANGE?
	 JUMPGE	 T1,DTUER2	; IT IS SMALL ENOUGH.  JUMP IF IT'S BIG ENOUGH
	HRRI	P1,[ASCIZ |Unknown error code from DTE. UUO|]
	JRST	DTUER3		;AND JUMP INTO THE FRAY

DTUER2:	HRLZI	T2,-DTUMLN	;MAKE AOBJN POINTER INTO ERROR LIST
DTUELP:	HLRZ	T3,DTUERM(T2)	;GET ERROR CODE
	CAME	T3,T1		;DO WE KNOW ABOUT THIS ONE??
	AOBJN	T2,DTUELP	;NO, LOOP TILL WE FIND OUR MESSAGE
	HRR	P1,DTUERM(T2)	;GET TEXT ADDRESS INTO A SAFE PLACE

DTUER3:	MOVEI	T1,[ASCIZ/? /]	;GET PREFIX
	PUSHJ	P,.TSTRG##	;TYPE IT OUT
	PUSHJ	P,TYPFE		;IDENTIFY WHO THIS IS
	MOVEI	T1,[ASCIZ/ DTE. (/] ;LET PEOPLE KNOW WHICH UUO
	PUSHJ	P,.TSTRG##	;TYPE IT OUT
	HLRE	T1,P1		;GET ERROR CODE BACK
	PUSHJ	P,.TOCTW##	;TYPE IT OUT
	MOVEI	T1,[ASCIZ/) -- /] ;TYPE OUT MORE FORMAT GARBAGE
	PUSHJ	P,.TSTRG##	;BLAH BLAH BLAH
	HRRZ	T1,P1		;GET ADDRESS OF TEXT
	PUSHJ	P,.TSTRG##	;(FINALLY!) TYPE OUT THE ERROR MESSAGE
	PUSHJ	P,.TCRLF##	;TYPE A <CRLF>

	MOVSI	T2,(ER.NPF)	;DID -11 POWERFAIL FAIL TO SET?
	HLRZ	T1,P1		;GET BACK ERROR CODE
	CAIN	T1,DTEPT%	;?
	IORM	T2,ERRWRD	;YES, LOG IT
	MOVSI	T2,(ER.RMF)	;DID -11 CLEAR ITS DOORBELL?
	CAIN	T1,DTEDE%	;?
	IORM	T2,ERRWRD
	MOVSI	T2,(ER.NRL)	;IS -11 OBJECT PROGRAM DEAD TO THE WORLD?
	CAIN	T1,DTEDD%	; (SUPPOSED TO GIVE A TO-10 DOORBELL)
	IORM	T2,ERRWRD	;YES, THAT'S THE PROBLEM
DTUDI1:	PUSHJ	P,DTEXIT	;CLEAR OUT DTE IF WE CAN
	PUSHJ	P,ERRLOG	;ERROR LOG IF POSSIBLE
	JRST	STARTE		;GO ASK FOR COMMAND AGAIN
;HERE ON ERROR, DON'T EXIT IF /AUTO

ERRXIT:	PUSHJ	P,DTEXIT	;CLEAR OUT DTE IF EXITING
	PUSHJ	P,ERRLOG	;LOG ERROR, IF NECESSARY
	SKIPGE	ATOFLG		;/AUTO IN EFFECT?
	JRST	STARTE		;YES, RESTART AT STARTE INSTEAD OF EXITING.

;HERE WHEN ERROR AND TIME TO GIVE UP
EXITX:	PUSHJ	P,DTEXIT	;CLEAR DTE IF USER I/O IS ON

;HERE TO RETURN TO MONITOR
GOHOME:	HLLZS	.JBREN##	;NEXT INSTRUCTION BREAKS REENTER
	RESET			;GO RETURN TO MONITOR
	HLLZS	.JBINT##	;DEACTIVATE ^C INTERCEPT
	PUSHJ	P,WTOFLS	;FLUSH THE WTO BUFFER
	EXIT	1,
	EXIT

;HERE TO CLEAR OUT DTE IF WE WERE DOING ANYTHING TO IT.

DTEXIT:	JSP	T1,.+1		;GET PC BITS
	TLNN	T1,(1B6)	;SEE IF I/O MODE
	RETURN			;NO, LEAVE FRONT END ALONE
	MOVE	T1,[.DTECL,,T2]
	MOVE	T2,A.DTE	;GET DTE NUMBER
	HRL	T2,A.CPU	;AND CPU NUMBER
	DTE.	T1,		;DO THE UUO
	  JFCL			;IGNORE  POSSIBLE ERROR
	RETURN
SUBTTL ERROR LOGGING ROUTINES


SETRTY:	HLRZM	T1,RTRYPC	;SAVE WHERE TO RETRY
	HRRZM	T1,FAILPC	;SAVE WHERE TO GIVE UP
	POP	P,T1		;GET RETURN ADDRESS TO MAKE P BE
	MOVEM	P,ERRORP	; THE POINTER TO BACKUP TO ON ERROR
	JRST	(T1)		;RETURN


;ROUTINE JRSTED TO IN LERROR MACRO WITH ERROR BIT IN T1

RETRY:	MOVE	P,ERRORP	;SAVE STACK POINTER TO BACK UP TO IN CASE OF ERROR
	IORM	T1,ERRWRD	;PUT THE BIT IN ERROR WORD
	AOS	T2,RETRYC	;INCREMENT PER EVENT RETRY COUNT
	CAILE	T2,.ERRTR	;SEE IF DONE WITH RETRIES FOR THIS EVENT
	JRST	[MOVEI	T1,[ASCIZ |? All retries failed|]
		 PUSHJ	P,.TSTRG##
		 PUSHJ	P,.TCRLF##
		 PUSHJ	P,.TCRLF##
		 SETZM	RETRYC	;CLEAR PER EVENT RETRY COUNT
		 JRST	@FAILPC];GO TO FAIL PLACE
	WARNC	(<Attempting retry>,T2)
	PUSHJ	P,.TCRLF##
	AOS	RETRYT		;INCREMENT RETRY TOTAL COUNT
	JRST	@RTRYPC
;ROUTINE TO GENERATE AN ENTRY IN ERROR.SYS.  CALLED AT ERRXIT
; AND AFTER SUCCESSFUL TERMINATION OF CFE-11 RELOAD.

ERRLOG:	SKIPE	ERRWRD		;ANYTHING TO LOG?
	SKIPL	A.NLOG		;WANT ERROR LOGGING
	POPJ	P,		;NO, EITHER NOTHING OR DISABLED

;CLEAR THE ERROR BLOCK
	SETZM	ERRFZR		;CLEAR THE FIRST WORD OF THE ERROR REPORT BLOCK
	MOVE	T2,[XWD ERRFZR,ERRFZR+1] ;GET A BLT POINTER TO THE BLOCK
	BLT	T2,ERRLZR	;  AND PROPAGATE THE CLEAR

	MOVSI	T1,(ER.LOG)	;CLEAR THE BORROWED BIT
	ANDCAM	T1,ERRWRD	;THAT CAUSED US TO LOG A NORMAL RELOAD
	MOVE	P1,RETRYT	;GET TOTAL RETRY COUNT
	ANDI	P1,ER.RTC	;CLEAR ALL BUT GOOD BITS
	IOR	P1,ERRWRD	;PICK UP THE ERROR BITS
	MOVEM	P1,ERRBLK+.ERSTS;PUT INTO MESSAGE
	MOVS	P1,A.CPU
	HRR	P1,A.DTE	;SETUP CPU#,,DTE#
	TLO	P1,(ER.MAS)	;ASSUME MASTER
	SKIPN	MASTER		;IS IT?
	TLZ	P1,(ER.MAS)	;NO
	MOVEM	P1,ERRBLK+.ERNUM;SETUP THAT PART OF ENTRY
	MOVEI	T1,.ERERL	;ELEVEN RELOAD CODE
	MOVEM	T1,ERRCOD	;SET IT UP
	MOVEI	T1,.ERSIZ+1	;GET POINTER TO TEXT
	MOVEM	T1,ERRBLK+.ERFNM;SETUP FOR ENTRY
	SETZ	P2,		;CLEAR BYTE COUNT
	MOVE	P1,[POINT 7,ERRBLK+.ERSIZ+1] ;GET BYTE POINTER
	SKIPL	A.NDMP		;WAS DUMP DONE?
	JRST	ERRLG2		;NO, SKIP THIS
	MOVEI	T1,DMPFIL	;GET ADDRESS OF THE DUMP FILE BLOCK
	SKIPE	ERFSDV(T1)	;IF THERE'S NO DEVICE WE DIDN'T DUMP IT.
	PUSHJ	P,ERRFSP	;PUT THE NAME IN THE BLOCK
ERRLG2:	MOVEM	P2,ERRBLK+.ERSIZ ;PUT SIZE OF STRING IN ENTRY
	MOVEI	T2,.DMERR	;DAEMON APPEND TO ERROR.SYS FUNCTION
	MOVEM	T2,ERRFCN	;PUT INTO THE BLOCK
	MOVEI	T1,4(P2)	;GET THE NUMBER OF CHARS IN THE FNAME
	IDIVI	T1,5		;  CONVERT THAT TO WORDS
	ADDI	T1,.ERSIZ+2	;CALCULATE THE LENGTH OF THE BLOCK
	MOVSI	T1,(T1)		;  AND PUT IT IN THE LH(T1)
	HRRI	T1,ERRFCN	;GET THE ADDRESS OF THE ERROR BLOCK
	DAEMON	T1,		;ATTEMPT TO REPORT THE ERROR
	  JRST	ERRDUF		;GO REPORT THE DAEMON UUO ERROR
	RETURN
	SUBTTL	DAEMON -- INTERFACE TO THE DAEMON ERROR-REPORTING ROUTINES

;SYSERR FUNCTIONS 202/203 (DUMP & LOAD)
;THE FORMAT OF THE SYSERR BLOCK IS:
; -2	.DMERR			;DAEMON ERROR REPORT FUNCTION CODE
; -1	"CODE"			;EITHER 202(LOAD) OR 203(DUMP)
;  0	TARGET			;POINTER TO THE NAME OF THE NODE LOADED/DUMPED
; +1	SERVER			;NAME OF THE NODE THAT LOADED/DUMPED THE OTHER
; +2	LINE			;NAME OF THE LINE LOADED/DUMPED
; +3	FILE			;POINTER TO THE FILE LOADED/DUMPED
; +4	RTN-CODE		;VALUE IS THE "NSP" RETURN CODE
; +5	PRG-NAME		;THE NAME OF THE PROGRAM DOING THE LOAD/DUMP
; +6	VALUE			;36 BITS OF "VALUE" RETURNED BY THE PROGRAM

ERRLOA:	SKIPA	T1,[XWD .ESNDL,LODFIL] ;HERE TO REPORT A DOWN LINE LOAD
ERRDMP:	MOVE	T1,[XWD .ESNUD,DMPFIL] ;HERE TO REPORT AN UP LINE DUMP
	SKIPL	A.NLOG		;IF "NOLOG" WAS REQUESTED
	RETURN			;  THEN DON'T LOG ANYTHING
	PUSH	P,T1		;SAVE "XWD DAEMON-CODE,FILE-SPEC-ADDRESS"

;CLEAR THE ERROR BLOCK
	SETZM	ERRFZR		;CLEAR THE FIRST WORD OF THE ERROR REPORT BLOCK
	MOVE	T2,[XWD ERRFZR,ERRFZR+1] ;GET A BLT POINTER TO THE BLOCK
	BLT	T2,ERRLZR	;  AND PROPAGATE THE CLEAR

;SET UP A BYTE POINTER TO THE "FREE SPACE" IN THE BLOCK
	MOVE	P1,[POINT 7,ERRFRE] ;P1 WILL ALWAYS HAVE A 7 BIT BYTE POINTER
	HRROI	T1,-ERRBLK(P1)	;T1 STARTS WITH A "SYSERR" POINTER.

;DAEMON FUNCTION CODE
	MOVEI	T2,.DMERR	;DAEMON ERROR REPORT
	MOVEM	T2,ERRFCN	;STORE THE FUNCTION CODE

;SYSERR FUNCTION CODE
	HLRZ	T2,(P)		;GET THE CODE OFF THE STACK
	MOVEM	T2,ERRCOD	;  AND STORE IT IN THE BLOCK

;TARGET NODE NAME (WE DON'T KNOW WHAT IT IS...)
	MOVEM	T1,ERRTRG	;SAVE A POINTER TO THE TARGET NAME
	MOVEI	T1,[ASCIZ /Not Applicable/]
	PUSHJ	P,ERRASC	;WRITE THE "NAME"
	PUSHJ	P,ERRNPT	;  AND CLOSE OFF THE FIELD.

;SERVER NODE (TRY SEVERAL WAYS TO GET OUR NAME AND RETURN THAT)
	MOVEM	T1,ERRSER	;SAVE A POINTER TO WHERE WE WILL PUT THE NAME
	MOVSI	T1,'CTY'	;ASK WHERE OUR "CTY" IS
	WHERE	T1,		;  AND THAT SHOULD GIVE US OUR NODE NUMBER
	  JRST	ERRLD1		;IF NO NETWORKS, GO RETURN "SYSNAM" INSTEAD
	PUSH	P,T1		;SAVE OUR NODE NUMBER FOR A BIT
	MOVE	T3,T1		;COPY THE NODE NUMBER FOR THE NEXT CALL
	MOVE	T1,[XWD .NDRNN,T2] ;SET UP FOR A NODE. UUO
	MOVEI	T2,2		;  THAT WILL TRANSLATE THE
	NODE.	T1,		;  NODE NUMBER INTO A SIXBIT NAME
	  JRST	[POP P,(P)	;??? SHOULDN'T HAPPEN.  MUST BE A DN60 ONLY SYS.
		 JRST ERRLD1]	;??? FIXUP STACK AND USE "SYSNAM" INSTEAD.
	PUSHJ	P,ERRSIX	;WRITE OUT THE SIXBIT NAME
	MOVEI	T1,"("		;GET THE OPEN PARENTHESIS
	PUSHJ	P,ERRCHR	;  AND WRITE THAT OUT.
	POP	P,T1		;GET OUR NODE NUMBER BACK
	PUSHJ	P,ERROCT	;  AND WRITE THAT
	MOVEI	T1,")"		;GET THE CLOSING PARENTHESIS
	PUSHJ	P,ERRCHR	;  AND CLOSE OFF THE NODE(NUM) SPEC
	JRST	ERRLD4		;GO TO COMMON CODE TO CLOSE OFF THE FIELD.

;HERE IF WE CAN'T GET OUR NODE NAME IN THE "NAME(NNM)" FORM.  USE SYSNAM INSTEAD
ERRLD1:	MOVEI	T1,0		;START WITH THE FIRST WORD OF "SYSNAM"
ERRLD2:	MOVEI	T2,.GTCNF	;THE NAME IS IN THE "CONFIGURATION TABLE"
	HRLI	T2,(T1)		;  STARTING AT "%CNFG0"
	GETTAB	T2,		;GET THE NEXT WORD OF THE NAME
	  JRST	[MOVEI T1,[ASCIZ /Couldn't read system's name./]
		 JRST ERRLD3]	;WE TRIED. WRITE THIS ERROR MSG INSTEAD.
	MOVEM	T2,SYSNAM(T1)	;STORE THE NEXT CHAR OF THE NAME
	CAIE	T1,4		;IF WE HAVEN'T READ ALL OF THE NAMES YET,
	AOJA	T1,ERRLD2	;  THEN GO BACK AND GET THE NEXT ONE
	MOVEI	T1,SYSNAM	;GET THE ADDRESS OF THE SYSTEM NAME
ERRLD3:	PUSHJ	P,ERRASC	;WRITE THE SYSTEM NAME INTO THE DAEMON MSG
ERRLD4:	PUSHJ	P,ERRNPT	;GET A "NEW POINTER" FOR THE NEXT FIELD.

;LINE DESIGNATOR (CPU:N, DTE:M)
	MOVEM	T1,ERRSLD	;SAVE THE POINTER TO THE LINE SPEC
	MOVEI	T1,[ASCIZ /Cpu:/] ;GET THE FIRST PART OF THE MSG
	PUSHJ	P,ERRASC	;  AND WRITE THAT OUT
	MOVE	T1,A.CPU	;GET THE CPU NUMBER
	PUSHJ	P,ERRDEC	;  AND WRITE THAT OUT
	MOVEI	T1,[ASCIZ /,  Dte:/] ;GET THE REST OF THE MSF
	PUSHJ	P,ERRASC	; ..
	MOVE	T1,A.DTE	;GET THE DTE NUMBER
	PUSHJ	P,ERRDEC	;  AND WRITE OUT THE LAST FIELD.
	PUSHJ	P,ERRNPT	;GET A "NEW POINTER" TO THE NEXT FIELD

;FILE SPEC LOADED FROM OR DUMPED TO.
	MOVEM	T1,ERRFIL	;SAVE THE POINTER TO THE ASCII FILE SPEC
	POP	P,T3		;GET THE ADDRESS OF THE FILE SPEC BLOCK
	HRRZ	T1,T3		;COPY IT FOR ERRFSP
	PUSHJ	P,ERRFSP	;WRITE THE FILE SPEC INTO THE BLOCK
	PUSHJ	P,ERRNPT	;  AND CLOSE OFF THIS FIELD.

;NSP "RETURN CODE"
	MOVEI	T2,1		;"SUCCESS"
	MOVEM	T2,ERRRET	;STORE THE CODE

;PROGRAM NAME (AND WHO RAN IT)
	MOVEM	T1,ERRPRG	;STORE A POINTER TO THE NAME STRING
	PUSHJ	P,ERRPGM	;GO WRITE OUT THE PROGRAM NAME
	MOVEI	T1,[ASCIZ /  By:/] ;GET A "DELIMETER"
	PUSHJ	P,ERRASC	;  AND WRITE THAT
	PUSHJ	P,ERRUNM	;NOW WRITE OUT THE USER'S NAME & PPN
	PUSHJ	P,ERRNPT	;  AND CLOSE OFF THIS FIELD

;NOW THE 36 BITS OF "VALUE" FOR SYSERR TO TYPE OUT
	MOVEI	T2,0		;JUST USE A
	MOVEM	T2,ERRVAL	;  ZERO.

;NOW DO THE DAEMON UUO (RH(T1) HAS THE LENGTH OF THE BLOCK)
	MOVSI	T1,2(T1)	;GET THE LENGTH (PLUS 2) IN THE LH
	HRRI	T1,ERRFCN	;GET THE ADDRESS OF THE FUNCTION BLOCK
	DAEMON	T1,		;DO THE DAEMON UUO
	  JRST	ERRDUF		;THE DAEMON UUO FAILED. GO PRINT AN ERROR
	RETURN			;ALL DONE WITH THE REPORT.
;SUBROUTINES TO WRITE VARIOUS ITEMS INTO THE DAEMON ERROR-REPORT BLOCK

;ROUTINE TO FORCE THE BYTE POINTER IN P1 TO START ON THE NEXT WORD
ERRNPT:	SETZ	T1,		;GET A ZERO,
	PUSHJ	P,ERRCHR	;  AND CLOSE OFF THIS FIELD
	MOVEI	P1,1(P1)	;GET THE ADDRESS OF THE NEXT WORD
	HRLI	P1,(POINT 7,0)	;  AND COMPLETE THE BYTE POINTER
	HRROI	T1,-ERRBLK(P1)	;MAKE T1 BE A "SYSERR" POINTER TO THE STRING
	SETZ	P2,		;CLEAR THE COUNT
	RETURN			;  AND WE'RE DONE

;ROUTINE TO COPY AN ASCIZ STRING INTO THE BLOCK
ERRASC:	PUSH	P,T2		;PRESERVE T2
	HRLI	T1,(POINT 7,0)	;MAKE THE ADDRESS A BYTE POINTER
	ILDB	T2,T1		;GET THE FIRST BYTE
	JUMPN	T2,[IDPB T2,P1	;STORE THE BYTE IN THE BLOCK
		    ILDB T2,T1	;GET THE NEXT BYTE
		    AOJA P2,.]	;COUNT THE BYTE AND LOOP.
	POP	P,T2		;RESTORE THE TEMP
	RETURN			;  AND WE'RE DONE

;ROUTINE TO OUTPUT THE SIXBIT STRING IN T1
ERRSIX:	PUSH	P,T2		;SAVE A TEMP
	PUSH	P,T3		; ..
	MOVE	T3,T1		;COPY THE NAME INTO T3
	MOVE	T2,[POINT 6,T3]	;GET A BYTE POINTER TO THE SIXBIT STRING
ERRSI1:	ILDB	T1,T2		;GET THE NEXT BYTE
	JUMPE	T1,RTN32	;IF WE'RE DONE, FIXUP THE STACK AND RETURN
	ADDI	T1,"0"-'0'	;MAKE THE CHAR ASCII
	PUSHJ	P,ERRCHR	;WRITE THE CHAR
	TLNE	T2,770000	;SEE IF WE'VE GOT ALL 6 BYTES
	JRST	ERRSI1		;LOOP OVER ALL 6 BYTES
	JRST	RTN32		;FIXUP THE STACK AND RETURN

;ROUTINE TO PUT THE CHAR IN "T1" INTO THE OUTPUT STRING
ERRCHR:	IDPB	T1,P1		;STORE THE CHAR
	AOS	P2		;COUNT THE CHAR
	RETURN
;ROUTINES TO WRITE NUMBERS INTO THE FILE

;ROUTINE TO WRITE AN OCTAL NUMBER INTO THE OUTPUT BLOCK
ERROCT:	PUSH	P,T2		;GET A TEMP
	PUSH	P,T3		; ..
	MOVEI	T3,^D8		;GET THE "BASE"
	PUSHJ	P,ERRPNT	;GO PRINT THE NUMBER
	JRST	RTN32		;CLEAN UP AND RETURN

;ROUTINE TO WRITE A DECIMAL NUMBER INTO THE OUTPUT BLOCK
ERRDEC:	PUSH	P,T2		;GET A TEMP
	PUSH	P,T2		; ..
	MOVEI	T3,^D10		;GET THE "BASE"
	PUSHJ	P,ERRPNT	;GO PRINT THE NUMBER
RTN32:	POP	P,T3		;RESTORE T3
	POP	P,T2		;  AND T2
	RETURN			;ALL DONE

;ROUTINE TO WRITE AN ARBITRARY NUMBER TO THE OUTPUT BLOCK
;T1 := NUMBER, T3 := THE BASE, T2 := SCRATCH
ERRPNT:	IDIV	T1,T3		;GET THE NEXT DIGIT
	HRLM	T2,(P)		;SAVE THE REMAINDER
	SKIPE	T1		;IF THERE IS MORE TO DO,
	PUSHJ	P,ERRPNT	;  THEN GO DO IT
	HLRZ	T1,(P)		;GET THE DIGIT
	ADDI	T1,"0"		;MAKE IT ASCII
	PUSHJ	P,ERRCHR	;WRITE THE CHARACTER
	RETURN			;  AND WE'RE DONE.
;ROUTINE TO OUTPUT A PPN IN THE FORM "[P,PN]"
ERRPPN:	PUSH	P,T1		;SAVE THE PPN
	MOVEI	T1,"["		;GET THE OPEN SQUARE
	PUSHJ	P,ERRCHR	;  AND PUT THAT IN THE MESSAGE
	HLRZ	T1,(P)		;GET THE "P"
	PUSHJ	P,ERROCT	;  AND PRINT THAT IN OCTAL
	MOVEI	T1,","		;GET THE SEPARATOR
	PUSHJ	P,ERRCHR	;  OUT IT GOES
	POP	P,T1		;GET THE PPN BACK
	HRRZ	T1,T1		;GET JUST THE "PN"
	PUSHJ	P,ERROCT	;  AND PRINT THAT
	MOVEI	T1,"]"		;GET THE CLOSING SQUARE
	JRST	ERRCHR		;  PRINT THAT AND RETURN
;ROUTINE TO PRINT THE USER'S NAME AND PPN.
ERRUNM:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;  T3
	PUSH	P,T1		;  AND T1
	PJOB	T1,		;GET OUR JOB NUMBER
	MOVSI	T2,(T1)		;PUT IT IN THE "LH"
	HRRI	T2,.GTNM1	;TABLE TO GET FIRST HALF OF THE USER'S NAME
	GETTAB	T2,		;GET THE FIRST HALF OF THE USERS NAME
	  SETZ	T2,		;ZERO IF NOT AVAILABLE
	MOVSI	T3,(T1)		;GET THE JOB NUMBER AGAIN
	HRRI	T3,.GTNM2	;TABLE WITH THE SECOND HALF OF THE USER'S NAME
	GETTAB	T3,		;GET THE SECOND HALF
	  SETZ	T3,		;ZERO IF STILL NOT AVAILABLE
	SKIPN	T2		;IF BOTH THE FIRST
	JUMPE	T3,ERRNU2	;  AND LAST ARE ZERO, DON'T HACK THE NAME

	TLNN	T2,770000	;STRIP LEADING SPACES OFF OF THE NAME
	JRST	[LSHC T2,6	;IF FIRST CHAR IS A SPACE, THROW IT AWAY
		 JRST .-1]	;  AND GO CHECK THE NEXT ONE.

ERRNU1:	LDB	T1,[POINT 6,T2,5] ;GET THE FIRST CHARACTER
	ADDI	T1,"0"-'0'	;ASCII-IZE THE CHARACTER
	PUSHJ	P,ERRCHR	;OUTPUT THE CHARACTER
	LSHC	T2,6		;SHIFT TO THE NEXT CHARACTER
	JUMPN	T2,ERRNU1	;  AND IF THERE ARE ANY MORE
	JUMPN	T3,ERRNU1	;  THEN OUTPUT THEM TOO.

ERRNU2:	PJOB	T1,		;GET OUR JOB NUMBER BACK
	MOVSI	T1,(T1)		;  AND PUT IT IN THE LH
	HRRI	T1,.GTPPN	;WE WANT OUR PPN
	GETTAB	T1,		;GET OUR PPN
	  SETZ	T1,		;???
	PUSHJ	P,ERRPPN	;OUTPUT THE PPN
	POP	P,T1		;RESTORE T1
	JRST	RTN32		;RESTORE T3 & T2 AND RETURN
;ROUTINE TO OUTPUT THE NAME OF THE PROGRAM.
ERRPGM:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;  AND T3
	PJOB	T3,		;GET OUR JOB NUMBER IN "T3"
	MOVEI	T1,.GTPRG	;GET THE PROGRAM
	HRLI	T1,(T3)		;  FIRST
	GETTAB	T1,		;GETTAB THE PROGRAM NAME
	  JRST	ERRPGX		;JUST RETURN 'DTELDR' IF WE FAIL
	PUSHJ	P,ERRSIX	;OUTPUT THE NAME IN SIXBIT
	MOVEI	T1,[ASCIZ /  From:  /]
	PUSHJ	P,ERRASC	;OUTPUT A "DELIMITER"
	MOVEI	T1,.GTRDV	;FIRST GET THE DEVICE THE JOB WAS
	HRLI	T1,(T3)		;  RUN FROM.
	GETTAB	T1,		;GETTAB THE DEVICE.
	  JRST	ERRPGX		;IF NO LUCK RETURN 'DTELDR'
	PUSHJ	P,ERRSIX	;OUTPUT THE NAME AS SIXBIT
	MOVEI	T1,":"		;GET THE COLON
	PUSHJ	P,ERRCHR	;  AND OUTPUT THE DEVICE SEPARATOR
	MOVEI	T1,.GTRFN	;GET THE FILE NAME
	HRLI	T1,(T3)		;  INDEXED BY OUR JOB NUMBER
	GETTAB	T1,		;GETTAB THE FILE NAME WE WERE RUN FROM
	  JRST	ERRPGX		;.. RETURN 'DTELDR'
	PUSHJ	P,ERRSIX	;OUTPUT THE NAME AS SIXBIT
;? OUTPUT .EXT
	MOVEI	T1,"["		;GET THE OPEN SQUARE
	PUSHJ	P,ERRCHR	;  AND OUTPUT IT
	MOVEI	T1,.GTRDI	;GET THE DIRECTORY WE WERE RUN FROM
	HRLI	T1,(T3)		;  INDEXED BY OUR
	GETTAB	T1,		;  JOB NUMBER
	  JRST	ERRPGX		;IF FAIL... RETURN 'DTELDR'
	HRRZ	T2,T1		;SAVE THE "PN"
	HLRZ	T1,T1		;GET THE "P"
	PUSHJ	P,ERROCT	;WRITE THE PROJECT
	MOVEI	T1,","		;GET THE DELIMITER
	PUSHJ	P,ERRCHR	;  AND WRITE IT
	MOVE	T1,T2		;GET THE "PN"
	PUSHJ	P,ERROCT	;WRITE THE PROGRAMMER NUMBER.

;NOW READ THE SFD CHAIN
	SETZ	T2,		;START WITH A ZERO
ERRPG1:	MOVEI	T1,.GTRS0(T2)	;GET THE NEXT SFD TO LOOK FOR
	HRLI	T1,(T3)		;  AND INDEX IT BY OUR JOB NUMBER
	GETTAB	T1,		;FETCH THE SFD
	  JRST	ERRPG2		;IF WE FAIL, SAY WE'RE "DONE" WITH THE SFD;S
	JUMPE	T1,ERRPG2	;  A ZERO ALSO TERMINATES THE LIST
	PUSH	P,T1		;SAVE THE NAME FOR A BIT
	MOVEI	T1,","		;GET THE COMMA
	PUSHJ	P,ERRCHR	;  OUTPUT THE DELIMITER
	POP	P,T1		;GET THE NAME BACK
	PUSHJ	P,ERRSIX	;  AND OUTPUT IT IN SIXBIT
	CAIG	T2,4		;QUIT IF WE'VE READ ALL 5
	AOJA	T2,ERRPG1	;LOOP OVER ALL SFD'S
ERRPG2:	MOVEI	T1,"]"		;GET THE CLOSE SQUARE
	PUSHJ	P,ERRCHR	;  AND WRITE IT OUT
	JRST	RTN32		;CLEAN UP THE STACK AND EXIT

ERRPGX:	MOVE	T1,[SIXBIT /DTELDR/] ;IF ALL ELSE FAILS,
	PUSHJ	P,ERRSIX	;  THEN OUTPUT 'DTELDR'
	JRST	RTN32		;CLEAN UP THE STACK AND RETURN
;ROUTINE TO OUTPUT A FILE SPEC TO THE ERROR BLOCK
;CALL	T1 := POINTER TO A FILE SPEC OF THE FORM
; +0	FILE NAME
; +1	EXT
; +2	DEVICE
; +3	RANDOM BITS (PATH.)
; +4	PPN
; +5	SFD #1
; +6	SFD #2
;   ...
;	0
ERRFSP:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;  AND T3
	MOVEI	T3,(T1)		;GET THE POINTER INTO T3 (FOR SEMI PERMANENCE)
	MOVE	T1,ERFSDV(T3)	;GET THE DEVICE
	PUSHJ	P,ERRSIX	;  AND WRITE THAT OUT IN SIXBUT
	MOVEI	T1,":"		;GET A COLON
	PUSHJ	P,ERRCHR	;  AND WRITE THE SEPARATOR
	MOVE	T1,ERFSFN(T3)	;GET THE FILE NAME
	PUSHJ	P,ERRSIX	;  AND WRITE IT IN SIXBIT
	MOVEI	T1,"."		;GET A DOT
	PUSHJ	P,ERRCHR	;WRITE THE SEPARATOR
	MOVE	T1,ERFSEX(T3)	;GET THE EXTENSION
	PUSHJ	P,ERRSIX	;  AND WRITE THAT.
	MOVEI	T1,"["		;GET THE OPEN SQUARE
	PUSHJ	P,ERRCHR	;  WRITE THE START OF THE PATH SPEC
	HLRZ	T1,ERFSPN(T3)	;GET THE "P"
	PUSHJ	P,ERROCT	;  WRITE THE PROJECT NUMBER IN OCTAL
	MOVEI	T1,","		;GET A COMMA
	PUSHJ	P,ERRCHR	;  AND USE IT TO SEPARATE THE P,PN
	HRRZ	T1,ERFSPN(T3)	;GET THE "PN"
	PUSHJ	P,ERROCT	;  WRITE THE PROGRAMMER NUMBER IN OCTAL
	MOVEI	T2,ERFSSF(T3)	;GET THE ADDRESS OF THE SFD SPEC
	SKIPE	(T2)		;  IF WE'RE NOT PAST THE END OF THE SPEC
	JRST	[MOVEI T1,","	;GET AND OUTPUT
		 PUSHJ P,ERRCHR	;  A SEPARATOR
		 MOVE T1,(T2)	;GET THE SFD NAME
		 PUSHJ P,ERRSIX	;  AND OUTPUT IT IN SIXBIT
		 AOJA T2,.-1]	;LOOP OVER ALL SFD NAMES.

	MOVEI	T1,"]"		;GET THE CLOSING SQUARE
	PUSHJ	P,ERRCHR	;  AND WRITE THAT
	JRST	RTN32		;RESTORE THE AC'S AND RETURN
;ROUTINE TO TYPE OUT INFORMATION REGARDING A DAEMON UUO ERROR
ERRDUF:	WARNCR	DAEMON UUO error while trying to append to ERROR.SYS.
	CAILE	T1,0		;NOW RANGE CHECK THE ERROR CODE
	CAILE	T1,DAEMLN-1	;  AND IF IT IS ONE WE DON'T KNOW ABOUT
	JRST	[WARN <Unknown error =  >
		 PUSHJ P,.TOCTW##
		 PJRST .TCRLF##] ;END THE LINE AND RETURN
	WARN	<Reason: >
	MOVE	T1,DAEERM(T1)	;GET ADDRESS OF THE TEXT
	PUSHJ	P,.TSTRG##	;TYPE IT OUT
	PJRST	.TCRLF##	;MAKE THINGS NEAT WITH A CLOSING CRLF


DAEERM:	[ASCIZ	/Unknown DAEMON UUO error code = /]
	[ASCIZ	/Illegal function code was specified./]
	[ASCIZ	/Adderss check occured during UUO process./]
	[ASCIZ	/Incorrect number of arguments for UUO./]
	[ASCIZ	/Impossible error number 4./]
	[ASCIZ	/File cannot be written./]
	[ASCIZ	/Program does not have privileges required./]
	[ASCIZ	/Invalid FACT entry format./]
	[ASCIZ	/Invalid PATH specification for UUO./]
DAEMLN=	.-DAEERM
	SUBTTL	COMMAND SCANNER

GETCOM:	OUTCHR	["*"]		;TELL USER WE ARE WAITING
	TXZ	F,F.FTYP	;HAVEN'T SEEN A FILE SPEC YET
	SETZM	NUMSWT		;CLEAR NUMBER OF SWITCHES SEEN
COMLP:	PUSHJ	P,GETNAM	;GET A SIXBIT NAME
	JRST	.+2
COMFND:	MOVEI	T2,0		;CLEAR NAME
	MOVSI	T4,-BRKLEN	;LOOK FOR BREAK
	HLRZ	T3,BRKTAB(T4)	;TRY NEXT BREAK
	CAME	T1,T3		;SEE IF MATCH
	AOBJN	T4,.-2		;LOOP UNTIL MATCH
	HRRZ	T3,BRKTAB(T4)	;GET DISPATCH ADDRESS
	JRST	(T3)		;JUMP TO HANDLE BREAK

BRKTAB:	" ",,COMNOP		;SPACE IS A NO-OP
	".",,COMEXT		;DOT IS EXTENSION
	":",,COMDEV		;COLON IS DEVICE
	"[",,COMDIR		;BRAKET IS DIRECTORY
	"/",,COMSWT		;SLASH IS SWITCH
	12,,SAVNAM		;RETURN AT END OF LINE, AFTER SAVING FILE NAME
	32,,GOHOME		;IF ^Z
	3,,GOHOME		;IF ^C
BRKLEN==.-BRKTAB
	0,,COMERR		;ELSE, MUST BE ERROR

COMERR:	USEROR	Command error--type /H for help
COMNOP:	PUSHJ	P,SAVNAM	;STORE FILE NAME
	JRST	COMLP		;AND GO AROUND AGAIN

COMEXT:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETNAM	;GET SIXBIT NAME
	HLLOM	T2,EXT		;SAVE EXT WITH FLAG FOR DOT
	JRST	COMFND		;AND GO AROUND AGAIN

COMDEV:	MOVEM	T2,DEV		;SAVE DEVICE
	TXO	F,F.FTYP	;REMEMBER THAT A FILE HAS BEEN TYPED
	JRST	COMLP		;GO AROUND AGAIN

COMDIR:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETOCT	;GET OCTAL NOW
	CAIN	T1,"-"		;SEE IF DEFAULT
	JUMPE	T2,[PUSHJ P,GETCHR
		    JRST  COMDIX]
	HRLZ	T2,T2		;POSITION IT
	SKIPN	T2		;SKIP IF SOMETHING THERE
	GETPPN	T2,		;NO--GET FROM SYSTEM
	  JFCL
	HLLZM	T2,DIRECT	;SAVE FOR LATER
	CAIE	T1,","		;VERIFY COMMA
	JRST	COMERR		;NO--GIVE UP IN DISGUST
	PUSHJ	P,GETOCT	;GET PROGRAMMER
	SKIPN	T2		;SKIP IF SOMETHING THERE
	GETPPN	T2,		;ELSE ASK MONITOR
	  JFCL
	HRRM	T2,DIRECT	;STORE FOR LOOKUP
	CAIE	T1,","		;SEE IF SFD COMING
	JRST	COMDIX		;NO--GO FINISH UP
	MOVEI	T2,DIRPTH	;YES--SHIFT TO SFD
	EXCH	T2,DIRECT	; FORMAT
	MOVEM	T2,DIRPTH+2	; ..
	MOVSI	T4,-5		;MAX SFD COUNT
COMDIL:	PUSHJ	P,GETNAM	;GET SFD NAME
	JUMPE	T2,COMERR	;ERROR IF BLANK
	MOVEM	T2,DIRPTH+3(T4)	;STORE
	CAIN	T1,","		;SEE IF MORE
	AOBJN	T4,COMDIL	;YES--GO GET UNLESS TOO MANY
COMDIX:	CAIN	T1,"]"
	JRST	COMLP
	CAIN	T1,12
	JRST	COMFND
	JRST	COMERR

SAVNAM:	SKIPN	T2		;IF NAME,
	POPJ	P,
	MOVEM	T2,NAME		; SAVE FOR LOOKUP
	TXO	F,F.FTYP	; AND REMEMBER A FILE SPEC HAS BEEN TYPED
	POPJ	P,		;RETURN
;HERE WHEN SWITCH TO BE PROCESSED

COMSWT:	PUSHJ	P,SAVNAM	;SAVE FILE NAME
	PUSHJ	P,GETNAM	;GET SIXBIT WORD
	MOVEI	T3,0		;PRESET MASK
	MOVSI	T4,770000	;PRESET CHARACTER
	TDNE	T2,T4		;IF CHARACTER,
	IOR	T3,T4		; INCLUDE IN MASK
	LSH	T4,-6		;MOVE OVER ONE
	JUMPN	T4,.-3		;LOOP FOR WORD
	SETO	T4,		;PRESET SUCCESS COUNTER
	MOVSI	P1,-SWTLEN	;PRESET LOOP
SWTLOP:	CAMN	T2,SWTTAB(P1)	;SEE IF EXACT MATCH
	JRST	SWTWIN		;YES--WIN
	MOVE	P2,SWTTAB(P1)	;NO--GET WORD
	XOR	P2,T2		;COMPARE WITH INPUT
	TDNE	P2,T3		;LOOK THROUGH MASK
	JRST	.+3		;NO--KEEP TRYING
	AOS	T4		;COUNT MATCH
	MOVE	P3,P1		;SAVE POINTER
	AOBJN	P1,SWTLOP	;SEE IF DONE YET
	MOVE	P1,P3		;RESTORE WINNER
	JUMPE	T4,SWTWIN	;SEE IF JUST ONE MATCH
	SKIPGE	T4
	USEROR	Unknown switch--type /H for help
	USEROR	Ambiguous switch--type /H for help
SWTWIN:	AOS	NUMSWT		;COUNT SWITCHES SEEN FOR QUICK CHECKING
	PUSHJ	P,@SWTDSP(P1)	;DISPATCH TO SWITCH ROUTINE
	JRST	COMFND		;HANDLE BREAK
SWTTAB:	SIXBIT	/AUTOMA/	;AUTOMATIC - LOOK FOR DEAD FE'S AND RELOAD THEM
	SIXBIT	/IGNORE/	;IGNORE - DON'T LISTEN TO SOME 11'S CTY
	SIXBIT	/NOLIST/	;NOLISTEN - DON'T OPEN CFE LINES TO 11'S CTY
	SIXBIT	/HELP/		;HELP - CALL "HELPER" TO PRINT OUT HELP FILE
	SIXBIT	/TERMIN/	;TERMINATE - TERMINATE PRIMARY PROTOCOL.
	SIXBIT	/IMAGE/		;IMAGE - READ LOAD FILE IN IMAGE MODE
	SIXBIT	/A11/		;A11 - USE ASCIZED-11 FORMAT FOR LOAD FILE
	SIXBIT	/NODUMP/	;NODUMP - DON'T DUMP THE FE.
	SIXBIT	/TALK/		;TALK - TYPE TO 11'S CTY (VIA A CFE LINE)
	SIXBIT	/RELOAD/	;RELOAD - DUMP AND RELOAD A FE.
	SIXBIT	/SELECT/	;SELECT - EITHER 10 OR 11 (WHO HAS BOOT PROG)
	SIXBIT	/SWITCH/	;SWITCH - VALUE OF CONSOLE SWITCHES
	SIXBIT	/NOLOG/		;NOLOG - SUPPRESS WRITING OF ERROR-LOG
	SIXBIT	/INITIA/	;INITIALIZE - START UP PRIMARY PROTOCOL
	SIXBIT	/LOAD/		;ONLY LOAD -11, DON'T START
	SIXBIT	/START/		;SET START ADDRESS FOR FROM10
	SIXBIT	/EXIT/		;EXIT - RETURN TO MONITOR
	SIXBIT	/ASWITC/	;ASWITCH - SET DEFAULT "SWITCHS" FOR FE'S
	SIXBIT	/PROTOC/	;PROTOCOL - SET PROTOCOL FOR THIS DTE
	SIXBIT	/APROTO/	;APROTOCOL - SAME AS ABOVE, BUT AUTOMATIC
	SIXBIT	/DETACH/	;DETACH - DETACH DTELDR WHEN NO MORE COMMANDS AVAILABLE
SWTLEN==.-SWTTAB


SWTDSP:	D.AUTO
	D.IGNR
	D.NLSN
	D.HELP
	D.TERM
	D.IMAG
	D.A11
	D.NDMP
	D.TALK
	D.RELD
	D.SEL
	D.SWIT
	D.NLOG
	D.STRP
	D.LOAD
	D.STRT
	GOHOME
	D.ASWT
	D.PROT
	D.APRO
	D.DETACH
SUBTTL SWITCH HANDLING

;/IGNORE:XY:XY:...:XY

D.IGNR:	CAIE	T1,":"		;INSIST ON AN ARGUMENT
	USEROR	/IGNORE must have an argument
	PUSHJ	P,SETFE		;GET ARGUMENT
	MOVX	T2,DTFIGN	;PREPARE TO SET THE IGNORE BIT IN THIS DTB
	PUSHJ	P,DISCFE	;DISCONNECT IT FROM MPX CHANNEL IF ON
D.IGN1:	CAIN	T1,":"		;MORE ARGS TO COME?
	JRST	D.IGNR		;DO ANOTHER
	POPJ	P,


;/NOLISTEN:XY:XY:...:XY

D.NLSN:	CAIE	T1,":"		;MUST HAVE AN ARGUMENT
	USEROR	/NOLISTEN must have an argument
	PUSHJ	P,SETFE		;READ FE NUMBER
	MOVX	T2,DTFNLS	;REMEMBER NOT TO ADD TO MPX DEVICE
	PUSHJ	P,DISCFE	;DISCONNECT IF ON MPX
	CAIN	T1,":"		;ANY MORE FRONT ENDS?
	JRST	D.NLSN		;YES, DO ANOTHER
	POPJ	P,		;DONE WITH COMMAND


;HERE FOR /HELP

D.HELP:	MOVE	1,['DTELDR']
	PUSHJ	P,.HELPR##	;CALL HELPER

HELP1:	MOVEI	T1,"J"&37	;HAVE TO FOOL CMDFND INTO THINKING WE'RE AT END OF LINE
	SKPINL			;SEE IF AT END OF LINE YET
	 RETURN			; YES, WE ARE DONE
	PUSHJ	P,GETCHR	;NO--GET ANOTHER CHAR
	JRST	HELP1		;AND LOOP


DISCFE:	IORB	T2,DTBFLG(DT)	;IGNORE IT IN THE FUTURE
	TXNN	T2,DTFCTD	 ;HAVE WE BEEN USING IT?
	JRST	CPOPJ		;NO, NO NEED TO DISCONNECT IT
	MOVX	T2,DTFCTD	;NOTE THAT DL11 IS NO LONGER CONNECTED
	ANDCAM	T2,DTBFLG(DT)
	DMOVE	T2,[EXP T3, <.CNCDR,,MPX>]
	HRRZ	T4,DTBUDX(DT)	;SETUP TO DISCONNECT FROM MPX
	CNECT.	T2,		;TRY IT
	  JRST	CPOPJ		;ASSUME THAT DL11 WASN'T CONNECTED
	SOS	MPXCTD		;ONE LESS DEVICE ON MPX
	POPJ	P,
;/TALK OR /TALK:XY

D.TALK:	SETZM	A.TALK		;NOTE THAT THE TALK SWITCH WAS TYPED
	CAIN	T1,":"		;WERE CPU AND DTE SPECIFIED?
	PJRST	SETFE		;YES, READ THEM
	RETURN

;/RELOAD:XY

D.RELD:	CAIE	T1,":"		;VALUE GIVEN?
	USEROR	Must specify front end in /RELOAD
	SETZM	A.RELD		;INDICATE /RELOAD WAS TYPED
SETFE:	PUSHJ	P,GETOCT	;GET FE #
	IDIVI	T2,10		;CPU # IN T2, DTE # IN T3
	CAILE	T3,DTEMAX	;DTE CANNOT BE GREATER THAN 3
	USEROR	DTE number too large
	CAILE	T2,CPUMAX	;NOR CAN CPU BE GREATER THAN THIS
	USEROR	CPU number too large
	MOVEM	T2,A.CPU
	MOVEM	T3,A.DTE	;STORE
	PUSH	P,T1		;SAVE CHARACTER
	MOVE	T1,T2		;ORIENT ACS
	MOVE	T2,T3		;CPU, DTE IN T1,T2
	MOVE	DT,@DTBIDR(T1)	;INDEX VIA T1 AND T2
	MOVEM	DT,A.DTB	;REMEMBER DTB CURRENT COMMAND REFERENCES
	PJRST	T1POPJ		;RESTORE NEXT CHARACTER AND RETURN
;/NODUMP

D.NDMP:	SETZM	A.NDMP
	RETURN

;/IMAGE

D.IMAG:	SKIPL	A.A11		;WAS /A11 ALREADY SPECIFIED?
	 USEROR	<Cannot specify both /A11 and /IMAGE>
	SETZM	A.IMAG
	RETURN

;/A11

D.A11:	SKIPL	A.IMAG		;WAS /IMAGE ALREADY SPECIFIED?
	 USEROR	<Cannot specify both /A11 and /IMAGE>
	SETZM	A.A11		;NO, SET SWITCH ACCORDINGLY
	RETURN

;/SELECT

D.SEL:	CAIE	T1,":"		;BETTER BE VALUE COMING
	USEROR	<Must specify either 10 or 11 for /select>
	PUSHJ	P,GETOCT	;GET OCTAL NUMBER
	CAIE	T2,10		;MUST BE EITHER 10 (TEN)
	CAIN	T2,11		;OR 11 (ELEVEN)
	CAIA			;OK
	USEROR	<Only legal values for /SELECT are 10, 11>
	MOVEM	T2,A.SEL	;PLACE TO RELOAD FROM
	RETURN			;RETURN
;/TERMINATE

D.TERM:	CAIE	T1,":"		;SOMEONE TYPED /TERMINATE
	USEROR	Must specify front end in /TERMINATE
	SETZM	A.TERM		;/TERMINATE TYPED.
	JRST	SETFE		;GO SET CPU AND DTE NUMBERS


;/AUTOMATIC

D.AUTO:	SETZM	A.AUTO
	RETURN


;/SWITCH:NUMBER

D.SWIT:	CAIE	T1,":"		;VALUE COMING?
	USEROR	Must specify switch value
	PUSHJ	P,GETOCT	;GET OCTAL NUMBER
	CAILE	T2,177777	;LEGAL?
	USEROR	Value for /SWITCH must not exceed 177777
	MOVEM	T2,A.SWIT	;SET THE VALUE
	RETURN			;EXIT.

;/NOLOG - DEFEATS ERROR LOGGING

D.NLOG:	SETZM	A.NLOG
	RETURN

;/INITIALIZE - STARTS PRIMARY PROTOCOL ON A FRONT END

D.STRP:	CAIE	T1,":"		;VALUE COMING?
	USEROR	Must specify front end number for /INITIALIZE
	SETZM	A.INIT		;SAY THAT ITS BEEN TYPED
	JRST	SETFE		;SET UP STUFF AND RETURN


;/START:# - SET -11'S START ADDRESS

D.STRT:	CAIE	T1,":"		;NEED A VALUE
	USEROR	Must specify address for /START
	PUSHJ	P,GETOCT	;GET IT
	TDNE	T2,[-1,,600001]	;LEGAL -11 WORD ADDRESS?
	USEROR	Illegal address for /START
	JRST	SVSTRT		;SAVE AND RETURN


;/LOAD - ONLY LOAD -11, DON'T START

D.LOAD:	MOVEI	T2,1		;SUPPLY FROM10 WITH ILLEGAL ADDRESS
SVSTRT:	MOVEM	T2,A.STRT	;SAVE IT
	RETURN			;AND RETURN
;/ASWITCH

D.ASWT:	CAIE	T1,":"		;CHECK TO MAKE SURE THAT A FE SPEC FOLLOWS
	USEROR	Must specify a front end in /ASWITCH
	PUSHJ	P,GETOCT	;GET FE SPEC (CPU AND DTE)
	IDIVI	T2,10		;T2 := CPU, T3 := DTE
	CAILE	T3,DTEMAX	;IS THE DTE NUMBER REASONABLE
	USEROR	DTE number to large in /ASWITCH
	CAILE	T2,CPUMAX	;CHECK THE CPU NUMBER
	USEROR	CPU number to large in /ASWITCH
	IMULI	T3,DTEMAX+1	;MAKE CPU "MORE SIGNIFICANT" THAN DTE
	ADD	T3,T2		;ADD IN THE DTE'S OFFSET
	CAIE	T1,":"		;CHECK TO MAKE SURE THAT SWITCH VALUE FOLLOWS
	USEROR	Must specifiy a value for /ASWITCH
	PUSHJ	P,GETOCT	;GET THE VALUE FOR THE SWITCHES
	CAILE	T2,ONES11	;SEE IF THE VALUE IS REASONABLE
	USEROR	Value for /ASWITCH must not exceed 177777.
	MOVEM	T2,SWTBLK(T3)	;REMEMBER THE DEFAULT SWITCH VALUE
	RETURN			;/ASWITCH PROCESSED
	;/PROTOCOL:  one of ANF, IBM, or DECNET

D.PROT:	PUSHJ	P,FNDPRO	;GO GET PROTOCOL ARGUMENT
	MOVEM	T2,A.PROT	;MUST BE VALID, WE GOT HERE AFTERALL
	RETURN

;/APROTOCOL:fe: one of IBM, ANF, or DECNET

D.APRO:	PUSHJ	P,SETFE		;READ IN THE FE SPEC
	PUSHJ	P,FNDPRO	;GO GET THE PROTOCOL TYPE
	MOVEM	T2,DTBPRO(DT)	;STUFF IT
	RETURN

FNDPRO:	CAIE	T1,":"		;DO WE HAVE AN ARGUMENT?
FNDPR1:	 USEROR	 Must specify protocol type in /PROTOCOL or /APROTOCOL
	PUSHJ	P,GETNAM	;GET THE PROTOCOL TYPE
	JUMPE	T2,FNDPR1	;BLANK NAMES ARE ILLEGAL
	PUSH	P,T1		;SAVE TERMINATOR
	MOVE	T1,[IOWD PROTBL,PROTAB]	;GET POINT TO PROTOCOL TABLE
	PUSHJ	P,.LKNAM##	;LOOK FOR THE NAME
	 JRST	 [SKIPL	T1	;NO MATCH? OR NON-UNIQUE?
		   USEROR Non-Unique protocol name
		   USEROR Unknown protocol name]
	MOVE	T2,(T1)		;GET FULL PROTOCOL NAME
	CAMN	T2,ANFLBL	;IS IT ANF?
	 HRLZI	 T2,'ANF'	; YES, MUST REALLY USE THIS
	CAMN	T2,RSXLBL	;OR RSX20F?
	MOVE	T2,PROTAB	;YES--HE'S A NON-PERSON
	POP	P,T1		;RESTORE TERMINATOR
	RETURN

PROTAB:
	SIXBIT	/NOBODY/
ANFLBL:	SIXBIT	/ANF10/
	SIXBIT	/IBM/
	SIXBIT	/DECNET/
RSXLBL:	SIXBIT	/RSX20F/
	PROTBL==.-PROTAB


;/DETACH - DETACH THIS JOB WHEN WE GO INTO AUTOMATIC MODE

D.DETACH:
	SETZM	A.DETA		;JUST SET A FLAG
	RETURN			;AND RETURN
GETNAM:	MOVE	T3,[POINT 6,T2]
	MOVEI	T2,0		;CLEAR NAME
GETNM1:	PUSHJ	P,GETCHR	;GET NEXT CHAR
	CAIL	T1,"A"+40	;SEE IF LC
	CAILE	T1,"Z"+40
	JRST	.+2
	SUBI	T1,40		;YES--MAKE UC
	CAIL	T1,"0"		;SEE IF BREAK
	CAILE	T1,"Z"		; ..
	RETURN
	CAILE	T1,"9"		;OR OK
	CAIL	T1,"A"
	JRST	.+2
	RETURN
	SUBI	T1,40		;CONVERT TO SIXBIT
	TLNE	T3,770000	;SEE IF OVERFLOW
	IDPB	T1,T3		;STORE RESULT
	JRST	GETNM1		;LOOP FOR MORE

GETOCT:	MOVEI	T2,0		;CLEAR RESULT
GETOC1:	PUSHJ	P,GETCHR	;GET NEXT ODGIT
	CAIL	T1,"0"		;SEE IF
	CAILE	T1,"7"		; BREAK
	RETURN
	LSH	T2,3		;MULT BY 8
	ADDI	T2,-"0"(T1)	;INCLUDE ODGIT
	JRST	GETOC1		;LOOP

GETCHR:	INCHWL	T1		;GET NEXT CHARACTER
	JUMPE	T1,GETCHR	;LOOP IF NULL
	CAIE	T1,177		;IF RUB
	CAIN	T1,15		;OR CR
	JRST	GETCHR		;LOOP
	CAIL	T1,175		;IF ALTERNATE ALT MODE
	MOVEI	T1,33		; STANDARDIZE
	CAIN	T1,33		;IF ESCAPE
	MOVEI	T1,12		; MAKE INTO EOL
	CAIE	T1,13		;IF VTAB
	CAIN	T1,14		; OR FORM
	MOVEI	T1,12		; MAKE INTO LF
	CAIN	T1,11		;SEE IF TAB
	MOVEI	T1," "		;YES, CHANGE TO SPACE
	RETURN
SUBTTL	RANDOM SUBROUTINES


;ROUTINE TO SET TIMLOC TO BE CURRENT TIME OF DAY PLUS C(T3),
;ACCOUNTING FOR MIDNIGHT. WHEN THAT TIME OCCURS, ISTIME CALLS WILL SKIP.

SETIME:	MSTIME	T2,
	ADD	T2,T3		;ARG
	MOVEM	T2,TIMLOC	;SAVE FOR ISTIME
CPOPJ:	RETURN


;ROUTINE TO SKIP IF ITS PAST THE INCREMENTAL TIME OF DAY AS
; SET BY SETIME.

ISTIME:	MSTIME	T3,
	SUB	T3,TIMLOC	;GET THE DIFFERENCE
	JUMPL	T3,[ADD T3,[JPERDA] ;WE WAN'T MOD FUNCTION,
		    JRST .]	; NOT REMAINDER.
	CAMG	T3,[JPERDA/2]	;IF IT'S A SMALL POSITIVE DIFFERENCE
	AOS	(P)		;THEN WE'RE PAST THE TIME TO WAKE UP
	RETURN			;RETURN
;ROUTINE TO TYPE OUT A FILE SPEC
TYPFIL:	PUSHJ	P,.SAVE1##	;SAVE A P
	MOVE	P1,T1		;PUT THE FILESPEC ADDR IN P1
	PUSH	P,T2		;SAVE A TEMP
	PUSH	P,T3		;  AND ANOTHER
	MOVE	T1,ERFSDV(P1)	;GET THE DEVICE
	PUSHJ	P,.TSIXN##	;  AND OUTPUT IT IN SIXBIT
	PUSHJ	P,.TCOLN##	;TYPE A SEPARATING COLON
	MOVE	T1,ERFSFN(P1)	;GET THE FILENAME
	PUSHJ	P,.TSIXN##	;  AND OUTPUT IT IN SIXBIT
	MOVEI	T1,"."		;TYPE A SEPARATING PERIOD
	PUSHJ	P,.TCHAR##	; . . .
	MOVE	T1,ERFSEX(P1)	;GET THE EXTENSION
	PUSHJ	P,.TSIXN##	;  AND OUTPUT THAT IN SIXBIT
	MOVEI	T1,"["		;OUTPUT THE OPEN SQUARE
	PUSHJ	P,.TCHAR##	;BLAH BLAH BLAH
	MOVE	T1,ERFSPN(P1)	;GET THE "P,,PN"
	PUSHJ	P,.TXWDW##	;TYPE IT OUT AS "P,PN"
	MOVEI	P1,ERFSSF(P1)	;GET THE ADDRESS OF THE FIRST SFD
	SKIPE	(P1)		;HAVE WE DONE ALL THE SFD'S YET?
	JRST	[PUSHJ P,.TCOMA## ;OUTPUT THE SEPARATOR FOR THE NEXT SFD
		 MOVE T1,(P1)	;GET THE SFD NAME
		 PUSHJ P,.TSIXN## ;  AND TYPE IT IN SIXBIT
		 AOJA P1,.-1]	;LOOP OVER ALL SFD'S
	PUSHJ	P,.TRBRK##	;OUTPUT THE CLOSING SQUARE
	JRST	RTN32		;CLEAN UP THE STACK AND WE'RE DONE
; Write to Operator routines

;Set up for doing WTO's by redirecting SCAN tty output
WTOSET:	PUSHJ	P,.PSH4T##	;SAVE SOME T'S
	MOVEI	T1,WTO		;GET ADDRESS OF TYPEOUT ROUTINE
	PUSHJ	P,.TYOCH##	;REDIRECT THE I/O TO ME
	SETOM	WTOFLG		;INDICATE WE ARE IN WTO MODE
	PJRST	WTOFL1		;SET UP BUFFERS AND RETURN

;WRITE TO OPERATOR
WTO1:	PUSHJ	P,WTOFLS	;FLUSH THE WTO BUFFER
WTO:	SOSGE	WTOCNT		;ANY ROOM LEFT IN THE BUFFER?
	 JRST	 WTO1		; NO, FLUSH THE BUFFER
	IDPB	T1,WTOPTR	;YES, STUFF THE CHARACTER
	RETURN

WTOFLS:	SKIPN	WTOFLG		;ARE WE IN WTO MODE?
	 POPJ	 P,		; NO, JUST RETURN
	PUSHJ	P,.PSH4T##	;SAVE ALL THE T'S
	SETZ	T1,		;CLEAR AN AC
	IDPB	T1,WTOPTR	;TIE OFF THE ASCIZ STRING
	MOVEI	T1,WTOLEN	;GET LENGTH OF WTO BUFFER
	SUB	T1,WTOCNT	;CALCULATE NUMBER OF BYTES SO FAR
	JUMPE	T1,WTOFL1	;JUST RETURN IF NOTHING TO OUTPUT
	MOVE	T1,QUEARG	;GET ARGUMENT FOR QUEUE.
	QUEUE.	T1,		;SEND THE TEXT TO OPR
	 JRST	 WTOTOP		; HMMM, GO DO A TRMOP.
WTOFL1:	MOVEI	T1,WTOLEN	;GET LENGTH OF WTO BUFFER
	MOVEM	T1,WTOCNT	;INSTALL IT
	MOVE	T1,[POINT 7,WTOBUF] ;GET POINTER TO WTO BUFFER
	MOVEM	T1,WTOPTR	;SET THAT UP TOO
	PUSHJ	P,.POP4T##	;RESTORE ALL THE T'S
	POPJ	P,		;AND RETURN

WTOTOP:	MOVSI	T1,'OPR'	;GET THE DEVICE NAME
	IONDX.	T1,		;GET IT'S UDX
	 HALT	 .		; WELL, WHAT CAN I DO!
	MOVEM	T1,TRMBLK+1	;STUFF IT
	MOVEI	T1,[ASCIZ |	-- |] ;GET LEADER
	MOVEM	T1,TRMBLK+2	;STUFF IT
	MOVE	T2,[3,,TRMBLK]	;GET ARG FOR TRMOP.
	TRMOP.	T2,		;TYPE OUT THE HEADER
	 HALT	 .
	MOVEI	T1,WTOHDR	;GET MAIN TEXT OF THE HEADER
	MOVEM	T1,TRMBLK+2	;STUFF IT
	TRMOP.	T2,		;TYPE OUT MAIN PART OF HEADER
	 HALT	 .		; ...
	MOVEI	T1,[ASCIZ | --
|]
	MOVEM	T1,TRMBLK+2	;STUFF IT
	TRMOP.	T2,		;TYPE OUT REST OF HEADER
	 HALT	 .
	MOVEI	T1,WTOBUF	;GET ADDRESS OF THE MEAT OF THE MESSAGE
	MOVEM	T1,TRMBLK+2	;STUFF IT
	TRMOP.	T2,		;FINALLY!  OUTPUT IT
	 HALT	 .
	JRST	WTOFL1		;RESET POINTERS, AND CONTINUE

QUEARG:	XWD	QUELEN,QUEBLK	;AC FOR QUEUE.
QUEBLK:	EXP	.QUWTO		;FUNCTION IS "WRITE TO OPERATOR"
	EXP	0		;WRITE TO THE CENTRAL SITE
	XWD	0,0		;NO RESPONSE
	XWD	WTOHLN,.QBTYP	;GET TITLE LINE
	EXP	WTOHDR		;ADDRESS OF TITLE LINE
	XWD	WTOBLN,.QBMSG	;WTO MESSAGE
	EXP	WTOBUF		;ADDRESS OF SECONDARY ARG BLOCK
	QUELEN==.-QUEBLK

WTOHDR:	ASCIZ	|Message from DTELDR|
	WTOHLN==.-WTOHDR
TELLCX:	PUSH	P,T1		;CALLED WITH T1/ADDR OF STRING TO PRINT
	MOVEI	T1,[ASCIZ\" \]	;START WITH BATCH ATTENTION CHARACTER
	PUSHJ	P,.TSTRG##	;TYPE IT OUT
	PUSHJ	P,TYPFE		;SAY WHO WE ARE DOING IN
	POP	P,T1		;RECOVER TEXT TO PRINT
	PJRST	.TSTRG##	;PRINT IT


TYPFEC:	PUSHJ	P,TYPFE		;PRINT TWO CHARACTER ID OF FE
	PJRST	.TCRLF##	;FINISH IT OFF WITH A <CRLF>

TYPFE:	MOVEI	T1,[ASCIZ\front end \] ;GET BANNER
	PUSHJ	P,.TSTRG##	;TYPE IT OUT
	MOVEI	T1,DTBID(DT)	;PRINT 2 CHARACTER ID
	PJRST	.TSTRG##	;. . .


HIBSEC:	DMOVE	T1,[EXP ^D1000,1]
	TXNN	F,F.TOPN	;IF TTX CHANNEL IS OPEN,
	SKIPE	MPXCTD		;OR IF DEVICES ARE ON MPX,
	TXO	T1,HB.RTC!HB.RIO ;THEN WAKEUP EARLY ON TTY ACTIVITY
	HIBER	T1,
	  SLEEP	T2,		;HIBER SHOULDN'T FAIL!
	POPJ	P,


SAVE1:	EXCH	P1,(P)		;STANDARD SAVE ROUTINE
	HRLI	P1,(P)
	PUSHJ	P,[JRA P1,(P1)]
	POP	P,P1
	POPJ	P,

T1POPJ:	POP	P,T1
	POPJ	P,
	SUBTTL	ERROR HANDLING ROUTINES

; THIS ROUTINE IS INVOKED ONLY VIA THE WARN, WARNC, WARNCR, AND JWARN MACROS.

WRNRTN:	PUSHJ	P,.PSH4T##		; Save T1-T4
	MOVEI	T1,[ASCIZ |% |]		; Get normal prefix
	PUSHJ	P,.TSTRG##		; Print it out

	MOVE	T3,@-4(P)		; Get the instruction after PUSHJ to us
	MOVE	T1,T3			; Get address of message
	LDB	T4,[POINT 9,T3,8]	; Get the opcode
	CAIE	T4,JUMP_-^D27		; Is it a jump?
	 JRST	 WRNRT1			;  No, go see if WARNC

	TLNE	T3,(1B11)		; Is it JWARN?
	 HRRZ	 T1,(T1)		;  Yes, address is pointed to by JUMP
	PUSHJ	P,.TSTRG##		; Type out the message

	TLNN	T3,(1B12)		; Suppressing CRLF?
	 PUSHJ	 P,.TCRLF##		;  No, tie it off with a CRLF

	HLRZ	T1,(T3)			; Get address of routine to jump to
	TLNE	T3,(1B11)		; Was a jump address supplied?
	 MOVEM	 T1,-4(P)		;  Yes, make that the new return addr
	PUSHJ	P,.POP4T##		; Restore the world
	POPJ	P,

; Here for WARNC

WRNRT1:	PUSHJ	P,.TSTRG##		; Type out the warning
	PUSHJ	P,.TSPAC##		; Type a space
	LDB	T1,[POINT 4,T3,12]	; Get AC
	MOVEM	T1,MEMTMP		; Put it in a safe place
	DMOVE	T1,-3(P)		; Restore T1 and T2
	DMOVE	T3,-1(P)		; Restore T3 and T4
	MOVE	T1,@MEMTMP		; Get the value we need
	PUSHJ	P,.TOCTW##		; Type it out
	PUSHJ	P,.TCRLF##		; Type a <CRLF>
	PUSHJ	P,.POP4T##		; Restore the world
	POPJ	P,			; And return

ERRRTN:	PUSHJ	P,.PSH4T##		; Save everything in case of ERRORC
	MOVEI	T1,[ASCIZ |? |]		; Get prefix
	PUSHJ	P,.TSTRG##		; Type it out
	MOVE	T1,@-4(P)		; Get instruction following PUSHJ
	PUSHJ	P,.TSTRG##		; Type out the message
	MOVE	T1,@-4(P)		; Get inst following PUSHJ (again)
	LDB	T2,[POINT 9,T1,8]	; Get opcode
	CAIE	T2,JUMP_-^D27		; Is it a JUMP?
	 JRST	 ERRRT1			;  No, must be ERRORC
	ADJSP	P,-4			; Remove AC's from the stack
ERRRT2:	PUSHJ	P,.TCRLF##		; Finish off with a <CRLF>
	ADJSP	P,-1			; Remove PUSHJ from the stack
	TLNE	T1,(1B12)		; Should we go to STARTE?
	 JRST	 STARTE			;  Yes, go to STARTE
	JRST	ERRXIT			; No, ERRXIT

ERRRT1:	LDB	T1,[POINT 4,T1,12]	; Get AC #
	MOVEM	T1,MEMTMP		; Save it in memory
	PUSHJ	P,.TSPAC##		; Type a space before the number
	PUSHJ	P,.POP4T##		; Restore all the AC's
	MOVE	T1,@MEMTMP		; Get the value
	PUSHJ	P,.TOCTW##		; Type it out
	SETZ	T1,			; Clear T1
	JRST	ERRRT2			; And finish off the line

	SUBTTL	DTE ERROR MESSAGES

; THIS LIST CONTAINS ONLY THE ERROR CODES THAT PERTAIN TO DTELDR, OR THE USERS
; OF THIS PROGRAM.  ERRORS WHICH ARE NOT LISTED HERE SHOULD NEVER BE CAUSED BY
; THIS PROGRAM, AND WILL RESULT IN A STOPCODE.

	DTUEMX==DTEIP%	; Maximum error code as of 7.02

	DEFINE	XX (CODE, TEXT)<
	XWD	CODE,[ASCIZ |TEXT|]
	>

DTUERM:
;	XX	0,DTE. UUO not implemented in this monitor
	XX	DTENP%,Must have privileges to run DTELDR
;	XX	DTEUF%,DTE. uuo called with bad function number
	XX	DTEDC%,Bad front end number
	XX	DTEAP%,Primary protocol still running
	XX	DTEPT%,PDP-11 Power fail did not set
	XX	DTEDE%,PDP-11 Rom failed to start - check halt switch
	XX	DTTTE%,To-10 error during bootstrap sequence
	XX	DTEDD%,PDP-11 program failed to send To-10 doorbell
;	XX	DTEIJ%,Bad job number given to DTE. UUO
	XX	DTESE%,Failed to start primary protocol
	XX	DTEWU%,DTELDR is not the owner of the DTE
	DTUMLN==.-DTUERM
; The following message MUST follow this table immediately because DTUERR
; expects it to be here.
	XX	0,Unexpected error code from DTE. UUO
SUBTTL STORAGE
	XLIST	;LITERALS
	LIT
	LIST

	RELOC

CCINT:	BLOCK	2		;^C INTERCEPT BLOCK
CCINTP:	BLOCK	2


MPXIHD:	BLOCK	4		;MPX HEADER (IF WE USE IT)
MPXBUF:	BLOCK	1		;POINTER TO MPX BUFFER RING
TTXIHD:	BLOCK	4		;TTX BUFFER HEADER (FAKE IT TO LOOK LIKE MPX CHAN)
TTXBUF:	BLOCK	1		;POINTER TO TTX BUFFER RING
MPXCTD:	BLOCK	1		;NUMBER OF DEVICES ON MPX CHANNEL (NEEDED
				; BECAUSE INPUT ON MPX WITH NO DEVICES LOSES BIG)
SWTBLK:	BLOCK	<CPUMAX+1>*<DTEMAX+1>	;PLACE FOR /ASWITCH VALUES TO GO.
MEMTMP:	BLOCK	1		;TEMP LOC USED FOR EVALUATING EA'S

FWAONE:!			;START OF AREA TO PRESET TO -1
A.CPU:	BLOCK	1		;CPU NUMBER OF FRONT END
A.DTE:	BLOCK	1		;DTE NUMBER (0-3) OF FRONT END
A.DTB:	BLOCK	1		;DTB REFERED TO BY A.CPU AND A.DTE
A.AUTO:	BLOCK	1		;/AUTO
A.NDMP:	BLOCK	1
A.TERM:	BLOCK	1
A.IMAG:	BLOCK	1
A.A11:	BLOCK	1
A.TALK:	BLOCK	1
A.RELD:	BLOCK	1
A.SEL:	BLOCK	1
A.SWIT:	BLOCK	1		;/SWITCH VALUE
A.NLOG:	BLOCK	1	
A.INIT:	BLOCK	1		;/INITIALIZE
A.STRT:	BLOCK	1
A.DETA:	BLOCK	1		;/DETACH
LWAONE==.-1			;END OF AREA TO PRESET TO -1
;TEMPORARY DATA AREA.  ZEROED AFTER EVERY LOAD/DUMP OPERATION


FWAZER:!			;START OF AREA TO CLEAR
DEV:	BLOCK	1		;DEVICE
NAME:	BLOCK	1		;FILE NAME
EXT:	BLOCK	1		;FILE EXTENSION,,-1 IF . SEEN
DIRECT:	BLOCK	1		;DIRECTORY
DIRPTH:	BLOCK	9		;SFD PATH

NUMSWT:	BLOCK	1		;NUMBER OF SWITCHES TYPED

INBUF:	BLOCK	<INLEN==200>
INHDR:	BLOCK	3		;INPUT HEADER
				;  (NOTE THAT WE REALLY USE DUMP MODE)
OUTHDR:	BLOCK	3		;OUTPUT HEADER
MASTER:	BLOCK	1		;SET TO -1 IF DTE WE'RE DOING IS MASTER
TIMLOC:	BLOCK	1		;LOCATION USED BY SETIME/ISTIME
HIBTIM:	BLOCK	1		;IF NON-ZERO, CAUSES THE NEXT "HIBER" TO
				;  SLEEP FOR THIS MANY MS.
				;  USED BY DL-11 ROUTINES
RETRYC:	BLOCK	1		;TEMPORARY, PER EVENT, RETRY COUNTER
RTRYPC:	BLOCK	1		;PC TO JRST THRU TO RETRY AN OPERATION
FAILPC:	BLOCK	1		;PC TO JRST THRU WHEN ALL RETRIES FAIL
ERRORP:	BLOCK	1		;STACK POINTER TO BACKUP TO ON ERROR
ADDRES:	BLOCK	1
CHKSUM:	BLOCK	1		;RUNNING CHECKSUM
LASZER:	BLOCK	1		;LAST ..

;IMPURE AREA FOR DAEMON ERROR REPORTING
ERRWRD:	BLOCK	1		;LIST OF BITS DESCRIBING VARIOUS ERRORS
ERRFZR:				;FIRST WORD TO CLEAR WHEN STARTING TO
				;  LOG A LOAD/DUMP
ERRFCN:	BLOCK	1		;DAEMON FUNCTION CODE
ERRCOD:	BLOCK	1		;SYSERR ERROR TYPE CODE
ERRBLK:				;BLOCK OF DATA FOR SYSERR
ERRTRG:	BLOCK	1		;TARGET NODE
ERRSER:	BLOCK	1		;SERVER NODE
ERRSLD:	BLOCK	1		;SERVER LINE DESIGNATOR
ERRFIL:	BLOCK	1		;POINTER TO THE FILE SPEC
ERRRET:	BLOCK	1		;NSP STYLE RETURN CODE
ERRPRG:	BLOCK	1		;POINTER TO THE PROG NAME AND USER
ERRVAL:	BLOCK	1		;36 BIT VALUE TO BE PRINTED BY SYSERR
ERRFRE:	BLOCK	100		;LOTS MORE ROOM FOR THE DATA.
SYSNAM:	BLOCK	10		;AREA TO STORE THE SYSTEM'S NAME INTO
ERRLZR==.-1			;LAST WORD TO ZERO IN THE ERROR BLOCK
LODFIL:	BLOCK	ERFSLN		;FILESPEC FOR FILE THAT WAS LOADED
DMPFIL:	BLOCK	ERFSLN		;FILESPEC FOR FILE THAT WAS DUMPED
A.PROT:	BLOCK	1		;/PROTOCOL:...
LWAZER==.-1			;END OF AREA TO CLEAR

;PERMANENT DATA-BASE.  CLEARED ONLY ON A RESTART.

FPDZER:				;FIRST "PERMANENT" WORD TO ZERO
PDLST:	BLOCK	PDSIZ+1
DEFDEV:	BLOCK	1		;LH: DEFAULT SOURCE DEVICE
				;RH: DEFAULT DUMP DEVICE
RETRYT:	BLOCK	1		;TOTAL COUNT OF RETRYS FOR DUMPS/LOADS 
BASEAD:	BLOCK	1		;EVA OF THIS PROGRAM AFTER LOCKED IN EVM
ATOFLG:	Z			;PERMANENT FLAG, CLEARED ONLY ON MANUAL
				; RESTART, SAYS DTELDR IS IN /AUTO MODE
DMPFLG:	Z			;PERMANENT FLAG USED TO SPECIFY ON /AUTO
				;WHETHER OR NOT DUMPS WILL BE TAKEN.
WTOFLG:	BLOCK	1		;WE ARE IN "WTO" MODE
LPDZER==.-1			;LAST "PERMANENT" WORD TO ZERO.
;DTE BLOCK DEFNITIONS AND STORAGE

DEFINE	CONC(A,B,C,D)<A'B'C'D>

DEFINE	DEFDTE(CPU,DTE)<
DTB'CPU'DTE:	PHASE	0
DTBFLG:!BLOCK	1		;;FLAGS
DTBDSC:!CPU,,DTE		;;PARAMETER WORD FOR DTE. UUO
DTBID:!	ASCIZ\CPU'DTE\		;;ASCII TEXT OF FE NAME
DTBUDX:!BLOCK	1		;;UDX OF DL11 TTY OR CTY
DTBPTR:!BLOCK	1		;;POINTER TO LINE BUFFER WHERE TEXT IS HELD TIL CRLF
DTBCTR:!BLOCK	1		;;COUNT OF BYTES LEFT IN LINE BUFFER
DTBUTM:!BLOCK	1		;;UPTIME OF LAST CHARACTER RECEIVED FROM DL11 TTY
DTBTXT:!BLOCK	TXTLEN		;;LINE BUFFER
DTBPRO:!BLOCK	1		;;PROTOCOL TYPE FOR THIS DTE
DTBLEN:!DEPHASE
>

DTBSTR:!
ZZ1==0
REPEAT CPUMAX+1,<
XLIST				;;TERRIBLY UNINTERESTING
    ZZ2==-1
    REPEAT DTEMAX+1,<
	DEFDTE(\ZZ1,\<ZZ2==ZZ2+1>)
    >
    ZZ1==ZZ1+1
>
LIST
DTBEND:!

ZZ1==-1
DTBIDR:
REPEAT CPUMAX+1,<
	Z	DTBIDR+<CPUMAX+1>+<<ZZ1==ZZ1+1>>*<DTEMAX+1>(T2)
>
ZZ1==-1
REPEAT	CPUMAX+1,<
XLIST				;;JUST AS UNINTERESTING
    ZZ1==ZZ1+1
    ZZ2==-1
    REPEAT DTEMAX+1,<
	CONC(Z DTB,\ZZ1,\<ZZ2==ZZ2+1>)
    >
>
LIST
DTECNO:	CONO	(T1)
DTECNI:	CONI	T1
DTEDTO:	DATAO	T1
DTECSZ:	CONSZ	(T1)
DTECSO:	CONSO	(T1)
DTUBLK:	BLOCK	1		;FOR DTE. UUO
DTUDAT:	BLOCK	1		;SAME
DMPSIZ:	^D28*2000		;DUMP 28K OF 11 WORDS
DTEIOW:	DTEBUF-1		;COUNT FILLED IN AT DUMP TIME.
	Z
DTEBUF:	BLOCK	DTEBSZ		;BUFFER USED FOR TO-10 AND TO-11 TRANSFERS.

WTOLEN==^D1000			;NUMBER OF CHARACTERS IN WTO BUFFER
WTOBLN==<WTOLEN+1+4>/5		;LENGTH OF WTO BUFFER IN WORDS
WTOCNT:	EXP	WTOLEN		;NUMBER OF CHARACTERS BUFFER CAN HOLD
WTOPTR:	BLOCK	1		;BYTE POINTER TO WTOBUF
WTOBUF:	BLOCK	WTOBLN		;THE BUFFER ITSELF

TRMBLK:	EXP	.TOOUS		;TRMOP. ARG BLOCK FOR WHEN QUEUE. FAILS
	EXP	0
	EXP	0
;MACRO TO PACK PDP-11 WORDS IN -10 MEMORY:
DEFINE	WORD11(A)<
    IRP A,<
	IFN ZZ,<			;;IF NONZERO THEN WE ARE ON RIGHT HALF
	    EXP <ZZ!A>&<177777,,177777>	;;SO STORE IN MEMORY
	    ZZ==0			;;AND CHANGE STAT BACK TO LEFT HALF
	;> ZZ==1B0!<A>B17		;;ELSE SAVE LEFT WORD AND FORCE NONZERO
    >
>;DEFINE WORD11

RP4PRG:	ZZ==0				;INIT WORD11
	WORD11	<12700,0>		;RP4PRG:MOV	#0,R0
	WORD11	<12704,176700>		;	MOV	#RPEXP,R4
	WORD11	<12703,176710>		;	MOV	#RPEXP+10,R3
	WORD11	<12713,40>		;	MOV	#40,@R3
	WORD11	<10005>			;	MOV	R0,R5
	WORD11	<305>			;	SWAB	R5
	WORD11	<42705,177770>		;	BIC	#177770,R5
	WORD11	<110513>		;	MOVB	R5,@R3
	WORD11	<12701,2>		;10$:	MOV	#2,R1
	WORD11	<12714,23>		;20$:	MOV	#23,@R4
	WORD11	<32714,4000>		;	BIT	#DVA,@R4
	WORD11	<1771>			;	BEQ	10$
	WORD11	<5301>			;	DEC	R1
	WORD11	<1371>			;	BNE	20$
	WORD11	<137,173034>		;	JMP	173034
	WORD11	<0>			;FORCE LAST HALFWORD OUT

DTAPRG:	ZZ==0				;INIT WORD11
	WORD11	<12700,0>		;DTAPRG:MOV	#0,R0
	WORD11	<137,173034>		;	JMP	173034
	WORD11	<0>
DTEPRG:	ZZ==0				;PRIME WORD11
	WORD11	<403>			;LODDTE: SEE SOURCE BELOW
	WORD11	<0>
	WORD11	<14,0>
	WORD11	<12700,160000>
	WORD11	<12706,162>
	WORD11	<5740>
	WORD11	<12702,156>
	WORD11	<12703,45>
	WORD11	<14240>
	WORD11	<77302>
	WORD11	<10002>
	WORD11	<5742>
	WORD11	<110>

	WORD11	<240>
	WORD11	<32711,4000>		;LODBLK: SEE SOURCE BELOW
	WORD11	<1775>
	WORD11	<12711,2100>
	WORD11	<10261,177766>
	WORD11	<12761,27774,177762>
	WORD11	<105711>
	WORD11	<2376>
	WORD11	<11061,177766>
	WORD11	<11203>
	WORD11	<1410>
	WORD11	<5403>
	WORD11	<42703,50000>
	WORD11	<10361,177762>
	WORD11	<105711>
	WORD11	<2376>
	WORD11	<750>

	WORD11	<10261,177766>		;STRT11:
	WORD11	<12761,127777,177762>
	WORD11	<5003>
	WORD11	<77301>
	WORD11	<32710,1>
	WORD11	<1001>
	WORD11	<130>
	WORD11	<0>
	WORD11	<0>			;THIS 0 FORCES OUT THE LAST -10 WORD

	BLOCK	^D128-.+DTEPRG		;RESERVE SPACE DTE WILL READ
COMMENT\	;DTE LOADER SOURCE:
	.TITLE	DTELDR - PDP-11 SIDE OF DTE LOADING PROGRAM
	.SBTTL	RIC WERME, JULY 1976
;COPYRIGHT 1976 DIGITAL EQUIPMENT CORP., MAYNARD, MA. 01752

R0	=%0
R1	=%1
R2	=%2
R3	=%3
R4	=%4
R5	=%5
SP	=%6
PC	=%7

;DTE LOCATIONS AND BIT DEFINITIONS
TO11BC	=174416
 I	=100000			;INTERRUPT -10 AT END OF TO-11 XFER
 TO11BM	=20000			;BYTE MODE TRANSFERS
TO11AD	=174422
STAT	=174434
 TO11DB	=4000			;DOORBELL RINGING
 INT11C	=2000			;CLEAR DOORBELL FLAG
 DON11C	=100			;WE HAVE TO CLEAR TO11 DONE MANUALLY
;THIS PROGRAM EXPECTS THAT R1 IS SETUP WITH THE ADDRESS OF THE STATUS
;WORD FOR THE DTE THAT INITIATED THE RELOAD.

	.ASECT
.	=0			;DTE ROM WILL PUT THIS AT 0

LODDTE:	BR	10$		;BRANCH OVER BUS TRAP VECTOR
	.WORD	0		;SPACE FILLING
	.WORD	20$,0		;BUS TRAP FOR TOP OF MEMORY SEARCH
10$:	MOV	#160000,R0	;ONE WORD PAST TOP OF MEMORY
20$:	MOV	#LASTWD+4,SP	;WE NEED A LITTLE STACK
	TST	-(R0)		;THIS WORD HERE? IF NOT, BACK UP ONE
	MOV	#LASTWD,R2	;MOVE LOADER BOTTOM UP
	MOV	#LODLEN,R3	;# WORDS TO MOVE TO HIGH CORE
30$:	MOV	-(R2),-(R0)	;MOVE LOADER THERE (NOTE - HIGH WORD IS FREE)
	SOB	R3,30$		;DO REST
	MOV	R0,R2		;R2 WILL BE DATLEN, R0 WILL BE DATADR
	TST	-(R2)		;SO POINT IT THERE
	JMP	@R0		;JUMP TO HIGH CORE WHERE THE LOADER IS

DATLEN	=.-2			;BYTE COUNT OF DATA PORTION OF MESSAGE OR 0
FRSTWD:
DATADR:	NOP			;ADDRESS WHERE TO PUT DATA OR START ADDR
LODBLK:	BIT	#TO11DB,@R1	;IS -10 READY FOR US?
	BEQ	LODBLK		;NOT YET
	MOV	#INT11C!DON11C,@R1 ;YES, CLEAR BITS TO SEE THEM SET AGAIN LATER
	MOV	R2,TO11AD-STAT(R1) ;TRANSFER 4 BYTES TO GET WHERE TO PUT DATA
	MOV	#TO11BM!<-4&7777>,TO11BC-STAT(R1)
10$:	TSTB	@R1		;TO11DN SET YET?
	BGE	10$		;NOT YET, WAIT FOR IT
	MOV	@R0,TO11AD-STAT(R1) ;TRANSFER REST OF BLOCK STARTING HERE
	MOV	@R2,R3		;GET LENGTH OF BLOCK
	BEQ	STRT11		;A 0 MEANS START ADDRESS WAS XFERRED
	NEG	R3		;MAKE NEGATIVE # OF BYTES
	BIC	#^C<I!TO11BM!7777>,R3 ;MAKE IT LIKE WHAT DTE WANTS
	MOV	R3,TO11BC-STAT(R1) ;START TRANSFER
20$:	TSTB	@R1		;DONE YET?
	BGE	20$		;NO, WAIT
	BR	LODBLK		;YES, GET ANOTHER

STRT11:	MOV	R2,TO11AD-STAT(R1) ;NEED SAFE PLACE TO
	MOV	#I!TO11BM!7777,TO11BC-STAT(R1) ; XFER AN EXTRA BYTE TO SET DONE
	CLR	R3		;DELAY LONG ENOUGH FOR EVERYTHING TO
	SOB	R3,.		; SETTLE AND FOR THE -10 TO SEE TO11DN
	BIT	#1,@R0		;IF START ADDRESS IS ODD,
	BNE	20$		;THEN SIMPLY HALT
	JMP	@(R0)+		;GO TO START (THE + SAVES A WORD)
20$:	HALT			;NO START ADDRESS SPECIFIED

LASTWD	=.			;END OF PROGRAM FOR COPY LOOP
LODLEN	=.-FRSTWD/2	;# WORDS TO COPY TO HIGH CORE

	.END	LODDTE
\	;END DTE LOADER SOURCE
	END	USTART
