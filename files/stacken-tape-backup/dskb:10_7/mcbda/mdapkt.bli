
MODULE PACKET (					!Display RSX I/O packet
		IDENT = '003010',
		LANGUAGE (BLISS16, BLISS36)
		) =
BEGIN
!
!			  COPYRIGHT (c) 1977, 1978 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY: MCBDA - MCB Crash Dump Analyzer
!
! ABSTRACT:
!
!
! ENVIRONMENT: ANY
!
! AUTHOR: ALAN D. PECKHAM	, CREATION DATE:
!
! MODIFIED BY:
!
! 	Alan D. Peckham, 10-Jul-80: VERSION 3
! 01	- Update RSX symbol references
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    DMPDEV : NOVALUE,				!Display device name.
    PUTPKT : NOVALUE;				!

!
! INCLUDE FILES:
!

LIBRARY 'MDACOM';				!MDA common definitions.

LIBRARY 'RSXLIB';				!RSX definitions.

!
! MACROS:
!
!
! EQUATED SYMBOLS:
!
!	None
!
! OWN STORAGE:
!
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BITLS : NOVALUE,				!IDENTIFY BITS AND EDIT INTO ASCII
    BYTSM : NOVALUE,				!Identify byte and edit into ASCII
    GETBYT,					!Get a byte from the dump.
    GETWRD,					!Get a word from the dump.
    MAPAPR : NOVALUE;				!Set up mapping bias.

ROUTINE DMPDEV (BUF_PTR_ADR, PAT_PTR_ADR, PRM_LST_ADR_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! The next parameters are:
!	UCB_ADDRESS
!
! FORMAL PARAMETERS:
!
!	..BUF_PTR_ADR				!Pointer to output buffer.
!	..PAT_PTR_ADR				!Pointer to pattern string.
!	..PRM_LST_ADR_ADR			!Pointer to next parameter.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PRM_LST : REF VECTOR,
	BUF_PTR_INI,
	UCB_ADDRESS;

    PRM_LST = ..PRM_LST_ADR_ADR;
    UCB_ADDRESS = .PRM_LST [0];
    .PRM_LST_ADR_ADR = PRM_LST [1];
    BUF_PTR_INI = ..BUF_PTR_ADR;

    IF .UCB_ADDRESS NEQ 0
    THEN
	BEGIN

	LOCAL
	    DCB_ADDRESS,
	    UNIT;

	EXTERNAL ROUTINE
	    $CBOMG;

	DCB_ADDRESS = GETWRD (.UCB_ADDRESS + FL$OFFSET (U_DCB));
	CH$WCHAR_A (GETBYT (.DCB_ADDRESS + FL$OFFSET (D_NAM) + 0), .BUF_PTR_ADR);
	CH$WCHAR_A (GETBYT (.DCB_ADDRESS + FL$OFFSET (D_NAM) + 1), .BUF_PTR_ADR);
	UNIT = ((.UCB_ADDRESS - GETWRD (.DCB_ADDRESS + FL$OFFSET (D_UCB)))/GETWRD (.DCB_ADDRESS + FL$OFFSET (
		D_UCBL))) + GETBYT (.DCB_ADDRESS + FL$OFFSET (D_UNIT));
	$CBOMG (.BUF_PTR_ADR, .UNIT, 0);
	END;

    CH$DIFF (..BUF_PTR_ADR, .BUF_PTR_INI)
    END;					!End of DMPDEV

GLOBAL ROUTINE PUTPKT (LINES, PACKET_ADDRESS) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ADR,
	TCB_ADDRESS,
	HEADER_ADDRESS;

    TCB_ADDRESS = GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_TCB));
    HEADER_ADDRESS = GETWRD (GETWRD (.TCB_ADDRESS + FL$OFFSET (T_PCB)) + SYMBOL ('P.HDR'));
    PUTLN (.LINES, CH$ASCIZ ('	PACKET ADDRESS: %P  REQUESTOR: %2R  LUN: %M.  PRI: %M.  EFN: %M.'),
	.PACKET_ADDRESS, GETWRD (.TCB_ADDRESS + FL$OFFSET (T_NAM) + 0),
	GETWRD (.TCB_ADDRESS + FL$OFFSET (T_NAM) + 2),
	(GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_LN2)) + 2 - (.HEADER_ADDRESS + FL$OFFSET (H_LUN)))^-2,
	GETBYT (.PACKET_ADDRESS + FL$OFFSET (I_PRI)), GETBYT (.PACKET_ADDRESS + FL$OFFSET (I_EFN)));
    BEGIN

    LITERAL
	IO_KIL = 0^8,
	IO_WLB = 1^8,
	IO_RLB = 2^8,
	IO_ATT = 3^8,
	IO_DET = 4^8,
	IO_FNA = 10^8,
	IO_RNA = 11^8,
	IO_ENA = 12^8,
	IO_ACR = 13^8,
	IO_ACW = 14^8,
	IO_ACE = 15^8,
	IO_DAC = 16^8,
	IO_RVB = 17^8,
	IO_WVB = 18^8,
	IO_EXT = 19^8,
	IO_CRE = 20^8,
	IO_DEL = 21^8,
	IO_RAT = 22^8,
	IO_WAT = 23^8;

    LOCAL
	FUNCTION;

    BIND
	FCN_LIST = BYTE_LIST ((IO_KIL/256, 'IO.KIL'), (IO_WLB/256, 'IO.WLB'), (IO_RLB/256, 'IO.RLB'),
		(IO_ATT/256, 'IO.ATT'), (IO_DET/256, 'IO.DET'), (IO_FNA/256, 'IO.FNA'),
		(IO_RNA/256, 'IO.RNA'), (IO_ENA/256, 'IO.ENA'), (IO_ACR/256, 'IO.ACR'),
		(IO_ACW/256, 'IO.ACW'), (IO_ACE/256, 'IO.ACE'), (IO_DAC/256, 'IO.DAC'),
		(IO_RVB/256, 'IO.RVB'), (IO_WVB/256, 'IO.WVB'), (IO_EXT/256, 'IO.EXT'),
		(IO_CRE/256, 'IO.CRE'), (IO_DEL/256, 'IO.DEL'), (IO_RAT/256, 'IO.RAT'),
		(IO_WAT/256, 'IO.WAT'));

    PUTLN (0, CH$ASCIZ ('	DEVICE: %@  FUNCTION: %P  %@'), DMPDEV,
	GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_UCB)),
	(FUNCTION = GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_FCN))), BYTSM, FCN_LIST, .FUNCTION<8, 8>);
    END;

    IF (ADR = GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_IOSB) + 0)) NEQ 0
    THEN
	BEGIN
	MAPAPR (6, GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_IOSB) + 2));
	PUTLN (0, CH$ASCIZ ('	I/O STATUS BLOCK: %P  CONTENTS: %O, %O'), .ADR,
	    GETWRD (ADR = GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_IOSB) + 4)), GETWRD (.ADR + 2));
	END;

    IF (ADR = GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_AST))) NEQ 0
    THEN
	PUTLN (0,
	    CH$ASCIZ ('	AST ADDRESS: %P'), .ADR);

    PUTLN (0, CH$ASCIZ ('	PARAMETERS: %P  %P  %P  %P  %P  %P  %P  %P'),
	GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_PRM) + 0), GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_PRM) + 2),
	GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_PRM) + 4), GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_PRM) + 6),
	GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_PRM) + 8), GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_PRM) + 10),
	GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_PRM) + 12), GETWRD (.PACKET_ADDRESS + FL$OFFSET (I_PRM) + 14));
    END;					!End of PUTPKT

END						!End of module

ELUDOM
