MODULE DMC (					!Display the data base for a DMC11
		IDENT = '003010',
		LANGUAGE (BLISS16, BLISS36)
		) =
BEGIN
!
!			  COPYRIGHT (c) 1977, 1978 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY: MCBDA - MCB Crash Dump Analyzer
!
! ABSTRACT:
!
!	Dump the DMC11 system line data base.
!
! ENVIRONMENT: ANY
!
! AUTHOR: ALAN D. PECKHAM	, CREATION DATE: 29-SEP-78
!
! MODIFIED BY:
!
! 	Alan D. Peckham, 12-Aug-80: VERSION 3
! 01	- Update for MCB V3.0
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    DMCLN : NOVALUE,				!Display DMC11 system line data base.
    PUTCCBS : NOVALUE;				!Display a chain of CCBs.

!
! INCLUDE FILES:
!

LIBRARY 'MDACOM';				!MDA common definitions.

!
! MACROS:
!

MACRO
    GETBYT_SIGNED (ADR) =
	BEGIN
	LOCAL TEMP;
	TEMP=GETBYT(ADR);
	.TEMP<0,8,1>
	END %;

!
! EQUATED SYMBOLS:
!
!
! OWN STORAGE:
!
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BITLS : NOVALUE,				!Interpret bits into ASCII text.
    CNV18 : NOVALUE,
    GETBYT,					!Get a byte from the dump image.
    GETWRD,					!Get a word from the dump image.
    MAPAPR : NOVALUE,				!Map APR to block of memory.
    MEMDMP : NOVALUE,
    PUTCCB : NOVALUE,				!Display a CCB.
    SKIP : NOVALUE,
    VMADMP : NOVALUE;

EXTERNAL
    FLAGS : BITVECTOR [M_MAX_BITS];

GLOBAL ROUTINE DMCLN (LINE_BIAS, LINE_ADDRESS) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    IF SYMBOL_TABLE ('DMC')
    THEN
	BEGIN

	%if FALSE %then

	LOCAL
	    ADR;

	PUTLN (2, CH$ASCIZ ('DMC11 LINE # %O  ADDRESS: %P  CSR ADDRESS: %P'),
	    GETWRD (.LINE_ADDRESS + SYMBOL ('D.LINE')), .LINE_ADDRESS,
	    GETWRD (.LINE_ADDRESS + SYMBOL ('D.SEL0')));
	PUTLN (0, CH$ASCIZ ('  LONG TIMER - CURRENT: %O  INITIAL: %O'),
	    GETBYT (.LINE_ADDRESS + SYMBOL ('D.TIMR')), GETBYT (.LINE_ADDRESS + SYMBOL ('D.TIME')));

	IF (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.STAT'))) NEQ 0
	THEN
	    BEGIN

	    LITERAL
		STSTP = 1^0,			!STOP IN PROGRESS
		STDIS = 1^1,			!DISABLE IN PROGRESS
		STMC = 1^7;			!DMC MICRO-PROCESSOR IS STOPPED

	    BIND
		LINE_STAT = BITS_LIST (('STSTP', 'STOP'), ('STDSC', 'DISCONNECT'), ('STDIS', 'DISABLE'));

	    PUTLN (0, CH$ASCIZ ('  PENDING FUNCTIONS: %@'), BITLS, LINE_STAT, .ADR)
	    END;

	IF (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.ERRS'))) NEQ 0
	THEN
	    BEGIN

	    BIND
		LINE_ERRS = BITS_LIST ('CE.ABO', 'CE.DIS', 'CE.ERR', 'CE.MOP', 'CE.RTE', 'CE.SRC', 'CE.TMO');

	    PUTLN (0, CH$ASCIZ ('  PENDING ERROR: %@'), BITLS, LINE_ERRS, .ADR)
	    END;

	IF DEFINED (ADR = SYMBOL ('D.LOGG'))
	THEN

	    IF (ADR = GETWRD (.LINE_ADDRESS + .ADR)) NEQ 0
	    THEN
		PUTLN (0,
		    CH$ASCIZ ('  EVENT LOGGING WORD: %P'), .ADR);

	PUTLN (0, CH$ASCIZ ('  THERE ARE %M. RECEIVE BUFFERS ASSIGNED OUT OF %M.'),
	    (ADR = -GETBYT_SIGNED (.LINE_ADDRESS + SYMBOL ('D.RBFC'))) + GETBYT_SIGNED (.LINE_ADDRESS + SYMBOL
		('D.RAQC')), .ADR);
	PUTLN (0, CH$ASCIZ ('  THERE ARE %M. TRANSMIT BUFFERS ASSIGNED OUT OF %M.'),
	    (ADR = -GETBYT_SIGNED (.LINE_ADDRESS + SYMBOL ('D.XBFC'))) + GETBYT_SIGNED (.LINE_ADDRESS + SYMBOL
		('D.XAQC')), .ADR);
	BEGIN

	BIND
	    D_PLEX = SYMBOL ('D.PLEX');

	DEVCHA (GETWRD (.LINE_ADDRESS + D_PLEX + 0), GETWRD (.LINE_ADDRESS + D_PLEX + 2))
	END;
	BEGIN
	PUTLN (1, CH$ASCIZ ('  STATISTICS COUNTERS -    TIME WHEN ZEROED: %P'),
	    GETWRD (.LINE_ADDRESS + SYMBOL ('D.TLZ'))^1);
	PUTLN (0, CH$ASCIZ ('%4SBLOCKS RECEIVED: %M.,  SENT: %M.'),
	    GETWRD (.LINE_ADDRESS + SYMBOL ('D.RCV')), GETWRD (.LINE_ADDRESS + SYMBOL ('D.XMT')));
	MAPAPR (6, GETWRD (.LINE_ADDRESS + SYMBOL ('D.LBIA')));
	ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.LVA'));
	PUTLN (0, CH$ASCIZ ('%4SNAKS RECEIVED: %M.'), GETBYT (.ADR + 5));
	PUTLN (0, CH$ASCIZ ('%4SNAKS SENT -'));
	PUTLN (0, CH$ASCIZ ('%6SNO BUFFER AVAILABLE: %M.'), GETBYT (.ADR + 6));
	PUTLN (0, CH$ASCIZ ('%6SBAD HEADER CRC: %M.'), GETBYT (.ADR + 7));
	PUTLN (0, CH$ASCIZ ('%6SBAD DATA CRC: %M.'), GETBYT (.ADR + 8));
	PUTLN (0, CH$ASCIZ ('%4SREPS RECEIVED: %M.,  SENT: %M.'), GETBYT (.ADR + 9), GETBYT (.ADR + 10));
	END;

	IF .FLAGS [M_CEX_DUMP]
	THEN
	    BEGIN
	    PUTLN (1, CH$ASCIZ ('%4SLINE TABLE:'));
	    SKIP (1);
	    VMADMP (0, .LINE_ADDRESS, .LINE_ADDRESS + SYMBOL ('D.LEN'));
	    END;

	BEGIN

	LOCAL
	    BIAS;

	PUTLN (1, CH$ASCIZ ('  DMC BASE TABLE BIAS: %P  ADDRESS: %P'),
	    (BIAS = GETWRD (.LINE_ADDRESS + SYMBOL ('D.LBIA'))),
	    (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.LVA'))));

	IF .FLAGS [M_CEX_DUMP]
	THEN
	    BEGIN

	    LOCAL
		LOW_PHYSICAL : VECTOR [2],
		HIGH_PHYSICAL : VECTOR [2];

	    CNV18 (LOW_PHYSICAL, .ADR, .BIAS);
	    CNV18 (HIGH_PHYSICAL, .ADR + 64*2, .BIAS);
	    SKIP (1);
	    MEMDMP (LOW_PHYSICAL, LOW_PHYSICAL, HIGH_PHYSICAL);
	    END;

	END;

	IF (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.RASQ'))) NEQ 0
	THEN
	    BEGIN
	    PUTLN (1, CH$ASCIZ ('%4STHERE ARE RECEIVE CCBS IN THE DMC QUEUE:'));
	    FLAGS [M_BUF] = 0;
	    PUTCCBS (1, .ADR, 0)
	    END;

	IF (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.RAWQ'))) NEQ 0
	THEN
	    BEGIN
	    PUTLN (1, CH$ASCIZ ('%4STHERE ARE RECEIVE CCBS WAITING FOR THE DMC:'));
	    FLAGS [M_BUF] = 0;
	    PUTCCBS (1, .ADR, 0)
	    END;

	IF (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.XASQ'))) NEQ 0
	THEN
	    BEGIN
	    PUTLN (1, CH$ASCIZ ('%4STHERE ARE TRANSMIT CCBS IN THE DMC QUEUE:'));
	    FLAGS [M_BUF] = 1;
	    PUTCCBS (1, .ADR, 0)
	    END;

	IF (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.XAWQ'))) NEQ 0
	THEN
	    BEGIN
	    PUTLN (1, CH$ASCIZ ('%4STHERE ARE TRANSMIT CCBS WAITING FOR THE DMC:'));
	    FLAGS [M_BUF] = 1;
	    PUTCCBS (1, .ADR, 0)
	    END;

	IF (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.CFNC'))) NEQ 0
	THEN
	    BEGIN
	    PUTLN (1, CH$ASCIZ ('%4SCURRENT CONTROL CCB:'));
	    FLAGS [M_BUF] = 0;
	    PUTCCB (1, .ADR, 0)
	    END;

	IF (ADR = GETWRD (.LINE_ADDRESS + SYMBOL ('D.PFNC'))) NEQ 0
	THEN
	    BEGIN
	    PUTLN (1, CH$ASCIZ ('%4STHERE ARE PENDING CONTROL CCBS:'));
	    FLAGS [M_BUF] = 0;
	    PUTCCBS (1, .ADR, 0)
	    END;

	%else NO_OPERATION %fi

	END;					!End of DMCLN

ROUTINE PUTCCBS (LINES, ADR, FORMATTER) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    IF .ADR NEQ 0
    THEN
	BEGIN

	LOCAL
	    CCB_COUNT;

	CCB_COUNT = CEX_MAX_CCB;

	DO

	    IF (CCB_COUNT = .CCB_COUNT - 1) LSS 0
	    THEN
		EXITLOOP (PUTLN (1,
			CH$ASCIZ (WARNING, 'TOO MANY CCBS')))
	    ELSE
		PUTCCB (.LINES, .ADR, .FORMATTER)

	WHILE (ADR = GETWRD (.ADR)) NEQ 0;

	END;					!End of PUTCCBS

END						!End of module

ELUDOM
