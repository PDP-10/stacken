
MODULE RSX (					!DISPLAY RSX11 EXEC INFO
		IDENT = '003010',
		LANGUAGE (BLISS16, BLISS36)
		) =
BEGIN
!
!
!
! COPYRIGHT (C) 1979 BY
! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
! COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY: MDA
!
! ABSTRACT:
!
!
! THIS MODULE CONTAINS THE RSX11 DATA BASE ANALYSIS ROUTINES
!
!
! ENVIRONMENT: ANY
!
! AUTHOR: ALAN D. PECKHAM, CREATION DATE: 15-AUG-78
!
! MODIFIED BY:
!
!	Alan D. Peckham, 10-Jul-80: VERSION 3
! 01	- Update RSX symbol references.
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    DMPLBN : NOVALUE,				!Display two-word logical block number.
    POOL : NOVALUE,				!Display the RSX pool.
    RSX : NOVALUE,				!Display the RSX data base.
    WINDOW : NOVALUE;				!Display a window of memory.

!
! INCLUDE FILES:
!

LIBRARY 'MDACOM';				!MDA COMMON DEFINITIONS

LIBRARY 'RSXLIB';				!RSX definitions.

!
! MACROS:
!
!
! EQUATED SYMBOLS:
!
!BIND
!    FMASK_BITS = BITS_LIST ('FE.EXT', 'FE.MUP', 'FE.EXV', 'FE.DRV', 'FE.PLA', 'FE.CAL', 'FE.PKT', 'FE.EXP',
!	    'FE.MXT', 'FE.NLG');
!
! OWN STORAGE:
!
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BITLS : NOVALUE,				!Display list of names for bits that are on.
    BYTLS : NOVALUE,				!Display value name as part of list.
    BYTSM : NOVALUE,				!Display value name.
    FILDT : NOVALUE,				!Convert file creation date to ASCII.
    FILNM : NOVALUE,				!Convert file name to ASCII.
    GETBYT,					!GET BYTE FROM DUMP FILE
    GETWRD,					!GET WORD FROM DUMP FILE
    MAPAPR : NOVALUE,				!SET MAPPING REGISTER
    MAPKNL : NOVALUE,				!Map to kernel space.
    MAPTSK,					!Map to given task.
    SBTTL : NOVALUE,				!SET LIST FILE SUB-TITLE
    SKIP : NOVALUE,				!Put a blank line on the listing file.
    VMADMP : NOVALUE,
    $CBTA;

EXTERNAL
    FLAGS : BITVECTOR [M_MAX_BITS];

GLOBAL ROUTINE RSX : NOVALUE = 			!DISPLAY RSX EXEC DATA

!++
! FUNCTIONAL DESCRIPTION:
!
!
!	DISPLAY THE GENERAL AND MAPPING REGISTERS, THE STACK, AND THE
!	CONTEXT OF THE CRASH PC.
!
!
! NO FORMAL PARAMETERS
!
! IMPLICIT INPUTS:
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	TRUE IF ALL INFORMATION WAS ACCESSABLE
!	OTHERWISE FALSE
!
! SIDE EFFECTS
!
!	SETS LISTING OUTPUT SUBTITLE
!	DISPLAYS INFORMATION ON LISTING DEVICE
!
!--

    BEGIN

    LOCAL
	ADR,
	PTR;

    SBTTL (CH$ASCIZ ('SYSTEM COMMON'));

    IF NOT SYMBOL_TABLE ('RSX11S') THEN RETURN;

    BEGIN

    LOCAL
	DATE_AND_TIME : VECTOR [8];

    BIND
	DATE = DATE_AND_TIME [0] : VECTOR [3],
	TIME = DATE_AND_TIME [3] : VECTOR [5];

    ADR = SYMBOL ($TTNS) - 12;

    INCR INDEX FROM 0 TO 6 DO
	DATE_AND_TIME [.INDEX] = GETWRD (2*.INDEX + .ADR);

    DATE_AND_TIME [7] = GETWRD (SYMBOL ($TKPS));

    IF .DATE [0] NEQ 0
    THEN
	PUTLN (3, CH$ASCIZ ('CRASH OCCURRED AT %3Z  %Y'), TIME, DATE)
    ELSE
	PUTLN (3,
	    CH$ASCIZ (WARNING, 'DATE AND TIME ARE INVALID'));

    END;
    BEGIN

    IF (ADR = GETBYT (SYMBOL ($IDLFL))) NEQ 0 THEN PUTLN (2, CH$ASCIZ ('THE PROCESSOR IS IDLING'));

    IF (ADR = GETWRD (SYMBOL ($TKTCB))) EQL SYMBOL ($HEADR)
    THEN
	PUTLN (2,
	    CH$ASCIZ ('CURRENT TASK = NULL TASK'))
    ELSE

	IF .ADR EQL 0
	THEN
	    PUTLN (2, CH$ASCIZ ('NO CURRENT TASK (?)'))
	ELSE
	    PUTLN (2,
		CH$ASCIZ ('CURRENT TASK = %2R    TCB ADDRESS = %P'), GETWRD (.ADR + FL$OFFSET (T_NAM) + 0),
		GETWRD (.ADR + FL$OFFSET (T_NAM) + 2), .ADR);

    END;
    PUTLN (1,
	(SELECTONE (ADR = GETWRD (SYMBOL ($STKDP))) OF
	    SET
	    [1] : CH$ASCIZ ('  EXECUTING ON USER STACK');
	    [0] : CH$ASCIZ ('  EXECUTING ON SYSTEM STACK');
	    [OTHERWISE] : CH$ASCIZ (WARNING, 'STACK DEPTH ERROR ($STKDP = %P)');
	    TES), .ADR);

    IF (ADR = GETWRD (SYMBOL ($RQSCH))) NEQ 0
    THEN

	IF .ADR NEQ SYMBOL ($HEADR)
	THEN
	    PUTLN (1,
		CH$ASCIZ ('  RESCHEDULING REQUESTED BEGINNING WITH TASK %2R (TCB %P)'),
		GETWRD (.ADR + FL$OFFSET (T_NAM) + 0), GETWRD (.ADR + FL$OFFSET (T_NAM) + 2), .ADR)
	ELSE
	    PUTLN (1, CH$ASCIZ ('  RESCHEDULING REQUESTED BEGINNING WITH THE NULL TASK'));

    IF (ADR = GETWRD (SYMBOL ($FRKHD))) NEQ 0
    THEN
	BEGIN

	LOCAL
	    ENTRY_COUNT;

	PUTLN (2, CH$ASCIZ ('THE FORK QUEUE:'));
	ENTRY_COUNT = RSX_MAX_FRK;

	DO
	    BEGIN

	    IF (ENTRY_COUNT = .ENTRY_COUNT - 1) LSS 0
	    THEN
		EXITLOOP PUTLN (1,
			CH$ASCIZ (WARNING,
			    'TOO MANY FORK ENTRIES'));

	    PUTLN (1, CH$ASCIZ ('  ADDRESS: %P   PC = %P  APR5 = %P  R5 = %P  R4 = %P'), .ADR,
		GETWRD (.ADR + 2), GETWRD (.ADR + 8), GETWRD (.ADR + 4), GETWRD (.ADR + 6));
	    END
	WHILE (ADR = GETWRD (.ADR)) NEQ 0;

	END
    ELSE
	PUTLN (2, CH$ASCIZ ('THE FORK QUEUE IS EMPTY'));

    BEGIN

    LOCAL
	SYSID : CH$SEQUENCE (4);

    BIND
	SYSID_PTR = CH$PTR (SYSID);

    ADR = SYMBOL ($SYSID);
    PTR = SYSID_PTR;

    INCR INDEX FROM 0 TO 3 DO
	CH$WCHAR_A (GETBYT (.ADR + .INDEX), PTR);

    PUTLN (2, CH$ASCIZ ('$SYSID = %4A   $EXSIZ = %P    $SYSIZ = %M./%DK    $SYUIC = [%O,%O]'), SYSID_PTR,
	GETWRD (SYMBOL ($EXSIZ)), (ADR = GETWRD (SYMBOL ($SYSIZ))), .ADR/32,
	GETBYT ((ADR = SYMBOL ($SYUIC)) + 1), GETBYT (.ADR + 0));
    END;
    PUTLN (1, CH$ASCIZ ('$COMEF:  <33-48> %P  <49-64> %P'), GETWRD (ADR = SYMBOL ($COMEF)), GETWRD (.ADR + 2))
    ;
    BEGIN

    LOCAL
	BUFFER : CH$SEQUENCE (2),
	LBN : VECTOR [2],
	PTR;

    BIND
	$SYSIZ = SYMBOL ($SYSIZ),
	BUFFER_PTR = CH$PTR (BUFFER);

    PTR = BUFFER_PTR;
    CH$WCHAR_A (GETBYT ($SYSIZ + 6), PTR);
    CH$WCHAR_A (GETBYT ($SYSIZ + 7), PTR);

    IF (( NOT GETWRD ($SYSIZ + 4) AND %O'177777') + ( NOT GETBYT ($SYSIZ + 3) AND %O'177')) EQL 0
    THEN
	BEGIN

	IF GETWRD ($SYSIZ + 6) NEQ %O'40735'
	THEN
	    PUTLN (1, CH$ASCIZ ('NETWORK LOAD DEVICE = %2E'),
		BUFFER_PTR)
	ELSE
	    PUTLN (1, CH$ASCIZ ('NETWORK LOAD DEVICE = DTE'));

	END
    ELSE
	BEGIN
	LBN [0] = GETBYT ($SYSIZ + 3);
	LBN [1] = GETWRD ($SYSIZ + 4);
	PUTLN (1, CH$ASCIZ ('LOAD DEVICE = %2E%O     LBN = %@     FILE SIZE = %D.'), BUFFER_PTR,
	    GETBYT ($SYSIZ + 2), DMPLBN, LBN, GETWRD ($SYSIZ + 8));
	END;

    END;
    BEGIN
    PUTLN (1, CH$ASCIZ ('  $ABTIM  %P%5S$ACTHD  %P%5S$CFLPT  %P%5S$CKCNT  %P'), GETWRD (SYMBOL ($ABTIM)),
	GETWRD (SYMBOL ($ACTHD)), GETWRD (SYMBOL ($CFLPT)), GETWRD (SYMBOL ($CKCNT)));
    PUTLN (0, CH$ASCIZ ('  $CKLDC  %P%5S$CLIPT  %P%5S$CLKHD  %P%5S$COPT   %P'), GETWRD (SYMBOL ($CKLDC)),
	GETWRD (SYMBOL ($CLIPT)), GETWRD (SYMBOL ($CLKHD)), GETWRD (SYMBOL ($COPT)));
    PUTLN (0, CH$ASCIZ ('  $CRAVL  %P%5S$CTLST  %P%5S$CXDBL  %P%5S$DEVHD  %P'), GETWRD (SYMBOL ($CRAVL)),
	GETWRD (SYMBOL ($CTLST)), GETWRD (SYMBOL ($CXDBL)), GETWRD (SYMBOL ($DEVHD)));
    PUTLN (0, CH$ASCIZ ('  $ERRPT  %P%5S$ERRSQ  %P%5S$ERRSZ  %P%5S$EXSIZ  %P'), GETWRD (SYMBOL ($ERRPT)),
	GETWRD (SYMBOL ($ERRSQ)), GETWRD (SYMBOL ($ERRSZ)), GETWRD (SYMBOL ($EXSIZ)));
    PUTLN (0, CH$ASCIZ ('  $FMASK  %P%5S$FRKHD  %P%5S$HEADR  %P%5S$INTCT  %P'), GETWRD (SYMBOL ($FMASK)),
	GETWRD (SYMBOL ($FRKHD)), GETWRD (SYMBOL ($HEADR)), GETWRD (SYMBOL ($INTCT)));
    PUTLN (0, CH$ASCIZ ('  $LDRPT  %P%5S$LOGHD  %P%5S$LSTLK  %P%5S$MCRCB  %P'), GETWRD (SYMBOL ($LDRPT)),
	GETWRD (SYMBOL ($LOGHD)), GETWRD (SYMBOL ($LSTLK)), GETWRD (SYMBOL ($MCRCB)));
    PUTLN (0, CH$ASCIZ ('  $MCRPT  %P%5S$MXEXT  %P%5S$PARHD  %P%5S$PARPT  %P'), GETWRD (SYMBOL ($MCRPT)),
	GETWRD (SYMBOL ($MXEXT)), GETWRD (SYMBOL ($PARHD)), GETWRD (SYMBOL ($PARPT)));
    PUTLN (0, CH$ASCIZ ('  $PKAVL  %P%5S$PKMAX  %P%5S$PKNUM  %P%5S$PWRFL  %P'), GETWRD (SYMBOL ($PKAVL)),
	GETWRD (SYMBOL ($PKMAX)), GETWRD (SYMBOL ($PKNUM)), GETWRD (SYMBOL ($PWRFL)));
    PUTLN (0, CH$ASCIZ ('  $RQSCH  %P%5S$SHFPT  %P%5S$SIGFL  %P%5S$STKDP  %P'), GETWRD (SYMBOL ($RQSCH)),
	GETWRD (SYMBOL ($SHFPT)), GETWRD (SYMBOL ($SIGFL)), GETWRD (SYMBOL ($STKDP)));
    PUTLN (0, CH$ASCIZ ('  $SYUIC  %P%5S$TKNPT  %P%5S$TKPS   %P%5S$TKTCB  %P'), GETWRD (SYMBOL ($SYUIC)),
	GETWRD (SYMBOL ($TKNPT)), GETWRD (SYMBOL ($TKPS)), GETWRD (SYMBOL ($TKTCB)));
    PUTLN (0, CH$ASCIZ ('  $TSKHD  %P%5S$UMRHD  %P'), GETWRD (SYMBOL ($TSKHD)), GETWRD (SYMBOL ($UMRHD)));
    END;

    !+
    ! Display the pool stats.
    !-

    BEGIN

    LOCAL
	FRAGMENTS,
	LENGTH,
	LARGEST,
	MASK,
	NEXT,
	TOTAL_FREE;

    PUTLN (2, CH$ASCIZ ('POOL STATISTICS:'));
    NEXT = GETWRD (ADR = SYMBOL ($CRAVL));
    MASK = GETWRD (.ADR - 2);
    LARGEST = 0;
    TOTAL_FREE = 0;
    FRAGMENTS = 0;

    WHILE (ADR = .NEXT) NEQ 0 DO
	BEGIN
	FRAGMENTS = .FRAGMENTS + 1;
	LENGTH = GETWRD (.ADR + 2);

	IF (NEXT = GETWRD (.ADR)) NEQ 0
	THEN

	    IF BIT_SET (.NEXT, 1) OR LEQ16 (.NEXT, .ADR + .LENGTH)
	    THEN
		EXITLOOP PUTLN (1,
			CH$ASCIZ (WARNING,
			    'POOL LINK ERROR AT %P, FWD PTR = %P, SIZE = %P'), .ADR, .NEXT, .LENGTH);

	TOTAL_FREE = .TOTAL_FREE + .LENGTH;

	IF GTR16 (.LENGTH, .LARGEST) THEN LARGEST = .LENGTH;

	END;

    PUTLN (2, CH$ASCIZ ('  POOL SIZE (BYTES) = %M.  TOTAL FREE BYTES = %M.'),
	GETWRD (SYMBOL ($EXSIZ)) - SYMBOL ($POOL), .TOTAL_FREE);
    PUTLN (1, CH$ASCIZ ('  LARGEST FREE BLOCK (BYTES) = %M.  NUMBER OF FRAGMENTS = %D.'), .LARGEST,
	.FRAGMENTS);
    PUTLN (1, CH$ASCIZ ('  MINIMUM BLOCK SIZE (BYTES) = %D.'), .MASK + 1);
    END;

    !+
    ! Dump the system common
    !-

    IF .FLAGS [M_RSX_DUMP]
    THEN
	BEGIN
	PUTLN (2, CH$ASCIZ ('  SYSTEM COMMON ($CMBEG THRU $CMEND)'));
	SKIP (1);
	VMADMP ((ADR = SYMBOL ($CMBEG)), .ADR, SYMBOL ($CMEND));
	END;

    END;					!OF RSX

ROUTINE DMPLBN (BUF_PTR_ADR, PAT_PTR_ADR, PRM_LST_ADR_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! The next parameters are:
!	VALUE
!
! FORMAL PARAMETERS:
!
!	..BUF_PTR_ADR				!Pointer to output buffer.
!	..PAT_PTR_ADR				!Pointer to pattern string.
!	..PRM_LST_ADR_ADR			!Pointer to next parameter.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS
!
!	NONE
!
!--

    BEGIN

    LITERAL
	FLAG = 4^11 + 1^9 + 8;

    LOCAL
	PRM_LST : REF VECTOR,
	VALUE : REF BLOCK [2];

    PRM_LST = ..PRM_LST_ADR_ADR;
    VALUE = .PRM_LST [0];
    .PRM_LST_ADR_ADR = PRM_LST [1];
    $CBTA (.BUF_PTR_ADR, .VALUE [1, 12, 4, 0] + .VALUE [0, 0, 8, 0]^5, FLAG) + $CBTA (.BUF_PTR_ADR,
	.VALUE [1, 0, 12, 0], FLAG)
    END;					!End of DMPLBN

GLOBAL ROUTINE POOL : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ADR;

    SBTTL (CH$ASCIZ ('POOL DUMP'));

    IF NOT SYMBOL_TABLE ('RSX11S') THEN RETURN;

    PUTLN (1, CH$ASCIZ ('%27SS Y S T E M     P O O L'));
    PUTLN (2, CH$ASCIZ ('%6SFIRST FREE BLOCK = %P ($CRAVL)%5SNEXT AVAILABLE PACKET = %P ($PKAVL)'),
	GETWRD (SYMBOL ($CRAVL)), GETWRD (SYMBOL ($PKAVL)));
    SKIP (2);
    VMADMP ((ADR = SYMBOL ($POOL)), .ADR, MINU (GETWRD (SYMBOL ($EXSIZ)), %O'120000'));
    END;					!End of POOL

ROUTINE WINDOW (START_ADDRESS, END_ADDRESS) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ADDR,
	FIRST_ADDRESS,
	WORD_COUNT,
	WORDS : VECTOR [8],
	WORDS_ADR;

    SKIP (1);
    ADDR = .START_ADDRESS;

    WHILE .ADDR LSSU .END_ADDRESS DO
	BEGIN
	FIRST_ADDRESS = .ADDR;
	WORD_COUNT = 0;

	INCRA WORDS_ADR FROM WORDS [0] TO WORDS [7] DO
	    BEGIN
	    .WORDS_ADR = GETWRD (.ADDR);
	    ADDR = .ADDR + 2;
	    WORD_COUNT = .WORD_COUNT + 1;

	    IF .ADDR EQL .END_ADDRESS THEN EXITLOOP;

	    END;

	PUTLN (0, CH$ASCIZ ('     %P	%#P'), .FIRST_ADDRESS, .WORD_COUNT, .WORDS [0], .WORDS [1], .WORDS [2],
	    .WORDS [3], .WORDS [4], .WORDS [5], .WORDS [6], .WORDS [7]);
	END;

    END;					!End of WINDOW
END

ELUDOM
