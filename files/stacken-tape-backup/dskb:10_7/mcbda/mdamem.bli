MODULE MEMORY (					!Dump window of memory.
		IDENT = '003010',
		LANGUAGE (BLISS16, BLISS36)
		) =
BEGIN
!
!			  COPYRIGHT (c) 1977, 1978 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY: MCBDA - MCB Crash Dump Analyzer
!
! ABSTRACT:
!
!	Dump specified window of physical memory.
!
! ENVIRONMENT: ANY
!
! AUTHOR: ALAN D. PECKHAM	, CREATION DATE: 22-SEP-78
!
! MODIFIED BY:
!
! 	Alan D. Peckham, 1-Aug-80: VERSION 3
! 01	- Fix bug in REPT_DUMP.
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    DIFFERENCE,					!Find defference between two bias/addresses.
    DUMP : NOVALUE,				!Main dumper routine.
    MEMDMP : NOVALUE,				!Dump physical memory.
    VMADMP : NOVALUE,				!Dump virtual memory.
    LINE_DUMP : NOVALUE,
    REPT_DUMP : NOVALUE;

!
! INCLUDE FILES:
!

LIBRARY 'MDACOM';				!MDA common definitions.

!
! MACROS:
!
!
! EQUATED SYMBOLS:
!

BIND
    LEFT_BORDER = UPLIT (%B'0000', %B'1000', %B'1100', %B'1110') : VECTOR [4],
    RIGHT_BORDER = UPLIT (%B'1111', %B'0111', %B'0011', %B'0001') : VECTOR [4];

!
! OWN STORAGE:
!

OWN
    OLD_ADDRESS : VECTOR [2],
    OLD_LINE : VECTOR [4],
    TIMES;

!
! EXTERNAL REFERENCES:
!

EXTERNAL
    FLAGS : BITVECTOR [M_MAX_BITS],
    DMPCNT,
    DMPLST : BLOCKVECTOR [MDA_MAX_DMPS, 4];

EXTERNAL ROUTINE
    GETWRD,					!Get a word from the dump image.
    MAPAPR : NOVALUE,				!Set a dump access address mapping bias.
    PHYAD : NOVALUE,				!Display a physical address.
    SBTTL : NOVALUE,				!Set up a listing sub-title.
    SKIP : NOVALUE;				!Insert a blank line in listing file.

GLOBAL ROUTINE DIFFERENCE (BIAS1, ADDRESS1, BIAS2, ADDRESS2) =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    IF .ADDRESS1<0, 16 - 3> LSS .ADDRESS2<0, 16 - 3>
    THEN
	BEGIN
	BIAS1 = .BIAS1 - 1;
	ADDRESS1 = .ADDRESS1 + %O'100';
	END;

    IF ABS (.BIAS1 - .BIAS2) GTR (1^10 - 1)
    THEN
	%O'100000'
    ELSE
	(.BIAS1 - .BIAS2)^6 + (.ADDRESS1<0, 16 - 3> - .ADDRESS2<0, 16 - 3>)

    END;					!End of DIFFERENCE

GLOBAL ROUTINE DUMP : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    IF .DMPCNT GTR 0
    THEN
	BEGIN

	LOCAL
	    DMPNUM;

	SBTTL (CH$ASCIZ ('MEMORY DUMP'));

	INCR DMPNUM FROM 0 TO .DMPCNT - 1 DO
	    BEGIN
	    PUTLN (3, CH$ASCIZ ('%12SDUMP OF MEMORY FROM %@ TO %@'), PHYAD, DMPLST [.DMPNUM, 0, 0, 2, 0],
		PHYAD, DMPLST [.DMPNUM, 2, 0, 2, 0]);
	    PUTLN (0, CH$ASCIZ ('%12S------------------------------------'));
	    SKIP (2);
	    MEMDMP (DMPLST [.DMPNUM, 0, 0, 2, 0], DMPLST [.DMPNUM, 0, 0, 2, 0], DMPLST [.DMPNUM, 2, 0, 2, 0]);
	    END;

	DMPCNT = 0;
	END;

    END;					!End of DUMP

GLOBAL ROUTINE MEMDMP (LOW_DISPLAY, LOW_PHYSICAL, HIGH_PHYSICAL) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	LOW_DISPLAY : REF BLOCK [2],
	LOW_PHYSICAL : REF BLOCK [2],
	HIGH_PHYSICAL : REF BLOCK [2];

    LOCAL
	ADDRESS,
	BIAS,
	DISPLAY_ADDRESS : VECTOR [2],
	DISPLAY_LINE : VECTOR [4],
	LEFT,
	LIMIT_BIAS,
	LIMIT_ADDRESS,
	MATCH,
	RIGHT;

    DISPLAY_ADDRESS [0] = .LOW_DISPLAY [0, 0, 2, 0];
    DISPLAY_ADDRESS [1] = .LOW_DISPLAY [1, 0, 16, 0];
    BIAS = .LOW_PHYSICAL [0, 0, 2, 0]^10 + .LOW_PHYSICAL [1, 6, 10, 0];
    ADDRESS = .LOW_PHYSICAL [1, 0, 6, 0] + %O'140000';

    IF (RIGHT = .DISPLAY_ADDRESS [1] MOD 8) NEQ 0
    THEN
	BEGIN
	DISPLAY_ADDRESS [1] = .DISPLAY_ADDRESS [1] - .RIGHT;

	IF .ADDRESS<0, 6> LSSU .RIGHT
	THEN
	    BEGIN
	    .BIAS = .BIAS - 1;
	    ADDRESS = .ADDRESS + %O'100' - .RIGHT;
	    END
	ELSE
	    ADDRESS = .ADDRESS - .RIGHT;

	END;

    LIMIT_BIAS = .HIGH_PHYSICAL [0, 0, 2, 0]^10 + .HIGH_PHYSICAL [1, 6, 10, 0];
    LIMIT_ADDRESS = .HIGH_PHYSICAL [1, 0, 6, 0] + %O'140000';
    MAPAPR (6, .BIAS);

    IF (LEFT = DIFFERENCE (.LIMIT_BIAS, .LIMIT_ADDRESS, .BIAS, .ADDRESS)) LEQ 7
    THEN
	BEGIN

	INCR INDEX FROM 0 TO 3 DO
	    BEGIN
	    DISPLAY_LINE [.INDEX] = GETWRD (.ADDRESS);
	    ADDRESS = .ADDRESS + 2;

	    IF .ADDRESS<6, 7> NEQ 0
	    THEN
		BEGIN
		ADDRESS = .ADDRESS AND %O'140077';
		BIAS = .BIAS + 1;
		MAPAPR (6, .BIAS);
		END;

	    END;

	LINE_DUMP (DISPLAY_ADDRESS, DISPLAY_LINE,
	    .RIGHT_BORDER [.RIGHT^-1] AND .LEFT_BORDER [.LEFT^-1]);
	END
    ELSE
	BEGIN

	IF .RIGHT NEQ 0
	THEN
	    BEGIN

	    INCR INDEX FROM 0 TO 3 DO
		BEGIN
		DISPLAY_LINE [.INDEX] = GETWRD (.ADDRESS);
		ADDRESS = .ADDRESS + 2;

		IF .ADDRESS<6, 7> NEQ 0
		THEN
		    BEGIN
		    ADDRESS = .ADDRESS AND %O'140077';
		    BIAS = .BIAS + 1;
		    MAPAPR (6, .BIAS);
		    END;

		END;

	    LINE_DUMP (DISPLAY_ADDRESS, DISPLAY_LINE, .RIGHT_BORDER [.RIGHT^-1]);
	    DISPLAY_ADDRESS [1] = .DISPLAY_ADDRESS [1] + 8 AND %O'177777';

	    IF .DISPLAY_ADDRESS [1] LSSU 7 THEN DISPLAY_ADDRESS [0] = .DISPLAY_ADDRESS [0] + 1;

	    END;

	MATCH = FALSE;
	TIMES = 0;

	WHILE DIFFERENCE (.LIMIT_BIAS, .LIMIT_ADDRESS, .BIAS, .ADDRESS) GEQ 7 DO
	    BEGIN

	    INCR INDEX FROM 0 TO 3 DO
		BEGIN
		DISPLAY_LINE [.INDEX] = GETWRD (.ADDRESS);
		ADDRESS = .ADDRESS + 2;

		IF .ADDRESS<6, 7> NEQ 0
		THEN
		    BEGIN
		    ADDRESS = .ADDRESS AND %O'140077';
		    BIAS = .BIAS + 1;
		    MAPAPR (6, .BIAS);
		    END;

		MATCH = .MATCH AND (.DISPLAY_LINE [.INDEX] EQL .OLD_LINE [.INDEX]);
		END;

	    IF NOT .MATCH
	    THEN
		BEGIN

		IF .TIMES NEQ 0 THEN REPT_DUMP ();

		LINE_DUMP (DISPLAY_ADDRESS, DISPLAY_LINE, .RIGHT_BORDER [0]);

		INCR INDEX FROM 0 TO 3 DO
		    OLD_LINE [.INDEX] = .DISPLAY_LINE [.INDEX];

		OLD_ADDRESS [0] = .DISPLAY_ADDRESS [0];
		OLD_ADDRESS [1] = .DISPLAY_ADDRESS [1];
		MATCH = TRUE;
		END
	    ELSE
		TIMES = .TIMES + 1;

	    DISPLAY_ADDRESS [1] = .DISPLAY_ADDRESS [1] + 8 AND %O'177777';

	    IF .DISPLAY_ADDRESS [1] LSSU 7 THEN DISPLAY_ADDRESS [0] = .DISPLAY_ADDRESS [0] + 1;

	    END;

	IF .TIMES NEQ 0 THEN REPT_DUMP ();

	IF (LEFT = .LIMIT_ADDRESS - .ADDRESS) NEQ 0
	THEN
	    BEGIN

	    INCR INDEX FROM 0 TO 3 DO
		BEGIN
		DISPLAY_LINE [.INDEX] = GETWRD (.ADDRESS);
		ADDRESS = .ADDRESS + 2;

		IF .ADDRESS<6, 7> NEQ 0
		THEN
		    BEGIN
		    ADDRESS = .ADDRESS AND %O'140077';
		    BIAS = .BIAS + 1;
		    MAPAPR (6, .BIAS);
		    END;

		END;

	    LINE_DUMP (DISPLAY_ADDRESS, DISPLAY_LINE, .LEFT_BORDER [.LEFT^-1]);
	    DISPLAY_ADDRESS [1] = .DISPLAY_ADDRESS [1] + 8 AND %O'177777';

	    IF .DISPLAY_ADDRESS [1] LSSU 7 THEN DISPLAY_ADDRESS [0] = .DISPLAY_ADDRESS [0] + 1;

	    END;

	END;

    END;					!End of MEMDMP

GLOBAL ROUTINE VMADMP (LOW_DISPLAY, LOW_VIRTUAL, HIGH_VIRTUAL) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ADDRESS,
	DISPLAY_ADDRESS : VECTOR [2],
	DISPLAY_LINE : VECTOR [4],
	LEFT,
	LIMIT_ADDRESS,
	MATCH,
	RIGHT;

    DISPLAY_ADDRESS [0] = 0;
    DISPLAY_ADDRESS [1] = .LOW_DISPLAY;
    ADDRESS = .LOW_VIRTUAL;

    IF (RIGHT = .DISPLAY_ADDRESS [1] MOD 8) NEQ 0
    THEN
	BEGIN
	DISPLAY_ADDRESS [1] = .DISPLAY_ADDRESS [1] - .RIGHT;
	ADDRESS = .ADDRESS - .RIGHT;
	END;

    LIMIT_ADDRESS = .HIGH_VIRTUAL;

    IF (LEFT = .LIMIT_ADDRESS - .ADDRESS) LEQ 7
    THEN
	BEGIN

	INCR INDEX FROM 0 TO 3 DO
	    BEGIN
	    DISPLAY_LINE [.INDEX] = GETWRD (.ADDRESS);
	    ADDRESS = .ADDRESS + 2;
	    END;

	LINE_DUMP (DISPLAY_ADDRESS, DISPLAY_LINE,
	    .RIGHT_BORDER [.RIGHT^-1] AND .LEFT_BORDER [.LEFT^-1]);
	END
    ELSE
	BEGIN

	IF .RIGHT NEQ 0
	THEN
	    BEGIN

	    INCR INDEX FROM 0 TO 3 DO
		BEGIN
		DISPLAY_LINE [.INDEX] = GETWRD (.ADDRESS);
		ADDRESS = .ADDRESS + 2;
		END;

	    LINE_DUMP (DISPLAY_ADDRESS, DISPLAY_LINE, .RIGHT_BORDER [.RIGHT^-1]);
	    DISPLAY_ADDRESS [1] = .DISPLAY_ADDRESS [1] + 8;
	    END;

	MATCH = FALSE;
	TIMES = 0;

	UNTIL ((.ADDRESS + 7) GEQU .LIMIT_ADDRESS) DO
	    BEGIN

	    INCR INDEX FROM 0 TO 3 DO
		BEGIN
		DISPLAY_LINE [.INDEX] = GETWRD (.ADDRESS);
		ADDRESS = .ADDRESS + 2;
		MATCH = .MATCH AND (.DISPLAY_LINE [.INDEX] EQL .OLD_LINE [.INDEX]);
		END;

	    IF NOT .MATCH
	    THEN
		BEGIN

		IF .TIMES NEQ 0 THEN REPT_DUMP ();

		LINE_DUMP (DISPLAY_ADDRESS, DISPLAY_LINE, .RIGHT_BORDER [0]);

		INCR INDEX FROM 0 TO 3 DO
		    OLD_LINE [.INDEX] = .DISPLAY_LINE [.INDEX];

		OLD_ADDRESS [0] = .DISPLAY_ADDRESS [0];
		OLD_ADDRESS [1] = .DISPLAY_ADDRESS [1];
		MATCH = TRUE;
		END
	    ELSE
		TIMES = .TIMES + 1;

	    DISPLAY_ADDRESS [1] = .DISPLAY_ADDRESS [1] + 8;
	    END;

	IF .TIMES NEQ 0 THEN REPT_DUMP ();

	IF (LEFT = .LIMIT_ADDRESS - .ADDRESS) NEQ 0
	THEN
	    BEGIN

	    INCR INDEX FROM 0 TO 3 DO
		BEGIN
		DISPLAY_LINE [.INDEX] = GETWRD (.ADDRESS);
		ADDRESS = .ADDRESS + 2;
		END;

	    LINE_DUMP (DISPLAY_ADDRESS, DISPLAY_LINE, .LEFT_BORDER [.LEFT^-1]);
	    DISPLAY_ADDRESS [1] = .DISPLAY_ADDRESS [1] + 8;
	    END;

	END;

    END;					!End of VMADMP

ROUTINE LINE_DUMP (ADDRESS, BUFFER, BORDER) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	ADDRESS : REF VECTOR [2],
	BUFFER : REF BLOCKVECTOR [4, 1];

    LOCAL
	ASCII_BUF : CH$SEQUENCE (8, 8),
	INDEX,
	PTR;

    BIND
	ASCII_PTR = CH$PTR (ASCII_BUF,, 8),
	PATTERN = UPLIT (
	0,
	CH$ASCIZ ('%6S%@    			%3+%1P    %1-!%12S%R! !%6S%3+%2E!'),
	CH$ASCIZ ('%6S%@    		%2+%1P	%10S%1-!%8S%R%4S!%1+ !%4S%2+%2E  !'),
	CH$ASCIZ ('%6S%@    		%2+%2P    %2-!%8S%R %R! !%4S%2+%4E!'),
	CH$ASCIZ ('%6S%@    	%1+%1P		%10S%1-!%4S%R%8S!%2+ !  %1+%2E%4S!'),
	0,
	CH$ASCIZ ('%6S%@    	%1+%2P	%10S%2-!%4S%R %R%8S!%2+ !  %1+%4E  !'),
	CH$ASCIZ ('%6S%@    	%1+%3P    %3-!%4S%R %R %R! !  %1+%6E!'),
	CH$ASCIZ ('%6S%@    %1P			%10S%1-!%R%12S!%3+ !%2E%6S!'),
	0,
	0,
	0,
	CH$ASCIZ ('%6S%@    %2P		%10S%2-!%R %R%8S!%2+ !%4E%4S!'),
	0,
	CH$ASCIZ ('%6S%@    %3P	%10S%3-!%R %R %R%4S!%1+ !%6E  !'),
	CH$ASCIZ ('%6S%@    %4P    %4-!%R %R %R %R! !%8E!')
	): VECTOR [16],
	WIDE_PATTERN = UPLIT (
	0,
	CH$ASCIZ ('%6S%@    			%3+%1P    %1-!%12S%R!%31S%3+%2B    %1-!%6S%2E!'),
	CH$ASCIZ ('%6S%@    		%2+%1P	%10S%1-!%8S%R%4S!%22S%3+%2B%13S%1-!%4S%2E  !'),
	CH$ASCIZ ('%6S%@    		%2+%2P    %2-!%8S%R %R!%22S%2+%2B  %2B    %2-!%4S%4E!'),
	CH$ASCIZ ('%6S%@    	%1+%1P		%10S%1-!%4S%R%8S!%13S%3+%2B%22S%1-!  %2E%4S!'),
	0,
	CH$ASCIZ ('%6S%@    	%1+%2P	%10S%2-!%4S%R %R%4S!%13S%2+%2B  %2B%13S%2-!  %4E  !'),
	CH$ASCIZ ('%6S%@    	%1+%3P    %3-!%4S%R %R %R!%13S%1+%2B  %2B  %2B    %3-!  %6E!'),
	CH$ASCIZ ('%6S%@    %1P			%10S%1-!%R%12S!%3+    %2B%31S%3-!%2E%6S!'),
	0,
	0,
	0,
	CH$ASCIZ ('%6S%@    %2P		%10S%2-!%R %R%8S!%2+    %2B  %2B%22S%2-!%4E%4S!'),
	0,
	CH$ASCIZ ('%6S%@    %3P	%10S%3-!%R %R %R%4S!%1+    %2B  %2B  %2B%13S%3-!%6E  !'),
	CH$ASCIZ ('%6S%@    %4P    %4-!%R %R %R %R!    %2B  %2B  %2B  %2B    %4-!%8E!')
	): VECTOR [16];

    PTR = ASCII_PTR;

    INCR INDEX FROM 0 TO 3 DO
	BEGIN
	CH$WCHAR_A (.BUFFER [.INDEX, 0, 0, 8, 0], PTR);
	CH$WCHAR_A (.BUFFER [.INDEX, 0, 8, 8, 0], PTR);
	END;

    PUTLN (0, (IF .FLAGS [M_WIDE] THEN .WIDE_PATTERN [.BORDER] ELSE .PATTERN [.BORDER]), PHYAD,
	.ADDRESS, .BUFFER [0, 0, 0, 16, 0], .BUFFER [1, 0, 0, 16, 0], .BUFFER [2, 0, 0, 16, 0],
	.BUFFER [3,
	    0, 0, 16, 0], ASCII_PTR, CH$PTR (ASCII_BUF, 2, 8), CH$PTR (ASCII_BUF, 4, 8),
	CH$PTR (ASCII_BUF,
	    6, 8));
    END;					!End of LINE_DUMP
ROUTINE REPT_DUMP : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    IF .TIMES LSS 9
    THEN

	WHILE (TIMES = .TIMES - 1) GEQ 0 DO
	    BEGIN
	    OLD_ADDRESS [1] = .OLD_ADDRESS [1] + 8 AND %O'177777';

	    IF .OLD_ADDRESS [1] LSSU 7 THEN OLD_ADDRESS [0] = .OLD_ADDRESS [0] + 1;

	    LINE_DUMP (OLD_ADDRESS, OLD_LINE, .RIGHT_BORDER [0])
	    END

    ELSE
	BEGIN
	PUTLN (1, CH$ASCIZ ('%23S[ABOVE LINE REPEATED %D. TIMES]'), .TIMES);
	SKIP (1);
	END;

    TIMES = 0;
    END;					!End of REPT_DUMP
END						!End of module

ELUDOM
