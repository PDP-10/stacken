MODULE CLQ (					!Display the RSX clock queues
		IDENT = '003010',
		LANGUAGE (BLISS16, BLISS36)
		) =
BEGIN
!
!			  COPYRIGHT (c) 1977, 1978 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY: MCBDA - MCB Crash Dump Analyzer
!
! ABSTRACT:
!
!	Display the RSX clock queues and associated information
!
! ENVIRONMENT: ANY
!
! AUTHOR: ALAN D. PECKHAM	, CREATION DATE: 19-MAY-79
!
! MODIFIED BY:
!
! 	Alan D. Peckham, 7-Jul-80 : VERSION 3
! 01	- Update to use RSXLIB for RSX structures
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    CLQ : NOVALUE;				!Display the clock queue information.

!
! INCLUDE FILES:
!

LIBRARY 'MDACOM';				!MDA common definitions.

LIBRARY 'RSXLIB';				!RSX definitions.

!
! MACROS:
!
!	None
!
! EQUATED SYMBOLS:
!
!	None
!
! OWN STORAGE:
!
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    GETBYT,					!GET A BYTE FROM THE DUMP FILE
    GETWRD,					!GET A WORD FROM THE DUMP FILE
    BITLS : NOVALUE,				!IDENTIFY BITS AND EDIT INTO ASCII
    BYTSM : NOVALUE,				!IDENTIFY AND EDIT BYTE INTO ASCII
    VMADMP : NOVALUE,
    SBTTL : NOVALUE,				!SET LIST FILE SUB-TITLE
    SKIP : NOVALUE;

EXTERNAL
    FLAGS : BITVECTOR [M_MAX_BITS];

GLOBAL ROUTINE CLQ : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ABTIM,
	CLOCK_ADDRESS,
	ENTRY_COUNT,
	TIME : VECTOR [2],
	TYPE;

    SBTTL (CH$ASCIZ ('SYSTEM CLOCK INFORMATION'));

    IF NOT SYMBOL_TABLE ('RSX11S') THEN RETURN;

    !+
    ! Check up on what type of clock we have.
    !-

    BEGIN

    LOCAL
	CNT,
	CSR,
	TKPS;

    CSR = GETWRD (SYMBOL ('$CKCSR'));
    CNT = GETWRD (SYMBOL ('$CKCNT'));
    TKPS = GETWRD (SYMBOL ('$TKPS'));

    IF .CSR EQL .CNT
    THEN
	BEGIN
	PUTLN (2, CH$ASCIZ ('THE SYSTEM IS USING A KW11-L, CSR = %P'), .CSR);
	PUTLN (0, CH$ASCIZ ('  THIS IS A %M. HERTZ MACHINE'), .TKPS);
	END
    ELSE
	BEGIN
	PUTLN (2, CH$ASCIZ ('THE SYSTEM IS USING A KW11-P, CSR = %P'), .CSR);
	PUTLN (0, CH$ASCIZ ('  THE LOAD COUNT IS %M. INTO REGISTER %P'), GETWRD (SYMBOL ('$CKLDC')), .CNT);
	PUTLN (0, CH$ASCIZ ('  FOR AND INTERRUPT RATE OF %M. TIMES A SECOND'), .TKPS);
	END;

    END;

    SELECTONE (TYPE = GETWRD (SYMBOL ('$INTCT'))) OF
	SET

	[%O'177777'] :
	    0;

	[0] :
	    PUTLN (1, CH$ASCIZ ('THE CLOCK FORK IS ACTIVE'));

	[OTHERWISE] :
	    PUTLN (1, CH$ASCIZ ('THE CLOCK FORK IS ACTIVE, AND BEHIND BY %M. TICKS ($INTCT)'), .TYPE);
	TES;

    PUTLN (1, CH$ASCIZ ('ABSOLUTE TIME COUNTER: %P ($ABTIM)'), (ABTIM = GETWRD (SYMBOL ('$ABTIM'))));

    !+
    ! If the clock quque is non-empty, then display it.
    !-

    IF GETWRD (CLOCK_ADDRESS = SYMBOL ('$CLKHD')) NEQ 0
    THEN
	BEGIN
	PUTLN (2, CH$ASCIZ ('QUEUED CLOCK REQUESTS:'));
	ENTRY_COUNT = RSX_MAX_CLQ;

	WHILE (CLOCK_ADDRESS = GETWRD (.CLOCK_ADDRESS)) NEQ 0 DO
	    BEGIN

	    IF (ENTRY_COUNT = .ENTRY_COUNT - 1) LSS 0
	    THEN
		EXITLOOP PUTLN (1,
			CH$ASCIZ (WARNING,
			    'TOO MANY QUEUE ENTRIES'));

	    IF .CLOCK_ADDRESS<0, 1>
	    THEN
		EXITLOOP PUTLN (1,
			CH$ASCIZ (WARNING,
			    'LINK ERROR,  LINK ADDRESS = %P'), .CLOCK_ADDRESS);

	    TIME [0] = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_TIM) + 2);
	    TIME [1] = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_TIM) + 0);

	    IF LSS16 (.TIME [1], .ABTIM) THEN TIME [0] = .TIME [0] - 1;

	    BLOCK [TIME, 1, 0, 16, 0] = .TIME [1] - .ABTIM;
	    PUTLN (1, CH$ASCIZ ('  ADDRESS: %P  TIME LEFT: %M. TICKS'), .CLOCK_ADDRESS, .TIME [1]);

	    CASE (TYPE = GETBYT (.CLOCK_ADDRESS + FL$OFFSET (C_RQT))) FROM 0 TO 10 OF
		SET

		[C_SYST, C_SYTK] :
		    PUTLN (0, CH$ASCIZ ('%4SINTERNAL SINGLE SHOT,  APR5 = %P,  ADDRESS = %P'),
			GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_AR5)),
			GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_SUB)));

		[C_SCHD] :
		    BEGIN

		    LOCAL
			ADR;

		    ADR = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_TCB));
		    PUTLN (0, CH$ASCIZ ('%4SPERIODIC REQUEST FOR TASK [%O,%O]%2R'),
			GETBYT (.CLOCK_ADDRESS + FL$OFFSET (C_UIC) + 1),
			GETBYT (.CLOCK_ADDRESS + FL$OFFSET (C_UIC) + 0),
			GETWRD (.ADR + FL$OFFSET (T_NAM) + 0), GETWRD (.ADR + FL$OFFSET (T_NAM) + 2));
		    TIME [0] = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_RSI) + 2);
		    TIME [1] = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_RSI) + 0);
		    PUTLN (0, CH$ASCIZ ('%4SRESCHEDULE INTERVAL: %M. TICKS'), .TIME [1]);
		    END;

		[C_SSHT] :
		    BEGIN

		    LOCAL
			ADR;

		    ADR = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_TCB));
		    PUTLN (0, CH$ASCIZ ('%4SSINGLE SHOT REQUEST FOR TASK [%O,%O]%2R'),
			GETBYT (.CLOCK_ADDRESS + FL$OFFSET (C_UIC) + 1),
			GETBYT (.CLOCK_ADDRESS + FL$OFFSET (C_UIC) + 0),
			GETWRD (.ADR + FL$OFFSET (T_NAM) + 0), GETWRD (.ADR + FL$OFFSET (T_NAM) + 2));
		    END;

		[C_MRKT] :
		    BEGIN

		    LOCAL
			ADR;

		    ADR = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_TCB));
		    PUTLN (0, CH$ASCIZ ('%4SMARK TIME FOR TASK %2R,  EFN = %M.,  AST = %P'),
			GETWRD (.ADR + FL$OFFSET (T_NAM) + 0), GETWRD (.ADR + FL$OFFSET (T_NAM) + 2),
			GETBYT (.CLOCK_ADDRESS + FL$OFFSET (C_EFN)),
			GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_AST)));
		    PUTLN (0, CH$ASCIZ ('%4SFLAG SOURCE: %P, DESTINATION: %P, CONTENTS: %P'),
			GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_SRC)),
			(ADR = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_DST))), GETWRD (.ADR));
		    END;

		[C_CSTP] :
		    BEGIN

		    LOCAL
			ADR;

		    ADR = GETWRD (.CLOCK_ADDRESS + FL$OFFSET (C_TCB));
		    PUTLN (0, CH$ASCIZ ('%4SUNSTOP TASK %2R'), GETWRD (.ADR + FL$OFFSET (T_NAM) + 0),
			GETWRD (.ADR + FL$OFFSET (T_NAM) + 2));
		    END;

		[INRANGE, OUTRANGE] :
		    PUTLN (2, CH$ASCIZ (WARNING, 'INVALID REQUEST TYPE: %O'), .TYPE);
		TES;

	    IF .FLAGS [M_RSX_DUMP]
	    THEN
		BEGIN
		SKIP (1);
		VMADMP (0, .CLOCK_ADDRESS, .CLOCK_ADDRESS + C_LGTH^1);
		END;

	    END;

	END;

    END;					!End of CLQ

END						!End of module

ELUDOM
