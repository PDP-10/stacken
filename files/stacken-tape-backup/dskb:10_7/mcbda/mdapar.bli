MODULE PARS (					!Dump RSX11 partition map
		IDENT = '003010',
		LANGUAGE (BLISS16, BLISS36)
		) =
BEGIN
!
!			  COPYRIGHT (c) 1977, 1978 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY: MCBDA - MCB Crash Dump Analyzer
!
! ABSTRACT:
!
!	This module contains the routines to display the RSX11 partition
!	information.
!
! ENVIRONMENT:
!
! AUTHOR: ALAN D. PECKHAM	, CREATION DATE: 12-SEP-78
!
! MODIFIED BY:
!
! 	Alan D. Peckham, 9-Jul-80: VERSION 3
! 01	- Change RSX symbol references
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    PCBMAP : NOVALUE,				!Display partition map.
    PUT_PARTITION : NOVALUE,
    PUT_HOLE : NOVALUE;

!
! INCLUDE FILES:
!

LIBRARY 'MDACOM';				!Mda common definitions.

LIBRARY 'RSXLIB';				!RSX definitions.

!
! MACROS:
!
!	None
!
! EQUATED SYMBOLS:
!
!	None
!
! OWN STORAGE:
!

OWN
    OLD_TOP;

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    GETBYT,					!Get a byte from the dump file.
    GETWRD,					!Get a word from the dump file.
    SKIP : NOVALUE,				!Send blank line to listing file.
    SBTTL : NOVALUE;				!Set listing page subtitle.

GLOBAL ROUTINE PCBMAP : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ENTRY_COUNT,
	EXSIZ,
	POOL;

    BIND
	PCB_ADDRESS = EXSIZ,
	SYSIZ = PCB_ADDRESS;

    SBTTL (CH$ASCIZ ('PARTITION INFORMATION'));

    IF NOT SYMBOL_TABLE ('RSX11S') THEN RETURN;

    PUTLN (3, CH$ASCIZ ('%24SM E M O R Y    M A P'));
    PUTLN (3, CH$ASCIZ ('  PARTITION   MEMORY  ALLOCATED     SIZE', '%8STYPE%7SOCCUPIED BY'));
    PUTLN (0, CH$ASCIZ ('  ---------   -----------------     ----', '%8S----%7S-----------'));
    SKIP (1);

    !+
    ! Display the executive partition and pool.
    !-

    PUTLN (0, CH$ASCIZ ('   <EXEC>%5S00%P 00%P   00%P'), 0, (POOL = SYMBOL ($POOL)), .POOL);
    PUTLN (0, CH$ASCIZ ('   <POOL>%5S00%P 00%P   00%P'), .POOL, (EXSIZ = GETWRD (SYMBOL ($EXSIZ))),
	(.EXSIZ - .POOL));
    OLD_TOP = .EXSIZ;

    !+
    ! Now the user partitions.
    !-

    ENTRY_COUNT = RSX_MAX_PCB;
    PCB_ADDRESS = SYMBOL ($PARHD) - FL$OFFSET (P_LNK);

    WHILE (PCB_ADDRESS = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_LNK))) NEQ 0 DO
	BEGIN

	IF (ENTRY_COUNT = .ENTRY_COUNT - 1) LSS 0
	THEN
	    RETURN PUTLN (1,
		    CH$ASCIZ (WARNING,
			'TOO MANY PARTITION ENTRIES'));

	PUT_PARTITION (.PCB_ADDRESS);

	IF FL$SET (GETWRD (.PCB_ADDRESS + FL$OFFSET (P_STAT)), PS_SYS)
	THEN
	    BEGIN

	    LOCAL
		SAVE_OLD_TOP,
		SUB_ADDRESS;

	    SAVE_OLD_TOP = .OLD_TOP;
	    OLD_TOP = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_REL));
	    SUB_ADDRESS = .PCB_ADDRESS;

	    WHILE (SUB_ADDRESS = GETWRD (.SUB_ADDRESS + FL$OFFSET (P_SUB))) NEQ 0 DO
		BEGIN

		IF (ENTRY_COUNT = .ENTRY_COUNT - 1) LSS 0
		THEN
		    RETURN PUTLN (1,
			    CH$ASCIZ (WARNING,
				'TOO MANY PARTITION ENTRIES'));

		PUT_PARTITION (.SUB_ADDRESS);
		END;

	    IF .OLD_TOP LSSU .SAVE_OLD_TOP THEN PUT_HOLE (.OLD_TOP, .SAVE_OLD_TOP);

	    OLD_TOP = .SAVE_OLD_TOP;
	    END;

	END;

    IF .OLD_TOP LSSU (SYSIZ = GETWRD (SYMBOL ($SYSIZ)))
    THEN
	BEGIN
	SKIP (1);
	PUT_HOLE (.OLD_TOP, .SYSIZ);
	END;

    END;					!End of PCBMAP

ROUTINE PUT_PARTITION (PCB_ADDRESS) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	TSK_TYPE = 0,
	SYS_TYPE = 1,
	COM_TYPE = 2,
	DYN_TYPE = 3,
	DRV_TYPE = 4;

    LOCAL
	TYPE,
	BOTTOM,
	SIZE,
	TOP,
	DEVICE_NAME;

    BIND
	STATUS = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_STAT)),
	TCB_ADDRESS = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_TCB)),
	MAIN_PARTITION = .PCB_ADDRESS EQL GETWRD (.PCB_ADDRESS + FL$OFFSET (P_MAIN)),
	SYS_PARTITION = FL$SET (STATUS, PS_SYS),
	BUSY = ((GETBYT (.PCB_ADDRESS + FL$OFFSET (P_BUSY) + 0) AND GETBYT (.PCB_ADDRESS + FL$OFFSET (P_BUSY)
		+ 1)) NEQ 0),
	DISPLAY_TYPE = UPLIT (CH$ASCII ('TASK   '), CH$ASCII ('SYS    '),
	    CH$ASCII('COMMON '), CH$ASCII('DYNAMIC'), CH$ASCII('DRIVER ')
	    ) : VECTOR [5];

    TYPE = (IF MAIN_PARTITION AND SYS_PARTITION THEN SYS_TYPE ELSE IF FL$SET (STATUS, PS_DRV) THEN DRV_TYPE
	ELSE IF NOT FL$SET (STATUS, PS_COM) THEN TSK_TYPE ELSE IF SYS_PARTITION THEN DYN_TYPE ELSE COM_TYPE);
    BOTTOM = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_REL));
    SIZE = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_BLKS));
    TOP = .BOTTOM + .SIZE;

    IF .OLD_TOP LSSU .BOTTOM THEN PUT_HOLE (.OLD_TOP, .BOTTOM);

    OLD_TOP = .TOP;

    IF .TYPE EQL DRV_TYPE
    THEN
	BEGIN
	CH$WCHAR (GETBYT (TCB_ADDRESS + FL$OFFSET (D_NAM) + 0), CH$PTR (DEVICE_NAME, 0));
	CH$WCHAR (GETBYT (TCB_ADDRESS + FL$OFFSET (D_NAM) + 1), CH$PTR (DEVICE_NAME, 1));
	END;

    PUTLN ((IF MAIN_PARTITION THEN 1 ELSE 0),
	(IF .TYPE EQL DRV_TYPE THEN CH$ASCIZ ('   %2R%5S%P00 %P00   %P00%4S%4A %7A   %2A:%+') ELSE CH$ASCIZ (
		'   %2R%5S%P00 %P00   %P00%4S%4A %7A   %2R')),
	(IF NOT MAIN_PARTITION AND SYS_PARTITION THEN 0 ELSE GETWRD (.PCB_ADDRESS + FL$OFFSET (P_NAM) + 0)),
	(IF NOT MAIN_PARTITION AND SYS_PARTITION THEN 0 ELSE GETWRD (.PCB_ADDRESS + FL$OFFSET (P_NAM) + 2)),
	.BOTTOM, .TOP, .SIZE, (IF MAIN_PARTITION THEN CH$ASCII ('MAIN') ELSE CH$ASCII (' SUB')),
	.DISPLAY_TYPE [.TYPE],
	(IF SYS_PARTITION OR BUSY THEN (SELECTONE .TYPE OF
		SET
		[TSK_TYPE] : IF TCB_ADDRESS NEQ 0 THEN GETWRD (TCB_ADDRESS + FL$OFFSET (T_NAM) + 0);
		[DYN_TYPE, COM_TYPE] : GETWRD (.PCB_ADDRESS + FL$OFFSET (P_NAM) + 0);
		[DRV_TYPE] : CH$PTR (DEVICE_NAME);
		[OTHERWISE] : 0;
		TES) ELSE 0),
	(IF SYS_PARTITION OR BUSY THEN (SELECTONE .TYPE OF
		SET
		[TSK_TYPE] : IF TCB_ADDRESS NEQ 0 THEN GETWRD (TCB_ADDRESS + FL$OFFSET (T_NAM) + 2);
		[DYN_TYPE, COM_TYPE] : GETWRD (.PCB_ADDRESS + FL$OFFSET (P_NAM) + 2);
		[OTHERWISE] : 0;
		TES) ELSE 0));
    END;					!End of PUT_PARTITION
ROUTINE PUT_HOLE (BOTTOM, TOP) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    PUTLN (0, CH$ASCIZ ('%14S%P00 %P00   %P00%5S<HOLE>'), .BOTTOM, .TOP, (.TOP - .BOTTOM));
    END;					!End of PUT_HOLE
END						!End of module

ELUDOM
