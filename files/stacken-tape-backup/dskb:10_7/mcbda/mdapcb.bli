
MODULE PCBS (					!Display Partition Control Block information
		IDENT = '003010',
		LANGUAGE (BLISS16, BLISS36)
		) =
BEGIN
!
!			  COPYRIGHT (c) 1977, 1978 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY: MCBDA - MCB Crash Dump Analyzer
!
! ABSTRACT:
!
!	Display the Partition Control Blocks in detail.
!
! ENVIRONMENT: ANY
!
! AUTHOR: ALAN D. PECKHAM	, CREATION DATE: 19-MAY-79
!
! MODIFIED BY:
!
! 	Alan D. Peckham, 9-Jul-80: VERSION 3
! 01	- Change RSX symbol references
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    DMPDEV : NOVALUE,				!
    DMPNAM : NOVALUE,				!
    PCBS : NOVALUE,				!Display the PCBs.
    PUT_ATTACHMENTS : NOVALUE,
    PUT_PARTITION : NOVALUE,
    PUT_WAIT_QUEUE : NOVALUE;

!
! INCLUDE FILES:
!

LIBRARY 'MDACOM';				!MDA common definitions.

LIBRARY 'RSXLIB';				!RSX definitions.

!
! MACROS:
!
!	None
!
! EQUATED SYMBOLS:
!
!	None
!
! OWN STORAGE:
!
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BITLS : NOVALUE,				!IDENTIFY BITS AND EDIT INTO ASCII
    BYTSM : NOVALUE,				!IDENTIFY AND EDIT BYTE INTO ASCII
    SBTTL : NOVALUE,				!SET LIST FILE SUB-TITLE
    GETBYT,					!GET A BYTE FROM THE DUMP FILE
    GETWRD,					!GET A WORD FROM THE DUMP FILE
    VMADMP : NOVALUE,
    SKIP : NOVALUE,				!Skip some lines.
    $C5TA;					!Convert RAD50 to ASCII.

EXTERNAL
    FLAGS : BITVECTOR [M_MAX_BITS];

ROUTINE DMPDEV (BUF_PTR_ADR, PAT_PTR_ADR, PRM_LST_ADR_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! The next parameters are:
!	UCB_ADDRESS
!
! FORMAL PARAMETERS:
!
!	..BUF_PTR_ADR				!Pointer to output buffer.
!	..PAT_PTR_ADR				!Pointer to pattern string.
!	..PRM_LST_ADR_ADR			!Pointer to next parameter.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PRM_LST : REF VECTOR,
	BUF_PTR_INI,
	UCB_ADDRESS;

    PRM_LST = ..PRM_LST_ADR_ADR;
    UCB_ADDRESS = .PRM_LST [0];
    .PRM_LST_ADR_ADR = PRM_LST [1];
    BUF_PTR_INI = ..BUF_PTR_ADR;

    IF .UCB_ADDRESS NEQ 0
    THEN
	BEGIN

	LOCAL
	    DCB_ADDRESS,
	    UNIT;

	EXTERNAL ROUTINE
	    $CBOMG;

	DCB_ADDRESS = GETWRD (.UCB_ADDRESS + FL$OFFSET (U_DCB));
	CH$WCHAR_A (GETBYT (.DCB_ADDRESS + FL$OFFSET (D_NAM) + 0), .BUF_PTR_ADR);
	CH$WCHAR_A (GETBYT (.DCB_ADDRESS + FL$OFFSET (D_NAM) + 1), .BUF_PTR_ADR);
	UNIT = ((.UCB_ADDRESS - GETWRD (.DCB_ADDRESS + FL$OFFSET (D_UCB)))/GETWRD (.DCB_ADDRESS + FL$OFFSET (
		D_UCBL))) + GETBYT (.DCB_ADDRESS + FL$OFFSET (D_UNIT));
	$CBOMG (.BUF_PTR_ADR, .UNIT, 0);
	END
    ELSE
	.BUF_PTR_ADR = CH$MOVE (4, CH$ASCIZ ('NONE'), ..BUF_PTR_ADR);

    CH$DIFF (..BUF_PTR_ADR, .BUF_PTR_INI)
    END;					!End of DMPDEV
ROUTINE DMPNAM (BUF_PTR_ADR, PAT_PTR_ADR, PRM_LST_ADR_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! The next parameters are:
!	UCB_ADDRESS
!
! FORMAL PARAMETERS:
!
!	..BUF_PTR_ADR				!Pointer to output buffer.
!	..PAT_PTR_ADR				!Pointer to pattern string.
!	..PRM_LST_ADR_ADR			!Pointer to next parameter.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS
!
!	NONE
!
!--

    BEGIN

    LOCAL
	BASE_ADDRESS,
	OFFSET,
	PRM_LST : REF VECTOR;

    PRM_LST = ..PRM_LST_ADR_ADR;
    BASE_ADDRESS = .PRM_LST [0];
    OFFSET = .PRM_LST [1];
    .PRM_LST_ADR_ADR = PRM_LST [2];

    IF .BASE_ADDRESS NEQ 0
    THEN
	BEGIN
	$C5TA (.BUF_PTR_ADR, GETWRD (.BASE_ADDRESS + .OFFSET + 0));
	$C5TA (.BUF_PTR_ADR, GETWRD (.BASE_ADDRESS + .OFFSET + 2));
	END
    ELSE
	.BUF_PTR_ADR = CH$MOVE (6, CH$ASCIZ ('      '), ..BUF_PTR_ADR);

    6
    END;					!End of DMPNAM

GLOBAL ROUTINE PCBS : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ENTRY_COUNT,
	PCB_ADDRESS;

    SBTTL (CH$ASCIZ ('PARTITION CONTROL BLOCKS'));

    IF NOT SYMBOL_TABLE ('RSX11S') THEN RETURN;

    ENTRY_COUNT = RSX_MAX_PCB;
    PCB_ADDRESS = SYMBOL ($PARHD) - FL$OFFSET (P_LNK);

    WHILE (PCB_ADDRESS = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_LNK))) NEQ 0 DO
	BEGIN

	IF (ENTRY_COUNT = .ENTRY_COUNT - 1) LSS 0
	THEN
	    RETURN PUTLN (1,
		    CH$ASCIZ (WARNING,
			'TOO MANY PARTITION ENTRIES'));

	PUT_PARTITION (.PCB_ADDRESS);

	IF FL$SET (GETWRD (.PCB_ADDRESS + FL$OFFSET (P_STAT)), PS_SYS)
	THEN
	    BEGIN

	    LOCAL
		SUB_ADDRESS;

	    SUB_ADDRESS = .PCB_ADDRESS;

	    WHILE (SUB_ADDRESS = GETWRD (.SUB_ADDRESS + FL$OFFSET (P_SUB))) NEQ 0 DO
		BEGIN

		IF (ENTRY_COUNT = .ENTRY_COUNT - 1) LSS 0
		THEN
		    RETURN PUTLN (1,
			    CH$ASCIZ (WARNING,
				'TOO MANY PARTITION ENTRIES'));

		PUT_PARTITION (.SUB_ADDRESS);
		END;

	    END;

	END;

    END;					!End of PCBS

ROUTINE PUT_ATTACHMENTS (PCB_ADDRESS) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	FE_PLA = 1^4;

    LOCAL
	ADR,
	ATT_ADDRESS;

    IF BIT_SET (GETWRD (SYMBOL ($FMASK)), FE_PLA) AND (GETWRD (.PCB_ADDRESS + FL$OFFSET (P_BLKS)) NEQ 0) AND ((
	ATT_ADDRESS = GETWRD (.PCB_ADDRESS + (ADR = SYMBOL ('P.ATT')))) NEQ 0) AND (GETWRD (.PCB_ADDRESS +
	    .ADR + 2) NEQ 0)
    THEN
	BEGIN

	LOCAL
	    ENTRY_COUNT;

	BIND
	    A_STAT_BITS = FIELDS_LIST ('AS.DEL', 'AS.EXT', 'AS.WRT', 'AS.RED');

	ENTRY_COUNT = RSX_MAX_ATD;
	PUTLN (2, CH$ASCIZ ('%6SATTACHMENT DESCRIPTORS:'));

	DO
	    BEGIN

	    IF (ENTRY_COUNT = .ENTRY_COUNT - 1) LSS 0
	    THEN
		RETURN PUTLN (1,
			CH$ASCIZ (WARNING,
			    'TOO MANY ATTACHMENT DESCRIPTORS'));

	    PUTLN (1,
		CH$ASCIZ ('%6SADDRESS   PARTITION   ATT TASK   A.PCBL   A.TCBL   PRI   IOC   MAP COUNT'));
	    PUTLN (0,
		CH$ASCIZ ('%6S-------   ---------   --------   ------   ------   ---   ---   ---------'));
	    PUTLN (0, CH$ASCIZ ('%6S%P     %@      %@    %P   %P   %D.   %D.      %D.'), .ATT_ADDRESS,
		DMPNAM, GETWRD (.ATT_ADDRESS + FL$OFFSET (A_PCB)), FL$OFFSET (P_NAM), DMPNAM,
		GETWRD (.ATT_ADDRESS + FL$OFFSET (A_TCB)), FL$OFFSET (T_NAM),
		GETWRD (.ATT_ADDRESS + FL$OFFSET (A_PCBL)), GETWRD (.ATT_ADDRESS + FL$OFFSET (A_TCBL)),
		GETBYT (.ATT_ADDRESS + FL$OFFSET (A_PRI)), GETBYT (.ATT_ADDRESS + FL$OFFSET (A_IOC)),
		GETBYT (.ATT_ADDRESS + FL$OFFSET (A_MPCT)));
	    PUTLN (1, CH$ASCIZ ('%6SSTATUS: %@'), BITLS, A_STAT_BITS,
		GETWRD (.ATT_ADDRESS + FL$OFFSET (A_STAT)));

	    IF .FLAGS [M_RSX_DUMP]
	    THEN
		BEGIN
		SKIP (1);
		VMADMP (0, .ATT_ADDRESS, .ATT_ADDRESS + A_LGTH^1);
		END;

	    END
	WHILE (ATT_ADDRESS = GETWRD (.ATT_ADDRESS + FL$OFFSET (A_PCBL))) NEQ 0;

	END;

    END;					!End of PUT_ATTACHMENTS
ROUTINE PUT_PARTITION (PCB_ADDRESS) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ADR;

    BIND
	P_STAT_BITS = FIELDS_LIST ('PS.OUT', 'PS.CKP', 'PS.CKR', 'PS.CHK', 'PS.FXD', 'PS.PER', 'PS.LIO',
		'PS.NSF', 'PS.COM', 'PS.PIC', 'PS.SYS', 'PS.DRV', 'PS.DEL');

    PUTLN (2, CH$ASCIZ ('PARTITION  ADDRESS  TYPE   MAIN    BASE    SIZE    TCB     PRO    PRI  IOC'));
    PUTLN (0, CH$ASCIZ ('---------  -------  ----  ------  ------  ------  ------  ------  ---  ---'));
    PUTLN (0, CH$ASCIZ (' %2R%12T%P   %4A  %2R%35T%P  %P  %P  %P  %D.%72T%D.'),
	GETWRD (.PCB_ADDRESS + FL$OFFSET (P_NAM) + 0), GETWRD (.PCB_ADDRESS + FL$OFFSET (P_NAM) + 2),
	.PCB_ADDRESS,
	(IF (ADR = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_MAIN))) EQL .PCB_ADDRESS THEN CH$ASCII ('MAIN') ELSE
	    CH$ASCII ('SUB ')), GETWRD (.ADR + FL$OFFSET (P_NAM) + 0), GETWRD (.ADR + FL$OFFSET (P_NAM) + 2),
	GETWRD (.PCB_ADDRESS + FL$OFFSET (P_REL)), GETWRD (.PCB_ADDRESS + FL$OFFSET (P_BLKS)),
	GETWRD (.PCB_ADDRESS + FL$OFFSET (P_TCB)),
	(IF (ADR = SYMBOL ('P.PRO')) LSS SYMBOL ('P.LGTH') THEN GETWRD (.PCB_ADDRESS + .ADR) ELSE 0),
	GETBYT (.PCB_ADDRESS + FL$OFFSET (P_PRI)), GETBYT (.PCB_ADDRESS + FL$OFFSET (P_IOC)));
    PUTLN (1, CH$ASCIZ ('%4SSTATUS: %@'), BITLS, P_STAT_BITS, GETWRD (.PCB_ADDRESS + FL$OFFSET (P_STAT)));

    IF .FLAGS [M_RSX_DUMP]
    THEN
	BEGIN
	SKIP (1);
	VMADMP (0, .PCB_ADDRESS, .PCB_ADDRESS + SYMBOL ('P.LGTH'));
	END;

    IF .PCB_ADDRESS EQL GETWRD (.PCB_ADDRESS + FL$OFFSET (P_MAIN)) THEN PUT_WAIT_QUEUE (.PCB_ADDRESS);

    PUT_ATTACHMENTS (.PCB_ADDRESS);
    END;					!End of PUT_PARTITION
ROUTINE PUT_WAIT_QUEUE (PCB_ADDRESS) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ADR,
	TCB_ADDRESS;

    BIND
	T_ST2_BITS = FIELDS_LIST ('T2.AST', 'T2.DST', 'T2.CHK', 'T2.CKD', 'T2.BFX', 'T2.FXD', 'T2.TIO',
		'T2.CAF', 'T2.HLT', 'T2.ABO', 'T2.STP', 'T2.SPN', 'T2.WFR');

    IF ((TCB_ADDRESS = GETWRD (.PCB_ADDRESS + FL$OFFSET (P_WAIT))) NEQ 0) AND (GETWRD (.PCB_ADDRESS +
	    FL$OFFSET (P_WAIT) + 2) NEQ 0)
    THEN
	BEGIN

	LOCAL
	    ENTRY_COUNT;

	ENTRY_COUNT = RSX_MAX_WTQ;
	PUTLN (2, CH$ASCIZ ('%6SWAIT QUEUE:'));
	PUTLN (1, CH$ASCIZ ('%7STASK    TCB ADR    TI    T.PRI    STATE'));
	PUTLN (0, CH$ASCIZ ('%7S----    -------    --    -----    -----'));

	DO
	    BEGIN

	    IF (ENTRY_COUNT = .ENTRY_COUNT - 1) LSS 0
	    THEN
		RETURN PUTLN (1,
			CH$ASCIZ (WARNING,
			    'TOO MANY WAITING TASKS'));

	    PUTLN (0, CH$ASCIZ ('%6S%@   %P     %@ %D.        %@'), DMPNAM, .TCB_ADDRESS, FL$OFFSET (T_NAM),
		.TCB_ADDRESS, DMPDEV, GETWRD (.TCB_ADDRESS + FL$OFFSET (T_UCB)),
		GETBYT (.TCB_ADDRESS + FL$OFFSET (T_PRI)), BITLS, T_ST2_BITS,
		GETWRD (.TCB_ADDRESS + FL$OFFSET (T_ST2)));
	    END
	WHILE (TCB_ADDRESS = GETWRD (.TCB_ADDRESS + FL$OFFSET (T_LNK))) NEQ 0;

	END;

    END;					!End of PUT_WAIT_QUEUE
END						!End of module

ELUDOM
