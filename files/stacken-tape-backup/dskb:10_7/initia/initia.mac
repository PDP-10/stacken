SUBTTL	AUTHOR:P.CONKLIN /PMW/JNG/WLH/KPY/WCL/GMU/CDO/TARL/RCB
; OLD AUTHOR INITIALS:/RCC/DAL/PFC




;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1970,1971,1972,1973,1974,1975,1976,1977,1978,1980,1982,1984,1985,1986,1987. 
;ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

	SALL				; CLEAN ASSEMBLY LISTINGS

	SEARCH	INTPRM

	PROLOG	(INITIA)

COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1970,1987.
ALL RIGHTS RESERVED.
\;END OF COPYRIGHT MACRO

	.REQUEST REL:HELPER		;LOAD LIBRARY MODULE

; JOB DATA AREA
	INT137
SUBTTL	INITIALIZATION

INITIA:	TDZA	F,F		;ALLOW FOR CCL ENTRY
	MOVX	F,F.NOHD!F.CCLC	;IF CCL CALL, SUPPRESS HEADER
	RESET			;CLEAR THE WORLD
	SETZB	1,ZER		;CLEAR OUT STORAGE
	MOVE	P,[ZER,,ZER+1]
	BLT	P,EZER-1
	MOVE	P,[1,,2]
	BLT	P,P
	MOVE	P,[IOWD L$PDL,PDL]  ;INITIALIZE PUSH-DOWN LIST
	MOVEI	T1,L$SBLK+.NSAST ;GET THE LENGTH OF OUR GENERIC STRING BLOCK
	MOVEM	T1,STR8BK	;SETUP THE WORD COUNT HALFWORD
IFN <L$SBLK-L$TERM>,MOVEI T1,L$TERM+.NSAST ;GET THE LENGTH OF A TERMINAL STRING BLOCK
	MOVEM	T1,MYTERM	;SETUP THE WORD COUNT
IFN <L$TERM-L$NNAM>,MOVEI T1,L$NNAM+.NSAST ;GET THE LENGTH OF A NODE NAME BLOCK
	MOVEM	T1,MYNODE	;SETUP THE WORD COUNT
	MOVEM	T1,MYNUMB	;  OF BOTH TYPES OF NODE NAMES

;NOW FIND SOME INITIAL SYSTEM VALUES

	MOVX	T1,%LDFFA	;GET [1,2]
	GETTAB	T1,		;PPN
	  MOVE	T1,[1,,2]	;(DEFAULT)
	MOVEM	T1,FFAPPN	;SAVE FOR LATER

	MOVX	T1,%LDSYS	;GET SYS:
	GETTAB	T1,		; PPN
	  MOVE	T1,[1,,1]	;LEVEL C?!?!?
	MOVEM	T1,SYSPPN	;SAVE FOR LATER

	MOVX	T1,%CNFLN	;FRCLIN GETTAB INDEX
	GETTAB	T1,		;GET FRCLIN TTY LINE NUMBER
	 SETO	T1,		;OOPS - NO SUCH BEAST
	TXO	T1,.UXTRM	;FAKE IT INTO A UDX
	MOVEM	T1,FLNNUM	;REMEMBER FRCLIN NUMBER

	GETPPN	T1,		;GET THIS JOB'S PPN
	  JFCL			;(IN CASE OF JACCT)
	MOVEM	T1,MYPPN	;SAVE FOR LATER USE
	PJOB	T1,		;GET THIS JOB NUMBER
	MOVEM	T1,JOBN		;REMEMBER IT
	MOVN	T2,T1		;NEGATIVE JOB NUMBER FOR JOBSTS TO
	JOBSTS	T2,		;GET THIS JOB'S STATUS
	  JRST	[TXO   	F,F.NJBS	;INDICATE JOBSTS FAILED
		MOVX   T2,%LDHLP	;CAN'T TELL--GET
		GETTAB T2,		;HELP PPN (UNLOGGED JOB)
		  MOVE T2,[2,,5]	; FROM SYSTEM
		CAME   T2,MYPPN		;SEE IF SAME
		TXO    F,F.LOGI		;NO--MUST BE LOGGED IN
		JRST   .+1]		;AND PROCEED
	TXNE	T2,JB.ULI	;SEE IF LOGGED IN YET
	TXO	F,F.LOGI	;YES. REMEMBER THAT

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVX	T1,%CNDTT	;DEFAULT TERMINAL TYPE
	GETTAB	T1,		;ASK THE MONITOR
	  MOVSI	T1,'TTY'	;PRE-7.04
	MOVEM	T1,DEFTYP	;SAVE FOR CHECK ROUTINE
	MOVX	T1,%CNDVN	;GET THE MONITOR'S
	GETTAB	T1,		;  VERSION NUMBER
	 SETZ	T1,		;ASSUME NO VERSION?
	ANDX	T1,VR.VER	;MASK DOWN TO THE MAJOR VERSION NUMBER
	CAMGE	T1,[INSVL.(703,VR.VER)] ;IS IT A GOOD VERSION NUMBER?
	TXO	F,F.OLD		;NO, OLD MONITOR
	MOVE	T3,FFAPPN	;GET FULL-FILE-ACCESS (OPR) PPN
	SETOM	T1		;-1 := PROGRAM'S CONTROLLING TTY
	GETLCH	T1		;GET OUR LINE CHARACTERISTICS
	MOVEM	T1,SAVLCH	;REMEMBER FOR THOSE WHO CARE
	HRRZ	T2,T1		;COPY OF JUST LINE INDEX
	MOVEM	T2,TERNUM	;REMEMBER TERMINAL UDX
	MOVEM	T2,TRMNUM	;ASSUME WANT OUR OWN TTY IN TYPTTY
	CAMN	T2,FLNNUM	;RUNNING ON FRCLIN?
	TXO	F,F.FLN		;YES, NOTE THAT FACT
	TXNE	F,F.FLN		;RUNNING ON FRCLIN?
	JRST	INITI2		;YES
	TXNN	T1,GL.CTY	;ON THE CTY?
	JRST	INITI4		;NO
	TXNE	F,F.LOGI	;ARE WE LOGGED IN?
	CAMN	T3,MYPPN	;YES, AS OPR?
	TXOA	F,F.CTY		;NOT LOGGED IN OR LOGGED IN AS OPR
	JRST	INITI4		;LOGGED IN AS RANDOM USER, NO CTY-SPECIAL
INITI2:	TXNN	F,F.LOGI	;ALREADY LOGGED IN?
	CHGPPN	T3,		;NO, REALLY WANT PRIVILEGES (FOR HPQ OR FRCUUO)
	 JFCL			;OH WELL, BLUNDER ONWARDS
IFG CTYHPQ,<			;IF WANT TO RUN IN HPQ
	MOVEI	T3,CTYHPQ	;SELECT DESIRED HPQ
	HPQ	T3,		;AND ASK MONITOR FOR PREFERENTIAL TREATMENT
	 JFCL			;HOHUM
> ;END IFG CTYHPQ

INITI4:	OPEN	TTY,[UU.AIO+.IOAS8
		     SIXBIT /TTY/
		     XWD TTYOBF,0]
	  JRST	LOGOF$		;CAN NOT FIX THIS
	MOVE	T1,[BF.VBR+TTYBUF+1] ;SETUP BUFFER HEADER
	MOVEM	T1,TTYOBF	; TO POINT TO OUR
	MOVE	T1,[POINT 8,0,35] ; OVERSIZED TTY
	MOVEM	T1,TTYPNT	; BUFFER
	MOVE	T1,[L$TTBF+1,,TTYBUF+1]
	MOVEM	T1,TTYBUF+1	;STORE POINTER IN BUFFER
	MOVE	T1,[PUSHJ P,LUUO] ;SET UP LOCATION 41
	MOVEM	T1,.JB41

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVSI	T1,'CTY'	; GET NODE,LINE FOR CENTRAL STATION
	PUSHJ	P,GTNTN$
	HRRZM	T1,NL.CTY
	IORI	T1,.UXTRM	;MAKE INTO A UDX
	HRRZM	T1,CTYNUM	;REMEMBER UDX FOR THE CTY

; NOW GET THE SIXBIT TTY NAME FOR THE CTY

	TLZ	T1,-1		; CLEAR OUT THE NODE
	PUSHJ	P,CVTSIX	; CONVERT TO SIXBIT
	LSH	T1,-^D18	; SHIFT NUMBER INTO RIGHT HALF
	HRLI	T1,'TTY'	; PLANT TTY
	MOVEM	T1,CTYTTY	; AND STORE AWAY FOR LATER

	MOVE	T1,['OPR0  ']	; GET NODE,LINE FOR CENTRAL OPR
	PUSHJ	P,GTNTN$
	MOVEM	T1,NL.OPR

	GETLIN	ME,0
	MOVE	WD,ME		; COPY THE TERMINAL NAME
	PUSHJ	P,XPNTTY	; EXPAND THE TERMINAL NUMBER
	MOVEM	WD,TRMNAM	; SAVE IT FOR LATER
	MOVE	T1,ME
	PUSHJ	P,GTNTN$
	MOVEM	T1,NL.ME
	TLZ	T1,-1		; GET RID OF THE NODE NUMBER
	PUSHJ	P,CVTSIX	; CONVERT TO A SIXBIT NUMBER
	HRRI	T1,'TTY'	; FILL IN THE OTHER HALF WITH A NAME
	MOVS	WD,T1		; COPY THE TERMINAL NAME
	PUSHJ	P,XPNTTY	; EXPAND THE NAME
	MOVEM	WD,TRMNNM	; SAVE THE NODE RELATIVE FLAVOR

	MOVE	T1,[.NOPNM+1,,.NOGDI] ; GET OUR NETOP. FUNCTION CODE AND ARG LENGTH
	MOVEM	T1,NOPBLK+.NOFCN;  TO READ THE TERMINAL INFO
	MOVEM	ME,NOPBLK+.NODEV; STORE THE DEVICE NAME
	XMOVEI	T1,MYNODE	; GET STORAGE FOR THE NODE NAME STRING
	MOVEM	T1,NOPBLK+.NONOD; AND STORE IN THE NETOP. ARG BLOCK
	XMOVEI	T1,MYTERM	; GET THE STRING BLOCK FOR THE PORT ID
	MOVEM	T1,NOPBLK+.NOPNM; STORE IT TOO.
	XMOVEI	T1,NOPBLK	; POINT TO THE ARG BLOCK
	NETOP.	T1,		; GET OUR TERMINAL'S REAL NAME
	  JRST	INITI3		; ERROR, GO TRY OLD ANF WAY
	MOVEI	T1,MYNODE	; OK, POINT AT MY NODE NAME
	PUSHJ	P,GET826	; CONVERT IT TO SIXBIT
	MOVEM	WD,MYNNAM	; STORE MY SIXBIT NODE NAME
	MOVE	T1,NOPBLK+.NOFLG; GET THE RETURNED FLAGS WORD
	TXNE	T1,NO.DCN	; IS THIS A DECNET LINE?
	TXO	F,F.DCNL	; YES, REMEMBER THAT
	TXNN	T1,NO.DCN!NO.LAT; ARE WE A FUNNY TERMINAL?
	TXOA	F,F.ANFL	; NO, ASSUME ANF
	JRST	INITI5		; YES, DON'T GET A NUMERIC NODE NAME THEN

INITI3:	HLRZ	T1,NL.ME	; GET MY NODE NUMBER
	PUSHJ	P,CVTSIX	; CONVERT TO SIXBIT-LEFT JUSTIFIED
	EXCH	WD,T1		; PUT THE WORD WHERE WE CAN COPY IT
	MOVEI	T1,MYNUMB	; POINT TO THE ASCII STORAGE BLOCK
	PUSHJ	P,GET628	; GET AN ASCII VERSION OF THIS
	EXCH	T1,WD		; PUT THE NODE NAME BACK INTO T1
	LSH	T1,-^D18	; SHIFT RESULT TO RIGHT HALF
	HRLI	T1,'OPR'
	PUSHJ	P,GTNTN$	; GET OUR, POSSIBLY LOCAL, OPR
	MOVEM	T1,NL.LOP

	TXOE	F,F.ANFL	;ALREADY HAVE OUR NODE NAME SETUP?
	JRST	INITI5		;YES, SKIP THIS
	MOVE	T2,[2,,T3]	; NODE. UUO ARGUMENT POINTER
	MOVEI	T3,2		; COUNT
	HLRZ	T4,NL.ME	; MY NODE
	NODE.	T2,0
	 MOVE	T2,['CENTRA']
	MOVEM	T2,MYNNAM	; SAVE SIXBIT NODE NAME
	MOVE	WD,T2		;COPY THE NODE NAME
	MOVEI	T1,MYNODE	;POINT TO THE NODE NAME STRING BLOCK
	PUSHJ	P,GET628	;CONVERT IT TO ASCII
	HRRZ	T1,NL.ME	;GET MY LINE NUMBER ON ANF NODE
	PUSHJ	P,CVTSIX	;CONVERT IT TO SIXBIT
	HRRI	T1,'TTY'	;MAKE IT INTO 'TTYNN' (SORT OF)
	MOVS	WD,T1		;COPY THE TERMINAL NAME
	MOVEI	T1,MYTERM	;POINT TO THE STORAGE FOR THE ASCII VERSION
	PUSHJ	P,GET628	;GET THE ASCII VERSION OF THE TERMINAL NAME
INITI5:	MOVX	T1,%CNSER	;GET APR
	GETTAB	T1,		; SERIAL
	  MOVEI	T1,0		; NUMBER
	MOVEM	T1,APRSN	;SAVE FOR LATER
	MOVE	T2,JOBN		;GET JOB NUMBER
	IDIVI	T2,^D36		;COMPUTE WORD AND POSITION FOR MY JOB
	MOVSI	T1,(1B0)	;IN "JOB WAITING FOR HIGHSEG LOCK" TABLE
	MOVNS	T3		;TO SPEED UP SYSTEM STARTUP
	LSH	T1,(T3)		;BY ONLY WAKING UP THE JOBS ACTUALLY
	MOVEM	T1,MYBIT	;WAITING, THIS PREVENTS LOTS OF
	ADDI	T2,JOBWAT	;JOBS FIGHTING FOR THE INTERLOCK
	MOVEM	T2,MYWRD

INIT.1:	MOVE	T2,TERNUM	;GET TERMINAL NUMBER
	MOVEI	T1,.TORSP	; GET RECEIVE SPEED
	MOVE	T3,[2,,T1]
	TRMOP.	T3,
	 SETO	T3,		; IF FAILS, USE ONES
	MOVEM	T3,MYSPD
SUBTTL	CODE TO HANDLE SPECIAL STARTUP CONDITIONS

	MOVE	T1,NL.ME	; GET OUR NODE/LINE
	TXNE	F,F.ANFL	; SKIP IF NOT ON AN ANF-10 LINE
	TLNN	T1,-1		; NODE ZERO?
	JRST	NOTREM		; YES, CAN'T BE REMOTE OPR THEN
	CAMN	T1,NL.LOP	; AM I A REMOTE OPR?
	CAMN	T1,NL.OPR	; ..
	JRST	NOTREM		; NO
	MOVEI	T1,4		;YES, MAKE SURE IT'S A REMOTE STATION
	MOVE	T2,MYNNAM	;OUR NODE NAME
	SETZ	T3,		;BLANK (RESERVED)
	MOVEI	T4,.TYMCR	;COMMAND PROCESSOR
	MOVE	T5,[.NDRCI,,T1]	;FUNCTION CODE FOR NODE.
	NODE.	T5,		;ASK
	  TLO	T4,1		;FAILED, CAN'T BE REMOTE OPR
	TLNN	T4,-1		;DOES THIS NODE HAVE ANY COMMAND DECODERS?
	TXO	F,F.REMO	;NO, MUST BE REMOTE OPERATOR
;HERE TO SEE IF CALLED FROM FORCED .HELLO COMMAND OR
;IF NORMAL COMMAND WITH ARGUMENTS.

NOTREM:	TLNE	ME,-1		;SEE IF DETACHED
	TXNE	F,F.CCLC	;OR IF CCL CALL
	JRST	INIC.6		;RIGHT--NO RESCAN

;HERE TO SEE IF WE HAVE COMMANDS ON LINE

	MOVEI	T1,TTYIN	;SET FOR TTY INPUT
	MOVEM	T1,GETCH	; IN CHARACTER GETTER
	RESCAN	1		;RETRY LINE
	  SKPINL		;SEE IF SOMETHING THERE
	    JRST INIC.3		;NOTHING--CHECK FOR FORCED CALL
	TXO	F,F.RTTY	;INDICATE COMMITMENT TO REEAT LINE
	PUSHJ	P,GETSIX	;SEE IF INITIA
	CAIN	CH,":"		;SEE IF DEVICE
	JRST	.-2		;YES--TRY AGAIN
	XOR	WD,['INITIA']	;SEE IF INITIA COMMAND
	TDNN	WD,T1		; OR ABBREVIATION
	JRST	INIC.2		;YES--GO SET FLAG
INIC.1:	CAIN	CH,"("		;SEE IF THIS FORM
	JRST	INIC.2		;YES--FLAG COMMAND
	PUSHJ	P,GETSIX	;NO--MOVE ON FOR (...) FORM
	TXNE	F,F.ECMD!F.EOF	;SEE IF END OF LINE YET
	JRST	INIC.6		;YES--GIVE UP
	JRST	INIC.1		;NO--LOOP ONWARDS
INIC.2:	TXO	F,F.ICMD	;SET COMMAND FLAG
	JRST	INIC.6		;AND PROCEED

;HERE IF NO COMMAND IN INPUT BUFFER.

INIC.3:			;COULD CHECK FOR .HELLO HERE
	TXNN	F,F.LOGI	;SEE IF LOGGED IN
	TXO	F,F.ANSW	;NO--INDICATE ANSWER MODE
INIC.6:
;CONTINUED ON NEXT PAGE
SUBTTL	MAIN PROGRAM--HANDLE COMMAND SCANNING AND DISPATCH

;CONTINUED FROM PREVIOUS PAGE

;HERE WHEN DONE WITH COMMAND ANALYSIS AND READY TO ISSUE
;THE SYSTEM SIGNON MESSAGE

INIS.0:	SETZM	GETCH		;CLEAR CHARACTER GETTER

;HERE TO LOOK FOR FILE SYS:TTY.INI

	MOVSI	T5,(UU.PHS)	;ASCII MODE, PHYSICAL ONLY.
	MOVSI	T6,'SYS'	;DEVICE SYS:
	MOVEI	T7,IBF		;POINT TO BUFFER HEADER
	MOVSI	T1,'TTY'	;FILE NAMED
	MOVSI	T2,'INI'	;  TTY.INI[-]
	SETZB	T3,T4		;  ..
	PUSHJ	P,HILOOK	;LOOK IN HISEG OR ON DSK:
	  INTERR(TNF,<SYS:TTY.INI not found>,<JRST TYIN.2>)
	MOVEI	T1,FILINC	;SET FOR FILE INPUT
	MOVEM	T1,GETCH	; FOR CHARACTER GRABBER
	TXZ	F,F.ECMD!F.EOF!F.ALIN ;CLEAR SCANNING FLAGS

;HERE TO LOOP OVER LINES IN FILE TO FIND ONE FOR THIS TTY

TYIN.1:	PUSHJ	P,FILELC	;CONDITIONALLY DO THIS LINE
	JUMPGE	CH,TYIN.1	;UNLESS EOF, LOOP THROUGH FILE
	SETZM	GETCH		;CLEAR CHARACTER GETTER
	SETZM	LOWPTR		;CLEAR PTR TO HISEG
	TXNE	F,F.LOGI	;ARE WE LOGGED IN?
	SETZM	FLCHEK		;YES--IGNORE CHECK FROM TTY.INI
TYIN.2:	RELEAS	TI,		;RELEASE FILE
;HERE TO LOOK FOR ENTRY IN DSK:SWITCH.INI[,]/PHY IF LOGGED IN

	TXNN	F,F.LOGI	;SEE IF LOGGED IN
	JRST	SWIN.3		;NO--SKIP SWITCH.INI
	MOVX	T1,UU.PHS	;YES--SET /PHYSICAL
	MOVSI	T2,'DSK'	;DSK:
	MOVEI	T3,IBF		;BUFFER HEADER
	OPEN	TI,T1		;OPEN
	  JRST	SWIN.3		;IGNORE IF CAN'T OPEN
	MOVE	T1,['SWITCH']	;FILE
	MOVSI	T2,'INI'	; SWITCH.INI
	MOVEI	T3,0		; ..
	MOVE	T4,MYPPN	; [,]
	LOOKUP	TI,T1		;GET FILE
	  JRST	SWIN.3		;IGNORE IF NOT THERE
	MOVEI	T1,FILINC	;SET FOR FILE INPUT
	MOVEM	T1,GETCH	; FOR CHARACTER GRABBER
	TXZ	F,F.ECMD!F.EOF!F.ALIN ;CLEAR SCANNING FLAGS

;HERE TO LOOP OVER LINES IN FILE TO FIND ONE FOR INITIA THIS TTY

SWIN.1:	PUSHJ	P,GETSIX	;GET FIRST WORD OF LINE
	CAME	WD,['INITIA']	;SEE IF FOR INITIA
	JRST	[PUSHJ P,FILELS	;NO--SKIP LINE
		 JRST  SWIN.2]	;AND FINISH LINE
	CAIE	CH,":"		;YES--SEE IF OPTION
	JRST	[PUSHJ P,FILELN	;NO--ASSUME ALL
		 JRST  SWIN.2]	;AND FINISH LINE
	PUSHJ	P,FILELC	;YES--DO IF THIS TTY
SWIN.2:	JUMPGE	CH,SWIN.1	;LOOP TO EOF
	SETZM	GETCH		;CLEAR CHARACTER GRABBER
SWIN.3:	RELEAS	TI,		;FREE CHANNEL
;HERE TO LOOK FOR THIS PROCESSOR S/N IN TABLE

	PUSHJ	P,DOCMD		;GO HANDLE COMMAND LINE
	PUSHJ	P,DOTTYS	;GO DO TTY SETUP
	TXNE	F,F.FLN		;FRCLIN?
	 JRST	INIF.0		;YES, START DUMPING STUFF DOWN FRCLIN
	SKIPE	T1,JUMPPR	;SEE IF PROCESSOR SET
	JRST	(T1)		;YES--GO DO THAT
	MOVE	T1,APRSN	;GET APR S/N
	MOVSI	T2,-APRTBL	;INITIALIZE FOR SEARCH ON APR S/N
	CAME	T1,APRTAB(T2)	;TEST FOR MATCH
	AOBJN	T2,.-1		;NO--LOOP UNTIL DONE
				;IF NOT FOUND, USE CATCHALL SET

;HERE TO LOOK THROUGH SPECIAL PROCESSING TABLE

	HRRZ	T3,APRTBV(T2)	;GET ADDRESS OF JUMP TABLE
	HLRZ	T2,APRTBV(T2)	;GET ADDRESS OF NAME TABLE
	HRLI	T2,T1		;ADD INDEXING
	HRLI	T3,T1		; ..

	MOVSI	T1,-SPTABL	;INITIALIZE FOR SEARCH ON NAME
TTYS.1:	SKIPN	T4,@T2		;FETCH TTY NAME, CHECK FOR END
	JRST	NOTFND		;END OF TABLE
	CAME	ME,T4		;TEST FOR MATCH
	AOBJN	T1,TTYS.1	;NO--LOOP UNTIL DONE
	JUMPGE	T1,NOTFND	;YES--IF NOT FOUND, GIVE UP
	HLRZ	T2,@T3		;SEE IF ANY TTY SET-UP NEEDED
	SKIPE	T2		;NO--SKIP
	PUSHJ	P,(T2)		;YES--SEND IT VIA SPECIAL ROUTINES
	HRRZ	T2,@T3		;GET SPECIAL PROCESSOR
	JUMPN	T2,(T2)		;GO TO IT IF NEEDED


;HERE IF NO SPECIAL PROCESSING REQUESTED IN TABLES
;SEE IF DEVICE OPR:, IF SO, BRING UP OPSER IN CCL MODE.
;THIS WILL CAUSE OPSER TO READ THE AUTO FILE AUTOMATICALLY.

NOTFND:	MOVX	T1,%CNOPR	;GET NAME OF
	GETTAB	T1,		; DEVICE OPR:
	  JRST	GEN		; IGNORE IF UNKNOWN
	TXNN	F,F.REMO	;YES--SEE IF REMOTE OPR
	CAMN	T1,ME		;NO--SEE IF LOCAL OPR
	JRST	OPSER1		;YES--GO DO OPSER CCL
;HERE FOR NON-INTERESTING TERMINAL

GEN:	MOVX	T1,%CNSTS	;GET SYSTEM STATES
	GETTAB	T1,		; FROM MONITOR
	  MOVEI	T1,0		;(ASSUME OK)
	TXNN	T1,ST%BON!ST%NRL!ST%NLG ;IF LOGIN ALLOWED,
	TXNE	F,F.LOGI	;SEE IF MIGHT WANT TO LOGIN
	JRST	GEN.4		;NO--JUST FINISH UP
	TTYSTR	[ASCIZ \Please LOGIN\]
	TXNE	F,F.NJBS	;SEE IF JOBSTS WORKED
	JRST	GEN.2		;NO--SKIP THIS LOGIC
	MOVEI	T1,1		;YES--START AT JOB 1
GEN.1:	MOVE	T2,T1		;GET THIS JOB NUMBER
	TRMNO.	T2,		;GET ITS TERMINAL
	  JRST	[JUMPN  T2,GEN.2 ;FAILED--IF NO ANSWER, GIVE UP
		 MOVN   T2,T1	;GET JOB
		 JOBSTS T2,	;GET ITS STATUS
		   JRST GEN.3	;OK IF NONE
		 HRLZ   T3,T1	;GET JOB NUMBER
		 HRRI   T3,.GTPPN ;GET ITS PPN
		 GETTAB T3,	;(FROM MONITOR)
		   MOVEI T3,0	; ..
		 CAME   T3,FFAPPN ;UNLESS [1,2],
		 JUMPL  T2,GEN.2 ; IF DETACHED, ISSUE MESSAGE
		 JRST   .+1]	;ELSE, CONTINUE LOOP
	AOJA	T1,GEN.1	;LOOP
GEN.2:	TTYSTR	[ASCIZ / or ATTACH/]
GEN.3:	TTYSTR	CRLFM

GEN.4:	JRST	KILJOB		;JUST TYPE SYSTEM START-UP MESSAGE
				; AND RETURN TO MONITOR
	SUBTTL	FRCLIN PROCESSING

;HERE TO FIND SYS:SYSJOB.INI AND FORCE IT DOWN FRCLIN'S THROAT

INIF.0:	CTYSTR	[ASCIZ\[FRCLIN INITIA: running]
\]				;LEAVE INCONTESTABLE TRACKS
	RELEAS	TTY,		;LEGGO OF TTY (AKA FRCLIN)
	MOVSI	T1,-1		;-1,,0 = DETACH
	ATTACH	T1,		;DETACH FROM FRCLIN
	 JRST	[CTYSTR	[ASCIZ\?FRCLIN INITIA: Unable to DETACH from FRCLIN
\]
		JRST	LOGO1$]		;SLIP BACK INTO THE CRACKS
	PUSHJ	P,ACCT$		;GO SET THE ACCOUNT STRING
	 CTYSTR	[ASCIZ\%FRCLIN INITIA: Unable to set account string for TTY STOMPER
\]				;COMPLAIN IF ERRORS HERE
	MOVE	T1,[-4,,T2]	;I'M DETACHED, ITS SAFE TO LOG IN AS [1,2]
	MOVE	T2,FFAPPN	;PPN WE ARE GOING TO LOGIN TO. (OPR JOB)
	MOVX	T3,%CNPRV	;GET THE PRIVILEGE
	GETTAB	T3,		;  BITS THAT WE'RE ALLOWED
	  MOVSI	T3,-1		;ERROR? DEC PRIVS ONLY,
	DMOVE	T4,[SIXBIT /TTY STOMPER/] ;USER NAME, MNEMONIC FOR JOB
	LOGIN	T1,		;LOG US IN, TO KEEP US SAFE FROM PROGRAMS
				;THAT DESTROY LOGGED OUT JOBS
;	JFCL			;Documentation claims this is an error return.
	MOVE	T1,[.STUVM,,[^D16384,,^D16384]] ;SET THE PHYSICAL AND VIRTUAL
	SETUUO	T1,		;  PAGE LIMITS FOR THIS JOB
	  SKIPA	T1,[.STUVM,,[^D512,,^D512]] ;FAILED?  TRY LOWER LIMITS
	SKIPA			;OK, GO ON
	SETUUO	T1,		;TRY TO SET THE LOWER LIMITS
	 JFCL			;NOT REALLY THAT IMPORTANT I GUESS
	MOVSI	T5,(UU.PHS)	;PHYSICAL ONLY SYS
	MOVSI	T6,'SYS'
	MOVEI	T7,IBF		;THE INPUT BUFFER
	MOVE	T1,[SIXBIT/SYSJOB/]
	MOVSI	T2,'INI'	;THE FILE TO READ
	SETZB	T3,T4		;REST OF THE LOOKUP BLOCK
	SETZM	LOWPTR		;IN CASE JUNK THERE
	OPEN	TI,T5		;OPEN DEVICE FOR SYSJOB
	  JRST	INIF.1		;SYS ISN'T THERE? LOSE.
	LOOKUP	TI,T1		;FIND SYSJOB.INI
	  JRST	INIF.1		;HMM. TELL CTY WE CAN'T FIND SYSJOB
	TXZ	F,F.EOF		;HAVEN'T SEEN EOF YET
	SETZM	FLNPNT		;NEED TO INIT BYTE STUFFER
	SETO	T7,		;SET THE INITIAL STATE FOR LOOKING FOR "LOG"
	MOVEI	CH,.CHCNC	;A CONTROL-C TO START THINGS OFF WITH A BANG
	TXO	F,F.ECMD	;"EOL"
	JRST	INIF.5		;ENTER SYSJOB.INI LOOP

INIF.1:	CTYSTR	[ASCIZ\%FRCLIN INITIA: Can't read SYS:SYSJOB.INI
\]
	JRST	TTWINI		;KEEP GOING
;LOOP SENDING SYSJOB.INI TO FRCLIN

INIF.3:	PUSHJ	P,FILIN		;GET ANOTHER CHARACTER
	 SKIPA			;EOL OR EOF. SEE WHICH
	JRST	INIF.5		;NORMAL CHARACTER, STUFF IT
	TXNN	F,F.OLD		;IF OLD MONITOR, END OF LINE MEANS END OF CMD
	SKIPGE	CH		;END OF FILE?
	TXO	F,F.ECMD	;YES, SAY SO.
	MOVEI	CH,.CHCRT	;GET EOL INDICATOR

;HERE WITH CHARACTER IN CH FOR FRCLIN

INIF.5:	SKIPN	FLNPNT		;READY FOR CHARACTERS?
	JRST	[MOVEI	T1,FLN$MX-1	;MAXIMUM BYTE COUNT
		TXNE	F,F.OLD		;OLD MONITOR?
		MOVEI	T1,FLO$MX-1	;YES, GET OLD MAXIMUM BYTE COUNT
		MOVEM	T1,FLNCNT	;SET THAT FOR CHAR LOOP
		MOVE	T1,[POINT 7,FLNBUF]  ;INITIAL BYTE POINTER
		MOVEM	T1,FLNPNT	;SET FOR CHAR LOOP
		TXNN	F,F.OLD		;NOT IF OLD MONITOR
		SKIPG	T7		;DID WE FIND "<CR>LOG"?
		JRST	.+1		;NO, JUST CONTINUE WITH THIS CHARACTER
		MOVEI	T1,FLN$MX-4	;YES, SAY WE ATE FOUR CHARACTERS
		MOVEM	T1,FLNCNT	;STORE THE NEW BYTE COUNT
		MOVE	T1,[POINT 7,FLNBUF,20] ;GET THE CORRECT BYTE POINTER
		MOVEM	T1,FLNPNT	;STORE THE NEW BYTE POINTER
		MOVE	T1,[ASCII \LOG\] ;GET THE CHARACTERS WE ATE
		MOVEM	T1,FLNBUF	;PUT THEM IN THE BUFFER
		JRST	.+1]		;CONTINUE WITH CHARACTER
	IDPB	CH,FLNPNT	;STASH THIS CHARACTER
	CAIL	CH,"a"		;IS THIS CHARACTER
	CAILE	CH,"z"		; LOWER CASE?
	SKIPA			;NO, GO ON
	SUBI	CH,"a"-"A"	;YES, MAKE IT UPPER CASE NOW
	CAIN	CH,.CHCRT	;IS THIS AN EOL?
	SETO	T7,		;YES, WE'RE ALWAYS WILLING TO FIND AN EOL
	CAMN	CH,[EXP .CHCRT,"L","O","G"]+1(T7) ;IS IT WHAT WE'RE LOOKING FOR NOW?
	XCT	[AOSA	T7		;YES, INCREMENT THE STATE
		 AOSA	T7
		 AOSA	T7
		 JRST	[TXNE	F,F.OLD		;IF OLD MONITOR,
			 JRST	.+1		;DON'T DO IT
			 TXO	F,F.ECMD	;END OF STRING. SAY END OF COMMAND TOO
			 MOVEM	T6,FLNPNT	;RESET THE BUFFER POINTER TO BEFORE COMMAND
			 JRST	INIF.4]]+1(T7)	;SEND THE STRING
	 SETO	T7,		;NO MATCH, RESET THE STATE
	SKIPN	T7		;JUST MOVE TO STATE ZERO?
	MOVE	T6,FLNPNT	;YES, SAVE THE STORAGE POINTER
	SOSLE	FLNCNT		;IF BUFFER FULL,
	TXNE	F,F.ECMD	;OR IF EOL
	CAIA			;EOL, OR BUFFER FULL
	JRST	INIF.3		;WANT MORE CHARACTERS

;TYPE THE CHARACTER STRING INTO FRCLIN AS A COMMAND

INIF.4:	MOVEI	T4,0		;A NULL
	IDPB	T4,FLNPNT	;ASCIZIZE THE STRING
	MOVEI	T4,FLNBUF	;THE BUFFER/STRING ADDRESS
	MOVE	T3,FLNNUM	;FRCLIN UDX
	MOVEI	T2,.TOTYP	;"TYPE" FUNCTION
	MOVE	T1,[3,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;TYPE INTO FRCLIN
	 JRST	[CTYSTR	[ASCIZ\?FRCLIN INITIA: Error typing SYSJOB.INI into FRCLIN
\]
		JRST	TTWINI]		;KEEP GOING
	SETZB	T4,FLNPNT	;RESET BYTE POINTER
	TXZN	F,F.ECMD	;WAS THAT EOL, OR LONG LINE?
	JRST	[CTYSTR	[ASCIZ \%FRCLIN INITIA: FRCLIN command too long
\]					;LONG LINE, JUST WARN ABOUT IT
		 SETO	T7,		;RESET THE STATE
		 JRST	INIF.3]		;GO GET THE REST OF THIS BUNCH
	TXZE	F,F.EOF		;EOL, ANY MORE FILE TO DO?
	JRST	TTWINI		;NO, JUST SLIP AWAY
	TXNE	F,F.OLD		;IF OLD MONITOR,
	SETO	T7,		;DON'T ALLOW THE "<CR>LOG" HACK
	MOVEI	T2,.TOTTC	;SKIP IF INPUT IN PROGRESS
INIF.8:	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;SEE IF INPUT IN PROGRESS ON FRCLIN
	 JRST	INIF.9		;THIS CAN'T FAIL.
	JUMPE	T1,INIF.3	;WHEN INPUT BUFFER EMPTY, GIVE HIM MORE
	SLEEP	T4,		;WAIT TWO TICS
	JRST	INIF.8		;SEE IF READY YET

INIF.9:	CTYSTR	[ASCIZ \%FRCLIN INITIA - Problem checking FRCLIN buffer
\]
	JRST LOGO2$		;QUIT
;HERE WHEN SYSJOB.INI HAS BEEN STUFFED DOWN FRCLIN'S THROAT.
;NOW WATCH FOR OPEN TTY LINES BOGGING DOWN THE SYSTEM, IF SO DESIRED.

TTWINI:
IFLE TTWMAX,<JRST LOGO2$>	;NO STOMPR DESIRED, GO AWAY.
IFG TTWMAX,<
	SKIPN	TTWFLG		;START UP STOMPR?
	JRST	[CTYSTR [ASCIZ \%%TTY STOMPER - Not starting
\]
		JRST LOGO2$]
	RELEASE	TI,		;LET GO OF ANYTHING ON THIS CHANNEL, SINCE
				;WE ARE GOING TO BE AROUND FOREVER.
	CTYSTR	[ASCIZ \%%TTY STOMPER - Starting
\]
	MOVE	T1,[SIXBIT \STOMPR\] ;SET NAME TO SOMETHING RECOGNIZABLE.
	SETNAM	T1,		;(SINCE WE DON'T NEED JACCT ANY MORE)

	MOVE	T1,[%FTDEB]	;GETTAB TABLE WITH FTRSP IN IT
	GETTAB	T1,		;FIND OUT THIS SET OF FEATURE TESTS
	 SKIPA			;FAIL
	TRNN	T1,F%RSP&777777	;DO WE HAVE FTRSP?
	 JRST	[CTYSTR[ASCIZ\?TTY STOMPER - FTRSP is turned off, aborting
\]
		JRST LOGO2$]
	SKIPE	TTWPCT		;GOT POINTERS?
	JRST	TTWIN0		;YES
	AOS	T1,.JBREL	;CALCULATE START ADDRESS OF CHAR COUNT BUFFER
	HRLI	T1,(<1B0 (T7)>)	;SO INDIRECT INDEXES OFF OF T7
	MOVEM	T1,TTWPCT	;SET LINE-INDEXED CHAR COUNT POINTER
	ADD	T1,NL.CTY	;ALLOW FOR ALL POSSIBLE TTY'S
	MOVEM	T1,TTWPTM	;SET LINE-INDEXED COUNT TIMER
	ADD	T1,NL.CTY	;ALLOW FOR ALL POSSIBLE TTY'S
	MOVEM	T1,TTWPRS	;SET LINE-INDEXED CHANNEL,,RECEIVE SPEED
	ADD	T1,NL.CTY	;T1 := FIRST ADDRESS PAST LAST DESIRED ADDRESS
	TLZ	T1,-1		;CLEAR JUNK OUT OF LEFT HALF
	MOVEM	T1,.JBFF	;NOTIFY .JBFF OF HAVING GRABBED MEMORY
	SUBI	T1,1		;T1 := LAST DESIRED ADDRESS
	CORE	T1,		;EXPAND MEMORY AS NEEDED FOR BUFFERS
	 JRST	[CTYSTR	[ASCIZ\?TTY STOMPER - Memory expansion failure
\]
		JRST	LOGO2$]		;GO AWAY

;MAP LINTAB AND LDBS IN, SO WE DON'T HAVE TO EXPEND UUOS.

	MOVE	T1,[%CNLNP]	;POINTER TO LINTAB
	GETTAB	T1,		;ASK MONITOR FOR POINTER
	 JRST	[CTYSTR[ASCIZ\?TTY STOMPER - Gettab failed
\]
		JRST LOGO2$]
	HRRZS	T2,T1		;CLEAR LEFT HALF, COPY ADDRESS
	ADD	T2,NL.CTY	;POINT TO END OF LINTAB
	LSHC	T1,-9		;CONVERT TO PAGE NUMBERS
	HLRZ	T4,T2		;COPY OFFSET WITHIN PAGE TO LINTAB
	SUBI	T1,1(T2)	;CONVERT TO NUMBER OF PAGES
	ADDI	T2,1(T1)	;POINT TO STARTING PAGE
	HRLZ	T2,T2		;PUT IN LEFT HALF AS MONITOR SOURCE ADDRESS
	HRRI	T2,LNTPAG	;PAGE IN OUR ADDRESS SPACE
	MOVE	T3,[.PAGSP,,T1]	;ARG FOR PAGE UUO
	PAGE.	T3,		;MAP IN LINTAB
	 JRST	[CTYSTR[ASCIZ\?TTY STOMPER - PAGE. to map LINTAB failed
\]
		JRST LOGO2$]	;GO AWAY.
	HRLI	T4,LNTPAG	;OUR PAGE FOR LINTAB
	LSH	T4,-9		;RIGHT JUSTIFY
	HRLI	T4,(<1B0(T7)>)	;MAKE IT AN INDIRECT POINTER
	MOVEM	T4,LINTAB	;ESTABLISH POINTER TO LINTAB
;MAP LDBS
	SETZ	T7,		;GET ZEROETH LDB
	MOVE	T1,@LINTAB	;GET POINTER TO FIRST LDB
	TXNE	F,F.OLD		;OLD MONITOR?
	TLZ	T1,-1		;YES, GET RID OF JUNK
	MOVE	T7,NL.CTY	;NUMBER OF LDBS
	SUBI	T7,1		;POINT TO LAST
	MOVE	T2,@LINTAB	;GET LAST LDB
	TXNE	F,F.OLD		;OLD MONITOR?
	TLZ	T2,-1		;YES, GET RID OF JUNK AGAIN
	LSHC	T1,-9		;CONVERT TO PAGE NUMBERS
	SUBI	T1,1(T2)	;CONVERT TO NUMBER OF PAGES
	ADDI	T2,1(T1)	;CONVERT TO STARTING PAGE
	HRLZ	T2,T2		;PUT IN LEFT HALF AS MONITOR SOURCE PAGE
	HRRI	T2,LDBPAG	;PAGE IN OUR ADDRESS SPACE
	MOVE	T4,T2		;SAVE FOR LATER
	MOVE	T3,[.PAGSP,,T1]	;ARG FOR PAGE UUO
	PAGE.	T3,		;ASK FOR THE PAGES
	 JRST	[CTYSTR[ASCIZ\?TTY STOMPER - PAGE. to map LDBs failed
\]
		JRST LOGO2$]	;GO AWAY
	HLRZ	T1,T4		;MONITOR'S PAGE
	SUBI	T1,(T4)		;MINUS OUR PAGE
	ASH	T1,9		;CONVERT TO ADDRESS (OFFSET)
	MOVEM	T1,LDBOFF	;SAVE AS OFFSET FROM LDB ADDR TO VIRTUAL ADDR

TTWIN0:	HRRZ	T8,NL.CTY	;LAST PHYSICAL TTY IN SYSTEM
	MOVNI	T8,-1(T8)	;(NEGATIVE) LAST "USER" TTY IN SYSTEM
	HRLZ	T8,T8		;T8 := MASTER AOBJN INDEXER FOR TTW LOOP

;FIRST MAKE A PASS OVER THE TTY LINES GETTING BASE VALUES

TTWIN2:	MOVE	T7,T8		;COPY OF AOBJN INDEXER
TTWIN3:	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TOICT	;TOTAL INPUT CHARACTER COUNT
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;READ TERMINAL INPUT CHARACTER COUNT
	 SETZ	T1,		;FAILED? ASSUME 0
	MOVEM	T1,@TTWPCT	;SAVE COUNT FOR THIS LINE
	MSTIME	T4,		;TIME OF DAY (MILLISECONDS)
	MOVEM	T4,@TTWPTM	;REMEMBER WHEN THE LAST COUNT WAS TAKEN
	SKIPE	@TTWPRS		;BETTER NOT HAVE ANY LINES HANGING AROUND
	HALT	.+1		;OH WELL
	SETZM	@TTWPRS		;CLEAR NEED-TO-GRAB FLAG
	AOBJN	T7,TTWIN3	;LOOP FOR ALL REAL TTY'S
	MOVX	T1,%SCNRI	;GETTAB INDEX TO
	GETTAB	T1,		;READ TOTAL SYSTEM CHARACTER COUNT
	 JRST	LOGO2$		;DON'T BOTHER
	MOVEM	T1,TTWNRI	;SAVE LAST TOTAL SYSTEM COUNT
	MOVEM	T4,TTWNTM	;AND THE TIME IT WAS SAMPLED

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;NOW CHECK ONCE A MINUTE FOR LINES RUNNING OPEN

TTWSL:
	MOVEI	T1,TTWSLP	;SLEEP INTERVAL
	SLEEP	T1,		;A (YAWN) QUICK NAP
TTWSL2:	MOVX	T1,%SCNRI	;GETTAB ITEM TO
	GETTAB	T1,		;OBTAIN SYSTEM CHARACTERS RECEIVED
	 JFCL			;CAN'T HAPPEN
	SUB	T1,TTWNRI	;T1 := INCREMENTAL CHARACTER COUNT
	ADDM	T1,TTWNRI	;ACCUMULATE TOTAL
	MSTIME	T4,		;GET CURRENT TIME OF DAY
	SUB	T4,TTWNTM	;T4 := MILLISECONDS SINCE LAST SAMPLE
	ADDM	T4,TTWNTM	;KEEP TOTAL UP TO DATE
	JUMPLE	T4,TTWIN2	;IF WRAPPED PAST MIDNIGHT, RESET
	IMULI	T1,^D1000	;ALLOW FOR UNITS CONVERSION
	IDIVI	T1,(T4)		;T1 := SYSTEM CHARACTERS PER SECOND THIS SAMPLE
	HRRZ	T2,NL.CTY	;NUMBER OF PHYSICAL TTY'S POSSIBLE
	ASH	T2,-4		;SCALE IT DOWN
	SKIPE	TTWILC		;INIT'ED LINE COUNT ZERO?
	JRST	TTWCHN		;NO--GO POLL
	CAMGE	T1,T2		;SEEING MUCH TTY ACTIVITY?
	JRST	TTWSL		;NO

TTWCHN:	SETZM	TTWILC		;RESET INIT'ED LINE COUNT
	MOVEI	T5,20		;FIRST CHANNEL WE USE
TTWCH0:	CAMLE	T5,TTWMCN	;PAST HIGHEST CHANNEL YET?
	 JRST	TTWSP		;YUP - GO AND CHECK FOR NEW OPEN LINES.
	HRLZ	T2,T5		;GET COPY OF CHANNEL NUMBER
	HRRI	T2,.FOGET	;FUNCTION CODE TO FILOP
	MOVE	T1,[XWD 1,T2]	;1 WORD, AND IT IS IN T2
	FILOP.	T1,		;GET STATUS OF THIS DEVICE
	 AOJA	T5,TTWCH0	;NOTHING THERE, TRY NEXT CHANNEL
	AOS	TTWILC		;COUNT THE INIT'ED LINE
	TRNE	T1,IO.ERR	;ANY ERROR ON IT?
	 JRST	TTWDET		;YES, LET GO OF THIS TTY
	MOVE	T2,T5		;GET THE CHANNEL NUMBER
	IONDX.	T2,		;GET THE UDX FOR THE CHANNEL
	 AOJA	T5,TTWCH0	;LOST. IGNORE THIS CHANNEL.
	HRRZI	T7,-.UXTRM(T2)	;COPY THE TERMINAL'S NUMBER FOR INDEXING
	MOVEI	T1,.TOICT	;NUMBER OF CHARACTERS SEEN (SHOULD BE 0)
	MOVE	T4,[2,,T1]	;ARG FOR TRMOP.
	TRMOP.	T4,		;GET NUMBER OF CHARACTER SINCE LAST TIME
	 MOVE	T4,@TTWPCT	;IF WE CAN'T, ASSUME NO CHARACTERS
	CAMG	T4,@TTWPCT	;DID WE GET ANYTHING?
	 AOJA	T5,TTWCH0	;NOPE - IGNORE THIS TERMINAL
	MOVEI	T1,.TOCIB	;CLEAR INPUT BUFFER
	MOVE	T4,[2,,T1]	;ARG FOR TRMOP
	TRMOP.	T4,		;CLEAR HIS INPUT BUFFER
	 AOJA	T5,TTWCH0	;NO CAN DO, MONITOR IS CONFUSED
	MOVEI	T1,.TORSP	;GET THE RECEIVE SPEED.
	MOVE	T4,[2,,T1]	;ARG FOR TRMOP.
	TRMOP.	T4,		;GET THE RECEIVE SPEED FOR THIS TERMINAL
	 AOJA	T5,TTWCH0	;THE MONITOR IS CONFUSED, IGNORE HIM.
	JUMPE	T4,TTWCH1	;SPEED IS ALREADY ZERO. CAN'T HELP THIS.
	SETZ	T3,		;MAKE HIS SPEED 0
	ADDI	T1,.TOSET	;SET FUNCTION.
	MOVE	T4,[3,,T1]	;ARG FOR TRMOP UUO.
	TRMOP.	T4,		;ZAP HIS SPEED.
	 AOJA	T5,TTWCH0	;THIS CANNOT HAPPEN. (KNOCK ON WOOD)
	CTYSTR	[ASCIZ \%TTY STOMPER: Zero-bauded line at \]
	PUSHJ	P,TTCNOD	;TYPE NODE SPECIFICATION FOR TTY ON CTY
TTWCH1:	MOVE	T7,T2		;LETS CLEAN THAT TTY A BIT.
	TRZ	T7,777000	;LEAVE ONLY THE LINE NUMBER.
	PUSHJ	P,TTWTCL	;CLEAN UP INPUT AND OUTPUT.
	AOJA	T5,TTWCH0	;AND GO ON TO THE NEXT TERMINAL

TTWDET:	MOVE	T3,T5		;TYPE THE CHANNEL NUMBER IN OCTAL
	PUSHJ	P,TTCOCT	; SO WE CAN TRACK WHEN WE GRABBED WHAT.
	CTYSTR	CRLFM		;END LINE
	MOVE	T3,T5		;GET COPY OF CHANNEL
	RESDV.	T3,		;RELEASE THE CHANNEL.
	 JFCL			;NO ERROR RECOVERY HERE.
	SOSGE	TTWILC		;COUNT DOWN NUMBER OF INIT'ED LINES
	SETZM	TTWILC		;BE REASONABLE
	AOJA	T5,TTWCH0	;TRY NEXT CHANNEL

;NOW SEE IF ANY LINES ARE BEHAVING OBNOXIOUSLY

TTWSP:	MOVE	T7,T8		;RESET LINE INDEXER
	SETZ	T6,		;OPEN LINES FLAG
TTWSP1:	MOVE	T1,@LINTAB	;GET LINTAB ENTRY FOR THIS TTY
	SUB	T1,LDBOFF	;CONVERT TO USER VIRTUAL ADDRESS
	HRRZ	T1,0(T1)	;GET DDB ADDRESS
	JUMPN	T1,[SETOM @TTWPTM ;FLAG DDB OCCUPIED
		   JRST TTWSP2]	;AND JOIN COMMON CODE
	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TOICT	;TOTAL INPUT CHARACTER COUNT
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;SEE HOW MANY CHARACTERS THIS LINE HAS SEEN
	 MOVE	T1,@TTWPCT	;DUH? ASSUME NO CHANGE
	MSTIME	T4,		;TIME OF DAY
	SKIPGE	@TTWPTM		;MAKE SURE WE COUNTED LAST TIME THROUGH.
	 JRST	[MOVEM T1,@TTWPCT ;WE DIDN'T, SET THINGS UP NOW
		MOVEM T4,@TTWPTM
		JRST TTWSP2]	;AND FALL INTO COMMON CODE.
	SUB	T1,@TTWPCT	;T1 := COUNT OF CHARACTERS SINCE LAST TIME
	ADDM	T1,@TTWPCT	;UPDATE TOTAL FOR NEXT ITERATION
	SUB	T4,@TTWPTM	;T4 := MILLISECONDS ELAPSED TIME
	ADDM	T4,@TTWPTM	;UPDATE TOTAL FOR NEXT ITERATION
	JUMPL	T4,TTWIN2	;IF WRAPPED AROUND MIDNIGHT, RESET EVERYTHING
	JUMPLE	T1,TTWSP2	;IF NO INPUT ACTIVITY THEN TTY IS OK
	IMULI	T1,^D1000	;SAME MULTIPLE AS TIME OF DAY
	IDIVI	T1,(T4)		;T1 := CHARACTERS PER SECOND
	CAIL	T1,TTWMAX	;SEEING "LOTS" OF ACTIVITY
	SETOB	T6,@TTWPRS	;FLAG TO STOMP ON THIS TTY
TTWSP2:	AOBJN	T7,TTWSP1	;SEE WHAT ELSE IS RUNNING OPEN
	JUMPE	T6,TTWSL	;IF NO LIKELY CANDIDATES, GO BACK TO SLEEP

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;AT LEAST ONE LIKELY CANDIDATE, SEE IF RUNNING OPEN, AND STOMP ON IT IF SO

	MOVE	T7,T8		;RESET AOBJN INDEXER
TTWSP4:	SKIPN	@TTWPRS		;WANT TO CHECK THIS LINE?
	JRST	TTWSP7		;NO
	HRRZ	T1,T7		;YES, GET LINE NUMBER
	PUSHJ	P,CVTSIX	;MAKE SIXBIT NNN
	IORI	T1,'TTY'	;MAKE INTO TTY NAME (SWAPPED)
TTWSP5:	MOVS	T3,T1		;PHYSICAL NAME OF THE TERMINAL
	SETZ	T4,		;NO BUFFERS
	MOVX	T2,UU.PHS+IO.SUP+.IOASC;NO ECHO, BUT ALLOW ^C
	MOVE	T1,[FO.PRV!FO.ASC+.FORED]  ;"OPEN" FILOP. FUNCTION
	MOVE	WD,[4,,T1]	;FILOP. ARG POINTER TO
	FILOP.	WD,		;OPEN THE TTY AS AN I/O DEVICE
	 JRST	[SETZM	@TTWPRS		;ASSUME IN USE AND VALID
		JRST	TTWSP7]		;CHECK THE REST
	LDB	T1,[POINTR T1,FO.CHN]  ;GET MONITOR-ALLOCATED CHANNEL
	CAMLE	T1,TTWMCN	;GREATER THAN MAX. CHANNEL?
	 MOVEM	T1,TTWMCN	;YUP. SAVE AWAY NEW HIGH.
	PUSH	P,T3		;SAVE DEVICE NAME FOR A WHILE
	GTNTN.	T3,		;CONVERT TO NODE,,LINE
	 JRST	[RESDV.	T1,	;NOT CONNECTED ANYWHERE - LET GO OF HIM.
		 JFCL		;IF WE CAN'T GET RID OF HIM, DON'T WORRY.
		POP	P,(P)	;POP DEVICE NAME OFF FOR A WHILE.
		SETZM	@TTWPRS	;ASSUME IN USE.
		JRST	TTWSP7]	;KEEP ON CHECKING FOR OTHER TTYS
	AOS	TTWILC		;REMEMBER ANOTHER INIT'ED LINE

;BUILD A LOGICAL NAME THAT LOOKS LIKE "NODE_TTY", WHERE NODE IS TWO DIGITS,
;AND TTY IS THREE DIGITS. IF NODE .GT. 100 (OCTAL), THE TOP DIGIT WILL BE JUNK.
TTWNAM:	HLRZ	T4,T3		;GET NODE NUMBER
	LSHC	T4,-3		;DROP LOW ORDER BYTE DIGIT FOR A WHILE
	ADDI	T4,'0'		;MAKE IT A SIXBIT NUMBER
	LSH	T4,3		;MAKE ROOM FOR PART OF A SIXBIT DIGIT
	LSHC	T4,3		;MAKE ROOM FOR THE REST, BRINGING IT IN.
	ADDI	T4,'0'		;MAKE IT A SIXBIT DIGIT
	LSH	T4,6		;MAKE ROOM FOR ANOTHER SIXBIT DIGIT
	ADDI	T4,'_'		;ADD IT IN
	MOVS	T5,T4		;SAVE NODE NUMBER FOR A WHILE
				;NOW DO THE TTY NUMBER
	LSHC	T3,-6		;DROP LOW ORDER TWO BYTES FOR A WHILE
	ANDI	T3,7		;KEEP ONLY HUNDREDS (64'S) DIGIT
	ADDI	T3,'0'		;MAKE IT SIXBIT
	LSH	T3,3		;MAKE ROOM FOR PART OF NEXT DIGIT
	LSHC	T3,3		;ROOM FOR REST, BRINGING IT IN
	ADDI	T3,'0'		;MAKE IT SIXBIT
	LSH	T3,3		;ROOM FOR LAST DIGIT
	LSHC	T3,3		;..
	ADDI	T3,'0'		;.....
	HLL	T3,T5		;GET "NODE_"
	POP	P,T2		;AND GET BACK TTY NAME
	DEVLNM	T2,		;SET LOGICAL NAME TO NODE,,LINE
	 JFCL			;IGNORE ANY ERROR.
	HRLOM	T1,@TTWPRS	;SAVE THE CHANNEL NUMBER AWAY

;NOW TRY TO CALM THE TTY DOWN

	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TORSP	;TTY RECEIVE SPEED
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;READ TTY RECEIVE SPEED
	 SETO	T1,		;DUH?
	HRRM	T1,@TTWPRS	;SAVE AWAY OLD TERMINAL RECEIVE SPEED
	MOVEI	T4,0		;0 BAUD
	MOVEI	T2,.TORSP+.TOSET;TTY RECEIVE SPEED
	MOVE	T1,[3,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;SET TERMINAL RECEIVE SPEED
	 JFCL			;OH WELL
	PUSHJ	P,TTWTCL	;CLEAR OUT ANY CHARACTERS
	AOS	T6		;FLAG WE DID SOMETHING
	PUSH	P,T3		;Save UDX for this terminal
	CTYSTR	[ASCIZ \%%TTY STOMPER: Quieting open line on TTY\]
	HRRZ	T3,T7		;GET TTY NUMBER
	PUSHJ	P,TTCOCT	;TYPE DIGITS
	CTYSTR	[ASCIZ	\ at \]
	POP	P,T2		;GET UDX BACK INTO T2
	PUSHJ	P,TTCNOD	;AND TYPE OUT THE NETWORK SPECIFICATION
TTWSP7:	AOBJN	T7,TTWSP4	;LOOK FOR ANY MORE TERMINALS
	JUMPL	T6,TTWSL	;IF NOTHING ACCOMPLISHED, BACK TO SLEEP

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;NOW WAIT AROUND A BIT FOR THE LINES TO SETTLE DOWN

TTWSQ:	MOVEI	T6,4		;REPEATITION COUNTER
TTWSQ0:	MOVE	T7,T8		;RESET INDEXER
TTWSQ1:	SKIPE	@TTWPRS		;POUNDING ON THIS TERMINAL?
	PUSHJ	P,TTWTCL	;YES, EAT ANY STRAGGLING CHARACTERS
	AOBJN	T7,TTWSQ1	;CHECK EM ALL
	MOVEI	T1,1		;A FEW SECONDS
	SLEEP	T1,		;TO WAIT FOR STRAGGLERS
	SOJG	T6,TTWSQ0	;LOOK FOR STRAGGLING STRAGGLERS

;NOW RESET THE TERMINALS TO A WORKABLE STATE

TTWSR:	MOVE	T7,T8		;RESET AOBJN INDEXER
TTWSR1:	SKIPN	T6,@TTWPRS	;HAVE WE GRABBED THIS LINE?
	JRST	TTWSR7		;NO
	HRRE	T4,T6		;GET ORIGINAL TERMINAL RECEIVE SPEED
	JUMPL	T4,TTWSR3	;IF NO RECEIVE SPEED DON'T RESET IT
	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TORSP+.TOSET;TTY RECEIVE SPEED
	MOVE	T1,[3,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;RESTORE TERMINAL RECEIVE SPEED
	 JFCL			;TOO BAD
TTWSR3:	SETZM	@TTWPRS		;THIS TTY LINE OF NO FURTHER INTEREST
TTWSR7:	AOBJN	T7,TTWSR1	;LOOP FOR EM ALL
	JRST	TTWSL2		;BACK AND TRY AGAIN


;HELPER TO CLEAR TTY INPUT AND OUTPUT (ASSUMES T7 IS LINE NUMBER)

TTWTCL:	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TOCIB	;CLEAR INPUT BUFFER FUNCTION
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;EAT ALL INPUT PENDING
	 JFCL			;DUH?
	MOVEI	T2,.TOCOB	;CLEAR OUTPUT BUFFER FUNCTION
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;EAT ALL OUTPUT TOO
	 JFCL			;SHOULDN'T HAPPEN
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	MOVEI	T2,.TOICT	;READ INPUT CHARACTER COUNT
	TRMOP.	T1,		;GO READ IT
	 MOVE	T1,@TTWPCT	;CAN'T? JUST USE AN OLD VALUE
	MOVEM	T1,@TTWPCT	;STORE NUMBER OF CHARACTERS SEEN.
	POPJ	P,		;ALL CHARACTERS EATEN

;Type out a node specification for a TTY on the CTY
;Assumes UDX is in T2

TTCNOD:	MOVE	T1,T2		;UDX, TO GET THE NODE NUMBER
	GTNTN.	T1,		;WE GET NODE,,LINE NUMBER
	 JRST	TTCGER		;FAILED??
	HLRZM	T1,NODLOC	;GET NODE NUMBER
	MOVEI	T3,2		;LENGTH OF ARGLIST
	MOVEM	T3,NODLEN	;NUMBER OF WORDS FOR NODE UUO
	MOVE	T3,[.NDRNN,,NODBLK];ARGUMENT FOR NODE. UUO
	NODE.	T3,		;TRANSALATE NODE NUMBER TO NODE NAME
	 JRST	TTCNER		;THIS SHOULDN'T HAPPEN.
	PUSHJ	P,TTCSIX	;TYPE IT OUT ON THE CTY
	CTYSTR	[ASCIZ \_TTY\]	;NODE_TTYNNN SEPARATOR
TTWT1O:	HRRZ	T3,T1		;LINE NUMBER
	PUSHJ	P,TTCOCT	;TYPE THE OCTAL LINE NUMBER ON CTY
	CTYSTR	CRLFM		;END LINE WITH CRLF
	POPJ	P,		;FINISHED DUMPING JUNK.

TTCGER:	CTYSTR	[ASCIZ\ GTNTN. failed, code \]
	TRNA			;FALL INTO TYPEOUT CODE
TTCNER:	CTYSTR	[ASCIZ\ NODE. failed, code \]
	JRST	TTWT1O		;TYPE OUT T1 IN OCTAL

;Type out an octal number on the CTY.
;Assumes octal number in T3

TTCOCT:	IDIVI	T3,10		;GET OUT A DIGIT
	PUSH	P,T4		;PUSH THE DIGIT
	SKIPE	T3		;HAVE WE EXTRACTED ALL WE CAN?
	 PUSHJ	P,TTCOCT	;NOPE, TRY FOR ANOTHER DIGIT OR TWO.
	POP	P,T4		;GET TOP DIGIT (FIRST DIGIT)
	CTYCHR	"0"(T4)		;TYPE OUT THE DIGIT CORRESPONDING.
	POPJ	P,		;RETURN, EITHER MORE DIGITS, OR TO USER.

TTCSIX:	JUMPE	T3,CPOPJ	;IF NOTHING LEFT, RETURN
	SETZ	T4,		;CLEAR DESTINATION
	ROTC	T3,6		;SHIFT BY ONE CHARACTER
	CTYCHR	" "(T4)		;OUTPUT THE CHARACTER IN ASCII ON THE CTY
	JRST	TTCSIX		;AND TRY FOR A FEW MORE CHARACTERS.
>;END IFG TTWMAX
SUBTTL	HANDLE COMMAND LINE

;SUBROUTINE TO HANDLE COMMAND LINE

DOCMD:	TXNE	F,F.RTTY	;IF NO COMMAND LEFT, RETURN
	TXNN	F,F.ICMD	;SEE IF COMMAND
	POPJ	P,		;NO--GIVE UP
	MOVEI	T1,TTYIN	;SET FOR TTY
	MOVEM	T1,GETCH	; IN CHARACTER GRABBER
	MOVEI	CH,0		;CLEAR CHARACTER GRABBER
	TXZ	F,F.ECMD!F.EOF!F.ALIN ;CLEAR SCANNING FLAGS
	PUSH	P,FLSET		;SAVE PREVIOUS VALUE
	SETZM	FLSET		;MAKE SURE WE ONLY LOOK AT COMMAND LINE
DOCM.1:	TXNN	F,F.ECMD!F.EOF	;SEE IF END OF COMMAND
	CAIN	CH,")"		;SEE IF END OF COMMAND YET
	JRST	DOCM.3		;YES--ALL DONE
	PUSHJ	P,GETSIX	;GET NEXT COMMAND WORD
	JUMPE	WD,DOCM.2	;LOOP IF NULL
	MOVE	T2,FLSET	;SEE IF "SET" TYPED YET
	CAIN	T2,2		;WAS IT?
	SKIPA	T2,[IOWD CMDLT,CMDT]	;YES, USE EXTENDED POSSIBILITIES
	MOVE	T2,[IOWD CMDLL,CMDT]	;NO, POINT TO NORMAL POSSIBILITIES
	PUSHJ	P,FNDCMD	;FIND AND STORE COMMAND
	INTERR	(CER,Command Error,<JRST KILJOB>)
DOCM.2:	CAIN	CH,"-"		;SEE IF -XYZ
	PUSHJ	P,NO$		;YES--SET NOXYZ
	TXZN	F,F.CERR	;SEE IF ERROR
	JRST	DOCM.1		;NO--LOOP

;HERE AT END OF COMMAND--CLEAN UP LINE

DOCM.3:	TXZE	F,F.ECMD!F.EOF	;SEE IF END OF LINE
	JRST	DOCM.4		;YES--RETURN
	PUSHJ	P,GETSIX	;NO--GET NEXT WORD
	JRST	DOCM.3		;LOOP UNTIL DONE
DOCM.4:	POP	P,T1		;GET PREVIOUS "SETTTY"
	SKIPN	FLSET		;IF NOT TYPED,
	MOVEM	T1,FLSET	;USE IT
	SETZM	GETCH		;CLEAR CHARACTER GRABBER
	POPJ	P,		;RETURN
;ROUTINES TO HANDLE A LINE IN TTY.INI
;FILELC--CONDITIONAL BASED ON FIRST WORD BEING THIS TTY
;FILELN--ALWAYS
;FILELS--NEVER
;ALL RETURN AT END OF LINE

FILELC:	TXZ	F,F.PARN!F.NODL	;CLEAR THE PAREN INDICATOR

;TOP OF LOOP FOR LIST OF THE FORM (NODE_ID,NODE_ID):

FILE.0:	MOVE	T8,TRMNAM	;GET OUR EXPANDED TERMINAL NAME
	SETZ	T7,		;CAN'T USE OUR ASCII NAME UNLESS NODE MATCH

;GET A NODE NAME:

	MOVEI	T1,STR8BK	;POINT TO OUR STRING STORAGE
	PUSHJ	P,GETAS8	;GET THE NODE NAME

;SEE IF WE'VE GOT A LIST OF NODE_ID PAIRS:

	HLRZ	T1,STR8BK+.NSASL ;GET THE NUMBER OF BYTES READ
	JUMPE	T1,[CAIE CH,"("		;NONE.  ARE WE DOING A LIST?
		    JRST FILELS		;NOPE.  LOOPS LIKE GARBAGE
		    TXO  F,F.PARN!F.NODL;YEAH, SAY WE'RE DOING A LIST
		    JRST FILE.0]	;RESTART THE LOOP

;SEE IF IT REALLY LOOKS LIKE A NODE NAME:

	SETZ	WD,		;ASSUME QUOTED NODE NAME STRING
	MOVEI	T1,STR8BK	;POINT TO THE STRING STORAGE
	TXNN	F,F.QUOT	;WAS IT QUOTED?
	PUSHJ	P,GET826	;NO, CONVERT IT TO SIXBIT
	CAIE	CH,":"		;IS THIS ANY SORT OF
	CAIN	CH,"_"		; NODE NAME TERMINATOR?
	SKIPA			;YES, PROCESS THE NODE NAME
	JRST	FILE.3		;NO, GO DO A RAW TERMINAL NAME THEN
	CAIN	CH,":"		;IS IT A NEW FLAVOR TERMINATOR?
	JRST	[PUSHJ	P,GETCHA	;MAYBE, GET THE NEXT CHARACTER
		 CAIN	CH,":"		;IS IT "::"?
		 JRST	.+1		;YEAH, GO ON THEN
		 MOVEM	CH,REEAT	;NO, PUT THE CHARACTER BACK
		 JRST	FILE.3]		;AND TRY THE TERMINAL NAME

;GOT A NODE NAME. SEE IF IT MATCHES SOME FORM OF OUR NODE NAME OR "ALL"

	CAMN	WD,['ALL   ']	;UNIVERSAL NODE DESIGNATOR?
	JRST	FILE.1		;YES, THIS NODE NAME WINS
	MOVEI	T1,STR8BK	;NO, POINT TO THE NODE NAME
	MOVEI	T2,MYNODE	; AND MY NODE NAME
	PUSHJ	P,CMPS8		;ARE THEY THE SAME?
	 SKIPA			;NO, TRY THE NODE NUMBER IF THERE IS ONE
	JRST	FILE.1		;YES, GO LOOK FOR THE TERMINAL NAME
	MOVEI	T1,STR8BK	;POINT TO THE NODE NAME AGAIN
	MOVEI	T2,MYNUMB	; BUT THIS TIME, TRY MY NODE NUMBER
	PUSHJ	P,CMPS8		;ARE THEY THE SAME?
	 SKIPA			;NO, SKIP THIS LINE
	JRST	FILE.1		;YES, GO PROCESS THIS LINE

;IF NODE NAME DOESN'T MATCH, GO AHEAD AND EAT THE PORT ID JUST IN CASE WE'RE
;PROCESSING A LIST (WE'D LIKE TO SEE THE ",")

	MOVEI	T1,STR8BK	;POINT TO THE SCRATCH STORAGE
	PUSHJ	P,GETAS8	;GO READ THE PORT ID ANYWAY
	JRST	FILE.7		;THEN SEE IF WE'RE IN A LIST

;NODE NAMES MATCH.  READ THE TERMINAL NAME, AND MAKE SURE WE ONLY TRY TO MATCH
;THE NODE'S TTY NUMBER INSTEAD OF THE CENTRAL STATION'S

FILE.1:	MOVE	T8,TRMNNM	;GET THE NODE RELATIVE TERMINAL NAME
	MOVEI	T7,MYTERM	;AND POINT TO THE ASCII TERMINAL NAME STRING

;TOP OF LOOP FOR LISTS OF THE FORM NODE_(ID,ID,ID)

FILE.2:	MOVEI	T1,STR8BK	;POINT BACK AT OUR SCRATCH STORAGE
	PUSHJ	P,GETAS8	;GET THE NEXT PIECE OF ASCII
	MOVEI	T1,STR8BK	;POINT AT THE NEWLY FILLED BLOCK
	SETZ	WD,		;ASSUME IT WAS A QUOTED STRING
	TXNN	F,F.QUOT	;WAS IT?
	PUSHJ	P,GET826	;NO, CONVERT IT TO SIXBIT

;HERE IF NO NODE NAME, OR IF NODE NAMES MATCH.  SEE IF THE APPARENT TERMINAL
;NAME IS REALLY SOME MAGIC COMMAND:

FILE.3:	MOVSI	T1,-FILECL	;GET THE NUMBER OF MAGIC COMMANDS

FILE.4:	CAMN	WD,FILECM(T1)	;HAVE WE GOT A MATCH?
	JRST	@FILECD(T1)	;YES, GO DISPATCH IT
	AOBJN	T1,FILE.4	;NO, TRY THE NEXT ONE

;NOT A COMMAND, TRY TERMINAL LIST, TERMINAL NAME, ETC

	HLRZ	T1,STR8BK+.NSASL ;GET THE NUMBER OF BYTES READ
	JUMPE	T1,[CAIN CH,"("		;NONE?  IS THIS A LIST?
		    TXOE F,F.PARN	;YES, ALREADY DOING A LIST?
		    JRST FILELS		;NO, YES. PUNT OFF THIS LINE
		    JRST FILE.2]	;YES, NO. GO GET FIRST LIST ITEM
	SKIPE	WD		;ANY SIXBIT TERMINAL NAME?
	PUSHJ	P,XPNTTY	;YES, EXPAND THE NUMBER
	CAIE	CH,"-"		;ARE WE DOING A RANGE?
	JRST	FILE.5		;NO, TRY AN EXPLICIT TERMINAL NAME THEN
	TXNN	F,F.ANFL	;IS THIS AN ANF-10 NODE?
	JRST	FILELS		;NO, CAN'T DO LISTS ON DECNET/LAT PORT IDS

;WE'VE BEEN GIVEN A RANGE OF TTY NUMBERS OF THE FORM "TTYnn-TTYmm" or "TTYnn-mm"

	PUSHJ	P,CVTBIN	;YES, CONVERT THE NUMBER TO BINARY
	MOVE	T6,WD		;COPY THE LOWER BOUND
	PUSHJ	P,GETSIX	;GET THE NEXT BIT OF BINARY
	JUMPG	WD,[HLRZS WD		;IF DIGITS ONLY,
		    HRLI  WD,'TTY'	; MAKE IT TTYNN
		    JRST  .+1]		;AND CONTINUE
	PUSHJ	P,XPNTTY	;EXPAND THE TERMINAL NUMBER
	PUSHJ	P,CVTBIN	;AND CONVERT THE NUMBER TO BINARY
	MOVE	T5,WD		;COPY THE UPPER BOUND
	CAMGE	T5,T6		;ARE THEY IN REVERSE ORDER?
	EXCH	T6,T5		;YES, UNREVERSE THEM
	MOVE	WD,T8		;GET OUR CURRENT LINE NAME
	PUSHJ	P,CVTBIN	;PULL THE NUMBER OUT OF IT
	CAMG	T6,WD		;IS IT IN THE
	CAMGE	T5,WD		;SPECIFIED RANGE?
	JRST	FILE.7		;NO, SKIP IT
	JRST	FILE.6		;YES, WE WIN

;HERE IF JUST A GENERIC TTY DESIGNATOR.  SEE IF THE SIXBIT LINE ID MATCHES.
;IF NOT, COMPARE THE ASCII VERSIONS.  THE ASCII COMPARISON CAN ONLY HAPPEN
;WHEN WE'VE SEEN AN EXPLICIT NODE NAME MATCH.

FILE.5:	HLRZ	T1,STR8BK	;GET THE NUMBER OF BYTES FROM TTY.INI
	JUMPE	T1,FILE.7	;NOTHING?  TRY NEXT LIST ITEM
	CAMN	WD,T8		;DO WE MATCH LINE NAMES?
	CAILE	T1,6		;YES. IS IT BIGGER THAN A SIXBIT WORD THOUGH?
	SKIPA			;NO. TRY THE REGULAR NAME
	JRST	FILE.6		;YES, GO DO IT THEN
	MOVEI	T1,STR8BK	;NO, POINT AT THE STRING STORAGE
	SKIPE	T2,T7		;AND AT OUR PORT ID IF APPROPRIATE
	PUSHJ	P,CMPS8		;DO THEY MATCH?
	 JRST	FILE.7		;NO, PUNT IT
	SKIPA			;YES, SKIP "OTHER" ENTRY

;HERE IF "OTHER" FOR THE TERMINAL NAME:

FILEOT:	TXNN	F,F.ALIN	;SKIP IF WE'VE EVER DONE ANYTHING

;HERE IF WE WANT TO DO A LINE:

FILE.6:	PUSHJ	P,FILELN	;GO DO THE REST OF THE LINE
	TXO	F,F.ALIN	;SAVE WE'VE BEEN HERE
	POPJ	P,		;AND RETURN

;HERE IF THIS LINE DOESN'T MATCH.  SEE IF WE'RE DOING A LIST:

FILE.7:	CAIN	CH,","		;DOES IT LOOK LIKE A LIST?
	TXNN	F,F.PARN	;YES, DOES IT SMELL LIKE ONE TOO?
	JRST	FILELS		;NOPE.  SKIP THE REST OF THE LINE
	TXNN	F,F.NODL	;YES, ARE WE LOOPING ON IDS ONLY?
	JRST	FILE.2		;YES, GO TRY THE NEXT ID
	JRST	FILE.0		;NO, TRY FOR A NEW NODE NAME

;TABLE OF MAGIC COMMANDS THAT CAN OCCUR IN PLACE OF A TERMINAL NAME:

FILECM:	<SIXBIT	\OTHER\>	;CONNECT IF NOTHING MATCHED SO FAR
	<SIXBIT	\ALL\>		;APPLIES TO EVERYTHING WITH NODE MATCH
	<SIXBIT	\DETECT\>	;MATCH IF AUTOBAUD LINE
	<SIXBIT	\LINSPD\>	;MATCH IF SPEED MATCHES
	<SIXBIT	\OTHSPD\>	;MATCH IF OTHER THAN SPEED GIVEN
	<SIXBIT	\CONNECT\>	;CONNECT ANF NETWORK LINES
	<SIXBIT	\STOMP\>	;START THE TTY STOMPER
	<SIXBIT	\FRCLIN\>	;MATCH IF WE'RE FRCLIN
	<SIXBIT	\APC\>		;MATCH ON .TOAPC VALUE
FILECL==.-FILECM		;NUMBER OF ENTRIES IN THIS TABLE

FILECD:	FILEOT			;DISPATCHES FOR ABOVE COMMANDS
	FILELN
	FILDET
	FILASP
	FILOSP
	FILCON
	STOMP
	FRCLIN
	FILAPC

;HERE IF WE'VE GOT A TERMINAL MATCH.  PROCESS COMMANDS ON THIS LINE

FILELN:	TXZE	F,F.PARN	;DO COMMAND--SEE IF IN LIST
	JRST	[CAIN  CH,")"	;YES--SEE IF DONE YET
		 JRST  .+1	;YES--PROCEED
		 PUSHJ P,GETSIX	;NO--GET ANOTHER WORD
		 CAIN CH,.CHLFD	;CHECK FOR END-OF-LINE
		 JRST	FILE.8	;FOUND IT, STOP LOSING SEARCH
		 JUMPE CH,FILE.8 ;STOP ON END-OF-FILE TOO
		 JRST	.]	;AND LOOP
	PUSHJ	P,DOFILE	;DO THIS COMMAND
FILELS:	JUMPLE	CH,FILE.9	;IF END OF FILE, SKIP ON
	CAIN	CH,.CHLFD	;IF END OF LINE,
	JRST	FILE.9		;  SKIP ON
	PUSHJ	P,GETSIX	;ELSE, SKIP THIS LINE
	JRST	FILELS		; AND LOOP

;HERE WHEN TIME TO PROCEED ON THROUGH FILE

FILE.8:	PUSHJ	P,ERRFCR	;UNMATCHED LEFT PAREN -- COMPLAIN
FILE.9:	TXZ	F,F.ECMD	;CLEAR END OF COMMAND LINE
	TXZ	F,F.PARN	;CLEAR PAREN INDICATOR
	POPJ	P,		;RETURN

	; ROUTINES TO SCAN LINES BASED ON SPEEDS

SCNSPD:	; SCAN OFF THE SPEED PART
	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETSIX	;GET SIXBIT WORD
	MOVE	T2,[IOWD SPEEDL,SPEEDT]
	PUSHJ	P,FNDWRD	;FIND SPEED
	 SKIPA			; TRY SPEED UNKNOWN
	POPJ	P,		;RETURN
	MOVNI	T2,2		; USE -2 FOR ERROR, -1 FOR UNKNOWN
	MOVE	T3,['UNKNOW']	; SEE IF UNKNOWN
	AND	T3,T1		; GET TO RIGHT LENGTH
	CAMN	WD,T3		; SEE IF SAME
	 SETO	T2,		; YES, USE -1
	POPJ	P,
FILASP:	PUSHJ	P,SCNSPD	; GET THE SPEED INDICATED
	CAME	T2,MYSPD	; SAME AS MINE?
	 JRST	FILE.7		; NO, TRY ANOTHER LINE
	JRST	FILE.6		; YES, DO THIS LINE

FILOSP:	PUSHJ	P,SCNSPD	; GET THE SPEED
	CAMN	T2,MYSPD	; SAME AS MINE?
	 JRST	FILE.7		; YES, TRY ANOTHER
	JRST	FILE.6		; NO, SO DO THIS ONE

FILDET:	PUSHJ	P,SCNSPD	; GET SPEED
	CAMN	T2,MYSPD	; SAME AS MINE?
	TXNN	F,F.ANSW	; AND ARE WE DOING .HELLO?
	 JRST	FILE.7		; NO
	JRST	FILE.6		; YES

;HERE IF "FRCLIN" SEEN IN TTY.INI

FRCLIN:	TXNN	F,F.FLN		;RUNNING ON FRCLIN?
	JRST	FILELS		;NO, IGNORE THIS COMMAND
	JRST	STMP.0		;GO LOOK FOR FRCLIN COMMANDS

;HERE TO FLAG STOMP SEEN IN TTY.INI

STOMP:	TXNN	F,F.FLN		;RUNNING ON FRCLIN?
	JRST	FILELS		;NO, IGNORE THIS COMMAND
	SETOM	TTWFLG		;FLAG THAT WE SHOULD START STOMPER
STMP.0:	TXNE	F,F.ECMD!F.EOF	;SEE IF END OF COMMAND
	POPJ	P,		;YES--RETURN
	PUSHJ	P,GETSIX	;GET NEXT WORD
	JUMPE	WD,STMP.1	;IF NULL, IGNORE IT
	MOVE	T2,[IOWD CMDS-CMDLL-CMDLT,CMDT+CMDLL+CMDLT]
				;ALLOWABLE STOMP COMMANDS TABLE
	PUSHJ	P,FNDCMD	;FIND AND STORE COMMAND
	  JRST	ERRFCR		;ERROR IF MISSING
STMP.1:	CAIN	CH,"-"		;SEE IF - XYZ
	PUSHJ	P,NO$		;YES--SET NOXYZ
	TXZN	F,F.CERR	;SEE IF ERROR
	JRST	STMP.0		;NO--LOOP
	JRST	ERRFCR		;YES--SAY SO
;HERE TO CONNECT REMOTE NETWORK TERMINALS

FILCON:	TXNN	F,F.CTY		;RUNNING ON THE CTY?
	JRST	FILELS		;NO, IGNORE THE CONNECT COMMAND(S)
	MOVEI	T1,NETSLP	;GET SECONDS TO WAIT
	MOVEM	T1,FILCWT	;SET MAXIMUM WAITABILITY

;LOOP READING NODE_TTY PAIRS FROM TTY.INI

FILCO2:	PUSHJ	P,GETSIX	;GET A NODE ID
	CAIE	CH,"_"		;LOOK LIKE A NODE?
	JRST	FILELS		;NO, EAT THE LINE
FILCO3:	MOVE	T3,WD		;YEAH, POSITION
	PUSHJ	P,NDNAM		;AND TRY TO DECIPHER THE NODE ID
 	JUMPLE	T2,[SOSGE FILCWT	;TIME TO FLICK IT IN?
		JRST	FILCE3		;YES
		MOVEI	T1,1		;NO,
		SLEEP	T1,		;GIVE THE NETWORK A CHANCE TO COME UP
		JRST	FILCO3]		;AND TRY AGAIN
	MOVE	T6,T1		;SAVE REAL NODE NAME
	HRLZ	T8,T2		;SAVE NODE NUMBER
	PUSHJ	P,GETSIX	;READ IN THE TTY ID
	PUSHJ	P,XPNTTY	;FORCE INTO KNOWN FORMAT
	PUSHJ	P,CVTBIN	;AND CONVERT TO LINE NUMBER
	JUMPLE	T8,FILCO7	;IF UNKNOWN NODE, JUST IGNORE IT
	HRR	T8,WD		;MAKE NODE,,LINE ARG
	MOVEI	T7,2		;LENGTH OF NODE. ARG LIST BLOCK
FILCO4:	MOVE	WD,[.NDTCN,,T7]	;ARG POINTER TO
	NODE.	WD,		;TRY TO CONNECT NETWORK TERMINAL
	 JRST	[SOSGE	FILCWT		;WILLING TO WAIT AROUND A BIT?
		JRST	FILCE4		;TIMED OUT, JUST IGNORE IT
		MOVEI	WD,1		;ONE SECOND
		SLEEP	WD,		;WAIT TO GIVE THE NET A CHANCE
		JRST	FILCO4]		;TRY TO CONNECT AGAIN
	MOVX	T1,UU.PHS	;PHYSICAL ONLY
	MOVE	T2,WD		;RESULTANT TERMINAL NAME
	SETZ	T3,		;NO BUFFER RINGS
	OPEN	TTZ,T1		;IS TERMINAL IN USE?
	 JRST	FILCO7		;YES, DON'T FORCE AN INITIA ON IT
	MOVEI	T8,TTZ		;NO, TERMINAL IS FREE,
	IONDX.	T8,		;GET ITS UDX
	 JRST	FILCO7		;THIS JUST CAN'T FAIL
	RELEAS	TTZ,		;NO, RETURN IT TO MONITOR
	MOVE	T7,['INITIA']	;YOURS TRULY
	MOVE	T1,[2,,T7]	;FRCUUO ARG POINTER TO
	FRCUUO	T1,		;RUN INITIA ON NEW-FOUND LINE
	 JRST	FILCE6		;WIN A FEW, LOSE A FEW . . .

;SEE IF MORE TO DO

FILCO7:	CAIE	CH,.CHLFD	;END OF LINE?
	JUMPG	CH,FILCO2	;NO, MORE TO DO
	JRST	FILE.9		;MARK END OF COMMAND
;VARIOUS "CONNECT" COMMAND ERRORS OF NOTE

;NO SUCH NODE

FILCE3:	TTYSTR	[ASCIZ\% No such node "\]
	MOVE	T2,WD		;COPY OF THE NODE NAME
	PUSHJ	P,TYPSIX	;TYPE SIXBIT NODE NAME
	TTYSTR	[ASCIZ\" in CONNECT command\]
	TTYSTR	CRLF		;CAP OFF WITH A CRLF
	JRST	FILCO7		;CONTINUE WITH TTY.INI

;CAN'T CONNECT TO TERMINAL

FILCE4:	TTYSTR	[ASCIZ\% Can't CONNECT to \]
	PUSHJ	P,FILCET	;TYPE NODE_TTY
	TTYSTR	CRLF		;CAP OFF WITH A CRLF
	JRST	FILCO7		;CONTINUE WITH TTY.INI

;CAN'T FORCE AN INITIA

FILCE6:	TTYSTR	[ASCIZ\% Can't force an INITIA on \]
	PUSHJ	P,FILCET	;LIST THE NODE_TTY
	TTYSTR	[ASCIZ\ (\]
	MOVE	T2,WD		;GET -10'S TTY NAME
	PUSHJ	P,TYPSIX	;TYPE THE RESULTANT TTY NAME
	TTYCHR	")"		;END PARENTHESIZED TTY NAME
	TTYSTR	CRLF		;CAP OFF WITH A CRLF
	JRST	FILCO7		;CONTINUE WITH TTY.INI

;TYPE NODE_TTY

FILCET:	MOVE	T2,T6		;COPY OF RESULTANT NODE NAME
	PUSHJ	P,TYPSIX	;LIST SIXBIT NODE NAME
	TTYSTR	[ASCIZ\_TTY\]	;SEPARATE NODE NAME FROM TTY NAME
	HRRZ	T1,T8		;GET NODE LINE NUMBER
	PJRST	TYPOCT		;AND LIST OCTAL LINE NUMBER
;HERE TO CHECK APC CONDITION OF FILE

FILAPC:	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETSIX	;READ APC NAME
	MOVE	T2,[IOWD APCL,APCT] ;APC NAME TABLE
	PUSHJ	P,FNDWRD	;SEE WHICH WE HAVE
	  JRST	ERRFCR		;GENERIC FILE COMMAND ERROR
	MOVE	T3,[2,,T4]	;POINTER FOR TRMOP
	MOVEI	T4,.TOAPC	;FUNCTION TO READ APC
	MOVE	T5,TERNUM	;OUR TTY
	TRMOP.	T3,		;ASK THE MONITOR
	  MOVEI	T3,.TOUNK	;UNKNOWN IF ANCIENT MONITOR
	CAME	T2,T3		;DO THEY AGREE?
	JRST	FILE.7		;NO, PUNT
	JRST	FILE.6		;YES, DO THIS LINE

APCT:
DEFINE	YY(CODE,NAME),<
 IFN <.-APCT>-.TO'CODE,<PRINTX ? APC ENTRY NAME IS OUT OF ORDER IN APCT>
 EXP SIXBIT |NAME|
>
	YY	UNK,UNKNOWN
	YY	HWD,HARDWIRED
	YY	DSD,DATASET
	YY	TSN,TSN
	YY	GAN,GANDALF
	YY	ADL,AUTODIALER
	YY	MCM,MICOM
	YY	NRT,NRTSER
	YY	LAT,LAT
	YY	CTM,CTERM
APCL==.-APCT
;SUBROUTINE TO HANDLE LINE OF COMMAND FILE
;CALLED AFTER FIRST WORD OF LINE IS FOR US

DOFILE:	TXNE	F,F.ECMD!F.EOF	;SEE IF END OF COMMAND
	POPJ	P,		;YES--RETURN
	PUSHJ	P,GETSIX	;GET NEXT WORD
	JUMPE	WD,DOFI.1	;IF NULL, IGNORE IT
	MOVE	T2,[IOWD CMDL,CMDT]	;FULL COMMAND TABLE
	PUSHJ	P,FNDCMD	;FIND AND STORE COMMAND
	  JRST	ERRFCR		;ERROR IF MISSING
DOFI.1:	CAIN	CH,"-"		;SEE IF - XYZ
	PUSHJ	P,NO$		;YES--SET NOXYZ
	TXZN	F,F.CERR	;SEE IF ERROR
	JRST	DOFILE		;NO--LOOP

ERRFCR:	INTWRN	(FCR,File command error)
	OUTSTR	CRLFM
	POPJ	P,0
SUBTTL	SUBROUTINE TO IDENTIFY AND SAVE COMMAND

;CALL:	MOVE	T2,[IOWD LENGTH,LIST]
;	PUSHJ	P,FNDCMD
;NON-SKIP RETURN IF ERROR
;SKIP RETURN IF DONE
;VALUES CAN BE SEPARATED BY

FNDCMD:	MOVE	T7,T2		;SAVE A COPY OF LIST
FNDC.1:	PUSHJ	P,FNDWRD	;LOOK WD UP IN TABLE
	  JRST	[XOR   WD,['NO    ']
		 TLNE  WD,777700  ;SEE IF NOXYZ
		 POPJ  P,	;NO--ERROR
		 PUSHJ P,NO$	;YES--SET FLAG
		 LSH   T1,^D12	;ADJUST MASK
		 LSH   WD,^D12	;ADJUST REST OF WORD
		 MOVE  T2,T7	;RESTORE LIST OF WORDS
		 JRST  FNDC.1]	;AND TRY AGAIN
	ADDI	T2,CMDP-CMDT+1(T7);POINT TO THE PROCESSOR
	SKIPGE	T1,(T2)		;GET PROCESSOR
	HRRZM	T1,JUMPPR	;IF -1,,ADDR, GIVES FINAL ROUTINE
	TXNE	F,F.NO		;SEE IF NO XXX
	JUMPL	T1,CPOPJ	;IF ROUTINE, ERROR
	HLRE	T2,T1		;GET POSSIBLE VALUE
	JUMPLE	T2,FNDC.2	;IF JUMP/ROUTINE, GO HANDLE
	TXZE	F,F.NO		;SEE IF NO XXX
	TRC	T2,3		;YES--INTERCHANGE 1-2
	CAIE	T2,1		;SEE IF YES
	CAIN	T2,2		;SEE IF NO
	MOVEM	T2,(T1)		;YES--STORE VALUE
	CAIG	T2,3		;SEE IF BIT VALUE
	JRST	CPOPJ1		;YES--ALL OK
	CAIE	T2,4		;SEE IF DECIMAL VALUE
	POPJ	P,		;NO--MUST BE ERROR
	PUSH	P,T1		;SAVE LOCATION
	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETDEC	;GET DECIMAL VALUE
	POP	P,T2		;RESTORE LOCATION
	HRROM	T1,(T2)		;STORE VALUE
	JRST	CPOPJ1		;GIVE GOOD RETURN
FNDC.2:	TLNN	T1,-1		;SEE IF 0,,ADDR
	PUSHJ	P,(T1)		; CALL ROUTINE
	TXZE	F,F.CERR	;SEE IF COMMAND ERROR
	POPJ	P,		;YES--GIVE ERROR
	JRST	CPOPJ1		;NO--GIVE SUCCESS
SUBTTL	DEFINE SYSTEMS WHICH NEED SPECIAL SET-UP

	DEFINE	APRS,<
	X 546
;OTHERS MAY BE ADDED--EACH REQUIRES A SP MACRO
>



;DEFINE TABLE OF APR S/N TO PROCESS

	DEFINE	X(A),<
			XLIST
			EXP A
			LIST
>


	RADIX	10
APRTAB:	APRS
APRTBL==.-APRTAB
	RADIX	8



;DEFINE LIST OF TTY NAME TABLE AND PROCESSING TABLE

	DEFINE	X(A),<
			XLIST
			XWD TT'A,JJ'A
			LIST
>

APRTBV:	APRS
	XWD	TTXXX,JJXXX	;CATCHALL
SUBTTL	SYSTEM TABLES

;SYSTEM 546 TABLES
	DEFINE	SP546,<
>

;CATCHALL TABLES FOR UNRECOGNIZED SYSTEMS
	DEFINE	SPXXX,<
>
;PEEL OUT THE TTY NAMES

T.==0

	DEFINE	X(A),<
	XLIST
TT'A:	SP'A
	0
	IFG	.-TT'A-T.,<T.==.-TT'A>
	LIST
>

	DEFINE	Y(A,B,C),<EXP SIXBIT /A/>

	APRS
	X XXX

SPTABL==T.		;SAFETY FACTOR FOR LOOP


;PEEL OUT JUMP TABLES

	DEFINE	X(A),<	XLIST
JJ'A:	SP'A
	LIST>

	DEFINE	Y(A,B,C),<XWD C,B>

	APRS
	X XXX
SUBTTL	STANDARD COMMAND TABLES

;FOR EACH KEYWORD, DEFINE LOCATION OF
;PROCESSOR AND WHETHER OR NOT COMMAND CAN GIVE
;W	KEY,PROCESSOR,X,Y
;		X=C IF COMMAND ALLOWED
;		  S IF ALLOWED ON STOMP OR FRCLIN
;		Y=J IF CALLED WITH JRST
;		  B IF SET A BIT
;		  I IF INVERT (OFF) A BIT
;		  D IF DECIMAL NUMBER

	DEFINE	CMDLST(J,B,I,D),<

;;FIRST THE COMMANDS ET AL

W	H,HELP,C,
W	HELP,HELP,C,
W	KSYS,FLKSYS,C,B
W	NAME,FLNAME,C,I
W	NO,NO$,C,
W	NORUN,GEN,C,J
W	NOTICE,FLNOTC,C,B
W	STRUCTURES,FLSTR,C,B
W	SYSTEM,SYSIN$,C,
W	STOMP,STOMP$,C,
W	TEXT,FLTEXT,C,B
W	UN,NO$,C,
W	CHECK,CHECK$,C,

W	ACCOUNT,REDACT,S,
W	AUTOMATIC,OPSER1,,J
W	CHKPNT,CHKPNT,,J
W	CRASH,FILEX,,J
W	DAEMON,DAEMON,,J
W	GALOPR,GALOPR,,J
W	LOCATE,LOCAT,,D
W	OMOUNT,OMOUNT,,J
W	OPSER,OPSER,,J
W	SYSDLT,SYSDPY,,J
W	SYSDPA,SYSDPY,,J
W	SYSDPB,SYSDPY,,J
W	SYSDPY,SYSDPY,,J
W	SYSHZL,SYSDPY,,J
W	SYSV52,SYSDPY,,J
W	SYSV61,SYSDPY,,J
W	SYSVFT,SYSDPY,,J
W	SYSVSO,SYSDPY,,J
;;THEN THE TTY PARAMETERS

W	ALTMODE,ALT,T,I
W	BLANKS,BLANK,T,I
W	CRLF,CRLF,T,I
W	DEFER,ECHDEF,T,B
W	DIALOUT,DIAL$,,
W	ECHO,ECHO,T,B
W	EDITOR,EDITOR,T,B
W	ESCAPE,ESCCMD,T,
W	FILL,FILL,T,D
W	FORM,FORM,T,B
W	GAG,GAG,T,I
W	IDLEDISC,IDLE,T,D
W	LC,LC,T,I
W	LENGTH,LENGTH,T,D
W	LOCALCOPY,LOCALC,T,B
W	MODEL,MODEL$,T,
W	PAGE,PAGCMD,T,
W	QUOTE,QUOTE,T,B
W	RCVSPEED,RCV$,T,
W	REMOTE,REM,T,B
W	RTCOMPATABILITY,RTCOMP,T,B
W	SBELL,SBELL,T,B
W	SETTTY,FLSET,C,I
W	SLAVE,SLAVE,T,B
W	SPEED,SPEED$,T,
W	SSIZE,SSIZE,T,D
W	SSTOP,SSTOP,T,B
W	STOP,STOP,T,B
W	TABS,TAB,T,B
W	TAPE,TAPE,T,B
W	TERMINET,TRMNET,C,
W	TTY,TTYCMD,C,
W	ATTRIBUTES,FLATTR,C,B
W	TYPE,TYPE$,T,
W	UC,LC,T,B
W	UNPAUSE,UNPCMD,T,
W	WIDTH,WIDTH,T,D
W	XMTSPEED,XMT$,T,
W	XONXOFF,XONXOF,T,B

;;HERE FOR TTY ATTRIBUTES
W	8BITAR,ATR8BA,T,B
W	8BIT,ATR8BT,T,B
W	EIGHTB,ATR8BT,T,B
W	AVO,ATRAVO,T,B
W	BLOCKM,ATRBMT,T,B
W	BLOCKT,ATRBMT,T,B
W	BLOCKA,ATRBTA,T,B
W	IDCHAR,ATRCID,T,B
W	COLOR,ATRCLR,T,B
W	COLOUR,ATRCLR,T,B
W	DISPLA,ATRDIS,T,B
W	STATUS,ATRESL,T,B
W	GAT,ATRGAT,T,B
W	GUARDE,ATRGAT,T,B
W	GPO,ATRGPO,T,B
W	REGIS,ATRGPO,T,B
W	HORIZO,ATRHSR,T,B
W	HSCROL,ATRHSR,T,B
W	ISO,ATRISO,T,B
W	KATAKA,ATRJTK,T,B
W	JTK,ATRJTK,T,B
W	IDLINE,ATRLID,T,B
W	KEYBOA,ATRNKB,T,I
W	NRC,ATRNRC,T,B
W	OVERST,ATROVR,T,B
W	PRINTE,ATRPPO,T,B
W	PPORT,ATRPPO,T,B
W	DRCS,ATRRCS,T,B
W	SEM,ATRSEM,T,B
W	SELECT,ATRSEM,T,B
W	SELERA,ATRSEM,T,B
W	SCROLL,ATRSRM,T,B
W	VSCROL,ATRSRM,T,B
W	SREGIO,ATRSRM,T,B
W	SESSIO,ATRSSU,T,B
W	SIXEL,ATRSXL,T,B
W	DECTCS,ATRTCS,T,B
W	TEKEM,ATRTEK,T,B
W	TEKTRO,ATRTEK,T,B
W	INTERR,ATRTSI,T,B
W	UDKEYS,ATRUDK,T,B
W	UWINDO,ATRUWN,T,B
W	VT52EM,ATRV52,T,B
W	VLENGT,ATRVFL,T,B
W	VWIDTH,ATRVFW,T,B
W	DECLVL,DECLVL,T,D
W	DECLEV,DECLVL,T,D
W	ANSLVL,ANSLVL,T,D
W	ANSLEV,ANSLVL,T,D
W	LDT,LOCDV$,T,
W	LOCATO,LOCDV$,T,
>
	XALL
	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFIDN	<$COM><C>,<
	EXP	<SIXBIT /$KEY/>	; $KEY
>>

	;TABLE OF COMMAND NAMES
CMDT:	CMDLST	(-1,1,2,4)
CMDLL==.-CMDT

;HERE FOR THE SET TTY COMMANDS

	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFIDN	<$COM><T>,<
	EXP	<SIXBIT /$KEY/>	; $KEY
>>
	CMDLST	(-1,1,2,4)
CMDLT==.-CMDT

;HERE FOR THE STOMP COMMANDS

	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFIDN	<$COM><S>,<
	EXP	<SIXBIT /$KEY/>	; $KEY
>>
	CMDLST	(-1,1,2,4)
CMDS==.-CMDT

	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFDIF	<$COM><C>,< IFDIF <$COM><S>,< IFDIF <$COM><T>,<
	EXP	<SIXBIT /$KEY/>	; $KEY
>>>>
	CMDLST	(-1,1,2,4)
CMDL==.-CMDT


	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFIDN	<$COM><C>,<
	XWD	$JUMP,$PROC		; $KEY
>>

	;LIST OF PROCESSORS
CMDP:	CMDLST	(-1,1,2,4)


	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFIDN	<$COM><T>,<
	XWD	$JUMP,$PROC		; $KEY
>>
	CMDLST	(-1,1,2,4)

	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFIDN	<$COM><S>,<
	XWD	$JUMP,$PROC		;$KEY
>>
	CMDLST	(-1,1,2,4)

	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFDIF	<$COM><C>,< IFDIF <$COM><S>,< IFDIF <$COM><T>,<
	XWD	$JUMP,$PROC		;$KEY
>>>>
	CMDLST	(-1,1,2,4)
	SALL

SUBTTL	ROUTINES FOR VARIOUS COMMANDS

SUBTTL	NO COMMAND HANDLER

NO$:	TXOE	F,F.NO		;SET NO FLAG
	TXO	F,F.CERR	;IF ON, ERROR
	POPJ	P,		;RETURN

SUBTTL	RCV/XMT SPEED COMMAND HANDLER

SPEED$:	MOVEI	T7,3		;BOTH SPEEDS
	JRST	SPEED		;GO HANDLE
RCV$:	MOVEI	T7,2		;REC SPEED
	JRST	SPEED		;GO HANDLE
XMT$:	MOVEI	T7,1		;XMT SPEED
SPEED:	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETSIX	;GET SIXBIT WORD
	MOVE	T2,[IOWD SPEEDL,SPEEDT]
	PUSHJ	P,FNDWRD	;FIND SPEED
	  TXO	F,F.CERR	;ERROR IF UNKNOWN
	TXZE	F,F.NO		;SEE IF NO
	TXO	F,F.CERR	;YES--COMMAND ERROR
	TRNE	T7,2		;SEE IF RCV
	HRROM	T2,RCV		;YES
	TRNE	T7,1		;SEE IF XMT
	HRROM	T2,XMT		;YES
	TRNE	T7,2		; IF RECEIVE SPEED
	 HRRZM	T2,MYSPD	; CHANGE MYSPEED
	POPJ	P,		;RETURN

SPEEDT:	SIXBIT	/0/
	SIXBIT	/50/
	SIXBIT	/75/
	SIXBIT	/110/
	SIXBIT	/134/
	SIXBIT	/150/
	SIXBIT	/200/
	SIXBIT	/300/
	SIXBIT	/600/
	SIXBIT	/1200/
	SIXBIT	/1800/
	SIXBIT	/2400/
	SIXBIT	/4800/
	SIXBIT	/9600/
	SIXBIT	/EXTA/
	SIXBIT	/EXTB/
SPEEDL==.-SPEEDT
SUBTTL	TTY COMMAND HANDLER

TTYCMD:	MOVEI	T1,2		;BOOLEAN NO
	TXZE	F,F.NO		;DID USER SAY NO?
	JRST	TTYCM2		;YES, DO IT THAT WAY
	CAIE	CH,":"		;NO, DO WE HAVE A VALUE?
	JRST	TTYCM1		;NO, JUST LIGHT FLTTY
	PUSHJ	P,GETSIX	;YES, READ IT
	PUSHJ	P,XPNTTY	;CONVERT TO A TTY NAME
	IONDX.	WD,		;GET ITS UDX
	  SETZ	WD,		;DUH?
	CAIL	WD,.UXTRM	;IS IT A VALID TTY UDX?
	CAILE	WD,.UXTRM+777	; ...
	TXOA	F,F.CERR	;NO, MAKE IT A COMMAND ERROR
	MOVEM	WD,TRMNUM	;YES, SAVE FOR TYPTTY
TTYCM1:	MOVEI	T1,1		;BOOLEAN TRUE
TTYCM2:	MOVEM	T1,FLTTY	;SAVE VALUE FOR DOTTYS TO TEST
	POPJ	P,		;RETURN TO DOCMD
SUBTTL	PAGE COMMAND HANDLER

PAGCMD:	PUSHJ	P,SKIPTV	;SKIP TO VALUE IF ANY
	CAIN	CH,":"		;SEE IF VALUE
	JRST	PAGCM1		;YES--SETTING NUMBER
	CAIL	CH,"0"		;OR
	CAILE	CH,"9"		; DECIMAL
	JRST	PAGCM2		;NO--MUST JUST BE ON/OFF
PAGCM1:	TXZE	F,F.NO		;NUMBER
	TXO	F,F.CERR	;NO IS ERROR
	PUSHJ	P,GETDEC	;GET DECIMAL PAGE COUNT
	HRROM	T1,PAGE		;SET PAGE NUMBER
PAGCM2:	TXZE	F,F.NO		;ON/OFF--SEE IF OFF
	TDZA	T1,T1		;NO SO OFF
	MOVEI	T1,1		;ELSE ON
	HRROM	T1,PAGEON	;SET FOR PAGE FLAG
	POPJ	P,		;RETURN

SUBTTL	DIAL COMMAND HANDLER

DIAL$:	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	SETOM	DIAL		;FILL WITH MARKERS
	SETOM	DIAL+1		;..
	MOVE	T7,[POINT 4,DIAL]
	MOVEI	T6,^D18		;PROTECTIVE COUNT
DIAL.1:	PUSHJ	P,GETCHA	;GET NEXT DIGIT
	CAIE	CH,"	"	;SEE IF TAB
	CAIN	CH," "		; OR SPACE
	JRST	DIAL.1		;YES--DISCARD
	CAIN	CH,"-"		;SEE IF SEPARATOR
	JRST	DIAL.1		;YES--DISCARD
	CAIE	CH,"("		;SEE IF
	CAIN	CH,")"		; AREA CODE SEPARATOR
	JRST	DIAL.1		;YES--DISCARD
	CAIN	CH,"*"		;SEE IF DELAY MARKER
	JRST	[MOVEI CH,16	;YES--INDICATE THAT
		 JRST  DIAL.2]	;AND STORE
	CAIL	CH,"0"		;SEE IF
	CAILE	CH,"9"		; DIGIT
	POPJ	P,		;NO--MUST BE END
DIAL.2:	IDPB	CH,T7		;STORE DIGIT
	SOJG	T6,DIAL.1	;SEE IF OVERFLOW
	TXO	F,F.CERR	;YES--SET ERROR
	SETZM	DIAL		;AND CLEAR
	SETZM	DIAL+1		; RESULT
	POPJ	P,		;RETURN
SUBTTL	LOCATOR COMMAND HANDLER

LOCDV$:	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETSIX	;READ A TOKEN
	MOVE	T2,[IOWD LOCDVL,LOCDVN]	;LOOKUP TABLE FOR DEVICE NAMES
	PUSHJ	P,FNDWRD	;SEE WHICH ONE WE FOUND
	  TXOA	F,F.CERR	;ERROR IF NONE
	HRROM	T2,LOCDVT	;SET FOR LATER
	POPJ	P,		;RETURN

;TABLE OF LOCATOR DEVICE TYPE NAMES
LOCDVN:
DEFINE DVN(NAME,VAL),<
 IFN <.-LOCDVN>-.T2'VAL,<PRINTX ENTRY NAME IS OUT OF ORDER IN LOCDVN>
	EXP	<SIXBIT	|NAME|>
>
	DVN	UNKNOWN,UNK
	DVN	MOUSE,MOU
	DVN	TABLET,TAB
LOCDVL==.-LOCDVN	;HOW MANY SUCH NAMES
SUBTTL	ESCAPE COMMAND HANDLER

ESCCMD:	MOVX	T1,.CHESC	;GET THE DEFAULT ESCAPE CHARACTER
	PUSH	P,[ESCAPE]	;GET THE STORAGE ADDRESS
	PJRST	UNPC.0		;CALL THE COMMON CODE BELOW

SUBTTL	UNPAUSE COMMAND HANDLER

UNPCMD:	MOVEI	T1,.CHCNQ	;GET THE DEFAULT FOR THIS GUY
	PUSH	P,[UNPAUSE]	;GET THE STORAGE ADDRESS

UNPC.0:	TXZE	F,F.NO		;DID HE SAY NO?
	JRST	UNPC.1		;YES, JUST USED THE DEFAULT
	PUSHJ	P,GCHVAL	;NO, GO GET THE CHARACTER VALUE
	  TXOA	F,F.CERR	;ERROR, DON'T STORE
UNPC.1:	HRROM	T1,@(P)		;OK, STORE THE CHARACTER
	POP	P,(P)		;CLEAN UP THE STACK
	POPJ	P,		;RETURN

SUBTTL	ACCOUNT COMMAND HANDLER

REDACT:	TXZN	F,F.NO		;DID HE SAY NO?
	JRST	REDA.1		;NO, GET THE STRING VALUE
	SETZM	ACTSTR		;YES, THEN
	MOVE	T1,[ACTSTR,,ACTSTR+1] ; ZERO
	BLT	T1,ACTSTR+7	;  ANY LEFTOVER STUFF
REDA.1:	MOVE	T1,[POINT 7,ACTSTR] ;POINT TO THE STRING STORAGE
	MOVEI	T2,^D39		;GET THE MAXIMUM LENGTH (NOT INCL NULL)
	PUSHJ	P,GSTARG	;GET THE STRING ARGUMENT
	  TXO	F,F.CERR	;ERROR, SO LITE THE BIT
	POPJ	P,		;RETURN
SUBTTL	ROUTINE TO SETUP TTY

DOTTYS:	SKIPN	T1,FLSET	;SEE IF
	TXNN	F,F.LOGI	; (IF DIDN'T SAY, AND LOGGED IN, ASSUME NO)
	TRNE	T1,1		; USER SAID NOSETTTY
	JRST	DOTTY0		;RIGHT--SKIP THIS
	MOVE	T1,TERNUM	;TTY WE'LL SET
	CAME	T1,TRMNUM	;IS IT THE ONE WE'LL REPORT?
	JRST	DOTTY0		;NO--SKIP THIS
	PUSHJ	P,DOTTYA	;SET PRE-TYPEOUT TRMOP.S
	SETOM	FLSET		;REMEMBER THAT WE WANT THIS
	JRST	DOTTY1		;SKIP TO SOME TYPEOUT
DOTTY0:	SETZM	FLSET		;REMEMBER NOT TO DO THIS
	MOVE	T1,[TTBZER,,TTBZER+1] ;CLEAR TTY PARAMETERS IN CASE OF CHECK
	SETZM	TTBZER		;ZERO FIRST WORD
	BLT	T1,TTEZER	;SPREAD IT AROUND
DOTTY1:	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TODSS	;GET DATASET STATUS
	MOVE	T3,TERNUM	;MY LINE
	TRMOP.	T1,		;CHECK CARRIER
	  SETO	T1,		;ON IF NOT A DATASET
	GETLCH	T3		;GET SOME OTHER RANDOM BITS
	TXNN	T3,GL.SLV	;IF A SLAVED TERMINAL,
	SKIPL	T1		;OR NO CARRIER ON A DATASET,
	JRST	DOTTY2		;GO SILENCE THIS OPERATION
	MOVE	T1,[.RCCPU,,T2]	;RECON. FUNCTION FOR CPU MASK
	MOVEI	T2,2		;NUMBER OF WORDS IN BLOCK
	MOVSI	T3,'TTY'	;OUR TERMINAL
	RECON.	T1,UU.PHY	;GET OUR BITS
	  JRST	DOTTY3		;PRE-7.03?
	MOVE	T4,[.RCCPU,,T2]	;GET A DIFFERENT CPU MASK
	MOVSI	T3,'CPU'	;THE RUNNING CPUS
	RECON.	T4,UU.PHY	;ASK THE MONITOR
	  JRST	DOTTY3		;SNH
	TDNN	T1,T4		;IF WE ARE OFF-LINE
	JRST	DOTTY2		;GO SILENCE OURSELVES
	MOVN	T4,T1		;GET FUDGED BITS
	AND	T4,T1		;ISOLATE RIGHTMOST BIT
	CAME	T1,T4		;SINGLE-CPU TTY?
	JRST	DOTTY3		;NO--ASSUME SOMETHING'S RUNNABLE
	JFFO	T1,.+1		;YES--GET THE BIT NUMBER
	MOVN	T1,T2		;FAKE A SUBTRACT
	ADDI	T1,^D35		;CONVERT TO CPU NUMBER
	LSH	T1,1		;*2 FOR GETTAB TABLE PAIRING
	ADD	T1,[%CVRUN]	;.CPRUN GETTAB FOR OUR CPU
	GETTAB	T1,		;READ IT
	  SETZ	T1,		;OK IF NOT AVAILABLE
	SKIPGE	T1		;IF CP.RUN IS ON,
DOTTY2:	SETOM	SILENC		;DON'T TRY TO TYPE ANYTHING AGAIN
DOTTY3:	PUSHJ	P,SIGNON	;ISSUE SIGNON MESSAGE (MAYBE)
	MOVE	T1,FLKSYS	;SEE IF
	TRNE	T1,1		; USER WANTS KSYS
	PUSHJ	P,TYKSYS	;YES--ISSUE IT
	MOVE	T1,FLTEXT	;SEE IF
	TRNE	T1,1		; USER WANTS INITIA.TXT
	PUSHJ	P,TEXT		;YES--TYPE IT
	MOVE	T1,FLCHEK	;GET CHECK FLAG
	TRNE	T1,1		;IF SET,
	PUSHJ	P,CHECK		;QUERY THE TERMINAL FOR ITS TYPE
	MOVE	T1,FLCHEK	;GET CHECK FLAG AGAIN
	TRNN	T1,1		;IF CHECK WANTED TO SET SOMETHING,
	SKIPE	FLSET		;OR THE USER WANTS TO SET SOME MORE,
	PUSHJ	P,DOTTYB	;SET THE REMAINING CHARACTERISTICS
	MOVE	T1,FLSTR	;SEE IF STRUCT
	TRNE	T1,1		; ..
	PUSHJ	P,STRUCT	;YES--TYPE STRUCTURE NOTES
	MOVE	T1,FLTTY	;GET TTY FLAG
	TRNE	T1,1		;SEE IF SET
	PUSHJ	P,TYPTTY	;YES--TYPE TTY SETTINGS
	MOVE	T1,FLATTR	;GET ATTRIBUTE FLAG
	TRNE	T1,1		;SEE IF SET
	PUSHJ	P,TYPATR	;YES--TYPE ATTRIBUTE SETTINGS
	MOVE	T1,FLNOTC	;GET NOTICE FLAG
	TRNE	T1,1		;SEE IF SET
	PUSHJ	P,NOTICE	;YES--TYPE NOTICE.TXT
	POPJ	P,		;RETURN
SUBTTL	ROUTINES TO SET TERMINAL CHARACTERISTICS (DOTTYA,DOTTYB)

DOTTYA:	MOVE	T7,[-DOTTLA,,DOTTTA] ;AOBJN POINTER TO SETUP TABLE
	PUSHJ	P,DOTTYC	;SET FROM THE TABLE
	MOVE	T7,[-DOTTLC,,DOTTTC] ;AOBJN POINTER TO SPECIAL TABLE
	TXNN	F,F.LOGI	;IF NOT LOGGED IN,
	PUSHJ	P,DOTTYC	;SET FROM THIS TABLE, TOO
	MOVE	T1,[4,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TODSC	;INDICATE CALL
	MOVE	T3,TERNUM	;GET OUR NUMBER
	MOVE	T4,DIAL		;GET FIRST HALF OF NUMBER
	SKIPE	T5,DIAL+1	;IF SET,
	TRMOP.	T1,		; MAKE CALL
	  JFCL			;IGNORE ERRORS
	POPJ	P,		;RETURN

DOTTYB:	MOVE	T7,[-DOTTLG,,DOTTYT] ;AOBJN POINTER TO USER-SETTABLE ITEMS
	TXNN	F,F.LOGI	;IF NOT LOGGED IN,
	HRLI	T7,-DOTTYU	;USE FULL TABLE
	PUSHJ	P,DOTTYC	;SET THE CHARACTERISTICS
;HERE TO DO ATTRIBUTES
	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOATR	;FIRST ATTR WORD
	MOVE	T3,TERNUM	;GET TERMINAL NUMBER
	TRMOP.	T1,		;READ LDBATR
	  JRST	NOATTR		;OLD MONITOR
	MOVEM	T1,TERATR	;SAVE CURRENT VALUES
	MOVEM	T1,TRMATR	;AGAIN FOR COMPARISON
	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOAT2	;SECOND ATTR WORD
	TRMOP.	T1,		;READ LDBAT2
	  SETZ	T1,		;SNH
	MOVEM	T1,TERAT2	;SAVE CURRENT
	MOVEM	T1,TRMAT2	;AGAIN FOR COMPARISON
	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOAT3	;CUSTOMER ATTR WORD
	TRMOP.	T1,		;READ LDBAT3
	  SETZ	T1,		;SNH
	MOVEM	T1,TERAT3	;SAVE CURRENT
	MOVEM	T1,TRMAT3	;AGAIN FOR COMPARISON
	MOVSI	T7,-ATRNM1	;AOBJN POINTER FOR BITS IN LDBATR
ATTR.0:	HLRZ	T1,ATRTB1(T7)	;GET ADDRESS OF FIRST VALUE
	SKIPN	T1,(T1)		;IF NOT EXPLICITLY SET,
	JRST	ATTR.1		;DON'T CHANGE IT
	HRRZ	T2,ATRTB1(T7)	;GET ADDRESS OF BIT
	MOVE	T2,(T2)		;AND BIT
	IORM	T2,TERATR	;SET IN VALUES
	TRNN	T1,1		;IF 'NO',
	ANDCAM	T2,TERATR	;CLEAR IN VALUES INSTEAD
ATTR.1:	AOBJN	T7,ATTR.0	;LOOP OVER LDBATR BITS
	MOVE	T1,[3,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOATR+.TOSET ;FUNCTION TO SET LDBATR
	MOVE	T4,TERATR	;WITH THIS NEW VALUE
	XORM	T4,TRMATR	;MAKE A CHANGE MASK
	SKIPE	TRMATR		;IF SOMETHING CHANGED,
	TRMOP.	T1,		;DO IT
	  JFCL			;IGNORE ERRORS
	MOVSI	T7,-ATRNM2	;AOBJN POINTER FOR LDBAT2 BYTES
ATTR.2:	HLRZ	T1,ATRTB2(T7)	;GET POINTER TO VALUE
	SKIPN	T1,(T1)		;IF NOT EXPLICITLY SET,
	JRST	ATTR.3		;DON'T DO IT
	HRRZ	T2,ATRTB2(T7)	;GET ADDRESS OF BYTE POINTER
	DPB	T1,(T2)		;SET IN TERAT2
ATTR.3:	AOBJN	T7,ATTR.2	;LOOP OVER ALL KNOWN BYTES IN LDBAT2
	MOVE	T1,[3,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOSET+.TOAT2 ;FUNCTION TO SET LDBAT2
	MOVE	T4,TERAT2	;WITH THIS VALUE
	XORM	T4,TRMAT2	;MAKE A CHANGE MASK
	SKIPE	TRMAT2		;IF CHANGED,
	TRMOP.	T1,		;DO IT
	  JFCL			;IGNORE ERRORS
	MOVSI	T7,-ATRNM3	;AOBJN POINTER TO CUSTOMER ATTRIBUTES TABLE
	JUMPE	T7,NOATTR	;DONE IF NONE DEFINED
ATTR.4:	HLRZ	T1,ATRTB3(T7)	;GET ADDRESS OF STORAGE
	SKIPN	T1,(T1)		;IF NOT EXPLICITLY SET,
	JRST	ATTR.5		;DON'T DO IT
	HRRZ	T2,ATRTB3(T7)	;GET ADDRESS OF BYTE POINTER
	DPB	T1,(T2)		;SET NEW VALUE
ATTR.5:	AOBJN	T7,ATTR.4	;LOOP OVER ALL KNOWN CUSTOMER VALUES
	MOVE	T1,[3,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOAT3+.TOSET ;FUNCTION TO SET LDBAT3
	MOVE	T4,TERAT3	;WITH THIS VALUE
	XORM	T4,TRMAT3	;MAKE A CHANGE MASK
	SKIPE	TRMAT3		;IF SOMETHING CHANGED,
	TRMOP.	T1,		;SET IT
	  JFCL			;IGNORE ERRORS
NOATTR:	POPJ	P,		;DONE SETTYING TERMINAL VALUES

DOTTYC:	MOVE	T1,FFAPPN	;GET [1,2]
	TXNE	F,F.ANSW	;IF NOT LOGGED IN,
	CHGPPN	T1,		;CHANGE TO IT FOR
	  JFCL			; PRIVILEGED TRMOP.S
DOTC.1:	MOVE	T1,[3,,T2]	;POINTER FOR TRMOP
	HLRZ	T2,(T7)		;GET TRMOP FUNCTION
	CAIL	T2,1000		;SEE IF READ TRMOP.
	ADDI	T2,.TOSET	;YES--CHANGE TO SET
	MOVE	T3,TERNUM	;GET TERMINAL NUMBER
	HRRZ	T5,(T7)		;GET POINTER TO VALUE
	HLRZ	T4,(T7)		;GET TRMOP FUNCTION
	CAIE	T4,.TOTTN	;MODEL NAME?
	CAIN	T4,.TOTRM	;IS IT .TOTRM?
	 SKIPA	T4,(T5)		;YES--GET FULL WORD
	HRRZ	T4,(T5)		;GET VALUE IF ANY
	SKIPE	(T5)		;UNLESS NULL,
	TRMOP.	T1,		; SET VALUE
	  JFCL			;IGNORE ERRORS
	AOBJN	T7,DOTC.1	;LOOP FOR ALL FUNCTIONS
	MOVE	T1,MYPPN	;RECOVER ORIGINAL PPN
	TXNE	F,F.ANSW	;IF CHANGED AWAY,
	CHGPPN	T1,		;CHANGE BACK TO IT
	  JFCL			;(IGNORE IF CAN'T)
	POPJ	P,		;DONE
SUBTTL	ROUTINE TO QUERY TERMINAL TYPE (CHECK)

CHECK$:	MOVEI	T1,2		;BOOLEAN NO
	TXZE	F,F.NO		;DID USER SAY THAT?
	JRST	CHECK2		;YES--JUST GO SAY NO
	MOVEI	T1,1		;NO--GET A BOOLEAN YES
	CAIE	CH,":"		;IF NO VALUE,
	JRST	CHECK2		;GO SAY YES
	PUSHJ	P,GETSIX	;READ THE ARGUMENT
	MOVE	T2,[IOWD CHECKL,CHECKN] ;TABLE POINTER
	PUSHJ	P,FNDWRD	;LOOK IT UP
	  JRST	[TXO	F,F.CERR ;COMMAND ERROR IF NOT FOUND
		 POPJ	P,]	;PUNT THE USER
;IF WE EVER HAVE MULTIPLE ARGUMENTS, WE'LL NEED TO DISPATCH BASED ON WHICH ONE
	MOVE	T1,[2,,T2]	;UUO ARG POINTER
	MOVEI	T2,.TOTRM	;TTY TYPE READ
	MOVE	T3,TERNUM	;GET THE UDX
	TRMOP.	T1,		;WHAT ARE WE?
	  JRST	CHECK1		;DON'T CHECK IF DETACHED
	CAME	T1,DEFTYP	;IS THIS THE DEFAULT TYPE?
	JRST	CHECK1		;NO--DON'T CHECK
	MOVEI	T1,1		;YES--RESTORE BOOLEAN YES
	JRST	CHECK2		;AND STORE IT
CHECK1:	MOVEI	T1,2		;RESTORE 'NO' VALUE
CHECK2:	MOVEM	T1,FLCHEK	;SAVE ANSWER FOR LATER
	POPJ	P,		;RETURN

;OPTIONS TABLE FOR CHECK COMMAND

CHECKN:	EXP SIXBIT /DEFAULT/	;ONLY IF .TOTRM==%CNDTT
  CHECKL==.-CHECKN	;LENGTH OF OPTIONS TABLE

;HERE LATER TO DO THE TYPE CHECKING

CHECK:	SETZM	FLCHEK		;JUST IN CASE WE DON'T MAKE IT
	TXNN	F,F.FLN		;RUNNING ON FRCLIN?
	SKIPE	SILENC		;OR REQUESTED TO DO NO I/O?
	POPJ	P,		;YES--CAN'T DO THIS
	MOVE	T3,TERNUM	;MY TTY
	CAME	T3,TRMNUM	;WILL DOTTYS DO ANYTHING?
	POPJ	P,		;NO, SO NEITHER WILL WE
	SETOM	FLCHEK		;OK, WE'LL DO SOMETHING--CALL DOTTYB LATER
	MOVEI	T2,.TOFLM	;YES, GET FUNCTION TO FORCE LEFT MARGIN
	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	DMPBUF			;MAKE SURE SCNSER KNOWS OUR HPOS
	SKPINL			;DEFEAT ^O
	  JFCL			; ...
	TRMOP.	T1,		;DO CRLF IF NEEDED
	  JFCL			;PRE-703?  JUST HOPE.
	TTYSTR	[ASCIZ \[Checking terminal type . . .\]
	DMPBUF			;FLUSH THE BUFFER
	MOVEI	T2,.TO8BT	;FUNCTION TO READ TA.8BT
	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	TRMOP.	T1,		;READ IT
	  SETZ	T1,		;JUST HOPE
	MOVEM	T1,CHKS8B	;SAVE FOR LATER RESTORE
	SETSTS	TTY,.IOPIM	;SET PACKED-IMAGE I/O MODE
	MOVE	T1,[3,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TO8BT+.TOSET ;FUNCTION TO DIDDLE TA.8BT
	MOVEI	T4,1		;TURN IT ON
	CAME	T4,CHKS8B	;IF WAS 7-BIT,
	TRMOP.	T1,		;MAKE IT 8-BIT
	  JFCL			;SNH
	MOVEI	T1,ASKWTM	;NOMINAL SLEEP TIME
	SKIPL	SAVLCH		;IF A PTY, OR
		.CREF	GL.ITY		;(NOTE BIT WE CHECKED)
	TXNE	F,F.DCNL	;DECNET TERMINAL?
	IMULI	T1,NETWTF	;YES, FUDGE
	TXNE	F,F.DCNL	;CHECK DECNET AGAIN
	TDZA	T2,T2		;YES--DON'T FUDGE FOR SPEED
	SKIPL	T2,MYSPD	;NO--IF I HAVE A KNOWN SPEED
	IDIV	T1,TIMTBL(T2)	;BE LESS PATIENT WITH FASTER TTYS
	TXO	T1,HB.RWJ!HB.RTC ;ADD IN HIBER CONDITIONS
	MOVEM	T1,SLPTIM	;SET FOR PIMGET
	MOVE	T7,[-CHKNM1,,CHKTB1] ;AOBJN POINTER TO DEC TABLE
	MOVE	T8,[CHKAC1-CHKTB1(T7)] ;OFFSET IW CORRESPONDING
CHK.1:	MOVE	T1,(T7)		;GET EPASCC TO TYPE
	PUSHJ	P,TYPIST	;SEND THE IMAGE STRING
CHK.2:	MOVE	T6,@T8		;GET POINTER TO RESPONSE TABLE
	PIMGET	CH		;READ A CHARACTER
	  JRST	[PIMGET	CH	;BE KIND FOR THE FIRST CHARACTER
		   JRST	CHKLOP	;TIMEOUT
		 JRST	.+1]	;RE-JOIN MAIN LINE
	PUSHJ	P,RSPFND	;FIND DISPATCH FOR THIS CHARACTER
	  JRST	CHK.2		;TRY AGAIN IF JUNK IN BUFFER
	PUSHJ	P,(T1)		;CALL THE ROUTINE
	  JRST	CHKABT		;ABORT
	JRST	CHKFIN		;SUCCESS
CHKLOP:	AOBJN	T7,CHK.1	;LOOP OVER ENTIRE MAJOR TABLE
	CAIE	T7,CHKTB1+CHKNM1 ;DID WE JUST FINISH THE DEC TABLE?
	JRST	CHKABT		;NO, CUSTOMER--GIVE UP
	MOVE	T7,[-CHKNM2##,,CHKTB2##] ;AOBJN POINTER TO CUSTOMER TABLE
	HRRI	T8,CHKAC2##-CHKTB2## ;UPDATE OFFSET
	JUMPL	T7,CHK.1	;TRY CUSTOMER TABLE IF IT HAS ANY ENTRIES
				;GIVE UP IF NONE

CHKABT:	CLRBFO			;GIVE UP ON JUNKY OUTPUT
	TTYSTR	[ASCIZ \ unknown\] ;GIVE UP ON TYPE
	PJRST	CHKDUN		;CLEAN UP AND RETURN

CHKFIN:	MOVEM	T2,MODEL	;SAVE MODEL NAME TO SET
CHKF.1:	MOVE	T2,[3,,T3]	;POINTER FOR TRMOP
	MOVEI	T3,.TOTRM+.TOSET ;SET TTY TYPE FUNCTION
	MOVE	T4,TERNUM	;MY TTY
	MOVE	T5,(T1)		;GET AN ENTRY FROM THE TYPE TABLE
	TRMOP.	T2,		;TRY TO SET IT
	  CAIA			;FAILURE--TRY THE NEXT
	JRST	CHKF.2		;WIN--GO ANNOUNCE
	AOBJN	T1,CHKF.1	;LOOP OVER TABLE
	TTYSTR	[ASCIZ \ unknown\] ;WE DON'T KNOW
	JRST	CHKF.3		;REPORT MODEL ANYWAY
CHKF.2:	TTYSTR	[ASCIZ \ found \] ;SAY WE FOUND A TYPE
	MOVEM	T5,TYPE		;SET IT FOR LATER
	MOVE	T2,T5		;THE TYPE WE JUST SET
	PUSHJ	P,TYPSIX	;TYPE IT OUT
	CAMN	T5,MODEL	;IS THE TYPE THE SAME AS THE MODEL?
	JRST	CHKF.4		;YES, DON'T BE REDUNDANT
CHKF.3:	TTYCHR	"("		;MODEL NAME GETS PARENTHESIZED
	MOVE	T2,MODEL	;FETCH
	PUSHJ	P,TYPSIX	;AND TYPE
	TTYCHR	")"		;CLOSE PARENTHESES
CHKF.4:!			;DONE

CHKDUN:	MOVE	T1,[3,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TO8BT+.TOSET ;FUNCTION TO DIDDLE TA.8BT
	MOVE	T3,TERNUM	;MY TTY
	SKIPN	T4,CHKS8B	;IF WAS PREVIOUSLY 7-BIT,
	TRMOP.	T1,		;RESTORE IT
	  JFCL			;IGNORE ERRORS
	DMPBUF			;FLUSH BUFFER
	SETSTS	TTY,.IOAS8	;BACK TO NORMAL
	TTYSTR	[BYTE(7)"]",.CHCRT,.CHLFD,0] ;END MESSAGE & LINE
	CLRBFI			;GET RID OF POSSIBLE LEFT-OVER JUNK
	DMPBUF	1,		;FLUSH BUFFER AND RETURN

TIMTBL:	DEC	1,1,1,1,1,1,1,1,1,2,3,4,8,16,16,16,16	;SPEEDS 0 TO EXT.B
;SUBROUTINES USED IN TYPE CHECK DISPATCHING

DSPFND::MOVE	T2,T1		;COPY NUMBER
	TSC	T2,(T6)		;XOR WITH MATCH VALUE
	TRNE	T2,-1		;CHECK FOR MATCH
	AOBJN	T6,DSPFND	;LOOP OVER DISPATCH TABLE
	JUMPGE	T6,CPOPJ	;RETURN NON-SKIP IF NO MATCH
	HRRZ	T1,(T6)		;POINT TO HANDLER ROUTINE
	JRST	CPOPJ1		;AND SUCCEED

RSPFND::MOVE	T1,CH		;COPY CHARACTER
	TSC	T1,(T6)		;XOR WITH MATCH CHARACTER
	TRNE	T1,400		;IF FLAGGED,
	TRZ	T1,200		;KEEP TO 7-BIT
	TRNE	T1,377		;CHECK FOR MATCH
	AOBJN	T6,RSPFND	;LOOP OVER RESPONSE TABLE
	JUMPGE	T6,CPOPJ	;RETURN NON-SKIP IF NOT FOUND
	HRRZ	T1,(T6)		;POINT TO RESPONSE HANDLER
	JRST	CPOPJ1		;SUCCEED WITH ROUTINE ADDRESS IN T1

TYPIST::HLRZ	T2,T1		;GET NUMBER OF BYTES
	HRLI	T1,(POINT 8)	;8-BIT BYTE STRING
	CLRBFI			;TRY TO AVOID PARTIAL RESULTS
	ILDB	T3,T1		;GET NEXT CHARACTER
	TTYCHR	(T3)		;SEND IT
	SOJG	T2,.-2		;LOOP OVER ENTIRE STRING
	DMPBUF	1,		;FLUSH BUFFER AND RETURN

;HERE TO CHECK ON THE LENGTH & WIDTH OF A VARIABLY-SIZED TERMINAL

AVSIZE::PUSH	P,T1		;SAVE TYPE LIST
	PUSH	P,T2		;SAVE MODEL
	SKIPA	T1,.+1		;GET ASCIC STRING POINTER
	EPASCC	<.CHESC,"[","6","n",.CHESC,"\"> ;DSR(CPR) + ST
	PUSHJ	P,TYPIST	;ASK FOR CURRENT X & Y
	PUSHJ	P,GETSEQ	;READ IN THE SEQUENCE
	  JRST	TTPPJ1		;PUNT ON ERRORS
	CAIE	CH,"R"		;IS IT WHAT WE REQUESTED?
		[PUSHJ	P,CSIFLS ;NO--EAT SEQUENCE
		 JRST	TTPPJ1]	;AND PUNT IT
	AOBJP	T7,TTPPJ1	;MUST HAVE TWO PARAMETERS IN RESPONSE
	SKIPA	T1,.+1		;GET PROTOTYPE ASCIC STRING POINTER
	EPASCC	<.CHESC,"[","2","5","5",";","2","5","5","H",
.CHESC,"[","6","n",
.CHESC,"[","0","0","0",";","0","0","0","H",.CHESC,"\"> ;POSITION+ASK+RETURN+ST
	MOVE	T3,T1		;COPY ADDRESS
	HRLI	T3,(POINT 8)	;MAKE BYTE POINTER
	MOVE	T6,[POINT 8,STRBUF] ;GET DESTINATION BYTE POINTER
	HLRZ	T2,T1		;GET SOURCE COUNT
	MOVE	T5,T2		;SAME AS DESTINATION COUNT
	SETZB	T4,T7		;MAKE SURE OF CLEAN BYTE POINTERS
	EXTEND	T2,[EXP <MOVSLJ>,0] ;TRANSFER THE BYTES
	  JFCL			;WILL ALWAYS SKIP
	HRRI	T1,STRBUF	;MAKE NEW ASCIC POINTER
	MOVE	T2,[POINT 8,STRBUF+4] ;IDPB POINTER TO "RESTORE" POSITION
	MOVE	T3,PRMLST	;GET CURRENT "X"
	IDIVI	T3,^D100	;SPLIT OFF CENTURIES
	IDIVI	T4,^D10		;AND DECADES FROM UNITS
	MOVE	T3,EPTABL(T3)	;GET EVEN PARITY
	MOVE	T4,EPTABL(T4)	; ...
	MOVE	T5,EPTABL(T5)	; ...
	IDPB	T3,T2		;UPDATE THE "RESTORE" NUMBER
	IDPB	T4,T2		;IN THE STRING WE'LL TYPE
	IDPB	T5,T2		; ...
	IBP	T2		;SKIP THE SEMICOLON
	MOVE	T3,PRMLST+1	;GET CURRENT "Y"
	IDIVI	T3,^D100	;SPLIT OFF CENTURIES
	IDIVI	T4,^D10		;AND DECADES FROM UNITS
	MOVE	T3,EPTABL(T3)	;GET EVEN PARITY
	MOVE	T4,EPTABL(T4)	; ...
	MOVE	T5,EPTABL(T5)	; ...
	IDPB	T3,T2		;UPDATE THE "RESTORE" NUMBER
	IDPB	T4,T2		;IN THE STRING WE'LL TYPE
	IDPB	T5,T2		; ...
	PJRST	VSIZ.1		;FINALLY, ASK FOR SIZES AND DEAL WITH IT

EPTABL::EXP	"0","1"!200,"2"!200,"3","4"!200,"5","6","7"!200,"8"!200,"9"

VSIZE::	PUSH	P,T1		;SAVE TYPE LIST
	PUSH	P,T2		;SAVE MODEL
	SKIPA	T1,.+1		;GET ASCIC STRING POINTER
	EPASCC	<.CHESC,"7",.CHESC,"[","2","5","5",";","2","5","5","H",
.CHESC,"[","6","n",.CHESC,"8",.CHESC,"\"> ;STRING TO ASK FOR LENGTH & WIDTH
VSIZ.1:	PUSHJ	P,TYPIST	;SEND THE STRING
	PUSHJ	P,GETSEQ	;READ IN THE SEQUENCE
	  JRST	TTPPJ1		;PUNT ON ERRORS
	CAIE	CH,"R"		;IS IT WHAT WE REQUESTED?
	JRST	[PUSHJ	P,CSIFLS ;NO--EAT SEQUENCE
		 JRST	TTPPJ1]	;AND PUNT
	AOBJP	T7,TTPPJ1	;DEMAND TWO PARAMETERS
	SKIPLE	T1,PRMLST+1	;IF WIDTH RETURNED
	MOVEM	T1,WIDTH	;USE IT
	SKIPLE	T1,PRMLST	;IF LENGTH RETURNED,
	MOVEM	T1,LENGTH	;USE IT
TTPPJ1::POP	P,T2		;RESTORE MODEL
	POP	P,T1		;RESTORE TYPE LIST
	JRST	CPOPJ1		;SUCCEED

ANSPRM::SETZ	T1,		;START WITH A VALUE OF ZERO
ANSP.1:	ANDI	CH,177		;IGNORE PARITY HERE
	CAIL	CH,"0"		;IN RANGE FOR A DIGIT?
	CAILE	CH,"9"		; ...
	JRST	ANSP.2		;NO--SEE IF LEGAL
	IMULI	T1,^D10		;YES--ADVANCE DECADE
	ADDI	T1,-"0"(CH)	;ACCUMULATE NEW UNITS PLACE
	PIMGET	CH		;READ NEXT POSSIBLE DIGIT
	  POPJ	P,		;TIMEOUT
	JRST	ANSP.1		;LOOP OVER ALL DIGITS
ANSP.2:	CAIE	CH,":"		;VALID PARAMETER SEPARATION
	CAIN	CH,";"		; ...
	JRST	CPOPJ1		;WIN
	CAILE	CH,"/"		;INTERMEDIATE?
	CAILE	CH,"?"		;OR FINAL?
	AOS	(P)		;YES, WIN
	POPJ	P,		;OR FAIL IF NOT

GETSEQ::PIMGET	CH		;GET FIRST CHARACTER OF RESPONSE
	  PIMGET CH		;BE FORGIVING FOR FIRST ONE
	  JUMPE	CH,CPOPJ	;DOUBLE-TIMEOUT IS FATAL
	CAIE	CH,.CHESC	;START WITH ESCAPE?
	JRST	GETS.1		;NO--LOOK FOR CSI
	PIMGET	CH		;YES--LOOK FOR BRACKET
	  POPJ	P,		;TIMEOUT
	ANDI	CH,177		;IGNORE PARITY
	CAIE	CH,"["		;IS THIS A 7-BIT CSI?
	PJRST	CSIFLS		;NO--EAT THE SEQUENCE
	JRST	GETPRM		;YES--GET THE NEXT CHARACTER
GETS.1:	CAIE	CH,233		;LAST CHANCE--IS IT CSI?
	PJRST	CSIFLS		;NO--EAT THE SEQUENCE
GETPRM::PIMGET	CH		;PRIME THE PUMP
	  POPJ	P,		;TIMEOUT
	ANDI	CH,177		;IGNORE PARITY
GETPRP::MOVSI	T7,-PRMMAX	;AOBJN LIMIT FOR ANSI PARAMETERS
	SETZM	PRVPRM		;ASSUME NOT PRIVATE PARAMETER LIST
	CAIL	CH,.CHLAB	;GOOD ASSUMPTION?
	CAILE	CH,"?"		;CHECK...
	JRST	GETP.2		;SO FAR
	MOVEM	CH,PRVPRM	;NO, SAVE WHICH KIND OF PRIVATE
GETP.1:	PIMGET	CH		;READ NEXT CHARACTER
	  POPJ	P,		;TIMEOUT
	ANDI	CH,177		;STRIP POSSIBLE PARITY
GETP.2:	PUSHJ	P,ANSPRM	;READ AN OPTIONAL DECIMAL NUMBER
	  POPJ	P,		;TIMEOUT OR INVALID TERMINATOR
	CAIN	CH,":"		;NEXT ONE SELECTIVE?
	TLO	T1,(1B0)	;YES, FLAG THIS ONE
	MOVEM	T1,PRMLST(T7)	;SAVE THE VALUE
GETP.3:	CAILE	CH,"/"		;IS IT AN INTERMEDIATE?
	CAILE	CH,"?"		;OR A FINAL?
	JRST	GETP.4		;YES--DONE READING PARAMETERS
	CAIE	CH,";"		;NO, SEE IF SEPARATOR
	CAIN	CH,":"		;OF EITHER TYPE
	AOBJN	T7,GETP.1	;YES--LOOP OVER ALL PARAMETERS
	PIMGET	CH		;TOO MANY PARAMETERS
	  POPJ	P,		;TIMEOUT
	ANDI	CH,177		;IGNORE POSSIBLE PARITY
	JRST	GETP.3		;LOOK FOR END OF PARAMETER LIST
GETP.4:	SKIPL	T7		;DID WE OVERFLOW?
	MOVEI	T7,PRMMAX-1	;YES--BACK OFF TO THE LIMIT
	MOVSI	T7,1(T7)	;GET +VE LENGTH,,0
	MOVN	T7,T7		;MAKE AOBJN INDEXER TO VALID PART OF PRMLST
	JRST	CPOPJ1		;RETURN WINNITUDE
;DRIVER TABLES FOR CHECKING TERMINAL TYPE

CHKTB1:	EPASCC	<.CHESC,"Z">	;DECID
	EPASCC	<.CHESC,"[","c",.CHESC,"\"> ;DA + ST
CHKNM1==.-CHKTB1		;NUMBER OF ENTRIES

CHKAC1:	-DECIDL,,DECIDT		;RESPONSE TABLE FOR DECID
	-ANSDAL,,ANSDAT		;RESPONSE TABLE FOR DA

DECIDT:	433,,DECID		;7-BIT ESCAPE,,DISPATCH
DECIDL==.-DECIDT		;LENGTH OF TABLE

ANSDAT:	33,,ESCID		;ESCAPE,,DISPATCH
	233,,CSIID		;CSI,,DISPATCH
ANSDAL==.-ANSDAT		;LENGTH OF TABLE
;ROUTINES TO IDENTIFY TERMINAL TYPES -- DECID RESPONSE

DECID:	SETOM	ATRV52		;DECID IMPLIES VT52 EMULATION
	MOVEM	CH,VT52CH	;SAVE INITIAL CHARACTER
	PIMGET	CH		;READ NEXT CHARACTER OF SEQUENCE
	  POPJ	P,		;ABORT
	MOVE	T6,[-VT5XL,,VT5XT] ;POINT TO DISPATCH TABLE
	PUSHJ	P,RSPFND	;TRY TO FIND THIS CHARACTER
	  CAIA			;NOT THERE
	PJRST	(T1)		;THE LEAP OF FAITH
DECI.1:	SKIPGE	T6,[-ESCZL##,,ESCZT##] ;CHECK FOR A CUSTOMER TABLE
	PUSHJ	P,RSPFND	;TRY TO FIND IT THERE
	  POPJ	P,		;ABORT RETURN
	PJRST	(T1)		;CONTINUE IN NEXT HANDLER

DECIDQ:	MOVE	T1,VT52CH	;GET SAVED CHARACTER
	CAIE	T1,233		;WAS IT A CSI?
	JRST	DECI.1		;NO--SEE IF CUSTOMER TABLE CAN HANDLE IT
	PJRST	CSII.0		;YES--HANDLE AS A DA RESPONSE

VT5XT:	"/"+400,,VT5XR		;7-BIT SLASH,,DISPATCH
	"["+400,,ESCI.0		;ANSI RESPONSE
	"0",,DECIDQ		;CSI RESPONSE
	"1",,DECIDQ		;CSI RESPONSE
	"2",,DECIDQ		;CSI RESPONSE
	"3",,DECIDQ		;CSI RESPONSE
	"4",,DECIDQ		;CSI RESPONSE
	"5",,DECIDQ		;CSI RESPONSE
	"6",,DECIDQ		;CSI RESPONSE
	"7",,DECIDQ		;CSI RESPONSE
	"8",,DECIDQ		;CSI RESPONSE
	"9",,DECIDQ		;CSI RESPONSE
	.CHLAB,,DECIDQ		;CSI RESPONSE
	"=",,DECIDQ		;CSI RESPONSE
	.CHRAB,,DECIDQ		;CSI RESPONSE
	"?",,DECIDQ		;CSI RESPONSE
VT5XL==.-VT5XT			;LENGTH OF TABLE

VT5XR:	PIMGET	CH		;READ NEXT CHARACTER OF SEQUENCE
	  POPJ	P,		;ABORT
	MOVE	T6,[-SLAS.L,,SLAS.T] ;DISPATCH TABLE POINTER
	PUSHJ	P,RSPFND	;FIND THE ENTRY
	  CAIA			;NOT IN OUR TABLE
	PJRST	(T1)		;CONTINUE IN NEXT HANDLER
	SKIPGE	T6,[-SLASHL##,,SLASHT##] ;TRY CUSTOMER TABLE
	PUSHJ	P,RSPFND	;IF THERE IS ONE
	  POPJ	P,		;ABORT
	PJRST	(T1)		;THE LEAP OF FAITH

SLAS.T:	"#"+400,,VT71R		;VT71/VT72 RESPONSE
	"A"+400,,VT50R		;VT50 RESPONSE
	"B"+400,,VT50R		; ...
	"C"+400,,VT55R		;VT55 RESPONSE
	"E"+400,,VT55R		; ...
	"H"+400,,VT52H		;VT52H RESPONSE
	"J"+400,,VT52H		; ...
	"K"+400,,VT52R		;VT52 RESPONSE
	"L"+400,,VT52R		; ...
	"M"+400,,VT52R		; ...
	"Z"+400,,VT52AN		;FAKE VT52 RESPONSE
	"`"+400,,VT61R		;VT61 RESPONSE
	"a"+400,,VT61R		; ...
	"b"+400,,VT61R		; ...
	"c"+400,,VT61R		; ...
SLAS.L==.-SLAS.T		;LENGTH OF TABLE

VT50R:	HRROI	T1,['VT50  ']	;TYPE NAME
	MOVE	T2,(T1)		;MODEL
	JRST	CPOPJ1		;SUCCESS AT LAST

VT55R:	MOVE	T1,[-2,,[EXP 'VT55  ','VT52  ']] ;TYPE LIST
	MOVE	T2,(T1)		;MODEL NAME
	JRST	CPOPJ1		;SUCCESS

VT52H:	HRROI	T1,['VT52  ']	;TYPE NAME
	MOVE	T2,['VT52H ']	;MODEL NAME
	JRST	CPOPJ1		;SUCCESS

VT52R:	HRROI	T1,['VT52  ']	;TYPE NAME
	MOVE	T2,(T1)		;MODEL NAME
	CAIE	CH,"M"		;HAVE A PRINTER?
	CAIN	CH,"M"+200	;(CHECK WITH PARITY)
	SETOM	ATRPPO		;YES, REMEMBER THAT
	JRST	CPOPJ1		;SUCCESS

VT71R:	PIMGET	CH		;READ NEXT CHARACTER
	  POPJ	P,		;ABORT ON TIMEOUT
	ANDI	CH,177		;KEEP ONLY 7-BIT VALUE
	CAIG	CH,"/"		;STILL AN INTERMEDIATE?
	JRST	VT71R		;YES, LOOP UNTIL A FINAL
	MOVE	T1,[-2,,[EXP 'VT72  ','DAS21 ']] ;TYPE LIST
	MOVE	T2,(T1)		;MODEL NAME
	JRST	CPOPJ1		;SUCCESS

VT52AN:	TTYCHR	.CHESC		;LEAVE VT52 MODE
	TTYCHR	.CHLAB		; ...
	MOVE	T1,CHKTB1	;GET DECID STRING AGAIN
	PUSHJ	P,TYPIST	;SEND THE IMAGE STRING
	PIMGET	CH		;WAIT FOR A RESPONSE
	  PIMGET CH		;BE FORGIVING
	  JUMPE	CH,CPOPJ	;GIVE UP IF DOUBLE-TIMEOUT
	MOVE	T6,CHKAC1	;GET RESPONSE TABLE POINTER
	PUSHJ	P,RSPFND	;SEE IF WE UNDERSTAND IT
	  CAIA			;OOPS
	PUSHJ	P,(T1)		;CALL THE NEW HANDLER
	  CAIA			;OOPS
	AOS	(P)		;SKIP IF SUCCESSFUL
	PUSH	P,T2		;SAVE POSSIBLE MODEL NAME
	SKIPA	T1,.+1		;GET STRING TO RESTORE VT52 MODE
	EPASCC	<.CHESC,"[","?","2","l",.CHESC,"\">	; + ST
	PUSHJ	P,TYPIST	;SEND THE IMAGE STRING
	POP	P,T2		;RESTORE MODEL NAME
	HRROI	T1,['VT52  ']	;TYPE NAME
	SETZM	ANSLVL		;NO MORE ANSI LEVEL
	POPJ	P,		;PROPAGATE SKIPNESS

VT61R:	TRNE	CH,2		;PRT ATTRIBUTE IN RESPONSE?
	SETOM	ATRPPO		;YES, REMEMBER IT
	SETOM	ATRCID		;I&D CHAR
	SETOM	ATRLID		;I&D LINES
	HRROI	T1,['VT61  ']	;TYPE NAME
	MOVE	T2,(T1)		;MODEL NAME
	JRST	CPOPJ1		;SUCCESS
;ROUTINES TO IDENTIFY TERMINAL TYPES -- ANSI DA RESPONSE

ESCID:	PIMGET	CH		;TRY FOR THE "["
	  POPJ	P,		;ABORT ON TIMEOUT
ESCI.0:	CAIE	CH,333		;IF PARITY,
	TDZA	T1,T1		;NO--UNKNOWN IF 8-BIT
	MOVEI	T1,2		;YES--DEFNITELY 7-BIT
	MOVEM	T1,CSIS8B	;REMEMBER IF WANT 7-BIT
	MOVEM	T1,ATR8BT	;HERE, TOO
	SETZM	CHKS8B		;GO BACK TO 7-BIT
	PIMGET	CH		;READ THE NEXT CHARACTER
	  POPJ	P,		;ABORT ON TIMEOUT
	ANDI	CH,177		;STRIP PARITY
	PJRST	CSII.1		;HANDLE LIKE CSI FROM HERE

CSIID:	SETZM	CSIS8B		;CSI DIDN'T SET 8-BIT YET
	PIMGET	CH		;GET THE NEXT CHARACTER
	  POPJ	P,		;ABORT ON TIMEOUT
	CAIE	CH,333		;MARK PARITY 7-BIT?
	JRST	CSII.0		;NO--WE WIN
	MOVEI	T1,2		;'OFF'
	MOVEM	T1,ATR8BT	;NO WAY FOR 8-BIT
	MOVEM	T1,CSIS8B	;LIKEWISE
	SETZM	CHKS8B		;I MEAN IT
	PIMGET	CH		;TRY FOR PARAMETER CHARACTER
	  POPJ	P,		;TIMEOUT
	ANDI	CH,177		;IGNORE THE MARK PARITY
	JRST	CSII.1		;PARSE PARAMETERS
CSII.0:	SETOM	ATR8BT		;REALLY 8-BIT
	SETOM	CHKS8B		;I MEAN IT
	SETOM	ATR8BA		;REALLY
	SETOM	CSIS8B		;I SAID SO
CSII.1:	PUSHJ	P,GETPRP	;READ IN THE PARAMETER LIST
	  POPJ	P,		;PROPAGATE ERROR
	CAIE	CH,"c"		;IS IT WHAT WE REQUESTED?
	PJRST	CSIFLS		;NO--FLUSH IT AND GIVE UP
	MOVE	CH,PRVPRM	;GET PRIVATENESS
	MOVE	T6,[-CSIT.L,,CSITAB] ;DISPATCH TABLE
	PUSHJ	P,RSPFND	;LOOK IT UP
	  POPJ	P,		;SNH
	PJRST	(T1)		;PASS THE BUCK

CSITAB:	0,,CSIANS##		;NON-PRIVATE (I NEVER HEARD OF ONE)
	"?",,CSIDEC		;ASSUME IT'S OURS
	.CHLAB,,CSILAB##	;LEFT-ANGLE
	"=",,CSIEQL##		;EQUALS
	.CHRAB,,CSIRAB##	;RIGHT-ANGLE (ANN ARBOR?)
CSIT.L==.-CSITAB		;LENGTH OF TABLE

CSIFLS::ANDI	CH,177		;IGNORE PARITY
	CAIL	CH,"@"		;IS THIS A FINAL?
	POPJ	P,		;YES--WE CAN ABORT NOW
	PIMGET	CH		;NO--READ NEXT
	  POPJ	P,		;TIMEOUT
	JRST	CSIFLS		;LOOP UNTIL A FINAL CHARACTER IS SEEN
;ROUTINES TO IDENTIFY TERMINAL TYPES -- DEC-PRIVATE ANSI DA RESPONSE

CSIDEC:	MOVE	T1,PRMLST	;INITIAL NUMBER RECEIVED
	MOVE	T6,[-DECT.L,,DECTAB] ;DISPATCH TABLE
	PUSHJ	P,DSPFND	;FIND THIS VALUE IN THE TABLE
	  CAIA			;NOT A DEC TERMINAL
	PJRST	(T1)		;PASS THE BUCK
	SKIPGE	T6,[-CSID.L##,,CSID.T##] ;USE LIST OF CUSTOMER VALUES
	PUSHJ	P,DSPFND	;IF PRESENT
	  POPJ	P,		;PUNT
	PJRST	(T1)		;THE LEAP OF FAITH

DECTAB:	1,,VT100R
	2,,LA120R
	3,,LA34R
	4,,VT132R
	5,,VK100R
	6,,VT102R
	7,,VT131R
;	8,,VT278R
;	9,,LQP8FR
	^D10,,LA100R
	^D11,,LA120K
	^D12,,VT125R
	^D13,,LQP02
;	^D15,,LA12
	^D16,,VT102J
;	^D18,,VT80R
;	^D20,,LA80
	^D24,,LQP03
	^D26,,LN03
	^D61,,DISP1R
	^D62,,DISP2R
	^D63,,DISP3R
DECT.L==.-DECTAB		;LENGTH OF THE TABLE
;HERE FOR INDIVIDUAL DEC TERMINALS

VT100R:	MOVE	T1,PRMLST+1	;GET SUB-IDENTIFIER
	ANDI	T1,17		;MASK DOWN TO WHAT WE WANT TO SEE
	MOVE	T2,VT100T(T1)	;GET OUR TYPE TO SET
	HRROI	T3,2		;'NO' SETTING
	MOVEM	T3,ATR8BT	;CLEAR SOME PARAMETERS
	MOVEM	T3,ATR8BA
	MOVEM	T3,ATRPPO
	MOVEM	T3,ATRAVO
	MOVEM	T3,ATRSXL
	TRNE	T1,2		;THIS BIT
	SETOM	ATRAVO		;IMPLIES AVO
	TRNE	T1,10		;THIS BIT
	SETOM	ATRPPO		;IMPLIES PPO
	TRNE	T1,4		;THIS BIT
	SETOM	ATRSXL		;IMPLIES THE GPO
	MOVE	T1,ATRSXL	;THIS
	MOVEM	T1,ATRGPO	;IS THIS
	MOVE	T1,ATRPPO	;PRINTER PORT
	MOVEM	T1,ATRCID	;GIVES IDCHAR
	MOVEM	T1,ATRLID	;AND IDLINE
	HRROI	T1,MODEL	;TYPE TO SET
	PJRST	VSIZE		;CHECK 132-COLUMN MODE AND SUCCEED

VT100T:	'VT101 '
	'VT180 '
	'VT100 '
	'VT180 '
	'VT125 '
	'VT185 '
	'VT125 '
	'VT185 '
	'VT100 '
	'VT100 '
	'VT102 '
	'VT102 '
	'VT125 '
	'VT125 '
	'VT125 '
	'VT125 '

VT102J:	SETOM	ATRJTK		;KATAKNA IS PRESENT
	SKIPA	T2,['VT102J']	;MODEL NAME
VT102R:	MOVE	T2,['VT102 ']	;NORMAL MODEL NAME
	HRROI	T1,['VT102 ']	;TYPE NAME
	PJRST	VSIZE		;CHECK 132-COLUMN MODE AND SUCCEED

LA120K:	SETOM	ATRJTK		;KATAKANA IS PRESENT
	SKIPA	T1,[-2,,[EXP 'LA120K','LA120 ']] ;TYPE LIST
LA120R:	HRROI	T1,['LA120 ']	;TYPE NAME
	MOVE	T2,(T1)		;MODEL NAME
	JRST	CPOPJ1		;SUCCEED

LA100R:	SKIPA	T1,[-2,,[EXP 'LA100 ','LA34  ']] ;TYPE LIST
LA34R:	HRROI	T1,['LA34  ']	;TYPE NAME
	MOVE	T2,(T1)		;MODEL NAME
	MOVE	T3,PRMLST+1	;OPTIONS PARAMETER
	TRNE	T3,2		;THIS BIT
	SETOM	ATRJTK		;MEANS KATAKANA
	JRST	CPOPJ1		;SUCCEED

VT132R:	SKIPA	T1,[-2,,[EXP 'VT132 ','VT131 ']] ;TYPE LIST
VT131R:	HRROI	T1,['VT131 ']	;TYPE NAME
	MOVE	T2,(T1)		;MODEL NAME
	MOVE	T3,PRMLST+1	;OPTIONS PARAMETER
	HRROI	T4,2		;'NO' VALUE
	TRNE	T3,4		;THIS BIT
	SETO	T4,		;SAYS GPO
	MOVEM	T4,ATRGPO	;PROPAGATE TO REGIS
	MOVEM	T4,ATRSXL	;AND SIXEL
	SETOM	ATRPPO		;PRINTER PORT
	SETOM	ATRAVO		;AND AVO
	SETOM	ATRCID		;PPO IMPLIES IDCHAR
	SETOM	ATRLID		;AND IDLINE
	PJRST	VSIZE		;CHECK 132-COLUMN MODE AND SUCCEED

VK100R:	MOVE	T2,['VK100 ']	;MODEL NAME
	HRROI	T1,['VK100 ']	;TYPE NAME
	JRST	CPOPJ1		;SUCCEED

VT125R:	MOVE	T2,['VT125 ']	;MODEL NAME
	HRROI	T1,['VT125 ']	;TYPE NAME
	MOVE	T3,PRMLST+1	;OPTIONS PARAMETER
	TRNE	T3,2		;THIS BIT
	SETOM	ATRAVO		;MEANS AVO
	PJRST	VSIZE		;CHECK 132-COLUMN MODE AND SUCCEED

LQP02:	SKIPA	T2,['LQP02 ']	;MODEL NAME
LQP03:	MOVE	T2,['LQP03 ']	;MODEL NAME
	HRROI	T1,MODEL	;TYPE NAME
	JRST	CPOPJ1		;SUCCEED

LN03:	MOVE	T2,['LN03  ']	;MODEL NAME
	HRROI	T1,MODEL	;TYPE NAME
	JRST	CPOPJ1		;SUCCEED

DISP1R:	PUSHJ	P,DISPCL	;CLEAR RANDOM ATTRIBUTES
	MOVEI	T1,1		;OPERATING LEVELS
	MOVEM	T1,ANSLVL	;ANSI LEVEL
	MOVEM	T1,DECLVL	;DEC LEVEL
	PUSHJ	P,DISPST	;SET RANDOM ATTRIBUTES
	HRROI	T1,['VT102 ']	;TYPE NAME TO SET
	MOVE	T2,['VT1XX ']	;UNKNOWN EXTENDED MODEL
	PJRST	DSP3.4		;MAYBE CHECK WIDTH, THEN SUCCEED

DISP2R:	PUSHJ	P,DISPCL	;CLEAR RANDOM ATTRIBUTES
	MOVEI	T1,2		;OPERATING LEVELS
	MOVEM	T1,ANSLVL	;ANSI LEVEL
	MOVEM	T1,DECLVL	;DEC LEVEL
	SETOM	ATR8BA		;REALLY IS 8-BIT INTERFACE, BUT WON'T ADMIT IT
	MOVE	T1,['VT200 ']	;DEFAULT TYPE IF NO USEFUL DA2 RESPONSE
	MOVEM	T1,DA2DEF	;SAVE FOR LATER
	SKIPA	T1,.+1		;GET S8C1T SEQUENCE
	EPASCC	<.CHESC," ","G">
	PJRST	DSP3.1		;RE-JOIN COMMON DISPLAY CODE

DISP3R:	PUSHJ	P,DISPCL	;CLEAR RANDOM ATTRIBUTES
	MOVEI	T1,3		;OPERATING LEVELS
	MOVEM	T1,ANSLVL	;ANSI LEVEL
	MOVEM	T1,DECLVL	;DEC LEVEL
	MOVE	T1,['VT300 ']	;DEFAULT TYPE IF UNKNOWN DA2 RESPONSE
	MOVEM	T1,DA2DEF	;SAVE FOR LATER
	SKIPA	T1,.+1		;GET DECSCL(3) SEQUENCE
	EPASCC	<.CHESC,"[","6","3",";","2","""","p">
DSP3.1:	PUSHJ	P,TYPIST	;SELECT CONFORMANCE LEVEL (2 OR 3)
	SKIPE	CSIS8B		;DO WE KNOW FOR SURE (CSI, MARK PARITY)?
	JRST	DSP3.2		;YES--DON'T CHECK
	MOVE	T1,CHKTB1+1	;GET DA SEQUENCE
	PUSHJ	P,TYPIST	;SOLICIT TYPE INFORMATION AGAIN
	PIMGET	CH		;GET FIRST CHARACTER OF RESPONSE
	  PIMGET CH		;WAIT AGAIN
	  JFCL			;IN CASE SECOND SUCCEEDS
	CAIE	CH,233		;CSI?
	TDZA	T1,T1		;NO, NOT 8-BIT
	MOVEI	T1,1		;YES, SET 8-BIT
	PIMGET	CH		;CHECK NEXT CHARACTER, TOO
	  SETZ	T1,		;CROCK TO GO BACK TO 7-BIT
	CAIN	CH,333		;IF MARK PARITY,
	SETZ	T1,		;DON'T TRUST THE CSI
	MOVEM	T1,CHKS8B	;IN RESTORE VALUE
	HRROM	T1,ATR8BT	;AND ATTRIBUTE FLAG
	PUSHJ	P,CSIFLS	;PUNT REMAINDER OF STRING
DSP3.2:	SKIPA	T1,.+1		;GET S7C1T STRING
	EPASCC	<.CHESC," ","F"> ;STRING TO SELECT 7-BIT C1 TRANSMISSION AGAIN
	SKIPL	CSIS8B		;UNLESS WAS ALREADY 8-BIT,
	PUSHJ	P,TYPIST	;PUT IT BACK TO 7-BIT CONTROLS
	SKIPA	T1,.+1		;GET (DEC)DA2 SEQUENCE
	EPASCC	<.CHESC,"[",.CHRAB,"c">	;SECONDARY ATTRIBUTES REQUEST
	PUSHJ	P,TYPIST	;TYPE THE STRING
	PUSHJ	P,DISPST	;SET RANDOM VALUES
	SKIPE	CHKS8B		;IF 8-BIT,
	SETOM	ATR8BA		;ENFORCE 8-BIT ARCHITECTURE
	PUSHJ	P,GETSEQ	;READ PARAMETERS FROM SEQUENCE
	  JRST	DSP3.3		;PUNT ON ERRORS
	CAIE	CH,"c"		;PROPER TERMINATOR?
	JRST	[PUSHJ	P,CSIFLS	;NO, EAT ANY REMAINING SEQUENCE
		 JRST	DSP3.3]		;AND PUNT IT
	MOVEI	T1,.CHRAB	;CHARACTER FOR DA2
	CAME	T1,PRVPRM	;RIGHT SORT OF PRIVATENESS?
	JRST	DSP3.3		;NO--PUNT
	MOVE	T1,PRMLST	;GET DEVICE TYPE
	MOVE	T6,[-DA2MAX,,DA2TYP] ;AND TYPE CODE LIST
	PUSHJ	P,DSPFND	;SEE WHAT WE THINK OF THE VALUE
	  JRST	[SKIPGE	T6,[-DA2T.L##,,DA2T.T##] ;IF HAVE A CUSTOMER LIST,
		 PUSHJ	P,DSPFND	;SEARCH IT
		   JRST	DSP3.3		;NOT THERE EITHER--PUNT IT
		 JRST	.+1]	;RE-JOIN MAIN LINE
	MOVE	T1,(T1)		;FETCH THE TYPE
	MOVEM	T1,DA2DEF	;SAVE IT FOR LATER
	MOVE	T1,PRMLST	;GET DEVICE-TYPE CODE AGAIN
	SKIPGE	T6,[-DA2DSL,,DA2DSP] ;IF ANYTHING IN THE TABLE,
	PUSHJ	P,DSPFND	;LOOK IT UP
	  JRST	[SKIPGE	T6,[-DA2D.L##,,DA2D.T##] ;CHECK FOR A CUSTOMER TABLE
		 PUSHJ	P,DSPFND	;AND SEARCH IT
		   JRST	.+2		;NO MATCH
		 JRST	.+1]	;RE-JOIN MATCH CODE
	PUSHJ	P,(T1)		;CALL SPECIAL PROCESSOR
	SKIPN	LOCDVT		;DO WE EXPECT A LOCATOR?
	JRST	DSP3.3		;NO--JUST SETUP THE TYPE
	SETZM	LOCDVT		;CLEAR, JUST IN CASE IT'S MISSING
	AOBJP	T7,DSP3.3	;SKIP OVER DEVICE TYPE
	AOBJP	T7,DSP3.3	;SKIP OVER FIRMWARE VERSION
	MOVE	T1,PRMLST(T7)	;GET LOCATOR DEVICE TYPE
	MOVEM	T1,LOCDVT	;PUT IT WHERE WE'LL USE IT
DSP3.3:	MOVE	T2,DA2DEF	;FETCH TYPE/MODEL NAME AGAIN
	HRROI	T1,MODEL	;TYPE IS SAME AS MODEL
	TLC	T2,777700	;SEE IF LOOKS LIKE AN AOBJN POINTER
	TLCE	T2,777700	; ...
	JRST	DSP3.4		;NO--JUST USE WHAT WE SET UP
	MOVE	T1,T2		;YES--USE THIS TYPE LIST
	MOVE	T2,(T1)		;AND THE FIRST ENTRY FOR THE MODEL NAME
DSP3.4:	HRRZ	T3,ATRVFW	;VARIABLE WIDTH SETTING
	CAIE	T3,2		;STILL CLEAR?
	PJRST	VSIZE		;NO--CHECK 132-COLUMN MODE AND SUCCEED
	JRST	CPOPJ1		;YES--JUST SUCCEED NOW

DA2DSP:
DA2DSL==.-DA2DSP

DA2TYP:	1,,['VT220 ']
	2,,['VT240 ']
	^D18,,['VT330 ']
	^D19,,['VT340 ']
DA2MAX==.-DA2TYP

DISPCL:	MOVSI	T1,-DA1MAX	;TABLE SIZE
	HRROI	T2,2		;'NO' VALUE
	MOVEM	T2,@DA1TAB(T1)	;CLEAR A PARAMETER
	AOBJN	T1,.-1		;LOOP OVER ALL KNOWN PARAMETERS
	SETZM	LOCDVT		;CLEAR THIS ONE SPECIALLY
	POPJ	P,		;DONE

DISPST:	AOBJP	T7,CPOPJ	;PRE-ADVANCE OVER CONFORMANCE LEVEL
DSPS.1:	MOVE	T1,PRMLST(T7)	;GET NEXT ATTRIBUTE INDEX
	SETOM	@DA1TAB(T1)	;SET THIS ONE
	AOBJN	T7,DSPS.1	;LOOP OVER ALL ATTRIBUTES IN DA RESPONSE
	POPJ	P,		;DONE

DA1TAB:	EXP	T3,ATRVFW,ATRPPO,ATRGPO,ATRSXL,ATRJTK,ATRSEM
	EXP	ATRRCS,ATRUDK,ATRNRC,T3,ATRESL,T3,ATRBMT,ATR8BA
	EXP	ATRTCS,LOCDVT,ATRTSI,ATRUWN,ATRSSU,T3,ATRHSR
DA1MAX==.-DA1TAB
SUBTTL	ROUTINE TO SETUP TTY "TYPE"

TYPE$:	TXZE	F,F.NO		;TEST AND ZERO NO BIT
	 JRST	[SETZ	WD,	;BIT ON--CLEAR WD
		 JRST	TYPE$1]	;AND WRAPUP
	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETSIX	;GET TERMINAL NAME
	JUMPN	WD,TYPE$1	;WAS ANYTHING SPECIFIED?
	INTWRN	(NTS,No type specified)
	POPJ	P,		;OK RETURN
TYPE$1:	MOVEM	WD,TYPE		;STORE TERMINAL TYPE
	SETZM	FLCHEK		;DON'T CHECK IF ALREADY HAVE THE TYPE
	POPJ	P,		;OK RETURN

SUBTTL	ROUTINE TO SETUP TTY "MODEL"

MODEL$:	TXZE	F,F.NO		;WAS "NO" TYPED?
	JRST	[SETZ	WD,	;YES, CLEAR WORD
		 JRST	MODEL1]	;AND SET THE ZERO
	PUSHJ	P,SKIPTV	;NO, SKIP SPACES
	PUSHJ	P,GETSIX	;READ IN THE TOKEN
	JUMPN	WD,MODEL1	;JUST DO IT IF OK
	INTWRN	(NMS,No model specified)
	POPJ	P,		;RETURN IF JUNK
MODEL1:	MOVEM	WD,MODEL	;SAVE MODEL NAME
	POPJ	P,		;RETURN
SUBTTL	TTY CONTROL LIST ROUTINE
;FORMAT IS XWD TRMOP.,VALUE

DOTTYT:
	.TOTRM,,TYPE	;TTY TYPE:XXXXXX
	.TOTTN,,MODEL	;TTY MODEL:XXXXXX
	.TOTCN,,CLASS	;TTY CLASS:XXXXXX
	.TOAPC,,APC	;TTY APC
DOTTTA:		;START HERE IN DOTTYA
	.TORSP,,RCV	;TTY RCV:XX
	.TOTSP,,XMT	;TTY XMT:XX
	.TOLCP,,LOCALC	;TTY LOCALCOPY
	.TOCLE,,ECHO	;TTY ECHO
	.TODEM,,ECHDEF	;TTY DEFER
	.TOWID,,WIDTH	;TTY WIDTH:N
	.TOLNB,,LENGTH	;TTY LENGTH:N
	.TOSSZ,,SSIZE	;TTY STOP:N
	.TOSST,,SSTOP	;TTY SSTOP
	.TOSTO,,STOP	;TTY STOP
	.TOFLC,,FILL	;TTY FILL:N
	.TOLCT,,LC	;TTY LC
	.TOTAB,,TAB	;TTY TAB
	.TOFRM,,FORM	;TTY FORM
	.TONFC,,CRLF	;TTY NO CRLF
	.TOSND,,GAG	;TTY NO GAG
	.TOSBL,,SBELL	;TTY SBELL
	.TODIS,,ATRDIS	;TTY DISPLAY
	.TOTAP,,TAPE	;TTY TAPE
	.TOPAG,,PAGEON	;TTY PAGE
	.TOPSZ,,PAGE	;TTY PAGE:N
	.TOBLK,,BLANK	;TTY NO BLANKS
	.TOALT,,ALT	;TTY ALT
	.TORTC,,RTCOMP	;TTY RTCOMP
	.TORMT,,REM	;TTY REMOTE (NOT LOCAL)
	.TOXNF,,XONXOFF	;TTY XONXOFF
DOTTLA==.-DOTTTA	;LENGTH FOR DOTTYA
	.TOUNP,,UNPAUSE	;TTY UNPAUSE
	.TOESC,,ESCAPE	;TTY ESCAPE
	.TO8BT,,ATR8BT	;TTY EIGHTBIT
	.TOQOT,,QUOTE	;TTY QUOTE
	.TOMXT,,IDLE	;TTY IDLEDISC
	.TOEDT,,EDITOR	;TTY EDITOR

DOTTLG==.-DOTTYT

;THE FOLLOWING ARE NOT SETTABLE BY THE USER, FOR TYPEOUT ONLY, AND MUST BE LAST

DOTTTC:
	.TOSLV,,SLAVE	;TTY SLAVE

DOTTLC==.-DOTTTC	;LENGTH FOR SECOND HALF OF DOTTYA

DOTTYU==.-DOTTYT
;TABLE FOR .TOATR SETTING
;FORMAT IS:	XWD	STORAGE-ADDRESS,BIT-ADDRESS

ATRTB1:

DEFINE	ATR(SYL),<IRP SYL,<XWD ATR'SYL,[TA.'SYL]>>

ATR	<8BA,8BT,AVO,BMT,BTA,CID,CLR,DIS>
ATR	<ESL,GAT,GPO,HSR,ISO,JTK,LID,NKB>
ATR	<NRC,OVR,PPO,RCS,SEM,SRM,SSU,SXL>
ATR	<TCS,TEK,TSI,UDK,UWN,V52,VFL,VFW>

ATRNM1==.-ATRTB1	;NUMBER OF KNOWN ATTRIBUTES


;TABLES FOR .TOAT2 & .TOAT3
;FORMAT IS:	XWD	STORAGE-ADDRESS,BYTE-POINTER-ADDRESS

ATRTB2:
	XWD	ANSLVL,[POINTR	TERAT2,T2.ACL]
	XWD	DECLVL,[POINTR	TERAT2,T2.DCL]
	XWD	LOCDVT,[POINTR	TERAT2,T2.LDT]

ATRNM2==.-ATRTB2

ATRTB3:

;ADD CUSTOMER-DEFINED FIELDS HERE

ATRNM3==.-ATRTB3
SUBTTL	SPECIAL PROCESSORS

;HERE TO START UP FILEX UNDER [10,1] TO SAVE CRASH

SUBTTL	FILEX PROCESSOR
FILEX:	MOVX	T2,%LDCRP	;GET NUMBER OF CRASH STORAGE AREA
	GETTAB	T2,		;FROM THE MONITOR
	  MOVE	T2,[10,,1]	;(FOR PRE 5.3)
	TLNE	T2,777760	;HACK TO GET AROUND 5.2 BUG
	MOVE	T2,[10,,1]	;WHICH GAVE JUNK IN 16,,16
	MOVE	T4,[SIXBIT /FILEX/]  ;GET CUSP NAME
	JRST	LOGCSP		;GO LOGIN AND RUN CUSP

SUBTTL	OMOUNT PROCESSOR
OMOUNT:	MOVE	T4,[SIXBIT /OMOUNT/]  ;GET CUSP NAME
	JRST	CUSP12		;GO LOGIN AND RUN IT

SUBTTL	DAEMON PROCESSOR
DAEMON:	MOVE	T4,[SIXBIT /DAEMON/]  ;GET THE CUSP NAME
	JRST	CUSP12		;GO LOGIN AND RUN IT

SUBTTL	CHKPNT PROCESSOR
CHKPNT:	MOVE	T4,[SIXBIT /CHKPNT/]  ;GET THE CUSP NAME
	JRST	CUSP12		;GO LOGIN AND RUN IT

SUBTTL	OPSER PROCESSOR
OPSER1:	TXO	F,F.CCL		;FORCE CCL ENTRY POINT
OPSER:	MOVE	T4,[SIXBIT /OPSER/]  ;GET CUSP NAME
	JRST	CUSP12		;LOGIN AND RUN IT

SUBTTL	PRINTR PROCESSOR
PRINTR:	MOVE	T4,[SIXBIT /PRINTR/]  ;GET THE CUSP NAME
	JRST	CUSP12		;AND LOGIN AND START IT

SUBTTL	GALOPR PROCESSOR
GALOPR:	TXO	F,F.CCL!F.IPCQ	;FORCE CCL RUN AND LARGE IPCF QUOTAS
	MOVSI	T4,'OPR'	;NAME OF PROGRAM
	JRST	CUSP12		;LOGIN AND START IT

SUBTTL	SYSDPY PROCESSOR

DEFINE	DPYNAM,<
        X VT05A,SYSDPA
	X VT05B,SYSDPB
	X VT06 ,SYSDPY
	X VT50 ,SYSV50
	X VT52 ,SYSV52
	X VT61 ,SYSV61
	X VK100,SYSANS		;GIGI
	X VT100,SYSANS
	X VT101,SYSANS
	X VT102,SYSANS
	X VT103,SYSANS
	X VT125,SYSANS
	X VT180,SYSANS
	X VT185,SYSANS
	X VT220,SYSANS
	X VT240,SYSANS
;NON-STANDARD TERMINAL TYPES, MONITOR DOESN'T KNOW ABOUT THEM.
	X HAZELT,SYSHZL		;HAZELTINE 2000
	X DELTA,SYSDLT		;DELTA DATATERM
	X VB10C,SYSVBC		;VB10C. HAH!
	X DAS21A,SYSANS		;DAS21 RUNNING ANSI CODE
>

DEFINE X(TERM,PROG),<SIXBIT \TERM\>
DPYTRM:	DPYNAM
DPYOFF=.-DPYTRM

DEFINE X(TERM,PROG),<SIXBIT \PROG\>
DPYPRG:	DPYNAM

	PURGE X
DPYTAB:	IOWD DPYOFF,DPYTRM


SYSDPY:	MOVE	T1,[2,,T2]	;ARG FOR TRMOP
	MOVEI	T2,.TOTRM	;TERMINAL TYPE
	SETO	T3,		;MYSELF
	TRMOP.	T1,		;ASK
	 SETZ	T1,		;GIVE A NONEXISTANT TERMINAL TYPE
	MOVE	T2,DPYTAB	;AOBJN POINTER TO TERMINAL TYPE TO SYSDPY NAME
	CAME	T1,(T2)		;IS THIS THE RIGHT NAME?
	AOBJN	T2,.-1		;NO, TRY NEXT NAME
	JUMPL	T2,SYSDP1	;RUN CORRESPONDING VERSION IF GOT ONE
	MOVE	T1,[2,,T2]	;ARG FOR TRMOP
	MOVEI	T2,.TOTCN	;CLASS NAME
	TRMOP.	T1,		;ASK
	  JRST	SYSDP0		;PRE-7.04
	MOVE	T2,DPYTAB	;AOBJN POINTER TO TYPE TABLE
	CAME	T1,(T2)		;HAVE A MATCH?
	AOBJN	T2,.-1		;LOOP OVER TABLE FOR A MATCH
	JUMPL	T2,SYSDP1	;GOT ONE, USE IT
	MOVE	T1,[2,,T2]	;ARG FOR TRMOP
	MOVEI	T2,.TOAT2	;ATTRIBUTE BYTES
	TRMOP.	T1,		;ASK
	  JRST	SYSDP0		;SNH
	MOVEI	T2,['SYSANS']-DPYOFF	;DEFAULT IF ANSI
	TXNE	T1,T2.ACL	;IS THIS AN ANSI TERMINAL?
	JRST	SYSDP1		;YES, USE THE ANSI VERSION OF SYSDPY
SYSDP0:	 SKIPA	T4,[SIXBIT \SYSV52\] ;NO, RUN A DEFAULT VERSION
SYSDP1:	MOVE	T4,DPYOFF(T2)	;GET PROGRAM NAME TO RUN
        TXO	F,F.LOGX	;FLAG OK TO RUN UNDER ANY NUMBER
	TXZ	F,F.REMO	;[267] MAKE SURE WE GET OUR PRIVS
SUBTTL	LOGIN TO 1,2 AND RUN CUSP NAMED IN T4

CUSP12:	PUSH	P,T4		;SAVE T4
	PUSHJ	P,LOGI12	;LOG INTO 1,2 TO DISPLAY PRIVILEGED INFORMATION
	JRST	CUSPXX		;GO FINISH RUNNING CUSP

;HERE TO DO ARBITRARY LOGIN TO (T2) AND RUN CUSP IN (T4)

LOGCSP:	PUSH	P,T4		;SAVE COPY OF CUSP NAME
	PUSHJ	P,LOGIN$	;GO DO LOGIN

CUSPXX:	POP	P,T2		;RESTORE T2

SUBTTL	START UP CUSP NAMED IN T2

CUSP:	PUSH	P,T2		;SAVE NAME
	TTYSTR	[ASCIZ /.R /]
	PUSHJ	P,TYPSIX	;TYPE NAME
	TTYSTR	CRLFM
	POP	P,T2		;RECOVER NAME
	TXNN	F,F.CCL		;SEE IF FORCED CCL ENTRY POINT
	TLZA	T1,-1		;CLEAR RUN OFFSET
CUSP1:	MOVSI	T1,1		;SET RUN OFFSET FOR CCL ENTRY
	MOVEM	T2,RUNBLK+1	;SAVE CUSP NAME
	MOVSI	T2,(SIXBIT /SYS/)  ;GET CUSPS FROM SYS
	MOVEM	T2,RUNBLK	;SAVE DEVICE
	HRRI	T1,RUNBLK	;SET POINTER FOR RUN UUO
	MOVEM	F,SAVEF		;SAVE FLAGS FOR LATER
	DMPBUF			;DUMP TTY BUFFER
	MOVE	T2,[RUN T1,]	;GET RUN UUO
	TXNE	F,F.PHYS	;SEE IF PHYSICAL NEEDED
	TXO	T2,UU.PHY	;YES--SET IT
	XCT	T2		;GO RUN THE CUSP
	MOVE	P,[IOWD L$PDL,PDL]  ;IN CASE OF FAILURE--LOGOUT
	MOVEI	ME,0		;CLEAR GARBAGE
	MOVE	F,SAVEF		;RESTORE FLAGS
	INTERR	(NFD,,<JRST .+1>)
	MOVE	T2,RUNBLK+1	;GET CUSP NAME
	PUSHJ	P,TYPSIX	;TYPE IT OUT
	TTYSTR	[ASCIZ / not found
/]
SUBTTL	KILL JOB ROUTINE

KILJOB:	TXNE	F,F.RTTY	;SEE IF STILL SOME TO REEAT
	PUSHJ	P,TTYIND	;YES--EAT IT UP
	TXNN	F,F.LOGI	;SEE IF LOGGED IN
	TTYSTR	[ASCIZ	/
./]				;NO--GIVE CONVENTIONAL DOT
LOGOF$:	DMPBUF			;EMPTY TTY BUFFER
LOGO1$:	LOGOUT	1,		;EXIT WITH JUST A DOT

LOGOU$:	LOGOUT			;DESTROY THE JOB

LOGO2$:	CTYSTR	[ASCIZ \%FRCLIN INITIA - Logging out
\]
	MOVEI	1,[SIXBIT \SYS\
		SIXBIT \LOGOUT\
		EXP 0,0,0,0]	;SYS:LOGOUT, NOTHING FANCY.
	RUN	1,
	 JFCL
	LOGOUT			;IF RUN FAILED, GIVE UP.

SUBTTL	SUBROUTINE TO LIST STRUCTURE NOTES

STRUCT:	MOVEI	T7,0		;PRESET FOR SYSSTR
	MOVE	T6,.JBFF	;SAVE FREE CORE
STRUCL:	MOVEM	T6,.JBFF	;RESTORE FREE CORE
	SYSSTR	T7,		;GET NEXT STR IN SYSTEM
	  POPJ	P,		;GIVE UP IF NOT LEVEL-D
	JUMPE	T7,CPOPJ	;RETURN WHEN DONE
	PUSH	P,T6		;SAVE TWO AC'S
	PUSH	P,T7		; ..
	MOVX	T5,UU.PHS	;ACCESS /PHYSICAL
	MOVE	T6,T7		;GET STR NAME
	MOVEI	T7,IBF		;POINT TO INPUT BUFFER HEADER
	MOVSI	T1,'STR'	;PREPARE
	MOVSI	T2,'TXT'	; FILE
	MOVEI	T3,0		; STR.TXT[1,4]
	MOVE	T4,SYSPPN	; ON EACH STRUCTURE
	PUSHJ	P,HILOOK	;LOOKUP FILE ON DISK OR HISEG
	  JRST	STRUCO		;IGNORE IF MISSING OR SCREWY
	MOVE	T2,(P)		;GET STR NAME
	PUSHJ	P,TYPSIX	;TYPE IT
	TTYSTR	[ASCIZ /:	/]
	PUSHJ	P,TYPFIL	;GO TYPE FILE
STRUCO:	POP	P,T7		;RESTORE STR NAME
	POP	P,T6		;RESTORE .JBFF
	SETZM	LOWPTR		;FORGET ABOUT FILE
	RELEAS	TI,		;RELEASE CHANNEL
	HLLZS	.JBINT		;CLEAR INTERCEPT
	TXZ	F,F.EOF		;CLEAR EOF FLAG
	JRST	STRUCL		;LOOP FOR NEXT STR
SUBTTL	SYSTEM STARTUP COMMAND (FORCE INITIA ON FRCLIN)

SYSIN$:	TXNN	F,F.CTY		;ARE WE A GOOD GUY?
	JRST	SYSINE		;NO
	MOVE	T3,FLNNUM	;GET FRCLIN UDX
	MOVE	T2,['INITIA']	;INITIA COMMAND
	MOVE	T1,[2,,T2]	;FRCUUO ARG POINTER TO
	FRCUUO	T1,		;FORCE AN INITIA COMMAND ON FRCLIN
	 JFCL			;OH WELL
	POPJ	P,		;SUCCESSFUL RETURN

SYSINE:	INTERR	(SLC,<SYSTEM command legal only from [OPR] on CTY:>,<JRST .+1>)
	TXO	F,F.CERR	;FLAG ERROR
	POPJ	P,		;AND DISAPPEAR

;NOTE, THAT IF WE GET HERE, WE DO NOT DO INITIA NORMAL STUFF
STOMP$:
	MOVE	T1,MYPPN	;FIND OUT WHAT I AM
	CAMN	T1,FFAPPN	;ARE WE GOD?
	 JRST	STOMP1		;I'M O.K. - GO AHEAD.
	INTERR	(STC,<STOMP command legal only from [OPR]>,<JRST .+1>)
	TXO	F,F.CERR	;FLAG AN ERROR
	POPJ	P,		;AND RETURN TO COMMAND PARSER

STOMP1:	SETOM	TTWFLG		;FLAG THAT WE WANT TO START STOMPING.
	MOVEI	T1,STOMP3	;ROUTINE TO START STOMPING WITH
	MOVEM	T1,JUMPPR	;WILL CATCH THIS AT END OF PROCESSING.
	POPJ	P,		;AND RETURN


STOMP3:	OUTSTR	[ASCIZ \%%TTY STOMPER detaching from terminal
\]
	HRROI	T1,		;SET UP FOR DETACH
	ATTACH	T1,		;LET GO OF THE TERMINAL
	 JRST	[INTERR (ATF,<ATTACH uuo to detach failed!!!>,<POPJ P,>)]
	JRST	TTWINI		;JUMP INTO TTY STOMPER CODE


SUBTTL	HELP ROUTINE

HELP:	MOVE	T1,['INITIA']
	PUSHJ	P,.HELPR##	;GO GIVE HELP
	JRST	KILJOB		;GO KILL JOB
SUBTTL	SUBROUTINES TO LIST SYSTEM AND TEXT NOTICES

;ROUTINE TO TYPE OUT INITIA.TXT FROM SYS:

TEXT:	MOVEI	T5,0		;READ IN ASCII MODE
	MOVSI	T6,'SYS'	;SYS:
	MOVEI	T7,IBF		;INPUT BUFFER
	MOVE	T1,['INITIA']	;LOOKUP
	MOVSI	T2,'TXT'	; FILE
	SETZB	T3,T4		; SYS:INITIA.TXT[-]
	PUSHJ	P,HILOOK	;FIND FILE IN HISEG
	  POPJ	P,		;GIVE UP IF NO FILE
	PUSHJ	P,TYPFIL	;TYPE CONTENTS OF FILE
	SETZM	LOWPTR		;FORGET FILE
	RELEAS	TI,		;RELEASE CHANNEL
	TXZ	F,F.EOF		;CLEAR EOF INDICATOR
	POPJ	P,		;RETURN

NOTICE:	MOVEI	T5,0		;READ IN ASCII MODE
	MOVSI	T6,'SYS'	;SYS:
	MOVEI	T7,IBF		;INPUT BUFFER
	MOVE	T1,['NOTICE']	;LOOKUP
	MOVSI	T2,'TXT'	; FILE
	SETZB	T3,T4		; SYS:NOTICE.TXT[-]
	PUSHJ	P,HILOOK	;FIND FILE IN HISEG
	  POPJ	P,		;GIVE UP IF NO FILE
	PUSHJ	P,TYPFIL	;TYPE CONTENTS OF FILE
	SETZM	LOWPTR		;FORGET FILE
	RELEAS	TI,		;RELEASE CHANNEL
	TXZ	F,F.EOF		;CLEAR EOF INDICATOR
	POPJ	P,		;RETURN
SUBTTL	SUBROUTINE TO TYPE TTY SETTINGS

TYPTTY:	MOVE	T1,[2,,T2]	;ARG POINTER
	MOVEI	T2,.TOATR	;ATTRIBUTES
	MOVE	T3,TERNUM	;SEE IF I CAN READ THEM AT ALL
	TRMOP.	T1,		;CAN I?
	  SETZM	FLATTR		;NO, SO TYPE OUT 8BIT & DISPLAY HERE
TYPT.1:	MOVSI	T7,-DOTTYU	;LOOP OF TTY SETUP TABLE
	SETZB	WD,CHRSOU	;CLEAR NUMBER OF THINGS TYPED
TYPT.2:	MOVE	T1,[2,,T2]	;ARG POINTER
	HLRZ	T2,DOTTYT(T7)	;GET FUNCTION
	CAIGE	T2,1000		;SEE IF READ FUNCTION
	JRST	TYPT.6		;NO--IGNORE IT
	HRRZ	T6,DOTTYT(T7)	;GET STORAGE
	MOVSI	T5,-TYPTTU	;LOOP OVER SPECIAL FORMATTERS
TYPT.3:	HRRZ	T4,TYPTTT(T5)	;GET ITS STORAGE
	CAME	T4,T6		;SEE IF SAME
	AOBJN	T5,TYPT.3	;NO--LOOP
	MOVE	T6,TYPTTW(T5)	;YES OR END--GET NAME
	HLR	T5,TYPTTT(T5)	;GET ADDRESS OF FORMATTER
	JUMPL	T5,TYPT.5	;IF FOUND, GO DO IT
	HRRZ	T6,DOTTYT(T7)	;RESTORE MATCHING VALUE
	MOVSI	T5,-CMDL	;ELSE LOOP OVER COMMAND TABLE
TYPT.4:	HRRZ	T4,CMDP(T5)	;GET ITS STORAGE
	CAME	T4,T6		;SEE IF SAME
	AOBJN	T5,TYPT.4	;NO--LOOP
	JUMPG	T5,TYPT.6	;IGNORE IF NOT IN EITHER TABLE
	MOVE	T6,CMDT(T5)	;GET NAME
	HLRE	T5,CMDP(T5)	;GET FORMAT INDICATOR
	JUMPLE	T5,TYPT.6	;IF SPECIAL ROUTINE, IGNORE
	CAIL	T5,3		;SEE IF 4
	MOVEI	T5,3		;YES--MERGE INTO SEQUENCE
	MOVE	T5,[TYPBON	;1=BIT ON
		    TYPBOF	;2=BIT OFF
		    TYPVAL]-1(T5) ;3/4=DECIMAL VALUE
;HERE WHEN STYLE IDENTIFIED
TYPT.5:	MOVE	T3,TRMNUM	;GET TTY NUMBER
	TRMOP.	T1,		;READ VALUE
	  JRST	TYPT.6		;IGNORE IF ERROR
	PUSHJ	P,(T5)		;FORMAT OUTPUT
	SKIPN	T1,CHRSOU	;GET CHARACTERS TYPED
	JRST	TYPT.6		;NO OUTPUT THIS TIME
	AOS	WD		;NUMBER OF THINGS TYPED
	TLC	T7,-1		;THIS IS TO BUM THE TABS AFTER THE LAST ITEM
	TLCE	T7,-1		;ONLY WORKS BECAUSE "REMOTE" TYPES SOMETHING
	TRNN	WD,3		;DO ONLY 4 PER LINE
	JRST	[TTYSTR CRLFM	;END THIS LINE
		JRST TYPT.6]	;AND GET THE NEXT THING
	CAIGE	T1,^D8		;NUMBER OF CHARACTERS TYPED
	TTYCHR	"	"	;SMALL, NEED 2 TABS
	TTYCHR	"	"	;ALIGN NEXT OUTPUT FIELD
TYPT.6:	SETZM	CHRSOU		;COUNT FRESH
	AOBJN	T7,TYPT.2	;LOOP OVER TRMOP TABLE
	POPJ	P,		;RETURN
SUBTTL	SUBROUTINE TO TYPE TTY ATTRIBUTES

TYPATR:	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOATR	;WORD TO READ
	MOVE	T3,TRMNUM	;TTY TO READ
	TRMOP.	T1,		;TRY FOR IT
	  POPJ	P,		;OLD MONITOR
	MOVEM	T1,TERATR	;REMEMBER VALUES
	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOAT2	;SECOND ATTRIBUTES WORD
	TRMOP.	T1,		;READ IT
	  SETZ	T1,		;SNH
	MOVEM	T1,TERAT2	;SAVE IT
	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TOAT3	;CUSTOMER ATTRIBUTE WORD
	TRMOP.	T1,		;READ IT
	  SETZ	T1,		;SNH
	MOVEM	T1,TERAT3	;SAVE IT
	MOVSI	T7,-ATRNUM	;AOBJN POINTER TO ATTRIBUTE TYPEOUT TABLE
	SETZ	WD,		;CLEAR COLUMN COUNTER
TYPA.1:	SETZM	CHRSOU		;NO CHARACTERS YET THIS FIELD
	HRRZ	T1,ATRTAB(T7)	;GET BYTE POINTER
	LDB	T1,(T1)		;AND VALUE
	HLRZ	T2,ATRTAB(T7)	;GET TEXT POINTER
	CAIGE	T2,TAIMAX	;OFF THE END OF THE PROCESSOR TABLE?
	SKIPA	T3,TATDSP(T2)	;NO, GET ROUTINE FROM TABLE
	MOVEI	T3,TYPA.0	;YES, USE DEFAULT ROUTINE
	PUSHJ	P,(T3)		;FORMAT THE VALUE
	SKIPN	T1,CHRSOU	;GET CHARACTERS TYPED
	JRST	TYPA.2		;NO OUTPUT THIS TIME
	AOS	WD		;NUMBER OF THINGS TYPED
	TLC	T7,-1		;THIS IS TO BUM THE TABS AFTER THE LAST ITEM
	TLCE	T7,-1		; ...
	TRNN	WD,3		;DO ONLY 4 PER LINE
	JRST	[TTYSTR CRLFM	;END THIS LINE
		 JRST TYPA.2]	;AND GET THE NEXT THING
	CAIGE	T1,^D8		;NUMBER OF CHARACTERS TYPED
	TTYCHR	"	"	;SMALL, NEED 2 TABS
	TTYCHR	"	"	;ALIGN NEXT OUTPUT FIELD
TYPA.2:	AOBJN	T7,TYPA.1	;LOOP OVER ATTRIBUTE TABLE
	POPJ	P,		;RETURN

TYPA.0:	SKIPN	T1		;CHECK VALUE
	TTYSTR	[ASCIZ /NO/]	;"NO" FOR VALUE OF ZERO
	TTYSTR	1,(T2)		;TYPE ATTRIBUTE NAME & RETURN


ATRTAB:

TERATA==TERATR	;TO AVOID CONFUSION

DEFINE ATR(TEXT,NAME,NUM<A>),<
 IFNB<TEXT>,<[ASCIZ |TEXT|],,[POINTR TERAT'NUM,T'NUM'.'NAME]>
 IFB<TEXT>,<TAI'NAME,,[POINTR TERAT'NUM,T'NUM'.'NAME]>
>

	ATR	,ACL,2
	ATR	,DCL,2
	ATR	EIGHTBIT,8BT
	ATR	8BITARCH,8BA
	ATR	DISPLAY,DIS
	ATR	OVERSTRIKE,OVR
	ATR	,CLR
	ATR	STATUSLINE,ESL
	ATR	ISO,ISO
	ATR	NRC,NRC
	ATR	DRCS,RCS
	ATR	UDKEYS,UDK
	ATR	AVO,AVO
	ATR	PRINTERPORT,PPO
	ATR	IDCHAR,CID
	ATR	IDLINE,LID
	ATR	REGIS,GPO
	ATR	SIXEL,SXL
	ATR	TEKEMULATION,TEK
	ATR	VT52EMULATION,V52
	ATR	SREGION,SRM
	ATR	HSCROLL,HSR
	ATR	VLENGTH,VFL
	ATR	VWIDTH,VFW
	ATR	USERWINDOWS,UWN
	ATR	,BMT
	ATR	GUARDEDAREA,GAT
	ATR	SELECTERASE,SEM
	ATR	KATAKANA,JTK
	ATR	SESSIONS,SSU
	ATR	DECTCS,TCS
	ATR	INTERROGATION,TSI
	ATR	,LDT,2
	ATR	,NKB

  ATRNUM==.-ATRTAB	;NUMBER OF ATTRIBUTES TO TYPE

TATDSP:			;SPECIAL ATTRIBUTE FORMATTING DISPATCH
	PHASE	0
TAILDT:! TYPLDT
TAIACL:! TYPACL
TAIDCL:! TYPDCL
TAIBMT:! TYPBMT
TAICLR:! TYPCLR
TAINKB:! TYPNKB

TAIMAX:! DEPHASE

TYPLDT:	SKIPN	T1	;DO WE CARE?
	TTYSTR	1,[ASCIZ /NOLOCATOR/] ;NO
	CAIL	T1,LOCDVL	;IN RANGE OF THE TABLE?
	SETZ	T1,		;NO, DEFAULT TO 'UNKNOWN'
	MOVE	T2,LOCDVN(T1)	;FETCH VALUE
	TTYSTR	[ASCIZ /LOCATOR:/] ;INTRODUCTION
	PJRST	TYPSIX		;TYPE IN SIXBIT & RETURN

TYPACL:	TTYSTR	[ASCIZ /ANSLEVEL:/] ;INTRODUCTION
	PJRST	TYPDEC		;TYPE IN DECIMAL & RETURN

TYPDCL:	TTYSTR	[ASCIZ /DECLEVEL:/] ;INTRODUCTION
	PJRST	TYPDEC		;TYPE IN DECIMAL & RETURN

TYPBMT:	MOVEI	T2,[ASCIZ /BLOCKMODE/]	;STRING TO USE
	JUMPE	T1,TYPA.0	;HANDLE NORMALLY IF OFF
	MOVX	T3,TA.BTA	;BLOCK-TRANSFER-ANSI BIT
	TDNN	T3,TERATR	;IS IT?
	PJRST	TYPA.0		;NO, JUST SAY "BLOCKMODE"
	TTYSTR	1,[ASCIZ /BLOCK:ANSI/] ;YES, SAY THIS AND RETURN

TYPCLR:	MOVEI	T2,[ASCIZ /COLOR/] ;TEXT IF 60HZ
	MOVX	T3,%CNSTS	;CNFSTS GETTAB
	GETTAB	T3,		;FETCH FROM THE MONITOR
	  SETZ	T3,		;SNH
	TXNE	T3,ST%CYC	;50HZ?
	MOVEI	T2,[ASCIZ /COLOUR/] ;YES, USE THIS INSTEAD
	PJRST	TYPA.0		;TYPE NORMALLY FROM THIS TEXT

TYPNKB:	TRC	T1,1		;INVERT VALUE
	MOVEI	T2,[ASCIZ /KEYBOARD/] ;TEXT TO USE
	PJRST	TYPA.0		;AND NOW TREAT NORMALLY
TYPTTT:			;TABLE OF SPECIAL FORMATTERS,,VALUE
;	TYPAGA,,PAGEON
;	TYPAGB,,PAGE
	CPOPJ,,PAGEON	;TTY PAGE (OBSOLETE)
	CPOPJ,,PAGE	;TTY PAGE:N (OBSOLETE)
	TYPSSI,,SSIZE	;TTY STOP N (DEFER UNTIL TTY STOP)
	TYPSST,,SSTOP	;TTY SSTOP  (DEFER UNTIL TTY STOP)
	TYPSTP,,STOP	;TTY STOP (ONE OF: NO STOP; STOP:N; SSTOP:N)
	TYPSPD,,RCV
	TYPSPD,,XMT
	TYPTYP,,TYPE
	TYPECL,,LOCALC
	TYPECA,,ECHO
	TYPECB,,ECHDEF
	TYPESC,,ESCAPE
	TYPUNP,,UNPAUSE
	TYPAPC,,APC
	TYPTYP,,CLASS
	TYPTYP,,MODEL
	TYPATB,,ATR8BT
	TYPATB,,ATRDIS
TYPTTU==.-TYPTTT

TYPTTW:			;TABLE OF NAMES OF ABOVE
	SIXBIT	/PAGE/
	SIXBIT	/PAGE/
	SIXBIT	/SSIZE/
	SIXBIT	/SSTOP/
	SIXBIT	/STOP/
	SIXBIT	/RCV/
	SIXBIT	/XMT/
	SIXBIT	/TYPE/
	SIXBIT	/LOCALC/
	SIXBIT	/ECHO/
	SIXBIT	/ECHO/
	SIXBIT	/ESCAPE/
	SIXBIT	/UNPAUS/
	SIXBIT	/APC/
	SIXBIT	/CLASS/
	SIXBIT	/MODEL/
	SIXBIT	/EIGHTB/
	SIXBIT	/DISPLA/
;ROUTINE TO TYPE ECHO:TEXT OR NO ECHO OR JUST ECHO

TYPECL:	MOVEM	T1,LOCALC	;SAVE FOR ECHO:DEFER LOGIC
	POPJ	P,		;WAIT FOR THE NEXT ONE TO DETERMINE
TYPECA:	MOVEM	T1,ECHO		;SAVE FOR ECHO:DEFER LOGIC
	JUMPE	T1,TYPBON	;TYPE NO ECHO IF NOT SET
	POPJ	P,		;ELSE WAIT FOR THE NEXT OONE
TYPECB:	SKIPN	ECHO		;DID WE ALREADY SAY "NO ECHO"
	POPJ	P,		;YES, THAT'S VERBOSE ENOUGH
	JUMPE	T1,TYPEC1	;NO--IS IT DEFERRED?
	SKIPE	LOCALC		;DEFERRED--ALSO LOCALCOPY?
	TTYSTR	1,[ASCIZ/ECHO:LDEFER/] ;YES--OUTPUT THAT AND RETURN
	TTYSTR	1,[ASCIZ/ECHO:DEFER/] ;NO--OUTPUT IT AND RETURN
TYPEC1:	SKIPN	LOCALC		;NOT DEFERRED--IS IT LOCALCOPY?
	JRST	TYPBOF		;NO--JUST TYPE "ECHO"
	TTYSTR	1,[ASCIZ/ECHO:LOCAL/] ;YES--TYPE THAT AND RETURN

;ROUTINE TO TYPE PAGE:N OR NOPAGE

TYPAGA:	MOVEM	T1,PAGEON	;SAVE FOR PAGE:N LOGIC
	JUMPE	T1,TYPBON	;IF NO PAGE, GO TYPE
	POPJ	P,		;ELSE, RETURN
TYPAGB:	SKIPN	PAGEON		;SEE IF NO PAGE
	POPJ	P,		;YES--RETURN
	JUMPE	T1,TYPBOF	;NO--IF PAGE:0 TYPE PAGE
	JRST	TYPVAL		;ELSE, TYPE DECIMAL PAGE

;ROUTINE TO FORMAT SPEED

TYPSPD:	ANDI	T1,17		;PROTECT AGAINST JUNK
	JUMPE	T1,CPOPJ	;IGNORE IF ZERO
	PUSH	P,T1		;SAVE VALUE
	MOVE	T2,T6		;GET NAME
	PUSHJ	P,TYPSIX	;TYPE IN SIXBIT
	TTYSTR	[ASCIZ /SPEED:/]
	POP	P,T1		;RECOVER SPEED INDEX
	MOVE	T2,SPEEDT(T1)	;GET SPEED
	PJRST	TYPSIX		;TYPE IN SIXBIT

;ROUTINE TO TYPE TYPE:XXXXXX

TYPTYP:	PUSH	P,T1		;SAVE THE NAME
	MOVE	T2,T6		;GET WHICH FIELD
	PUSHJ	P,TYPSIX	;TYPE IT OUT
	TTYCHR	":"		;THEN A COLON TO SEPARATE
	POP	P,T2		;GET NAME IN T2
	PJRST	TYPSIX		;TYPE IT OUT

;ROUTINE TO TYPE APC:XXXXXX

TYPAPC:	SKIPN	T2,APCTXT(T1)	;GET POINTER TO APC TYPE NAME
	POPJ	P,		;FORGET ABOUT IT IF NONE
	TTYSTR	[ASCIZ /APC:/]
	TTYSTR	1,(T2)		;TYPE IT OUT AND RETURN

DEFINE YY(NAME,COD),<
	IFN .TO'COD-<.-APCTXT>,<PRINTX ? .TO'COD (NAME) OUT OF ORDER>
	IFNB<NAME>,<	0,,[ASCIZ /NAME/]	>
	IFB<NAME>,<	EXP	0		>
>

APCTXT:	YY		,UNK
	YY	HARDWIRED,HWD
	YY	DATASET	,DSD
	YY	TSN	,TSN
	YY	GANDALF	,GAN
	YY	AUTODIAL,ADL
	YY	MICOM	,MCM
	YY	NRT	,NRT
	YY	LAT	,LAT
	YY	CTERM	,CTM

;HANDLE STOP PARAMETER(S)

TYPSTP:	JUMPE	T1,TYPBNO	;TYPE "NO STOP" IF TTY NO STOP
	SKIPN	SSIZE		;OR IF TTY STOP:0
	JRST	TYPBNO		;THEN "TTY NO STOP"
	SKIPE	SSTOP		;SUPER-STOP SET?
	TTYCHR	"S"		;YES, SO INDICATE
	TTYSTR	[ASCIZ\STOP:\]	;NAME THE FIELD/FUNCTIONALITY
	MOVE	T1,SSIZE	;GET AUTO-STOP SIZE
	PJRST	TYPDEC		;AND LIST DECIMAL LINES

TYPSSI:	MOVEM	T1,SSIZE	;SAVE SSIZE PARAMETER FOR TYPSTP
	POPJ	P,		;BUT OTHERWISE IGNORE

TYPSST:	MOVEM	T1,SSTOP	;SAVE SSTOP PARAMETER FOR TYPSTP
	POPJ	P,		;BUT OTHERWISE IGNORE IT

;ROUTINE TO TYPE CHARACTER VALUES

TYPESC:	CAIN	T1,.CHESC	;REAL ESCAPE?
	JRST	TYPBNO		;YES, SAY "NOESCAPE"
	JRST	TYPCHR		;NO, TYPE THE VALUE

TYPUNP:	CAIN	T1,.CHCNQ	;REAL CONTROL-Q?
	JRST	TYPBNO		;YES, SAY "NOUNPAUSE"

TYPCHR:	PUSH	P,T1		;SAVE VALUE
	MOVE	T2,T6		;GET NAME
	PUSHJ	P,TYPSIX	;TYPE IN SIXBIT
	TTYCHR	":"		;SEPARATE FROM VALUE
	POP	P,T1		;RECOVER SPEED INDEX
	PJRST	TYPOCT		;TYPE THE CHARACTER VALUE IN OCTAL

TYPATB:	MOVE	T2,FLATTR	;TYPE-ATTRIBUTES FLAG
	TRNE	T2,1		;IF ON,
	POPJ	P,		;DON'T BE REDUNDANT
	PJRST	TYPBON		;NO--ADMIT TO THE VALUE HERE
;ROUTINE TO FORMAT DECIMAL

TYPVAL:	PUSH	P,T1		;SAVE VALUE
	MOVE	T2,T6		;GET NAME
	PUSHJ	P,TYPSIX	;TYPE IN SIXBIT
	TTYCHR	":"		;SEPARATE FROM VALUE
	POP	P,T1		;RESTORE VALUE
	PJRST	TYPDEC		;TYPE IN DECIMAL

;ROUTINE TO FORMAT BIT VALUES

TYPBOF:	TRC	T1,1		;VALUE NORMALLY ON SO SWITCH
TYPBON:	TRNN	T1,1		;SEE IF SET
TYPBNO:	TTYSTR	[ASCIZ /NO/]	;NO--INDICATE
	MOVE	T2,T6		;GET NAME
	PJRST	TYPSIX		;TYPE IN SIXBIT
SUBTTL	TTY SETUP PROCESSORS


;NOTE--ALL MUST PRESERVE T1, T3

SUBTTL	TERMINET ROUTINE
;TRMNET -- SETUP TERMINET 300 TABS

TRMNET:	MOVEI	T2,TRMIMG	;GET SPECIAL TEXT TO SEND
	PUSHJ	P,SNDIMG	;SEND TO UNIT
	SETOM	T2		;FLAG FOR THIS UNIT
	GETLCH	T2		;GET LINE CHARACTERISTICS
	TXO	T2,GL.TAB	;SET TABS FLAG
	SETLCH	T2		;SET LINE CHARACTERISTICS
	POPJ	P,		;RETURN
SUBTTL	COMPARE EIGHT BIT ASCII STRINGS (CMPS8)

;SUBROUTINE TO COMPARE TWO EIGHT BITS ASCII STRINGS
;CALL:	MOVEI	T1,<ADDRESS OF FIRST STRING BLOCK>
;	MOVEI	T2,<ADDRESS OF SECOND STRING BLOCK>
;	PUSHJ	P,CMPS8
;	 ERROR RETURN IF STRINGS DON'T MATCH
;	SKIP RETURN IF MATCH
;USES T1, T2

CMPS8:	PUSH	P,T1		;SAVE THE FIRST STRING BLOCK ADDRESS
	PUSH	P,T2		;SAVE THE SECOND STRING BLOCK ADDRESS
	HLRZ	T1,.NSASL(T1)	;GET THE NUMBER OF BYTES IN THE FIRST STRING
	PUSH	P,T1		;SAVE IT
	HLRZ	T1,.NSASL(T2)	;GET THE LENGTH OF THE SECOND STRING
	CAME	T1,(P)		;ARE THEY THE SAME LENGTH?
	JRST	CMPS.3		;NO, RETURN ERROR
	JUMPE	T1,CMPS.2	;IF ZERO LENGTH, ALWAYS WINS
	MOVE	T1,[POINT 8,.NSAST] ;GET THE BYTE POINTER BITS
	ADDM	T1,-2(P)	;AND FIX UP BOTH
	ADDM	T1,-1(P)	; OF THE BLOCK POINTERS
CMPS.1:	ILDB	T1,-2(P)	;GET A BYTE FROM THE FIRST STRING
	CAIL	T1,"a"		;IS IT
	CAILE	T1,"z"		; LOWER CASE?
	CAIL	T1,340		;  OR INTERNATIONALLY
	CAILE	T1,376		;   LOWER CASE?
	SKIPA			;NOPE
	SUBI	T1,"a"-"A"	;YES, CONVERT TO UPPER
	ILDB	T2,-1(P)	;GET A BYTE FROM THE FIRST STRING
	CAIL	T2,"a"		;IS IT
	CAILE	T2,"z"		; LOWER CASE?
	CAIL	T2,340		;  OR INTERNATIONALLY
	CAILE	T2,376		;   LOWER CASE?
	SKIPA			;NOPE
	SUBI	T2,"a"-"A"	;YES, CONVERT TO UPPER
	CAME	T1,T2		;ARE THE TWO CHARACTERS EQUAL?
	JRST	CMPS.3		;NOPE.  THAT'S AN ERROR
	SOSLE	(P)		;YES, ANY MORE CHARACTERS?
	JRST	CMPS.1		;YES, DO ANOTHER ONE THEN
CMPS.2:	AOS	-3(P)		;NO, WE'RE HAPPY THEN
CMPS.3:	POP	P,(P)		;CLEAN ALL
	POP	P,(P)		; THE JUNK
	POP	P,(P)		; OFF THE STACK
	POPJ	P,		;AND RETURN
SUBTTL	INPUT ROUTINES

;SUBROUTINE TO FIND A WORD IN A TABLE
;CALL:	MOVE	WD,WORD IN SIXBIT
;	MOVE	T1,MASK OF WHAT TYPED
;	MOVE	T2,[IOWD LEN,TABLE]
;	PUSHJ	P,FNDWRD
;	ERROR RETURN
;	FOUND WITH T2=INDEX OF RESULT
;USES T3, T4, T5

SUBTTL	TABLE SEARCH ROUTINE
FNDWRD:	MOVE	T3,T2		;SAVE POINTER
	MOVEI	T5,0		;CLEAR ABBREVIATION POINTER
FNDW.1:	MOVE	T4,1(T3)	;GET NEXT TRIAL
	XOR	T4,WD		;COMPARE
	JUMPE	T4,FNDW.3	;GOOD MATCH
	TDNE	T4,T1		;SEE IF OK AS ABBREVIATION
	JRST	FNDW.2		;NOT ABBREVIATION
	SKIPE	T5		;SEE IF ABBREVIATION KNOWN
	SETOM	T5		;YES--SET FLAG
	SKIPN	T5		;SEE IF ANY ABBREVIATION
	HRRZ	T5,T3		;SAVE POINTER
FNDW.2:	AOBJN	T3,FNDW.1	;LOOP OVER LIST
	SKIPG	T3,T5		;RECOVER ABBREVIATION
	POPJ	P,		;ERROR RETURN IF NONE
FNDW.3:	SUBI	T3,(T2)		;GET INDEX
	MOVEI	T2,(T3)		;COPY RESULT
CPOPJ1::AOS	(P)		;SUCCESS
CPOPJ::	POPJ	P,		;RETURN
;SUBROUTINE TO GET A CHARACTER VALUE:  WHICH IS EITHER AN OCTAL CHARACTER
;CODE, A SINGLE CHARACTER ^X FOR CONTROL CHARACTER OR ^^ FOR ^
;RETURNS VALUE IN T1; USES T2
	
GCHVAL:	PUSHJ	P,SKIPTV	;SKIP TO VALUE IF ANY
	CAIN	CH,":"		;SEE IF VALUE
	JRST	GCHVA1		;YES--SETTING NUMBER
	CAIL	CH,"0"		;OR
	CAILE	CH,"7"		; OCTAL
	JRST	GCHVA2		;NO. MUST BE REAL CHARACTER
GCHVA1:	PUSHJ	P,GETOCT	;GET THE OCTAL CHARACTER VALUE
	JRST	CPOPJ1		;OK, RETURN WITH CHAR VALUE
GCHVA2:	PUSHJ	P,GETCHA	;GET THE NEXT CHARACTER
	CAIE	CH," "		;ANY LEADING WHITESPACE?
	CAIN	CH,"	"	; (INCLUDING TABS)?
	JRST	GCHVA2		;YES, SKIP IT
	CAIN	CH,"^"		;DOES IT LOOK LIKE A CONTROL CHARACTER?
	JRST	[MOVE	T1,CH		;NO, GET THE CHARACTER AS GIVEN
		 JRST	CPOPJ1]		;AND GIVE THE SUCCESS RETURN
	PUSHJ	P,GETCHA	;YES, GET THE NEXT CHARACTER
	MOVE	T1,CH		;COPY THE CHARACTER
	CAIN	T1,"^"		;OR DID HE REALLY MEAN CIRCUMFLEX?
	JRST	CPOPJ1		;HE REALLY MEANT ^
	TRNN	T1,100		;IS IT SOMETHING WE CAN MAKE A CONTROL CHAR OUT OF?
	JRST	[MOVX	T1,.CHESC	;NO, JUST ASSUME GOOD OL' ESCAPE
		 POPJ	P,]		;GIVE ERROR RETURN
	ANDI	T1,37		;YES, MAKE IT A CONTROL CHARACTER
	JRST	CPOPJ1		;AND RETURN HAPPY
;SUBROUTINE TO READ A STRING ARGUMENT, DELIMITED BY EITHER FLAVOR OF QUOTE.
;CALLED WITH STRING POINTER IN T1, MAX BYTE COUNT (NOT INCLUDING TERMINATING
;NULL) IN T2.

;DESTROYS T1-T

GSTARG:	PUSHJ	P,SKIPTV	;SKIP TO VALUE IF ANY
	PUSHJ	P,GETCHA	;GET THE FIRST QUOTE
	CAIE	CH,""""		;IS IT A QUOTE
	CAIN	CH,"'"		;  OF EITHER TYPE?
	SKIPA			;YES, GO ON
	POPJ	P,		;NO, RETURN ERROR
	MOVE	T3,CH		;SAVE THE DELIMITER
	JRST	GSTA.2		;SKIP INTO THE LOOP
GSTA.1:	SOSL	T2		;ALLOWED TO STORE THIS ONE?
	IDPB	CH,T1		;YES, STORE IT THEN
GSTA.2:	PUSHJ	P,GETCHA	;GET THE NEXT CHARACTER
	TXNE	F,F.EOF!F.ECMD	;ARE WE AT THE END OF THE LINE?
	POPJ	P,		;YES, THAT'S AN ERROR
	CAME	CH,T3		;IS IT THE DELIMITER AGAIN?
	JRST	GSTA.1		;NO, STORE IT AND TRY ANOTHER
	PUSHJ	P,GETCHA	;GET THE NEXT CHARACTER
	CAMN	CH,T3		;IS IT THE QUOTE AGAIN?
	JRST	GSTA.1		;YES, GO STORE IT
	MOVEM	CH,REEAT	;NO, PUT IT BACK
	SETZ	T2,		;GET A NULL
	IDPB	T2,T1		;TERMINATE THE STRING
	JRST	CPOPJ1		;AND RETURN HAPPY
;SUBROUTINE TO SKIP TO VALUE IF ANY
;SKIPS ONE : OR SEVERAL SPACES/TABS

SUBTTL	SKIP TO VALUE ROUTINE
SKIPTV:	CAIN	CH,":"		;SEE IF :
	POPJ	P,		;YES--OK TO PROCEED
SKTV.1:	CAIE	CH," "		;SEE IF SPACE
	CAIN	CH,"	"	; OR TAB
	JRST	[PUSHJ P,GETCHA	;YES--SKIP ON
		 JRST  SKTV.1]	;AND LOOP
	TXNN	F,F.ECMD	;IF END OF LINE NOT REACHED,
	HRROM	CH,REEAT	;REEAT LAST CHAR
	POPJ	P,		;RETURN

;ROUTINE TO READ A DECIMAL NUMBER
;RETURNS VALUE IN T1; USES T2

SUBTTL	DECIMAL READ ROUTINE
SUBTTL	OCTAL READ ROUTINE
GETOCT:	SKIPA	T2,[10]	; LOAD OCTAL BASE
GETDEC:	MOVEI	T2,^D10	; LOAD DECIMAL BASE
	MOVEI	T1,0		; CLEAR RESULT
GTDC.0:	PUSHJ	P,GETCHA	;GET LEAD CHARACTER
	CAIE	CH," "		;IS IT A SPACE
	CAIN	CH,"	"	; OR A TAB?
	JRST	GTDC.0		;YES, IGNORE IT.
	CAIE	CH,"#"		;SEE IF OCTAL FORCER
	JRST	GTDC.1		;NO--START ACCUMULATION
	MOVEI	T2,10		;YES--CHANGE TO OCTAL RADIX
	PUSHJ	P,GETCHA	;AND REPLACE FIRST CHARACTER
GTDC.1:	CAIL	CH,"0"		;SEE IF
	CAIL	CH,"0"(T2)	; NUMERIC
	JRST	GTDC.2		;NO--MUST BE DONE
	IMULI	T1,(T2)		;YES--ROUND UP
	ADDI	T1,-"0"(CH)	;INCLUDE THIS DIGIT
	PUSHJ	P,GETCHA	;GET NEXT CHARACTER
	JRST	GTDC.1		;LOOP
GTDC.2:	CAIN	CH,"."		;SEE IF DECIMAL SUFFIX
	PUSHJ	P,GETCHA	;YES--SKIP IT
	POPJ	P,		;RETURN VALUE
;SUBROUTINE TO GET AN EIGHT BIT ASCII STRING
;CALLED WITH STRING BLOCK POINTER IN T1, MAX LENGTH IN T2
;DESTROYS T1, T2, CH

SUBTTL	EIGHT BIT ASCII STRING INPUT (GETAS8)
GETAS8:	HRRZ	T2,.NSASL(T1)	;GET THE LENGTH OF THE STRING BLOCK
	SUBI	T2,.NSAST	;ACCOUNT FOR THE COUNT WORDS
	LSH	T2,2		;GET THE MAXIMUM NUMBER OF BYTES
	PUSH	P,[0]		;INIT THE CURRENT BYTE COUNT
	PUSH	P,[POINT 8,.NSAST(T1)] ;SETUP THE OUTPUT BYTE POINTER
	PUSHJ	P,GETCHA	;GET THE FIRST CHARACTER
	TXNE	F,F.ECMD	;END OF STRING ALREADY?
	JRST	GETA85		;YES, EXIT THE LOOP
	PUSH	P,CH		;PUT IT ON THE STACK
	JUMPE	T2,GETA84	;DON'T BOTHER IF NO STORAGE
	CAIE	CH,""""		;IS IT SOME SORT
	CAIN	CH,"'"		;OF QUOTING CHARACTER?
	JRST	GETA81		;YES, START READING THE STRING
	SETZM	(P)		;NO, NO QUOTING THEN
	JRST	GETA82		;ENTER THE LOOP ALREADY IN PROGRESS
GETA81:	PUSHJ	P,GETCHA	;GOT SOME ROOM, GET A CHARACTER
	TXNE	F,F.ECMD	;END OF LINE?
	JRST	GETA84		;YES, QUIT
	SKIPN	(P)		;DOING A QUOTED STRING?
	JRST	GETA82		;NO, CHECK FOR ALPHANUMERIC
	CAME	CH,(P)		;IS IT OUR QUOTE CHARACTER COME BACK?
	JRST	GETA83		;NO, GO ON
	PUSHJ	P,GETCHA	;YES, GET THE NEXT CHARACTER
	TXNE	F,F.ECMD	;END OF LINE?
	JRST	GETA84		;YES, QUIT
	CAME	CH,(P)		;IS IT THE QUOTE CHARACTER AGAIN?
	JRST	GETA84		;NO, END OF STRING
	JRST	GETA83		;YES, GO STORE THE CHARACTER
GETA82:	CAIN	CH,.CHCNV	;CONTROL-V?
	JRST	[PUSHJ	P,GETCHA	;YES, GET THE NEXT CHARACTER
		 JRST	GETA83]		;SEND IT IN ANY CASE
	CAIGE	CH,"0"		;IS IT A DIGIT?
	JRST	GETA84		;DEFINITELY NOT
	CAIG	CH,"9"		;MAYBE ...
	JRST	GETA83		;YEP
	CAIGE	CH,"A"		;HOW ABOUT SOME UPPER CASE?
	JRST	GETA84		;NOPE
	CAIG	CH,"Z"		;MAYBE AGAIN ...
	JRST	GETA83		;YEP
	CAIL	CH,"a"		;LAST CHANCE IS LOWER CASE
	CAILE	CH,"z"		; ...
	JRST	GETA84		;NOPE, END OF STRING
GETA83:	IDPB	CH,-1(P)	;STORE THE CHARACTER
	AOS	-2(P)		;COUNT THE CHARACTER
	SOJG	T2,GETA81	;LOOP FOR ALL OF THEM
GETA84:	SKIPN	(P)		;WERE WE READING A QUOTED STRING?
	TXZA	F,F.QUOT	;NO, SAY WE WEREN'T
	TXO	F,F.QUOT	;YES, REMEMBER THAT
	POP	P,(P)		;GET RID OF THE QUOTE CHARACTER
GETA85:	POP	P,(P)		;GET RID OF THE BYTE POINTER
	POP	P,T2		;GET THE BYTE COUNT
	HRLM	T2,.NSASL(T1)	;STORE THE BYTE COUNT
	POPJ	P,		;AND RETURN
;SUBROUTINES TO CONVERT A SIXBIT NAME TO AN EIGHT BIT ASCII STRING
;EXPECTS SIXBIT WORD IN WD, STRING BLOCK ADDRESS IN T1
;DESTROYS CH

SUBTTL	EIGHT BIT STRING FROM SIXBIT WORD ROUTINE (GET628)
GET628:	PUSH	P,[POINT 6,WD]	;SETUP A POINTER TO THE SIXBIT WORD
	PUSH	P,T1		;SAVE THE STRING BLOCK POINTER
	HRRZ	CH,.NSASL(T1)	;GET THE NUMBER OF WORDS IN THE BLOCK
	SUBI	CH,.NSAST	;ACCOUNT FOR THE HEADER WORDS
	LSH	CH,2		;CONVERT TO A BYTE COUNT
	CAIL	CH,6		;ENOUGH FOR A WHOLE WORD OF SIXBIT?
	MOVEI	CH,6		;YES, LIMIT IT TO SIX CHARACTERS
	PUSH	P,CH		;SAVE THE BYTE COUNT
	MOVE	CH,[POINT 8,.NSAST] ;GET THE BYTE POINTER BITS
	ADDM	CH,-1(P)	;MAKE THE BLOCK POINTER A BYTE POINTER
	HRLZS	T1		;INIT THE BYTE COUNTER, SAVE ADDR IN LH
GET6.1:	SOSGE	(P)		;ANY MORE BYTES TO DO?
	JRST	GET6.2		;NO, EXIT LOOP
	ILDB	CH,-2(P)	;GET THE NEXT BYTE
	JUMPE	CH,GET6.2	;END OF STRING IF ZERO
	ADDI	CH," "-' '	;CONVERT IT TO ASCII
	IDPB	CH,-1(P)	;STORE IT IN THE OUTPUT STRING
	AOJA	T1,GET6.1	;LOOP FOR ALL THE BYTES
GET6.2:	MOVS	T1,T1		;SWAP HALVES OF COUNT WORD
	HLLM	T1,.NSASL(T1)	;STORE THE NEW BYTE COUNT
	POP	P,(P)		;GET RID OF THE BYTE LIMIT
	POP	P,(P)		;GET RID OF THE OUTPUT POINTER
	POP	P,(P)		;GET RID OF THE INPUT POINTER
	POPJ	P,		;AND RETURN
;SUBROUTINE TO GET A SIXBIT NAME FROM A STRING BLOCK
;EXPECTS STRING BLOCK ADDRESS IN T1
;RETURNS SIXBIT NAME IN WD, LEAVES WHATEVER WAS IN CH, MASK IN T1, DESTROYS T2

SUBTTL	SIXBIT NAME FROM STRING BLOCK ROUTINE (GET826)
GET826:	PUSH	P,CH		;SAVE THE OLD TERMINATOR
	MOVEI	T2,.NSAST(T1)	;POINT TO THE EIGHT BIT STRING STORAGE
	HRLI	T2,(POINT 8,)	;MAKE IT A BYTE POINTER
	PUSH	P,T2		;PUT THE BYTE POINTER ON THE STACK
	HLRZ	T1,.NSASL(T1)	;GET THE NUMBER OF BYTES IN THE STRING
	PUSH	P,T1		;SAVE THE BYTE COUNT
	SETZB	T1,WD		;CLEAR RESULTS
	MOVEI	T2,6		;GET MAX NUMBER OF BYTES
GET8.1:	LSH	WD,6		;SHIFT THE RESULT ANOTHER CHARACTER
	LSH	T1,6		;SHIFT THE MASK AS WELL
	SOSGE	(P)		;ANOTHER BYTE COMING?
	SKIPA	CH,[" "]	;NO, FILL WITH A SPACE
	ILDB	CH,-1(P)	;YES, GET IT
	ANDI	CH,177		;FORCIBLY MAKE IT 7 BIT ASCII (WELL ...)
	CAIL	CH,"a"		;IS IT
	CAILE	CH,"z"		; LOWER CASE?
	SKIPA			;NOPE
	SUBI	CH,"a"-"A"	;YES, CONVERT TO UPPER
	IORI	WD,' '-" "(CH)	;STORE THE CHARACTER
	TRNE	WD,77		;DID WE JUST STORE SOMETHING?
	TRO	T1,77		;YES, LITE THE MASK
	SOJG	T2,GET8.1	;LOOP IF MORE BYTES TO DO
	POP	P,(P)		;GET RID OF THE COUNT
	POP	P,(P)		;AND THE BYTE POINTER
	POP	P,CH		;RESTORE THE OLD TERMINATOR
	POPJ	P,		;AND RETURN
SUBTTL	SIXBIT NAME ROUTINE (GETSIX)

;SUBROUTINE TO GET A SIXBIT NAME
;RETURNS SIXBIT NAME IN WD, TERMINATOR IN CH, MASK IN T1

GETSIX:	SETZB	T1,WD		;CLEAR RESULTS
GETSI1:	PUSHJ	P,GETCHA	;GET NEXT CHARACTER
	CAIL	CH,"0"		;SEE IF ALPHANUMERIC
	CAILE	CH,"9"
	CAIL	CH,"A"
	CAILE	CH,"Z"
	CAIL	CH,"a"
	CAILE	CH,"z"
	JRST	GETSI3		;NO--EXIT
	CAIL	CH,"a"		;IF LOWER CASE,
	TRZ	CH,40		;FORCE UPPER
GETSI2:	TLOE	T1,(77B5)	;MASK NEXT CHAR ON
	JRST	GETSI1		;LOOP
	ROT	T1,6		;POSITION MASK
	LSH	WD,6		;POSITION SIXBIT NAME
	IORI	WD,-40(CH)	;INCLUDE NEXT CHAR
	JRST	GETSI1		;LOOP FOR MORE
GETSI3:	CAIE	CH,"	"	;SEE IF TAB OR
	CAIN	CH," "		;BLANK SEPARATOR
	JUMPE	T1,GETSIX	;IF BLANK OR TAB FIELD, SKIP LEADING BLANKS
	JUMPE	T1,CPOPJ	;RETURN IF NULL
GETSI4:	TLNE	T1,(77B5)	;SEE IF LEFT ADJUSTED
	POPJ	P,		;YES--RETURN
	LSH	T1,6
	LSH	WD,6
	JRST	GETSI4
;SUBROUTINE TO CHANGE TTXXX: INTO TTYXXX:
;THIS ALLOWS 2 LETTER GENERIC DEVICE NAMES
;ROUTINE ALSO INSERTS LEADING 0 IN TTY NUMBERS TO SIMPLIFY
;COMPARES

SUBTTL	TTY EXPANSION ROUTINE (XPNTTY)
XPNTTY:	CAMN	WD,[SIXBIT /CTY/]
	MOVE	WD,CTYTTY	; GET TTY NNN FOR CTY
	MOVE	T1,WD		; COPY WORD
	TRNN	WD,777777	;DOES THIS JUST LOOK LIKE
	TLNE	WD,^-'777'	;  A STRING OF DIGITS?
	JRST	XPNT.0		;NO, GO ON
	MOVSS	WD		;YES, PUT THE DIGITS INTO THE RIGHT HALF
	HRLI	WD,'TTY'	;AND FAKE UP A TTY NAME
XPNT.0:	TLC	T1,'TT0'	;TEST TT THEN DIGIT
	TRNN	T1,77		;MUST BE LE 5 CHARS
	TLNE	T1,777770	;AND THAT FORM
	JRST	XPNT.1		;NOT--LEAVE ALONE
	MOVE	T1,WD		;MAKE ANOTHER COPY
	LSHC	T1,-^D24	;IS--SEPARATE GENERIC PART
	LSH	T1,6		;MOVE OVER
	TRO	T1,'Y'		;INCLUDE THE Y
	LSHC	T1,^D18		;REJOIN
	MOVE	WD,T1		;RESTORE TO NORMAL AC
XPNT.1:	TRNN	WD,77		;SEE IF LESS THAN 6 CHARS
	TRNN	WD,-1		;SEE IF GREATER THAN 3
	POPJ	P,		;NO--RETURN
	TRNE	T1,^-'777'	;IS THIS EVEN A NUMERIC NAME?
	POPJ	P,		;NO.  MUST BE LAT STRING
	HRRZ	T1,WD		;YES--GET RIGHT HALF
	TRC	T1,'0  '	;REMOVE DIGIT OFFSET
	TRNE	T1,7700		;SEE IF SECOND DIGIT
	TRC	T1,'0 '		;YES--REMOVE ITS OFFSET
	TRNE	T1,707070	;VERIFY ALL DIGITS
	POPJ	P,		;NO--LEAVE ALONE
	HRRZ	T1,WD		;OK--GET CLEAN COPY
	SKIPA			;ALL DIGITS
	LSH	T1,-6		; ADJUST
	TRNN	T1,77		; DIGITS
	JRST	.-2		; ..
	TRNN	T1,770000	;SEE IF FILL NEEDED
	TRO	T1,'0  '	;YES--FILL WITH 0
	TRNN	T1,7700		;SEE IF MORE FILL
	TRO	T1,'0 '		;YES--AGAIN
	HRR	WD,T1		;RETURN TO ANSWER
	POPJ	P,		;RETURN
SUBTTL	CVTSIX
;SUBROUTINE CVTSIX - CONVERT OCTAL NUMBERS IN THE RANGE
; 0-777 TO LEFT-JUSTIFIED SIXBIT. ON ENTRY T1=BINARY, ON
; RETURN T1=SIXBIT VALUE
; NOTE: THIS SUBROUTINE STRIPS TRAILING ZEROS.
CVTSIX:	TDZ	T1,[-1,,777000] ; CLEAR OUT GARBAGE
	MOVE	T3,[POINT 6,T1]	; PREPARE BYTE POINTER
CVTLOP:	IDIVI	T1,10	; DIVIDE OCTAL
	HRLM	T2,(P)		; STACK REMAINDER
	SKIPE	T1		; QUIT WHEN DONE
	PUSHJ	P,CVTLOP	; ELSE LOOP
	HLRZ	T2,(P)		; UNSTACK
	TRO	T2,20		; SIXBITIZE
	IDPB	T2,T3		; STORE IN LEFT HALF OF T1
	POPJ	P,0

;SUBROUTINE CVTBIN - CONVERT RIGHT HALF OCTAL TO SIXBIT
;CALL	MOVE	WD,ARG
;	PUSHJ	P,CVTBIN
;RETURN	CPOPJ

CVTBIN:	PUSH	P,WD+1
	TDZ	WD,[XWD -1,707070]
	LSHC	WD,-3
	LSH	WD,-3
	LSHC	WD,-3
	LSH	WD,-3
	LSHC	WD,6
	POP	P,WD+1
	POPJ	P,
;SUBROUTINE TO GET NEXT CHARACTER
;RETURNS CHARACTER IN CH

SUBTTL	CHARACTER ROUTINE (GETCHA)
GETCHA:	SKIPE	REEAT		;SEE IF REPEATING CHAR
	JRST	[HRRE  CH,REEAT  ;REPEAT IT
		 SETZM REEAT	;ONLY ONCE
		 POPJ  P,]	;RETURN
	SETOM	CH		;PRESET EOF
	TXNE	F,F.EOF		;SEE IF EOF ALREADY
	POPJ	P,		;YES--RETURN
	MOVEI	CH,.CHLFD	;PRESET EOL
	TXNE	F,F.ECMD	;SEE IF END ALREADY
	POPJ	P,		;RETURN IF SO
	SKIPE	CH,GETCH	;SEE IF INPUT ROUTINE
	PUSHJ	P,(CH)		;YES--GO READ
	  TXOA	F,F.ECMD	;END OF LINE--SET FLAG
	POPJ	P,		;ELSE, RETURN
	MOVEI	CH,0		;CLEAR CH IF END
	POPJ	P,		;RETURN

SUBTTL	SUBROUTINE TO READ FROM COMMAND TTY
;SKIP RETURNS WITH VALUE IN CH
;NON-SKIPS IF END OF LINE (BREAK)

TTYIN:	GETLIN	ME,		;GET CURRENT LINE
	TLNE	ME,-1		;IF DETACHED, ALL DONE
	INCHSL	CH		;GET CHARACTER
	  JRST	TTYI.2		;ALL DONE IF BUFFER EMPTY
	JUMPE	CH,TTYIN	;IGNORE IF NULL
	CAIE	CH,.CHCRT	;ALSO IF C.RET.
	CAIN	CH,.CHDEL	; OR NULL
	JRST	TTYIN		; IGNORE
	CAIE	CH,"!"		;SEE IF COMMENT
	CAIN	CH,";"		; OR OTHER FORM
	JRST	TTYIND		;YES--GO DISCARD LINE
TTYI.1:	CAIE	CH,.CHBEL	;IF BELL
	CAIN	CH,.CHESC	; OR ESCAPE,
	JRST	TTYI.2		;IT IS ALL DONE
	CAIL	CH,.CHLFD	;IF LESS THAN LINE FEED
	CAILE	CH,.CHFFD	; OR GREATER THAN FORM FEED
	JRST	CPOPJ1		; THEN OK
TTYI.2:	TXZ	F,F.RTTY	;INDICATE SUCCESSFUL REEATING
	POPJ	P,		;ELSE, ALL DONE
TTYIND:	INCHSL	CH		;GET CHARACTER TO DISCARD
	  JRST	TTYI.2		;RETURN IF DONE
	PUSHJ	P,TTYI.1	;ANALYZE RESULT
	  POPJ	P,		;RETURN IF EOL
	JRST	TTYIND		;LOOP UNTIL DONE
SUBTTL	COMMAND LINE PROCESSOR
; SUBROUTINE TO INPUT FROM FILE DISCARDING
; COMMENTS AND HANDLING CONTINUATIONS

FILINC:	SKIPE	CH,FILICH	;SEE IF LEFT OVER CHARACTER
	JRST	FILI.1		;YES--REUSE IT
	PUSHJ	P,FILI.3	;NO--GET NEXT FROM FILE
	  POPJ	P,		;AT END, RETURN
FILI.1:	SETZM	FILICH		;CLEAR LEFT OVERS
	CAIE	CH,"-"		;SEE IF CONTINUATION
	JRST	CPOPJ1		;NO--GOOD RETURN
FILI.2:	PUSHJ	P,FILI.3	;YES--SKIP ON
	  JRST	FILINC		;IF END, GET CONTINUATION
	CAIE	CH,"	"	;IGNORE TRAILING
	CAIN	CH," "		; SPACES AND TABS
	JRST	FILI.2		;LOOP
	MOVEM	CH,FILICH	;NOT EOL, MUST BE REAL -
	MOVEI	CH,"-"		;RETURN IT
	JRST	CPOPJ1		;SAVING NEXT CHAR FOR LATER ON

;SUBROUTINE TO STRIP COMMENTS

FILI.3:	PUSHJ	P,FILIN		;GET NEXT CHAR
	  POPJ	P,		;IF EOL, INDICATE THAT
	CAIE	CH,"!"		;ELSE SEE IF COMMENT
	CAIN	CH,";"		; OR OLD FORM
	SKIPA			;YES
	JRST	CPOPJ1		;NO--GOOD RETURN
FILI.4:	PUSHJ	P,FILIN		;SKIP REST OF LINE
	  POPJ	P,		;GIVE EOL RETURN
	JRST	FILI.4		;LOOP

SUBTTL	SUBROUTINE TO TYPE CONTENTS OF FILE

TYPFIL:	TXO	F,F.TSOL	;INDICATE NOT AT START OF LINE
	TXZ	F,F.ECMD!F.EOF	;INDICATE NOT AT EOF
TYPF.1:	PUSHJ	P,FILIN		;GET NEXT CHARACTER
	  JUMPL	CH,TYPF.2	;RETURN AT EOF
	CAIN	CH,.CHLFD	;IF LINE FEED,
	TXZA	F,F.TSOL	;AT EOL, CLEAR LINE FULL FLAG
	TXOA	F,F.TSOL	;NOT EOL, INDICATE SOMETHING TYPED
	TTYCHR	.CHCRT		; OUTPUT C.RET.
	TTYCHR	(CH)		;OUTPUT CHARACTER
	JRST	TYPF.1		;LOOP UNTIL DONE

TYPF.2:	TXZE	F,F.TSOL	;SEE IF ANYTHING ON THIS LINE
	TTYSTR	CRLFM
	POPJ	P,		;NOW RETURN
;SUBROUTINE TO LOOKUP A FILE (MAYBE IN HISEG)
;CALL WITH:
;	T1 THRU T4 SET TO 4-WORD LOOKUP BLOCK
;	T5 THRU T7 SET TO OPEN BLOCK
;	PUSHJ	P,HILOOK
;	  RETURN HERE IF FILE NOT FOUND
;	RETURN HERE IF FILE EXISTS (LOWPTR SET TO BYTE PTR OR 0)
HILOOK:	OPEN	TI,T5		;OPEN THE FILE
	  POPJ	P,		;FILE NOT FOUND
	TXNN	F,F.ANSW	;IS THIS A FORCED COMMAND?
	JRST	HILK.7		;NO--DO THE SLOW THING
	PUSH	P,T4		;SAVE THE PPN FOR A SPELL
	LOOKUP	TI,T1		;GO FIND THE FILE
	  SETO	T3,		;NOT THERE? MAKE AN UNLIKELY DATE WORD
	TRZ	T2,-1		;IN ANY CASE, CLEAR THE ACCESS DATE JUNK
	POP	P,T4		;AND RESTORE THE PPN WORD
	PUSHJ	P,HIFIND	;IS THIS IN THE HISEG TABLES?
	  JRST	HILK.2		;NO--GO MEMORIZE THE FILE
HILK.1:	SKIPN	T1,HS$PTR(I)	;DOES THE FILE EXIST?
	POPJ	P,0		;NO--GIVE NON-SKIP RETURN
	MOVEM	T1,LOWPTR	;REMEMBER BYTE POINTER TO STRING
	JRST	CPOPJ1		;GIVE GOOD RETURN
;HERE TO REMEMBER A FILE
HILK.2:	PUSHJ	P,HILOCK	;INTERLOCK THE HISEG
	  JRST	HILK.7		;GIVE UP IF CAN'T LOCK
	PUSHJ	P,HIFIND	;GO FIND THE FILE IN THE HISEG TABLE
				; ON THE CHANCE THAT IT SNUCK IT.
	  SKIPA			;NO--THAT IS WHAT I THOUGHT
	JRST	HILK.1		;YES--IT HAS SNUCK IT
	MOVE	I,JOBN		;GET OUR JOB NUMBER
	CAME	I,LOKJOB	;DO WE OWN THE INTERLOCK
	AOS	ITLCNT		;NO, COUNT IT BUT TRY TO CONTINUE
	MOVSI	I,-N$HSGF	;MAKE AN AOBJN POINTER
HILK.3:	SKIPE	HS$DEV(I)	;IS THIS SLOT FREE?
	AOBJN	I,.-1		;NO--KEEP LOOKING
	JUMPGE	I,HILK.7	;TABLE FULL?
	PUSH	P,T6		;REMEMBER DEVICE, BUT NOT SO THAT HIFIND
				;FINDS IT BEFORE FILE ACTUALLY GETS IN
				;(PUT IT IN HS$DEV(I) ON COMPLETION)
	SETOM	HS$DEV(I)	;RESERVE THIS SLOT
	SETZM	HS$PTR(I)	;ZERO POINTER
	SETOM	HS$DAT(I)	;ASSUME THE FILE'S NOT THERE
	MOVEM	T1,HS$FIL(I)	;REMEMBER FILE NAME
	MOVEM	T2,HS$EXT(I)	;REMEMBER EXTENSION
	MOVEM	T4,HS$PPN(I)	;REMEMBER PPN
	LOOKUP	TI,T1		;FIND THE FILE
	  JRST	HILK.8		;FILE NOT FOUND
	MOVEM	T3,HS$DAT(I)	;REMEMBER THE FILE'S CREATION DATE/TIME
;HERE TO COPY FILE INTO THE HISEG
	HLRZ	T2,.JBHRL	;FIND WHERE IN HIGH SEGMENT
	TRO	T2,400000	;PUT IN HIGH-SEG BIT
	MOVE	T1,HIPTR	;GET POINTER TO STRING
	TRNN	T1,-1		;IF NOT SET...
	HRRI	T1,1(T2)	;...GET FIRST FREE IN HIGH SEG
	MOVEM	T1,HIPTR	;INITIALIZE IT
	MOVEM	T1,HS$PTR(I)	;REMEMBER FOR THE FUTURE
	TXZ	F,F.ECMD!F.EOF	;FLAG NOT AT EOF
HILK.4:	HRRZ	T1,HIPTR	;GET POINTER TO STRING
	ADDI	T1,10		;AVOID USUAL END EFFECTS
	HRRZ	T2,.JBHRL	;GET SIZE OF HISEG
	CAMG	T1,T2		;WILL WE NEED MORE CORE
	JRST	HILK.5		;NO--KEEP GOING
	HRLZ	T1,T1		;DO A CORE UUO FOR HISEG
	CORE	T1,		; ..
	  JRST	[AOS	CORCNT	;COUNT THE FAILURE FOR DEBUGGING
		 SETZM HS$DEV(I);FORGET THE FILE
		 SETZM HS$PTR(I);AND THE POINTER
		 POP	P,T6
		 SETZM	LOWPTR	;FILE NOT FOUND
		 JRST	CPOPJ1]	;BUT STILL SET UP
HILK.5:	PUSHJ	P,FILIN		;GET A BYTE
	  JUMPL	CH,HILK.6	;EOF?
	IDPB	CH,HIPTR	;STORE THE BYTE IN THE HISEG
	JRST	HILK.4		;KEEP LOOKING
HILK.6:	SETZM	CH		;FLAG END OF FILE
	IDPB	CH,HIPTR	; ..
	IDPB	CH,HIPTR	; ..
HILK.8:	POP	P,HS$DEV(I)	;NOW, REMEMBER DEVICE IN TABLE
	JRST	HILK.1		;RETURN TO STORE POINTERS

;HERE IF USER IS LOGGED IN -- JUST DO THE LOOKUPS
HILK.7:	SETZM	LOWPTR		;MAKE SURE WE READ FILE
	LOOKUP	TI,T1		;LOOK FOR THE FILE
	  POPJ	P,0		;FILE NOT FOUND
	JRST	CPOPJ1		;FILE SETUP
;SUBROUTINE TO FIND A FILE IN HISEG TBALES
;CALL WITH:
;	T1 = FILE NAME
;	T2 = EXTENSION
;	T3 = DATE/TIME/PROTECTION/MODE WORD
;	T4 = PPN
;	T6 = DEVICE
;	PUSHJ	P,HIFIND
;	  HERE IF NOT IN TABLE
;	HERE IF IN TABLE (INDEX IN I)
HIFIND:	MOVSI	I,-N$HSGF	;AOBJN PTR
HFND.1:	CAME	T6,HS$DEV(I)	;RIGHT DEVICE
	JRST	HFND.2		;NO.
	CAME	T1,HS$FIL(I)	;RIGHT FILE
	JRST	HFND.2		;NO.
	CAME	T2,HS$EXT(I)	;RIGHT EXTENSION
	JRST	HFND.2		;NO
	CAME	T4,HS$PPN(I)	;RIGHT PPN
	JRST	HFND.2		;NO
	CAMN	T3,HS$DAT(I)	;RIGHT DATE/TIME
	JRST	CPOPJ1		;YES--WE WON
	MOVE	T3,JOBN		;NO, THE FILE MUST HAVE CHANGED
	CAMN	T3,LOKJOB	;DO WE ALREADY OWN THE INTERLOCK?
	JRST	HFND.3		;YES, DON'T TRY TO GET IT AGAIN THEN
	PUSHJ	P,HILOCK	;NO, GET THE INTERLOCK THEN
	  POPJ	P,		;OH, BUGGER IT!  IT AIN'T THERE.
HFND.3:	SETZB	T3,HS$DEV(I)	;FORGET THAT WE EVER SAW IT
	EXCH	T3,HS$PTR(I)	;GET AND ZERO THE MEMORY POINTER
	MOVE	T8,T3		;SAVE IT INCASE IT'S THE END OF MEMORY

;PERFORM A RATHER TEDIOUS LOOP TO SEE IF THIS IS THE LAST FILE IN MEMORY.

	ILDB	CH,T3		;GET A CHARACTER
	JUMPN	CH,.-1		;LOOP IF THERE'S MORE GETTING TO BE HAD
	ILDB	CH,T3		;SEEM TO REMEMBER THAT FILES END WITH 2 NULLS
	JUMPN	CH,.-3		; ...
	CAMN	T3,HIPTR	;ARE WE AT THE END OF MEMORY?
	MOVEM	T8,HIPTR	;YES, RECLAIM THE SPACE
	POPJ	P,		;AND SAY IT ISN'T HERE
HFND.2:	AOBJN	I,HFND.1	;LOOP OVER WHOLE TABLE
	POPJ	P,0		;NOT THERE
;SUBROUTINE TO INTERLOCK THE HISEG
;CALL WITH:
;	PUSHJ	P,HILOCK
;	  ERROR RETURN IF CAN'T GET HISEG
;	RETURN HERE
;NOTE: HISEG IS RELEASED ON POPJ
;
HILOCK:	MOVE	T8,[[XWD 4,INTLOC
		    XWD 0,ER.ICC!ER.OFL
		    0
		    0],,INTBLK]
	BLT	T8,INTBLK+3
	MOVEI	T8,INTBLK	; POINT TO TRAP BLOCK
	MOVEM	T8,.JBINT	; SET FOR TRAPPING!
TR.SET:	MOVEI	T8,0		;CLEAR USER WRITE PROTECT
	SETUWP	T8,		; ..
	  JRST	[SETZM NOINT
		POPJ	P,0]
	SETOM	NOINT		; NOT INTERRUPTABLE
	AOSN	LOCKWD		;GET THE INTERLOCK
	JRST	HLCK.2		;IF THE RESULT IS ZERO WE WON
	SETZM	NOINT		;DIDN'T GET INTERLOCK, MAKE
				; INTERRUPTABLE AGAIN
HLCK.1:	MOVE	T8,MYBIT	;BIT SAYING WE ARE WAITING FOR THE INTERLOCK
	IORM	T8,@MYWRD	;LIGHT FOR OWNER TO SEE
	MOVEI	T8,^D15000	;SLEEP FOR 15 SECONDS
	HIBER	T8,		;
	JRST	[MOVEI	T8,10	;SLEEP 8 SECONDS
		 SLEEP	T8,	;SLEEP IF HIBER NOT IMPLEMENTED
		 JRST	.+1]	;CONTINUE
	MOVE	T8,MYBIT	;GET BIT AGAIN
	ANDCAM	T8,@MYWRD	;NOT ACTUALLY WAITING ANYMORE
	PUSHJ	P,HIFIND	;SEE IF THE FILE IS IN CORE YET
	  CAIA			;NO, MUST WAIT FOR IT
	JRST	UNLK.4		;RETURN WITHOUT INTERLOCK
	SETOM	NOINT		;LOCK OUT INTS.
	AOSN	LOCKWD		;OPEN YET??
	 JRST	HLCK.2		;YES. PROCEED
	SETZM	NOINT		;STILL LOCKED. BETTER INVESTIGATE THIS...
HLCK.5:	PUSH	P,LOKJOB	;SAVE A COPY FOR CHECKING
	PUSH	P,LOKTTY	;GET HIM TOO
	HRLZ	T8,-1(P)	;POINT TO INTERLOCKER'S JBTSTS
	GETTAB	T8,		;GET IT
	  JRST	FORCE		;??? FORCE THE LOCK
	TLC	T8,440000	;RUN+JNA
	TLCE	T8,440000	;BOTH ON?
	  JRST	FORCE		;NO, SOMETHING WRONG
	HRLZ	T8,-1(P)	;SET UP JOB # AGAIN
	HRRI	T8,.GTPRG	;LOOK FOR PROGRAM NAME
	GETTAB	T8,		;GET IT
	  JRST	FORCE		;TOO BAD
	CAME	T8,['INITIA']	;RIGHT GUY?
	  JRST	FORCE		;NO, TOO BAD
	MOVE	T8,(P)		;GET OWNER'S TTY UDX
	DEVTYP	T8,		;LOOK AT TTY'S PROPERTIES
	  JRST	FORCE		;TOO BAD
	LDB	T8,[POINTR(T8,TY.JOB)]	;GET JOB # USING IT
	CAME	T8,-1(P)	;RIGHT GUY?
	 JRST	FORCE		;NO, GOT HIM!!
	SUB	P,[2,,2]	;RESTORE THE PDL
	JRST	HLCK.1		;GOOD LOCK, RETURN
HLCK.2:	POP	P,T8		;GET RETURN PC
	PUSH	P,JOBN		;GET OUR JOB #
	POP	P,LOKJOB	;STORE FOR OTHERS
	PUSH	P,TERNUM	;AND OUR LINE
	POP	P,LOKTTY	;SAVE IT AWAY
	PUSHJ	P,1(T8)		;SKIP CALL COROUTINE
UNLOCK:	  SOS	(P)		;INDICATE FAILURE
	MOVE	T8,JOBN		;GET OUR JOB NUMBER
	CAME	T8,LOKJOB	;WE OWN THE INTERLOCK?
	JRST	UNLK.4		;NO
	MOVE	T8,TERNUM	;GET OUR TTY NUMBER
	CAME	T8,LOKTTY	;WE OWN IT?
	JRST	UNLK.4		;NO
	SETZM	LOKJOB		;CLEAR OWNER
	SETZM	LOKTTY		;AND OWNER'S TTY
	SETOM	LOCKWD		;RESET INTERLOCK
	PUSH	P,T1		;SAVE A FEW ACS
	PUSH	P,T2		;...
	PUSH	P,T3		;...
	MOVSI	T1,-JBWATL	;NUMBER OFF ENTRIES IN JOBWAT TABLE
	SKIPN	T2,JOBWAT(T1)	;ANYBODY WAITING HERE
	AOBJN	T1,.-1		;NO, LOOK SOME MORE
	JUMPGE	T1,UNLK.1	;NOBODY WAITING FOR THE INTERLOCK
	JFFO	T2,.+1		;GET WAITERS BIT
	MOVEI	T2,(T1)		;GET THE WORD NUMBER
	IMULI	T2,^D36		;TO A JOB NUMBER
	ADDI	T2,(T3)		;...
	WAKE	T2,		;WAKE UP THE JOB
	  JFCL			;OH WELL
	MOVSI	T2,(1B0)	;FIGURE OUT THE BIT TO CLEAR
	MOVNS	T3		;...
	LSH	T2,(T3)		;POSITION IT
	ANDCAM	T2,JOBWAT(T1)	;SO OTHER INITIAS DONT TRIP OVER A STALE JOB
UNLK.1:	POP	P,T3		;RESTORE
	POP	P,T2		;...
	POP	P,T1		;...
UNLK.4:	MOVEI	T8,1		;GO AND WRITE PROTECT
	SETUWP	T8,		; THE HISEGMENT AGAIN
	  JFCL
	SETZM	.JBINT		; TURN OFF TRAPPING
	SETZM	NOINT		; CLEAR NO INTERRUPT WORD
	JRST	CPOPJ1		;GIVE SKIP RETURN

;HERE TO FORCE THE LOCK
FORCE:	AOS	FRCTRY		;COUNT ATTEMPTS TO FORCE THE LOCK
	MOVE	T8,LOKJOB	;GET CURRENT OWNER OF LOCK
	CAME	T8,-1(P)	;SAME AS WE CHECKED?
	JRST	FORCE1		;NO
	MOVE	T8,LOKTTY	;GET TTY OF OWNER
	CAME	T8,0(P)		;SAME AS WE CHECKED?
	JRST	FORCE1		;NO
	SETZM	LOKJOB		;NO OWNER
	SETZM	LOKTTY		;  OR TTY
	SETOM	LOCKWD		;GIVE UP INTERLOCK
	AOS	FRCCNT		;COUNT NUMBER OF ACTUAL FORCES
	SUB	P,[2,,2]	;RESTORE PDL
	JRST	HLCK.1		;RE-JOIN THE COMPETITION
FORCE1:	SUB	P,[2,,2]	;RESTORE THE PDL
	JRST	HLCK.5		;CHECK AGAIN
; HERE TO PROCESS CONTROL-C INTERCEPT
INTLOC:	MOVEM	T1,TEMP1	; SAVE T1
	HLRZ	T1,INTBLK+3	; GET REASON FOR INTERRUPT
	CAIN	T1,ER.OFL	; DSK OFF LINE?
	JRST	OFLPRC		; YES, GO PROCESS IT
	CAIE	T1,ER.ICC	; NO, CONTROL-C INTERRUPT?
	HALT			; NO, MY GOD!
	SKIPL	NOINT		; INTERRUPTABLE?
	EXIT		; YES, SO QUIT IF THAT'S WHAT HE WANTS
	OUTSTR	[ASCIZ /
Interlocked/]
OFLENT:	EXCH	T1,TEMP1	; RESTORE T1
	PUSH	P,INTBLK+2	; SETUP FOR POPJ RETURN
	SETZM	INTBLK+2	; SET FOR ANOTHER TRAP
BADTRP:	POPJ	P,0		; RETURN TO SEQUENCE
; HERE ON DSK OFF LINE INTERRUPTS
OFLPRC:	MOVEI	T1,STRUCO	; GET DESIRED RETURN ADDRESS
	MOVEM	T1,INTBLK+2	; AND FUDGE IT
	JRST	OFLENT		; GO DO THE STANDARD STUFF
SUBTTL	SUBROUTINE TO READ FROM FILE
;SKIP RETURNS WITH VALUE IN CH
;NON-SKIPS IF END OF LINE (CH=-1 AT EOF)

FILIN:	TXNE	F,F.EOF		;SEE IF EOF
	JRST	FLIN.3		;YES--REPEAT THAT
	ILDB	CH,LOWPTR	;GET A BYTE FROM HISEG
	JUMPN	CH,FLIN.1	;JUMP IF VALID DATA
	SKIPE	LOWPTR		;SKIP IF WE NEVER SETUP HISEG
	JRST	FLIN.3		;ELSE THIS IS THE EOF MARK
	SOSGE	IBF+.BFCTR	;COUNT DOWN BYTES
	JRST	FLIN.2		;EMPTY--GET NEXT BUFFER
	IBP	IBF+.BFPTR	;INCREMENT TO NEXT BYTE
REPEAT 0,<			;NO LONGER USED NOW THAT WE DON'T READ AUXACC.SYS
	TXNE	F,F.BIN		;SEE IF BINARY FILE
	JRST	[LDB  CH,IBF+.BFPTR
		 JRST CPOPJ1]	;IF SO, RETURN WORD
>	;END REPEAT 0
	MOVE	CH,@IBF+.BFPTR	;GET NEXT WORD
	TRNE	CH,1		;SEE IF SEQUENCED
	JRST	[AOS IBF+.BFPTR	;YES--SKIP 5
		 MOVNI CH,5	; MORE CHARS
		 ADDM CH,IBF+.BFCTR
		 JRST FILIN]	;AND TRY AGAIN
	LDB	CH,IBF+.BFPTR	;GET CHARACTER
	JUMPE	CH,FILIN	;IGNORE NULLS
	CAIE	CH,.CHCRT	;ALSO C.RET.
	CAIN	CH,.CHDEL	; AND DELETE
	JRST	FILIN		;--JUST LOOP FOR NEXT
FLIN.1:	CAIL	CH,.CHLFD	;IF LESS THAN LINE FEED
	CAILE	CH,.CHFFD	; OR GT FORM FEED,
	JRST	CPOPJ1		; GIVE SKIP RETURN
	POPJ	P,		;ELSE, GIVE END OF LINE

FLIN.2:	IN	TI,		;INPUT NEXT BUFFER
	  JRST	FILIN		;LOOP IF OK
	STATZ	TI,IO.ERR	;SEE IF ERROR BITS
	INTERR	(IOE,<I/O Error>,<JRST FLIN.3>)
FLIN.3:	SETOM	CH		;SET FLAG
	TXO	F,F.EOF		;SET END FLAG
	POPJ	P,		;RETURN
SUBTTL	SUBROUTINES
SUBTTL	SUBROUTINE TO LOGIN A JOB
;CALL:	T2/ PROJECT,,PROGRAMMER NUMBER
;	T4/ "USER" NAME IN SIXBIT
;	PUSHJ	P,LOGIN$
;RETURNS IF SUCCESSFUL

LOGI12:	TXO	F,F.PRIV	;FLAG TO GET ALL PRIVILEGES
	MOVE	T2,FFAPPN	;GET [1,2]
	TXNN	F,F.REMO	;SEE IF REMOTE OPR
	JRST	LOGI.1		;NO--PROCEED
	HLRZ	T1,NL.ME	;YES--GET STATION NUMBER
	HRLI	T2,100(T1)	;USE [100+SN,2]
	JRST	LOGIN$		;AND GO LOGIN
;HERE IF LOGIN TO [1,2]
LOGI.1:	TXNE	F,F.LOGI	;SEE IF LOGGED IN
	JRST	LOGIN$		;YES--NO SPECIAL TEST
	SETOM	T3		;NO--GET MY TTY
	GETLCH	T3		; CHARACTERISTICS
	TXNE	T3,GL.ITY!GL.DSL!GL.REM ;MAKE SURE LOCAL
	JRST	KILJOB		;NO--GO EXIT INSTEAD
LOGIN$:	TXNN	F,F.LOGI	;SEE IF ALREADY LOGGED IN
	JRST	LOGI.2		;NO--GO LOG IT IN
	TXNN	F,F.LOGX	;SEE IF OK TO BE DIFFERENT
	CAMN	T2,MYPPN	;NO--SEE IF DIFFERENT
	POPJ	P,		;NO--RETURN
	JRST	KILJOB		;YES--GO EXIT INSTEAD
LOGI.2:	MOVSI	T1,.STOPP	;CODE TO SET (NO) OPERATOR PRIVS
	HRRI	T1,.OBNOP	;SET NO OPERATOR PRIVS BY DEFAULT
	TXNE	F,F.PRIV	;NEED PRIVS?
	HRRI	T1,.OBSOP	;YES, MAKE THIS JOB A SYSTEM OPR
	TXNE	F,F.REMO	;ARE WE BECOMING A REMOTE OPR?
	HRRI	T1,.OBROP	;YES, ONLY GIVE REMOTE OPR PRIVS
	SETUUO	T1,		;GIVE THE APPROPRIATE PRIV
	 JFCL			;OH WELL, WE TRIED!
	PUSHJ	P,ACCT$		;GO SET THE ACCOUNT STRING
	 JRST	[SKIPN	ACTSTR		;ERROR. DO WE EVEN HAVE A STRING?
		 INTWRN	(NAS,<No account string specified in TTY.INI
>,<JRST .+1>)
		 INTWRN	(ESA,<Error setting account string
>,<JRST .+1>)]
	MOVE	T1,[.STUVM,,[^D16384,,^D16384]] ;SET THE PHYSICAL AND VIRTUAL
	SETUUO	T1,		;  PAGE LIMITS FOR THIS JOB
	  SKIPA	T1,[.STUVM,,[^D512,,^D512]] ;FAILED?  TRY LOWER LIMITS
	SKIPA			;OK, GO ON
	SETUUO	T1,		;TRY TO SET THE LOWER LIMITS
	 JFCL			;NOT REALLY THAT IMPORTANT I GUESS
	MOVE	T1,[-3,,T2]	;SETUP POINTER FOR UUO
	MOVX	T3,%CNPRV	;FIND OUT WHAT PRIVILEGES
	GETTAB	T3,		;  WE'RE ALLOWED TO SET
	 MOVSI	T3,-1		;ERROR--SET ALL DEC PRIVILEGES.
	TXNN	F,F.PRIV	;SEE IF PRIVILEGES NEEDED
	SETZ	T3		;NO--CLEAR THEM
	TXNE	F,F.REMO	;UNLESS REMOTE OPR
	MOVE	T3,[JP.NSP]	;WHO ONLY NEEDS UNSPOOLING
	MOVEM	T2,REQPPN	;SAVE REQUESTED PPN
	LOGIN	T1,		;TRY

	TXNN	F,F.IPCQ	;DO WE WANT BIG IPCF QUOTAS?
	JRST	LOGI.3		;NO, DON'T SET THEM THEN.
	MOVE	T1,JOBN		;GET OUR JOB NUMBER
	MOVEM	T1,IPCCBK+.IPCS1 ;STORE IN THE [SYSTEM]IPCC BLOCK
	MOVX	T1,IP.CMP!<.IPCCC,,.IPCMP+1> ;GET THE HEADER WORD
	MOVEM	T1,IPCMHD+.IPCMF ;STORE AS THE IPCFM FUNCTION HEADER
	XMOVEI	T1,IPCCBK	;GET THE ADDRESS OF THE IPCC BLOCK
	MOVEM	T1,IPCMHD+.IPCMP ;STORE
	MOVE	T1,[3,,.IPCQS]	;GET THE LENGTH AND FUNCTION
	MOVEM	T1,IPCCBK+.IPCS0 ;TO SET THE PID QUOTA
	MOVEI	T1,777		;GET A LARGE PID QUOTA
	MOVEM	T1,IPCCBK+.IPCS2 ;STORE
	XMOVEI	T1,IPCMHD	;POINT TO THE HEADER
	IPCFM.	T1,		;SET THE PID QUOTA
	 JRST	LOGI.3		;ERROR?  SKIP IT
	HLLOS	IPCCBK+.IPCS2	;SET LARGE SEND AND RECEIVE QUOTAS
	MOVEI	T1,.IPCSQ	;GET THE FUNCTION TO SET SEND/RCV QUOTAS
	HRRM	T1,IPCCBK+.IPCS0 ;STORE IT
	XMOVEI	T1,IPCMHD	;POINT TO THE HEADER AGAIN
	IPCFM.	T1,		;SET THE SEND/RECEIVE QUOTAS
	 JFCL			;OH WELL ...

LOGI.3:	TTYSTR	[ASCIZ /.LOGIN /]
	HLRZ	T1,REQPPN	;GET PROJECT
	PUSHJ	P,TYPOCT	;TYPE IN OCTAL
	TTYCHR	","		;SEPARATE
	HRRZ	T1,REQPPN	;GET PROGRAMMER
	PUSHJ	P,TYPOCT	;TYPE IN OCTAL
	TTYSTR	CRLFM
;HERE TO LOCATE USER TO NODE SPECIFIED IN /LOCATE:NN OR
;IN THE ABSENCE OF A LOCATE COMMAND, TO THE CENTRAL SITE
;IF HE IS BEING LOGGED IN ON A NODE WITHOUT AN LPT

LOCAT$:	SKIPGE	T1,LOCAT	;DID USER SPECIFY LOCATE?
	 JRST	LOCAT0		;YES--LOCATE HIM THERE
LOCAT2:	MOVEI T1,.GTLOC		;GETTAB FOR NODE # OF CENTRAL SITE
	GETTAB	T1,		;GET CENTRAL SITE NODE NUMBER
	  JRST	NOLOC		;MONITOR MUST NOT SUPPORT NETWORKS
	HRROI	T2,.GTLOC	;THIS JOB'S LOCATION
	GETTAB	T2,		;GET THAT
	  JRST	NOLOC		;NO NETWORK SOFTWARE
	CAMN	T1,T2		;ALREADY LOCATED AT CENTRAL SITE?
	JRST	NOLOC		;YES, NO POTENTIAL PROBLEMS THEN
	MOVEM	T2,NODLOC	;STORE THIS JOB'S LOCATION IN NODE BLOCK
	MOVEI	T2,4		;LENGTH OF THE ARGUMENT BLOCK
	MOVEM	T2,NODLEN	;STORE IN NODE UUO ARGUMENT BLOCK
	MOVEI	T2,.TYLPT	;DEVICE TYPE
	MOVEM	T2,NODDEV	;STORE THAT IN THE ARGUMENT BLOCK
	MOVE	T2,[.NDRCI,,NODBLK]  ;NODE UUO ARGUMENT
	NODE.	T2,		;GET NODE CONFIGURATION INFORMATION
	  JRST	NOLOC		;NOT IMPLEMENTED?
	HLRZ	T2,NODDEV	;NUMBER OF LPT'S AT THIS NODE
	JUMPN	T2,NOLOC	;JUMP IF THERE ARE SOME
	JRST	LOCAT1		;NO LPT'S AT THIS NODE,
				;LOCATE JOB AT CENTRAL SITE

LOCAT0:	HRRZS	T1		;CLEAR LH
	CAIG	T1,^D77		;NODE NUMBER .GT. 77?
	 JRST	LOCAT3		;NO--CONTINUE
	INTWRN	(NTL,NODE NUMBER TOO LARGE)
	JRST	LOCAT2		;CANNOT LOCATE HIM, SAME AS IF NO SWITCH
LOCAT3:	IDIVI	T1,^D10		;CONVERT NODE TO OCTAL
	LSH	T1,3		;...
	ADD	T1,T2		;...

LOCAT1:	LOCATE	T1,		;LOCATE USER

	OUTSTR	[ASCIZ /%INTLUF LOCATE UUO failed.
/]
;HERE TO FIND THE PPN IN SYS:AUXACC.SYS IF POSSIBLE
;IF ANY PROBLEMS, PROCEED ONWARD AND DUPLICATE THE SYS S/L

NOLOC:
REPEAT 0,<			;NO LONGER USED DUE TO ACTDAE
	MOVE	T1,[UU.PHS!.IOBIN]	;BINARY MODE, PHYSICAL ONLY.
	MOVSI	T2,'SYS'	;SYS:
	MOVEI	T3,IBF		;INPUT BUFFER HEADER
	OPEN	TI,T1		;GET DEVICE
	  JRST	STRN.6		;GIVE UP IF UNAVAILABLE!
	MOVE	T1,['AUXACC']	;FILE
	MOVSI	T2,'SYS'	; NAMED
	SETZB	T3,T4		; SYS:AUXACC.SYS[-]
	LOOKUP	TI,T1		;GET IT
	  JRST	STRN.6		;GIVE UP IF MISSING
	TXO	F,F.BIN		;TELL INPUTTER BINARY
	TXZ	F,F.EOF		;CLEAR EOF FLAG
	PUSHJ	P,FILIN		;GET FIRST WORD
	  JRST	STRN.6		;IF NULL FILE, GIVE UP
	JUMPN	CH,STRN.6	;ONLY FORMAT V.0 WORKS
;BACK HERE TO LOOP OVER PPNS IN FILE
STRN.1:	PUSHJ	P,FILIN		;GET INDICATOR
	  JRST	STRN.6		;OUR PPN MISSING!
	AOJN	CH,STRN.6	;-1 IS FLAG
	PUSHJ	P,FILIN		;GET SIZE
	  JRST	STRN.6		;BAD FILE
	SOSGE	T6,CH		;GET COUNT LESS PPN
	JRST	STRN.6		;ERROR IF NEGATIVE SIZE
	PUSHJ	P,FILIN		;GET PPN
	  JRST	STRN.6		;BAD FILE
	MOVE	T1,CH		;GET PPN
	XOR	T1,REQPPN	;COMPARE TO DESIRED
	TRC	CH,-1		;SEE IF FILE IS WILD
	TRNN	CH,-1		;TEST WILD
	TRZ	T1,-1		;YES--PROGRAMMER ALWAYS MATCHES
	JUMPE	T1,STRN.3	;JUMP IF MATCH!!!
;LOOP TO SKIP ENTRY WE WANT TO IGNORE
STRN.2:	PUSHJ	P,FILIN		;DISCARD
	  JRST	STRN.6		;(BAD FILE)
	SOJG	T6,STRN.2	;UNTIL COUNT EXHAUSTED
	JRST	STRN.1		;THEN TRY NEXT PPN
;HERE WHEN ENTRY MATCHES
STRN.3:	IDIVI	T6,5		;GET STR COUNT
	JUMPN	T7,STRN.6	;ERROR IF NOT MULTIPLE OF 5
	MOVEI	T7,1		;START INDEX INTO ANSWER
;LOOP OVER STRS FOR THIS PPN
STRN.4:	JUMPE	T6,STRN.5	;EXIT WHEN DONE
	CAIGE	T7,ENDSTR-STRBLK  ;SEE IF OVERFLOW
	PUSHJ	P,FILIN		;NO--GET NEXT STR
	  JRST	STRN.5		;EXIT IF EOF (EVEN THO ERROR)
	MOVEM	CH,STRBLK(T7)	;SAVE STR NAME
	SETZM	STRBLK+1(T7)	;CLEAR PPN OF THIS STR
	PUSHJ	P,FILIN		;GET/IGNORE NEXT WORD
	  JRST	STRN.5		;(ERROR)
	PUSHJ	P,FILIN		;GET/IGNORE NEXT WORD
	  JRST	STRN.5		;(ERROR)
	PUSHJ	P,FILIN		;GET/IGNORE NEXT WORD
	  JRST	STRN.5		;(ERROR)
	PUSHJ	P,FILIN		;GET STATUS BIT WORD
	  JRST	STRN.5		;(ERROR)
	MOVEM	CH,STRBLK+2(T7)	;SAVE BITS
	MOVE	T1,[1,,T2]	;POINTER FOR DSKCHR
	MOVE	T2,STRBLK(T7)	;GET STR NAME
	DSKCHR	T1,		;GET ITS STATUS
	  SETOM	T1		;ERROR
	TXC	T1,<.DCTFS_<ALIGN.(DC.TYP)>>
	TXNN	T1,<DC.SAF!DC.NNA!DC.TYP>  ;MUST BE MULTI-ACCESS
			; ,ACCESSIBLE, AND A FILE-STRUCTURE
	ADDI	T7,3		;YES--ADVANCE ANSWER POINTER
	SOJG	T6,STRN.4	;LOOP OVER ALL STRS THIS PPN
;HERE WHEN A LIST HAS BEEN BUILT IN CORE
STRN.5:	RELEAS	TI,		;RELEASE INPUT CHANNEL
	TXZ	F,F.BIN!F.EOF	;CLEAR BINARY INDICATOR AND EOF
	MOVE	T1,T7		;POSITION COUNTER
	JRST	STRN.8		;PROCEED TO TELL MONITOR

;HERE WHEN CAN'T USE SYS:AUXACC.SYS FOR ANY REASON
STRN.6:	RELEAS	TI,		;RELEASE INPUT CHANNEL
	TXZ	F,F.BIN!F.EOF	;CLEAR BINARY INDICATOR AND EOF
>	;END REPEAT 0 FOR AUXACC.SYS
;HERE TO COPY THE SYS: SEARCH LIST

	SETZM	GETSTR		;SET GOBSTR ARGS TO JOB 0
	MOVE	T1,SYSPPN	;GET [1,4]
	MOVEM	T1,GETSTR+1	;SET SYS PPN AS PPN IN QUESTION
	SETOM	GETSTR+2	;SET TO START OF LIST
	MOVNI	T1,2		;PRESET ANSWER BLOCK

STRN.7:	MOVE	T3,[5,,GETSTR]	;GET POINTER FOR GOBSTR
	ADDI	T1,3		;ADVANCE ANSWER POINTER
	CAIGE	T1,ENDSTR-STRBLK  ;SEE IF FULL
	GOBSTR	T3,		;NO--GET NEXT STR
	  JRST	STRN.8		;CAN'T--GO SEE IF CAN SET IT UP
	SKIPE	T3,GETSTR+2	;GET STR NAME
	CAMN	T3,[-1]		;CHECK FOR FENCE
	JRST	STRN.8		;YES--GO SEE IF CAN SET IT UP
	MOVEM	T3,STRBLK(T1)	;OK--STORE STR
	MOVE	T3,GETSTR+3	;GET PPN JUST IN CASE IT EVER COUNTS
	MOVEM	T3,STRBLK+1(T1)  ;STORE IN STRUUO BLOCK
	MOVE	T3,GETSTR+4	;GET STATUS BITS
	MOVEM	T3,STRBLK+2(T1)  ;STORE IN BLOCK
	JRST	STRN.7		;LOOP BACK FOR MORE

STRN.8:	SETZM	STRBLK		;SET FUNCTION FOR STRUUO
	MOVE	T3,['DSKB  ']	;SET FOR DSKB JUST IN CASE NONE
	SKIPN	STRBLK+1	;SEE IF ANY STR SETUP
	MOVEM	T3,STRBLK+1	;NO--FILL IN DEFAULT
	HRLZI	T1,(T1)		;GET LENGTH OF LIST
	TLNN	T1,-2		;SEE IF ANYTHING THERE
	HRLZI	T1,4		;NO--SET FOR AT LEAST ONE STR
	HRRI	T1,STRBLK	;POINT TO BLOCK
	STRUUO	T1,		;TELL MONITOR
	  JFCL			;WELL--NICE TRY
	POPJ	P,		;RETURN IF SUCCESSFUL
;HERE TO SET THE ACCOUNT STRING FOR A JOB THAT WE'RE GOING TO LOG IN.
;IF ONE IS SET, USE IT.  OTHERWISE, GO LOOK FOR A SYSTEM DEFAULT ACCOUNT
;STRING.  RETURN ERROR IF ACCOUNT VALIDATION IS REQUIRED AND WE FAILED
;IN SOME WAY.

;DESTROYS T1 AND T3

ACCT$:	MOVX	T3,%CNST2	;GET THE SECOND MONITOR
	GETTAB	T3,		; STATES WORD
	  SETZ	T3,		;WELL, ASSUME NO STATES
	MOVX	T1,<.ACTRD,,[EXP 2,0,ACTSTR]> ;GET ACCT. ARG BLOCK
	SKIPN	ACTSTR		;DO WE HAVE AN ACCOUNT STRING?
	 ACCT.	T1,		;NO, READ JOB ZERO'S ACCOUNT STRING
	  JFCL			;ERRORS CAN ALWAYS HAPPEN
	MOVX	T1,<.ACTCH,,[EXP 1,<POINT 7,ACTSTR>]> ;GET ACCT. ARGUMENT BLOCK
	SKIPE	ACTSTR		;DO WE HAVE AN ACCOUNT STRING YET?
	ACCT.	T1,		;YES, GO SET IT
	 TXNN	T3,ST%ACV	;ERROR, ACCOUNT VALIDATION REQUIRED?
	  AOS	(P)		;NOPE.  NO ERROR HERE
	POPJ	P,		;RETURN
SUBTTL	SUBROUTINE TO TYPE SIGN ON MESSAGE
;CALL:	PUSHJ	P,SIGNON
;USES ALL TEMPS

SIGNON:	MOVE	T1,FLNAME	;SEE IF USER
	TRNN	T1,1		;  SAID NONAME
	TXNE	F,F.NOHD	;SEE IF HEADER SUPPRESSED
	POPJ	P,		;YES--RETURN QUICKLY
	TTYSTR	CRLFM
	MOVSI	T7,-5		;SETUP POINTER TO READ
	MOVX	T6,%CNFG0	;SYSTEM HEADER LINE

SIGN.1:	MOVE	T5,T6		;MAKE POINTER
	GETTAB	T5,		;GET THE HEADER
	  MOVEI	T5,0		;DON'T REALLY CARE IF THIS FAILS
	MOVEM	T5,T1(T7)	;STORE IN ARRAY
	ADD	T6,[1,,0]	;ADVANCE INDEX
	AOBJN	T7,SIGN.1	;LOOP FOR TITLE

	MOVEI	T6,0		;GUARANTEE CLEAN END
	TTYSTR	T1		;TYPE HEADER
	TTYCHR	" "		;SEND A SPACE
	MSTIME	T4,		;GET TIME OF DAY
	IDIVI	T4,^D1000	;CONVERT TO SECONDS
	IDIVI	T4,^D3600	;GET HOURS
	PUSHJ	P,TYPD2		;TYPE HOURS
	MOVE	T4,T5		;RE-POSITION REMAINDER
	IDIVI	T4,^D60		;GET MINUTES
	PUSHJ	P,TYPD2C	;TYPE COLON, MINUTES
	MOVE	T4,T5		;GET SECONDS
	PUSHJ	P,TYPD2C	;TYPE COLON, SECONDS
	TTYCHR	" "		;SEND A SPACE
	MOVE	T2,ME		;GET TTY NAME
	PUSHJ	P,TYPSIX	;TYPE IT
	TTYSTR	[ASCIZ / system /]
	MOVE	T1,[%CCSER]	;GET CPU0 SERIAL NUMBER
	GETTAB	T1,		;...
	MOVE	T1,APRSN	;USE DEFAULT
	MOVNI	T7,6*2		;PRESET FOR 6 CPU'S
SIGN.2:	PUSHJ	P,TYPDEC	;LIST IN DECIMAL
	AOS	T1,T7		;TRY NEXT CPU
	ADD	T1,[%CCSER+6*2+1]  ;GET APR S/N
	GETTAB	T1,		; FROM MONITOR
	  MOVEI	T1,0		;STOP IF NO CPU
	JUMPLE	T1,SIGN.3	;END LOOP IF JUNK
	TTYCHR	"/"		;SEPARATE
	AOJL	T7,SIGN.2	;LOOP UNTIL DONE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

SIGN.3:	TTYSTR	[ASCIZ /
Connected to Node /]
	MOVEI	T1,MYNODE	;POINT TO MY NODE NAME'S STRING BLOCK
	PUSHJ	P,TYPAS8	;TYPE THE NODE NAME
	HLRZ	T1,MYNUMB+.NSASL ;GET THE LENGTH OF THE NODE NUMBER STRING
	JUMPE	T1,SIGN3B	;SKIP THIS IF NOTHING THERE
	TTYSTR	[ASCIZ /(/]
	HLRZ	T1,NL.ME	; GET NODE NUMBER
	PUSHJ	P,TYPOCT
	TTYSTR	[ASCIZ /)/]	;CLOSE OFF THE NODE NUMBER
SIGN3B:	HLRZ	T1,MYTERM+.NSASL ;SEE IF ANY TERMINAL NAME STRING
	JUMPE	T1,SIGN3A	;NOPE, DON'T TRY TO TYPE IT THEN
	TTYSTR	[ASCIZ / Line /];YEP.  SAY WE'RE GOING TO TYPE THE LINE NAME
	MOVEI	T1,MYTERM	;POINT TO THE STRING BLOCK
	TXNN	F,F.ANFL!F.DCNL	;IS THIS AN ANF-10 OR CTERM CONNECTION?
	JRST	[PUSHJ	P,TYPAS8	;NO, JUST TYPE THE NAME STRING IN FULL
		 JRST	SIGN3A]		;AND CONTINUE BELOW
	TTYSTR	[ASCIZ /# /]	;YES, SAY THIS IS A TERMINAL NUMBER
	PUSHJ	P,GET826	;CONVERT PORT NAME TO SIXBIT
	PUSHJ	P,XPNTTY	;EXPAND THE TTY NAME
	PUSHJ	P,CVTBIN	;GET THE LINE NUMBER OUT OF IT
	MOVE	T1,WD		;COPY THE LINE NUMBER
	PUSHJ	P,TYPOCT	;GO TYPE THE LINE NUMBER
SIGN3A:	TTYSTR	CRLFM
	TXNN	F,F.LOGI	;SEE IF LOGGED IN
	POPJ	P,		;NO--ALL DONE
	TTYSTR	[ASCIZ /Job /]
	MOVE	T1,JOBN		;GET JOB NUMBER
	PUSHJ	P,TYPDEC	;TYPE IN DECIMAL
	HRROI	T2,.GTNM1	;GET USER'S NAME
	GETTAB	T2,		; FROM MONITOR
	  JRST	SIGN.4		;IGNORE IF UNAVAILABLE
	JUMPE	T2,SIGN.4	;OR MISSING
	TTYSTR	[ASCIZ /   User /]
	PUSHJ	P,TYPSX6	;TYPE SIX CHARACTERS
	HRROI	T2,.GTNM2	;GET 2ND HALF OF NAME
	GETTAB	T2,		; FROM MONITOR
	  MOVEI	T2,0		;(IMPOSSIBLE)
	PUSHJ	P,TYPSIX	;TYPE IN SIXBIT AND RETURN
	TTYSTR	[ASCIZ /   [/]	;THEN ISSUE PPN
	HLRZ	T1,MYPPN	;GET MY PROJECT
	PUSHJ	P,TYPOCT	;ISSUE IN OCTAL
	TTYCHR	","		;SEPARATE WITH COMMA
	HRRZ	T1,MYPPN	;GET MY PROGRAMMER
	PUSHJ	P,TYPOCT	;ISSUE IN OCTAL
	TTYCHR	"]"		;END PPN
SIGN.4:	TTYSTR	1,CRLFM
SUBTTL	SUBROUTINE TO TYPE KSYS MESSAGE
;CALL:	PUSHJ	P,TYKSYS
;USES ALL TEMPS

TYKSYS:	MOVX	T1,%NSKTM	;GET TIME TO GO
	GETTAB	T1,		; FROM MONITOR
	  POPJ	P,		;RETURN IF NOT IMPLEMENTED
	SKIPE	T1		;SEE IF SET
	CAIL	T1,^D24*^D60	; AND LESS THAN 24 HRS.
	POPJ	P,		;NO--RETURN
	JUMPL	T1,TYKS.2	;SEE IF ALREADY DOWN
	TTYSTR	[ASCIZ /Timesharing will cease in /]
	PUSH	P,T1		;SAVE TIME
	IDIVI	T1,^D60		;GET HOURS
	JUMPE	T1,TYKS.1	;JUMP IF LT 1 HOUR
	PUSHJ	P,TYPDEC	;TYPE IN DECIMAL
	TTYSTR	[ASCIZ / hours /]
TYKS.1:	MOVE	T1,(P)		;GET TIME AGAIN
	IDIVI	T1,^D60		;GET MINUTES
	MOVE	T1,T2		; INTO RIGHT AC
	PUSHJ	P,TYPDEC	;TYPE IN DECIMAL
	TTYSTR	[ASCIZ / minutes, at /]
	MSTIME	T1,		;GET TIME OF DAY
	IDIVI	T1,^D60000	;GET MINUTES OF DAY
	POP	P,T2		;RESTORE KSYS TIMER
	ADD	T1,T2		;FIND TIME OF DAY
	CAIL	T1,^D24*^D60	;SEE IF TOMORROW
	SUBI	T1,^D24*^D60	;YES--CORRECT TIME
	IDIVI	T1,^D60		;GET HOURS
	PUSH	P,T2		;SAVE MINUTES
	MOVE	T4,T1		;POSITION HOURS
	PUSHJ	P,TYPD2		;TYPE HOURS AS TWO DIGITS
	POP	P,T4		;RESTORE MINUTES
	PUSHJ	P,TYPD2C	;TYPE AS :TWO DIGITS
	JRST	TYKS.3		;AND FINISH LINE

;HERE IF KSYS TIMER ALREADY RUN OUT
TYKS.2:	TTYSTR	[ASCIZ /Timesharing is over/]
TYKS.3:	TTYSTR	1,[ASCIZ /.
/]
SUBTTL	ERROR HANDLERS

;HERE IF LOGICAL INCONSISTENCY IN PROGRAM--NOTE BP=ADDR. OF PROBLEM

E$$BMB:	INTERR	(BMB,<Bomb out >,<JRST .+1>)
	MOVEI	T1,(BP)		;GET ADDRESS
	SUBI	T1,INITIA+1	;CONVERT TO RELATIVE
	PUSHJ	P,TYPOCT	;ISSUE IN OCTAL
EBMB.1:	OUTSTR	CRLFM		;END LINE
	SUBI	BP,INITIA+1	;SUBTRACT RELOCATION AND PC INCREMENT
	LIGHTS	BP,		;FOR DEBUGGING, SEND TO LIGHTS
	JRST	KILJOB		;GO KILL OFF JOB

SUBTTL	TYPEOUT ROUTINES

;SUBROUTINE TO TYPE THE CONTENTS OF AN EIGHT BITS ASCII STRING BLOCK
;CALL:	MOVEI	T1,STRING BLOCK ADDRESS
;	PUSHJ	P,TYPAS8
;USES T1, T2

TYPAS8:	HLRZ	T2,.NSASL(T1)	;GET THE STRING LENGTH
	JUMPE	T2,CPOPJ	;RETURN NOW IF NULL STRING
	ADD	T1,[POINT 8,.NSAST] ;SET THE BYTE POINTER
	PUSH	P,T1		;SAVE THE BYTE POINTER
TYP8.1:	ILDB	T1,(P)		;GET A BYTE
	TTYCHR	(T1)		;TYPE IT
	SOJG	T2,TYP8.1	;LOOP FOR ALL BYTES
	POP	P,(P)		;CLEAN UP THE STACK
	POPJ	P,		;AND RETURN

;SUBROUTINE TO TYPE TWO DECIMAL DIGITS
;WARNING--THIS DOES NOT HANDLE NEGATIVE NUMBERS OR NUMBERS
;	GREATER THAN 99.
;CALL:	MOVE	T4,NUMBER
;	PUSHJ	P,TYPD2
;USES T1, T2

TYPD2C:	TTYCHR	":"

TYPD2:	MOVE	T1,T4		;GET NUMBER
	IDIVI	T1,^D10		;GET TENS
	TTYCHR	"0"(T1)		;TYPE IT
	TTYCHR	1,"0"(T2)	;TYPE IT AND RETURN



;SUBROUTINE TO TYPE A DECIMAL/OCTAL NUMBER
;CALL:	MOVE	T1,NUMBER
;	PUSHJ	P,TYPDEC/OCT
;USES T1,T2,T3

TYPOCT:	SKIPA	T3,[10]		;SET OCTAL RADIX
TYPDEC:	MOVEI	T3,^D10		;SET DECIMAL RADIX
TYPRAD:	SKIPGE	T1		;IF NEGATIVE,
	TTYCHR	"-"		; ISSUE MINUS
TYPR.1:	IDIVI	T1,(T3)		;GET LOWEST DIGIT
	MOVMS	T2		;GET POSITIVE OF REMAINDER
	HRLM	T2,(P)		;STACK IT
	SKIPE	T1		;UNLESS DONE
	PUSHJ	P,TYPR.1	;  TRY AGAIN
	HLRZ	T1,(P)		;GET TOP DIGIT
	TTYCHR	1,"0"(T1)	;OUTPUT IT AND RETURN

;SUBROUTINE TO TYPE 6 SIXBIT CHARACTERS
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,TYPSX6
;USES T1, T2, T3

TYPSX6:	MOVEI	T3,6		;SET COUNT
TYPS.1:	MOVEI	T1,0		;CLEAR NEXT CHARACTER
	LSHC	T1,6		;GET NEXT CHAR
	TTYCHR	40(T1)		;TYPE IT
	SOJG	T3,TYPS.1	;LOOP UNTIL COUNT DONE
	POPJ	P,		;THEN RETURN

;SUBROUTINE TO TYPE A SIXBIT WORD
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,TYPSIX
;USES T1, T2

TYPSIX:	MOVEI	T1,0		;CLEAR NEXT CHAR
	LSHC	T1,6		;GET NEXT CHAR
	TTYCHR	"A"-'A'(T1)	;TYPE  IT
	JUMPN	T2,TYPSIX	;LOOP UNTIL ALL DONE
	POPJ	P,		;THEN RETURN

;SUBROUTINE TO TYPE AN ASCII STRING IN IMAGE MODE
;CALL:	MOVEI	T2,STRING POINTER
;	PUSHJ	P,SNDIMG
;	RETURN
;USES T2, T6, T7


SNDIMG:	HRLI	T2,(POINT 7,)	;TURN INTO BYTE POINTER
SNDI.1:	ILDB	T7,T2		;GET NEXT CHARACTER
	JUMPE	T7,CPOPJ	;RETURN IF NULL
			;THE FOLLOWING COMES FROM 5.04 UUOCON(PEVEN8)
	MOVEI	T6,(T7)		;MAKE A COPY OF BYTE
	LSH	T6,-4		;FOLD INTO LOW 4 BITS
	XORI	T6,(T7)		; ..
	TRCE	T6,14		;CHECK BITS
	TRNN	T6,14		; 32 AND 33
	TRC	T7,200		;IF EVEN, COMPLIMENT RESULT
	TRCE	T6,3		;CHECK BITS
	TRNN	T6,3		; 34 AND 35
	TRC	T7,200		;IF EVEN, COMPLEMENT RESULT
	IONEOU	T7		;SEND OUT VIA IMAGE MODE
	JRST	SNDI.1		;LOOP BACK FOR MORE
;THIS IS THE LUUO HANDLER
;IT SCRATCHES OC AND PRESERVES ALL OTHERS

LUUO:	MOVE	OC,.JBUUO	;GET UUO
	TLNE	OC,(Z 1,0)	;AC1 ON IN LUUO
	POP	P,(P)		;YES, REMOVE CALL
	LSH	OC,-^D27	;ISOLATE OPCODE
	CAIL	OC,LUUOMX	;IN RANGE OF KNOWN OPCODES?
	SETZ	OC,		;NO, USE DISPATCH ZERO
	PJRST	@LUUORT(OC)	;LET THE ROUTINE HANDLE IT

LUUORT:	LUUO0			;INVALID
	$TTOUT			;TTYCHR
	$TTSTR			;TTYSTR
	$CTSTR			;CTYSTR
	$CTCHR			;CTYCHR
	$PIMIN			;PIMGET
	TTYPBF			;DMPBUF
LUUOMX==.-LUUORT	;NUMBER OF LUUOS

LUUO0:	OUTSTR	[ASCIZ\? Illegal LUUO\]  ;OOPS
	EXIT			;DIE
;HERE ON A TTYSTR LUUO

$TTSTR:	SKIPE	SILENC		;ARE WE MUTE?
	POPJ	P,		;YES, JUST RETURN NOW
	MOVSI	OC,(POINT 7,)	;SETUP BYTE POINTER
	HLLM	OC,.JBUUO	; IN LOW CORE
TTSTR2:	ILDB	OC,.JBUUO	;GET A BYTE
	JUMPE	OC,CPOPJ	;RETURN ON NULL
	PUSHJ	P,TTCHR1	;TYPE IT
	JRST	TTSTR2		;LOOP OVER STRING

;HERE ON A TTYCHR LUUO
;WARNING--THIS IS IMMEDIATE MODE, UNLIKE OUTCHR

$TTOUT:	SKIPE	SILENC		;ARE WE MUTE?
	POPJ	P,		;YES, JUST RETURN NOW
	HRRZ	OC,.JBUUO	;GET THE BYTE
TTCHR1:	SOSG	TTYCNT		;COUNT DOWN SPACE IN BUFFER
	PUSHJ	P,TTYPBF	;WRITE THE DATA
	IDPB	OC,TTYPNT	;STORE THE BYTE
	AOS	CHRSOU		;COUNT CHARACTERS FOR TYPTTY
	POPJ	P,		;RETURN

;SUBROUTINE TO DUMP THE TTY OUTPUT BUFFER
TTYPBF:	SKIPN	SILENC		;IF SILENCED, DO NO OUTPUT
	OUT	TTY,		;DO THE OUTPUT
	  POPJ	P,		;ALL IS OK
	STATZ	TTY,IO.ERR	;ANY ERRORS?
	JRST	LOGO1$		;YES--SEEMS SORT OF BAD
	PUSH	P,T1		;SAVE AN AC
	PUSH	P,[EXP ^D10]	;NUMBER OF MINUTES TO WAIT
TTYP.1:	MOVE	T1,[HB.RIO!HB.RWJ+^D6000]
	HIBER	T1,
	  JRST	LOGO1$		;MUST WORK
	OUT	TTY,		;TRY AGAIN
	  JRST	TTYP.2		;WE ARE DONE
	SOSLE	(P)		;KEEP WAITING
	JRST	TTYP.1		;YES--WAIT
	CLRBFO			;NO--BOMB OUT
	JRST	LOGO1$		;GO LOGOUT
TTYP.2:	POP	P,T1
	POP	P,T1
	POPJ	P,
;HERE FOR CTYSTR (OUTSTR TO THE CTY)

$CTSTR:	PUSH	P,T2		;NEED
	PUSH	P,T3		; SOME
	PUSH	P,T4		;  ACS
	HRRZ	T4,.JBUUO	;ADDRESS OF ASCIZ STRING
	MOVE	T3,CTYNUM	;UDX FOR CTY
	MOVEI	T2,.TOOUS	;OUTPUT STRING FUNCTION
	MOVE	OC,[3,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	OC,		;OUTPUT ASCIZ STRING TO THE CTY
	 JFCL			;OH WELL
	POP	P,T4		;  RESTORE
	POP	P,T3		; USED
	POP	P,T2		;ACS
	POPJ	P,		;RETURN TO CALLER


;HERE FOR CTYCHR LUUO

$CTCHR:	PUSH	P,T2		;NEED
	PUSH	P,T3		; SOME
	PUSH	P,T4		;  ACS
	HRRZ	T4,.JBUUO	;GET CHARACTER TO SEND
	ANDI	T4,177		;AND ONLY THE CHARACTER
	HRRZ	T3,CTYNUM	;UDX FOR THE CTY
	MOVEI	T2,.TOOUC	;SEND CHARACTER FUNCTION
	MOVE	OC,[3,,T2]	;TRMOP. ARG BLOCK TO
	TRMOP.	OC,		;OUTPUT SINGLE CHARACTER TO THE CTY
	 JFCL			;HOHUM
	POP	P,T4		;  RESTORE
	POP	P,T3		; THE
	POP	P,T2		;ACS
	POPJ	P,		;RETURN TO CALLER
;HERE ON A PIMGET LUUO

$PIMIN:	INCHRS	OC		;GET A CHARACTER
	  JRST	PIMIN1		;DIDN'T WORK, WAIT FOR IT
	JRST	PIMIN2		;GOT IT, RETURN IT

PIMIN1:	SETO	OC,		;OURSELVES
	WAKE	OC,		;MAKE SURE
	  JFCL			;CAN'T FAIL
	HLLZ	OC,SLPTIM	;SETUP CONDITIONS & CANCEL CLOCK REQUEST
	HIBER	OC,		;DO IT
	  JFCL			;CAN'T FAIL
	MOVE	OC,SLPTIM	;WAIT FOR CHARACTER OR TIMEOUT
	HIBER	OC,		;WAIT A WHILE
	  JFCL			;FTHIBWAKE IS REMOVED ON
	INCHRS	OC		;GET THE CHARACTER
	  TDZA	OC,OC		;NONE, CLAIM A NULL
	JRST	PIMIN2		;RETURN IT
	JRST	PIMIN3		;RETURN NON-SKIP WITH NULL
PIMIN2:	JUMPE	OC,$PIMIN	;TRY AGAIN IF GOT A NULL ON INPUT
	AOS	(P)		;SKIP ON SUCCESS
PIMIN3:	MOVEM	OC,@.JBUUO	;STUFF IN DESIRED DESTINATION
	POPJ	P,		;RETURN APPROPRIATELY
SUBTTL	GTNTN. ROUTINE

; SUBROUTINE TO GET NODE,,LINE# FOR DEVICE SPECIFIED IN T1 IN T1

GTNTN$:	GTNTN.	T1,0		; TRY DIRECTLY
	SKIPA			; NOW THE HARD WAY
	POPJ	P,0		; RETURN
	PUSH	P,T1		; SAVE DEVICE NAME
	IONDX.	T1,0		; GET THE LINE # + 200000
	  SETZ	T1,0		; NICE TRY
	TXZ	T1,.UXTRM	; CLEAR BIT 1
	EXCH	T1,(P)		; GET DEVICE AGAIN IN T1
	WHERE	T1,0		; GET THE NODE NUMBER
	  SETZ	T1,0		; NICE TRY
	HRLM	T1,(P)
	POP	P,T1
	POPJ	P,0		; RETURN
	SUBTTL	NDNAM TURN A NODE SPEC INTO A NODE NAME

;NDNAM  --  TRY TO MAKE A NAME OUT OF A NODE SPECIFIER
;CALL IS:
;
;	MOVX	T3,<NODE>
;	PUSHJ	P,NDNAM
;	RETURN
;
;WHERE <NODE> IS SIXBIT NODE NAME, SIXBIT NODE NUMBER, OR OCTAL NODE NUMBER.
;
;ON RETURN T1 WILL HAVE THE NODE NAME IF <NODE> IS MEANINGFUL, OTHERWISE
;T1 WILL HAVE <NODE>, ASSUMING WHOEVER WANTS TO USE IT WILL BE BETTER
;SITUATED TO COMPLAIN ABOUT NO SUCH NODE. T2 WILL HAVE THE NODE NUMBER
;ASSOCIATED WITH THE NAME IN T1, IF ANY.

NDNAM:	PUSH	P,T3		;SAVE INPUT
	CAMN	T3,MYNNAM	;LOCAL (KNOWN) NAME?
	JRST	NDNAM5		;YES, THEN ALL SET
	TLNN	T3,770000	;SIXBIT OF SOME SORT?
	JRST	NDNAM3		;NO, MUST BE OCTAL NODE NUMBER
	MOVE	T1,[.NDRNN,,T2]	;YES, MAY BE SIXBIT NODE NUMBER
	MOVEI	T2,2		;SO ASK MONITOR FOR OCTAL NODE NUMBER
	NODE.	T1,		;SINCE WE CAN'T TELL THE DIFFERENCE
	 JRST	NDNAM5		;JUNK, PRESERVE INPUT
	MOVE	T3,T1		;SET UP NODE NUMBER
NDNAM3:	MOVE	T1,[.NDRNN,,T2]	;ARG POINTER
	MOVEI	T2,2		;AND ARG BLOCK LENGTH
	NODE.	T1,		;TO READ NODE NAME GIVEN NODE NUMBER
NDNAM5:	 MOVE	T1,0(P)		;NO SUCH NODE, RETURN INPUT SPECIFIER
	PUSH	P,T1		;SAVE NODE NAME
	MOVE	T3,T1		;POSITION NAME IN T3
	MOVE	T1,[.NDRNN,,T2]	;ARG POINTER
	MOVEI	T2,2		;AND ARG BLOCK LENGTH
	NODE.	T1,		;TO READ NODE NUMBER FOR NAME
	 SETO	T1,		;NONE KNOWN
	MOVE	T2,T1		;RETURN NODE NUMBER IN T2
	POP	P,T1		;AND NODE NAME IN T1
	POP	P,T3		;ADJUST STACK
	POPJ	P,		;AND RETURN
SUBTTL	SPECIAL TTY SETUP SEQUENCES

;TERMINET 300--SET TABS AT 4,12,... (4 IS THEN C.RET.POINT)

TRMIMG:	BYTE	(7)15,12,33,62,177,177,15,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,15,0
SUBTTL	STORAGE AREA

;STORAGE AREA

	XLIST	;LITERALS
	LIT
	LIST

CRLFM:	ASCIZ	/
/


;TABLES SHARED AMONG ALL COPIES OF INITIA
LOCKWD:	EXP	-1		;INTERLOCK FOR HISEG
LOKJOB:	BLOCK	1		;JOB # THAT HAS INTERLOCK
LOKTTY:	BLOCK	1		;ABOVE JOB'S TTY LINE
FRCTRY:	BLOCK	1		;NUMBER OF TIMES WE GOT TO FORCE
FRCCNT:	BLOCK	1		;NUMBER OF TIMES THAT WE ACTUALLY FORCED THE LOCK
ITLCNT:	BLOCK	1		;NUMBER OF TIMES WE THOUGHT WE HAD
				;THE HIGH-SEG INTERLOCK BUT WE DIDN'T
CORCNT:	BLOCK	1		;NUMBER OF TIMES THE CORE UUO TO
				;INCREASE THE HIGH-SEG FAILED
JOBWAT:	BLOCK	<^D512+^D35>/^D36 ;BIT TABLE FOR JOBS WAITING FOR THE INTERLOCK
JBWATL==.-JOBWAT		;NUMBER OF ENTRIES IN THE TABLE

HIPTR:	POINT	7,0		;BYTE POINTER TO TEXT STORAGE
HS$DEV:	BLOCK	N$HSGF		;DEVICE NAMES
HS$FIL:	BLOCK	N$HSGF		;FILE NAMES
HS$EXT:	BLOCK	N$HSGF		;EXTENSIONS
HS$PPN:	BLOCK	N$HSGF		;PPN'S
HS$DAT:	BLOCK	N$HSGF		;DATE/TIME WORDS
HS$PTR:	BLOCK	N$HSGF		;BYTE POINTER TO CONTENTS OF
				; THE FILE.  IF THIS WORD IS 0
				; THE FILE DOES NOT EXIST
	SUBTTL	IMPURE DATA

	RELOC

ZER:!			;START OF AREA TO ZERO ON RESTART
PDL:	BLOCK	L$PDL+1	;PUSH-DOWN LIST
GETCH:	BLOCK	1	;ADDRESS OF TTY INPUT ROUTINE IF ANY
REEAT:	BLOCK	1	;CHARACTER TO REEAT
FILICH:	BLOCK	1	;REUSABLE CHARACTER IN STRIPPER
JUMPPR:	BLOCK	1	;ADDRESS OF SPECIAL STARTUP ROUTINE
SYSPPN:	BLOCK	1	;PPN OF SYS:
MYPPN:	BLOCK	1	;PPN OF THIS JOB
NOPBLK:	BLOCK	.NOPNM+1	;BLOCK FOR NETOP.ING
DEFTYP:	BLOCK	1	;SYSTEM DEFAULT TTY TYPE
TERNUM:	BLOCK	1	;INDEX OF THIS TTY
TRMNAM:	BLOCK	1	;SIXBIT CENTRAL NODE TERMAL NAME ("TTYNNN"), EXPANDED
TRMNNM:	BLOCK	1	;SIXBIT NODE RELATIVE TERMINAL NAME (EXPANDED ALSO)
TRMNUM:	BLOCK	1	;UDX OF TTY FOR SET/READ IN TYPTTY
STR8BK:	BLOCK	L$SBLK+.NSAST ;EIGHT BIT ASCII STRING BLOCK
MYTERM:	BLOCK	L$TERM+.NSAST ;EIGHT BIT PORT ID STRING
MYNODE:	BLOCK	L$NNAM+.NSAST ;EIGHT BIT ASCII NODE NAME
MYNUMB:	BLOCK	L$NNAM+.NSAST ;EIGHT BIT ASCII NODE NUMBER
MYNNAM:	BLOCK	1	;SIXBIT NODE NAME
JOBN:	BLOCK	1	;OUR JOB NUMBER
MYBIT:	BLOCK	1	;BIT FOR THIS JOB IN JOBWAT TABLE
MYWRD:	BLOCK	1	;ADDRESS OF THE WORD CONTAING THE BIT
MYSPD:	BLOCK	1	;MY RECEIVE SPEED AS DETECTED
FFAPPN:	BLOCK	1	;PPN OF [1,2]
REQPPN:	BLOCK	1	;REQUESTED PPN
; SYMBOLIC LOCATIONS OF THE FORM "NL.???" STORE VALUES IN THE FORM
; XWD NODE,LINE
NL.CTY:	BLOCK	1	; CENTRAL STATION (CTY)
NL.OPR:	BLOCK	1	; CENTRAL OPR
NL.LOP:	BLOCK	1	; OUR LOCAL OPR
NL.ME:	BLOCK	1	; OUR LOCATION
CTYTTY:	BLOCK	1	; SIXBIT TTY NAME FOR CTY
CTYNUM:	BLOCK	1	;UDX FOR CTY
FLNNUM:	BLOCK	1	;UDX FOR FRCLIN
APRSN:	BLOCK	1	;APR SERIAL NUMBER
IBF:	BLOCK	3	;BUFFER HEADER BLOCK
RUNBLK:	BLOCK	6	;RUN UUO PARAMETERS
ACTSTR:	BLOCK	10	;ACCOUNT STRING FROM TTY.INI
INTBLK:	BLOCK	4	;INTERCEPT BLOCK
TEMP1:	BLOCK	1	; TEMPORARY STORAGE FOR INTERCEPT
NOINT:	BLOCK	1	; IF NEGATIVE DON'T INTERRUPT
SAVEF:	BLOCK	1	;PLACE TO HOLD F
FLKSYS:	BLOCK	1	;FLAG TO TYPE KSYS TIME
FLNAME:	BLOCK	1	;FLAG NONAME (SUPPRESS HEADER LINE)
FLSET:	BLOCK	1	;FLAG NOSETTTY (SUPRESS TTY SETUP)
FLSTR:	BLOCK	1	;FLAG TO DO STRUCTURE NOTES
FLTEXT:	BLOCK	1	;FLAG TO PRINT TEXT MSG
FLNOTC:	BLOCK	1	;FLAG TO TYPE NOTICE.TXT
FLTTY:	BLOCK	1	;FLAG TO TYPE TTY SETTINGS
FLATTR:	BLOCK	1	;FLAG TO TYPE TTY ATTRIBUTES
FLCHEK:	BLOCK	1	;FLAG TO QUERY TERMINAL FOR ITS TYPE
DIAL:	BLOCK	2	;NUMBER TO DIAL
LOCAT:	BLOCK	1	; LOCATE USER
NODBLK:			;START OF NODE. UUO ARGUMENT BLOCK
NODLEN:	BLOCK	1	;LENGTH OF NODE UUO ARGUMENT BLOCK
NODLOC:	BLOCK	1	;NODE NUMBER
	BLOCK	1	;RESERVED ARGUMENT
NODDEV:	BLOCK	1	;NUMBER OF DEVICES,,DEVICE TYPE
FILCWT:	BLOCK	1	;SLEEP COUNTER IN FILCON
TTBZER:!		;START CLEARING HERE IF CHECK BUT NOSET

;TTY PARAMETERS

APC::	BLOCK	1	;TTY APC
ALT::	BLOCK	1	;TTY ALT
BLANK::	BLOCK	1	;TTY BLANK
CLASS:	BLOCK	1	;TTY CLASS
CRLF::	BLOCK	1	;TTY CRLF
ECHO::	BLOCK	1	;TTY ECHO
ECHDEF:	BLOCK	1	;TTY DEFER
EDITOR:	BLOCK	1	;TTY EDITOR
ESCAPE:	BLOCK	1	;TTY ESCAPE
FILL::	BLOCK	1	;TTY FILL
FORM::	BLOCK	1	;TTY FORM
GAG:	BLOCK	1	;TTY GAG
IDLE:	BLOCK	1	;TTY IDLEDISC
LC::	BLOCK	1	;TTY LC
LENGTH::BLOCK	1	;TTY LENGTH
LOCALC::BLOCK	1	;TTY LOCALCOPY
MODEL::	BLOCK	1	;TTY MODEL:NAME
PAGEON::BLOCK	1	;TTY PAGE
PAGE:	BLOCK	1	;TTY PAGE:N
QUOTE:	BLOCK	1	;TTY QUOTE
RCV:	BLOCK	1	;TTY RCVSPEED
REM:	BLOCK	1	;TTY REMOTE
RTCOMP::BLOCK	1	;TTY RTCOMP
SBELL::	BLOCK	1	;TTY SBELL (RING BELL ON AUTO-STOP)
SLAVE::	BLOCK	1	;TTY SLAVE
SSIZE::	BLOCK	1	;TTY STOP N (THE "N" OF STOP EVERY N LINES)
SSTOP::	BLOCK	1	;TTY SSTOP
STOP::	BLOCK	1	;TTY STOP
TAB::	BLOCK	1	;TTY TAB
TAPE::	BLOCK	1	;TTY TAPE
TYPE::	BLOCK	1	;TTY TYPE
UNPAUS:	BLOCK	1	;TTY UNPAUSE
WIDTH::	BLOCK	1	;TTY WIDTH
XMT:	BLOCK	1	;TTY XMTSPEED
XONXOF::BLOCK	1	;TTY XONXOF
;TTY ATTRIBUTES

ATR8BA::BLOCK	1	;TTY ATR 8BITARCHITECURE
ATR8BT::BLOCK	1	;TTY ATR EIGHTBIT
ATRAVO::BLOCK	1	;TTY ATR AVO
ATRBMT::BLOCK	1	;TTY ATR BLOCKMODETRANSFER
ATRBTA::BLOCK	1	;TTY ATR BLOCKANSI
ATRCID::BLOCK	1	;TTY ATR IDCHARACTER
ATRCLR::BLOCK	1	;TTY ATR COLOR
ATRDIS::BLOCK	1	;TTY ATR DISPLAY
ATRESL::BLOCK	1	;TTY ATR STATUSLINE
ATRGAT::BLOCK	1	;TTY ATR GUARDEDAREATRANSFER
ATRGPO::BLOCK	1	;TTY ATR REGIS
ATRHSR::BLOCK	1	;TTY ATR HORIZONTALSCROLLING
ATRISO::BLOCK	1	;TTY ATR ISO
ATRJTK::BLOCK	1	;TTY ATR KATAKANA
ATRLID::BLOCK	1	;TTY ATR IDLINE
ATRNKB::BLOCK	1	;TTY ATR [NO]KEYBOARD
ATRNRC::BLOCK	1	;TTY ATR NRC
ATROVR::BLOCK	1	;TTY ATR OVERSTRIKE
ATRPPO::BLOCK	1	;TTY ATR PRINTERPORT
ATRRCS::BLOCK	1	;TTY ATR DRCS
ATRSEM::BLOCK	1	;TTY ATR SELECTIVEERASE
ATRSRM::BLOCK	1	;TTY ATR SCROLLREGIONS
ATRSSU::BLOCK	1	;TTY ATR SESSIONS
ATRSXL::BLOCK	1	;TTY ATR SIXEL
ATRTCS::BLOCK	1	;TTY ATR DECTCS
ATRTEK::BLOCK	1	;TTY ATR TEKTRONIXEMULATION
ATRTSI::BLOCK	1	;TTY ATR INTERROGATION
ATRUDK::BLOCK	1	;TTY ATR UDKEYS
ATRUWN::BLOCK	1	;TTY ATR UWINDOW
ATRV52::BLOCK	1	;TTY ATR VT52EM
ATRVFL::BLOCK	1	;TTY ATR VLENGTH
ATRVFW::BLOCK	1	;TTY ATR VWIDTH

TERATR:	BLOCK	1	;BIT MASK
TRMATR:	BLOCK	1	;CHANGE MASK

DECLVL::BLOCK	1	;TTY ATR DECLEVEL:N
ANSLVL::BLOCK	1	;TTY ATR ANSLEVEL:N
LOCDVT::BLOCK	1	;TTY ATR LOCATOR:XXXXXX

TERAT2:	BLOCK	1	;FIELDS
TRMAT2:	BLOCK	1	;CHANGE FLAG

;ADD .TOAT3 STORAGE HERE

TERAT3:	BLOCK	1	;FIELDS
TRMAT3:	BLOCK	1	;CHANGE FLAG

TTEZER==.-1		;LAST WORD TO CLEAR WAS ABOVE

SAVLCH:	BLOCK	1	;SAVED GETLCH RESULTS
VT52CH:	BLOCK	1	;SAVED PRESUMED <ESC> AT START OF DECID RESPONSE
CHKS8B::BLOCK	1	;SAVED COPY OF .TO8BT AT START OF CHECK ROUTINE
CSIS8B::BLOCK	1	;FLAG WHETHER CSIID DETECTED 8-BIT OR MARK PARITY
DA2DEF::BLOCK	1	;TYPE(S) TO SET AT END OF DA2 PARSING
PRVPRM::BLOCK	1	;PRIVATE PARAMETER CHARACTER OR ZERO (CONTROL SEQ)
PRMLST::BLOCK	PRMMAX+1 ;BLOCK OF PARAMETER VALUES FOLLOWING CSI
SLPTIM::BLOCK	1	;HIBER ARGUMENT FOR PIMGET
STRBUF::BLOCK	7	;SPACE TO BUILD A STRING FOR TYPIST ON THE FLY
LOWPTR:	BLOCK	1	;POINTER TO HISEG TEXT
CHRSOU:	BLOCK	1	;COUNT OF CHARACTERS OUTPUT FOR TYPTTY
SILENC:	BLOCK	1	;DON'T TYPE ANYTHING ON TTY IF NONZERO
TTYOBF:	BLOCK	1	;TTY OUTPUT RING HEADER
TTYPNT:	BLOCK	1	;TTY OUTPUT BYTE POINTER
TTYCNT:	BLOCK	1	;TTY OUTPUT BYTE COUNT
TTYBUF:	BLOCK	L$TTBF+3 ;SIZE OF OUTPUT BUFFER

FLNCNT:	BLOCK	1	;BYTE COUNTER FOR TYPER
FLNPNT:	BLOCK	1	;BYTE POINTER FOR TYPER
FLNBUF:	BLOCK	<FLN$MX+4>/5	;BYTE BUFFER FOR TYPER

GETSTR:	BLOCK	5	;ARGUMENT BLOCK FOR GOBSTR UUO
STRBLK:	BLOCK	1+3*N$STRS	;ARGUMENT BLOCK FOR STRUUO
ENDSTR==.

IPCMHD:	BLOCK	.IPCMP+1 ;HEADER BLOCK FOR IPCFM.
IPCCBK:	BLOCK	.IPCS2+1 ;[SYSTEM]IPCC MESSAGE BLOCK

TTWFLG:	BLOCK	1	;FLAG THAT WE WILL/ARE STOMP/ING
TTWNRI:	BLOCK	1	;TOTAL CHARACTER COUNT
TTWNTM:	BLOCK	1	;LAST TIMER
TTWPCT:	BLOCK	1	;POINTER (INDEXES T7) TO LINE-DEPENDENT CHAR COUNT
TTWPTM:	BLOCK	1	;POINTER (INDEXES T7) TO PARALLEL TIME OF LAST SAMPLE
TTWPRS:	BLOCK	1	;POINTER (INDEXES T7) TO CHANNEL,,.TORSP
LINTAB:	BLOCK	1	;POINTER (INDEXES T7) TO ENTRY IN MAPPED LINTAB
TTWMCN:	BLOCK	1	;HIGHEST CHANNEL WE ARE USING.
TTWILC:	BLOCK	1	;INIT'ED LINE COUNT
LDBOFF:	BLOCK	1	;OFFSET FROM MONITOR LDB ADDR TO USER LDB ADDR.

EZER:	BLOCK	0	;LAST LOCATION (+1) FOR ZEROING

	END	INITIA
