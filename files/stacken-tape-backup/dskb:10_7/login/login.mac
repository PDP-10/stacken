TITLE	LOGIN - Program to access the DECsystem-10
SUBTTL DLC/TW/DJB/DAL/RCC/JSL/DAL/LC/HRB/BAH/WCL/KPY/MSL/WSM/DPM/Tarl


;	      COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION
;     1969,1974,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988.
;			ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.


	LGNVER==65
	LGNMIN==0
	LGNEDT==3010
	LGNWHO==0

	SEARCH	UUOSYM,MACTEN,SCNMAC,ACTSYM,UFDPRM
	.REQUEST REL:SCAN,REL:WILD,REL:HELPER,REL:UFDSET

	SALL
	.DIRECT	FLBLST

	TWOSEG

	LOC	137
	EXP	<%%LGN==<BYTE(3)LGNWHO(9)LGNVER(6)LGNMIN(18)LGNEDT>>

	RELOC	400000

COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1969,1986,1988. ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO
SUBTTL	Table of contents


;               TABLE OF CONTENTS FOR LOGIN
;
;
;                        SECTION                                   PAGE
;    1. Table of contents.........................................   2
;    2. Edit history..............................................   3
;    3. Debugging patch for the monitor...........................  18
;    4. Definitions
;         4.1   Assembly parameters...............................  19
;         4.2   AC assignments....................................  20
;         4.3   Flags in AC F.....................................  21
;         4.4   Command bits and offsets..........................  22
;         4.5   Text concatenation macros.........................  23
;         4.6   Message macros....................................  24
;    5. Program initialization....................................  25
;    6. Command processing
;         6.1   Initialization and dispatch.......................  28
;         6.2   ATTACH - ATTACH command...........................  29
;         6.3   DOLOG - LOGIN command.............................  30
;         6.4   REATTA - REATTACH command.........................  32
;         6.5   SESSIO - SESSION command..........................  33
;         6.6   SETPSW - SET PASSWORD command.....................  34
;         6.7   PASSWO - PASSWORD command.........................  35
;    7. Exit routines
;         7.1   DAYMES - Print daily messages.....................  36
;    8. Accounting routines
;         8.1   ACCCHK - Check for a previous valid LOGIN.........  37
;         8.2   ACTCHK - Check for [SYSTEM]ACCOUNTING.............  38
;         8.3   CHGPSW - Change password..........................  39
;         8.4   PFLCHK - Profile check............................  40
;         8.5   PSWCHK - Check for a legal password...............  41
;         8.6   PPNEXP - Check for PPN expiration.................  42
;         8.7   SETTNL - Set up terminal designator for USAGE.....  43
;         8.8   STACCT - Read a user profiles.....................  44
;         8.9   TIMCHK - Check for access times...................  47
;    9. File I/O
;         9.1   INIFIL - Initialize I/O data storage..............  48
;         9.2   NEWFIL - Check file creation time.................  49
;         9.3   NOTE - Print file(s) specified by /NOTE switch....  50
;         9.4   NOTICE - Print NOTICE.TXT.........................  51
;         9.5   STRMES - Print STR.TXT............................  52
;         9.6   TYPE - Print a file on the terminal...............  53
;   10. Command dispatch tables...................................  54
;   11. Command scanning routines
;        11.1   ERRUKK/ERREXA/ERRILC - Error messages.............  55
;        11.2   GETUSR - Read PPN/path/user name..................  56
;        11.3   PSCAN - Init scanning of switches.................  61
;        11.4   PXSCAN - Init scanning one argument...............  62
;        11.5   SCMPMT - SCAN prompt..............................  63
;        11.6   SWTSCN - Parse switches...........................  64
;   12. Prompt for additional data
;        12.1   ASKACT - Read account string......................  65
;        12.2   ASKATT - Read detached job# for ATTACH............  66
;        12.3   ASKLOG - Read detached job# for LOGIN.............  67
;        12.4   ASKNAM - Read user name...........................  68
;        12.5   ASKPSW - Read password(s).........................  69
;        12.6   ASKRMK - Read remark string.......................  72
;   13. SCAN argument blocks
;        13.1   .ISCAN............................................  73
;        13.2   .OSCAN............................................  74
;        13.3   .PSCAN............................................  75
;   14. SCAN switch tables
;        14.1   ATTACH command....................................  76
;        14.2   LOGIN command.....................................  78
;        14.3   [SET] PASSWORD COMMAND............................  80
;        14.4   REATTA command....................................  82
;        14.5   SESSION command...................................  84
;        14.6   /BATCH switch.....................................  86
;        14.7   /DEFAULT switch...................................  88
;        14.8   /TERMINAL switch..................................  90
;   15. SCAN switch processing
;        15.1   ACCTSW - /ACCOUNT.................................  92
;        15.2   ASGNSW - /ASSIGN..................................  93
;        15.3   BATCSW - /BATCH...................................  94
;        15.4   BATNAM - /BATCH:NAME..............................  95
;        15.5   DEFASW - /DEFAULT.................................  96
;        15.6   DSKPSW - /DSKPRIORITY.............................  97
;        15.7   NOINSW/NOWASW - /NOINFO and /NOWARN...............  98
;        15.8   QUOTSW - /QUOTA................................... 100
;        15.9   RMRKSW - /REMARK.................................. 101
;        15.10  TERMSW - /TERMINAL................................ 102
;        15.11  CHRSWT - Read a character or octal contstant...... 103
;        15.12  HELPTB - Keyword help typeout..................... 104
;        15.13  KEYWRD - Complex switch argument parsing.......... 105
;        15.14  SWITCH - Read SWITCH.INI.......................... 107
;   16. SCAN switch defaulting
;        16.1   TTYDEF - Terminal parameters...................... 108
;   17. Set routines
;        17.1   ASNDEV - Assign devices........................... 109
;        17.2   CRESFD - Create SFDs.............................. 110
;        17.3   PRETMS/POSTMS - Set terminal parameters........... 111
;        17.4   PRVSET - Set all privileged parameters............ 112
;        17.5   USRSET - Set all unprivileged parameters.......... 113
;        17.6   SETACT - Set account string....................... 114
;        17.7   SETCOR - Set core limits.......................... 115
;        17.8   SETDEF - Set DEFAULT.............................. 116
;        17.9   SETDSF - Set DSKFUL............................... 117
;        17.10  SETDSP - Set DSKPRIORITY.......................... 118
;        17.11  SETENQ - Set ENQ/DEQ parameters................... 119
;        17.12  SETGLX - Set GALAXY batch parameters.............. 120
;        17.13  SETIPC - Set IPCF quotas.......................... 121
;        17.14  SETLOC - Set job's location for spooling.......... 122
;        17.15  SETPTH - Set PATH................................. 123
;        17.16  SETSCD - Set scheduler parameters................. 124
;        17.17  SETSPL - Set spooling parameters.................. 125
;        17.18  SETVMX - Set current virtual and physical limits.. 126
;        17.19  SETWAT - Set watch bits........................... 127
;        17.20  SETXXX - Do a SETUUO.............................. 128
;        17.21  TRMOP - TRMOP. UUO loop processor................. 129
;   18. Structure routines
;        18.1   BLDJSL - Build job S/L............................ 131
;        18.2   MNTSTR - Mount structures (set RIPLOG)............ 132
;        18.3   ENTPTH - Create a path............................ 133
;        18.4   STRCHK - Check recomp, empty S/L, etc............. 134
;        18.5   STRPUT - Store structure name..................... 135
;        18.6   STRNXT - Return next structure.................... 136
;        18.7   STRQTA - Check for /QUOTA on structure............ 137
;   19. TTY I/O
;        19.1   TTYPMT - Prompt................................... 138
;        19.2   TTYGET - Read a character......................... 139
;        19.3   Set various terminal parameters................... 140
;   20. UFD setup
;        20.1   UFDSET - Call .UFD to mount/setup STR/UFD......... 141
;        20.2   UFDRCP - Recompute disk usage on random structures 142
;        20.3   UFDTYO - Handle typeout of errors from .UFD....... 143
;        20.4   UFDINI - Initialize block......................... 144
;        20.5   ADDSTR - Add a structure to search list........... 145
;        20.6   GETLOK - Get UFD interlock........................ 146
;        20.7   CLRLOK - Clear the UFD interlock.................. 147
;   21. Usage entry creation
;        21.1   USGATT - Attach................................... 148
;        21.2   USGLOG - Login.................................... 149
;        21.3   USGQUE - Set up QUEUE. UUO blocks................. 150
;        21.4   USGSES - Session.................................. 151
;        21.5   USGVAL - Validate an account string............... 152
;   22. WTO routines
;        22.1   WTOINI - Initialize WTO message................... 153
;        22.2   WTOSND - Send a WTO to OPR........................ 153
;        22.3   WTOCTY - Send text to the CTY if OPR not available 154
;   23. Miscellaneous routines
;        23.1   ACCERR - Process ACCLG. UUO errors................ 155
;        23.2   ATTLGL - Check for a legal ATTACH................. 156
;        23.3   AVLCHK - Check system availability................ 157
;        23.4   BANNER - Print LOGIN banner....................... 158
;        23.5   CVTNAM - Convert 8-bit user name to SIXBIT........ 159
;        23.6   DAYTIM - Print time, date, and weekday............ 160
;        23.7   DETJOB - Report detached jobs..................... 161
;        23.8   DETSTS - Print detached job status................ 162
;        23.9   ERRMSG - Error message handler.................... 163
;        23.10  FAILUR - Check for access failures................ 166
;        23.11  GENTIM - Generate day-of-week and times data...... 167
;        23.12  ISBATC - Determine if a batch job................. 168
;        23.13  ISOPSR - Determine if a subjob of OPSER........... 169
;        23.14  KSYCHK - Check pending KSYS....................... 170
;        23.15  LGLACT/LGLRMK - Check strings..................... 171
;        23.16  MAILCH - Check for mail........................... 172
;        23.17  MAPJOB - Map all jobs with same PPN............... 173
;        23.18  NEWPPN/OLDPPN - Change PPN........................ 175
;        23.19  OTHJOB - Report other jobs same PPN............... 176
;        23.20  PTHCHK - Check a path spec........................ 177
;        23.21  PPNCHK - Check for illegal PPNs................... 178
;        23.22  QUEERR - Process QUEUE. UUO errors................ 179
;   24. OLD LOGIN CRUFT........................................... 180
;   25. OLD END CRUFT............................................. 183
;   26. Keyword lists for /NOINFO and /NOWARN switches............ 187
SUBTTL	Edit history

;316)	FIX TEST FOR WEEKEND TO PREVENT NON-PRIME-TIME USERS FROM
;	LOGGING IN DURING PRIME TIME (SPRS 10-14,021 AND 10-14,046)

;317)	ENLARGE PARAMETER BLOCK FOR STRUUO SO POINTER TO AUXACC
;	ENTRY (RDHED) DOESN'T GET OVERWRITTEN.
;		SPRS 10-14,219 AND 10-14,083

;320)	MAKE LOGIN PREFIX EACH STR.TXT TYPEOUT WITH THE NAME OF THE
;	FILE STRUCTURE FROM WHICH IT CAME.  SPR 10-14,031

;321)	REALLY IMPLEMENT /HELP	(SPR 10-14,031)

;322)	CHANGE PREFIX FOR WARNING ERROR MESSAGES FROM ? TO %
;	TO PREVENT BATCH JOBS FROM FLUSHING.
;		SPRS 10-14,145 AND 10-14,172.

;323)	FIX SECURITY BREACH WHERE BOTH NAME AND PSWD ARE REQUIRED AND
;	NEITHER IS ASKED FOR.	SPR 10-14,306.

;324)	PUT IN TEST SO SETUUO IS SKIPPED IF NO BITS WANT TO BE SET.
;		SPR 10-14190.

;325)	FIX ?LGNIPS IF NO SPACE BETWEEN PPN AND SWITCHES.
;		SPR 10-14,031


;326)	MOVE MISPLACED CLOSE CONDITIONAL	(SPR 10-14,244)

;327)	MAKE LOGIN LOOK AT PHYSICAL CORE LIMIT EVEN IN KA MONITORS.
;		SPR 10-14,264.

;330)	ALLOW PPN TO BE ENCLOSED IN SQUARE BRACKETS ON LOGIN.

;331)	REMOVE ALL REFERENCES TO FL.BRK -- OBSOLETE BATCH HACK.
;		SPR 10-14,021.

;332)	IMPLEMENT /NOWATCH	SPR 10-14,145

;333)	FIX EDITS 221 AND 226 SO LOGIN REALLY WON'T PRINT NOTICE.TXT
;	TO AN OPSER SUBJOB.

;334)	MAKE LOGIN SLEEP BETWEEN RETRIES AFTER BAD PASSWORDS ONLY
;	ONLY ON PTY'S.  SPR 10-14,021.

;335)	CLEAR TMPCOR AT BEGINNING OF FLOW RATHER THAN END
;		SO /TMPCOR SWITCH WORKS.

;336)	FIX EDIT 332, WHICH ONLY DID HALF THE JOB.

;337)	FIX EDIT 333, WHICH COMPLETELY MADE NOTICE.TXT GO AWAY, OPSER
;		SUBJOB OR NOT!
;340)	MAKE ISOPSR ONLY LOOK AT IMMEDIATELY CONTROLLING JOB SO
;		NOTICE.TXT WILL GET PRINTED FOR BATCH JOBS.

;341)	ANOTHER FIX TO THE INFAMOUS EDIT 333, WHICH SOMETIMES
;		TURNED THE TTY INTO A LOCAL COPY TERMINAL
;		(SUPER NO-ECHO).

;342)	WHEN SETTING UP TEMP SEARCH LIST TO READ SWITCH.INI, ONLY LOOK
;		AT STRS WHOSE NAMES BEGIN WITH DSK (DSKA, DSKB, ETC.).

;343)	EXIT ON ^Z.

;344)	IMPLEMENT SWITCHES TO SET TERMINAL CHARACTERISTICS.

;345)	FIX TO EDIT 344 WHERE JOBS WHICH DIDN'T NEED PASSWORDS
;		DIDN'T GET TTY CHARACTERISTICS SET.

;346)	WHEN SETTING UP TO READ SWITCH.INI, ENABLE SYS (IN CASE
;		OF SYSTEMS WITH FUNNY-NAMED FILE STRUCTURES).

;347)	PRINT NOTICE.TXT AND /NOTE:FILE EVEN IF CAN'T LOG IN
;		(SYS NOT AVAILABLE, BATCH ONLY, ETC.)


;350)	MAKE LOGIN GET NAME IF REQUIRED ON ATTACH
;		(SPR 10-14,593)

;351)	MISCELLANEOUS CODE CLEANUP AND SPEEDUP.

;352)	ADD CODE TO SET ENQ/DEQ QUOTAS.

;353)	MAKE SURE RP.LOG GETS SET WHEN RECOMPUTING DISK USAGE.

;354)	ADD "SYSTEM IS UNATTENDED" MESSAGE

;355)	MAKE /NAME LOGIC WORK RIGHT.

;356)	ADD CHECK FOR ACCT.SYS FORMAT VERSION 4 AND DON'T
;		SET ENQ/DEQ QUOTAS IF NOT VERSION 4.

;357)	MISCELLANEOUS CODE CLEANUP ON SUGGESTIONS BY DAL.

;360)	MORE CODE CLEANUP.

;361)	IF DEVPPN ON SYS FAILS, WE USE GARBAGE.  LET'S USE [1,4].

;362)	MAKE /NOTE PRINT OUT BEFORE NOTICE.TXT.

;363)	DO ALL NON-PRIV. SETUUO'S AFTER PRINTING NOTICES.  THIS IS SO
;		THE TRMOP.'S (LIKE SPEED) WON'T SCREW UP PRINTING NOTES.

;364)	DON'T SETUUO THE SPOOL BITS IF SYSTEM DOESN'T HAVE SPOOLING.

;365)	ADD /DEFER AND /NODEFER SWITCHES, AND PREVENT /SPOOL:ALL FROM
;		SETTING BIT FOR DEFERRED SPOOLING.
;366)	FIX BUG INTRODUCED BY EDIT 324 WHERE /DSKFUL:PAUSE NO LONGER
;		WORKS.

;367)	ADD CODE TO SLEEP UNTIL OUTPUT BUFFER EMPTY BEFORE DOING
;		TRMOP.S WHICH MIGHT GARBLE TTY OUTPUT.

;370)	REMOVE ALL REFERENCES TO DATE75 CONDITIONAL

;371)	CODE CLEANUP.

;372)	MAKE LGNUNV INTO A SEPARATE (UNIVERSAL) FILE TO SPEED ASSEMBLY.

;373)	ADD ERROR MESSAGE IN CASE SETUUO FOR DEFER BIT FAILS.

;374)	CHECK ST%GAL (GALAXY) BIT IN 2ND STATES WORD AND DON'T TRY
;	TO SET DEFER BIT IF ZERO.

;375)	IMPROVE ERROR MESSAGE IF TRMOP. FAILS TO TELL FUNCTION CODE.

;376)	IF USER TYPES BAD PATH OR PSWD AND RETRIES, HIS PATH
;	IS SCREWED UP.  FIX: CLEAR PATH BLOCK EACH TIME AROUND.

;377)	DON'T DOUBLE-SPACE /NOTE OR /STR TYPEOUT

;400)	ADD FTINHOUSE CONDITIONAL AND ENCLOSE IN IT THE CODE
;	WHICH WILL ONLY ALLOW FILE STRUCTURES WHOSE NAMES BEGIN WITH
;	'DSK' TO GO INTO YOUR SEARCH LIST WHEN READING SWITCH.INI.
;	THIS CODE FIXES THE BUG IN WHICH SWITCH.INI WAS NOT READ
;	IF 7 OR 8 PRIVATE PACKS PRECEDE THE PUBLIC PACKS IN THE
;	RETURNS FROM SYSSTR.  SINCE THIS IS ONLY A PROBLEM IN
;	SYSTEMS WITH 9 OR MORE FILE STRUCTURES, THE CODE WILL BE
;	CONDITIONED OUT IN FIELD-IMAGE.

;401)	PREVENT /MESSAGE:ALL FROM TURNING ON RANDOM WATCH BITS

;402)	RANDOM CODE CLEANUP -- ALSO REMOVE CODE FOR ENQ/DEQ SO IT
;	CAN BE PUT INTO V57 ALONG WITH SCHED. STUFF IN
;	ONE FELL SWOOP

;403)	IMPROVE LOGIC FOR READING AUXACC.SYS

;404)	(SIGH) FIX EDIT 333 AGAIN.

;405)	REMOVE EDIT 372.

;406)	SLEEP ON DATASETS AS WELL AS PTY'S FOR RETRIES.

;****	RELEASE VERSION 56 -- -- START VERSION 57  ****
;	  NEXT EDIT NUMBER WILL BE 420 TO LEAVE ROOM FOR
;	  MAINTENANCE EDITS.

;420)	CHECK LINE NUMBER JUST BEFORE ATTACH UUO SO JOB WHICH
;	BECOMES DETACHED DURING ATTACH COMMAND CAN'T STEAL TTY0
;					[SPR 15329]
;421)	FIX TEST FOR DETACHED LINE.  [SPR 15330]

;422)	FIX BUG IN RECOMPUTING LOGIC.  [SPR 15396]

;423)	ADD /RTCOMPATABILITY SWITCH.

;424)	MAKE LOGIN USE ALL OF HIGH SEG FOR ACCT.SYS (LOGIN
;	USED TO ALWAYS EXPAND CORE EVEN IF NOT NECESSARY)

;425)	ADD CODE TO READ SCDMAP.SYS AND SET SCHEDULER CLASSES.

;426)	FIX ENQ/DEQ QUOTA ROUTINE.

;427)	CHECK FOR END OF STR LIST IN SYSTEMS WITHOUT FENCE AT USRST1.

;430)	MAKE A -1 ENQ QUOTA ENTRY MEAN DON'T SET THE QUOTA SO ON THE
;	FIRST ENQ UUO MONITOR WILL SUPPLY SYSTEM-WIDE DEFAULT QUOTA

;431)	JUMP AROUND ABOUT 30 INSTRUCTIONS IF NON-6.02 MONITOR
;	WHICH ONLY APPLY TO 6.02.  AREA AFFECTED: PRVSET, PRSET3.

;432)	DO A CRLF AFTER TYPING "NO OPERATOR COVERAGE."

;433)	FIX POSSIBLE BUG IN SCHED. TABLE BUILDING LOGIC, AND CLEAN
;	UP SOME CODE AND ERROR MESSAGES.

;434)	ALLOW /HELP TO BE TYPED WITHOUT A PPN

;435)	ALLOW CR IN RESPONSE TO # PROMPT WITHOUT NASTY ERROR MESSAGE

;436)	ADD CODE TO CALL TSKCHK MODULE.  THIS IS USED ON OUR IN-HOUSE
;	TIMESHARING SYSTEM TO ASK FOR AND RECORD IN THE FACT FILE
;	A COST CENTER AND TASK FOR ACCOUNTING PURPOSES.  THIS CODE
;	IS UNDER THE FTTASK SWITCH WHICH WILL REMAIN 0 IN FIELD IMAGE.
;	THIS CODE IS FOR INFORMATIONAL PURPOSES ONLY AND IS NOT
;	SUPPORTED.  [NOTE SWITCH REMOVED AS PART OF EDIT 716]

;437)	WHEN LOGIN BELIEVES IN ENQ/DEQ AND SCHED. CLASSES, IT
;	FORGETS ALL ABOUT VM.  FIX - SET NEWACT=-1 IF ACCT.SYS
;	VERSION NUMBER IS 3 OR GREATER (NOT JUST 3).

;440)	WHEN SAYING "OTHER JOBS SAME PPN", TELL HIM WHAT JOBS.

;441)	MAKE START ADDRESS AND PROGRAM NAME WORK RIGHT.

;442)	MOVE CALL TO .OSCAN SO A) USER HAS SEARCH LIST WHEN IT IS
;	CALLED AND B) /NAME SWITCH WORKS CORRECTLY WITHOUT THE
;	NECESSITY OF HACKS LIKE EDIT 355.

;443)	FINISH THE JOB OF EDIT 442 BY REMOVING (AT LAST!) SETTMP
;	AND CLRTMP.
;444)	ADD TWO ROUTINES: LOCK TO WRITE-ENABLE HI SEG AND LOCK
;	OUT CTRL-C AND OTHER JOBS WHO WANT TO MODIFY HI SEG, AND
;	UNLOCK TO DO THE REVERSE.

;445)	DON'T TELL [1,2] JOBS WHICH JOBS ARE ALSO LOGGED IN UNDER
;	[1,2] - THERE'RE USUALLY VERY MANY AND YOU DON'T WANT TO KNOW

;446)	FIX SPURIOUS ERROR MESSAGE IN TINY MONITOR, AND DO SOME
;	RANDOM CODE CLEANUP

;447)	MAKE .LOGIN [PROJ,PROG,SFD,SFD,..]/SWITCH WORK

;450)	ADD /NOTICE:ARG SWITCH TO CONTROL PRINTING OF NOTICE.TXT
;	ARG=ALWAYS TO ALWAYS SEE NOTICE
;	ARG=SOMETIMES TO WORK LIKE PROJ/PPN
;	ARG=NEVER TO NEVER SEE IT

;451)	ALLOW USER TO SPECIFY DIFFERENT DEFAULT PATH THEN LOGGED-IN
;	PPN

;452)	USE SECOND 512 ENTRIES OF SCDMAP.SYS FOR BATCH JOBS.

;453)	MAKE DEFAULT FOR /NOTICE BE SOMETIMES.

;454)	FIX BUG IN SFD LOGIC AND TYPO IN /NOTICE LOGIC.

;455)	MAKE /VERBOSITY WORK RIGHT.

;456)	USE BUFFERED TTY OUTPUT.  THIS WILL SPEED UP LOGIN IN
;	REAL TIME ON HEAVILY-LOADED DUAL-CPU SYSTEMS.

;457)	ADD /PATH SWITCH TO DO THE OBVIOUS THING.  THIS WILL OVERRIDE
;	A PATH TYPED ON THE LOGIN COMMAND LINE - I.E.,
;	.LOG [34,35,FOO]/PATH:[24,25,BAR] WILL LOG THE USER IN
;	TO [34,35] WITH A PATH OF [24,25,BAR].

;460)	WHEN RECOMPUTING DISK USAGE, DO AN OUTPUT TTY AFTER EACH
;	STR SO USER THINKS SYSTEM IS STILL ALIVE

;461)	SPRINKLE A FEW OUTPUT TTY,S THROUGHOUT LOGIN SO STUFF
;	GETS TYPED A LITTLE AT A TIME, RATHER THAN A LONG
;	WAIT AND THEN A GUSH OF TTY OUTPUT.  ALSO, RELEASE TTY
;	BEFORE ATTACH SO 2,5 JOBS DON'T GET LEFT LYING AROUNG
;	IN TO WAIT.

;462)	WHEN ATTACHING TO A JOB WHOSE PPN REQUIRES NAME, ONLY ASK
;	NAME IF THERE IS ONE IN ACCT.SYS TO CHECK IT AGAINST

;463)	FIX POSSIBLE BUG IN SCHED. TABLE LOGIC

;464)	REMEMBER TO RESERVE BATMIN JOBS FOR BATCH - I.E., FOR A T/S JOB,
;	ALLOW LOGIN ONLY IF LOGMAX-BATMIN-LOGNUM+BATNUM>0 [SPR 10-15847]

;465)	ADD OUTPUT TTY, TO TYPE RTN TO KEEP USERS PATIENT.
;466)	SAVE ERROR CODE OVER CALL TO UFDSMB AT LGNCAS. [SPR 10-15873]

;467)	MAKE /PATH IN SWITCH.INI WORK.

;470)	ADD /ASSIGN:PHYS:LOG SWITCH TO DO THE OBVIOUS.

;471)	IN EDIT 467, AT NOZAP-1, THE BLT DIDN'T HAVE A -1 AFTER IT
;	SO IT BLT'ED THE SPOOL BITS.  FIX: ADD A -1.

;472)	SPLIT TRMOP.S INTO TWO CLASSES - THOSE WHICH SHOULD BE DONE
;	BEFORE PRINTING NOTICE.TXT, AND THOSE WHICH SHOULD BE DONE
;	AFTER.  CURRENTLY ONLY SPEED IS SET AFTER PRINTING NOTICES.

;473)	/ASSIGN:DEV (NO LOG. NAME) MAKES SCAN HALT.  FIX: IF EOL IS
;	SEEN WHILE PROCESSING /ASSIGN, SET FLAG (R.EOL) SO NO MORE
;	INPUT WILL BE DONE AND REEAT ONE CHAR SO SCAN WILL SEE EOL.

;474)	FIX POSSIBLE STACK PHASE PROBLEM IN PARSE.

;475)	ADD TIMEOUT TO WAITO ROUTINE IN LGNSET & CLEAN UP SOME CODE

;476)	FIX BAD RETURN FROM ERROR RECOVERY ROUTINE IN LGNDSK (UFDSE3)

;477)	CHECK LOGMAX FOR BATCH JOBS AND ADD A NEW CLASS OF ERROR MESSAGE
;	FOR BATCON: REQUE, ERROR CODE 5, MEANING REQUE THIS JOB AND
;	DON'T SCHEDULE ANYBODY ELSE FOR A LITTLE WHILE

;500)	REMOVED BY EDIT 505.

;501)	WHEN SCANNING THRU ALL JOB NUMBERS, SCAN UP TO HIGHJOB, NOT
;	LOGNUM.

;502)	IN A SEQUENCE OF /ASSIGNS, THE LAST ONE IS NOT DONE.
;	CURE: CHANGE AOJL TO AOJLE.

;503)	WHEN LOGMAX IS EXCEEDED LOGIN TELLS YOU AND THEN CLEVERLY
;	PROCEEDS TO LOG YOU IN.  FIX: TREAT REQUE AS A FATAL ERROR.

;504)	EQACT WAS MISTAKENLY PUT IN THE LOW SEG. PUT IT IN THE HI SEG.

;505)	REMOVE EDIT 500, AND CHECK BATMAX RATHER THAN LOGMAX FOR BATCH
;	JOBS.  LOGMAX IS NOW DEFINED TO MEAN THE GREATEST NUMBER OF
;	INTERACTIVE, USER JOBS LOGGED IN.  ALSO ADD CONDITIONAL ASSEMBLY
;	SWITCH BATMAX WHICH WILL TURN ON THE NEW BATMAX/LOGMAX
;	CODE.  THIS REQUIRES EDIT 1055 IN BATCON.

;506)	MAKE .LOG 3,4[5,6] WORK.

;507)	ADD AN ERROR MESSAGE IF THE ENQC. UUO FAILS.

;510)	CLEAN UP SOME ERROR MESSAGES AND ADD SOME HUMAN ENGINEERING.

;511)	FIX BUG IN /CORE LOGIC; ADD SOME ERROR MESSAGES FOR 'THIS
;	CAN NEVER HAPPEN' TYPE STUFF; DO SOME CODE CLEANUP.
;512)	ADD A CHECK IN TYPE ROUTINE TO POPJ RIGHT OUT IF NAME
;	OF FILE IS 0 (NO NAME, NO WILDCARDS) TO AVOID AN
;	INCREDIBLY BIZARRE BUG IN WILD.

;513)	DON'T TURN ECHO OFF UNTIL ENTIRE COMMAND LINE(S) TYPED,
;	SO CONTINUATION LINES WILL ECHO.

;514)	IF UFD INTERLOCK IS BUSY TOO LONG GET NASTY AND BREAK
;	THE DOOR DOWN.

;515)	MAKE SURE RP.LOG ALWAYS GETS SET [QAR 3638]

;516)	CODE CLEANUP.

;517)	DON'T TYPE 'NO OPERATOR COVERAGE' ON EVERY RETRY.

;520)	DON'T BOTHER CLEARING TMPCOR, CLEAN UP SOME COSMETICS.
;	ALSO LOCK OUT CTRL-C WHILE WE HAVE UFD INTERLOCK.

;521)	FIX HANDLING OF /CORE.
;	THIS WILL BE LAST EDIT IN VERSION 57.  NEXT EDIT NUMBER
;	WILL BE 540 TO LEAVE ROOM FOR MAINTENANCE EDITS.

;540)	CHECK CREATION DATE-TIME OF ACCOUNTING FILES AND REBUILD
;	HIGH SEGMENT DATA BASE IF THEY HAVE CHANGED.

;541)	IF NOT JACCTED, GIVE WARNING MESSAGE.

;542)	FIX /VERB AND /MESSAG.

;543)	MOVE CALL TO RNMAIL TO BEFORE THE LOGIN UUO SO IT HAS
;	JACCT AND CAN RENAME MAIL TO USER'S AREA.

;544)	.REQUEST SCAN, WILD, AND HELPER TO SIMPLIFY ASSEMBLY & LOADING

;545)	FIX ONE MORE BUG IN /CORE.

;546)	DETERMINE WHETHER TTY IS A 2741 EARLIER SO IF WE DO THE
;	NUMBER-SIGN PROMPT WE GO INTO TI WAIT RATHER THAN
;	HIBERNATING SO THE KEYBOARD UNLOCKS.

;547)	ALLOW /QUOTA TO FORCE RECOMPUTING EVEN IF OTHER JOBS SAME PPN.

;550)	ADD /SFDPROT:055 SWITCH TO DO THE OBVIOUS.

;551)	REWROTE CODE AT NSPOOL+1 SO /CORE WILL FINALLY WORK CORRECTLY

;552)	REORDERED CODE AROUND ACCT1 THRU ACCT3 AND MOVED
;	CODE FOR TYPING DATE AND TIME TO DAYMES,
;	WHERE IT BELONGS

;553)	FIX BUG IN WAITO ROUTINE.

;554)	ADD /UFDPROT:N SWITCH TO DO THE OBVIOUS.
;555)	DON'T ALLOW ATTACHES AFTER KSYS UNLESS OPR OR SON-OF-OPR

;556)	CLEAN UP THE LISTING

;557)	ADD 2 SECURITY FEATURES.  ASSEMBLY SWITCH NCRYPT CAUSES CODE TO
;	BE GENERATED TO ENCRYPT PASSWORDS BEFORE COMPARING THEM TO THE
;	PASSWORD IN ACCT.SYS (WHICH WAS ENCRYPTED BY REACT ALREADY).
;	THE ENCRYPTION FUNCTION IS A NON-INVERTIBLE FUNCTION SO HACKERS
;	CAN READ ACCT.SYS ALL THEY WANT AND NOT GET INTO SOMEONE'S PPN.
;	ASSEMBLY SWITCH PSWCHG ALLOWS USERS TO CHANGE THEIR OWN PSWDS
;	AT LOGIN TIME BY SPECIFYING THE /PASSWORD SWITCH IN THE LOGIN
;	COMMAND LINE.  THIS CAUSES LOGIN TO PROMPT FOR A NEW PASSWORD
;	AND WRITE IT INTO ACCT.SYS.  NOTE: THE ENCRYPTION FEATURE
;	REQUIRES VERSION 32 OF REACT.

;560)	REMOVE THE SIGNIFICANCE OF SLASH IN PPN (REPLACED BY /NOTICE)

;561)	DO AN EXTENDED LOOKUP OF THE FACT FILES SO WE ALWAYS GET
;	THE FILE'S LENGTH IN WORDS AND DON'T MAKE FACT.SYS SEEM
;	TO BE MESSED UP (HIATUS RECORDS).

;562)	IF WE GET THE SKIP RETURN FROM THE IN UUO THAT READS
;	ACCT.SYS, CHECK THE ERROR CODE RATHER THAN ASSUMING THAT IT
;	IS END-OF-FILE.  IF IT ISN'T, GIVE A MORE ILLUMINATING ERROR
;	MESSAGE THAN "INVALID ENTRY - TRY AGAIN".

;563)	DON'T ENABLE CONTROL-C IF THE USER IS LOCKED INTO RUNNING
;	A PROGRAM BY ACCT.SYS.

;564)	CLEAN UP THE EXIT SEQUENCE.

;565)	RE-INIT STACK EVERY TIME THROUGH LOGIN3.

;566)	TURN RP.LOG OFF IF USER CONTROL-C'S DURING RECOMPUTING
;	SO HE WON'T RECOMPUTE NEEDLESSLY NEXT TIME.

;567)	IF EITHER HALF OF LIB PPN IS ZERO, USE USER'S HALF AS DEFAULT.

;570)	CLEAN UP THE CODE.

;571)	REMOVE FACT FILE CODE FROM LOGIN.  MOVE IT TO A SEPARATE MODULE
;	CALLED FACTOR AND CALL THIS MODULE FROM LOGIN.

;572)	ADD CHECK TO BYPASS BLANK AUXACC.SYS ENTRIES.

;573)	FIX ?LGNSND ERROR IN MONITORS WITH LIMLVL=5.

;574)	SAVE M, N, AND CH OVER STUFBS IF THE MESSAGE IS TYPED
;	SO GARBAGE QUOTAS ARE NOT TYPED.

;575)	MAKE BATCH JOBS WAIT TWICE AS LONG ON UFD INTERLOCKS
;	AS INTERACTIVE JOBS, AND DON'T LET THEM BREAK IT DOWN.

;576)	FIX ?ILL MEM REF WHEN CUSP-TO-RUN DOESN'T EXIST
;577)	ALLOW LOGIN WITH NO AUXACC.SYS IF OPR OR HIS OFFSPRING

;600)	DON'T TYPE ERROR SEVERITY TO ANYTHING BUT A BATCH JOB.

;601)	ADD TWOSEG TO LGNDCL MACRO SO LOGIN COMPILES WITH
;	MACRO V.51

;602)	CHECK JBTLIM TO SEE IF BATCH JOB SO WE DON'T DEPEND
;	ON BATCON BEING CALLED BATCON

;603)	CHECK TIMES-TO-LOG IN FOR BATCH JOBS AND AC.BAT

;604)	FIX PROBLEM WITH 2ND TRY AT LOGGING IN WITH /ASSIGN
;	GIVES ? NULL DEVICE ILLEGAL FROM SCAN

;605)	REWRITE CODE AT NOJBMS THRU TTYDET TO FIX BUG
;	INTRODUCED BY EDITS 602 AND 603

;606)	ALLOW ATTACH AND LOGIN AFTER KSYS FROM LOCAL TTY'S

;607)	FIX PROBLEM IN EDIT 605.

;610)	PASSWORDS IN ACCT.SYS ENTRIES WHICH SPAN DISK BLOCKS CANNOT
;	BE CHANGED.  CURE: REMEMBER ONLY POINTER TO PASSWORD,
;	DON'T WORRY IF WHOLE ENTRY CAN'T BE READ IN ONE DSK READ

;611)	PREVENT STRANGE RACES IN ATTACHES

;612)	MAKE ?MAY NOT LOGIN REMOTE/DATASET/BATCH/BATCH SUBJOB
;	ERRORS FATAL SO BATCON WON'T WASTE TIME
;	TRYING TO LOG THE JOB IN

;613)	CLEAN UP THE LISTING; REMOVE UNREACHABLE CODE AND
;	UNREFERENCED DATA

;614)	EDIT 573 IS MISSING A POPJ. CURE: YES.

;615)	SETNAM TO LOGIN RATHER THAN FLUSH TO EVADE KLUDGE IN STOP1C.

;616)	DON'T CHANGE UFD PROTECTION UNLESS /UFDPROTECT SPECIFIED.

;617)	MORE CHANGES TO CONFORM TO MACRO 52.

;620)	IMPLEMENT /DEFPROT:NNN TO SET DEFAULT FILE PROTECTION.

;621)	DON'T PRINT STRANGE GARBAGE IF USER TYPES .R LOGIN

;622)	DON'T LOG IN A USER WHOSE SCHEDULER CLASS HAS A ZERO
;	CPU QUOTA IF THE CLASS SCHEDULER IS RUNNING.

;623)	ENTRY POINT TO FACTOR IS NOW CALLED .FACTR

;624)	PICK UP WHERE EDIT 610 LEFT OFF AND REALLY FIX /PASSWORD.
;625)	SLEEP BEFORE TYPING ?LGNIET TO MAKE IT HARDER TO BREAK
;	SECURITY (EASIER THAN SLEEPING BEFORE ASKING FOR PASSWORD
;	AND TRAPPING FOR CONTROL-C'S WHILE SLEEPING)

;626)	IF WE DON'T HAVE JACCT, WE'RE BEING DEBUGGED - SO DON'T
;	RECOMPUTE DISK USAGE

;627)	/ASSIGN:PHYS-NAME WITH NO LOGICAL NAME LOSES.  FIX IT.

;630)	MAKE "NO OPR COVERAGE" INFORMATIONAL RATHER THAN WARNING.

;631)	LAST-MINUTE CODE CLEANUP.  THIS WILL BE THE LAST EDIT
;	IN VERSION 60.

;632)	DON'T TRY TO SET SCHEDULER CLASS QUOTAS IF 6.03 SCHEDULER
;	RUNNING IN WMU MODE

;633)	LOCATE USER AT CENTRAL SITE IF LOGGING IN ON A NODE WITHOUT
;	AN LPT
;634)	SEE EDIT HISTORY FOR 672 EDIT

;%60A(634)	SHIPPED WITH 6.03A

;635-637) RESERVED FOR DEC 6.03 SUPPORT

;640)	DO PHYSICAL-ONLY RUN UUO FOR CUSP-TO-RUN (SECURITY)

;641)	DISABLE CONTROL-C JUST BEFORE LOGIN UUO AND ENABLE ONLY IF
;	NO CUSP-TO-RUN SPECIFIED

;642)	IF A LINE OF SWITCH.INI ENDS WITH A /ASSIGN, AND THE NEXT LINE
;	CONTAINS A /ASSIGN, YOU GET ?SCNILC ILLEGAL CHAR IN CMD
;	FIX: CLEAR R.EOL EACH TIME THROUGH ASSIGN

;643)	ENQ QUOTA DOESN'T GET SET UP; SENSE OF TEST INSTRUCTION IS BACKWARDS
;	AT PRSET3+5

;644)	FIX YET ANOTHER CASE OF OFF-BY-ONE ARITHMETIC AT UFDEX1-2

;645)	DELETE SEARCH LIST IF USER TYPES ^C WHILE LOGGED OUT

;646)	?LGNCWR UNDESERVEDLY - WRONG GETTAB VALUE BEING USED

;647)	FIX SWITCH.INI NOT BEING READ IF FACTSW TURNED OFF

;650)	RESERVE BATMIN JOB SLOTS FOR BATCON'S USE

;651)	FIX BUG IN /PASSWORD (BUG ONLY IF NCRYPT TURNED ON)

;652)	DON'T ATTEMPT TO CREATE SFD'S ON STRS THAT ARE WRITE-LOCKED

;653)	REMOVE EDIT 547 WHICH ALLOWS USERS TO AVOID QUOTAS

;654)	FIX EDIT 650 SO ATTACH WORKS DESPITE BATMIN.  SPR#10-23336

;655)	SUPPORT "<" AS PPN DELIMITER ON ATTACH.  THIS IS FOR 2741.
;	SPR #10-23335

;656)	TEACH LOGIN ABOUT FIXED VS. UNFIXED CLASS QUOTAS.  SPR#10-23094.

;657)	DON'T PERMIT DATA-SET LOGINS AFTER KSYS.

;660)	PERMIT DETACHED [1,2] JOB TO LOGIN PTY SUBJOBS. SPR #10-23725.
;	NOTE: ONLY PERMITS SON OF [1,2] NOT SON OF DETACHED OPR OR CTY.

;661)	MOVE LOGIN UUO AFTER MESSAGE TYPE-OUT TO PERMIT PROPER /STR
;	OPERATION.  SPR #10-23847

;662)	EDIT 661 WAS NOT VERY GOOD.  REMOVE IT AND TRY AGAIN.

;663)	FIX UP ALL DATES AND COPYRIGHT STATEMENTS

;664)	DON'T PERMIT MORE THAN LOGMAX JOBS IF BATMAX TESTING
;	IS DISABLED.  SPR #10-24354.

;665)	LOGMAX+1 JOBS CAN LOGIN; SHOULD BE LOGMAX.  SPR #10-24354

;666)	IMPLEMENT ACCOUNT AND REMARK PROMPTS TO ENTER AN ACCOUNT STRING
;	AND A REMARK

;667)	DO UFD ZERO COMPRESSION WHEN RECOMPUTING QUOTA.
;	THIS USES THE DISK. UUO FUNCTION CODE 7 WHICH IS NEW FOR
;	7.01.  THE EFFECT OF UFD COMPRESSION IS TO SPEED UP
;	LOOKUPS AND ENTERS.

;670)	FIX BAD POPJ ON ERROR RETURN FROM CTLJOB UUO. SPR #10-24481

;671)	FIX SOME PROBLEMS INTRODUCED BY EDIT 666.

;672)	ADD BACKROUND BATCH SUPPORT.

;673)	IMPLEMENT ACCOUNT VALIDATION

;674)	PUT IN TEMPORARY FIX SO BATCH JOBS CAN RUN WITH ACCOUNT VALIDATION

;675)	IMPLEMENT /TYPE SWITCH TO SET TERMINAL TYPE.

;676)	SPR # 10-25342  WCL  JUNE-27-78
;	Fix code that checks for necessary job slots for Batch so it checks
;	how many Batch jobs are already logged in
;	Areas affected: PPNGO
;677)	FIX BUG IN 675.  AT NOTTYP INSERT  POP	T,T1.
;700)	FIX BUG WHERE CODE AT BACHEK NEVER GETS EXECUTED.
;701)	IMPLEMENT USAGE ACCOUNTING, SPECIFICALLY ACCOUNT VALIDATION (LGNUSG MODULE)
;702)	FIX A VALIDATION ERROR. ALSO MAKE THE LOGIN MESSAGE REPORT THE TIME
;	AS HH:MM INSTEAD OF HHMM.
;703)	FIX BUGS INTRODUCED WITH 702
;704)	DON'T LOSE OWNER PPN FOR NESTED PTY SUBJOBS. SPR #10-27223
;705)	MAKE  /PATH[,,SFD] USE LOGGED-IN PPN AS DEFAULT. SPR #10-27073
;706)	/BAH
;	1)  ADD ATTACH, LOGIN, AND SESSION IPCF MESSAGES SO THE ACCOUNT
;	DAEMON CAN DO USAGE ACCOUNTING WITH SESSION ENTRIES.
;	2)  ADD /BATSEQ, /BATNAM, AND /REQID SWITCHES SO BATCON CAN PASS
;	BATCH JOB INFORMATION TO THE ACCOUNT DAEMON VIA LOGIN IPCF MESSAGES
;707)	/BAH ADD SETUUO FUNCTION TO SET OPERATOR PRIVILEGES FOR GALAXY 4 SUPPORT
;	3)  FIX UP EDIT 701'S ERROR MESSAGES
;710	REPEAT LOGMAX CHECK JUST PRIOR TO LOGIN UUO
;	SPR 10-27195
;711	CHECK THAT STR NAME IN AUXACC IS "FULL FILE STRUCTURE NAME"
;	SPR 10-27402
;712	/MSL/BAH 22-MAY-79 Display SEARCH, .REQUEST info during compilation
;713)	/MSL/BAH 22-MAY-79 Limit /DSKPRI value by ACCT.SYS
;714)	/MSL/BAH 22-MAY-79 Warn user if account expires within one month
;715)	/MSL/BAH 22-MAY-79 Let user logging in attach if PPN already has detached job
;716)	/MSL/BAH 22-MAY-79 Set up search list before calling OSCAN (for SWITCH.INI), thus
;	allowing account switches, UFD defaults, etc. in SWITCH.INI
;	This rewrite completely changes the order of things (such as
;	where account validation and accounting is done).  As a result,
;	the FTTASK switch (an unsupported switch used by our in-house
;	systems) no longer applied as written and has been removed.
;717)	/MSL/BAH 22-MAY-79 No NOTICE.TXT if Job Capacity Exceeded
;720)	/MSL/BAH 22-MAY-79 Clear search list before LOGOUT when flushing (c.f. ed.645)
;721)	/MSL/BAH 22-MAY-79 Fix so last error try also gets a FACT entry
;722)	/MSL/BAH 22-MAY-79 Make ENCODE global (SPR 10-23055)
;723)	/MSL/BAH 22-MAY-79 Clear FL.ACC when done with ACCT instead of waiting for AUXACC
;724)	/MSL/BAH 22-MAY-79 Fill AUXACC pointer table, even if early EOF
;725)	/BAH 31-MAY-79 IF A JOB REQUIRES AN ACCOUNT AND/OR REMARK AND THE
;	TERMINAL IS A PTY AND AN ACCOUNT/REMARK WAS NOT SUPPLIED, USE THE
;	CONTROLLING JOB'S ACCOUNT (IF IT EXISTS) AND ALLOW A NULL REMARK.
;726	IF A USER HAS ZERO LOGGED-IN QUOTA ON A STR IN HIS SEARCH LIST
;	DON'T TRY TO CREATE AN SFD ON IT.
;727	COMMAND LIST IS ONE TOO LONG.  ALSO FIX A PJRST P,.USAGE
;730	SEARCH OF AUXACC.SYS FOR PPN IS OFF BY 1.
;	SPR 10-28333.
;731	REMOVE EDIT 730
;732	20-SEP-79/BAH CORE UUO TO EXPAND HIGH SEGMENT CAN FAIL IF 1) SOMEONE
;	IS SAVING LOGIN OR IF 2) IN AN SMP ENVIRONMENT, ANOTHER CPU IS
;	EXECUTING THE SAME CODE WITH THE HIGH SEGMENT WRITE-ENABLED.
;	TO GIVE THE MONITOR TIME TO CATCH UP, SLEEP A SECOND AND TRY AGAIN
;	(3 TIMES) IF THE CORE UUO FAILS.
;733	4-OCT-79/BAH  ADD ATTACH:ARG SWITCH.  IF ATTACH:IGNORE IS IN SWITCH.INI OR TYPED,
;	THEN DON'T PROMPT USER FOR ATTACH MESSAGE IF ANY DETACHED
;	JOBS UNDER HIS PPN.  IF ATTACH:ASK IS IN SWITCH.INI OR TYPED, THEN
;	ASK USER IF HE WANTS TO ATTACH OR LOGIN.  THE DEFAULT IS
;	ALWAYS ASK IF ANY DETACHED JOBS.  SEE EDIT 715.
;734	22-OCT-79/BAH SET U.ACTS AND U.RMRK TO -1 FOR SCAN.  ALSO ZERO  THEM
;	BEFORE FILLING IN THE CHARACTERS SO THE USAGE FILES GET THEM RIGHT.
;735	7-NOV-79/BAH  MAKE LOGIN SEARCH ACTSYM.UNV INSTEAD OF ACCSYM.UNV.
;736	25-JAN-80/BAH  EDIT 723 CLEARED FL.ACC TOO SOON CAUSING PASSWORDS
;	NOT TO BE CHANGED.  ALSO EDIT 716 DELETED THE CALL TO .USAGE THAT
;	SENT A LOGIN MESSAGE TO THE ACCOUNT DAEMON.  ALSO CHANGE THE CALL TO
;	.SIXSW FOR THE /BATNAM SWITCH TO .SIXQW.
;737	14-FEB-80/BAH IF A USER TRIES TO LOGIN WITH AN ILLEGAL PROGRAMMER
;	NUMBER, THEN LOGIN GOES INTO A LOOP READING ACCT.SYS AND REBUILDING
;	ITS TABLE.
;740	SPR 10-28750 Edit 627 caused SCAN to read the slash after a name
;	twice in an /ASSIGN switch if there were more switches.
;741	11-Apr-80/BAH QAR 10-03985 Don't type out error message setting
;	operator privileges if the monitor version number is earlier than
;	7.00.
;742	24-Apr-80/BAH LOGIN doesn't send the terminal designator in its
;	LOGIN and ATTACH IPCF messages to the account daemon.  Include
;	a common routine to find the terminal designator, line number and
;	node name of the job -- SETTNL.  Also include a switch to defer
;	TTY output /TTDEFER.
;743	29-april-80/FRS SPR 10-28831
;	Change put in FACTOR to check to see if job being attached to
;	is DAEMON and [1,2].  If so, skip trying to write FACT entry.
;744	5-May-80/WSM Allow new form for specifing settty switches for LOGIN.
;	ie /TERMINAL:(NOPAGE,SPEED:300,WIDTH:80,TYPE:VT52) instead of a
;	random set of several switches. Also, cleanup some SCAN switch
;	handling. Use standard version macro from MACTEN.
;	Fix recovery from %LGNTTI Terminal type invalid errors
;745	6-May-80/WSM Improve command scanning especially for SESSION
;746	6-MAY-80/WSM Fix the bug that didnt set path to area that
;	already existed if user had no login quota or software write-locked
;	Also, type warning if any PATH. uuo fails.
;747	1-Jun-80/WSM Complete implementation of /TERMINAL by adding
;	keywords [no]UC, NOFILL and [no]TIDY. Also, dont prompt with
;	password if the user types it on the same line.
;750	2-Jun-80/WSM Include debugged DDT patch for testing LOGIN under 7.01
;	(QAR 10-04145) Add /DEFBUFFER:n switch to set default number
;	of disk buffers, like .SET DEFAULT BUFFER n command
;751	3-Jun-80/WSM (QARs 10-42046, 10-04172) LOGIN loops if invalid PPN given.
;	Edit 737 didnt fix the problem as reported.
;
;;61(751) released with 7.01
;Start V62 for Galaxy 4.1
;
;752	17-Jun-80/WSM Fix the usage accounting entries for ATTACH and
;	SESSION commands.  Remove unreachable code.
;753	27-Jun-80/DPM
;	Add /BATINT:[NO/YES] and /BATSTR:ooo so BATCON can set the Batch
;	operator intervention values and Batch stream numbers. This is
;	required for Galaxy 4.1 and later versions of QUASAR and ORION.
;	These switches apply only to Batch jobs and are ignored for
;	timesharing jobs. Also before we open the TTY, determine if the job
;	is a Batch job and don't turn off echoing. Note: SCNSER must also
;	check this at TTYRS1 plus a few and not turn off echoing when an
;	unlogged in job starts running LOGIN.
;754	8-Jul-80/WSM Add some fixes for accounting support
;	  1) Include expiration date in UFD (.RBDED)
;	  2) Dont type NOTICE.TXT on errors with SESSION command
;	  3) Expand ATTACH message to include target job number
;	  4) Dont allow retries on SESSION command
;	  5) Dont do checks to see if user can LOGIN if SESSION command
;	  6) Flush receive queue correctly when waiting for ACK
;	  Improve date/time printing (use SCANs routines)
;	  Add lost instruction @RICC to fix ^C problems
;755	SPR #10-29629	RKB	14-Jul-80
;	(published 15-Jul as edit 752) Fix a bug in edit 651 so /PASSWORD
;	will work properly with NCRYPT set.
;756	Be consistant in handling account string and remark. If its
;	-1 (for SCAN and ACTDAE's benifit) it hasnt been specified.
;	Anything else should be treated as ASCIZ text
;757	SPR #10-29879		12 AUG 80
;	Creating SFDs on all structures is annoying, so lets let the
;	user say whether he wants it to happen or not. Install the
;	/[NO]SFDCREATE switch, which allows him to say 'DONT CREATE'
;760	If you logged in and recomputed disk usage at or before 4 minutes
;	22.192 seconds after midnight, LOGIN would die with ?Illegal
;	address in UUO trying to compress the UFD.
;	Also, change REPEAT 0 to IFN FTMAIL for RNMAIL routine.
;761	23-Sep-80/WSM Convert to more UUOSYM and ACTSYM symbols
;	Allow /LOCATE to take sixbit node name
;	Improve usage accounting routines--Dont let user in if account
; 	validation is required, and ACTDAE isnt around or talking to us
;762	28-Sep-80/WSM Cleanup error messages and interface with BATCON.
;	In the process, fix ?Job capacity errors from dumping the job.
;	Dont output ^D when you fail to login. Thats old stuff.
;	Define new bit in error macros to WTO to operator. This removes
;	all the "Please call the operator" messages. If ORION isnt running
;	that text is appended to the users output.
;763	30-Sep-80/WSM (QAR 10-04663) Improve ATTACH query logic. Give
;	a small SYSTAT output (job, program, state), and if/when we
;	attach to a job, preserve the user/monitor state.
;764	Use ND to set number of days for warning on %PPN will expire message
;765	6-Oct-80/WSM (QAR 10-04728) Improve things a little
;	bit if the unsupported PSWCHG feature test is turned on
;	by asking for new password twice with echo off
;766	20-Oct-80/WSM Remove part of edit 761 which allowed LOCATE to take SIXBIT name.
;	It requires more monitor/GALAXY support than was thought.
;	Dont create a UFD of AUXACC says its write-locked.
;	(QAR 10-04816) Change BLANK to BLANKS to be consistent with
;	INITIA and monitor SET TTY commands
;767	24-Nov-80/WSM (QAR 10-04969) LOGIN is too hard to be debugged.
;	Add more tests for R.DBUG
;770	24-Nov-80/WSM LOGIN loses /OPTION when asking for detached jobs.
;	Save /OPTION around second .PSCAN call. Requires kludge that assumes
;	SCANs OPTION storage is .NMUL##-3 (until OPTION made global)

;771	16-Dec-80/WSM Add support for ACTDAE returning an account string
;	from a validation request. (It may be a default, or case changed)
;772	15-Jan-81/WSM (QAR 10-05259) Allow switches on ATTACH to attach to
;	the job in either user or monitor mode.
;773	15-Jan-81/WSM Allow OPR[1,2] to login in w/o an account string if
;	the PID of ACTDAE doesnt exist in 5 seconds.
;	Dont complain if the LOCATE UUO fails and he is trying to locate
;	to the central site (node 0)
;774	30-JAN-81/WSM (QAR 10-05356) Allow SESSION command to be invoked
;	from CCL entry point and look for TMP:LGN. Always send account
;	string to ACTDAE for possible defaulting.
;	(QAR 10-05356) Path not also set correctly if we cant create an
;	SFD in the path. Get around SCAN bug with .LOGIN/ACCOUNT:"" using
;	SWITCH.INI when it shouldnt
;775	17-Feb-81/WSM (QAR 10-05478) Fix up more scanning problems with
;	the /ACCOUNT switch.  Change some UUOSYM symbols that changed.
;	Allow indirect command files for SESSION command.
;776	19-Mar-81/WSM (QAR 10-05786) Fix blanks in TERMINAL scanning
;	(QAR 10-05797) Dont type expiration date on ATTACH
;777	7-Apr-81/WSM (QAR 10-05931) Fix a one instruction race
;	(QAR 10-05925) Remove checks for level C disk service!
;	(QAR 10-05942) Check response from ATTACH question for YES/NO
;	(no QAR) Remove checks for old scanner service
;1000	9-Apr-81/WSM Move setting batch stream number before STRUUOs
;	to change search list so we dont confuse QUASAR.
;
;1001	9-Jul-81/WSM Increase MAXFS to 7.01 defined value of 10; handle
;	more AUXACC entries than can fix in a S/L more gracefully.
;1002	16-Nov-81/WSM Bypass accounting if we are attaching to the
;	ACTDAE job so we dont get hung if ACTDAE is ^Ced.
;	Improve ATTACH job query logic to show default and preserve
;	/OPTION around .PSCAN better.
;1003	23-Nov-81/WSM Insert fix for ^C, and removed window where user
;	can ^C out of cusp-to-run. This was incorrectly published as
;	edit 754 to LOGIN as CMCO 571.1.
;1004	9-Mar-82/WSM (QAR 10-06880) Explicitly BLT scan block words to
;	zero in routine PARSE.
;	(QAR 10-06495) /SCAN not set /NOSFDCREATE and the SFD doesnt exist.
;1005	27-Aug-82/DPM (QAR #10-02018) Correct logic to GETTAB ACTDAE pid.
;Start of version 63 for 7.02
;
;1100	14-JUL-81/WSM Add support for new terminal switches, and /DEFAULT:(BIGBUF)
;	Allow new batch switch syntax of /BATCH:(args) too.
;1101	30-Jul-81/BCM (SPR 10-30609) Add a new UUO to do LOGMAX/BATMAX
;	quota checking.  This is necessary to eliminate race between two
;	simultaneous LOGINs where LOGNUM could be 1 greater than LOGMAX.
;1102	21-Aug-81/BCM (SPR 10-30832) Correct test for no
;	class scheduler at PRSET4 and NOTHER.
;1103	8-Sep-81/WSM Add (under FTMAIL) /[no]MAILCHECK switch to control
;	scanning for new mail. Check for mail on ATTACH too.
;1104	3-Feb-82/WSM Add new TRMOP. to see if we are on a full-SCNSER-PTY
;	so we know we can turn the echo off.
;1105	26-Apr-82/WSM Rip out lots of code, and call DPM's new UFDSET routine
;	to handle UFD setup. This is the same routines that PULSAR/MDA
;	use, so it should all do it the same way.
;1106	29-Jun-82/WSM Fix up all error messages and macros (This also
;	fixing the ^C ?Ill mem ref bug introduced with edit 1105)
;
;1107	22-Apr-83/DPM
;	1. Turn on echo if called by SCAN for continuation lines.
;	2. Don't make junk FACT file entries on LOGIN failures.
;	3. Allow /QUOTA:(str,...).
;	4. If a name is required, make sure it's non-zero.
;
;1110	26-Apr-83/DPM
;	Eliminate problems with I/O to unassigned channel by doing buffered
;	OUTSTRs to the TTY.  This is a lot more efficient than doing buffered
;	I/O and saves lots of OUTPUT TTY, instructions.
;
;1111	 8-Jul-83/DPM
;	1. Add a few missing calls to TTYOUT.
;	2. Disconnect line if too many command format errors.
;	3. Call .ISLGI to determine logged-in/out status in FLUSH routine.
;	4. Finally after all these years, add verbosity checking in ERRMSG
;	   routine.  Attn. future LOGIN hackers: calls to .PSCAN wipe .FLVRB!
;	5. Fix up listing stuff in .ERR. macro.
;
;1112	31-Aug-83/DPM
;	Don't set UFD protection to <000> when recomputing disk usage on
;	structures not in AUXACC.
;
;1113	12-Sep-83/DPM
;	1. FATAL, WARN, INFO, etc. still don't list.
;	2. Make references to .POPJ1 external in LGNMS.
;
;1114	21-Sep-83 /DPM
;	1. Remove ZEROSL.  No longer needed now that the LOGOUT UUO does this.
;	2. Remove unreferenced and non-existant symbols from GLOB macros.
;	3. Remove unreferenced low seg locations.
;	4. Repeated ^Cs typed while recomputing disk usage gives ill mem ref.
;	   ERRMSG isn't recursive. Fix Control-C trap.
;
;1115	12-Jan-84 /DPM
;	Add missing AC in test instruction (UFDSET + a bunch).
;
;
;1116	18-Feb-84 /DPM
;	If a logging in job is located at a station with an MCR, then locate
;	it at the central station to allow spooled LPT output to get printed.
;
;63(1115) released with 7.02
; Start V64 for 7.03
;
;2000	5-Apr-84 /DPM
;	1. Remove old FACT file code.
;	2. Re-write /ASSIGN switch processor to eliminate all bugs.
;	   R.NXSW and R.EOL crock flags also go away.
;
;2001	7-July-84 /Tarl
;	Start massive changes to move all validation into ACTDAE.
;	For today, remove edit 557. This edit (PSWCHG and NCRYPT)
;	is no longer relevant; Encryption is entirely handled by
;	ACTDAE, and password changing is handled by the .SET PASSWORD
;	monitor command.
;
;2002	1-Sep-84 /Tarl
;	More massive changes to move validation into ACTDAE.
;	Move code around so that we don't check password until ACCT,
;	which will lead to slightly different behaviour under some
;	conditions. Remove all logic to keep files in hiseg, remove
;	all logic to read ACCT, AUXACC, SCDMAP. Add code to ask
;	for profile from ACCT.
;
;2003	7-Sep-84 /Tarl
;	Allow username as well as PPN on login	lines, allow attach
;	without giving PPN.
;
;2004	26-Dec-84 /DPM
;	Rewrite code added by edit 2003 to make LOGIN/BYPASS work.
;	Add /WATCH:CONTEXTS.
;
;2005	27-Dec-84 /DPM
;	Merge LGNMS into LOGIN.  Default FTMAIL on.  Define MAILFN and
;	MAILEX to be the mail file name and extension respectively, with
;	the defaults being 'MAIL  ' and 'TXT' for compatibility with DEC's
;	mail system (MS).
;
;2006	 2-Jan-85 /DPM
;	Add /TERMINAL:(EIGHTBIT,ESCAPE,QUOTE,UNPAUSE).  Put all old TTY
;	switched under OLDTTY conditional.  Put all old DEFAULT switches
;	under OLDDEF conditional.  These conditionals will be removed in
;	the next release of LOGIN (version 65).
;
;2007	 2-Jan-85 /DPM
;	Fix password echoing problem created by edit 2003.
;
;2010	 3-Jan-85 /DPM
;	Add support for [SET] PASSWORD command and /PASSWORD switch.
;	Fix password parsing problems (8-bit stuff) caused by edit 2003.
;
;2011	 7-Jan-85 /DPM
;	Fix numerous bugs relating to SESSION command scanning and setting
;	bogus account strings.  Completely separate SESSION handling from
;	the mainstream code for reading clarity and cleanliness.  This has
;	the somewhat undesirable side effect of breaking some user's /ACCOUNT
;	defaults in SWITCH.INI, but no one really uses usage accounting, do
;	they?
;
;2012	14-Jan-85 /DPM
;	Fix bugs introduced by editg 2003 that prevented logging in with
;	user names and losing a path spec (i.e. LOGIN DPM[,,FOO] didn't
;	work).  Also allow ATTACH [PPN] or user name without job number.
;	Turn on /TERMINAL switch for ATTACH command.  Do lots of general
;	clean up work.
;
;2013	16-Jan-85 /DPM
;	Begin massive code cleanup.
;
;2014	18-Jan-85 /DPM
;	Lots more code cleanup.  Rearrange lots of code into subroutines so
;	it may eassily be called from several places.  Support SWITCH.INI
;	processing on ATTACH commands.  Remove old stand-alone batch switches
;	now superseded by /BATCH:(args).
;
;2015	22-Jan-85 /DPM
;	Merge all modules into one.  Remove the need for LGNUNV universal.
;	Fix bugs associated with setting paths.
;
;2016	24-Jan-85 /DPM
;	Replace all IPCF code to create usage entries with QUEUE. UUOs.
;	Look at the OTS and application words of the extended LOOKUP
;	block to determine if new mail exists.
;
;2017	28-Jan-85 /DPM
;	SWITCH.INI won't get scanned and the user is needlessly prompted
;	for an account string if:
;	 1. The first attempt at LOGIN failed and ...
;	 2. The PPN typed was valid but wasn't the intended one and ...
;	 3. The PPN typed didn't require an account string but ...
;	 4. The correct PPN did require an account string which would
;	    normally be found in SWITCH.INI
;	SETOM .OPTN because SCAN zeroed it the last time it failed to find
;	SWITCH.INI, causing all subsequent calls to .OSCAN to fail.  A real
;	bitch to figure out.  Also fix numerous bugs caused by edits 2001,
;	2002, and 2003 which caused /PATH not to work any more.
;
;2020	30-Jan-85 /DPM
;	Add code to change user names to support multiple PPN insertions
;	in REACT.
;
;2021	 6-Feb-85 /DPM
;	Set context and saved page quotas.  Set the job's search list to
;	the system search list if /BYPASS.  Also set infinite FCFS and
;	logged out quotas.
;
;2022	 8-Feb-85 /DPM
;	People are wondering what job and PPN are being attached to these
;	days since the new ATTACH command syntax allows just a job number,
;	PPN, or a user name.  Therefore, always type "Attaching to job ..."
;	message.  Also do a better job chosing monitor or user mode.
;
;2023	11-Feb-85 /DPM
;	Add support for locked accounting files.  Make .LOGIN 10,# work.
;	Plug holes in program-to-run logic by cleaning up exit code.  Also
;	remove definitions for ACs M and WD as they're no longer used.
;
;2024	15-Feb-85 /DPM
;	Use correct AC when testing for LOGIN after KSYS times out.
;	Prevent loop typing KJOB in FLUSH.  Fix bug that expected passwords
;	to be typed on the CTY.
;
;2025	20-Feb-85 /DPM
;	If a user hosts into the -10 and is physically located at a node
;	that has an MCR, then locate the job at the central site to which
;	will cause queued output to be spooled.  Also fix problem that
;	prevented watch bits in the profile from getting set.
;
;2026	28-Feb-85 /DPM
;	Fix up usage of /CORE switch argument by removing .STCLM SETUUO.
;	Dynamically determine if BATMAX checking should be done by GETTABing
;	the MPB feature test (BATMAX is meaningful only in an MPB environment).
;
;2027	 7-Mar-85 /DPM
;	Add support for files-only PPNs and password expiration dates.
;
;2030	20-Mar-85 /DPM
;	Fix account string validation bug.  Make /LOCATE with no argument
;	default to the central station.  Increase MAXFS to 12.
;
;2031	 4-Apr-85 /DPM
;	Report ACCT. UUO error codes when we fail to set the account string.
;	Fix ATTACH, LOGIN, and SESSION message generation.
;
;2032	17-Apr-85 /DPM
;	Respect /NAME when used with /BYPASS.
;
;2033	26-Apr-85 /LWS
;	Include account string arg block when doing UGACC$ function
;	with QUEUE. ACTDAE expects an account string when doing
;	access checking, especially when an account string is required.
;
;2034	 7-May-85 /DPM
;	Add support for QUEUE. UUO timeout.  Incorporate CHAR8 into LOGIN.
;	This table is only needed when running LOGIN under a 7.02 monitor.
;	8-bit character translation is done using the CHTRN. UUO under
;	later monitors (** no supporting code in LOGIN yet **).  Also fix
;	a few minor problems reported in QARs.
;
;2035	10-May-85 /DPM
;	Be more defensive against logging into [10,777776].
;
;2036	14-May-85 /DPM
;	Add routine CHRTRN to do 8-bit chraracter translation via UUO
;	or old-style translation table.
;
;2037	22-May-85 /DPM
;	Forgot to include account string in ATTACH validation message.
;
;2040	22-Jul-85 /DPM
;	Include IPCFS. and IPCFR. UUO error codes in SETIPC errors
;
;2041	15-Aug-85 /LEO
;	Do copyrights.
;
;2042	27-AUG-85 /DPM
;	Remove references to AE.PCH and key off .AEPCT being -1 to
;	indicate a password change is required.
;
;2043	 3-Sep-85 /DPM
;	Fix off-by-one bug when checking PTY line number.
;
;2044	12-Sep-85 /DPM
;	Can't attach to jobs 36, 72, 108, ...
;
;2045	14-Sep-85 /DPM
;	Warn when password expiration will happen soon.
;
;2046	23-Oct-85 /DPM
;	Setup ALLPPN early so /BYPASS works under OPSER.
;
;2047	28-Oct-85 /DPM
;	Re-init switch storage on restarts.
;
;2050	11-Nov-85  /DPM
;	Upgrade to version 6 profile format.
;
;2051	22-Jan-86  /DPM
;	/WATCH doesn't work because the watch bits belong in the RH
;	half of the SETUUO AC, not in the LH.
;
;2052	19-Mar-86  /DPM
;	Edit 2051 fixed the watch bits coming from the profile, not the
;	command line switch.
;
;2053	19-Mar-86  /DPM
;	LOGIN 10,# syntax appears not to create a UFD.  Not true.  LOGIN
;	just creates another unique PPN after the UFD(s) have already
;	been created.  Remove left over cruft from V63.
;
;2054	 9-Apr-86  /DPM
;	Move call to CHGPSW back before the LOGIN UUO.  If the password
;	change fails, you really want to abort the login.  Also correct
;	ordering of similar calls in the ATTACH and LOGIN code for the
;	same reasons.
;
;2055	14-Apr-86  /DPM
;	Fix test for CTY by setting up GETLCH bits before storing DEVOPR.
;
;2056	16-Apr-86  /DPM
;	Never prompt for a name if L.SOPR is set; works like passwords.
;
;2057	27-Aug-86  /DPM
;	Check FAILFL in ASKPSW to avoid letting a malicious user know
;	the target PPN really doesn't exist.
;
;2060	22-Jan-87  /KDO
;	Defend against QUEUE. UUO hangs.
;
;2061	04-Feb-87  /KDO
;	Fix a race condition between MONRET and CTRL/C intercept code.
;
;2062	13-Feb-87  /KDO
;	Verify the job number on an attach before telling ACTDAE.
;
;2063	11-Mar-87  /KDO
;	Fix edit 2060.
;
;2064	04-May-87  /KDO
;	Always type SYS:LOGIN.TXT after successfully logging in.
;
;2065	09-Sep-87  /LWS
;	Bomb if batch job and profile does not exist.

; Start Version 65(3000) for 7.04
;
; 3001	30-Dec-87/JJF
;	Add support for "Logged-in PPN" GETTAB.  Allows LOGIN to 
;	determine if the user's current PPN isn't the one s/he actually 
;	logged in under, and to "pivot" back home before logging out.
;
; 3002	13-Jan-88/KDO
;	Fix the loop in GETPSW to allow a password that is thirty-nine
;	characters long.
;
; 3003	17-Mar-88/KDO
;	If SCAN restarts .PSCAN, whether its for /HELP or after an error,
;	jump to .MONRT to exit.
;
; 3004	26-Apr-88/KDO
;	Fix KJOB/BATCH processing.
;
; 3005	4-Jul-88/KDO
;	Allow LOGIN to run with JLOG turned off for 7.03 compatibility.
;	In case of a FATAL error, use the LOGIN UUO to get back in.
;
; 3006	 3-Aug-88/DPM
;	Don't bomb out login if user says /PASSWORD but accounting file
;	prohibits password changes.
;
;3007	 3-Aug-88/DPM
;	Remove local definition of .GTLPN GETTAB table.  7.04 UUOSYM
;	has this symbol now.
;
;3010	 3-Aug-88/KDO
;	Allow password changes if a password change is required (even if
;	password changes are prohibited).
SUBTTL	Debugging patch for the monitor


; THIS PATCH WILL ALLOW YOU TO DEBUG LOGIN UNDER NORMAL TIMESHARING.
; THE PATCH IS EXECUTED VIA FILDDT AND CAUSES YOUR TERMINAL TO RUN
; LOGIN FROM HAKSTR/HAKPPN WHILE ALL OTHER TERMINALS USE SYSPPN.
; NOTE THAT THE "$" ARE DOLLAR SIGNS.  BEFORE EDITING THIS PATCH OUT
; AND APPLYING IT WITH FILDDT, CHANGE THE DOLLARS SIGNS TO ESCAPES.
;
; THIS PATCH HAS BEEN TESTED UNDER THE 7.03 MONITOR.  IT WILL NOT WORK
; WITH PREVIOUS MONITORS.


	REPEAT 0,<

PATCH/HAKPPN:10,,56
HAKSTR:$"/DSKB/
LOGLDB:-1
LOGHAK:PUSHJ P,. 2
JRST MSTART
CAME U,LOGLDB
POPJ P,
PUSHJ P,SAVE1
MOVE P1,SGANAM+.JDAT
CAME P1,LOGTXT
POPJ P,
MOVE P1,JBTSTS(J)
TLNE P1,JLOG
POPJ P,
MOVE P1,HAKSTR
MOVEM P1,SGADEV+.JDAT
MOVE P1,HAKPPN
MOVEM P1,SGAPPN+.JDAT
POPJ P,

COMCON$:
SGSET9-FTMP/JRST LOGHAK
GJOB2 5/JFCL
CLOGIN 1/JRST RUNAME
.CPJOB[$Q<JOBNOX:
TTYTAB JOBNOX[
$Q DDBLDB[$Q<LDB:
LOGLDB/LDB

>>>;END REPEAT 0
SUBTTL	Definitions -- Assembly parameters


ND ACTFMT,6		;ACCOUNTING FILE/PROFILE FORMAT NUMBER
ND SUPNOT,1		;SUPPRESS NOTICE.TXT IF / IN PPN
ND UFDSEC,^D5*^D60	;SECONDS TO WAIT FOR UFD INTERLOCK
ND OLDTTY,0		;INCLUDE OLD-STYLE TTY SWITCHES NOW SUPERSEDED BY
			; /TERMINAL:(A,B,C...)
ND OLDDEF,0		;INCLUDE OLD-STYLE DEFAULT SWITCHES NOW SUPERSEDED BY
			; /DEFAULT:(A,B,C,...)
ND CLSDEF,0		;MAKE KJOB/CLEAR THE DEFAULT
ND CTXDLN,20		;CONTEXT UUO DATA BUFFER LENGTH
ND MAILDV,<SIXBIT/DSK/>	;DEFAULT MAIL FILE DEVICE
ND MAILFN,<SIXBIT/MAIL/>;DEFAULT MAIL FILE NAME
ND MAILEX,<SIXBIT/TXT/>	;DEFAULT MAIL FILE EXTENSION
ND MAILPP,<XWD -1,-1>	;DEFAULT MAIL FILE PPN (-1 MEANS USE PPN)
ND MAILBT,1		;BIT IN APPLICATION FIELD OF EXTENDED LOOKUP
			; BLOCK THAT INDICATES NEW MAIL EXISTS
ND DATLEN,50		;LENGTH OF QUEUE. UUO DATA BLOCK
ND QUELEN,50		;LENGTH OF QUEUE. UUO ARGUMENT BLOCK
ND RSPLEN,20		;LENGTH OF QUEUE. UUO RESPONSE BLOCK
ND ACCTIM,^D20		;TIMEOUT FOR REQUESTING ACCOUNTING INFO
ND ACCTI2,^D60		;TIMEOUT FOR RETRIES ON ACCOUNTING INFO
ND ACCTRY,^D10		;RETRY LIMIT FOR ACCOUNTING INFO REQUESTS
ND CHGTIM,^D20		;TIMEOUT FOR CHANGING PARAMETERS
ND USGTIM,^D60		;TIMEOUT FOR MAKING USAGE ENTRIES
ND RETRYM,^D10		;NUMBER OF RETRIES A USER IS GIVEN TO TYPE THE PPN,
			; PASSWORD, ETC.
ND RETRYN,^D5		;NUMBER OF RETRIES BEFORE UNCONDITIONALLY DISALLOWING
			; ACCESS WHETHER OR NOT PPN, PASSWORD, ETC. ARE VALID
ND RETRYS,^D3		;NUMBER OF SECONDS TO SLEEP BETWEEN RETRIES
			; THIS MAKES IT HARD FOR A USER TO TELL WHAT FAILED
			; (SECURITY THROUGH OBSCURITY)
ND TTYSLP,2		;NUMBER OF MINUTES TO SLEEP BEFORE INPUT TIMEOUT
ND PDLSIZ,60		;DEPTH OF STACK
ND DVICES,20		;NUMBER OF DEVICES ASSIGNABLE BY /ASSIGN
ND EXPWRN,^D31		;DAYS TO WARN IF PPN WILL EXPIRE SOON
ND PSWWRN,^D7		;DAYS TO WARN IF PASSWORD WILL EXPIRE SOON
ND STRMAX,^D36		;MAXIMUM NUMBER OF STRS IN SYSTEM
ND MAXFS,^D12		;MAXIMUM NUMBER OF FILE STRUCTURES PER USER
ND WTOCHN,^D240		;NUMBER OF CHARACTERS MAXIMUM IN WTO BUFFER
SUBTTL	Definitions -- AC assignments


	F=0		;FLAGS

	T1=1		;FOUR
	T2=T1+1		; PRESERVED
	T3=T2+1		;  ACS
	T4=T3+1		;   ...

	P1=5		;FOUR
	P2=6		; PRESERVED
	P3=7		;  ACS
	P4=10		;   ...

	N=P3		;LAST SCANNING WORD RESULT
	C=P4		;LAST SCANNING CHARACTER RESULT

	PP=12		;PROJECT PROGRAMMER PAIR

	P=17		;PUSHDOWN POINTER

IOC==1	;RANDOM I/O CHANNEL

	MSGOK==1		;FLAG TO TYPE MEESSAGE EVEN IF USER HAS SEEN IT
	FNAME==2		;FLAG TO REQUEST FILE NAME PRINTING
	STONLY==4		;FLAG TO PRINT STR NAME ONLY
SUBTTL	Definitions -- Flags in AC F


;LEFT HALF

FL.LGN==1	;JOB IS LOGGED IN
L.MANY==2	;ON IF MORE THAN ONE CONTROLLING JOB IN CHAIN
FL.WKD==4	;ON IF THIS IS A WEEKDAY
FL.BYP==10	;SET IF BYPASSING THE ACCOUNTING SYSTEM
FL.BSJ==20	;SET IF BATCH JOB SUBJOB
FL.BAT==40	;SET IF THIS JOB IS A BATCH JOB
FL.GPN==100	;GENERATE A PROGRAMMER NUMBER
L.OPR== 200	;SET IF MY TTY IS OPR OR CTY
L.SOPR==400	;SET IF I AM ON PTY UNDER OPR, CTY OR A [1,2] JOB
FL.WLD==1000	;WILD CARD PROGRAMER
FL.CTY==2000	;TTY IS A CTY

;RH OF F

R.ACRE==1	;SET IF ANY CREATES ALLOWED ON ANY STR'S
R.ASTR==2	;SET IF ANY STR'S IN THIS JOB'S SEARCH LIST
R.PTYJ==10	;PTY JOB
R.COMA==20	;COMMA HAS BEEN TYPED WHEN TELLING OTHER JOBS

;SPECIAL PPN CHARACTERS

UNISYM=="#"	;CHARACTER FOR CREATE UNIQUE PPN
UNIPRG==777776	;INTERNAL VALUE FOR UNIQUE PPN
DEFPRG==777777	;DEFAULT (INTERNAL TO REACT) PPN
SUBTTL	Definitions -- Command bits and offsets


DEFINE	CMDS,<
;;	PFX, NAME , HELP ,PROCES,PROMPT,OSCNAM
X	LOG,LOGIN ,LOGIN ,DOLOG ,<#>   ,<>
X	ATT,ATTACH,ATTACH,DOATT ,<#>   ,<>
X	RTA,REATTA,REATTA,REATTA,<New terminal: >,<>
X	SES,SESSIO,SESSIO,SESSIO,<>    ,<>
X	PSW,PASSWO,PASSWO,PASSWO,<>    ,<>
X	SET,SET   ,PASSWO,SETPSW,<>    ,<>
X	KJB,KJOB  ,LOGOUT,KJOB  ,<>    ,<KJOB,LOGOUT>

>


	ZZ==-1
DEFINE	X	(PFX,NAM,HLP,PRC,PMT,OSC),<
	COM'PFX==<ZZ==ZZ+1>
	CM.'PFX==1B<COM'PFX>
>

	CMDS
SUBTTL	Definitions -- Message macros


;ERROR CODES FOR TYPES OF LOGIN ERRORS (FOR PTY JOBS)
;**** NOTE ERROR COMMENTS SHOULD ALL BEGIN WITH A QUESTION MARK
;**** AND FOR PTY JOBS INCLUDE AN ERROR TYPE OF THE FORM
;**** (#) WHERE # IS ONE OF THE FOLLOWING:

;ERR.NF==1	;NON FATAL (Not used by BATCON or LOGIN)
;ERR.SF==2	;SEMI FATAL (Not used by BATCON or LOGIN)
 ERR.FT==3	;FATAL - CANCEL JOB
 ERR.SS==4	;STOP SCHEDULING (Shutdown batch stream but requeue job)
 ERR.RQ==5	;REQUE JOB (Requeue job)

IF1,<

;FLAGS IN LEFT HALF OF EF
EF.SYS==1B1	;SYSTEM ERROR
EF.ERR==1B2	;FATAL ERROR
EF.WRN==1B3	;WARNING
EF.INF==1B4	;INFORMATION LINE (IN [])
EF.REQ==1B5	;REQUE JOB
EF.WTO==1B6	;WTO ERROR TO OPERATOR (ANY ERROR MESSAGE TYPE)
EF.SIL==1B7	;SUPPRESS NOTICE.TXT TYPEOUT ON FATAL ERRORS
EF.FMT==1B8	;FORMAT ERROR (USER GETS TO RETRY)
EF.ACF==1B9	;ACCESS FAILURE

;SUPER FATAL ERROR -- NEVER RETURNS
;THE BATCH STREAM IS SHUTDOWN, AND THE JOB IS REQUEUED
	DEFINE	STOP(PFX,TXT,FLG,MOR),<
	.ERR.	EF.SYS,PFX,<TXT>,FLG,MOR
>

;FATAL ERROR (HOWEVER, SYSTEM IS STILL OK)
	DEFINE	FATAL(PFX,TXT,FLG,MOR),<
	.ERR.	EF.ERR,PFX,<TXT>,FLG,MOR
>

;WARNING MESSGAE
;CALL WITH:
;	WARN	PREFIX,<TEXT>
	DEFINE	WARN(PFX,TXT,FLG,MOR),<
	.ERR.	EF.WRN,PFX,<TXT>,FLG,MOR
>

;SEMI-FATAL ERROR--BATCON SHOULD REQUE JOB AND STOP SCHEDULING
;FOR A LITTLE WHILE
;CALL WITH:
;		REQUE	PREFIX,<TEXT>
;		  NEVER RETURN
	DEFINE	REQUE(PFX,TXT,FLG,MOR),<
	.ERR.	EF.REQ,PFX,<TXT>,FLG,MOR
>

;INFORMATION MESSAGE (PRINTED IN [])
;CALL WITH:
;	INFO	PREFIX,<TEXT>
	DEFINE	INFO(PFX,TXT,FLG,MOR),<
	.ERR.	EF.INF,PFX,<TXT>,FLG,MOR
>

DEFINE	.ERR.	(TYP,PFX,TXT,FLG,MOR),<
	PUSHJ	P,[XLIST
		   PUSHJ P,ERRMSG	;CALL ERROR MESSAGE
		   IFB  <MOR>,<XWD 0,''PFX''>
		   IFNB <MOR>,<XWD MOR,''PFX''>
		   IFB  <FLG>,<TYP![ASCIZ\TXT\]>
		   IFNB <FLG>,<TYP!FLG![ASCIZ\TXT\]>
		   LIST]
	>

> ;END IF1
SUBTTL	Program initialization


START:	TDZA	17,17		;CLEAR AC17 ON A NORMAL START
	MOVEI	17,1		;SETUP A 1 ON A CCL START
	SETZB	0,ZZBEG		;PREPARE TO CLEAR CORE
	MOVEI	16,1		;CLEAR THE AC'S
	BLT	16,16		; ..
	MOVE	T1,[ZZBEG,,ZZBEG+1] ;CLEAR OUT THE LOWSEG
	BLT	T1,ZZMAX-1	; ..
	MOVEM	17,SAOFST	;SAVE STARTING OFFSET
	MOVE	P,PDPLST	;SET UP THE STACK
	PUSHJ	P,GTTABS	;GET INFORMATION
	PUSHJ	P,ISLGO		;CHECK TO SEE IF WE ARE LOGOUT (BEFORE 7.04)
	MOVE	T1,[4,,RICC]	;LOAD UP JOBINT BLOCK
	MOVEM	T1,INTBLK	; ..
	MOVX	T1,ER.ICC	;ASK FOR CONTROL-C
	MOVEM	T1,INTBLK+1	; INTERCEPT
	MOVEI	T1,INTBLK	;CONTROL-C INTERCEPT BLOCK
	MOVEM	T1,.JBINT##	;STORE FOR THE MONITOR
	RESET

	PJOB	T1,		;Get our job number
	MOVEM	T1,THSJOB	;Store for later
	PUSHJ	P,ISBATC	;Is this a Batch job ?
	SKIPA			;No
	TLO	F,FL.BAT!L.SOPR	;This guy is a real son of a batch
	PUSHJ	P,.TOINI##	;INITIAL TTY
	PUSHJ	P,TTYNEC	;SET TTY NO ECHO
	PUSHJ	P,.T8BIT##	;ENABLE 8-BIT TTY I/O
	PUSHJ	P,GENTIM	;GENERATE DAY-OF-WEEK AND TIMES DATA
	PUSHJ	P,NOTBAT	;INIT TTY/JOB STATUS BITS
	PUSHJ	P,CTYCHK	;CHECK CTY STATUS
	GETLIN	T1,		;GET MY TTY NAME
	MOVEM	T1,MYTTY	;SAVE IT
	TLNN	T1,777777	;DETACHED?
	SETOM	DETFLG		;YES, SET FLAG
	MOVE	T3,TTBITS	;GET TTY BITS
	TXNN	T3,GL.CTY	;IS MY TTY THE CTY?
	CAMN	T1,SAVOPR	;OR THE OPR?
	TLO	F,L.OPR		;YES. REMEMBER THAT IN FLAG AC
	MOVE	T3,THSJOB	;GET OUR JOB NUMBER
	TRMNO.	T3,		;GET TTY UDX
	  SETZ	T3,		;SO WHAT?
	MOVEM	T3,TTYUDX	;SALT AWAY FOR TRMOP. STUFF
	SETOM	OOBEG		;SET SCAN SWITCH BLOCK TO -1
	MOVE	T1,[XWD OOBEG,OOBEG+1]
	BLT	T1,OOMAX-1
	MOVEI	T1,RETRYM	;GET MAX NUMBER OF RETRIES
	MOVEM	T1,LOGTRY
	DATE	T1,
	MOVEM	T1,TDATE	;SAVE FOR LATER

	PJRST	COMMAN
GTTABS:	MOVSI	T2,-GTBLEN	;MAKE AOBJN POINTER
GTTAB1:	MOVE	T1,GTBARG(T2)	;GET AN ARGUMENT
	GETTAB	T1,		;DO THE GETTAB
	  MOVE	T1,GTBFAI(T2)	;FAILED: USE THIS VALUE
	XCT	GTBXCT(T2)	;STORE THE RESULT
	AOBJN	T2,GTTAB1	;GET ALL OF THE INFORMATION
	LDB	T1,[POINTR UFDPRT,RB.PRV]
	MOVEM	T1,UFDPRT	;RIGHT-JUSTIFY THE UFD PROTECTION CODE
	POPJ	P,		;RETURN WHEN DONE


; THE ARGUMENTS TO THE TABS MACRO ARE:
;
;	1) GETTAB ARGUMENT
;	2) VALUE TO USE SHOULD THE GETTAB FAIL
;	3) INSTRUCTION TO STORE THE RESULT (WITHOUT THE AC)

DEFINE TABS,<

	XLIST

	XX	<%CNOPR>	,<'CTY   '>	,<MOVEM SAVOPR>
	XX	<%CNSJN>	,<^D64>		,<HRRZM L.MXJB>
	XX	<%CNSTS>	,		,<MOVEM STATES>
	XX	<%CNST2>	,		,<MOVEM STATS2>
	XX	<%CNTIC>	,<^D60>		,<MOVEM JIFFIE>
	XX	<%CNDTM>	,		,<MOVEM CURDTM>
	XX	<%CNFLN>	,		,<MOVEM FRCLIN>
	XX	<%CNDAE>	,		,<MOVEM MONVER>
	XX	<%NSHJB>	,		,<MOVEM L.HJIU>
	XX	<%LDMFD>	,<1,,1>		,<MOVEM MFDPPN>
	XX	<%LDSYS>	,<1,,4>		,<MOVEM SYSPPN>
	XX	<%LDFFA>	,<1,,2>		,<MOVEM ALPPPN>
	XX	<%LDHLP>	,<2,,5>		,<MOVEM HLPPPN>
	XX	<%LDQUE>	,<3,,3>		,<MOVEM QUEPPN>
	XX	<%LDUFP>	,<775B8>	,<MOVEM UFDPRT>

	XX	< 0,,.GTLOC>	,		,<MOVEM LOCSTA>
	XX	<-1,,.GTLOC>	,		,<MOVEM JOBSTA>
	XX	<-1,,.GTPPN>	,		,<MOVEM PPN>
	XX	<-1,,.GTPRG>	,		,<MOVEM PRGNAM>
	XX	<-1,,.GTPRV>	,		,<MOVEM PRIVWD>
	XX	<-1,,.GTLPN>	,		,<MOVEM LPNPPN>
	XX	<-1,,.GTNM1>	,		,<MOVEM NAME>
	XX	<-1,,.GTNM2>	,		,<MOVEM NAME2>
	XX	<-1,,.GTCNO>	,		,<MOVEM CHGNO>
	XX	<-1,,.GTKCT>	,		,<MOVEM KCTNUM>
	XX	<-1,,.GTRCT>	,		,<MOVEM DSKRDS>
	XX	<-1,,.GTWCT>	,		,<MOVEM DSKWTS>
	XX	<-1,,.GTTIM>	,		,<MOVEM RUNTIM>
	XX	<-1,,.GTJLT>	,		,<MOVEM JLOGTM>
	XX	<-1,,.GTLIM>	,		,<MOVEM BATLIM>
	XX	<-1,,.GTEQJ>	,		,<MOVEM ENQLOK>

	LIST

>  ;END OF TABS MACRO
; BUILD THE TABLE OF GETTAB ARGUMENTS
;
DEFINE	XX (ARG,FAI,XCT),<EXP <ARG>>

GTBARG:	TABS
GTBLEN==.-GTBARG


; BUILD THE TABLE OF VALUES TO USE IN CASE OF FAILURE
;
DEFINE	XX (ARG,FAI<0>,XCT),<EXP <FAI>>

GTBFAI:	TABS


; BUILD THE TABLE OF INSTRUCTIONS TO SAVE THE RESULT
;
DEFINE	XX (ARG,FAI,XCT),<EXP <<<XCT>&<777037,,777777>>+<<T1>B12>>>

GTBXCT:	TABS
ISLGO:	MOVE	T1,PRGNAM	;GET THE NAME OF THIS PROGRAM
	CAMN	T1,['LOGOUT']	;IS IT LOGOUT?
	SKIPN	JLOGTM		;HAS THIS JOB EVER LOGGED IN?
	POPJ	P,		;NO--RETURN
	PUSHJ	P,.ISLGI##	;IS THE JOB CURRENTLY LOGGED IN?
	  SETOM	IAMLGO		;NO--MUST BE BEFORE 7.04
	POPJ	P,		;RETURN
SUBTTL	Command processing -- Initialization and dispatch


COMMAN:	MOVE	T1,[SCILEN,,SCIBLK] ;POINT TO SCAN ARGUMENTS
	PUSHJ	P,.ISCAN##	;CALL SCAN TO GET COMMAND
	JUMPGE	T1,COMMA2	;JUMP IF WE HAVE A COMMAND
	SKIPN	SAOFST		;CCL ENTRY?
	JRST	COMMA1		;NO
	PUSHJ	P,.SIXSW##	;READ COMMAND NAME FROM TMPCOR
	JUMPE	N,COMMA1	;GIVE UP IF NO KEYWORD
	MOVE	T1,[IOWD COMLEN,COMLST] ;POINT TO LIST OF COMMANDS
	MOVE	T2,N		;GET KEYWORD
	PUSHJ	P,.LKNAM##	;SOME FLAVOR OF PASSWORD?
COMMA1:	  TLOA	T1,(1B0)	;STILL DON'T KNOW WHAT THE COMMAND IS
	MOVEI	T1,-COMLST(T1)	;CONVERT FROM -M,,COMLST+N TO N
COMMA2:	MOVN	T2,THSJOB	;MAKE NEGATIVE
	JOBSTS	T2,		;READ JOB STATUS
	  SETZ	T2,		;???
	JUMPGE	T1,COMMA3	;SKIP THIS STUFF IF COMMAND IS KNOWN
	MOVEI	T1,COMLOG	;ASSUME A LOGIN COMMAND
	TXNN	T2,JB.ULI	;JOB LOGGED IN?
	SKIPE	IAMLGO		;RUNNING LOGOUT?
	MOVEI	T1,COMKJB	;YES--THEN MUST BE A KJOB COMMAND
COMMA3:	TXNE	T2,JB.ULI	;JOB LOGGED IN?
	TLO	F,FL.LGN	;REMEMBER FOR LATER
	MOVE	T3,COMLST(T1)	;GET COMMAND NAME
	MOVEM	T3,COMNAM	;SAVE IT
	MOVN	T3,T1		;SAVE COMMAND VALUE
	MOVNM	T3,COMIDX	;SAVE FOR LATER
	MOVSI	T4,400000	;GET A BIT
	LSH	T4,(T3)		;POSITION IT
	HLLM	T4,COMIDX	;SAVE IT TOO
	MOVSI	T3,(CM.LOG)	;BIT TO TEST
	TLNE	F,FL.LGN	;ALREADY LOGGED IN?
	TDNN	T3,COMIDX	;YES--LOGIN COMMAND?
	JRST	COMMA4		;LET IT GO
	SKIPN	.JBDDT##	;SKIP IF DDT LOADED
	FATAL	KOD,<Please KJOB or DETACH>,EF.SIL
COMMA4:	TXNN	T2,JB.UJC	;JACCT?
	WARN	IDJ,<I do not have JACCT>
	HRRZ	T1,COMIDX	;GET COMMAND INDEX
	MOVE	T2,COMNAM	;GET COMMAND NAME
	MOVEM	T2,.NMUL##	;INCASE OF ERROR
	MOVEI	T2,.TSIXN##	;TYPEOUT ROUTINE
	MOVEM	T2,.LASWD##	;SAVE IT TOO
	PJRST	@COMDSP(T1)	;DISPATCH
SUBTTL	Command processing -- ATTACH - ATTACH command


DOATT:	SETOM	NOWBIT		;CAN ALWAYS ATTACH
	PUSHJ	P,TTYECH	;SET TTY ECHO
	PUSHJ	P,PSCAN		;INIT PARTIAL LINE SCANNER
	CAIL	C,"0"		;RANGE
	CAILE	C,"9"		; CHECK
	JRST	ATTAC1		;NOT A JOB NUMBER
	PUSHJ	P,.REEAT##	;BACKUP ONE CHARACTER
	MOVEI	T1,[ASCIZ /a job number/]
	MOVEM	T1,HELP
	PUSHJ	P,.DECNW##	;READ JOB NUMBER TO BE ATTACHED TO
	MOVEM	N,ATTJBN	;SAVE JOB NUMBER
	PUSHJ	P,SWTSCN	;CHECK FOR SWITCHES
	CAIN	C," "		;SITTING ON A SPACE?
	PUSHJ	P,.TIAUC##	;PRIME THE PUMP
	HRLZ	PP,ATTJBN	;GET TARGET JOB NUMBER
	HRRI	PP,.GTPPN	;GETTAB TABLE
	GETTAB	PP,		;READ THE PPN
	  MOVEI	PP,0		;SHOULDN'T FAIL
	PUSHJ	P,USRDEF	;DO /BYPASS LEGALITY CHECKING
	CAIN	C,","		;ATTACH JOB,PASSWORD?
	JRST	ATTACX		;YES
	JUMPG	C,ATTAC1	;EOL?
	JRST	ATTAC2		;ONWARD
ATTAC1:	MOVEI	T1,[ASCIZ /a PPN or user name/]
	MOVEM	T1,HELP		;SAVE INCASE INPUT TIMEOUT
	PUSHJ	P,GETUSR	;READ USER ID (PPN/PATH/NAME)
	SKIPE	FAILFL		;ACCESS FAILURE?
	JRST	ATTAC2		;YES
	SKIPN	AENTRY+.AEPPN	;DID WE GET A REASONABLE PROFILE?
	JRST	DOATT		;NO--PROBABLY THE RESULT OF A SCAN ERROR
	JUMPE	PP,DOATT	;IGNORE BLANK LINES
ATTAC2:	MOVE	T1,[2,,U.PATH+.FXDIR] ;INCASE OF ERROR
	SKIPE	U.PATH+.FXDIR+2	;ANY SFDS GIVEN?
	FATAL	SIP,<SFDs illegal in PPN specification >,EF.FMT,.TDIRB##
ATTACX:	PUSHJ	P,ASKPSW	;READ PASSWORD
	SKIPE	PP		;REALLY HAVE A PPN?
	PUSHJ	P,ASKATT	;YES--SEE IF OTHER JOBS SAME PPN
	  FATAL	NJS,<No job number specified>,EF.SIL
	MOVX	T1,%NSHJB	;
	GETTAB	T1,		;GET THE HIGHEST JOB IN USE
	  TRNA			;ERROR - BE SAFE: DON'T ALLOW IT
	CAMGE	T1,ATTJBN	;IS THIS A VALID JOB NUMBER?
	JRST	NOATT		;NO - TELL THE USER
	MOVEI	T1,.GTPPN	;CHECK TO SEE THAT THIS
	HRL	T1,ATTJBN	; JOB HAS THE PPN HE
	GETTAB	T1,		; CLAIMED IT DOES. THE MONITOR
	  SETZ	T1,		; MAKES THIS CHECK BUT LOGIN
	CAMN	T1,PPN		; COULD HAVE A BUG WHICH WOULD
	JRST	ATTAC3		; ZAP A USER.
	MOVE	PP,T1
	MOVEM	PP,PPN
ATTAC3:	SKIPE	AENTRY+.AEPPN	;ALREADY HAVE PROFILE?
	JRST	ATTAC4		;YES
	MOVE	T1,[EXP <QA.IMM!1B17!.UGPPN>] ;QUEUE. BLOCK CODE
	MOVE	T2,PPN		;PPN THAT WE WANT
	PUSHJ	P,STACCT	;GET ACCT DATA
	  SETOM	FAILFL		;NO SUCH PPN
ATTAC4:	MOVE	T1,[.ACTRD,,T2]	;SET UP UUO AC
	MOVEI	T2,2		;TWO WORDS FOLLOWING (JOB NUMBER IN T3)
	MOVE	T3,ATTJBN	;GET TARGET JOB NUMBER
	MOVEI	T4,U.ACTS	;POINT TO STORAGE
	ACCT.	T1,		;READ CONTROLLING JOB'S ACCOUNT STRING
	  JFCL			;LET ACTDAE WORRY ABOUT IT
	SETZM	AENTRY+.AEPCT	;CLEAR PASSWORD CHANGE REQUIREMENTS
	PUSHJ	P,PSWCHK	;CHECK FOR A LEGAL PASSWORD
	SKIPE	FAILFL		;ANY FAILURES?
	JRST	NOATT		;TOO BAD
	PUSHJ	P,PFLCHK	;PERFORM PROFILE CHECKS
	PUSHJ	P,NEWPPN	;CHANGE PPN
	PUSHJ	P,BLDJSL	;BUILD JOB SEARCH LIST
	  SKIPA			;FAILED
	PUSHJ	P,SWITCH	;READ SWITCH.INI
ATTAC5:	SKIPLE	U.PASS		;/PASSWORD SEEN (LOGIN TURNED INTO ATTACH)?
	PUSHJ	P,CHGPSW	;YES--REQUEST CHANGE
	PUSHJ	P,AVLCHK	;CHECK FOR SYSTEM AVAILABILITY
	PUSHJ	P,KSYCHK	;CHECK FOR PENDING KSYS
	MOVE	T3,CNTLJT	;GET CONTROLLING JOB'S BITS (PROBABLY OURS)
	TXNN	T3,GL.LCP!GL.CNE!GL.HDP ;LOCAL COPY, COMMAND NO ECHO OR HDX?
	PUSHJ	P,TTYECH	;SET TTY ECHO
	PUSHJ	P,MAILCH	;CHECK FOR MAIL
	PUSHJ	P,OLDPPN	;SWITCH BACK TO OUR OLD PPN ([2,5])
	PUSHJ	P,USGATT	;SEND USAGE MESSAGE TO [SYSTEM]ACCOUNTING
	PUSHJ	P,PRETMS	;DO PRE-MESSAGE TRMOPS
	PUSHJ	P,LGNMES	;TYPE SYS:LOGIN.TXT
	PUSHJ	P,POSTMS	;DO POST MESSAGE TRMOPS
	PUSHJ	P,ATTLGL	;SEE IF TARGET JOB AND PPN AGREE
	PUSHJ	P,ATTJOB	;ATTACH TO THE TARGET JOB
	PJRST	MONRET		;GO FINISH UP
SUBTTL	Command processing -- KJOB - KJOB command


KJOB:	PUSHJ	P,GTTABS	;FILL IN ALL THE GETTABS
	PUSHJ	P,CHKLPN	;CHECK TO SEE IF WE'RE PIVOTED
	PUSHJ	P,PSCAN		;INIT PARTIAL LINE SCANNER AND EAT SWITCHES
	JUMPG	C,ERREXA	;CHECK FOR JUNK ON COMMAND LINE
	SKIPN	REPARS		;ANYTHING TYPED?
	JRST	MONLGO		;JUST /HELP
	PUSHJ	P,SWITCH	;DO SWITCH.INI PROCESSING
	SKIPGE	T1,U.KJOB	;GET TYPE OF KJOB
	MOVEI	T1,1		;ASSUME /FAST
	TLNE	F,FL.BAT	;BATCH JOB?
	SETZ	T1,		;YES
	MOVEM	T1,U.KJOB	;UPDATE
	MOVE	T1,TTBITS	;GET TTY BITS
	TXNN	T1,GL.ITY	;PTY?
	TLNE	F,FL.BAT	;OR BATCH?
	CLRBFI			;CLEAR TYPEAHEAD
	GETPPN	PP,		;GET OUR PPN
	  JFCL			;JACCT
	MOVSI	T1,.STTLM	;FUNCTION,,ZERO
	SETUUO	T1,		;CLEAR TIME LIMIT
	  WARN	CCT,<Can't clear time limit>

	MOVX	T1,1		;
	MOVEM	T1,CCWAIT	;NO MORE CTRL/C'S ALLOWED
	SKIPE	ENQLOK		;HAVE ANY OUTSTANDING LOCKS?
	FATAL	ENQ,<Job has outstanding eternal ENQ. locks set>,EF.SIL
	PUSHJ	P,TRMCLS	;CLEAR SCREEN
	PUSHJ	P,TYPLPN	;TELL USER WE PIVOTED BACK IF NEEDED
	SKIPE	U.NMSG		;/NOMESSAGE?
	PUSHJ	P,OTHJOB	;CHECK FOR OTHER JOBS SAME PPN
	PUSHJ	P,DELTMP	;DELETE TMP FILES
	PUSHJ	P,SETPTH	;SET PATH TO [,]
	PUSHJ	P,CHKQTA	;CHECK QUOTAS
	PUSHJ	P,SUMARY	;PRINT SUMMARY
	SKIPE	T1,.JBDDT##	;DEBUGGING?
	JRST	(T1)		;YES, GO TO DDT
	SETZB	T3,T4		;BLOCK FOR TMPCOR UUO
	MOVE	T1,[.TCRDD,,T3]	;DELETE DIRECTORY
	TMPCOR	T1,		;DO IT
	  JFCL			;DOESN'T MATTER
	LOGOUT			;****END OF JOB****
SUBTTL	Command processing -- DOLOG - LOGIN command


DOLOG:	PUSHJ	P,BANNER	;TYPE LOGIN BANNER
RESTAR:	MOVE	T1,[OOBEG,,OOBEG+1] ;SET UP BLT
	SETOM	OOBEG		;INIT FIRST WORD
	BLT	T1,OOMAX	;INIT SWITCH STORAGE
	MOVE	T1,[N.ZER##,,N.ZER##+1] ;SET UP BLT
	SETZM	N.ZER##		;CLEAR FIRST WORD	
	BLT	T1,N.EZER##	;ZERO SCAN'S SCAN BLOCK FOR /RUN
	SETOM	.OPTN##		;INIT /OPTION INCASE RESTART
	MOVE	P,PDPLST	;RE-INIT STACK
	PUSHJ	P,ACCLOG	;DO LOGMAX CHECKING
	PUSHJ	P,FAILUR	;CHECK LOGIN FAILURE FLAG
	PUSHJ	P,GENTIM	;GENERATE DAY-OF-WEEK AND TIMES DATA
	PUSHJ	P,PARSE		;GO PARSE LOGIN LINE
	PUSHJ	P,ASKPSW	;READ PASSWORD(S)
	PUSHJ	P,NEWPPN	;CHANGE PPN
	SKIPN	FAILFL		;DON'T BOTHER WITH SEARCH LIST STUFF IF FAILING
	PUSHJ	P,BLDJSL	;BUILD JOB SEARCH LIST
	  SKIPA			;FAILED
	PUSHJ	P,SWITCH	;READ SWITCH.INI
	PUSHJ	P,ASKNAM	;READ USER NAME IF REQUIRED
	PUSHJ	P,ASKACT	;READ ACCOUNT STRING IF REQUIRED
	PUSHJ	P,ASKRMK	;READ REMARK STRING IF REQUIRED
	PUSHJ	P,PSWCHK	;CHECK VALAIDITY OF PASSWORD
	PUSHJ	P,PPNEXP	;CHECK FOR PPN/PSW EXPIRATION
	PUSHJ	P,PFLCHK	;CHECK USER'S PROFILE
	PUSHJ	P,TIMCHK	;CHECK FOR LEGAL ACCESS TIMES
	SKIPE	FAILFL		;ANY FAILURES?
	JRST	TRYAGN		;TOO BAD
	PUSHJ	P,ASKLOG	;ASK LOGIN/ATTACH PREFERENCE IF DETACHED JOBS
	  JRST	ATTAC5		;USER ATTACHING INSTEAD OF LOGGING IN A NEW JOB
	PUSHJ	P,AVLCHK	;CHECK FOR SYSTEM AVAILABILITY
	PUSHJ	P,KSYCHK	;CHECK FOR PENDING KSYS
	MOVE	T1,AENTRY+.AEPRV;AND PRIV WD
	MOVEM	T1,PRIVWD	;STORE PRIV WORD
	PUSHJ	P,SETGLX	;SETUP GALAXY BATCH PARAMETERS
	PUSHJ	P,OTHJOB	;REPORT OTHER JOBS SAME PPN
	PUSHJ	P,MNTSTR	;MOUNT ALL STRS (SET RIPLOG)
	PUSHJ	P,CHGNAM	;CHANGE USER NAME IF NECESSARY
	SKIPLE	U.PASS		;/PASSWORD SEEN?
	PUSHJ	P,CHGPSW	;YES--REQUEST CHANGE
	PUSHJ	P,USGLOG	;SEND USAGE MESSAGE TO [SYSTEM]ACCOUNTING
	PUSHJ	P,STRCHK	;CHECK NEED TO RECOMPUTE, EMPTY S/L, ETC.
	PUSHJ	P,PRVSET	;SET PRIV'ED JOB PARAMETERS
	PUSHJ	P,ACCCHK	;CHECK LAST VALIDATION FAILURE
	PUSHJ	P,MAILCH	;CHECK FOR MAIL
	PUSHJ	P,STRMES	;DO /STR IF DESIRED
	PUSHJ	P,LOGJOB	;LOG THE JOB IN
	PUSHJ	P,USRSET	;SET UNPRIV'ED JOB PARAMETERS
	PUSHJ	P,DAYMES	;PRINT OUT DAILY MESSAGES
	PUSHJ	P,POSTMS	;DO POST-MESSAGE TRMOP.S (SPEED)
	PJRST	MONRET		;EXIT
;SUBROUTINE TO PARSE THE LOGIN COMMAND LINE
;CALL WITH:
;	PUSHJ	P,PARSE
;	RETURN HERE IF OK
;
PARSE:	TLZ	F,FL.WLD	
	SETZM	Z.STRT		;INIT SOME SWITCHES TO 0
	MOVE	T1,[XWD Z.STRT,Z.STRT+1];SETUP BLT
	BLT	T1,Z.END-1	;CLEAR THEM OUT
	SETOM	OOBEG		;CLEAR OUT SWITCH BLOCK
	MOVE	T1,[XWD OOBEG,OOBEG+1]	
	BLT	T1,OOMAX-1	
	MOVE	T1,[IOWD DVICES*2+1,DEVTAB] ;INIT PTR TO DEV TABLE
	MOVEM	T1,DEVPTR	;..
	PUSHJ	P,PSCAN		;INIT PARTIAL LINE SCANNER
	MOVEI	T1,[ASCIZ /a PPN, path, or user name/]
	MOVEM	T1,HELP		;SAVE INCASE INPUT TIMEOUT
	PUSHJ	P,GETUSR	;READ USER ID (PPN/PATH/NAME)
	SKIPE	FAILFL		;ACCESS FAILURE?
	JRST	PARSE1		;YES
	SKIPN	AENTRY+.AEPPN	;DID WE GET A REASONABLE PROFILE?
	JRST	PARSE		;NO--PROBABLY THE RESULT OF A SCAN ERROR
	JUMPE	PP,PARSE	;IGNORE BLANK LINES
	MOVEM	PP,PPN		;YES - SALT PPN AWAY FOR LOGIN UUO
PARSE1:	MOVEI	T1,U.PATH	;GET ADDR OF PATH SPEC TO CHECK
	PUSHJ	P,PTHCHK	;MAKE SURE IT'S A NICE PATH SPEC
BADPTH:	  FATAL IPS,<Invalid path specification>,EF.FMT
	SKIPN	U.PATH+.FXDEV	;WAS A PATH TYPED?
	POPJ	P,		;NO
	SKIPN	T4,U.PATH+.FXDIR ;WAS A PPN TYPED IN THE PATH?
	MOVE	T4,PP		;NO--USE TARGET PPN
	TLNN	T4,-1		;IS PROJECT NUMBER ZERO?
	HLL	T4,PP		;DEFAULT TO USER'S
	TRNN	T4,-1		;IS PROGRAMMER NUMBER ZERO?
	HRR	T4,PP		;DEFAULT TO USER'S
	MOVEM	T4,U.PATH+.FXDIR ;UPDATE IN PATH BLOCK
	POPJ	P,		;RETURN
SUBTTL	Command processing -- REATTA - REATTACH command


REATTA:	GETPPN	PP,		;GET OUR PPN
	  JFCL			;INCAES OF JACCT
	PUSHJ	P,USRDEF	;DO /BYPASS LEGALITY CHECKING
	MOVE	T1,[EXP <QA.IMM!1B17!.UGPPN>] ;QUEUE. BLOCK CODE
	MOVE	T2,PP		;PPN THAT WE WANT
	PUSHJ	P,STACCT	;READ OUR ACCOUNTING PROFILE
	  SETOM	FAILFL		;???
	PUSHJ	P,TTYECH	;SET TTY ECHO
	MOVE	T1,PP		;INCASE OF ERROR
	SKIPE	FAILFL		;ERRORS ALREADY?
	FATAL	NSP,<No such PPN as >,EF.FMT!EF.SIL,.TPPNW##
	PUSHJ	P,PSCAN		;INIT PARTIAL LINE SCANNER AND EAT SWITCHES
	PUSHJ	P,.TICAN##	;CHECK FOR ALPHANUMERICS
	  JUMPG	C,ERREXA	;CHECK FOR JUNK ON COMMAND LINE
	SKIPN	REPARS		;ANYTHING TYPED
	JRST	MONRET		;JUST /HELP
	PUSHJ	P,.SIXSC##	;READ TARGET TTY NAME
	CAIN	C,":"		;DEVICE TERMINATOR?
	PUSHJ	P,.TIAUC##	;EAT IT
	JUMPE	N,REATTA	;REPROMPT IF NO INPUT
	JUMPL	N,REATT1	;HAVE A REAL NAME?
	HLRZS	N		;PUT IN RH
	HRLI	N,'TTY'		;MAKE IT TTYNNN
REATT1:	MOVEM	N,NEWTTY	;SAVE TARGET TTY NAME
	PUSHJ	P,SWTSCN	;CHECK FOR TRAILING SWITCHES
	JUMPG	C,ERREXA	;CHECK FOR JUNK ON THE LINE
	PUSHJ	P,SWITCH	;DO SWITCH.INI PROCESSING
	MOVE	N,NEWTTY	;GET TTY NAME BACK
	MOVE	T1,N		;GET TTY NAME (SAVE FOR ERRORS)
	MOVE	T2,T1		;MAKE A WORKING COPY
	IONDX.	T2,UU.PHY	;REAL TTY?
REATT2:	  FATAL	DNT,<Device not a physical terminal >,EF.FMT!EF.SIL,.TSIXN##
	MOVEM	T2,TTYUDX	;SAVE TARGET UDX
	GETLCH	T2		;READ TTY BITS
	MOVEM	T2,TTBITS	;SAVE
	MOVE	T3,TTYUDX	;GET NAME AGAIN
	DEVCHR	T3,		;GET DEVICE CHARACTERISTICS
	TXNN	T3,DV.DSK	;A DSK?
	TXNN	T3,DV.TTY	;A TTY?
	JRST	REATT2		;NOT A PHYSICAL TTY
	MOVX	T1,UU.PHS	;PHYSICAL
	MOVE	T2,N		;DEVICE NAME
	SETZ	T3,		;NO BUFFERS
	OPEN	IOC,T1		;SEE IF AVAILABLE
	  SKIPA	T1,N		;FAILED
	JRST	REATT3		;ONWARD
	MOVE	T1,TTYUDX	;GET TARGET UDX
	DEVTYP	T1,		;READ OWNING JOB NUMBER
	  JRST	REATT1		;FAILED
	LDB	T1,[POINTR T1,TY.JOB] ;GET OWNER JOB
	FATAL	TIU,<Terminal in use by job >,EF.FMT!EF.SIL,.TDECW##
REATT3:	MOVEI	T1,IOC		;CHANNEL NUMBER
	IONDX.	T1,		;GET UDX
	  JRST	REATT1		;FAILED
	MOVSI	T2,'TTY'	;GET OUR TTY
	IONDX.	T2,UU.PHY	;CONVERT TO UDX
	  JFCL			;CAN'T FAIL
	CAMN	T1,T2		;SAME?
	FATAL	TIY,<Terminal is your job's controlling TTY>,EF.FMT!EF.SIL
	MOVE	T3,[%CNFLN]	;ARGUMENT
	GETTAB	T3,		;READ FRCLIN LINE NUMBER
	  JFCL
	TRO	T3,.UXTRM	;MAKE INTO A UDX
	CAMN	T3,TTYUDX	;SAME?	
	FATAL	TIF,<Terminal is FRCLIN>,EF.FMT!EF.SIL!EF.WTO!EF.ACF
	MOVE	T1,N		;RESET NAME INCASE OF ERRORS
	MOVX	T2,GL.SLV	;BIT TO TEST
	TDNE	T2,TTBITS	;SLAVED?
	FATAL	TIS,<Terminal is slaved; >,EF.FMT!EF.SIL,.TSIXN##
	MOVX	T1,JP.POK	;BIT TO TEST
	CAME	PP,ALPPPN	;GOD CAN DO ANYTHING
	TDNE	T1,AENTRY+.AEPRV ;AND SO MAY HIS APPOSTLES
	JRST	REATT4		;GO REATTACH TO ANOTHER TTY
	PUSHJ	P,PFLCHK	;CHECK PROFILE FOR LEGAL TTY TYPES

REATT4:	MOVE	T1,THSJOB	;GET OUR JOB NUMBER
	INFO	FJN,<From job >,,.TDECW##
	MOVEI	T1,CRLFPD	;<CRLF>DOT
	PUSHJ	P,.TSTRG##	;TYPE IT
	PUSHJ	P,.TOOUT##	;FORCE OUTPUT
	MOVE	T2,TTYUDX	;GET TARGET UDX
	TRZ	T2,.UXTRM	;STRIP OFF UDX OFFSET
	HRLZS	T2		;PUT IN LH
	TXO	T2,AT.UUM	;ATTACH IN USER MODE
	HRR	T2,THSJOB	;INCLUDE OUR JOB NUMBER
	ATTACH	T2,		;DO THE ATTACH
	  FATAL	ATF,<ATTACH to terminal failed>,EF.FMT!EF.SIL
	MOVE	T1,THSJOB	;GET JOB AGAIN
	INFO	NAJ,<Now attached to job >,,.TDECW##
	RELEAS	IOC,		;GIVE UP CHANNEL
	PJRST	MONRET		;CLEAN UP
SUBTTL	Command processing -- SESSIO - SESSION command


SESSIO:	PUSHJ	P,TTYECH	;SET TTY ECHO
	GETPPN	PP,		;GET OUR PPN
	  JFCL			;INCASE OF JACCT
	MOVEM	PP,PPN		;SAVE
	PUSHJ	P,PSCAN		;INIT PARTIAL LINE SCANNER AND EAT SWITCHES
	JUMPG	C,ERREXA	;CHECK FOR JUNK ON COMMAND LINE
	SKIPN	REPARS		;ANYTHING TYPED?
	JRST	MONRET		;JUST /HELP
	PUSHJ	P,SWITCH	;DO SWITCH.INI PROCESSING
	MOVE	T1,[EXP <QA.IMM!1B17!.UGPPN>] ;QUEUE. BLOCK CODE
	MOVE	T2,PPN		;PPN THAT WE WANT
	PUSHJ	P,STACCT	;GET ACCT DATA
	  FATAL	APA,<Accounting profile not available>,EF.FMT!EF.SIL
	PUSHJ	P,ASKACT	;READ ACCOUNT STRING IF REQUIRED
	PUSHJ	P,ASKRMK	;READ REMARK STRING IF REQUIRED
	PUSHJ	P,SETACT	;SET ACCOUNT STRING
	PUSHJ	P,USGSES	;SEND USAGE MESSAGE TO [SYSTEM]ACCOUNTING
	PJRST	MONRET		;DONE
SUBTTL	Command processing -- SETPSW - SET PASSWORD command


SETPSW:	PUSHJ	P,PSCAN		;INIT PARTIAL LINE SCANNER AND EAT SWITCHES
	JUMPLE	C,SETPS1	;ERROR IF EOL
	PUSHJ	P,.SIXSC##	;GET NEXT WORD
	MOVE	T1,[IOWD 1,['PASSWO']]
	MOVE	T2,N		;GET KEYWORD
	PUSHJ	P,.LKNAM##	;SOME FLAVOR OF PASSWORD?
SETPS1:	  FATAL	PMS,<"PASSWORD" missing in SET PASSWORD command>,EF.SIL
	PUSHJ	P,SWTSCN	;SCAN SWITCHES (MAYBE THE CLOWN TYPED /H)
	JRST	PASSW0		;JOIN COMMON CODE
SUBTTL	Command processing -- PASSWO - PASSWORD command


PASSWO:	PUSHJ	P,PSCAN		;INIT PARTIAL LINE SCANNER AND EAT SWITCHES
PASSW0:	JUMPG	C,ERREXA	;CHECK FOR JUNK ON COMMAND LINE
	SKIPN	REPARS		;ANYTHING TYPED?
	JRST	MONRET		;JUST /HELP
	MOVEI	T1,[ASCIZ /password may not be changed/]
	PUSHJ	P,LOKWRN	;CHECK FOR LOCKED ACCOUNTING FILES
	  PJRST	MONRET		;GIVE UP
	MOVEI	T1,1		;GET A "YES"
	MOVEM	T1,U.PASS	;FORCE /PASSWORD:YES
	GETPPN	T1,		;GET OUR PPN
	  JFCL			;INCASE OF JACCT
	MOVEM	T1,PPN		;SAVE
PASSW1:	MOVEI	T1,[ASCIZ /your old password/]
	MOVEI	T2,[ASCIZ /Old password: /]
	MOVEI	T3,PASSWD	;BUFFER ADDRESS
	PUSHJ	P,ASKPSW	;READ PASSWORDS
	PUSHJ	P,CHGPSW	;REQUEST PASSWORD CHANGE
	PJRST	MONRET		;FINISH UP
SUBTTL	Exit routines -- FLUSH - Special error processing


FLUSH:	PUSHJ	P,.CLRBF##	;CLEAR TYPE-AHEAD
	SKIPE	IAMLGO		;ARE WE RUNNING LOGOUT BEFORE 7.04?
	JRST	MONLGO		;YES--EXIT
	PUSHJ	P,.ISLGI##	;ARE WE LOGGED IN?
	  SKIPA	T1,[KLGMSG]	;POINT TO KJOB TEXT
	JRST	MONRET		;GO FINISH UP
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	PUSHJ	P,.TOOUT##	;FORCE OUTPUT
	SKIPN	.JBDDT##	;DEBUGGING?
	SKIPLE	LOGTRY		;FAILED SEVERAL TIMES TO LOGIN?
	JRST	MONRET		;DON'T DISCONNECT THE LINE
	MOVEI	T1,3		;WAIT A BIT SO THE
	SLEEP	T1,		; KJOB TEXT GETS OUT
	MOVE	T1,[.NDTDS,,T2]	;SET UP UUO
	MOVEI	T2,2		;TWO WORDS
	MOVE	T3,MYTTY	;SIXBIT TTY NAME
	NODE.	T1,		;DISCONNECT OUR LINE
	  JFCL			;OK IF DISCONNECT FAIELD
	PJRST	MONRET		;FINISH UP


NOATT:	FATAL	CAJ,<Can't ATTACH to job>,EF.SIL
TRYAGN:	TLNE	F,FL.BAT	;BATCH JOB?
	TDZA	T1,T1		;DON'T WASTE TIME
	MOVEI	T1,RETRYS	;GET SECONDS TO SNOOZE ON RETRY
	SKIPE	T1		;ZERO?
	SLEEP	T1,		;ZZZZZZ
	FATAL	IET,<Invalid entry>,EF.FMT!EF.SIL,
SUBTTL	Exit routines -- MONRET - Exit program


MONRET:	MOVSI	T1,(AC.DCR)	;GET THE DECREMENT BIT
	ACCLG.	T1,		;TRY TO COUNT DOWN
	  JFCL			;IF ERROR IGNORE AND CONTINUE
MONLGO:	SKIPE	T1,.JBDDT##	;SKIP IF NO DDT
	JRST	(T1)		;GO TO DDT
	RESET			;STOP I/O
	MOVX	T1,CM.ATT	;BIT TO TEST
	TDNE	T1,COMIDX	;ATTACH?
	JRST	MONRE1		;YES--IT'S SPECIAL
	PUSHJ	P,.TOOUT##	;FORCE OUT ANY REMAIN TEXT IN OUTPUT BUFFER
	PUSHJ	P,.ISLGI##	;ARE WE LOGGED IN?
	  JRST	MONRE1		;NO
	SKIPN	RUNBLK+.RNDEV	;SKIP IF USER IS LOCKED INTO A PROGRAM
	PUSHJ	P,.RUNCM##	;PROCESS /RUN IF ANY
MONRE1:	SKIPE	IAMLGO		;ARE WE RUNNING LOGOUT BEFORE 7.04?
	PUSHJ	P,RELOGN	;YES--RELOGIN THE JOB
	MOVX	T1,PS.FOF	;
	PISYS.	T1,		;TURN OFF THE PSI INTERRUPT SYSTEM
	  JFCL			;OH WELL, WE TRIED
	SETZM	.JBSA##		;CLEAR START ADDRESS
	SETZM	.JBREN##	;CLEAR REENTER ADDRESS
	SETZM	.JBINT##	;CLEAR INTERCEPTS (JACCT STILL ON)
	MOVSI	17,XITMON	;ASSUME NORMAL PROGRAM EXIT
	SKIPE	RUNBLK+.RNDEV	;PROGRAM-TO-RUN?
	MOVSI	17,XITRUN	;YES
	BLT	17,17		;LOAD THE ACS
	JRST	0		;JUMP INTO THE ACS AND FINISH UP

RELOGN:	SKIPN	JLOGTM		;JUST TO BE SURE, WERE WE EVER LOGGED IN?
	POPJ	P,		;NO--RETURN
	MOVE	T1,[-5,,LGNBLK]	;SET UP UUO AC
	LOGIN	T1,		;GET BACK IN
	POPJ	P,		;
SUBTTL	Exit routines -- RICC - Control-C trapping


; SUBROUTINE TO ALLOW CONTROL-C'S TO WORK AGAIN
; CALL WITH:
;	PUSHJ	P,CTLCOK
;	RETURN HERE IF NO CONTROL-C TYPED
;
CTLCOK:	SETZM	CCWAIT		;CLEAR THE CONTROL-C DELAY FLAG
	AOSE	CCTYPED		;WAS A CONTROL-C TYPED?
	POPJ	P,0		;NO--RETURN TO CALLER
				;YES--FALL INTO RICC
;HERE WHEN A CONTROL-C TYPED
RICC:	PUSH	P,INTBLK+2	;SAVE OLD PC
	SKIPN	CCWAIT		;DO WE WANT CONTROL-C HELD UP?
	JRST	RICC1		;NO--CHARGE AHEAD
	SKIPG	CCWAIT		;DO WE WANT THIS MESSAGE?
	INFO	WFC,<Please wait for Control-C>
	SETZM	INTBLK+2	;REENABLE INTERRUPTS
	SETOM	CCTYPED		;SET THE FLAG
	POPJ	P,0		;RETURN
RICC1:	SKIPE	IAMLGO		;ARE WE RUNNING LOGOUT BEFORE 7.04?
	JRST	MONLGO		;YES--EXIT
	PUSHJ	P,.ISLGI##	;ARE WE LOGGED IN?
	AOJE	T1,.MNRET##	;NO--EXIT
	HRRZ	T1,COMIDX	;GET INVOKING COMMAND INDEX
	CAIN	T1,COMLOG	;LOGIN?
	WARN	LAC,<LOGIN aborted by Control-C; job is logged in>
	JRST	MONRET		;EXIT QUICKLY
SUBTTL	Exit routines -- SUMARY - Print KJOB summary


SUMARY:	SKIPE	U.KJOB		;/BATCH?
	SKIPE	U.NMSG		;OR NOT /NOMESSAGE?
	TRNA			;YES, SHOW THE SUMMARY
	JRST	SUMAR3		;NO, EXIT QUICKLY
	MOVE	T1,RUNTIM	;GET RUNTIME IN TICKS
	IMULI	T1,^D1000	;CONVERT TO MILLI-TICKS
	IDIV	T1,JIFFIE	;CONVERT TO MILLI-SECONDS
	MOVEM	T1,RUNTIM	;AND STORE RUNTIME

	MOVE	T1,KCTNUM	;GET CTI IN KCTS
	IMULI	T1,^D100	;GET CTI IN <KCT>*100
	IDIV	T1,JIFFIE	;DIVIDE BY JIFSEC
	MOVEM	T1,KCTNUM	;YIELDING KILO-CORE-CENTI-SECS

	MOVSI	T1,777700	;MASK FOR INCREMENTAL READS AND WRITES
	ANDCAM	T1,DSKRDS	;TURN OFF INCREMENTAL READS
	ANDCAM	T1,DSKWTS	;TURN OFF INCREMENTAL WRITES

	MOVEI	T1,[ASCIZ /Job /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,THSJOB	;JOB NUMBER
	PUSHJ	P,.TDECW##
	MOVEI	T1,[ASCIZ /  User /]
	PUSHJ	P,.TSTRG##
	SKIPE	T1,NAME	;GET FIRST HALF OF MY NAME
	PUSHJ	P,.TSIXN##	;TYPE IT
	SKIPN	T1,NAME	;GET FIRST HALF OF MY NAME BACK
	MOVEI	T1,77		;MAKE THE FOLLOWING TEST FAIL
	TRNN	T1,77		;WAS THE LAST CHARACTER A SPACE?
	PUSHJ	P,.TSPAC##	;YES, TYPE A SPACE
	SKIPE	T1,NAME2	;GET SECOND HALF
	PUSHJ	P,.TSIXN##	;TYPE IT
	PUSHJ	P,.TSPAC##	;TYPE A SPACE
	MOVE	T1,PP		;GET PPN
	PUSHJ	P,.TPPNW##	;AND TYPE IT
	PUSHJ	P,.TCRLF##	;TYPE A CRLF
	MOVEI	T1,[ASCIZ /Logged-off /]
	PUSHJ	P,.TSTRG##	;TYPE THE STRING
	MOVE	T1,MYTTY	;GET THE TTY NAME
	PUSHJ	P,.TSIXN##	;AND TYPE IT
	MOVEI	T1,[ASCIZ /  at /]
	PUSHJ	P,.TSTRG##	;TYPE IT
	MOVE	T1,CURDTM	;GET DATE AND TIME
	PUSHJ	P,.CNTDT##	;TAKE APART
	ADDI	T1,^D500	;ROUND TO SECOND FOR PRINTING
	CAMG	T1,[^D24*^D60*^D60*^D1000];PAST MIDNIGHT?
	JRST	SUMAR1		;NO, NORMAL CASE
	ADDI	T2,1		;WAS 23:59:59.835, BUMP DAY
	SUB	T1,[^D24*^D60*^D60*^D1000];MAKE TIME 0:0:0
SUMAR1:	PUSH	P,T2		;SAVE DATE
	PUSHJ	P,.TTIME##	;TYPE TIME
	MOVEI	T1,[ASCIZ /  on /]
	PUSHJ	P,.TSTRG##
	POP	P,T1		;GET DATE
	PUSHJ	P,.TDATE##	;TYPE DATE
	PUSHJ	P,.TCRLF##	;AND A CRLF

	MOVEI	T1,[ASCIZ /Runtime:/]
	PUSHJ	P,.TSTRG##	;AND A LABEL
	MOVE	T1,RUNTIM	;GET RUNTIME IN MILLI-SECONDS
	PUSHJ	P,.TTIME##	;TYPE IT
	MOVEI	T1,[ASCIZ /, KCS:/]
	PUSHJ	P,.TSTRG##
	MOVE	T1,KCTNUM	;GET CORE-TIME INTEGRAL IN KCS*100
	IDIVI	T1,^D100	;CONVERT TO KCS
	PUSHJ	P,.TDECW##	;TYPE IT
	MOVEI	T1,[ASCIZ /, Connect time:/]
	PUSHJ	P,.TSTRG##	;TYPE IT
	MOVE	T1,CURDTM	;GET TIME OF DAY NOW
	SUB	T1,JLOGTM	;SUBTRACT JOB LOGIN TIME
	MULI	T1,^D86400	;CONVERT TO SECONDS
	ASHC	T1,^D17		;SHIFT IT IN
	IMULI	T1,^D1000	;CONVERT TO MILLISECS
	PUSHJ	P,.TTIME##	;AND TYPE IT
	PUSHJ	P,.TCRLF##	;AND A CRLF
	MOVEI	T1,[ASCIZ /Disk Reads:/]
	PUSHJ	P,.TSTRG##	;TYPE A LINE
	MOVE	T1,DSKRDS	;GET NUMBER OF READS
	PUSHJ	P,.TDECW##	;AND TYPE IT
	MOVEI	T1,[ASCIZ /, Writes:/]
	PUSHJ	P,.TSTRG##
	MOVE	T1,DSKWTS	;GET NUMBER OF WRITES
	PUSHJ	P,.TDECW##	;TYPE IT
	SKIPE	L.OJCS		;OTHER JOB CONTAIN CONFLICTING STR?
	JRST	SUMAR2		;YES, WE DIDN'T COUNT EVERYTHING THEN
	MOVEI	T1,[ASCIZ /, Blocks saved:/]
	PUSHJ	P,.TSTRG##
	MOVE	T1,TOTBLK	;GET TOTAL NUMBER OF BLOCKS
	PUSHJ	P,.TDECW##	;AND TYPE IT
SUMAR2:	PUSHJ	P,.TCRLF##	;AND A CRLF
SUMAR3:	MOVX	T1,GL.ITY	;
	SKIPN	DETFLG		;DETACHED?
	TDNE	T1,TTBITS	;USING A PTY?
	POPJ	P,		;YES - FINISHED
	PUSHJ	P,.TCRLF##	;TYPE A CRLF
	MOVEI	T1,"."		;
	PUSHJ	P,.TCHAR##	;TYPE A DOT
	PUSHJ	P,.TOOUT##	;FORCE OUT THE LAST OUTPUT
	SETO	T3,		;THIS TERMINAL
	SKIPL	U.DISC		;/DISCONNECT OR /NODISCONNECT?
	JRST	SUMAR4		;YES - NO DEFAULT TO FILL IN
	DMOVE	T1,[EXP <2,,T2>,<.TOAPC>]
	TRMOP.	T1,		;GET APC CODE
	  JRST	SUMAR4		;ERROR
	MOVEI	T4,1		;
	MOVSI	T2,-DISLEN	;-LENGTH OF TABLE
	CAME	T1,DISTAB(T2)	;MATCH?
	AOBJN	T2,.-1		;LOOP
	SKIPG	T2		;FOUND A MATCH?
	MOVEM	T4,U.DISC	;YES - /DISCONNECT

SUMAR4:	MOVEI	T2,.TOSOP	;FUNCTION
SUMAR5:	MOVX	T1,<2,,T2>	;LENGTH,,ADDRESS
	SKIPN	DETFLG		;DETACHED?
	TRMOP.	T1,		;OUTPUT COMPLETE?
	  JRST	SUMAR6		;YES - HANG UP THE PHONE
	MOVEI	T1,1		;SLEEP TIME
	SLEEP	T1,		;ZZZZZZ
	JRST	SUMAR5		;TRY AGAIN

SUMAR6:	SKIPG	U.DISC		;WANT TO DISCONNECT LINE?
	POPJ	P,		;NO, FINISHED
	MOVEI	T1,1		;OK NOW GIVE THE OUTPUT A CHANCE TO
	SLEEP	T1,		; MAKE IT THROUGH THE REMOTE STATION
	DMOVE	T1,[EXP <2,,T2>,<.TODSF>]
	SKIPN	DETFLG		;DETACHED?
	TRMOP.	T1,		;DISCONNECT DATASET
	  JFCL			;OH WELL, WE TRIED
	DMOVE	T1,[EXP <2,,T2>,<.TODNT>]
	SKIPN	DETFLG		;DETACHED?
	TRMOP.	T1,		;DISCONNECT NETWORK TERMINAL
	  JFCL			;OH WELL, WE TRIED
	POPJ	P,		;RETURN
; MACRO TO DEFINE APC CODES FOR LINES WHICH WILL GET AUTOMATICALLY
; DISCONNECTED.

DEFINE	DISC,<
X	(<NRT,CTM,LAT>)		;;NRT, CTERM, LAT
> ;END DEFINE DISC


DEFINE	X,(APC),<
	IRP APC,<EXP .TO'APC>
>
DISTAB:	DISC
DISLEN==.-DISTAB
SUBTTL	Exit routines -- XITMON - Code to exit to the monitor


XITMON:	PHASE	0

	SETZM	.JBDA		;(00) CLEAR FIRST WORD
	MOVSI	0,.JBDA		;(01) START OF LOW SEGMENT TO ZERO
	HRRI	0,.JBDA+1	;(02) MAKE A BLT POINTER
	BLT	0,.JBDA!777	;(03) CLEAR MOST OF FIRST PAGE
	MOVEI	0,.JBDA!777	;(04) END OF LOW SEG TO ZERO
	HRLI	0,1		;(05) KILL THE HIGH SEGMENT TOO
	CORE	0,		;(06) RELEASE MOST OF LOW SEG + ALL OF HIGH SEG
	  JFCL			;(07) SHOULDN'T FAIL
	SETZ	0,		;(10) ZAP AC
	SETNAM	0		;(11) CLEAR PROGRAM NAME AND JACCT
	LOGOUT	1,		;(12) DIE QUIETLY
	JRST	.-1		;(13) STAY DEAD
	EXP	0		;(14) FREE AC
	EXP	0		;(15) FREE AC
	EXP	0		;(16) FREE AC
	EXP	0		;(17) FREE AC

	DEPHASE
SUBTTL	Exit routines -- XITRUN - Code to do a RUN UUO


XITRUN:	PHASE	0

	SETZM	Z.XITE		;(00) CLEAR FIRST WORD
	MOVSI	0,Z.XITE	;(01) START OF LOW SEGMENT TO ZERO
	HRRI	0,Z.XITE+1	;(02) MAKE A BLT POINTER
	BLT	0,Z.XITE!777	;(03) CLEAR MOST OF FIRST PAGE
	MOVEI	0,Z.XITE!777	;(04) END OF LOW SEG TO ZERO
	HRLI	0,1		;(05) KILL THE HIGH SEGMENT TOO
	CORE	0,		;(06) RELEASE MOST OF LOW SEG + ALL OF HIGH SEG
	  JFCL			;(07) SHOULDN'T FAIL
	SETZ	0,		;(10) ZAP AC
	SETNAM	0		;(11) CLEAR PROGRAM NAME AND JACCT
	MOVEI	0,RUNBLK	;(12) POINT TO RUN UUO BLOCK
	RUN	0,UU.PHY	;(13) CHAIN TO PROGRAM-TO-RUN
	  LOGOUT 1,		;(14) FAILED--DIE QUIETLY
	EXP	0		;(15) FREE AC
	EXP	0		;(16) FREE AC
	EXP	0		;(17) FREE AC

	DEPHASE
SUBTTL	Exit routines -- DAYMES - Print daily messages


DAYMES:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	T1,PPN		;GET PPN
	TLNE	F,FL.WLD	;WILD PPN?
	INFO	LIA,<You are logged in as >,,.TPPNW##
	PUSHJ	P,DAYTIM	;TYPE DAYTIME, DATE, DAY
	MOVX	T1,CM.LOG	;BIT TO TEST
	TDNE	T1,COMIDX	;LOGIN COMMAND?
	PUSHJ	P,LGNMES	;YES--TYPE SYS:LOGIN.TXT
	MOVEI	T1,2		;GET DEFAULT FOR /NOTICE
	MOVE	P1,U.NOTC	;GET SWITCH TYPED
	AOSN	P1		;WAS A SWITCH TYPED?
	  MOVEM	T1,U.NOTC	;NO - USE DEFAULT
	PUSHJ	P,NOTE		;PRINT NOTES
	MOVSI	T1,(CM.LOG!CM.ATT) ;BITS TO TEST
	TDNN	T1,COMIDX	;LOGIN OR ATTACH COMMAND?
	POPJ	P,		;NO
	PUSHJ	P,ISOPSR	;IS THIS AN OPSER SUBJOB?
	  PUSHJ	P,NOTICE	;NO--PRINT NOTICE.TXT
	POPJ	P,		;DON'T TYPE NOTICE.TXT
SUBTTL	Accounting routines -- ACCCHK - Check for a previous valid LOGIN


ACCCHK:	TLNN	F,FL.WLD	;WILDCARDED PPN?
	SKIPN	LSTACC		;HAVE A LAST ACCESS UDT?
	POPJ	P,		;MAYBE THIS IS THE FIRST TIME
	MOVX	T1,AE.FAI	;BIT TO TEST
	TDNE	T1,LSTFLG	;WAS IT A FAILURE?
	JRST	ACCCH1		;YES--WARN USER
	INFO	LAS,<Last access to >,,E.LAS
	POPJ	P,		;RETURN
ACCCH1:	WARN	LAF,<Last access to >,,E.LAF
	POPJ	P,		;RETURN

E.LAF:!
E.LAS:	MOVE	T1,PPN		;GET PPN
	PUSHJ	P,.TPPNW##	;PRINT IT
	MOVEI	T1,[ASCIZ / succeeded on /]
	MOVX	T2,AE.FAI	;GET FAILURE BIT
	TDNE	T2,LSTFLG	;WAS IT A FAILURE?
	MOVEI	T1,[ASCIZ / failed on /]
	PUSHJ	P,.TSTRG##	;PRINT DELIMITER
	MOVE	T1,LSTACC	;GET UFD OF LAST ACCESS
	PJRST	.TDTTM##	;TYPE IT AND RETURN
SUBTTL	Accounting routines -- ACTCHK - Check for [SYSTEM]ACCOUNTING


ACTCHK:	TLNE	F,FL.BYP	;BYPASSING THE ACCOUNTING SYSTEM?
	POPJ	P,		;YES--RETURN NOW
	MOVEI	T1,^D5		;TRY 5 TIMES
	MOVEI	T2,^D1		;WAITING 1 SECOND
	PUSHJ	P,ACTCH1	;SEE IF PID FOR [SYSTEM]ACCOUNTING EXISTS
	  POPJ	P,		;IT IS
	INFO	WFA,<Waiting for accounting daemon to start>
	MOVEI	T1,^D30		;TRY 30 TIMES
	MOVEI	T2,^D10		;WAITING 10 SECONDS
	PUSHJ	P,ACTCH1	;SEE IF PID FOR [SYSTEM]ACCOUNTING EXISTS
	  POPJ	P,		;IT IS
	STOP	ADN,<Accounting daemon not running>,EF.WTO

ACTCH1:	MOVE	T3,[%SIACT]	;GETTAB ARGUMENT
	GETTAB	T3,		;GET PID FROM MONITOR
	  JRST	.POPJ1##	;NOT THERE
	JUMPN	T3,.POPJ##	;RETURN IF THERE'S A PID
	SOJLE	T1,.POPJ1##	;COUNT DOWN
	SLEEP	T2,		;ZZZZ
	JRST	ACTCH1		;AND TRY AGAIN
SUBTTL	Accounting routines -- CHGNAM - Change name


CHGNAM:	MOVX	T1,AE.NCH	;BIT TO TEST
	TDNN	T1,AENTRY+.AEFLG ;CHANGING THE NAME?
	POPJ	P,		;NO
	PUSHJ	P,ACTCHK	;WAIT FOR [SYSTEM]ACCOUNTING TO START
	MOVEI	T1,.QUMAE	;ACCOUNTING FUNCTION
	MOVEI	T2,0		;CENTRAL STATION OPR
	MOVE	T3,[RSPLEN,,RSPBLK] ;RESPONSE BLOCK POINTER
	MOVEI	T4,CHGTIM	;TIMEOUT
	PUSHJ	P,QUEINI	;SET UP QUEUE. UUO ARGUMENT BLOCK
	DMOVE	T2,[EXP <QA.IMM!1B17!.QBAFN>,<UGCUP$>] ;FUNCTION CODE
	DMOVEM	T2,(T1)
	MOVE	T2,[EXP <QA.IMM!2B17!.AEVRS>] ;SET VERSION VALIDATION
	MOVEM	T2,2(T1)		;STORE
	DMOVE	T2,[EXP <%AECVN,,0>,<AE.VRS>] ;GET VERSION INFO
	DMOVEM	T2,3(T1)	;STORE
	DMOVE	T2,[EXP <XWD 1,.AEPPN!AF.AND>,<PPN>] ;PPN WE ARE GOING TO AFFECT
	DMOVEM	T2,5(T1)	;STORE
	DMOVE	T2,[EXP <XWD .AANLW,.AENAM>,<AENTRY+.AENAM>] ;NEW NAME
	DMOVEM	T2,7(T1)
	HRLI	T1,-QUEBLK+11(T1) ;GET LENGTH
	HRRI	T1,QUEBLK	;AND ADDRESS
	PUSH	P,CCWAIT	;PRESERVE THE SETTING OF ^C FLAG
	SETOM	CCWAIT		;DON'T LET THE GUY ^C OUT
	QUEUE.	T1,		;REQUEST PASSWORD CHANGE
	  PJRST	QUEERR		;REPORT QUEUE. UUO ERROR
	INFO	UNS,<User name has been set>
	POP	P,CCWAIT	;RESTORE
	POPJ	P,		;RETURN
SUBTTL	Accounting routines -- CHGPSW - Change password


CHGPSW:	PUSHJ	P,ACTCHK	;WAIT FOR [SYSTEM]ACCOUNTING TO START
	MOVEI	T1,.QUMAE	;ACCOUNTING FUNCTION
	MOVEI	T2,0		;CENTRAL STATION OPR
	MOVE	T3,[RSPLEN,,RSPBLK] ;RESPONSE BLOCK POINTER
	MOVEI	T4,CHGTIM	;TIMEOUT
	PUSHJ	P,QUEINI	;SET UP QUEUE. UUO ARGUMENT BLOCK
	DMOVE	T2,[EXP <QA.IMM!1B17!.QBAFN>,<UGCUP$>] ;FUNCTION CODE
	DMOVEM	T2,(T1)
	MOVE	T2,[EXP <QA.IMM!2B17!.AEVRS>] ;MUST VALIDATE VERSION
	MOVEM	T2,2(T1)	;SET IT UP
	DMOVE	T2,[EXP <%AECVN,,0>,<AE.VRS>] ;GET VERSION INFO
	DMOVEM	T2,3(T1)	;STORE
	DMOVE	T2,[EXP <XWD 1,.AEPPN!AF.AND>,<PPN>] ;PPN WE ARE GOING TO AFFECT
	DMOVEM	T2,5(T1)
	DMOVE	T2,[EXP <XWD .APWLW,.AEPSW!AF.AND>,<PASSWD>] ;OLD PASSWORD
	DMOVEM	T2,7(T1)
	DMOVE	T2,[EXP <XWD .APWLW,.AEPSW>,<NEWPSW>] ;NEW PASSWORD
	DMOVEM	T2,11(T1)
	HRLI	T1,-QUEBLK+13(T1) ;GET LENGTH
	HRRI	T1,QUEBLK	;AND ADDRESS
	PUSH	P,CCWAIT	;PRESERVE THE SETTING OF ^C FLAG
	SETOM	CCWAIT		;DON'T LET THE GUY ^C OUT
	QUEUE.	T1,		;REQUEST PASSWORD CHANGE
	  PJRST	QUEERR		;REPORT QUEUE. UUO ERROR
	INFO	PHC,<Password has been changed>
	POP	P,CCWAIT	;RESTORE
	POPJ	P,		;RETURN
SUBTTL	Accounting routines -- LOKCHK/LOKWRN - Check for locked files


LOKCHK:	SETZ	T1,		;NO MESSAGE
LOKWRN:	PUSH	P,T1		;SAVE T1
	AOS	-1(P)		;ASSUME NOT LOCKED
	MOVX	T1,AE.LOK	;BIT TO TEST
	TDNN	T1,AENTRY+.AEFLG ;ACCOUNTING FILE LOCKED?
	JRST	LOKWR1		;NO
	SOS	-1(P)		;COMPENSATE FOR AOS
	SKIPE	T1,0(P)		;SKIP IF NO MESSAGE WANTED
	WARN	AFL,<Accounting files locked; >,,.TSTRG##
LOKWR1:	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN
SUBTTL	Accounting routines -- PFLCHK - Profile check


PFLCHK:	SKIPE	FAILFL		;ABOUT TO FAIL?
	POPJ	P,		;YES--LET USER THINK ALL IS WELL
	MOVE	T3,AENTRY+.AEACC ;GET ACCESS BITS
	MOVE	T1,TTBITS	;AND OUR TTY BITS
	TXNN	T1,GL.ITY	;SKIP IF PTY
	JRST	PFLCH1		;SEE IF MAY LOGIN AT THIS TERMINAL
	TLNE	F,FL.BSJ	;SKIP IF NOT BATCH JOB SUBJOB
	TXNE	T3,AE.SBJ	;SKIP IF MAY NOT LOGIN AS SUBJOB
	SKIPA			;OK
	JRST	PFLCH2		;NO GOOD
	TLNE	F,FL.BAT	;BATCH JOB?
	TXNE	T3,AE.BAT	;YES - ALLOWED TO BE ONE?
	SKIPA			;NOT BATCH OR BATCH & ALLOWED TO BE
	JRST	PFLCH2		;BATCH & SHOULDN'T BE - COMPLAIN
	TLNE	F,FL.BAT	;BATCH JOB?
	POPJ	P,		;YES--RETURN
	MOVE	T2,CNTLJP	;CONTROL JOB PPN
	CAME	T2,ALPPPN	;OK IF RUN BY JOB WITH ALL PRIVILEGES
	CAMN	T2,PPN		;OK IF RUN BY SAME PPN
	POPJ	P,		;NO MORE CHECKS NEEDED
	MOVE	T1,CNTLJT	;GET LINE BITS FOR CONTROL JOB
PFLCH1:	TLNE	F,FL.BYP!L.OPR!L.SOPR ;OK IF /BYPASS, OPR, SUB OF OPR, OR [1,2]
	POPJ	P,		;LET HIM THROUGH
	MOVX	T2,AE.LOC	;LOCAL BIT
	TXNE	T1,GL.REM	;SKIP IF NOT REMOTE HARDWIRED TTY
	MOVX	T2,AE.RMT	;REMOTE BIT
	TXNE	T1,GL.DSL	;SKIP IF NOT DATA SET TTY
	MOVX	T2,AE.DST
	TDNN	T2,T3		;SKIP IF MAY LOGIN AT THIS TERMINAL
	JRST	PFLCH2		;NO GOOD
	TXNN	T3,AE.FIO	;SKIP IF FILES-ONLY
	POPJ	P,		;RETURN
	MOVX	T2,AE.FIO	;FIX BIT
PFLCH2:	MOVX	T1,CM.ATT	;BIT TO TEST
	TDNE	T1,COMIDX	;ATTACH COMMAND?
	FATAL	MNA,<May not ATTACH >,EF.SIL,E.MNA
	FATAL	MNL,<May not LOGIN >,EF.SIL,E.MNL

E.MNL:!
E.MNA:	MOVEI	T1,[ASCIZ/files-only PPN/]
	TXNN	T2,AE.FIO	;FILES-ONLY?
	MOVEI	T1,[ASCIZ/local/]
	TXNE	T2,AE.RMT	;SKIP IF NOT REMOTE HARDWIRED TTY
	MOVEI	T1,[ASCIZ/remote/]
	TXNE	T2,AE.DST	;SKIP IF NOT DATA SET TTY
	MOVEI	T1,[ASCIZ/data set/]
	TXNE	T2,AE.ROP	;SKIP IF NOT REMOTE CTY OR OPR
	MOVEI	T1,[ASCIZ/remote CTY or OPR/]
	TLNE	F,FL.BSJ	;SKIP IF NOT BATCH JOB SUBJOB
	MOVEI	T1,[ASCIZ/as a batch job subjob/]
	TLNE	F,FL.BAT	;BATCH JOB?
	MOVEI	T1,[ASCIZ/as a batch job/]
	PJRST	.TSTRG##		;TYPE AND RETURN
SUBTTL	Accounting routines -- PSWCHK - Check for a legal password


PSWCHK:	SKIPN	FAILFL		;IGNORE PSW CHECK IF GOING TO FAIL ANYWAY
	TLNE	F,FL.CTY!FL.BYP!FL.BAT!L.SOPR ;PASSWORD REQUIRED?
	POPJ	P,		;NO
	MOVE	T2,CNTLJP	;CONTROL JOB PPN
	CAME	T2,ALPPPN	;OK IF RUN BY JOB WITH ALL PRIVILEGES
	CAMN	T2,PPN		;OK IF RUN BY SAME PPN
	POPJ	P,		;DON'T NEED TO CHECK PASSWORD
	MOVEI	T1,.QUMAE	;ACCOUNTING FUNCTION
	MOVEI	T2,0		;CENTRAL STATION OPR
	MOVE	T3,[RSPLEN,,RSPBLK] ;RESPONSE BLOCK POINTER
	MOVEI	T4,ACCTIM	;TIMEOUT
	PUSHJ	P,QUEINI	;SET UP QUEUE. UUO ARGUMENT BLOCK
	DMOVE	T2,[EXP <QA.IMM!1B17!.QBAFN>,<UGACC$>]
	DMOVEM	T2,(T1)		;CHECK PASSWORD AND ACCOUNT STRING
	MOVE	T2,[EXP <QA.IMM!1B17!.UGPPN>]
	MOVE	T3,PPN		;PPN THAT WE WANT
	DMOVEM	T2,2(T1)	;
	DMOVE	T2,[EXP <.APWLW,,.UGPSW>,PASSWD]
	DMOVEM	T2,4(T1)	;POINT TO PASSWORD
	DMOVE	T2,[EXP <.AACLW,,.UGACT>,U.ACTS]
	DMOVEM	T2,6(T1)	;POINT TO ACCOUNT STRING
	MOVEI	T3,ACCTRY	;INITIALIZE RETRY COUNTER
	HRLI	T4,-QUEBLK+10(T1) ;GET LENGTH
	HRRI	T4,QUEBLK	;AND ADDRESS
PSWCH1:	MOVE	T1,T4		;COPY LENGTH,,ADDRESS
	QUEUE.	T1,		;DO THE QUEUE.
	  TRNA			;EXAMINE THE ERROR
	POPJ	P,		;NO ERROR: RETURN
	CAIE	T1,QUTMO%	;TIMEOUT ERROR?
	JRST	PSWCH2		;NO, FAILED
	SOJL	T3,PSWCH2	;TOO MANY RETRIES: FAILURE
	INFO	WAR,<Waiting for [SYSTEM]ACCOUNTING response>
	MOVEI	T1,ACCTI2	;TIMEOUT FOR RETRIES
	MOVEM	T1,QUEBLK+.QUTIM
	JRST	PSWCH1		;TRY AGAIN
PSWCH2:	SETOM	FAILFL		;FAILED
	POPJ	P,		;RETURN
SUBTTL	Accounting routines -- PPNEXP - Check for PPN/PSW expiration


PPNEXP:	SKIPE	FAILFL		;ABOUT TO FAIL?
	POPJ	P,		;YES
	MOVE	T2,[%CNDTM]	;DATE TIME IN INTERNAL FORMAT
	GETTAB	T2,		;GET IT
	  POPJ	P,		;IF FAILS, GIVE THE GUY A BREAK
	MOVE	T1,AENTRY+.AEEXP ;GET EXPIRATION DATE/TIME OF PPN
	MOVEM	T1,XPDDTM	;SAVE
	JUMPLE	T1,PPNEX1	;DON'T CHECK IF NO EXPIRATION DATE
	CAMG	T1,T2		;SKIP IF NOT EXPIRED YET
	FATAL	PHE,<PPN has expired>
	SUB	T1,[EXPWRN,,0]	;SUBTRACT OFF THRESHOLD
	CAML	T1,T2		;SKIP IF WE'RE CLOSE
	JRST	PPNEX1		;NO NEED FOR WARNING
	MOVE	T1,XPDDTM	;GET EXPIRATION DATE
	WARN	PPE,<PPN will expire on >,,.TDTTM##

PPNEX1:	SKIPG	T1,AENTRY+.AEPCT ;GET PSW EXIPRATION DATE/TIME
	POPJ	P,		;WON'T EXPIRE OR ALREADY EXPIRED
	SUB	T1,[PSWWRN,,0]	;SUBTRACT OFF THRESHOLD
	CAML	T1,T2		;SKIP IF WE'RE CLOSE
	POPJ	P,		;NO NEED FOR WARNING
	MOVE	T1,AENTRY+.AEPCT ;GET DATE/TIME AGAIN
	WARN	PSE,<Password will expire on >,,.TDTTM##
	POPJ	P,		;RETURN
SUBTTL	Accounting routines -- SETTNL - Set up terminal designator for USAGE


SETTNL:	PUSHJ	P,.PSH4T##	;SAVE TEMPS
	MOVSI	T4,(ASCIZ/D/)	;ASSUME DETACHED
	MOVNI	T1,1		;-1 FOR OUR JOB
	TRMNO.	T1,		;GET TERMINAL DESIGNATOR
	  JRST	SETTN1		;DETACHED
	DPB	T1,[POINT 9,MONLNO,35] ;STORE IN CASE NO NETWORKS
	MOVE	T1,TTBITS	;GET OUR TTY BITS
	MOVSI	T4,(ASCIZ/T/)	;ASSUME REGULAR TTY
	TXNE	T1,GL.CTY	;THE SYSTEM CTY
	MOVSI	T4,(ASCIZ/C/)	;YES
	TXNE	T1,GL.ITY	;INVISIBLE (PSEUDO) TTY
	MOVSI	T4,(ASCIZ/P/)	;YES
	HRRZS	T1		;GET RID OF GETLCH BITS
	GTNTN.	T1,		;CONVERT TO NODE AND LINE
	  JRST	SETTN1		;NO NETWORKS
	HRRZM	T1,MONLNO	;STORE REAL LINE NUMBER
	HLRZ	T3,T1		;ISOLATE NODE NUMBER
	HRRI	T2,2		;NUMBER OF ARGUMENTS
	MOVE	T1,[.NDRNN,,T2]	;RETURN NODE NAME FOR NUMBER
	NODE.	T1,		;ASK TODD
	  SKIPA			;FAILED?
	MOVEM	T1,MONNOD	;STORE SIXBIT NODE NAME
SETTN1:	MOVEM	T4,MONTDE	;STORE TERMINAL DESIGNATOR
	PUSHJ	P,.POP4T##	;RESTORE TEMPS
	POPJ	P,		;AND RETURN
SUBTTL	Accounting routines -- STACCT - Read a user profiles


; HERE TO ASK [SYSTEM] ACCOUNTING FOR USER'S PROFILE
; CALL:
;	T1/ QA.IMM!.UGPPN OR LEN,,.UGUSR
;	T2/ PPN OR POINTER TO USER'S NAME
; RETURN
;	NON SKIP - NO SUCH USER
;	SKIP - ENTRY IS STORED IN AENTRY
STACCT:	TLNE	F,FL.BYP	;SUPPOSED TO BYPASS ACCOUNTING?
	JRST	STACC1		;YES, DON'T WAIT FOR HIM TO START
	PUSH	P,T2		;SAVE PPN OR POINTER TO USER'S NAME
	PUSH	P,T1		;SAVE QA.IMM!.UGPPN OR LEN,,.UGUSR
	PUSHJ	P,TTYNEC	;SET TTY NO ECHO
	PUSHJ	P,ACTCHK	;WAIT FOR [SYSTEM]ACCOUNTING TO START
	MOVEI	T1,.QUMAE	;ACCOUNTING FUNCTION
	MOVEI	T2,0		;CENTRAL STATION OPR
	MOVE	T3,[.AEMAX,,AENTRY] ;RESPONSE BLOCK POINTER
	MOVEI	T4,ACCTIM	;TIMEOUT
	PUSHJ	P,QUEINI	;SET UP QUEUE. UUO ARGUMENT BLOCK
	DMOVE	T2,[EXP <QA.IMM!1B17!.QBAFN>,<UGOUP$!AF.PRV>]
	DMOVEM	T2,(T1)		;OBTAIN PROFILE
	POP	P,2(T1)		;RESTORE QA.IMM!.UGPPN OR LEN,,.UGUSR
	POP	P,3(T1)		;RESTORE PPN OR POINTER TO USER'S NAME
	MOVEI	T3,ACCTRY	;INITIALIZE RETRY COUNTER
	HRLI	T4,-QUEBLK+4(T1) ;GET LENGTH
	HRRI	T4,QUEBLK	;AND ADDRESS
STACC3:	MOVE	T1,T4		;COPY LENGTH,,ADDRESS
	QUEUE.	T1,		;DO THE QUEUE.
	  TRNA			;EXAMINE THE ERROR
	JRST	STACC2		;ONWARD
	CAIE	T1,QUTMO%	;TIMEOUT ERROR?
	JRST	STACC4		;NO, FAILED
	SOJL	T3,STACC4	;TOO MANY RETRIES: FAILURE
	INFO	WAR,<Waiting for [SYSTEM]ACCOUNTING response>
	MOVEI	T1,ACCTI2	;TIMEOUT FOR RETRIES
	MOVEM	T1,QUEBLK+.QUTIM
	JRST	STACC3		;TRY AGAIN
STACC4:	MOVE	T1,[BADACT,,AENTRY] ;NO SUCH USER
	BLT	T1,AENTRY+.AEMIN ;COPY
	SETOM	FAILFL		;REMEMBER THE FAILURE
	TLNE	F,FL.BAT	;BATCH JOB?
	FATAL	NPB,<No profile for batch user>,EF.WTO
	POPJ	P,		;GIVE UP
STACC1:	MOVE	T1,[DEFACT,,AENTRY] ;COPY DEFAULT FOR /BYPASS TO AENTRY
	BLT	T1,AENTRY+.AEMIN ;COPY AS FAR AS THE DEC RESERVED WORDS
	PUSHJ	P,SSLCOP	;COPY THE SSL

STACC2:	HLRZ	T1,AENTRY+.AEVRS ;GET VERSION NUMBER
	CAIE	T1,ACTFMT	;CURRENT?
	STOP	(WVR,<Wrong profile version; found >,,E.WVR)
	HRRZ	T1,AENTRY+.AEPPN ;GET PROGRAMMER NUMBER
	CAIN	T1,UNIPRG	;WILD?
	TLO	F,FL.WLD	;YES
	JRST	.POPJ1##	;RETURN


E.WVR:	PUSHJ	P,.TOCTW##	;PRINT BAD VERSION NUMBER
	MOVEI	T1,[ASCIZ / when expecting /]
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	MOVEI	T1,ACTFMT	;GET GOOD NUMBER
	PJRST	.TOCTW##	;PRINT IT AND RETURN
; MACRO TO GENERATE WORDS IN THE DEFAULT (/BYPASS) PROFILE
DEFINE	ADEF	(OFS,DAT),<
	RELOC	DEFACT+.AE'OFS
	DAT
>

DEFACT:	ADEF	(VRS,<ACTFMT,,.AEMIN>)	;VERSION AND LENGTH
	ADEF	(PPN,<1,,2>)		;PPN
	ADEF	(NAM,<BYTE(8)"O","p","e","r","a","t","o","r">)
	ADEF	(PRV,<-1,,0>)		;PRIVILEGE WORD 1
					; ALL DEC PRIVS
	ADEF	(PRX,<<.OBSOP>B1>)	;PRIVILEGE WORD 2
					; SYSTEM OPERATOR PRIVS
	ADEF	(LGT,<-1>)		;LOGIN TIMES
					; ALL HOURS (WEEKDAYS AND WEEKENDS)
	ADEF	(COR,<40000,,40000>)	;PHYSICAL,,VIRTUAL CORE LIMITS
					; 16384K
	ADEF	(IPC,<777,,-1>)		;IPCF QUOTAS
					; 512 PIDS, 512 SENDS, 512 RECEIVES
	ADEF	(CTX,<4B8!1000>)	;CONTEXT QUOTAS
					; 4 SAVED CONTEXTS, 512 SAVED PAGES
	ADEF	(WCH,<JW.WMT>)		;WATCH MTA
	ADEF	(ACC,<-1>)		;ALL ACCESS TYPES
	ADEF	(ENQ,<777>)		;ENQ/DEQ QUOTA
	ADEF	(EXP,<-1>)		;EXPIRATION DATE/TIME

	RELOC	DEFACT+.AEMIN
; MACRO TO GENERATE WORDS IN THE BAD PROFILE
DEFINE	ABAD	(OFS,DAT),<
	RELOC	BADACT+.AE'OFS
	DAT
>

BADACT:	ABAD	(VRS,<ACTFMT,,.AEMIN>)	;VERSION AND LENGTH
	ABAD	(PPN,<0,,0>)		;PPN
	ABAD	(NAM,<BYTE(8)"U","n","k","n","o","w","n"," ","U","s","e","r">)
	ABAD	(PRV,<0,,0>)		;PRIVILEGE WORD 1
					; NO PRIVS
	ABAD	(PRX,<0>)		;PRIVILEGE WORD 2
					; NO PRIVS
	ABAD	(LGT,<-1>)		;LOGIN TIMES
					; ALL HOURS (WEEKDAYS AND WEEKENDS)
	ABAD	(COR,<1000,,1000>)	;PHYSICAL,,VIRTUAL CORE LIMITS
	ABAD	(IPC,<0>)		;IPCF QUOTAS
					; 0 PIDS, 0 SENDS, 0 RECEIVES
	ABAD	(CTX,<1B8!1000>)	;CONTEXT QUOTAS
					; 1 SAVED CONTEXT, 512 SAVED PAGES
	ABAD	(WCH,<JW.WMT>)		;WATCH BITS - MTA
	ABAD	(EXP,<-1>)		;EXPIRATION DATE/TIME

	RELOC	BADACT+.AEMIN
SUBTTL	Accounting routines -- TIMCHK - Check for access times


TIMCHK:	SKIPE	FAILFL		;ABOUT TO FAIL?
	POPJ	P,		;YES--LET USER THINK ALL IS WELL
	MOVE	T2,AENTRY+.AELGT;PICK UP TIME TO LOGIN TIMES WORD
	TDNN	T2,NOWBIT	;IS HE ALLOWED NOW?
	REQUE	SOT,<PPN not valid for this time of day>
	POPJ	P,		;RETURN
SUBTTL	KJOB routines -- CHKQTA - Main quota checking loop


CHKQTA:	PUSHJ	P,.SAVE1##	;SAVE P1
	SETZ	P1,		;INITIALIZE ERROR COUNT
	PUSHJ	P,INIQTA	;INITIALIZE STRUCTURE LIST
	SETZM	TOTBLK		;INITIALIZE TOTAL BLOCKS USED
	SETOM	RDUFLG		;SET SO WE GET A RECOMPUTING MSG
	SETOM	QTACNT		;START AT THE BEGINNING

CHKQT1:	PUSHJ	P,NXTQTA	;GET THE NEXT STRUCTURE IN THE S/L
	  JRST	CHKQT3		;DONE
	SETZ	T1,		;CHECK QUOTAS
	PUSHJ	P,UFDDMO	;DISMOUNT THE STRUCTURE
	  JRST	CHKQT2		;ERROR
	MOVE	T1,UFDARG+.UFUSD ;GET THE NUMBER OF BLOCKS USED
	ADDM	T1,TOTBLK	;UPDATE THE TOTAL NUMBER OF BLOCKS
	JRST	CHKQT1		;FIND NEXT STRUCTURE
CHKQT2:	MOVE	T1,UFDARG+.UFERR ;GET THE ERROR CODE
	CAIN	T1,UFSND%	;STRUCTURE NOT DISMOUNTED (OVER QUOTA)
	SKIPE	U.KJOB		;AND DOING /BATCH?
	AOJA	P1,CHKQT1	;NO, UNRECOVERABLE ERRORS
	PUSHJ	P,LGTBAT	;YES, ENFORCE LOGGED-OUT QUOTA
	ADDM	T1,TOTBLK	;UPDATE THE TOTAL NUMBER OF BLOCKS
	SETOM	U.NMSG		;SHOW SUMMARY, EVEN IF /NOMESSAGE
	MOVX	T1,UF.NOQ	;DO NOT CHECK QUOTAS
	PUSHJ	P,UFDDMO	;DISMOUNT THE STRUCTURE
	  AOJA	P1,CHKQT1	;ERROR: FIND THE NEXT STRUCTURE
	JRST	CHKQT1		;FIND NEXT STRUCTURE
CHKQT3:	JUMPE	P1,.POPJ##	;NO UNRECOVERABLE ERRORS: RETURN
	PUSHJ	P,RESQTA	;RESTORE THIS JOB'S SEARCH LIST
	RESET			;RESET I/O
	MONRT.			;EXIT QUIETLY
	JRST	.-1		;WATCH FOR CONTINUE
SUBTTL	KJOB routines -- INIQTA - Initialize the list of structures


;CALL INIQTA TO RECORD THE JOB SEARCH LIST IN QTATAB AND SET UP FOR
;	SUBSEQUENT CALLS TO NXTSTR TO RETURN NEXT STRUCTURE IN JOB'S
;	SEARCH LIST.

INIQTA:	SETZM	QTANUM		;CLEAR NUMBER OF STRUCTURES IN JSL
	SETO	T2,		;START WITH FIRST STRUCTURE
INIQT1:	MOVE	T1,[3,,T2]	;GET POINTER TO ARGUMENTS
	JOBSTR	T1,		;ASK FOR NEXT STR IN JOB SEARCH LIST
	  JRST	INIQT3		;ERROR
	CAMN	T2,[-1]		;END OF LIST IF -1
	POPJ	P,		;RETURN
	AOS	T1,QTANUM	;BUMP NUMBER OF STRUCTURES
	CAILE	T1,STRMAX	;TOO MANY STRUCTURES?
	JRST	INIQT2		;YES, ERROR
	SUBI	T1,1		;WE WANT AN OFFSET
	IMULI	T1,.DFJBL	;TIMES LENGTH OF AN ENTRY
	MOVEM	T2,QTATAB+.DFJNM(T1) ;STORE STRUCTURE NAME
	MOVEM	T3,QTATAB+.DFJDR(T1) ;STORE RESERVED QUOTA
	MOVEM	T4,QTATAB+.DFJST(T1) ;STORE STATUS BITS
	JRST	INIQT1		;ON TO NEXT STRUCTURE

INIQT2:	WARN	TMS,<Too mamy structures - no quota enforcement>
	SOSA	QTANUM		;
INIQT3:	WARN	JUF,<JOBSTR UUO failed - no quota enforcement>
	POPJ	P,		;
SUBTTL	KJOB routines -- NXTQTA - Get next structure in search list


;CALL NXTQTA WILL THE CURRENT STRUCTURE NAME IN QTATAB TO RETURN
;	THE NEXT STRUCTURE IN THE SEARCH LIST IN QTATAB.
;
;WHEN THE END OF THE SEARCH LIST IS REACHED (OR IF JOBSTR FAILS),
;	THE NON-SKIP RETURN IS TAKEN.

NXTQTA:	AOS	T4,QTACNT	;ADVANCE TO NEXT STRUCTURE
	CAML	T4,QTANUM	;GONE PAST THE END?
	POPJ	P,		;YES, TAKE DONE RETURN
	IMULI	T4,.DFJBL	;TIMES LENGTH OF AN ENTRY
	SKIPN	T1,QTATAB+.DFJNM(T4) ;GET STRUCTURE NAME
	JRST	NXTQTA		;SKIP THE FENCE
	MOVEM	T1,UFDFSN	;SAVE FOR POSTERITY
;	MOVE	T2,QTATAB+.DFJDR(T4) ;GET RESERVED QUOTA
	MOVE	T3,QTATAB+.DFJST(T4) ;GET STATUS BITS
	TXZN	T3,DF.SWL	;WAS SOFTWARE WRITE LOCK SET?
	JRST	.POPJ1##	;NO, SKIP RETURN
	MOVX	T1,.FSMNW	;LOAD FUNCTION CODE INTO T1
	MOVE	T2,UFDFSN	;PICK UP STRUCTURE NAME AGAIN
	MOVE	T4,[3,,T1]	;POINT AT ARGUMENTS
	STRUUO	T4,		;CLEAR SOFTWARE WRITE-LOCK
	  SKIPA	T1,UFDFSN	;ERROR
	JRST	.POPJ1##	;NOERROR: SKIP RETURN
	WARN	CCW,<Can't clear software write-lock on >,,.TSIXN##
	POPJ	P,		;ERROR RETURN
SUBTTL	KJOB routines -- RESQTA - Restore this job's search list


RESQTA:	SKIPG	QTANUM		;ANY STRUCUTURES IN S/L?
	POPJ	P,		;NO, NOTHING TO RESTORE
	MOVX	T1,.FSDSL	;FUNCTION TO DEFINE S/L
	MOVEM	T1,QTAUUO+.FSFCN
	MOVE	T1,THSJOB	;MY JOB NUMBER
	MOVEM	T1,QTAUUO+.FSDJN
	MOVE	T1,.MYPPN##	;MY PPN
	MOVEM	T1,QTAUUO+.FSDPP
	SETZM	QTAUUO+.FSDFL	;NO FLAGS
	MOVE	T1,QTANUM	;GET NUMBER OF STRUCTURES
	IMULI	T1,.DFJBL	;TIMES LENGTH OF AN ENTRY
	ADDI	T1,.FSDSO	;ADD IN HEADER LENGTH
	HRLI	T1,QTAUUO	;POINT AT ARGUMENTS
	MOVSS	T1		;...
	STRUUO	T1,		;PUT S/L BACK IN ORIGINAL ORDER
	  JFCL			;WE TRIED
	POPJ	P,		;RETURN
SUBTTL	KJOB routines -- LGTBAT - Batch deletion algorithm


LGTBAT:	PUSHJ	P,.SAVE1##	;SAVE P1
	SETZM	BATTOT		;CLEAR TOTAL BLOCKS
	SETZM	BATNQC		;CLEAR TOTAL NQC BLOCKS
	SETZM	BATDFL		;CLEAR NUMBER OF FILES DELETED
	MOVE	T1,UFDARG+.UFQTO
	MOVEM	T1,BATQTO	;QUOTA OUT
	PUSHJ	P,STEP1		;GO TO STEP 1
	RELEAS	IOC,		;RELEASE THE CHANNEL
	MOVE	T1,BATTOT	;RETURN THE TOTAL NUMBER OF BLOCKS
	ADD	T1,BATNQC	; (BOTH CHECKED AND UNCHECKED)
	POPJ	P,		;
SUBTTL	KJOB routines -- STEP1 - Delete files that are too large


;STEP 1 OF THE FILE-DELETION ALGORITHM DOES A RECOMP OF THE SPECIFIED 
;	UFD, AND DELETES ALL FILES WHICH ARE STRICTLY LARGER THAN THE
;	LOGGED-OUT QUOTA.

STEP1:	PUSHJ	P,BATALL	;SETUP TO GET *.*

STEP1A:	PUSHJ	P,BATNXT	;GET A FILE TO WORK ON
	  JRST	STEP1C		;NO MORE FILES
	OPEN	IOC,OPN		;OPEN THE CHANNEL
	  JRST	STEP1A		;LOSE, IGNORE IT
	LOOKUP	IOC,LEB		;LOOKUP THE FILE
	  JRST	STEP1A		;LOSE, IGNORE IT
	MOVX	T4,RP.NQC	;GET NQC BIT
	TDNE	T4,LEB+.RBSTS	;IS IT SET?
	JRST	STEP1D		;YES, COUNT THE FILE
	MOVE	T3,LEB+.RBALC	;GET BLOCKS ALLOCATED
	SKIPE	LEB+.RBSIZ	;CHECK FOR ZERO BLOCK FILES
	CAMLE	T3,BATQTO	;LARGER THAN QUOTA?
	JRST	STEP1B		;YES, DELETE IT
	ADDM	T3,BATTOT	;NO, ACCUMLATE THE TOTAL
	JRST	STEP1A		;AND LOOP

STEP1B:	PUSHJ	P,BATDEL	;DELETE THE FILE
	JRST	STEP1A		;AND LOOP

STEP1C:	MOVE	T1,BATTOT	;GET TOTAL BLOCKS
	CAMG	T1,BATQTO	;GREATER THAN QUOTA?
	POPJ	P,		;NO, EXIT THE ALGORITHM
	JRST	STEP2		;YES, GO ON TO STEP 2

STEP1D:	MOVE	T3,LEB+.RBALC	;GET BLOCKS ALLOCATED
	ADDM	T3,BATNQC	;ADD TO TOTAL
	JRST	STEP1A		;AND LOOP AROUND
SUBTTL	KJOB routines -- STEP2 - Delete FIRST files


;STEP 2 OF THE FILE-DELETION ALGORITHM LOOPS THRU THE 'FIRST' TABLE
;	OF EXTENSIONS IN ORDER, AND FOR EACH EXTENSION, 'EXT', WE
;	BEGIN DELETING ALL UNPROTECTED (<200) *.EXT UNTIL WE ARE
;	UNDER QUOTA.  IF WE DELETE *.EXT AND ARE STILL OVER QUOTA
;	WE GO ON TO THE NEXT EXTENSION.  IF WE REACH THE END OF THE
;	TABLE, ON TO STEP 3.

STEP2:	MOVEI	P1,FIRST	;START ADR OF TABLE
	HRLI	P1,-FIRLEN	;AND NEGATIVE LENGTH

STEP2A:	MOVE	T1,(P1)		;GET EXT,,MASK
	PUSHJ	P,BATEXT	;SETUP TO GET *.EXT

STEP2B:	PUSHJ	P,BATNXT	;GET A FIND
	  JRST	STEP2C		;THAT'S ALL FOLKS
	MOVEI	T1,177		;MAX PROTECTION
	PUSHJ	P,BATLKP	;LOOKUP AND DELETE
	MOVE	T1,BATTOT	;GET TOTAL BLOCKS USED
	CAMG	T1,BATQTO	;STILL OVER QUOTA?
	POPJ	P,		;NO, RETURN
	JRST	STEP2B		;YES, LOOP

STEP2C:	AOBJN	P1,STEP2A	;FINISHED THAT EXT,
				; ON TO THE NEXT
	JRST	STEP3		;NO NEXT EXT, ON TO STEP 3
SUBTTL	KJOB routines -- STEP3 - Get all other unIMPORTant files


;STEP 3 DELETES ALL REMAINING UNPROTECTED FILES WHOSE EXTENSIONS DON'T
;	APPEAR IN THE "IMPORT" TABLE.

STEP3:	PUSHJ	P,BATALL	;SETUP TO READ ABSOLUTELY EVERYTHING

STEP3A:	PUSHJ	P,BATNXT	;GET A FILE TO LOOKUP
	  JRST	STEP4		;NO MORE, ON TO STEP 4
	MOVE	P1,[-IMPLEN,,IMPORT] ;POINT TO IMPORT TABLE
	HLLZ	T3,LEB+.RBEXT	;GET THE EXTENSION OF THE FILE

STEP3B:	CAMN	T3,(P1)		;MATCH???
	JRST	STEP3A		;YES, IT'S IMPORTANT, SKIP IT
	AOBJN	P1,STEP3B	;NO, KEEP LOOPING

STEP3C:	MOVEI	T1,177		;MAX PROTECTION
	PUSHJ	P,BATLKP	;AND LOOKUP AND DELETE
	MOVE	T1,BATTOT	;GET THE TOTAL
	CAMG	T1,BATQTO	;STILL OVER QUOTA?
	POPJ	P,		;NO, DONE!!
	JRST	STEP3A		;YES, KEEP GOING
SUBTTL	KJOB routines -- STEP4 - Delete rest of FIRST files


;STEP FOUR OF THE FILE-DELETION ALGORITHM DELETES ALL REMAINING
;	FILES WHOSE EXTENSION IS IN THE "FIRST" TABLE.  THE TABLE
;	IS, AS IN STEP 2, SCANNED IN ORDER AND THE ALGORITHM STOPS
;	AS SOON AS WE ARE UNDER QUOTA.

STEP4:	MOVEI	P1,FIRST	;START ADR OF TABLE
	HRLI	P1,-FIRLEN	;AND NEGATIVE LENGTH

STEP4A:	MOVE	T1,(P1)		;GET EXT,,MASK
	PUSHJ	P,BATEXT	;SETUP TO GET *.EXT

STEP4B:	PUSHJ	P,BATNXT	;GET A FIND
	  JRST	STEP4C		;THAT'S ALL FOLKS
	MOVEI	T1,1000		;SUPER MAX
	PUSHJ	P,BATLKP	;LOOKUP AND DELETE
	MOVE	T1,BATTOT	;GET TOTAL BLOCKS USED
	CAMG	T1,BATQTO	;STILL OVER QUOTA?
	POPJ	P,		;NO, RETURN
	JRST	STEP4B		;YES, LOOP

STEP4C:	AOBJN	P1,STEP4A	;FINISHED THAT EXT,
				; ON TO THE NEXT
	JRST	STEP5		;NO NEXT EXT, ON TO STEP 5
SUBTTL	KJOB routines -- STEP5 - Delete unprotected IMPORTant files


;STEP FIVE DELETES ALL FILES WHOSE EXTENSIONS APPEAR IN
;	THE "IMPORT" TABLE WHICH ARE UNPROTECTED.

STEP5:	MOVEI	P1,IMPORT	;START ADR OF TABLE
	HRLI	P1,-IMPLEN	;AND NEGATIVE LENGTH

STEP5A:	HLLO	T1,(P1)		;GET EXT,,MASK
	PUSHJ	P,BATEXT	;SETUP TO GET *.EXT

STEP5B:	PUSHJ	P,BATNXT	;GET A FIND
	  JRST	STEP5C		;THAT'S ALL FOLKS
	MOVEI	T1,177		;MAX PROTECTION
	PUSHJ	P,BATLKP	;LOOKUP AND DELETE
	MOVE	T1,BATTOT	;GET TOTAL BLOCKS USED
	CAMG	T1,BATQTO	;STILL OVER QUOTA?
	POPJ	P,		;NO, RETURN
	JRST	STEP5B		;YES, LOOP

STEP5C:	AOBJN	P1,STEP5A	;FINISHED THAT EXT,
				; ON TO THE NEXT
	JRST	STEP6		;NO NEXT EXT, ON TO STEP 6
SUBTTL	KJOB routines -- STEP6 - Delete rest of unIMPORTant files


;STEP 6 IS SIMILAR TO STEP 3 IN THAT IT GETS FILES WHOSE EXTENSIONS
;	DON'T APPEAR IN THE "IMPORT" TABLE, EXCEPT THAT NOW IT
;	IGNORES THE PROTECTION AND JUST DELETES THE FILE.

STEP6:	PUSHJ	P,BATALL	;SETUP TO READ ABSOLUTELY EVERYTHING

STEP6A:	PUSHJ	P,BATNXT	;GET A FILE TO LOOKUP
	  JRST	STEP7		;NO MORE, ON TO STEP 7
	MOVE	P1,[-IMPLEN,,IMPORT] ;POINT TO IMPORT TABLE
	HLLZ	T3,LEB+.RBEXT	;GET THE EXTENSION OF THE FILE

STEP6B:	CAMN	T3,(P1)		;MATCH???
	JRST	STEP6A		;YES, IT'S IMPORTANT, SKIP IT
	AOBJN	P1,STEP6B	;NO, KEEP LOOPING

STEP6C:	MOVEI	T1,1000		;SUPER MAX PROTECTION
	PUSHJ	P,BATLKP	;LOOKUP IT AND DELETE
	MOVE	T1,BATTOT	;GET THE TOTAL
	CAMG	T1,BATQTO	;STILL OVER QUOTA?
	POPJ	P,		;NO, DONE!!
	JRST	STEP6A		;YES, KEEP GOING
SUBTTL	KJOB routines -- STEP7 - Delete the rest of the files


;STEP 7 SIMPLY DELETES EVERYTHING

STEP7:	PUSHJ	P,BATALL	;SETUP TO GET EVERYTHING

STEP7A:	PUSHJ	P,BATNXT	;GET A FILE
	  POPJ	P,		;WE'RE DONE...
	MOVEI	T1,1000		;GET THEM ALL!!!
	PUSHJ	P,BATLKP	;LOOKUP AND DELETE
	MOVE	T1,BATTOT	;GET TOTAL
	CAMG	T1,BATQTO	;DONE YET?
	POPJ	P,		;YES, RETURN
	JRST	STEP7A		;NO, LOOP
SUBTTL	KJOB routines -- BATLKP - Routine to LOOKUP a file


;BATLKP IS CALLED WITH T1 CONTAINING A PROTECTION, AND T2 CONTAINING
;	THE ADDRESS OF A LOOKUP BLOCK.  THE FILE IS LOOK-ED UP, AND
;	IF THE PROTECTION IS .LE. THAN THE PROTECTION SPECIFIED
;	BY THE USER IN T1, THE FILE IS DELETED, AND ALL COUNTS
;	ARE UPDATED.
;
;IF THE FILE IS ANY SFD, TRY TO DELETE IT IN ANY CASE

BATLKP:	OPEN	IOC,OPN		;OPEN THE CHANNEL
	  POPJ	P,		;FAILED, FORGET IT
	LOOKUP	IOC,LEB		;LOOKUP THE FILE
	  POPJ	P,		;FAILED, FORGET IT
	MOVX	T2,RP.NQC	;GET NQC BIT
	TDNE	T2,LEB+.RBSTS	;IS IT AN NQC FILE?
	POPJ	P,		;YES, IGNORE IT
	HLRZ	T2,LEB+.RBEXT	;GET THE FILE EXTENSION
	MOVEI	T3,0		;LOAD A SMALL PROTECTION
	CAIE	T2,'SFD'	;SKIP IF ITS AN SFD
	LDB	T3,[POINT 9,LEB+.RBPRV,8] ;GET THE PROTECTION
	CAMLE	T3,T1		;IS IT LESS?
	POPJ	P,		;YES, JUST RETURN
	MOVN	T1,LEB+.RBALC	;NO, GET RIBALC
	ADDM	T1,BATTOT	;AND DECREMENT TOTAL
	PJRST	BATDEL		;DELETE THE FILE
SUBTTL	KJOB routines -- BATDEL - Routine to DELETE a file


;BATDEL IS CALLED WITH T1 CONTAINING THE ADDRESS OF THE LOOKUP BLOCK.
;	A MESSAGE IS TYPED AND THE FILE (WHICH IS ASSUMED TO BE
;	LOOK'ED UP)  IS DELETED.

BATDEL:	SETZB	T1,T2		;CLEAR A RENAME BLOCK
	SETZB	T3,T4		; "        "
	RENAME	IOC,T1		;DELETE THE FILE
	  JRST	BATDE2		;FAILED?
	SKIPE	BATDFL		;DID WE DELETE ANY ALREADY?
	JRST	BATDE1		;YES, SKIP THE EXTRA MESSAGE
	MOVEI	T1,[ASCIZ /Files deleted:
/]
	PUSHJ	P,.TSTRG##	;NO, TYPE THE MESSAGE

BATDE1:	AOS	BATDFL		;ANOTHER ONE DELETED
	MOVEI	T1,[ASCIZ /   /] ;LOAD SOME SPACES
	PUSHJ	P,.TSTRG##	;AND TYPE THEM
	MOVEI	T1,OPN		;GET ADR OF OPEN BLOCK
	MOVEI	T2,LEB		;GET ADR OF LKP BLOCK
	PUSHJ	P,.TOLEB##	;TYPE A FILESPEC
	MOVEI	T1,[ASCIZ /       /] ;LOAD SEVEN SPACES
	PUSHJ	P,.TSTRG##	;TO LINE UP TAB STOPS
	PUSHJ	P,.TTABC##	;A TAB
	MOVE	T1,LEB+.RBALC ;GET BLOCKS ALLOCATED
	PUSHJ	P,.TDECW##	;TYPE IT
	MOVEI	T1,[ASCIZ / blocks freed/]
	PUSHJ	P,.TSTRG##	;AND TYPE IT
	PJRST	.TCRLF##	;AND A CRLF AND RETURN

BATDE2:	MOVE	T1,LEB+.RBALC	;GET BLOCKS ALLOCATED
	ADDM	T1,BATTOT	;ADD BACK IN
	HRRZS	T2		;GET ONLY THE ERROR CODE IN T2
	CAIE	T2,ERPRT%	;IS IT PROTECTION FAILURE?
	ADDM	T1,BATQTO	;NO, MAKE HIS QUOTA BIGGER (SORT OF)
	CAIN	T2,ERDNE%	;TRYING TO DELETE NON-EMPTY DIRECTORY?
	POPJ	P,		;YES - JUST RETURN
	PUSH	P,T2		;SAVE ERROR CODE
	MOVX	T1,'LGNCDF'	;GET PREFIX
	MOVE	T2,["%",,[ASCIZ |Cannot delete file: |]]
	PUSHJ	P,.ERMSG##	;TYPE IT
	MOVEI	T1,OPN		;GET ADDRESS OF OPEN BLOCK
	MOVEI	T2,LEB		;GET ADDRESS OF LOOKUP BLOCK
	PUSHJ	P,.TOLEB##	;TYPE A FILESPEC
	MOVEI	T1,[ASCIZ | ; error code |] ;MORE TEXT
	PUSHJ	P,.TSTRG##	;TYPE IT
	POP	P,T1		;GET ERROR CODE
	PUSHJ	P,.TOCTW##	;TYPE IT
	PJRST	.TCRLF##	;TYPE A CRLF AND RETURN
DEFINE FIRMAC,<
	X	TMP,777777
	X	TEM,777777
	X	SFD,777777
	X	BAK,777777
	X	Q??,770000
	X	MAP,777777
	X	CRF,777777
	X	LSD,777777
	X	LSQ,777777
	X	LST,777777
	X	LIS,777777
	X	LPT,777777
	X	PTP,777777
	X	PLT,777777
	X	CDP,777777
	X	Z??,770000
	X	FOO,777777
	X	LOG,777777
	X	BIN,777777
	X	DMP,777777
	X	FIN,777777
>  ;END DEFINE FIRMAC


;NOW GENERATE THE "FIRST" TABLE

DEFINE X(A,B),<
	XLIST
	<SIXBIT /A/>+B
	LIST
>  ;END DEFINE X

FIRST:	FIRMAC
	FIRLEN==.-FIRST
DEFINE IMPMAC,<
	X	RNO
	X	RND
	X	RNH
	X	CMD
	X	KBD
	X	CED
	X	MCR
	X	SNO
	X	FAI
	X	FOR
	X	F4
	X	MAC
	X	ALG
	X	AID
	X	BLI
	X	B10
	X	B11
	X	COB
	X	CBL
	X	BAS
	X	PAL
	X	P11
	X	SRC
	X	IDA
	X	IDX
	X	DAT
	X	DBS
	X	B16
	X	B32
	X	B36
	X	REQ
	X	R16
	X	R36
	X	PAS
	X	INI
>  ;END DEFINE IMPMAC

;NOW GENERATE THE "IMPORT" TABLE

DEFINE X(A),<
	XLIST
	SIXBIT /A/
	LIST
>  ;END DEFINE X

IMPORT:	IMPMAC
	IMPLEN==.-IMPORT
SUBTTL	KJOB routines -- BATALL - Setup to LOOKUP STR:[,,**]



;THIS ROUTINE WAS ORIGINALLY WRITTEN BY DON LEWINE FOR LOGIN VERSION
;	55.  MY THANKS TO HIM FOR SUPPLYING IT FULLY DEBUGGED./LSS 


BATALL:	MOVE	T1,[WILDBK,,WILDBK+1]	;BLT POINTER TO WILD BLOCK
	SETZM	WILDBK			;CLEAR THE FIRST WORD
	BLT	T1,WILDBK+.FXLEN-1	;AND CLEAR THE REST

	MOVE	T1,UFDARG+.UFSTR	;
	MOVEM	T1,WILDBK+.FXDEV	;SAVE THE STRUCTURE
	MOVE	T1,.MYPPN##		;
	MOVEM	T1,WILDBK+.FXDIR	;SAVE THE PPN
	SETOM	WILDBK+.FXDIM		;AND SET DIRECTORY MASK
	MOVX	T1,FX.DIR!FX.PHY!FX.NOM!FX.PRT
	MOVEM	T1,WILDBK+.FXMOD	;STORE ALL THE STATUS BITS
	TXO	T1,FX.STR		;SET ANOTHER BIT
	MOVEM	T1,WILDBK+.FXMOM	;AND THE MASK FOR THE MOD WORD

	MOVSI	T1,'*  '		;CLASSICAL WILDCARD
	MOVEM	T1,WILDBK+.FXNAM	;STORE AS	FILENAME
	MOVEM	T1,WILDBK+.FXEXT	;		EXTENSION
	MOVEM	T1,WILDBK+.FXDIR+2	;		1ST SFD
	MOVEM	T1,WILDBK+.FXDIR+4	;		2ND SFD
	MOVEM	T1,WILDBK+.FXDIR+6	;		3RD SFD
	MOVEM	T1,WILDBK+.FXDIR+10	;		4TH SFD
	MOVEM	T1,WILDBK+.FXDIR+12	;		5TH SFD

	SETOM	WILDBK+.FXBFR		;NO /BEFORE
	SETOM	WILDBK+.FXSNC		;NO /SINCE

	SETZM	WILDPT			;WILD'S POINTER
	POPJ	P,			;RETURN
SUBTTL	KJOB routines -- BATEXT - Setup to read *.EXT[*,*,*,*,*]


;BATALL IS CALLED TO SETUP A WILD BLOCK TO LOOKUP EVERY FILE ON A
;	STRUCTURE WITH A GIVEN EXTENSION,,MASK (IN T1).  USES T1.

BATEXT:	PUSH	P,T1		;SAVE EXT,,MASK
	PUSHJ	P,BATALL	;SETUP TO READ *.*
	POP	P,WILDBK+.FXEXT	;STORE EXT,,MASK
	POPJ	P,		;AND RETURN
SUBTTL	KJOB routines -- BATNXT - Routine to call .LKWLD


;BATNXT IS CALLED WITH T1 CONTAINING THE ADDRESS OF AN OPEN BLOCK,
;	AND T2 CONTAIN XWD SIZE,,ADR WHERE ADR IS THE ADDRESS OF A
;	LOOKUP BLOCK, AND SIZE IS THE LENGTH OF THE BLOCK - 1 
;	(I.E. THE NUMBER OF RIB WORDS DESIRED).  IF ANY OF THESE
;	FIELDS ARE ZERO UPON CALLING BATNXT, IT IS FILLED IN WITH
;	DEFAULT PARAMETERS.  BATNXT ALL CALLS .LKWLD TO SETUP
;	THE LOOKUP AND OPEN BLOCK FOR THE NEXT FILE (.LGTSA SHOULD
;	BE CALLED TO SET EVERYTHING UP BEFORE THE FIRST CALL).
;	RETURNS T1 AND T2 UNCHANGED (WITH MISSING FIELDS FILLED).
;	SKIP RETURN WITH NEXT FILE, NON-SKIP IF NO MORE FILES.


BATNXT:	MOVSI	T1,[WILDBK]	;
	MOVEM	T1,WLDARG+0	;FIRST FILE SPEC,,LAST FILE SPEC
	MOVE	T1,[OPN,,LEB]	;
	MOVEM	T1,WLDARG+1	;OPEN BLOCK,,LOOKUP BLOCK
	MOVE	T1,[.FXLEN,,.RBMAX]
	MOVEM	T1,WLDARG+2	;FILE SPEC SIZE,,LOOKUP BLOCK SIZE
	MOVEI	T1,WILDPT	;
	MOVEM	T1,WLDARG+3	;ADDRESS OF POINTER (NO CHANNEL)
	MOVE	T1,[4,,WLDARG]	;LENGTH,,ADDRESS
	PUSHJ	P,.LKWLD##	;CALL WILD
	  POPJ	P,		;NO MORE!!
	PJRST	.POPJ1##	;SKIP RETURN
SUBTTL	File I/O -- DELFIL - Delete a single file


DELFIL:	MOVE	T1,[.FOMAX,,FOP] ;SET UP UUO AC
	HRRZ	T2,FOP+.FOLEB	;POINT TO LOOKUP/ENTER BLOCK FOR LATER
	FILOP.	T1,		;DELETE THE FILE
	  TDZA	T2,T2		;ERROR
	JRST	DELFI1		;RETURN WITH FILE SIZE
	CAIE	T1,ERPRT%	;PROTECTION FAILURE?
	WARN	CDF,<Cannot delete >,,E.CDF

DELFI1:	LDB	T1,[POINTR (FOP+.FOFNC,FO.CHN)] ;GET CHANNEL
	RESDV.	T1,		;RELEASE CHANNEL
	  JFCL			;...
	JUMPE	T2,.POPJ##	;ERROR: RETURN
	MOVE	T1,.RBALC(T2)	;RETURN WITH ALLOCATED FILE SIZE
	PJRST	.POPJ1##	;


E.CDF:	PUSH	P,T1		;SAVE ERROR CODE
	MOVEI	T1,FOP		;POINT TO FILOP BLOCK
	PUSHJ	P,.TOFEB##	;TYPE FILESPEC
	MOVEI	T1,[ASCIZ /; error /]
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	POP	P,T1		;GET ERROR CODE BACK
	PJRST	.TOCTW##	;PRINT IT AND RETURN
SUBTTL	File I/O -- INIFIL - Initialize I/O data storage


; ZERO I/O DATA STORAGE AND DEFAULT THE FILESPEC TO
; DSK:[,]/PHYSICAL/ASCII
; CALL:	PUSHJ	P,INIFIL

INIFIL:	SETZM	IO.ZB		;CLEAR FIRST WORD
	MOVE	T1,[IO.ZB,,IO.ZB+1] ;SET UP BLT
	BLT	T1,IO.ZE-1	;CLEAR I/O DATA STORAGE

; FILOP BLOCK
INIFOP:	MOVE	T1,[RNB,,LEB]	;RENAME AND LOOKUP/ENTER BLOCKS
	MOVEM	T1,FOP+.FOLEB
	MOVE	T1,[.FOFMX,,RFS] ;RETURNED FILESPEC BLOCK
	MOVEM	T1,FOP+.FOFSP

; OPEN BLOCK
INIOPN:	MOVE	T1,[UU.PHS+.IOASC] ;DEFAULT IS ASCII /PHYSICAL
	MOVEM	T1,FOP+.FOIOS
	MOVSI	T1,'DSK'	;DEFAULT DEVICE
	MOVEM	T1,FOP+.FODEV

; LOOKUP/ENTER BLOCK
INILEB:	MOVEI	T1,.RBMAX	;LENGTH OF BLOCK
	MOVEM	T1,LEB+.RBCNT
	MOVE	T1,AENTRY+.AEPPN ;PPN
	MOVEM	T1,LEB+.RBPPN
	POPJ	P,		;RETURN
SUBTTL	File I/O -- NEWFIL - Check file creation time


; ROUTINE TO COMPARE CREATIONS DATES OF A FILE VS. THE
; UFD CREATION TIME.
; CALL:	PUSHJ	P,NEWFIL
;	  <NON-SKIP>		;OLD FILE
;	<SKIP>			;NEW FILE

NEWFIL:	LDB	T1,[POINTR(LEB+.RBPRV,RB.CRD)] ;GET LOW DATE
	LDB	T2,[POINTR(LEB+.RBEXT,RB.CRX)] ;GET HIGH DATE
	LSH	T2,^D12		;POSITION
	IORI	T1,(T2)		;FORM STANDARD 15-BIT DATE
	LDB	T2,[POINTR(LEB+.RBPRV,RB.CRT)] ;GET CREATE TIME
	CAMLE	T1,UFDDAT	;FILE NEWER THAN UFD CREATION?
	JRST	.POPJ1##	;YES
	CAMN	T1,UFDDAT	;SAME DAY?
	CAMGE	T2,UFDTIM	;YES--FILE NEWER THAN UFD CREATION?
	POPJ	P,		;OLDER
	JRST	.POPJ1##	;A NEW FILE
SUBTTL	File I/O -- NOTE - Print file(s) specified by /NOTE switch


NOTE:	TLNE	F,FL.BYP	;BYPASSING THE ACCOUNTING SYSTEM?
	POPJ	P,		;YES--PROBABLY DON'T WANT THIS STUFF
	MOVEI	T1,NOTSPC	;/NOTE FILESPEC
	MOVEI	P1,FNAME	;PRINT FILE NAME
	PJRST	TYPE		;DO PRINT IT AND RETURN
SUBTTL	File I/O -- NOTICE - Print NOTICE.TXT


NOTICE:	TLNE	F,FL.BYP	;BYPASSING THE ACCOUNTING SYSTEM?
	POPJ	P,		;YES--PROBABLY DON'T WANT THIS STUFF
	MOVE	T1,[DAYSPC]	;PRINT NOTICE.TXT
	MOVEI	P1,0		;FLAGS
	PJRST	TYPE		;GO PRINT IT AND RETURN


; SCAN BLOCK FOR SYS:NOTICE.TXT/PHYSICAL/NOSTR
DAYSPC:	SIXBIT	/SYS/
	SIXBIT	/NOTICE/
	EXP	-1
	XWD	'TXT',-1
	EXP	FX.PHY!FX.NOM
	EXP	FX.STR!FX.PHY!FX.NOM
	BLOCK	.FXLEN-<.-DAYSPC>
SUBTTL	File I/O -- STRMES - Print STR.TXT


STRMES:	SKIPG	U.STR		;/STR GIVEN
	POPJ	P,0		;NO--RETURN
	MOVEI	T1,STRSPC	;STR.TXT SPEC
	MOVEI	P1,MSGOK!FNAME!STONLY ;OK TO TYPE MESSAGE
	PJRST	TYPE		;GO PRINT IT AND RETURN


; SCAN BLOCK FOR SYS:STR.TXT/PHYSICAL/STRS
STRSPC:	SIXBIT	/ALL/
	SIXBIT	/STR/
	EXP	-1
	XWD	'TXT',-1
	EXP	FX.PHY!FX.STR
	EXP	FX.PHY!FX.STR
	XWD	1,4
	XWD	-1,-1
	BLOCK	.FXLEN-<.-STRSPC>
SUBTTL	File I/O -- LGNMES - Print LOGIN.TXT


LGNMES:	MOVEI	T1,LGNSPC	;LOGIN.TXT SPEC
	MOVEI	P1,MSGOK	;ALWAYS TYPE MESSAGE
	PJRST	TYPE		;GO PRINT IT AND RETURN


; SCAN BLOCK FOR SYS:WELCOM.TXT/PHYSICAL/NOSTR
LGNSPC:	SIXBIT	/SYS/
	SIXBIT	/LOGIN/
	EXP	-1
	XWD	'TXT',-1
	EXP	FX.PHY!FX.NOM
	EXP	FX.STR!FX.PHY!FX.NOM
	BLOCK	.FXLEN-<.-LGNSPC>
SUBTTL	File I/O -- TYPE - Print a file on the terminal


;SUBROUTINE TO TYPE A FILE
;CALL:	MOVEI	T1,ADDRESS-OF-SCAN-STYLE-FILESPEC
;	MOVEI	P1,FLAGS
;	PUSHJ	P,TYPE
;	RETURN HERE

TYPE:	SKIPN	.FXNAM(T1)	;ANY NAME OR MASK SPECIFIED?
	  POPJ	P,		;NO - SKIP IT
	HRLZ	T1,T1		;FLIP AROUND
	HRRI	T1,TYPSPC	;ADDRESS OF OUT SPEC
	BLT	T1,TYPSPC+.FXLEN-1 ;COPY THE FILESPEC
	SETZM	WILDPT		;CLEAR MEMORY FOR FIRST CALL
	MOVX	T1,FX.NOM!FX.PRT ;/OKNONE AND /OKPROT
	IORM	T1,TYPSPC+.FXMOD;FORCE SWITCH TO BE
	IORM	T1,TYPSPC+.FXMOM; SET ON ALL CALLS TO WILD
TYPE1:	PUSHJ	P,INIFIL	;INIT STORAGE FOR FILE I/O
	MOVEI	T1,B.DC##	;SET UP ADDRESS OF BUFFER HEADER
	MOVEM	T1,OPN+.OPBUF	;SAVE
	MOVE	T1,[4,,[[TYPSPC],,0
			OPN,,LEB
			.FXLEN,,.RBMAX
			IOC,,WILDPT]]
	PUSHJ	P,.LKWLD##	;LOOK FOR FILE
	  POPJ	P,0		;ALL DONE
	OPEN	IOC,OPN		;OPEN THE FILE
	  PJRST	E.DFO##		;CAN'T
	LOOKUP	IOC,LEB		;LOOKUP FILE
	JRST	[PUSHJ P,E.DFL## ;REPORT ERROR
		 JRST  TYPE1]	;LOOK FOR NEXT FILE
	MOVE	T1,[2,,T2]	;SET UP UUO AC
	MOVE	T2,[IOC,,.FOFIL] ;CHANNEL,,FUNCTION CODE
	MOVE	T3,[.FOFMX,,RFS] ;LENGTH,,ADDR
	FILOP.	T1,		;READ LOOKUP'ED FILESPEC
	  JFCL			;CAN'T FAIL
IFN SUPNOT,<
	TRNE	P1,MSGOK	;WANT MESSAGE ALWAYS?
	JRST	TYPE3		;YES--GO TYPE IT
	SKIPE	UFDNDL		;SKIP IF UFD CAN BE DELETED
	JRST	TYPE2		; SAW THE MESSAGE
	PUSHJ	P,NEWFIL	;A NEW FILE?
	  JRST	TYPE2		;NO
	JRST	TYPE3		;YES--GO PRINT
TYPE2:	MOVE	T1,U.NOTC	;GET /NOTICE VALUE
	CAIL	T1,2		;[450,453] SOMETIMES OR NEVER?
	JRST	TYPE1		;YES -LOOK FOR NEXT FILE
>
TYPE3:	MOVE	T1,U.NOTC	;GET /NOTICE VALUE
	CAIN	T1,3		;NEVER PRINT?
	  JRST	TYPE1		;YES - SKIP IT
	MOVEI	T1,RFS		;POINT TO RETURNED FILESPEC BLOCK
	TXNE	P1,FNAME	;WANT TO SEE FILE NAME?
	INFO	FIL,<File: >,,.TFRFS##
TYPE4:	PUSHJ	P,.NXDTW##	;GET A BYTE
	  JRST	TYPE1		;END OF FILE
	PUSHJ	P,.TCHAR##	;TYPE IT
	JRST	TYPE4
SUBTTL	Command dispatch tables


DEFINE	X	(PFX,NAM,HLP,PRC,PMT,OSC),<<SIXBIT/NAM/>>
COMLST:	CMDS
COMLEN==.-COMLST

DEFINE	X	(PFX,NAM,HLP,PRC,PMT,OSC),<EXP	PRC>
COMDSP:	CMDS

DEFINE	X	(PFX,NAM,HLP,PRC,PMT,OSC),<XWD	PFX'PL,PFX'PB>
COMPBK:	CMDS

DEFINE	X	(PFX,NAM,HLP,PRC,PMT,OSC),<XWD	PFX'OL,PFX'OB>
COMOBK:	CMDS

DEFINE	X	(PFX,NAM,HLP,PRC,PMT,OSC),<EXP	[ASCIZ \'PMT\]>
COMPMT:	CMDS
SUBTTL	Command scanning routines -- ERRUKK/ERREXA/ERRILC - Error messages


; THESE ERROR MESSAGE EXIST BECAUSE WE CAN'T DISPATCH TO SCAN.
; SCAN WANTS TO RESTART .PSCAN WHICH GOES INTO AN INFINITE LOOP.

ERRUKK:	EXCH	T1,N		;SWAP KEYWORD WITH VALUE
	SKIPGE	N		;UNKNOWN OR AMBIGUOUS?
	FATAL	UKW,<Unknown keyword >,EF.SIL,.TSIXN##
	FATAL	AKW,<Ambiguous keyword >,EF.SIL,.TSIXN##

ERREXA:	FATAL	EXA,<Excess arguments starting with >,EF.SIL,E.EXA
ERRILC:	FATAL	ILC,<Illegal character >,EF.SIL,E.ILC

E.EXA:!
E.ILC:	MOVEI	T1,""""		;GET DOUBLE QUOTES
	PUSHJ	P,.TCHAR##	;PRINT THEM
	MOVE	T1,C		;GET CHARACTER IN ERROR
	PUSHJ	P,.TFCHR##	;PRINT POSSIBLE FUNNY CHARACTER
	SKIPE	.LASWD##	;HAVE A TYPEOUT ROUTINE?
	SKIPN	.NMUL##		;HAVE A WORD SCANNING RESULT?
	JRST	E.ILC1		;NO TO EITHER
	MOVEI	T1,[ASCIZ /" following word "/]
	PUSHJ	P,.TSTRG##	;PRINT STRING
	MOVE	T1,.NMUL##	;GET LAST WORD INPUT
	SKIPGE	T2,.LASWD##	;A STRING PERHAPS?
	MOVEI	T1,.NMUL##	;YES--GET ADDRESS INSTEAD
	PUSHJ	P,(T2)		;PRINT WORD (OR STRING) IN ERROR
E.ILC1:	MOVEI	T1,""""		;DOUBLE QUOTE
	PJRST	.TCHAR##	;PRINT IT AND RETURN
SUBTTL	Command scanning routines -- GETUSR - Read PPN/path/user name


GETUSR:	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	SETZB	PP,USERID	;CLEAR TARGET
	SETZM	USERID		;CLEAN OUT BLOCK BEFORE START
	MOVE	T1,[USERID,,USERID+1] ;BLT POINTER
	BLT	T1,USERID+.AANLW-1 ;CLEAN IT
	SKIPA			;ALREADY HAVE FIRST CHARACTER
GETUS1:	PUSHJ	P,.TICHE##	;GET FIRST CHARACTER
	JUMPLE	C,.POPJ##	;ALLOW BLANK LINES
	CAIE	C,.CHTAB	;TAB?
	CAIN	C," "		;SPACE?
	JRST	GETUS1		;IGNORE THEM
	CAIN	C,""""		;QUOTED STRING?
	JRST	GETUS2		;MUST BE A USER NAME
	PUSHJ	P,.TICAN##	;SEE IF ALPHANUMERIC
	  JRST	GETUS3		;IT'S NOT
	MOVEI	T1,USRPPN	;ASSUME A PPN ON THE WAY
	CAIL	C,"0"		;RANGE
	CAILE	C,"9"		; CHECK
GETUS2:	MOVEI	T1,USRNAM	;A USER NAME
	PUSHJ	P,(T1)		;PARSE PPN OR USER NAME
	DMOVE	P1,T1		;COPY ARGUMENTS TO VALIDATE PPN OR USER NAME
	JUMPLE	C,GETUS4	;JUMP IF EOL
GETUS3:	PUSHJ	P,SWTSCN	;CHECK FOR SWITCHES
	JUMPLE	C,GETUS4	;JUMP IF EOL
	CAIE	C,"["		;PATH SPEC?
	CAIN	C,"<"		;2741 STYLE?
	SKIPA			;YES
	JRST	GETUS4		;ELSE ALMOST DONE HERE
	PUSHJ	P,USRPAT	;READ PATH AND PARSE SWITCHES
	DMOVE	P1,T1		;COPY ARGUMENTS TO VALIDATE PPN
GETUS4:	PUSHJ	P,USRDEF	;PERFORM PPN DEFAULTING AND /BYPASS CHECKING
	DMOVE	T1,P1		;GET ARGUMENTS TO VALIDATE PPN/PATH/USER NAME
	PUSHJ	P,STACCT	;GET USER'S PROFILE
	  SETOM	FAILFL		;NO SUCH PPN OR USER
	SKIPN	PP		;HAVE A PPN ALREADY?
	MOVE	PP,AENTRY+.AEPPN;GET PPN
	TLNE	F,FL.BYP	;BYPASSING THE ACCOUNTING SYSTEM?
	MOVEM	PP,AENTRY+.AEPPN;USE THE PPN WE JUST PARSED
	SKIPE	T1,LSTPPN	;HAVE A PREVIOUS PPN?
	CAME	T1,PP		;SAME AS LOGGING-IN PPN?
	SKIPA	T1,AENTRY+.AEPPN ;GET LAST ACCESS PPN
	POPJ	P,		;ALREADY HAVE LAST FAILURE INFO
	MOVEM	T1,LSTPPN	;SAVE
	MOVE	T1,AENTRY+.AEFAI ;GET LAST ACCESS UDT
	MOVEM	T1,LSTACC	;SAVE IT NOW
	MOVE	T1,AENTRY+.AEFLG ;GET LAST ACCESS FLAGS
	MOVEM	T1,LSTFLG	;SAVE
	POPJ	P,		;RETURN
USRPPN:	PUSHJ	P,.OCTNC##	;GET PROJECT NUMBER (FIRST DIGIT IN C)
	JUMPGE	C,USRPP1	;JUMP IF NOT EOL
	JUMPE	N,.POPJ##	;IGNORE BLANK LINES
	PJRST	ERRILC		;REPORT ILLEGAL CHARACTER
USRPP1:	CAIE	C,"/"		;SLASH BREAK?
	CAIN	C,","		;ORDINARY COMMA BREAK?
	SKIPA			;EITHER IS OK
	PJRST	ERRILC		;REPORT ILLEGAL CHARACTER
	MOVE	T1,N		;INCASE OF ERROR
	TRNE	N,377777	;MUST HAVE A NON-ZERO PROJECT NUMBER
	TDNE	N,[-1,,400000]	;ALSO ONLY 6 DIGITS
	FATAL	IPJ,<Illegal project number >,EF.FMT,.TOCTW##
	HRLZ	PP,N		;PUT IN AC PP
	PUSHJ	P,.TIAUC##	;LOOK AT NEXT CHAR
	CAIE	C,UNISYM	;WANT UNIQUE PPN?
	JRST	USRPP2		;NO, COLLECT PROGRAMMER NO
	PUSHJ	P,.TIAUC##	;GET SEPARATOR INTO CH
	MOVEI	N,UNIPRG	;PUT UNIQUE CODE INTO N
	TLOA	F,FL.WLD	;NOTE UNIQUE PROGRAMMER NO
USRPP2:	PUSHJ	P,.OCTNC##	;COLLECT PROGRAMMER, 1ST CHAR IN CH
	MOVE	T1,N		;INCASE OF ERROR
	TRNE	N,777777	;MUST HAVE A NON-ZERO PROGRAMMER NUMBER
	TLNE	N,777777	;ALLOW ONLY 6 DIGITS
	FATAL	IPG,<Illegal programmer number >,EF.FMT,.TOCTW##
	HRR	PP,N		;MAKE AN XWD
USRPP3:	PUSHJ	P,PPNCHK	;CHECK LEGALITY OF THE TARGET PPN
USRPP4:	MOVE	T1,[EXP <QA.IMM!1B17!.UGPPN>] ;QUEUE. BLOCK CODE
	MOVE	T2,PP		;PPN THAT WE WANT
	POPJ	P,		;RETURN
USRPAT:	PUSHJ	P,.REEAT##	;BACK UP ONE CHARACTER
	PUSHJ	P,.FILIN##	;GO SCAN OFF THE PATH
	MOVEI	T1,U.PATH	;NOW GO COPY THE SPEC
	MOVEI	T2,.FXLEN	;  INTO LOGIN'S CORE
	PUSHJ	P,.GTSPC##	;  AREA
	JUMPN	PP,USRPP4	;RETURN IF ALREADY CHECKED OUT PPN
	SKIPE	USERID		;HAVE A USER NAME?
	PJRST	USRNA3		;YES--DON'T WORRY ABOUT THE PPN NOW
	MOVE	T1,[2,,U.PATH+.FXDIR] ;INCASE OF ERROR
	SKIPN	PP,U.PATH+.FXDIR ;GET THE PPN FROM THE PATH
	FATAL	NPP,<No PPN in path specification >,EF.FMT,.TDIRB##
	TLNE	PP,777777	;MUST HAVE NON-ZERO PROJECT NUMBER
	TRNN	PP,777777	; AND A NON-ZERO PROGRAMMER NUMBER
	FATAL	IPP,<Illegal PPN in path specification >,EF.FMT,.TDIRB##
	MOVE	T2,U.PATH+.FXDIM ;GET MASK
	AOSE	T2		;CHECK IT
	FATAL	WPP,<Wildcarded PPN in path specification >,EF.FMT,.TDIRB##
	PJRST	USRPP3		;FINISH UP
USRNAM:	CAIE	C,""""		;QUOTED NAME?
	TDZA	T1,T1		;NO
	MOVEI	T1,1		;REMEMBER FOR LATER
	PUSH	P,T1		;SAVE FLAG
	PUSHJ	P,.AS8QC##	;PARSE A POSSIBLY QUOTED ASCII STRING
	POP	P,T1		;GET FLAG BACK
	SKIPN	T1		;NOTHING SPECIAL IF A QUOTED STRING
	CAIE	C,":"		;STOPPED ON A COLON?
	JRST	USRNA2		;NO--JUST A NORMAL NAME
	MOVE	T1,.NMUL##	;PICK UP FIRST WORD
	TDNE	T1,[BYTE(8)0,0,377,0] ;LESS THAN THREE CHARACTERS OR
	TRNE	T1,7760		; MORE THAN THREE CHARACTERS IS JUST TEXT
	JRST	USRNA2		;GO PROCESS USER NAME
	MOVE	T3,[POINT 8,.NMUL##] ;POINT TO STRING
	MOVEI	T4,3		;INIT COUNTER
	SETZ	T1,		;CLEAR STORAGE
USRNA1:	ILDB	T2,T3		;GET A CHARACTER
	ANDI	T2,177		;REDUCE TO 7-BITS
	SUBI	T2," "		;CONVERT TO SIXBIT
	LSH	T2,36		;POSITION
	LSHC	T1,6		;STORE
	SOJG	T4,USRNA1	;LOOP
	HRLZS	T1		;PUT IN LH
	DEVPPN	T1,UU.PHY	;COULD THIS BE AN ERSATZ DEVICE?
	  JRST	USRNA2		;NO
	MOVE	PP,T1		;COPY PPN
	PUSHJ	P,.TIALT##	;EAT ONE CHARACTER BEYOND THE COLON
	PJRST	USRPP4		;PRETEND WE PARSED A PPN
USRNA2:	MOVE	T1,[.NMUL##,,USERID] ;SET UP BLT
	BLT	T1,USERID+.AANLW ;COPY IT
USRNA3:	MOVE	T1,[XWD .AANLW,.UGUSR] ;QUEUE. BLOCK CODE
	MOVEI	T2,USERID	;POINT TO THE USERNAME WE JUST READ
	SETZ	PP,		;CAN'T DETERMINE PPN
	POPJ	P,		;RETURN
; HERE TO DO /BYPASS LEGALITY CHECKING AND PPN DEFAULTING
; THE USER IS ALLOWED TO BYPASS THE ACCOUNTING SYSTEM IF
; ANY OF THE FOLLOWING CONDITIONS ARE TRUE:
;
;   1. LOGIN/BYPASS WAS TYPED ON ANY CTY (REMOTE CTYS EXCLUDED)
;   2. LOGIN/BYPASS WAS TYPED ON OPR:
;   3. LOGIN/BYPASS WAS TYPED ON A SUBJOB OF A [1,2] JOB
;   4. LOGIN/BYPASS WAS TYPED ON A LOCAL TERMINAL
;   5. LOGIN/BYPASS WAS TYPED ON ANY TERMINAL AND SCHED 10 IS IN EFFECT
;
; FOR ANY OTHER CASE, /BYPASS IS NOT VALID AND A FATAL ERROR MESSAGE
; IS ISSUED.

USRDEF:	TLZ	F,FL.BYP	;DEFAULT TO OFF (A LITTLE PARANOIA HERE)
	SKIPG	U.BYPA		;BYPASSING THE ACCOUNTING SYSTEM?
	JRST	USRDE2		;NO

; CHECK FOR ANY CTY
	TLNN	F,FL.CTY	;ONE OF THE CTYS?

; CHECK FOR OPR OR SUBJOB OF OPR
	TLNE	F,L.OPR!L.SOPR	;PERHAPS OPR OR SUBJOB OF OPR?
	JRST	USRDE1		;GO BYPASS ACCOUNTING SYSTEM

; CHECK FOR A LOCAL TERMINAL
	MOVX	T1,GL.REM!GL.DSL ;BITS TO TEST
	TDNN	T1,TTBITS	;SOME FLAVOR OF LOCAL?
	JRST	USRDE1		;YES

; CHECK FOR SCHED 10
	MOVE	T1,STATES	;GET MONITOR'S STATES WORD
	TXNE	T1,ST%NRL	;OR DEBUGGING THE MONITOR (SCHED 10)?
	JRST	USRDE1		;KEEP JMF, DPM, SPIDER, AND KBY HAPPY
	FATAL	NPB,<No privileges to bypass the accounting system>,EF.FMT!EF.SIL
USRDE1:	TLO	F,FL.BYP	;OK TO BYPASS ACCOUNTING SYSTEM
USRDE2:	MOVE	T1,U.PATH+.FXDIR;GET NORMAL DEFAULT PPN FROM PATH BLOCK
	TLNE	F,FL.BYP	;BYPASSING THE ACCOUNTING SYSTEM?
	MOVE	T1,DEFACT+.AEPPN ;GET DEFAULT PPN
	SKIPE	USERID		;BUT IS THERE A USER-ID?
	POPJ	P,		;YES--CAN'T TRUST THE PPN FROM THE PATH
	SKIPN	PP		;HAVE A PPN?
	MOVE	PP,T1		;USE DEFAULT
	POPJ	P,		;RETURN
SUBTTL	Command scanning routines -- PSCAN - Init scanning of switches


; ROUTINE TO DO PARTIAL LINE SCANNING AND LEADING SWITCH HANDLING
; CALL:	PUSHJ	P,PSCAN

PSCAN:	SETOM	REPARS		;INIT REPARSE FLAG
	HRRZ	T1,COMIDX	;GET INVOKING COMMAND INDEX
	MOVE	T1,COMPBK(T1)	;POINT TO SCAN ARGUMENTS
	PUSH	P,.OPTN##	;SAVE /OPTION
	PUSH	P,.FLVRB##	;SAVE /MESSAGE
	PUSHJ	P,.PSCAN##	;SET UP PARTIAL LINE SCANNER
	  TDZA	T1,T1		;WANTS TO PROMPT
	MOVEI	T1,1		;JUST PARSE
	SKIPL	REPARS		;DID SCAN RESTART .PSCAN (/HELP MAYBE)?
	JRST	.MONRT##	;YES, EXIT 
	POP	P,.FLVRB##	;RESTORE /MESSAGE
	POP	P,.OPTN##	;RESTORE /OPTION
	JUMPN	T1,PSCAN1	;JUMP IF NO PROMPT NEEDED
	HRRZ	T1,COMIDX	;GET INVOKING COMMAND INDEX
	MOVE	T1,COMPMT(T1)	;AND IT'S ASSOCIATED PROMPT STRING
	SKIPN	(T1)		;NULL STRING?
	POPJ	P,		;NEVER PROMPT--JUST EXIT
	PUSHJ	P,TTYPMT	;PROMPT
PSCAN1:	PUSHJ	P,.TIAUC##	;PRIME THE PUMP
	PJRST	SWTSCN		;ENTER SWITCH SCANNER
SUBTTL	Command scanning routines -- PXSCAN - Init scanning one argument


; INITIALIZE SCANNING OF A SINGLE ARGUMENT.  THIS IS NOT TO BE
; USED FOR FILESPEC OR SWITCH SCANNING.
; CALL:	MOVE	T1, INPUT TIMEOUT TEXT ADDRESS
;	MOVE	T2, PROMPT STRING TEXT ADDRESS
;	PUSHJ	P,PXSCAN

PXSCAN:	MOVEM	T1,HELP		;SAVE INPUT TIMEOUT TEXT
	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	P1,T2		;COPY PROMPT STRING
	PUSHJ	P,.PSH4T##	;SAVE T1-T4
	PUSH	P,.OPTN##	;SAVE /OPTION
	PUSH	P,.FLVRB##	;SAVE /MESSAGE
	SETZ	T1,		;NO ARGUMENTS
	PUSHJ	P,.PSCAN##	;INITIALIZE
 	  PUSHJ	P,[MOVE	 T1,P1	;COPY PROMPT STRING
		   PJRST TTYPMT];TYPE IT
	POP	P,.FLVRB##	;RESTORE /MESSAGE
	POP	P,.OPTN##	;RESTORE /OPTION
	PUSHJ	P,.POP4T##	;RESTORE T1-T4
	POPJ	P,		;RETURN
SUBTTL	Command scanning routines -- SCMPMT - SCAN prompt


SCNPMT:	PUSHJ	P,TTYECH	;SET TTY ECHO
	MOVEI	T1,"#"		;ALWAYS PROMPT WITH "#" WHETHER
	PUSHJ	P,.TCHAR##	;FIRST OR CONTINUATION LINE
	PJRST	.TOOUT##	;FORCE OUTPUT AND RETURN
SUBTTL	Command scanning routines -- SWTSCN - Parse switches


; ROUTINE TO DO SWITCH SCANNING
; CALL:	PUSHJ	P,SWTSCN

SWTSCN:	CAIN	C," "		;A SPACE?
	PUSHJ	P,.TIAUC##	;YES--GET A REAL CHAR
	TLNE	F,FL.LGN	;JOB LOGGED IN?
	CAIE	C,"@"		;YES--SEE IF INDIRECT CMD FILE
	JRST	SWTSC1		;IT ISN'T
	PUSHJ	P,.GTIND##	;YES--SETUP FOR IT
	JUMPLE	C,SWTSC1	;LOOP IF EOL
	JRST	E.ILSC##	;ELSE ERROR
SWTSC1:	CAIE	C,"/"		;SWITCH COMING?
	POPJ	P,		;NO
	AOS	REPARS		;FIRST TIME THROUGH
	PUSHJ	P,.KEYWD##	;YES--GO PROCESS IT
	  FATAL	NSS,<No switch specified>
	AOS	REPARS		;INDICATE A SWITCH TYPED
	JUMPLE	C,.POPJ##	;RETURN IF EOL
	CAIN	C," "		;A SPACE?
	PUSHJ	P,.TIAUC##	;YES--EAT IT
	JRST	SWTSC1		;LOOP BACK FOR ANOTHER SWITCH
SUBTTL	Prompt for additional data -- ASKACT - Read account string


ASKACT:	SKIPE	FAILFL		;DO WE ALREADY KNOW WE'RE GOING TO FAIL?
	POPJ	P,		;YES--DON'T BOTHER WITH THIS STUFF
	MOVE	T1,U.ACTS	;GET FIRST WORD OF /ACCOUNT STORAGE
	AOJN	T1,ASKAC5	;JUMP IF /ACCOUNT HAS BEEN SEEN
	SETZM	.NMUL##		;CLEAR FIRST WORD
	MOVE	T1,[.NMUL##,,.NMUL##+1] ;SET UP BLT
	BLT	T1,.NMUL##+7	;CLEAR ENTIRE ACCOUNT STRING
	MOVX	T1,AE.ACT	;BIT TO TEST
	TLNN	F,FL.BYP	;BYPASSING THE ACCOUNTING SYSTEM?
	TDNN	T1,AENTRY+.AEREQ ;IS AN ACCOUNT REQUIRED?
	JRST	ASKAC2		;NO--FINISH UP
	MOVX	T1,GL.ITY	;ANOTHER BIT TO TEST
	TDNE	T1,TTBITS	;DON'T CONFUSE BATCON OR OPSER
	JRST	ASKAC3		;TRY TO GET CONTROLLING JOB'S ACCOUNT STRING
	PUSHJ	P,TTYECH	;SET TTY ECHO
	MOVEI	T1,[ASCIZ /an account string/]
	MOVEI	T2,[ASCIZ /Account: /]
	PUSHJ	P,PXSCAN	;INIT PARTIAL LINE SCANNING AND PROMPT
	MOVE	T1,[POINT 7,.NMUL##]
ASKAC1:	PUSHJ	P,.TICHE##	;GET A CHARACTER
	JUMPLE	C,ASKAC2	;JUMP IF EOL OR EOF
	CAME	T1,[POINT 7,.NMUE##,34] ;ABOUT TO OVERFLOW BUFFER?
	IDPB	C,T1		;NO--STORE CHARACTER
	JRST	ASKAC1		;LOOP
ASKAC2:	PUSHJ	P,LGLACT	;CHECK THE ACCOUNT STRING FOR LEGAL CHARACTERS
	MOVE	T1,[.NMUL##,,U.ACTS] ;SET UP BLT
	BLT	T1,U.ACTS+7	;COPY ACCOUNT STRING
	JRST	ASKAC5		;AND PROCEED
ASKAC3:	MOVNI	T3,1		;-1 TO START THINGS OFF
	CTLJOB	T3,		;GET CONTROLLING JOB NUMBER
	  MOVNI	T3,1		;THERE ISN'T ONE
	JUMPLE	T3,ASKAC4	;JUMP IF NONE
	HRL	T1,T3		;GET JOB NUMBER
	HRRI	T1,.GTPPN	;GETTAB TABLE NUMBER
	GETTAB	T1,		;READ PPN
	  SETZ	T1,		;CAN'T
	CAME	T1,PPN		;SAME PPN?
	JRST	ASKAC4		;NO
	MOVE	T1,[.ACTRD,,T2]	;SET UP UUO AC
	MOVEI	T2,2		;TWO WORDS FOLLOWING (JOB NUMBER IN T3)
	MOVEI	T4,U.ACTS	;POINT TO STORAGE
	ACCT.	T1,		;READ CONTROLLING JOB'S ACCOUNT STRING
ASKAC4:	  FATAL	NAS,<No account string specified>,EF.FMT
ASKAC5:	PJRST	USGVAL		;SEND VALIDATION MESSAGE TO [SYSTEM]ACCOUNTING
SUBTTL	Prompt for additional data -- ASKATT - Read detached job# for ATTACH


ASKATT:	SKIPE	ATTJBN		;HAVE A JOB TO ATTACH TO YET?
	JRST	.POPJ1##	;YES--NOTHING TO DO
	MOVEI	T1,ATTMAP	;SUBROUTINE TO VALIDATE JOB NUMBER
	PUSHJ	P,MAPJOB	;SEE IF OTHER JOBS EXIST
	SKIPN	T1,JOBCNT	;FOUND ANY JOBS?
	POPJ	P,		;NO
	SOJN	T1,ASKAT1	;JUMP IF MORE THAN ONE
	PUSHJ	P,MAPNXT	;FIND THE JOB
	  POPJ	P,		;JOB MUST EXIST BUT DOESN'T??
	MOVEM	T1,ATTJBN	;SAVE JOB NUMBER
	JRST	.POPJ1##	;AND RETURN
	MOVE	T1,JOBCNT	;GET COUNT OF JOBS MAPPED
	SOJN	T1,ASKAT1	;JUMP IF MORE THAN ONE
	PUSHJ	P,MAPNXT	;FIND THE JOB
	  POPJ	P,		;JOB MUST EXIST BUT DOESN'T??
	MOVEM	T1,ATTJBN	;SAVE JOB NUMBER
	JRST	.POPJ1##	;AND RETURN
ASKAT1:	PUSHJ	P,DETJOB	;REPORT DETACHED JOBS
ASKAT2:	PUSHJ	P,TTYECH	;SET TTY ECHO
	MOVEI	T1,[ASCIZ /a job number/] ;INPUT TIMEOUT TEXT
	MOVEI	T2,[ASCIZ /Type a job number to attach to: /] ;PROMPT
	PUSHJ	P,PXSCAN	;INIT PARTIAL LINE SCANNING
	PUSHJ	P,.SWDEC##	;READ A DECIMAL NUMBER
	JUMPG	C,ERRILC	;ERROR IF NOT EOL
	JUMPE	N,ASKAT2	;USER IS UNDECIDED
	MOVEM	N,ATTJBN	;STORE JOB NUMBER AWAY
	JRST	.POPJ1##	;AND RETURN


ATTMAP:	MOVE	T2,T1		;COPY JOB NUMBER
	TRMNO.	T2,		;DETACHED?
	  SKIPA			;YES
	POPJ	P,		;CANNOT BE ATTACHED
	HRLZ	T2,T1		;GET JOB NUMBER
	HRRI	T2,.GTDFL	;GET DEFAULT
	GETTAB	T2,		;FIND OUT IF USER WANTED TO BE ASKED
	  MOVEI	T2,0		;ALWAYS DEFAULT TO ASK THE USER
	TXNN	T2,JD.DAD	;DOES THIS JOB WANT TO PROMPT?
	AOS	(P)		;PUT THIS JOB IN THE MAP
	POPJ	P,		;RETURN
SUBTTL	Prompt for additional data -- ASKLOG - Read detached job# for LOGIN


ASKLOG:	MOVE	T1,U.ATT	;GET /ATTACH ARGUMENT
	TLNN	F,FL.WLD	;WILDCARDED PPN?
	CAIN	T1,ATTIGN	;DID THE USER TYPE /ATTACH:INGORE?
	JRST	.POPJ1##	;YES--DON'T PROMPT
	MOVX	T1,GL.ITY	;BIT TO TEST
	MOVE	T2,PPN		;GET PPN
	TDNN	T1,TTBITS	;A PTY?
	CAMN	T2,ALPPPN	;OR [1,2]?
	JRST	.POPJ1##	;DON'T ASK
ASKLOX:	MOVEI	T1,LOGMAP	;SUBROUTINE TO VALIDATE JOB NUMBER
	PUSHJ	P,MAPJOB	;SEE IF OTHER JOBS EXIST
	SKIPN	T2,JOBCNT	;FOUND ANY JOBS?
	JRST	.POPJ1##	;NO
	PUSHJ	P,TTYECH	;SET TTY ECHO
	CAIE	T2,1		;JUST ONE JOB?
	JRST	ASKLO2		;NO
ASKLO1:	PUSHJ	P,DETJOB	;REPORT DETACHED JOB
	MOVEI	T1,[ASCIZ /LOGIN or ATTACH preference/]
	MOVEI	T2,[ASCIZ /Do you want to ATTACH to this job? [Y] /]
	PUSHJ	P,PXSCAN	;INIT PARTIAL LINE SCANNING
	PUSHJ	P,.SIXSW##	;READ A SIXBIT WORD
	JUMPG	C,ERRILC	;ERROR IF NOT EOL
	JUMPE	N,[MOVE N,JOBNUM ;GET TARGET JOB NUMBER
		   JRST	ASKLO3]	;GO ATTACH
	MOVE	T1,[IOWD YNLEN,YNTBL] ;POINT TO ANSWERS
	PUSHJ	P,.NAME##	;CHECK THEM OUT
	  JRST	ERRUKK		;ERROR
	MOVE	N,JOBNUM	;GET LAST JOB NUMBER FOUND BY MAPNXT
	MOVEI	T1,-YNTBL(T1)	;FORM INDEX
	JUMPN	T1,.POPJ1##	;JUMP IF USER SAID NO
	JRST	ASKLO3		;ELSE GO FAKE UP AN ATTACH COMMAND
ASKLO2:	PUSHJ	P,DETJOB	;REPORT DETACHED JOBS
	MOVEI	T1,[ASCIZ /LOGIN or ATTACH preference/]
	MOVEI	T2,[ASCIZ /Type a job number to ATTACH or return to LOGIN a new job: /]
	PUSHJ	P,PXSCAN	;INIT PARTIAL LINE SCANNING
	PUSHJ	P,.SWDEC##	;READ A DECIMAL NUMBER
	JUMPG	C,ERRILC	;ERROR IF NOT EOL
	JUMPE	N,.POPJ1##	;USER WANTS TO LOGIN A NEW JOB
	MOVX	T1,%NSHJB	;
	GETTAB	T1,		;GET THE HIGHEST JOB IN USE
	  TRNA			;ERROR - BE SAFE: DON'T ALLOW IT
	CAMGE	T1,N		;IS THIS A VALID JOB NUMBER?
	JRST	ASKLO4		;NO - TELL THE USER
	MOVEI	T1,.GTPPN	;CHECK TO SEE THAT THIS
	HRL	T1,N		; JOB HAS THE PPN HE
	GETTAB	T1,		; CLAIMS IT DOES
	  TRNA			;ERROR - DON'T ALLOW THE ATTACH
	CAME	T1,PPN		;DOES THE PPN MATCH?
	JRST	ASKLO4		;NO - TELL THE USER
ASKLO3:	MOVEM	N,ATTJBN	;STORE JOB NUMBER AWAY
	MOVEI	T1,1		;GET A "YES"
	MOVEM	T1,U.MODE	;MAKE IT LOOK LIKE /USER WAS TYPED
	MOVE	T1,[CM.ATT+COMATT] ;MUST DUMMY UP INVOKING COMMAND
	MOVEM	T1,COMIDX	; WORD TO LOOK LIKE AN ATTACH COMMAND
	SETOM	NOWBIT		;ALL ACCESS TIMES ARE LEGAL
	MOVEI	T1,[ASCIZ /.ATTACH /]
	PUSHJ	P,.TSTRG##	;PRINT A REASSURING MESSAGE
	MOVE	T1,ATTJBN	;GET TARGET JOB NUMBER
	PUSHJ	P,.TDECW##	;PRINT IT
	MOVE	T1,PPN		;GET TARGET PPN
	PUSHJ	P,.TPPNW##	;PRINT IT TOO
	PJRST	.TCRLF##	;END LINE WITH A CRLF AND TAKE ATTACH RETURN

ASKLO4:	WARN	IJN,<Invalid job number; try again>
	JRST	ASKLOX


LOGMAP:	MOVE	T2,T1		;COPY JOB NUMBER
	TRMNO.	T2,		;DETACHED?
	  SKIPA			;YES
	POPJ	P,		;CANNOT BE ATTACHED
	HRLZ	T2,T1		;GET JOB NUMBER
	HRRI	T2,.GTDFL	;GET DEFAULT
	GETTAB	T2,		;FIND OUT IF USER WANTED TO BE ASKED
	  MOVEI	T2,0		;ALWAYS DEFAULT TO ASK THE USER
	TXNN	T2,JD.DAD	;DOES THIS JOB WANT TO PROMPT?
	AOS	(P)		;PUT THIS JOB IN THE MAP
	POPJ	P,		;RETURN


YNTBL:	SIXBIT	/YES/
	SIXBIT	/NO/
YNLEN==.-YNTBL
SUBTTL	Prompt for additional data -- ASKNAM - Read user name


ASKNAM:	MOVE	T1,U.NAME	;GET THE USER NAME
	MOVE	T2,U.NAME+1	;GET THE SECOND HALF
	MOVE	T3,T1		;COPY FIRST WORD
	IOR	T3,T2		;MERGE THE TWO
	CAMN	T1,[EXP -1]	;NAME GIVEN?
	CAME	T2,[EXP -1]	;MUST CHECK BOTH WORDS
	JUMPN	T3,ASKNA6	;JUMP IF WE HAVE A NAME
	MOVE	T1,CNTLJP	;GET CONTROLLING JOB'S PPN
	CAME	T1,ALPPPN	;OK IF [1,2]
	TLNE	F,FL.BYP!L.SOPR	;BYPASS OR SON OF OPR?
	JRST	ASKNA4		;NEVER ASK FOR A NAME
	MOVX	T1,AE.NCH	;BIT TO TEST
	MOVX	T2,AE.NRT	;GET NAME REQUIRED BIT
	TDNN	T1,AENTRY+.AEFLG ;NAME REQUIRED BY SYSTEM ADMINISTRATOR?
	JRST	ASKNA1		;NO
	PUSHJ	P,LOKCHK	;CHECK FOR LOCKED ACCOUNTING FILES
	  JRST	ASKNA4		;CAN'T CHANGE NAME
	IORM	T2,AENTRY+.AEREQ ;SET THE BIT
	WARN	NCR,<A name is required for accounting purposes>
ASKNA1:	TDNN	T2,AENTRY+.AEREQ ;NAME REQUIRED?
	JRST	ASKNA4		;NO--USE WHAT'S IN THE PROFILE
	PUSHJ	P,TTYECH	;SET TTY ECHO
	MOVEI	T1,[ASCIZ /your name/]
	MOVEI	T2,[ASCIZ/Name: /]
	PUSHJ	P,PXSCAN	;INIT PARTIAL LINE SCANNING AND PROMPT
	MOVE	T1,[AENTRY+.AENAM,,AENTRY+.AENAM+1] ;SET UP BLT
	SETZM	AENTRY+.AENAM	;CLEAR FIRST WORD
	BLT	T1,AENTRY+.AENAM+.AANLW-1 ;CLEAR NAME STORAGE
	MOVE	T1,[POINT 8,AENTRY+.AENAM] ;BYTE POINTER TO STORAGE
	MOVEI	T2,.AANLC	;MAXIMUM NUMBER OF CHARACTERS
ASKNA2:	PUSHJ	P,.TICHE##	;GET A CHARACTER
	JUMPLE	C,ASKNA3	;EOL?
	IDPB	C,T1		;PUT A CHARACTER
	SOJG	T2,ASKNA2	;LOOP
ASKNA3:	SKIPE	AENTRY+.AENAM	;MUST BE NON-ZERO
	JRST	ASKNA5		;IT IS
	SETOM	FAILFL		;ELSE FORCE A FAILURE
ASKNA4:	MOVX	T1,AE.NCH	;BIT TO CLEAR
	ANDCAM	T1,AENTRY+.AEFLG ;DON'T ALLOW NAME CHANGES
ASKNA5:	SETZM	NAME		;CLEAR WORD 1
	SETZM	NAME2		;CLEAR NAME 2
	MOVEI	T1,AENTRY+.AENAM ;ADDRESS OF ACCOUNTING NAME
	MOVE	T2,[POINT 6,NAME];BYTE POINTER TO DESTINATION
	MOVEI	T3,^D12		;NAME IS 12 CHARACTERS LONG
	PJRST	CHRTRN		;TRANSLATE STRING AND RETURN
ASKNA6:	DMOVEM	T1,NAME		;STORE IT
	POPJ	P,		;RETURN
SUBTTL	Prompt for additional data -- ASKPSW - Read password(s)


ASKPSW:	MOVE	T1,COMIDX	;GET COMMAND FLAGS
	TXNE	T1,CM.PSW!CM.SET ;PASSWORD OR SET PASSWORD COMMANDS?
	JRST	ASKPS1		;YES--ALWAYS ASK
	SKIPE	FAILFL		;GOING TO FAIL?
	JRST	ASKPS1		;ASK FOR PASSWORD ANYWAY
	JUMPG	C,ASKPS1	;ALSO ASK IF PASSWORD ON ATTACH OR LOGIN LINE
	MOVE	T2,CNTLJP	;GET CONTROLLING JOB'S PPN
	CAME	T2,ALPPPN	;OK IF [1,2]
	TLNE	F,FL.CTY!FL.BYP!FL.BAT!L.SOPR ;PASSWORD REQUIRED?
	POPJ	P,		;NO
	JUMPE	PP,ASKPS1	;IF NO PPN, THEN LOGIN WON'T SUCCEED, SO ASK
	CAMN	T2,PP		;OK IF US
	POPJ	P,		;RETURN IF NOT ORDINARY UNPRIV'ED ATTACH/LOGIN
	TXNE	T1,CM.ATT	;ATTACH COMMAND?
	JRST	ASKPS1		;ALWAYS ASK FOR A PASSWORD
	MOVX	T1,AE.PRT	;BIT TO TEST
	TDNN	T1,AENTRY+.AEREQ ;IS A PASSWORD REQUIRED?
	POPJ	P,		;NO--RETURN
ASKPS1:	MOVEI	T1,[ASCIZ /your password/]
	MOVEI	T2,[ASCIZ /Password: /]
	MOVEI	T3,PASSWD	;BUFFER ADDRESS
	PUSHJ	P,GETPSW	;READ PASSWORD
	PUSHJ	P,.GTNOW##	;GET CURRENT UDT
	SKIPN	T2,AENTRY+.AEPCT ;GET PASSWORD CHANGE TIME
	MOVE	T2,T1		;ZERO MEANS NOT YET
	CAMLE	T1,T2		;TIME TO CHANGE PASSWORD?
	SETOB	T1,AENTRY+.AEPCT ;YES
	SKIPG	U.PASS		;USER ASK FOR A PASSWORD CHANGE?
	CAME	T1,[EXP -1]	;PASSWORD CHANGE REQUIRED?
	JRST	ASKPS2		;DON'T BOTHER USER WITH USELESS CHATTER
	PUSHJ	P,LOKCHK	;CHECK FOR A LOCKED FILE
	  JRST	ASKPS3		;GIVE UP
	WARN	PCR,<A password change is required by the system administrator>
	MOVEI	T1,1		;NOW FAKE STORAGE
	MOVEM	T1,U.PASS	;SO IT LOOKS LIKE /PASSWORD:YES WAS TYPED
ASKPS2:	SKIPG	U.PASS		;/PASSWORD SEEN?
	POPJ	P,		;NO--DONE
	MOVEI	T1,[ASCIZ /password may not be changed/]
	PUSHJ	P,LOKWRN	;CHECK FOR A LOCKED FILE
	  SKIPA			;GIVE UP
	JRST	ASKPS4		;ONWARD
ASKPS3:	SETZM	U.PASS		;NO PASSWORD CHANGE
	POPJ	P,		;RETURN
ASKPS4:	MOVX	T1,AE.PCP	;GET "PASSWORD CHANGE PROHIBITED" BIT
	SKIPN	FAILFL		;BYPASS CHECKS IF LOGIN WON'T SUCCEED
	TDNN	T1,AENTRY+.AEREQ ;PASSWORD CHANGE PROHIBITED?
	JRST	ASKPS5		;NO, PROCEED
	MOVE	T1,AENTRY+.AEPCT ;GET THE PASSWORD CHANGE REQUIRED FLAG
	AOJE	T1,ASKPS5	;REQUIRED BY SYSTEM ADMINISTRATOR: PROCEED
	WARN	PCP,<Password change prohibited>
	JRST	ASKPS3		;NO PASSWORD CHANGE
ASKPS5:	MOVEI	T1,[ASCIZ /your new password/]
	MOVEI	T2,[ASCIZ /New password: /]
	MOVEI	T3,NEWPSW	;BUFFER ADDRESS
	PUSHJ	P,GETPSW	;READ NEW PASSWORD
	MOVEI	T1,[ASCIZ /your new password/]
	MOVEI	T2,[ASCIZ /Verification: /]
	MOVEI	T3,CHKPSW	;BUFFER ADDRESS
	PUSHJ	P,GETPSW	;READ NEW PASSWORD AGAIN
	MOVSI	T1,-.APWLW	;-WORD COUNT
	MOVE	T2,NEWPSW(T1)	;GET A WORD
	CAMN	T2,CHKPSW(T1)	;A MATCH?
	AOBJN	T1,.-2		;LOOP
	JUMPGE	T1,.POPJ##	;RETURN IF ALL WORDS CHECK OUT
	WARN	PNV,<The new password did not verify; try again>,,
	JRST	ASKPS5		;LOOP BACK
; READ A ONE PASSWORD
; CALL:	MOVE	T1, TIME-OUT HELP TEXT
;	MOVE	T2, ADDRESS OF PROMPT STRING
;	MOVE	T3, ADDRESS OF BUFFER
;	PUSHJ	P,GETPSW

GETPSW:	SETZM	0(T3)		;CLEAR FIRST WORD OF BUFFER
	MOVSI	T4,0(T3)	;POINT TO START OF BUFFER
	HRRI	T4,1(T3)	;MAKE A BLT POINTER
	BLT	T4,.APWLW-1(T3)	;CLEAR ENTIRE BUFFER
	JUMPG	C,GETPS1	;JUMP IF ALREADY HAVE A CHARACTER
	PUSHJ	P,.PSH4T##	;SAVE T1-T4
	PUSH	P,.OPTN##	;SAVE /OPTION
	PUSH	P,.FLVRB##	;SAVE /MESSAGE
	MOVEI	T1,0		;NO ARGUMENTS
	PUSHJ	P,.PSCAN##	;CALL PARTIAL LINE SCANNER
	  JFCL			;MUST ALWAYS PROMPT
	POP	P,.FLVRB##	;RESTORE /MESSAGE
	POP	P,.OPTN##	;RESTORE /OPTION
	PUSHJ	P,.POP4T##	;RESTORE T1-T4
	MOVEM	T1,HELP		;SAVE INCASE INPUT TIMEOUT
	PUSHJ	P,TTYNEC	;SET TTY NO ECHO
	PUSHJ	P,PMTPSW	;PROMPT THE USER
GETPS1:	MOVE	T2,T3		;GET PASSWORD BUFFER ADDRESS
	HRLI	T2,(POINT 8,)	;MAKE A BYTE POINTER
	MOVEI	T3,.APWLC	;MAXIMUM NUMBER OF CHARACTERS
GETPS2:	PUSHJ	P,.TICHE##	;GET A CHARACTER
	JUMPLE	C,GETPS3	;DONE?
	SOSG	T3		;WATCH FOR OVERFLOW
	FATAL	PTL,<Password too long>
	IDPB	C,T2		;STORE
	JRST	GETPS2		;LOOP
GETPS3:	MOVEI	T1,.CHNUL	;GET TERMINATOR
	IDPB	T1,T2		;MAKE ASCIZ
	PJRST	.TNEWL##	;PRINT A CRLF IF NEEDED AND RETURN
; ROUTINE TO ISSUE PASSWORD PROMPT
PMTPSW:	PUSH	P,T2		;SAVE PROMPT STRING
	PUSH	P,T3		;SAVE BUFFER ADDRESS
	PUSHJ	P,.TNEWL##	;START ON A NEW LINE
	MOVE	T3,CNTLJT	;GET CONTROLLING JOB'S BITS (PROBABLY OURS)
	TXNN	T3,GL.LCP!GL.CNE!GL.HDP ;LOCAL COPY, COMMAND NO ECHO OR HDX?
	JRST	PMTPS2		;YES
	MOVEI	T2,3		;NUMBER OF TIMES TO OVERSTRIKE LINE
PMTPS1:	MOVE	T1,-1(P)	;GET PROMPT STRING
	PUSHJ	P,.TSTRG##	;TYPE IT
	MOVEI	T3,.APWLC	;LENGTH OF PASSWORD IN CHARACTERS
	MOVE	T1,[EXP "*","#","@"]-1(T2) ;GET MASK CHARACTER
	PUSHJ	P,.TCHAR##	;TYPE MASK CHARACTER
	SOJG	T3,.-1		;LOOP
	MOVEI	T1,.CHCRT	;RETURN THE
	PUSHJ	P,.TCHAR##	; CARRIAGE
	SOJG	T2,PMTPS1	;LOOP
PMTPS2:	MOVE	T1,-1(P)	;GET PROMPT STRING ONCE MORE
	PUSHJ	P,.TSTRG##	;TYPE IT
	PUSHJ	P,.TOOUT##	;FORCE OUTPUT
	POP	P,T3		;RESTORE BUFFER ADDRESS
	POP	P,T2		;RESTORE PROMPT STRING
	POPJ	P,		;RETURN
SUBTTL	Prompt for additional data -- ASKRMK - Read remark string


ASKRMK:	SKIPE	FAILFL		;DO WE ALREADY KNOW WE'RE GOING TO FAIL?
	POPJ	P,		;YES--DON'T BOTHER WITH THIS STUFF
	MOVE	T1,U.RMRK	;GET FIRST WORD OF /REMARK STORAGE
	AOJN	T1,.POPJ##	;RETURN IF A /REMARK SWITCH HAS BEEN SEEN
	MOVEI	T1,1		;SET FLAG TO ASSUME REMARK NEEDED
	MOVX	T2,AE.RMK	;BIT TO TEST
	MOVX	T3,GL.ITY	;ANOTHER BIT TO TEST
	TDNN	T3,TTBITS	;DON'T CONFUSE BATCON OR OPSER
	TDNN	T2,AENTRY+.AEREQ ;IS A REMARK REQUIRED?
	MOVEI	T1,0		;NO--SET FLAG ACCORDINGLY
	SETZM	.NMUL##		;CLEAR FIRST WORD
	MOVE	T2,[.NMUL##,,.NMUL##+1] ;SET UP BLT
	BLT	T2,.NMUL##+7	;CLEAR ENTIRE REMARK STRING
	JUMPE	T1,.POPJ##	;RETURN IF NO REMARK NEEDED
	TLNE	F,FL.BYP	;BYPASSING THE ACCOUNTING SYSTEM?
	POPJ	P,		;YES
	PUSHJ	P,TTYECH	;SET TTY ECHO
	MOVEI	T1,[ASCIZ/a remark string/]
	MOVEI	T2,[ASCIZ/Remark: /]
	PUSHJ	P,PXSCAN	;INIT PARTIAL LINE SCANNING AND PROMPT
	MOVE	T1,[POINT 7,.NMUL##]
ASKRM1:	PUSHJ	P,.TICHE##	;GET A CHARACTER
	JUMPLE	C,ASKRM2	;JUMP IF EOL OR EOF
	CAME	T1,[POINT 7,.NMUE##,34] ;ABOUT TO OVERFLOW BUFFER?
	IDPB	C,T1		;NO--STORE CHARACTER
	JRST	ASKRM1		;LOOP
ASKRM2:	PUSHJ	P,LGLRMK	;CHECK THE REMARK STRING FOR LEGAL CHARACTERS
	MOVE	T1,[.NMUL##,,U.RMRK] ;SET UP BLT
	BLT	T1,U.RMRK+7	;COPY REMARK STRING
	POPJ	P,
SUBTTL	SCAN argument blocks -- .ISCAN


SCIBLK:	IOWD	COMLEN,COMLST	;POINTER TO INVOKING COMMAND NAMES
	XWD	SAOFST,'LGN'	;CCL OFFSET,,CCL FILE NAME
	XWD	TTYGET,TTYPUT	;TTY INPUT ROUTINE,,TTY OUTPUT ROUTINE
	XWD	0,0		;POINTER TO INDIRECT COMMAND FILE SCAN BLOCK
	XWD	SCNPMT,FLUSH	;PROMPT ROUTINE,,EXIT ROUTINE
	EXP	FS.ICL		;FLAGS,,RESERVED
SCILEN==.-SCIBLK		;LENGTH OF BLOCK
SUBTTL	SCAN argument blocks -- .OSCAN


DEFINE	X	(PFX,NAM,HLP,PRC,PMT,OSC),<
PFX'OB:
IFE PFX'SWL,<EXP 0,0,0>
IFN PFX'SWL,<
	IOWD	PFX'SWL,PFX'SWN
	XWD	PFX'SWD,PFX'SWM
	XWD	0,PFX'SWP
>
	<SIXBIT	/'HLP/>
IFB <OSC>,<
	XWD	1,COMNAM
>
IFNB <OSC>,<
	ZZ==0
	IRP OSC,<ZZ==ZZ+1>
	XWD	ZZ,[
	IRP OSC,<SIXBIT /OSC/>
		]
>
PFX'OL==.-PFX'OB
>

	CMDS
SUBTTL	SCAN argument blocks -- .PSCAN


DEFINE	X	(PFX,NAM,HLP,PRC,PMT,OSC),<
PFX'PB:
IFE PFX'SWL,<EXP 0,0,0>
IFN PFX'SWL,<
	IOWD	PFX'SWL,PFX'SWN
	XWD	PFX'SWD,PFX'SWM
	XWD	0,PFX'SWP
>
	<SIXBIT	/'HLP/>
PFX'PL==.-PFX'PB
>

	CMDS
SUBTTL	SCAN switch tables -- ATTACH command


DEFINE SWTCHS,<

	SN	BYPASS,U.BYPA,
	SS	MONITOR,U.MODE,0
	SP	TERMINAL,,TERMSW,,FS.VRQ!FS.HEL
	SS	USER,U.MODE,1

>
; TABLE EXPANSION
	DOSCAN(ATTSW)
SUBTTL	SCAN switch tables -- KJOB command


DEFINE SWTCHS,<

	SS	*BATCH,U.KJOB,0
	SN	*CLEAR,U.CLEA,
	SN	*DISCONNECT,U.DISC,
	SS	FAST,U.KJOB,1
	SS	*NOMESSAGE,U.NMSG,0
	SN	*TEMP,U.TEMP,

>
; TABLE EXPANSION
	DOSCAN(KJBSW)
SUBTTL	SCAN switch tables -- LOGIN command


DM	COR,^D0,^D262143,^D262143
DM	DPR,3,0,1
DM	FIL,.FXLEN,0,0
DM	LOC,77,0,0
DM	QTA,1,0,0
DM	TIM,0,0,^D60
DM	YN,1,0,1

KEYS	ATT,<ASK,IGNORE>
KEYS	DSKF,<ERROR,PAUSE>
KEYS	SPOL,<LPT,PLT,PTP,CDP,CDR>
KEYS	NOTC,<ALWAYS,SOMETIMES,NEVER>
KEYS	WTCH,<FILES,MTA,VERSION,WRITE,READ,WAIT,RUN,DAY,CONTEXTS>
	WCHLSH==^D17-WTCHDA	;AMOUNT TO SHIFT BITS FOR SETUUO

DEFINE	SWTCHS,<

SP	ACCOUNT,<POINT ^D65-^D8,U.ACTS>,ACCTSW,,FS.VRQ!FS.HEL
SP	ASSIGN,DEVTAB,ASGNSW,,FS.VRQ!FS.HEL
SL	ATTACH,U.ATT,ATT,ATTASK
SP	BATCH,,BATCSW,,FS.VRQ!FS.HEL
SN	BYPASS,U.BYPA,
SP	CORE,U.CORE,.SWCOR##,COR,FS.VRQ
SN	DEFER,U.DFER,
SP	DEFAULT,,DEFASW,,FS.VRQ!FS.HEL
SL	DSKFUL,U.DFUL,DSKF,DSKFPA
SP	DSKPRI,U.DPRI,DSKPSW,DPR,FS.VRQ!FS.HEL
SN	GUIDELINE,U.GUID
SP	LIB,LIBSPC,.SWFIL##,FIL,FS.VRQ
SN	LIMIT,U.LIMIT
SP	LOCATE,U.STA,.SWOCT##,LOC,
SN	MAILCHECK,U.MAIL,
SP	NAME,<POINT ^D65-2,U.NAME>,.SIXQW##,,FS.VRQ
SN	NEW,U.NEW,
SS	NOLIB,LIBSPC+.FXDIR,0
SP	NOTE,NOTSPC,.SWFIL##,FIL,FS.VRQ
SL	NOTICE,U.NOTC,NOTC,0,FS.VRQ
SS	NOWATCH,U.NWAT,0
SN	PASSWORD,U.PASS,0
SP	PATH,U.PATH,.SWFIL##,FIL,FS.VRQ
SP	*PHYSICAL,U.CPPL,.SWCOR##,COR,FS.VRQ
SP	QUOTA,U.QTA,QUOTSW,QTA,FS.HEL
SP	REMARK,<POINT ^D65-^D8,U.RMRK>,RMRKSW,,FS.VRQ!FS.HEL
SP	REQID,U.BREQ,.SWDEC##,,FS.VRQ
SN	SETTTY,U.SETT,			
SN	SCAN,U.SCAN,
SN	SFDCREATE,U.SFDC,			
SP	SFDPROT,U.SFDP,.SWOCT##,,FS.VRQ
SL	SPOOL,U.SPL,SPOL,0,FS.OBV
SN	STR,U.STR,
SN	SYS,U.SYS,
SP	TERMINAL,,TERMSW,,FS.VRQ!FS.HEL
SP	TIME,U.TIME,.SWDEC##,TIM,FS.VRQ
SP	UFDPROT,U.UFDP,.SWOCT##,,FS.VRQ	
SP	VIRTUAL,U.CVPL,.SWCOR##,COR,FS.VRQ
SL	WATCH,U.WAT,WTCH,0,FS.OBV


; **NOTE** DO NOT ADD NEW SWITCHES HERE.  ADD THEM IN THE OTHER KEYWORD
; TABLES (/DEFAULT OR /TERMINAL).  THESE DEFINITIONS WILL GO AWAY IN LOGIN
; VERSION 65.

IFN	OLDDEF,<
SP	DEFBUFFER,U.DFBU,.SWDEC##,BUF,	
SP	DEFPROT,U.DFPR,.SWOCT##,PRO,FS.VRQ	
> ;END IFN OLDDEF

IFN	OLDTTY,<
SN	ALTMODE,U.ALTM,
SN	BLANK,U.BLNK,
SN	CRLF,U.CRLF,
SN	DEBREAK,U.DBRK,
SN	ECHO,U.ECHO,
SP	FILL,U.FILL,.SWOCT##,FLL
SN	FORM,U.FORM,
SN	GAG,U.GAG,
SN	LC,U.LC,
SN	PAGE,U.PAGE,
SP	PAGESIZE,U.PGSZ,.SWDEC##,PSZ,FS.VRQ
SL	RCVSPEED,U.RSPD,SPED,0,FS.VRQ
SN	RTCOMP,U.RTC,
SL	SPEED,U.SPED,SPED,0,FS.VRQ
SN	TABS,U.TABS,
SN	TAPE,U.TAPE,
SN	TTDEFER,U.TTDE,
SP	TYPE,U.TYPE,.SWSIX##,,FS.VRQ	
SP	WIDTH,U.WDTH,.SWDEC##,WTH,
SL	XMTSPEED,U.XSPD,SPED,0,FS.VRQ
> ;END IFN OLDTTY

>
; TABLE EXPANSION
	DOSCAN(LOGSW)			;LOGIN SWITCHES
SUBTTL	SCAN switch tables -- [SET] PASSWORD COMMAND


	DEFINE	SWTCHS,<


>
; TABLE EXPANSION
	DOSCAN	(SETSW)
	DOSCAN	(PSWSW)
SUBTTL	SCAN switch tables -- REATTA command


DEFINE	SWTCHS,<


>
; TABLE EXPANSION
	DOSCAN	(RTASW)
SUBTTL	SCAN switch tables -- SESSION command


DEFINE	SWTCHS,<

SP	ACCOUNT,<POINT ^D65-^D8,U.ACTS>,ACCTSW,,FS.VRQ!FS.HEL
SP	REMARK,<POINT ^D65-^D8,U.RMRK>,RMRKSW,,FS.VRQ!FS.HEL

>
; TABLE EXPANSION
	DOSCAN	(SESSW)
SUBTTL	SCAN switch tables -- /BATCH switch


DEFINE	SWTCHS,<
	SN	INTERVENTION,U.BINT,
	SP	NAME,U.BNAM,BATNAM,,FS.VRQ
	SP	SEQUENCE,U.BSEQ,.SWDEC##,,FS.VRQ
	SP	STREAM,U.BSTR,.SWOCT##,,FS.VRQ
	SP	REQUESTID,U.BREQ,.SWDEC##,,FS.VRQ
>
; TABLE EXPANSION
	DOSCAN	(BATC.)
SUBTTL	SCAN switch tables -- /DEFAULT switch


DM	PRO,777,0,0
DM	BUF,777,0,2
DM	BIG,^D31,0,^D4


DEFINE	SWTCHS,<
	SP	BIGBUFFER,U.DFBB,.SWDEC##,BIG,
	SP	BUFFER,U.DFBU,.SWDEC##,BUF,
	SP	PROTECTION,U.DFPR,.SWOCT##,PRO,FS.VRQ
>
; TABLE EXPANSION
	DOSCAN	(DEFA.)
SUBTTL	SCAN switch tables -- /TERMINAL switch


DM	ESC,377,377,.CHESC
DM	FLL,3,0,2
DM	PSZ,^D255,^D255,^D24
DM	UPS,377,377,.CHCNQ
DM	WTH,^D255,^D80,^D132


KEYS	SPED,<50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,EXTA,EXTB>


DEFINE	SWTCHS,<
	SN	ALTMODE,U.ALTM,
	SN	BLANKS,U.BLNK,
	SN	CRLF,U.CRLF,
	SN	DEBREAK,U.DBRK,
	SN	DEFER,U.TTDE,
	SN	DISPLAY,U.DISP,
	SN	ECHO,U.ECHO,
	SN	EIGHTBIT,U.8BIT,
	SP	ESCAPE,U.ESCA,.SWCHR##,ESC,
	SN	FFHOME,U.FFHO,
	SN	FFSIMULATE,U.FFSI
	SN	FFSTOP,U.FFST
	SP	FILL,U.FILL,.SWOCT##,FLL
	SN	FORM,U.FORM,
	SN	GAG,U.GAG,
	SN	LC,U.LC,
	SP	LENGTH,U.LENG,.SWDEC##,PSZ,FS.VRQ
	SN	LOCALCOPY,U.LCP,
	SS	NOFILL,U.FILL,0
	SS	NOSTOP,U.STOP,0
	SS	NOSSTOP,U.SSTO,0
	SN	PAGE,U.PAGE,
	SP	PAGESIZE,U.PGSZ,.SWDEC##,PSZ,FS.VRQ
	SN	QUOTE,U.QUOT,
	SL	RCVSPEED,U.RSPD,SPED,0,FS.VRQ
	SN	RTCOMP,U.RTC,
	SN	SBELL,U.SBEL,
	SL	SPEED,U.SPED,SPED,0,FS.VRQ
	SP	STOP,U.STOP,.SWDEC##,PSZ,FS.VRQ
	SP	SSTOP,U.SSTO,.SWDEC##,PSZ,FS.VRQ
	SN	TABS,U.TABS,
	SN	TAPE,U.TAPE,
	SN	TIDY,U.TIDY,
	SP	TYPE,U.TYPE,.SIXSW##,,FS.VRQ
	SN	UC,U.UC,
	SP	UNPAUSE,U.UNPA,.SWCHR##,UPS,
	SP	WIDTH,U.WDTH,.SWDEC##,WTH,
	SN	XONXOFF,U.XONXO,
	SL	XMTSPEED,U.XSPD,SPED,0,FS.VRQ

>
; TABLE EXPANSION
	DOSCAN	(TERM.)
SUBTTL	SCAN switch processing -- ACCTSW - /ACCOUNT


	XWD	0,[ASCIZ /"ASCII string"/]
ACCTSW:	PUSHJ	P,.SWASQ##	;READ THE QUOTED STRING
	MOVE	N,.NMUL##	;MAKE SCAN HAPPY
	PUSHJ	P,LGLACT	;CHECK STRING FOR LEGAL CHARACTERS AND LENGTH
	PJRST	.SWDPB##	;GO STORE RESULT AND RETURN
SUBTTL	SCAN switch processing -- ASGNSW - /ASSIGN


	XWD	0,[ASCIZ /Device:logical-name/]
ASGNSW:	MOVE	T1,DEVPTR	;GET POINTER TO TABLE
	AOBJP	T1,ASGNS1	;TOO MANY /ASSIGN SWITCHES
	PUSH	P,T1		;SAVE T1 OVER .SIXQW
	PUSHJ	P,.SIXSW##	;GET SIXBIT STRING
	MOVE	T1,(P)		;GET POINTER BACK
	MOVEM	N,0(T1)		;STORE DEVICE NAME
	CAIE	C,":"		;LOGICAL NAME ON THE WAY?
	TDZA	N,N		;NO
	PUSHJ	P,.SIXSW##	;GET IT
	POP	P,T1		;GET POINTER BACK
	MOVEM	N,1(T1)		;SAVE
	AOBJP	T1,.+1		;ACCOUNT FOR TWO WORD ENTRIES
	MOVEM	T1,DEVPTR	;UPDATE POINTER
	JRST	.SWDON##	;RETURN

ASGNS1:	WARN	A2M,<Attempt to assign too many devices with /ASSIGN>
	POPJ	P,		;AND RETURN
SUBTTL	SCAN switch processing -- BATCSW - /BATCH


	PUSHJ	P,BATHLP	;/HELP:ARG ROUTINE
BATCSW:	MOVEI	T1,BATSWT	;POINT TO SUB-TABLE
	PJRST	KEYWRD		;HANDLE THE KEYWORDS

BATHLP:	MOVE	T1,BATSWT+SWA	;POINT TO KEYWORD TABLE
	PJRST	HELPTB		;PRINT TABLE AND RETURN

	IOWD	BATC.L,BATC.N	;POINTER TO SWITCH KEYWORDS
BATSWT:	BATC.N(P1)		;SWITCH POINTERS FOR /BATCH
	BATC.P(P1)
	BATC.M(P1)
	BATC.D(P1)
SUBTTL	SCAN switch processing -- BATNAM - /BATCH:NAME


BATNAM:	PUSHJ	P,.SIXQW##	;READ QUOTED SIXBIT STRING
	MOVE	N,.NMUL##	;RETURN FIRST WORD
	JRST	.SWDPB##	;AND LET SCAN STORE
SUBTTL	SCAN switch processing -- DEFASW - /DEFAULT


	PUSHJ	P,DEFHLP	;/HELP:ARG ROUTINE
DEFASW:	MOVEI	T1,DEFSWT	;POINT TO SUB-TABLE
	PJRST	KEYWRD		;HANDLE THE KEYWORDS

DEFHLP:	MOVE	T1,DEFSWT+SWA	;POINT TO KEYWORD TABLE
	PJRST	HELPTB		;PRINT TABLE AND RETURN

	IOWD	DEFA.L,DEFA.N	;POINTER TO SWITCH KEYWORDS
DEFSWT:	DEFA.N(P1)		;SWITCH POINTERS FOR /DEFAULT
	DEFA.P(P1)
	DEFA.M(P1)
	DEFA.D(P1)
SUBTTL	SCAN switch processing -- DSKPSW - /DSKPRIORITY


	XWD	0,[ASCIZ /Octal number (Min=-3, Max=3)/]
DSKPSW:	PUSHJ	P,.OCTNW##	;READ THE NUMBER
	CAML	N,[-3]		;TOO SMALL
	CAILE	N,3		;TOO BIG
	PUSHJ	P,DSKPS1	;COMPLAIN A LITTLE
	MOVEM	N,U.DPRI	;STORE THE ANSWER
	PJRST	.SWDON##	;RETURN

DSKPS1:	MOVE	T1,N		;GET BAD NUMBER
	WARN	DPO,</DSKPRIORITY switch value >,,E.DPO
	MOVEI	N,0		;DEFAULT IT TO ZERO
	POPJ	P,		;RETURN

E.DPO:	PUSHJ	P,.TOCTW##	;PRINT VALUE
	MOVEI	T1,[ASCIZ /; defaulting to zero/]
	PJRST	.TSTRG##	;PRINT TEXT AND RETURN
SUBTTL	SCAN switch processing -- QUOTSW - /QUOTA


; /QUOTA SWITCH PROCESSING.  THIS ROUTINE WILL EXPAND ABBREVIATED
; STRUCTURE NAMES AND "ALL".  IT ALSO SPECIAL CASES "DSK" TO MEAN
; ALL STRUSTURES IN THE JOB'S SEARCH LIST.  WHEN SWITCH SCANNING
; IS DONE, THE JOB'S SEARCH LIST IS UNKNOWN SO WE LIGHT A FLAG
; AND GO AWAY.  "DSK" CANNOT BE EXPANDED.

	XWD	0,[ASCIZ /List of structure names/]
QUOTSW:	PUSHJ	P,.SIXSW##		;GET STR NAME
	SETZM	LSTSTR			;INIT "LAST" STR
	MOVE	T3,N			;GET STR
	CAME	T3,['DSK   ']		;WAS IT DSK?
	JRST	QUOTS1			;NO
	AOS	U.QTA			;INDICATE /QUOTA:DSK
	JRST	.POPJ1##		;AND RETURN WITHOUT STORE

QUOTS1:	CAMN	T3,['ALL   ']		;ALL STRS IN SYSTEM?
	TDZA	N,N			;ALLOW ALL STRS TO MATCH

QUOTS2:	PUSHJ	P,.MKMSK##		;GENERATE A MASK
	MOVEM	T1,STRMSK		;SAVE MASK

QUOTS3:	MOVE	T1,LSTSTR		;GET LAST STR
	SYSSTR	T1,			;GET NEXT
	  JRST	QUOTS5			;ILLEGAL STR
	JUMPE	T1,.POPJ1##		;RETURN IF NO MORE
	MOVEM	T1,LSTSTR		;SET NEW "LAST" STR
	JUMPE	N,QUOTS4		;ALL?
	AND	T1,STRMSK		;MASK NAME
	CAME	T1,N			;MATCH?
	JRST	QUOTS3			;NO--TRY THE NEXT ONE
	MOVE	T1,LSTSTR		;RELOAD STR NAME

QUOTS4:	PUSHJ	P,STRPUT		;ADD TO QTATAB
	JRST	QUOTS3			;LOOP FOR ALL STRS

QUOTS5:	WARN	(ISN,<Illegal structure name ">,QUOTS6)
	JRST	.POPJ1##		;RETURN WITHOUT STORE

QUOTS6:	MOVE	T1,N			;GET STR NAME
	PUSHJ	P,.TSIXN##		;TYPE IT
	MOVEI	T1,""""			;GET A DOUBLE QUOTE
	PJRST	.TCHAR##		;TYPE IT AND RETURN
SUBTTL	SCAN switch processing -- RMRKSW - /REMARK


	XWD	0,[ASCIZ /"ASCII string"/]
RMRKSW:	PUSHJ	P,.SWASQ##	;READ THE QUOTED STRING
	MOVE	N,.NMUL##	;MAKE SCAN HAPPY
	PUSHJ	P,LGLRMK	;CHECK STRING FOR LEGAL CHARACTERS AND LENGTH
	PJRST	.SWDPB##	;GO STORE RESULT AND RETURN
SUBTTL	SCAN switch processing -- TERMSW - /TERMINAL


	PUSHJ	P,TERHLP	;/HELP:ARG ROUTINE
TERMSW:	MOVEI	T1,TERSWT	;POINT TO SUB-TABLE
	PJRST	KEYWRD		;HANDLE THE KEYWORDS

TERHLP:	MOVE	T1,TERSWT+SWA	;POINT TO KEYWORD TABLE
	PJRST	HELPTB		;PRINT TABLE AND RETURN

	IOWD	TERM.L,TERM.N	;POINTER TO SWITCH KEYWORDS
TERSWT:	TERM.N(P1)		;SWITCH POINTERS FOR /TERMINAL
	TERM.P(P1)		
	TERM.M(P1)		
	TERM.D(P1)		
SUBTTL	SCAN switch processing -- HELPTB - Keyword help typeout


HELPTB:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	P1,T1		;GET IOWD POINTER TO SWITCH NAME TABLE
	MOVEI	T1,"("		;START LIST
	PUSHJ	P,.TCHAR##
HELPT1:	MOVE	T1,1(P1)	;GET A KEYWORD
	PUSHJ	P,.TSIXN##	;TYPE IT
	AOBJP	P1,HELPT2	;ADVANCE POINTER
	PUSHJ	P,.TCOMA##	;SEPARATE
	JRST	HELPT1		;LOOP THROUGH TABLE
HELPT2:	MOVEI	T1,")"		;FINISH
	PJRST	.TCHAR##	;TYPE IT AND RETURN
SUBTTL	SCAN switch processing -- KEYWRD - Complex switch argument parsing


; THIS ROUTINE IS SIMILIAR TO .KEYWD IN SCAN, EXCEPT IT DOESNT HANDLE
; ALSO THE CASES THAT SCAN'S DOES. BUT, IT HANDLES THE SIMPLE SN,SP,SL
; SUB-SWITCHES THAT LOGIN USES FOR /TERMINAL:. MAYBE SOMEDAY IF SCAN
; CHANGES, WE CAN REMOVE THIS CODE

; OFFSETS INTO SWT TABLES FOR KEYWRD ROUTINE
	SWA==-1
	SWN==0
	SWP==1
	SWM==2
	SWD==3

KEYWRD:	PUSHJ	P,.SAVE2##	;SAVE P1 (SWITCH INDEX)
	MOVEI	P2,(T1)		;SAVE POINTER TO SWITCH TABLE
	PUSHJ	P,SIXSW		;GET NAME
	MOVE	T1,SWA(P2)	;GET POINTER TO TABLES
	PUSHJ	P,SWTNAM	;LOOKUP IN TABLE
	  SKIPA			;CAN'T FIND, TRY HARDER
	JRST	KEYWDG		;GOT IT
	JUMPG	T1,E.UKK##	;AMBIGUOUS IF MORE THAN ONE
	TLC	N,'NO '		;SEE IF /NOXYZ
	TLCE	N,'NO '		;..
	JRST	E.UKK##		;NO--ISSUE ERROR
	PUSH	P,N		;SAVE WORD
	LSH	N,^D12		;STRIP "NO"
	MOVE	T1,SWA(P2)	;POINT TO TABLES AGAIN
	PUSHJ	P,SWTNAM	;LOOKUP
	  JRST	[POP   P,N	;ERROR--RESTORE WORD
		 JRST	E.UKK##] ;AND ISSUE ERROR
	POP	P,N		;RESTORE NAME
	TLO	P1,-1		;FLAG /NOXYZ
	MOVX	T1,FS.NOS 	;GET YES/NO BIT
	TDNN	T1,@SWD(P2)	;SEE IF YES/NO SWITCH
	JRST	[MOVNI	T1,1	;ELSE PRETEND UNKNOWN
		 JRST	E.UKK##] ;FOR SCAN
KEYWDG:	MOVE	T2,@SWD(P2)	;GET DEFAULT
	MOVEI	N,(T2)		;COPY INTO N
	MOVE	T1,@SWM(P2)	;GET PROCESSOR OR TABLE POINTER
	TXNE	T2,FS.NOS	;SEE IF "NO" SWITCH
	JRST	[HLRZ N,P1	;IF SN STYLE, GET NO INDICATOR
		 MOVEI N,1(N)	;SET N=0 IF NO, 1 IF NOT NO
		 JRST KEYWDA]	;GO STUFF RESULT
	CAIN	C,":"		;SEE IF VALUE SPECIFIED
	JRST	KEYWD2		;YES--GO CHECK INTO IT

; HERE WHEN DEFAULT NEEDED
KEYWD1:	TXNE	T2,FS.VRQ	;SEE IF VALUE REQUIRED
	JRST	E.SVR##		;YES--GIVE ERROR
	TLNN	T1,-1		;SEE IF MAX SET
	JUMPN	T1,KEYWDJ	;NO--DIRECT ACTION
	JRST	KEYWD8		;YES--GO STORE DEFAULT

; HERE WHEN VALUE SPECIFIED BY USER (MAY BE NULL)
KEYWD2:;JUMPE	T1,E$$NMA	;IF NO VALUE LEGAL, GIVE ERROR
	JUMPG	T1,KEYWDJ	;IF SPECIAL PROCESSOR, GO DO IT
	PUSHJ	P,SIXSW		;VALUE IS ANOTHER KEYWORD--GET IT
	MOVE	T1,@SWM(P2)	;REFETCH SUB-KEY POINTER
	PUSHJ	P,.NAME		;LOOK IT UP
	  JRST	E.UKK##		;ERROR
	SUB	T1,@SWM(P2)	;DETERMINE INDEX AS VALUE
	MOVEI	N,(T1)		;PLACE IN VALUE (1,2,...)
	JRST	KEYWD8		;AND GO STORE IT AWAY

; HERE IF SN SWITCH TO LOOK FOR VALUES
KEYWDA:	JUMPE	N,KEYWD8	;IF NO, PROCEED (NO VALUES)
	CAIE	C,":"		;SEE IF VALUE COMING
	JRST	KEYWD8		;NO--THAT'S IT
KEYWDB:	PUSHJ	P,SIXSW		;GET VALUE AS NAME
	MOVE	T1,[IOWD YNTABL,YNTAB] ;TRY YES-NO TABLE
	PUSHJ	P,.NAME		;LOOK UP NAME
	  JRST	E.UKK##		;UNKNOWN
	MOVEI	N,(T1)		;GET LOCATION OF MATCH
	SUBI	N,YNTAB		;GET OFFSET IN TABLE
	ANDI	N,1		;GET YES/NO SETTING
	JRST	KEYWD8		;RETURN THAT VALUE

; HERE TO GO TO SWITCH PROCESSOR
KEYWDJ:	PUSHJ	P,(T1)		;GO DO IT
	  JFCL			;GO STORE

; HERE TO STORE SWITCH
KEYWD8:	LDB	T1,@SWP(P2)	;GET STORED VALUE
	CAME	T1,[-1]		;SEE IF SET
	JRST	[CAME	T1,N	;SAME AS BEFORE?
		 SKIPE	INISCN	;IN SWITCH.INI?
		 JRST	.SWDON## ;YES--JUST FORGET
		 JRST	E.DSI##] ;NO--ERROR
	DPB	N,@SWP(P2)	;NO--STORE VALUE
	JRST	.SWDON##	;AND RETURN W/O STORE
; TABLE OF YES/NO VALUES--MUST BE NO/YES PAIRS
YNTAB:	SIXBIT	/0/
	SIXBIT	/1/
	SIXBIT	/NO/
	SIXBIT	/YES/
	SIXBIT	/OFF/
	SIXBIT	/ON/
YNTABL==.-YNTAB


; ROUTINE TO READ SIXBIT WORD IGNORING LEADING SPACES
SIXSW:	PUSHJ	P,.TIAUC##	;PRIME THE PUMP
	CAIN	C," "		;SPACE?
	PUSHJ	P,.TIAUC##	;YES--GET A REAL CHAR
	PJRST	.SIXSC##	;READ SIXBIT (CHAR IN C)


; ROUTINE TO LOOKUP SWITCH IN TABLE
SWTNAM:	PUSHJ	P,.NAME##	;LOOKUP IN TABLE
	  POPJ	P,		;NOT FOUND
	HRRZ	T2,SWN(P2)	;GET START
	MOVEI	P1,(T1)		;GET MATCH
	SUBI	P1,(T2)		;COMPUTE OFFSET
	JRST	.POPJ1##	;AND SKIP RETURN
SUBTTL	SCAN switch processing -- SWITCH - Read SWITCH.INI


SWITCH:	HRRZ	T1,COMIDX	;GET INVOKING COMMAND INDEX
	MOVE	T1,COMOBK(T1)	;POINT TO APPROPRIATE SWITCH TABLES
	SETOM	INISCN		;FLAG IN SWITCH.INI OSCAN
	TLNN	F,FL.WLD	;FUNNY PPN'S GET NO SWITCH.INI
	PUSHJ	P,.OSCAN##	;READ SWITCH.INI
	SETZM	INISCN		;DONE WITH SWITCH.INI
	MOVE	T3,TTBITS	;GET TTY BITS
	TXNN	T3,GL.ITY	;PTY?
	POPJ	P,		;NO--DONE
	SETZM	U.PASS		;DON'T CONFUSE BATCON OR OPSER
	POPJ	P,		;RETURN
SUBTTL	SCAN switch defaulting -- TTYDEF - Terminal parameters


TTYDEF:	SKIPG	T1,U.SPED	;DID HE SAY /SPEED:N?
	JRST	TTYDE1		;NOPE
	MOVEM	T1,U.RSPD	;YES -- SET BOTH RCV AND XMIT
	MOVEM	T1,U.XSPD	;SPEED TO N
TTYDE1:	MOVEI	T1,1		;A BIT
	SKIPG	U.STOP		;STOP?
	SKIPLE	U.SSTOP		;OR SSTOP?
	MOVEM	T1,T.STOP	;YES--SET STOP
	SKIPLE	U.SSTOP		;SSTOP?
	MOVEM	T1,T.SSTOP	;YES--SET SSTOP TOO
	POPJ	P,		;RETURN
SUBTTL	Set routines -- ASNDEV - Assign devices


ASNDEV:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVSI	P1,-DVICES	;AOBJN POINTER
ASNDE1:	SETZB	T1,T3		;SET UP OPEN BLOCK
	SKIPN	T2,DEVTAB+0(P1)	;GET PHYSICAL NAME
	POPJ	P,		;DONE
	OPEN	IOC,T1		;INIT DEVICE
	  JRST	ASNDE3		;FAILED
	MOVEI	T1,IOC		;CHANNEL NUMBER
	SKIPN	T2,DEVTAB+1(P1)	;GET LOGICAL NAME
	JRST	ASNDE2		;NONE--KEEP GOING
	DEVLNM	T1,		;ASSIGN LOGICAL NAME
	  JRST	ASNDE3		;CAN'T
ASNDE2:	MOVE	T1,THSJOB	;SET ASSCON BY REASSIGN
	MOVEI	T2,IOC		;CHANNEL NUMBER
	REASSI	T1,		;ASSIGN DEV:LOG
	SKIPA			;ONWARD
ASNDE3:	WARN	CAD,<Cannot assign device >,,E.CAD
	RELEAS	IOC,		;GIVE UP CHANNEL
	AOS	P1		;ACCOUNT FOR TWO WORD ENTRIES
	AOBJN	P1,ASNDE1	;LOOP THROUGH DEVICE LIST
	POPJ	P,		;RETURN


E.CAD:	MOVE	T1,DEVTAB+0(P1)	;GET DEVICE NAME
	PUSHJ	P,.TSIXN##	;PRINT IT
	SKIPN	DEVTAB+1(P1)	;HAVE A LOGICAL NAME?
	POPJ	P,		;NO--DONE
	MOVEI	T1,[ASCIZ / logical name /]
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	MOVE	T1,DEVTAB+1(P1)	;GET LOGICAL NAME
	PJRST	.TSIXN##	;PRINT IT AND RETURN
SUBTTL	Set routines -- CRESFD - Create SFDs


CRESFD:	SETOM	UFDFSN		;START WITH FIRST STR
CRESF1:	MOVE	T2,UFDFSN	;GET STR NAME
	MOVE	T1,[3,,T2]	;POINTER TO ARG BLOCK
	JOBSTR	T1,		;GET NEXT STR
	  POPJ	P,		;EMPTY S/L
	JUMPE	T2,.POPJ##	;JUMP IF WE ARE UP TO FENCE
	AOJE	T2,.POPJ##	;OR END OF LIST IN ONE-STR SYSTEMS
	SOS	T2		;ACCOUNT FOR AOJE
	MOVEM	T2,UFDFSN	;SAVE STR NAME
	MOVE 	T1,[2,,T2]	;POINTER TO ARG BLOCK
	DSKCHR	T1,		;GET AMOUNT OF LOGGED-IN QUOTA
	  JRST	CRESF2		;FAIL-SKIP THIS STR
	TRNN	T3,-1		;ANY BLOCKS LEFT?
	JRST	CRESF2		;NO - SKIP THIS STR
	TXNE	T4,DF.SWL	;UNLESS SOFTWARE W/L STR
CRESF2:	TDZA	T1,T1		;INDICATE DONT CREATE SFDS
	MOVEI	T1,1		;FLAG TO CREATE SFDS
	SKIPN	U.SFDC		;USER WANT THEM CREATED?
	MOVEI	T1,0		;NO--FLAG NOT TO CREATE EVEN IF WE COULD
	PUSHJ	P,ENTPTH	;CREATE SFD'S AS NEEDED
	JRST	CRESF1		;LOOP OVER ALL ACTIVE STRS
SUBTTL	Set routines -- PRETMS/POSTMS - Set terminal parameters


; ROUTINE TO RO PRE-MESSAGE TRMOPS
PRETMS:	PUSHJ	P,TTYDEF	;DEFAULT TERMINAL PARAMETERS
	MOVE	T1,[-TTLNTH,,TTAB] ;TABLE OF PRE-NOTICE TRMOP.S
	PJRST	TRMOPL		;DO TRMOPS AND RETURN


; ROUTINE TO DO POST-MESSAGE TRMOPS
POSTMS:	MOVEI	P1,^D120	;WAIT FOR TTY OUTPUT FOR 2 MIN.
POSTM1:	MOVE	T1,[XWD 2,T2]	;SET UP POINTER FOR TRMOP.
	MOVEI	T2,.TOSOP	;SKIP IF OUTPUT BUFFER NON-EMPTY
	MOVE	T3,TTYUDX	;OUR UNIVERSAL I/O INDEX
	TRMOP.	T1,		;IF OUTPUT BUFFER EMPTY OR TRMOP.
	  JRST	POSTM2		;FAILED, ASSUME OK AND RETURN
	MOVEI	T1,1		;SLEEP FOR ONE SECOND
	SLEEP	T1,		;ZZZZZZ
	SOJG	P1,POSTM1	;IF STILL PATIENT, KEEP SLEEPING
POSTM2:	MOVE	T1,[-PTLNTH,,PTAB] ;TABLE OF POST-NOTICE TRMOP.S
	PJRST	TRMOPL		;DO THEM UP
SUBTTL	Set routines -- PRVSET - Set all privileged parameters


PRVSET:	PUSHJ	P,SETSPL	;SET SPOOLING PARAMETERS
	PUSHJ	P,SETCOR	;SET CORE LIMITS
	PUSHJ	P,SETENQ	;SET ENQ/DEQ QUOTAS
	PUSHJ	P,SETSCD	;SET SCHEDULER PARAMETERS
	PUSHJ	P,SETACT	;SET ACCOUNT STRING
	PUSHJ	P,SETIPC	;SET IPCF QUOTAS
	PUSHJ	P,SETCTX	;SET CONTEXT QUOTAS
	POPJ	P,
SUBTTL	Set routines -- USRSET - Set all unprivileged parameters


USRSET:	PUSHJ	P,CRESFD	;CREATE SFDS
	PUSHJ	P,SETPTH	;SET PATH
	PUSHJ	P,SETWAT	;SET WATCH
	PUSHJ	P,SETDSF	;SET DSKFUL
	PUSHJ	P,SETDSP	;SET DSKPRIORITY
	PUSHJ	P,SETLOC	;SET JOB'S LOCATION FOR SPOOLING
	PUSHJ	P,SETDEF	;SET DEFAULTS
	PUSHJ	P,SETVMX	;SET CURRENT VIRTUAL AND PHYSICAL LIMITS
	PUSHJ	P,PRETMS	;DO PRE-MESSAGE TRMOPS
	PUSHJ	P,ASNDEV	;ASSIGN DEVICES
	POPJ	P,
SUBTTL	Set routines -- SETACT - Set account string


SETACT:	MOVE	T1,U.ACTS	;GET ACCOUNT STRING
	AOJE	T1,.POPJ##	;RETURN IF NONE TO SET
	MOVE	T1,[.ACTCH,,T2]	;SET UP UUO AC
	MOVEI	T2,1		;ONE ARGUMENT
	HRROI	T3,U.ACTS	;SEVEN BIT BYTE POINTER TO ACCOUNT STRING
	ACCT.	T1,		;TELL THE MONITOR THE USER'S ACCOUNT STRING
	  SKIPA			;FAILED
	POPJ	P,		;RETURN
	SKIPE	.JBDDT##	;DEBUGGING?
	JRST	SETAC1		;YES--JUST MAKE IT A WARNING
	MOVE	T2,STATS2	;GET SECOND STATES WORD
	TXNE	T2,ST%ACV	;ACCOUNT VALIDATION REQUIRED?
	STOP	FSA,<Cannot set account string; ACCT. UUO error >,EF.WTO,.TOCTW##
SETAC1:	WARN	WSA,<Cannot set account string>,EF.WTO
	POPJ	P,		;AND RETURN
SUBTTL	Set routines -- SETCOR - Set core limits


SETCOR:	LDB	T3,[POINTR AENTRY+.AECOR,AE.NPP] ;GET PHYS. LIMIT
	LDB	T4,[POINTR AENTRY+.AECOR,AE.NVP] ;GET VIRT LIM
	SKIPG	T1,U.CORE	;GET /CORE ARG IF ONE
	JRST	SETCO2		;NO ARG--USE PHYS. LIMIT
	CAIL	T1,1000		;IS ARG ALREADY IN WORDS ?
	JRST	SETCO1		;YES--SKIP ON
	CAILE	T1,^D256	;IS ARG UNREASONABLE ?
	LSH	T1,^D9		;YES--ASSUME HE MEANT P AND CONVERT
	CAIG	T1,^D256	;IS ARG IN K ?
	LSH	T1,^D10		;YES--CONVERT TO WORDS
SETCO1:	LSH	T1,-11		;CONVERT TO PAGES
	CAML	T3,T1		;IS /CORE ARG .LT. OR = PHYS. LIMIT
	MOVE	T3,T1		;NO--USE PHYS. LIMIT FROM /CORE
SETCO2:	HRL	T3,T4		;MAKE IT VIRT,,PHYS
	MOVE	T1,[.STUVM,,T3]	;LOAD POINTER TO STUFF
	PUSHJ	P,SETXXX	;SET VM LIMITS
	  WARN	SVM,<Set maximum virtual and physical limits failed>
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETCTX - Set context quotas


SETCTX:	MOVEI	T1,.CTSQT	;FUNCTION CODE TO SET QUOTAS
	PUSHJ	P,CTXINI	;INIT CONTEXT BLOCKS
	SETOM	CTXDAT+.CTJOB	;-1 FOR OUR JOB
	MOVE	T1,AENTRY+.AECTX ;COPY CONTEXT QUOTA WORD
	LDB	T2,[POINTR T1,AE.CNQ] ;GET CONTEXT QUOTA
	MOVEM	T2,CTXDAT+.CTCTQ ;SAVE
	LDB	T2,[POINTR T1,AE.CPQ] ;GET SAVED PAGE QUOTA
	MOVEM	T2,CTXDAT+.CTPGQ ;SAVE
	PUSHJ	P,CTXUUO	;EXECUTE CONTEXT UUO AND PROCESS ERRORS
	  JFCL			;FAILED (MESSAGE ALREADY PRINTED ON TTY)
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETDEF - Set DEFAULT


SETDEF:	
; FILE PROTECTION
	MOVE	T1,[.STDEF,,T2]	;SETUUO FOR DEFAULTS
	HRRZI	T2,.STDPC	;FUNCTION CODE FOR FILE PROTECTION
	SKIPGE	T3,U.DFPR	;SWITCH SPECIFIED?
	JRST	SETDE1		;NO - SKIP THE SETUUO
	PUSHJ	P,SETXXX	;SET DEFAULT FILE PROTECTION
	  WARN	SFP,<Set default file protection failed>

; ATTACH ASK/IGNORE
SETDE1:	MOVE	T1,[.STDEF,,T2]	;SET UUO FOR DEFAULTS
	MOVSI	T2,1		;ASSUME IGNORE
	HRRI	T2,.STDAD	;FUNCTION CODE
	SKIPL	T3,U.ATT	;DID USER TYPE A /ATTACH SWITCH?
	CAIE	T3,ATTIGN	;YES. DID HE SAY TO IGNORE ATTACH PROMPTING?
	TDZA	T3,T3		;NO.  DEFAULT TO ASK
	SETOM	T3		; SET JOB'S DEFAULT TO DON'T ASK
	PUSHJ	P,SETXXX	;SET ATTACH
	  WARN	SAF,<Set ATTACH failed>

; DEFAULT BUFFERS
	MOVE	T1,[.STDEF,,T2]	;SETUP ARGS
	MOVEI	T2,.STDNB	;SUBFUNCTION DEFAULT BUFFERS
	SKIPGE	T3,U.DFBU	;GET USERS SWITCH VALUE
	JRST	SETDE2		;NONE GIVEN
	PUSHJ	P,SETXXX	;SET DEFAULT BUFFERS
	  WARN	SBN,<Set default buffers failed>

;HERE TO SET DEFAULT BIGBUF
SETDE2:	SKIPGE	T3,U.DFBB	;SEE IF BIGBUF GIVEN
	POPJ	P,		;NO
	HRLZS	T3		;POSITION TO LH FOR JOB-WIDE DEFAULT
	MOVE	T1,[.STDEF,,T2]	;SETUP ARGS
	MOVEI	T2,.STDSB	;SUBFUNCTION DEFAULT BIGBUF
	PUSHJ	P,SETXXX	;SET DEFAULT BIGBUF
	  WARN	SBB,<Set default big buffers failed>
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETDSF - Set DSKFUL


SETDSF:	SKIPGE	T2,U.DFUL	;GET DISK FULL SWITCH
	POPJ	P,		;RETURN
	CAIN	T2,DSKFER	;ERROR?
	MOVX	T1,.DFERR	;YES--SET ERROR ARG
	CAIN	T2,DSKFPA	;PAUSE?
	MOVX	T1,.DFPSE	;YES--SET THAT
	HRLI	T1,.STDFL	;SET FUNCTION
	PUSHJ	P,SETXXX	;SET DSKFUL
	  WARN	SDF,<Set DSKFUL failed>
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETDSP - Set DSKPRIORITY


SETDSP:	SKIPN	T1,U.DPRI	;GET DISK PRIORITY
	POPJ	P,		;NONE SPECIFIED
	LDB	T2,[POINTR AENTRY+.AEPRV,JP.DPR] ;GET VALUE FROM PROFILE
	JUMPE	T2,.POPJ##	;NONE ALLOWED
	CAILE	T1,(T2)		;IS SWITCH VALUE WITHIN LIMITS?
	MOVEI	T1,(T2)		;NO--USE LIMITS FROM USER'S PROFILE
	HRLI	T1,-2
	MOVE	T2,[.DUPRI,,T1]	;ARG POINTER
	DISK.	T2,		;DO THE UUO
	  WARN	SDP,<Can not set disk priority>
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETENQ - Set ENQ/DEQ parameters


SETENQ:	MOVE	T1,AENTRY+.AEENQ ;GET ENQ/DEQ QUOTA
	HRLZ	T1,T1		;PUT QUOTA IN LEFT HALF
	HRR	T1,THSJOB	;AND JOB NUMBER IN RIGHT HALF
	MOVE	T2,[XWD 2,T1]	;SET UP POINTER TO ARG
	ENQC.	T2,		;DO IT UP
	  CAMN	T2,[XWD 2,T1]	;AC UNCHANGED (UUO NOT IMPLEMENTED)?
	POPJ	P,		;YES--DON'T BOTHER USER
	MOVE	T1,T2		;PICK UP ERROR CODE
	WARN	EUF,<ENQC. UUO failederror code = >,EF.WTO,.TOCTW##
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETGLX - Set GALAXY batch parameters


SETGLX:	TLNN	F,FL.BAT	;BATCH JOB?
	POPJ	P,		;NO

; SET WTO/WTOR PRIVS
	SKIPGE	T1,U.BINT	;GET /BATINT VALUE
	MOVEI	T1,1		;ASSUME YES INCASE BATCON FORGOT THIS SWITCH
	MOVE	T1,[.OBNWR	;WTO ALLOWED
		    .OBALL](T1)	;WTO AND WTOR ALLOWED
	HRLI	T1,.STWTO	;SETUUO FUNCTION CODE
	PUSHJ	P,SETXXX	;SET WTO/WTOR PRIVS
	  WARN	SWT,<Set write to OPR privileges failed>

; SET BATCH STREAM NUMBER
	SKIPGE	T1,U.BSTR	;GET /BATSTR VALUE
	POPJ	P,		;THERE WASN'T ONE
	HRLI	T1,.STBSN	;SETUUO FUNCTION CODE
	PUSHJ	P,SETXXX	;SET BATCH STREAM NUMBER
	  WARN	SBS,<Set batch stream number failed>
	POPJ	P,		;AND RETURN
SUBTTL	Set routines -- SETIPC - Set IPCF quotas


SETIPC:	MOVE	T1,STATS2	;GET 2ND STATES WORD
	TXNN	T1,ST%IPC	;DO WE HAVE IPCF?
	POPJ	P,0		;NO--RETURN NOW
	MOVE	T1,[%IPCCP]	;GET THE PID OF [SYSTEM]IPCF
	GETTAB	T1,		; ..
	  POPJ	P,0		;CAN NOT FAIL
	MOVEM	T1,TOPID	;SAVE AS TARGET OF THIS MESSAGE
	MOVX	T1,IP.CFP	;INDICATE THAT I HAVE PRIVS AND
	MOVEM	T1,IPCFLG	; WANT TO USE THEM
	MOVE	T1,[3,,IPCMSG]	;POINTER TO THE MESSAGE
	MOVEM	T1,IPCPTR	; ..
	MOVX	T1,.IPCSQ	;WANT TO SET QUOTA
	MOVEM	T1,IPCMSG	;STORE AS FUNCTION
	HRRZ	T1,AENTRY+.AEIPC ;GET IPCF QUOTAS
	MOVEM	T1,IPCQTA	;STORE IT AWAY
	MOVE	T1,THSJOB	;GET MY JOB NUMBER
	MOVEM	T1,IPCJOB	;STORE THAT AWAY
	MOVEM	T1,FMPID	;ALSO LOAD AS SENDERS PID
	MOVE	T1,[4,,IPCFLG]	;POINTER TO THE MESSAGE
	IPCFS.	T1,		;SEND IT
	  JRST	IPCSER		;SEND ERROR
	MOVX	T1,IP.CFB	;SAY WE DON'T WANT TO BLOCK
	MOVEM	T1,IPCFLG
	MOVE	T1,[4,,IPCFLG]	;SET UP TO GET BACK AN
	IPCFR.	T1,		; ANSWER.
	  JRST	IPCRER		;NO ANSWER
	MOVE	T1,IPCFLG	;GET THE FALGS WORD
	TXNN	T1,IP.CFE	;ANY ERROR CODE?
	POPJ	P,0		;NO--RETURN
	WARN	ESI,<Error from [SYSTEM]IPCF>,EF.WTO
	  POPJ	P,0		;ALL DONE
	JRST	IPCQER		;TELL HIM MORE


IPCSER:	WARN	STI,<Send to [SYSTEM]IPCF failed; error >,EF.WTO,.TOCTW##
	JRST	IPCQER		;TELL HIME MORE
IPCRER:	CAIN	T1,IPCNP%	;QUEUE EMPTY?
	POPJ	P,0		;YES--ALL IS WELL
	WARN	RFI,<Receive from [SYSTEM]IPCF failed; error >,EF.WTO, .TOCTW##
IPCQER:	WARN	IQS,<IPCF quotas may not be set correctly>
	POPJ	P,0		;RETURN
SUBTTL	Set routines -- SETLOC - Set job's location for spooling


SETLOC:	MOVE	T1,U.STA	;GET STATION
	CAME	T1,[-1]		;SEE IF SPECIFIED
	JRST	SETLO1		;ONE WAS SPECIFIED, USE IT
	MOVEI T1,.GTLOC		;GETTAB FOR NODE # OF CENTRAL SITE
	GETTAB	T1,		;GET CENTRAL SITE NODE NUMBER
	  POPJ	P,		;MONITOR MUST NOT SUPPORT NETWORKS
	HRROI	T2,.GTLOC	;THIS JOB'S LOCATION
	GETTAB	T2,		;GET THAT
	  POPJ	P,		;NO NETWORK SOFTWARE
	CAMN	T1,T2		;ALREADY LOCATED AT CENTRAL SITE?
	POPJ	P,		;YES, NO POTENTIAL PROBLEMS THEN
	MOVEM	T2,NODLOC	;STORE THIS JOB'S LOCATION IN NODE BLOCK
	MOVEI	T2,5		;LENGTH OF THE ARGUMENT BLOCK
	MOVEM	T2,NODLEN	;STORE IN NODE UUO ARGUMENT BLOCK
	DMOVE	T2,[EXP .TYLPT,.TYMCR] ;DEVICE TYPES
	DMOVEM	T2,NODDEV	;STORE THAT IN THE ARGUMENT BLOCK
	MOVE	T2,[.NDRCI,,NODBLK] ;NODE UUO ARGUMENT
	NODE.	T2,		;GET NODE CONFIGURATION INFORMATION
	  POPJ	P,		;NOT IMPLEMENTED?
	HLRZ	T2,NODDEV+1	;SEE IF LOCATED NODE HAS AN MCR
	JUMPN	T2,SETLO1	;IF SO, THEN LOCATE AT CENTRAL STATION
	HLRZ	T2,NODDEV+0	;NOW SEE IF STATION AS AT LEAST ONE LPT
	JUMPN	T2,.POPJ##	;IF SO, THEN USER CAN GET LISTINGS
SETLO1:	LOCATE	T1,		;SET JOB'S LOCATION FOR SPOOLING
	  CAIN	T1,0		;FAILED--SEE IF FOR CENTRAL SITE
	SKIPA			;OK OR POSSIBLY NETSER NOT LOADED
	WARN	LUF,<LOCATE UUO failed>
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETPTH - Set PATH


SETPTH:	HRREI	T1,.PTFSD	;FUNCTION TO SET DEFAULT PATH
	MOVEM	T1,PTHBUF+.PTFCN ;STORE IN ARGUMENT BLOCK
	SKIPGE	T1,U.SCAN	;SCAN SWITCH GIVEN
	MOVEI	T1,AD.YN	;NO--SETUP DEFAULT
	ADDI	T1,.PTSCN	;ADJUST TO START OF RANGE
	MOVEM	T1,PTHBUF+.PTSWT ;SAVE SWITCH IN ARGUMENT BLOCK
	MOVE	T1,[.PTMAX,,PTHBUF] ;DO THE PATH UUO TO SET
	PATH.	T1,		; DEFAULT PATH
	  SKIPA	T1,[1,,PTHBUF+.PTPPN] ;FAILED--POINT TO PATH BLOCK
	JRST	SETPT1		;ONWARD
	WARN	CSP,<Can not set path to >,,.TDIRB##
	SETZM PTHBUF+.PTSFD	;CLEAR SFDS IN CASE THEY DIDNT EXIST
	MOVE  T1,[.PTMAX,,PTHBUF];SETUP ARGS AGAIN
	PATH. T1,		;ONE MORE TRY
	  WARN  CSS,<Can not set /SCAN switch>
SETPT1:	SETZM	PTHBUF+.PTSWT	;CLEAR THE SWITCHES
	SKIPN	LIBSPC+.FXDIR	;IF THERE IS NO LIB REQUESTED
	SETZM	PTHBUF+.PTPPN	;CLEAR THE LIB PPN
	HRREI	T1,.PTFSL	;CHANGE FUNCTION TO SET DEFAULT
	MOVEM	T1,PTHBUF+.PTFCN ; LIBRARY
	SKIPGE	T1,U.SYS	;WAS /SYS GIVEN?
	MOVEI	T1,AD.YN	;NO--SET DEFAULT
	JUMPE	T1,SETPT2	;JUMP IF NOSYS
	MOVX	T1,PT.SSY	;ELSE ADD SYS BIT
	IORM	T1,PTHBUF+.PTSWT ; INTO ARGUMENT
SETPT2:	SKIPGE	T1,U.NEW	;WAS /NEW GIVEN
	MOVEI	T1,AD.YN	;NO--SUPPLY ABSENT DEFAULT
	JUMPE	T1,SETPT3	;JUMP IF NONEW
	MOVX	T1,PT.SNW	;SET THE NEW BIT IN
	IORM	T1,PTHBUF+.PTSWT ; PATH. UUO ARGUMENT BLOCK
SETPT3:	SKIPN	T1,LIBSPC+.FXDIR ;GET LIB PPN
	JRST	SETPT4		;JUMP IF NONE
	TLNN	T1,-1		;IS PROJECT # ZERO?
	HLL	T1,PP		;YES - USE USER'S
	TRNN	T1,-1		;ZERO PROGRAMMER NO.?
	HRR	T1,PP		;DEFAULT TO USER'S OWN
	MOVEM	T1,PTHBUF+.PTPPN ;STORE PPN
	MOVX	T1,PT.LIB	;SET THE LIB BIT
	IORM	T1,PTHBUF+.PTSWT ;SET /LIB
SETPT4:	MOVE	T1,[.PTMAX,,PTHBUF] ;DO THE PATH UUO
	PATH.	T1,		; ..
	  JFCL			; ..
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETSCD - Set scheduler parameters


SETSCD:	MOVE	T1,STATS2	;GET 2ND STATES WORD
	TXNN	T1,ST%NCS	;SKIP THIS IF 6.03 SCHEDULER IN WMU MODE
	TXNN	T1,ST%SHC	;DOES MONITOR HAVE SCHED. UUO?
	POPJ	P,		;NO--SKIP THIS STUFF
	LDB	T4,[POINTR AENTRY+.AESCD,AE.SCT] ;GET TIMESHARING SCHED CLASS
	TLNE	F,FL.BAT	;BATCH JOB?
	LDB	T4,[POINTR AENTRY+.AESCD,AE.SCB] ;YES, USE BATCH CLASS INSTEAD

	MOVX	T1,%SSMSI	;NOW GETTAB THE MEDIUM-TERM
	GETTAB	T1,		;SCHEDULING INTERVAL TO SEE
	  POPJ	P,		;CLASS SCHEDULER NOT RUNNING
	JUMPE	T1,SETSC2	;IF INTERVAL=0, CLASS SCHEDULER
				;ISN'T RUNNING SO SKIP CHECKS
	MOVX	T1,%SSSET	;CHECK FLAG FOR CLASS
	GETTAB	T1,		;SCHEDULING
	  SETO	T1,		;NOT WMU CLASS SCHEDULER
	JUMPE	T1,SETSC2	;SKIP CHECKS IF RUNNING ROUND ROBIN
	HRRZI	T1,.GTCQP	;NOW GET CPU QUOTA FOR THIS CLASS
	HRL	T1,T4		;T4 HAS OUR CLASS
	GETTAB	T1,		
	  POPJ	P,		;MONITOR NOT BUILT FOR CLASS SCHEDULER
	TRNE	T1,-1		;IF PRIMARY % NON-ZERO,
	JRST	SETSC2		;WERE OK
	MOVE	T2,[%SSBBQ]	;CHECK BACKROUND BATCH
	GETTAB	T2,		;GET BB CLASS
	  SETO	T2,		;NO BB
	CAMN	T2,T4		;IS USER IN BB?
	JRST	SETSC2		;YES, HE IS OK
	JUMPL	T1,SETSC1	;GIVE ERROR IF FIXED SWAPIN BIT SET
	HRRZI	T1,.GTSQP	;NOW GETTAB SECONDARY ALLOCATION
	HRL	T1,T4		;FOR THIS CLASS
	GETTAB	T1,		
	  JRST	SETSC2		;NOT WMU SCHEDULAR
	JUMPN	T1,SETSC2	;OK IF THERE IS A SECONDARY QUOTA
SETSC1:	FATAL	CWR,<CPU class quota is zero; You would never run>

SETSC2:	HRLI	T4,-1		;-1 MEANS THIS JOB
	MOVE	T1,[1,,T2]	;SET UP POINTER FOR SCHED. UUO
	MOVE	T2,[.SCSJC,,T3]	;XWD FUNC, LOC OF ARG LIST
	MOVEI	T3,1		;ONLY ONE ARGUMENT
	SCHED.	T1,		;ZAP!
	  CAMN	T1,[1,,T2]	;FAILED--SEE IF NOT IMPLEMENTED
	POPJ	P,		;OK OR NOT IMPLEMENTED
	WARN	SCF,<SCHED. UUO failed; error code = >,EF.WTO,.TOCTW##
	POPJ	P,		;RETURN


BYTTAB:	POINT	9,(T1),8	;BYTE PTR FOR REMAINDER=0
	POINT	9,(T1),17	;REMAINDER=1
	POINT	9,(T1),26	;T1 HAS ADDR OF WORD TO LOOK AT
	POINT	9,(T1),35

SUBTTL	Set routines -- SETSPL - Set spooling parameters


SETSPL:	SKIPGE	T1,U.TIME	;WANT TIME LIMIT SET?
	JRST	SETSP1		;NO--CHECK SPOOL
	HRLI	T1,.STTLM	;YES--SET UP ENTIRE ARGUMENT
	PUSHJ	P,SETXXX	;SET TIME LIMIT
	  WARN	STL,<Set time limit failed>
SETSP1:	HRROI	T1,.GTSPL	;GET SPOOL BITS FOR JOB TO SEE
	GETTAB	T1,		;IF SYSTEM HAS SPOOLING. IF NOT,
	  POPJ	P,		;DON'T TRY TO SET SPOOL BITS
	MOVE	T1,AENTRY+.AESPL ;GET SPOOL BITS
	IOR	T1,U.SPL	;OR IN ONES REQUESTED BY  USER
	HRLI	T1,.STSPL	;COMPLETE ARGUMENT
	TRZ	T1,-JS.PAL-1	;CLEAR BITS WHICH AREN'T DEVICES
	PUSHJ	P,SETXXX	;SET SPOOL BITS
	  WARN	SSB,<Set spool bits failed>
	LDB	T1,[POINTR AENTRY+.AEPRX,JP.OPR];GET OPERATOR PRIVILEGE CODE
	HRLI	T1,.STOPP
	PUSHJ	P,SETXXX	;SET GALAXY OPR PRIVS
	  WARN	SOP,<Set OPR privileges failed>
	SKIPGE	T1,U.DFER	;WAS THERE A /DEFER SWITCH?
	POPJ	P,		;NO
	HRLI	T1,.STDFR	;SETUUO CODE FOR DEFERRED SPOOLING
	PUSHJ	P,SETXXX	;SET DEFERRED SPOOLING
	  WARN	SDS,<Set deferred spooling failed>
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETVMX - Set current virtual and physical limits


SETVMX:	MOVEI	T3,0		;PRESET ANSWER TO ZERO
	SKIPGE	T1,U.CVPL	;GET CURRENT VIRT LIMIT
	JRST	SETVM1		;NONE SUPPLIED
	CAIG	T1,^D512	;JUST A NUMBER?
	IMULI	T1,^D1024	;YES--CONVERT TO WORDS
	LSH	T1,-9		;CONVERT TO PAGES
	HRL	T3,T1		;USER SUPPLIED ONE -- USE IT
SETVM1:	SKIPGE	T1,U.CPPL	;GET CURRENT PHYS LIMIT
	JRST	SETVM2		;NONE SUPPLIED--LEAVE ZERO
	CAIG	T1,^D512	;JUST A NUMBER?
	IMULI	T1,^D1024	;YES--CONVERT TO WORDS
	LSH	T1,-9		;CONVERT TO PAGES
	HRR	T3,T1		;USER SPECIFIED ONE -- USE IT
SETVM2:	JUMPE	T3,.POPJ##	;JUMP IF NOTHING REQUESTED
	SKIPG	U.LIMIT		;SKIP IF /LIMIT
	SKIPN	U.GUID		;SKIP UNLESS /NOGUIDELINE GIVEN
	TRO	T3,400000	;SET THE BIT
	MOVE	T1,[.STCVM,,T3]	;ARGUMENT TO SET UUO
	PUSHJ	P,SETXXX	;SET CURRENT VIRTUAL AND PHYSICAL LIMITS
	  WARN	SCV,<Set current virtual and physical limits failed>
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETWAT - Set watch bits


SETWAT:	SKIPN	U.NWAT		;SKIP IF NO /NOWATCH
	POPJ	P,		;NO
	MOVE	T1,AENTRY+.AEWCH ;GET WATCH BITS
	HRLZ	T2,U.WAT	;GET WATCH BITS
	LSH	T2,WCHLSH	;SHIFT TO CORRECT PLACE
	IOR	T1,T2		;OR IN THE USER SETTINGS
	MOVE	T2,.FLVRB##	;GET /VERBOSITY FROM SCAN
	LSH	T2,^D6		;SHIFT OVER TO RIGHT PLACE
	ANDI	T2,700		;THROW AWAY GARBAGE BITS
	IOR	T1,T2		;OR INTO WATCH BITS
	HLRZS	T1		;PUT IN RH FOR UUO
	HRLI	T1,.STWTC	;SET WATCH FUNCTION
	PUSHJ	P,SETXXX	;SET WATCH BITS
	  WARN	SWB,<Set watch failed>
	POPJ	P,		;RETURN
SUBTTL	Set routines -- SETXXX - Do a SETUUO


SETXXX:	SETUUO	T1,		;DO THE UUO
	  POPJ	P,		;FAILED
	JRST	.POPJ1##	;RETURN
SUBTTL	Set routines -- TRMOP - TRMOP. UUO loop processor


TRMOPL:	SKIPN	U.SETT		;/NOSETTTY?
	POPJ	P,		;YES--RETURN
	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	P1,T1		;COPY AOBJN POINTER TO TABLE
TRMOP1:	HLRZ	T4,(P1)		;GET ADDR OF ARG FOR TRMOP.
	MOVE	T4,(T4)		;GET ACTUAL ARGUMENT
	CAMN	T4,[-1]		;IF -1,
	JRST	TRMOP2		; SCAN DIDN'T TOUCH IT
	MOVE	T1,[3,,T2]	;SET UP UUO AC
	HRRZ	T2,(P1)		;GET TRMOP. FUNCTION CODE & FLAGS
	MOVE	T3,TTYUDX	;GET TTY UDX
	TRZE	T2,TF.CMP	;CLEAR FLAGS OUT OF T2 SO IT
	TRC	T4,1		;YUP
	TRMOP.	T1,
	  PUSHJ	P,TRMERR	;REPORT ERROR IF NECESSARY
TRMOP2:	AOBJN	P1,TRMOP1	;GO ROUND AGAIN
	POPJ	P,		;ALL DONE

TRMERR:	CAIE	T1,TOILF%	;ILLEGAL FUNCTION?
	CAIN	T1,TOPRC%	;NOT PRIVILEGED?
	POPJ	P,		;IGNORE
	PUSH	P,T1		;WATCH OUT FOR T1
	HRRZ	T1,(P1)		;PICK UP FUNCTION CODE
	CAIN	T1,.TOTRM+.TOSET ;TRYING TO SET TERMINAL TYPE
	JRST	TRMER1		;YES
	WARN	TUF,<TRMOP. UUO failed; function code = >,,.TOCTW##
	JRST	TRMER2		;FINISH UP
TRMER1:	MOVE	T1,T4		;GET TYPE WE TRIED TO SET
	WARN	UTT,<Unknown terminal type >,,.TSIXN##
TRMER2:	POP	P,(P)		;PHASE STACK
	POPJ	P,		;RETURN
; MACRO TO GENERATE TRMOP TABLE ENTRIES
DEFINE X(TCODE,ARG,FLAGS),<XWD	ARG,FLAGS!TCODE+.TOSET>

TF.CMP==1B18			;USE COMPLEMENT OF VALUE STORED BY SCAN


; PRE-MESSAGE TABLE
TTAB:	X .TOTRM,U.TYPE,0	;DO TYPE SETTING FIRST THEN ALTER
	X .TOALT,U.ALTM,TF.CMP	;TRMOP.S WHICH ARE DONE BEFORE
	X .TOBLK,U.BLNK,TF.CMP	;PRINTING NOTICE.TXT
	X .TONFC,U.CRLF,TF.CMP
	X .TODBK,U.DBRK,0
	X .TOLCP,U.LCP,0
	X .TOFLC,U.FILL,0
	X .TOFRM,U.FORM,0
	X .TOSND,U.GAG,TF.CMP
	X .TOLCT,U.LC,TF.CMP
	X .TOPAG,U.PAGE,0
	X .TOPSZ,U.PGSZ,0
	X .TORTC,U.RTC,0
	X .TOTAB,U.TABS,0
	X .TOTAP,U.TAPE,0
	X .TOWID,U.WDTH,0
	X .TODEM,U.TTDE,0
	X .TODIS,U.DISP,0
	X .TOLCT,U.UC,0
	X .TOTDY,U.TIDY,0
;;	X .TOFFH,U.FFHO,0
;;	X .TOFFF,U.FFSI,0
;;	X .TOFFS,U.FFST,0
	X .TOLNB,U.LENG,0
	X .TOSBL,U.SBEL,0
	X .TOSSZ,U.SSTO,0	;STOP SIZE
	X .TOSSZ,U.STOP,0	; "     "
	X .TOXNF,U.XONXO,0
	X .TOSTO,T.STOP,0	;STOP BIT
	X .TOSST,T.SSTOP,0	;SSTOP BIT
	X .TOUNP,U.UNPA,0	;UNPAUSE CHARACTER (ACTS LIKE CONTROL-Q)
	X .TOESC,U.ESCA,0	;ESCAPE CHARACTER (ACTS LIKE ESCAPE ON TYPEIN)
	X .TO8BT,U.8BIT,0	;EIGHT-BIT TERMINAL
	X .TOQOT,U.QUOT,0	;TTY QUOTE ENABLED
	X .TOCLE,U.ECHO,0	;COMMAND MODE ECHO
TTLNTH==.-TTAB			;LENGTH OF TABLE


; POST-MESSAGE TABLE
PTAB:	X .TORSP,U.RSPD,0	;TRMOP.S WHICH SHOULD BE DONE
	X .TOTSP,U.XSPD,0	;AFTER PRINTING NOTICE.TXT
PTLNTH==.-PTAB			;LENGTH OF TABLE
SUBTTL	Structure routines -- BLDJSL - Build job S/L


BLDJSL:	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	TRZ	F,R.ACRE!R.ASTR	;CLEAR ANY CREATE AND ANY STR FLAGS
	SKIPN	P1,AENTRY+.AEAUX ;GET AOBJN POINTER TO AUXACC DATA
	POPJ	P,		;THERE ARE NO STRUCTURES FOR THIS GUY
	ADDI	P1,AENTRY	;INDEX INTO THE PROFILE
	SETZ	P2,		;CLEAR COUNT OF STRUCTURES PROCESSED

BLDJS1:	SKIPN	T2,.AUSTR(P1)	;ANOTHER STRUCTURE?
	JRST	BLDJS4		;NOPE, END OF LIST
	MOVE	T1,[XWD 1,T2]	;SET UP UUO AC
	DSKCHR	T1,		;SEE IF STR IS IN SYSTEM
	  JRST	BLDJS3		;NO, DO NOT PUT IN SEARCH LIST
	LDB	T2,[POINTR(T1,DC.TYP)] ;GET STR TYPE
	TXNN	T1,DC.SAF	;SKIP IF SINGLE ACCESS
	CAIE	T2,.DCTFS	;IS IT FULL FILE STRUCTURE NAME?
	JRST	BLDJS3		;IGNORE STRUCTURE
	MOVX	T1,AU.DNM	;BIT TO TEST
	TDNE	T1,.AUBIT(P1)	;DO NOT MOUNT?
	JRST	BLDJS3		;THAT'S RIGHT
	CAIGE	P2,MAXFS	;TOO MANY STRS IN S/L?
	JRST	BLDJS2		;GO ADD STR
	WARN	MTS,<More than >,,E.MTS
	JRST	BLDJS3		;GIVE UP ON THIS STR
BLDJS2:	TLNN	F,FL.WLD	;WILDCARDED PPN?
	PUSHJ	P,ADDSTR	;NO--ADD STRUCTURE TO SEARCH LIST
	SKIPA			;AND FO TO NEXT STRUCTURE
BLDJS3:	SETOM	.AUSTR(P1)	;INVALIDATE STRUCTURE NAME
	ADDI	P2,1		;COUNT THE STRUCTURE JUST ADDED
	ADD	P1,[.AULEN-1,,.AULEN-1] ;ACCOUNT FOR MULTI-WORD ENTRIES
	AOBJN	P1,BLDJS1	;LOOP
BLDJS4:	JUMPG	P2,.POPJ1##	;SKIP IF S/L HAS AT LEAST ONE STR
	POPJ	P,		;RETURN


E.MTS:	MOVEI	T1,MAXFS	;GET THE MAX
	PUSHJ	P,.TDECW##	;OUTPUT
	MOVEI	T1,[ASCIZ/ structures in search list; cannot add structure /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,.AUSTR(P1)	;GET STR BACK
	PJRST	.TSIXN##	;TYPE AND RETURN
SUBTTL	Structure routines -- MNTSTR - Mount structures (set RIPLOG)


MNTSTR:	PUSHJ	P,.SAVE1##	;SAVE P1
	TLNE	F,FL.WLD	;WILDCARD PPN?
	TLO	F,FL.GPN	;LITE SPECIAL FLAG FOR UFDSET
	SKIPN	P1,AENTRY+.AEAUX ;GET AOBJN POINTER TO AUXACC DATA
	POPJ	P,		;EMPTY S/L
	ADDI	P1,AENTRY	;INDEX INTO PROFILE
	SKIPN	.AUSTR(P1)	;EMPTY S/L?
	POPJ	P,		;YES
	SETOM	RDUFLG		;INIT RECOMP TYPEOUT FLAG
MNTST1:	SKIPE	T1,.AUSTR(P1)	;ANOTHER ONE IN THE WINGS?
	CAMN	T1,[EXP -1]	;DID WE INVALIDATE A STR NAME EARLIER?
	JRST	MNTST2		;YES--IGNORE THIS ONE
	MOVE	T1,.AUBIT(P1)	;GET STATUS BITS
	TXNN	T1,DF.SWL!DF.SNC;CAN WE CREATE ON THIS STR
	TRO	F,R.ACRE	;YES-INDICATE CREATION POSSIBLE
	PUSHJ	P,UFDSET	;SET UP UFD FOR USER ON THIS STR
MNTST2:	ADD	P1,[.AULEN-1,,.AULEN-1] ;ACCOUNT FOR MULTI-WORD ENTRIES
	AOBJN	P1,MNTST1	;LOOP THROUGH S/L
	POPJ	P,		;DONE
SUBTTL	Structure routines -- SSLCOP - Copy the system search list


SSLCOP:	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	MOVEI	P1,AENTRY+.AEMIN ;POINT TO END OF STATIC PROFILE
	MOVEI	P2,GOBBLK	;POINT TO GOBSTR UUO BLOCK
	SETZM	.DFGJN(P2)	;0 FOR SYSTEM SEARCH LIST
	MOVE	T1,SYSPPN	;GET [1,4]
	MOVEM	T1,.DFGPP(P2)	;SAVE
	SETOM	.DFGNM(P2)	;START WITH THE FIRST STRUCTURE
SSLCO1:	MOVE	T1,P2		;POINT TO BLOCK
	HRLI	T1,.DFGST+1	;GET LENGTH
	GOBSTR	T1,		;GET THE NEXT STRUCTURE
	  JRST	SSLCO2		;GIVE UP
	MOVE	T1,.DFGNM(P2)	;GET STR NAME
	SKIPE	T1		;END OF S/L?
	CAMN	T1,[EXP -1]	;FENCE?
	JRST	SSLCO2		;ALMOST DONE
	MOVEM	T1,.AUSTR(P1)	;SAVE STR NAME
	MOVE	T1,.DFGST(P2)	;GET STR BITS
	MOVEM	T1,.AUBIT(P1)	;SAVE
	HRLOI	T1,377777	;+INFINITY
	MOVEM	T1,.AULIN(P1)	;SET FCFS QUOTA
	MOVEM	T1,.AUOUT(P1)	;SET LOGGED OUT QUOTA
	SETZM	.AURES(P1)	;ZERO RESERVED QUOTA
	ADDI	P1,.AULEN	;OFFSET TO THE NEXT STR STORAGE
	JRST	SSLCO1		;LOOP

SSLCO2:	SUBI	P1,AENTRY+.AEMIN ;COMPUTE WORDS APPENDED
	ADDM	P1,AENTRY+.AEVRS ;ADD TO TOTAL LENGTH OF PROFILE
	MOVNS	P1		;NEGATE
	HRLZS	P1		;PUT IN LH
	HRRI	P1,.AEMIN	;RELATIVE OFFSET WHERE AUXACC DATA BEGINS
	MOVEM	P1,AENTRY+.AEAUX ;SAVE
	POPJ	P,		;RETURN
SUBTTL	Structure routines -- ENTPTH - Create a path


;ARGS:	U.PATH=PATH DESIRED
;	UFDFSN=STR NAME
;CALL WITH:
;	MOVEI	T1,1		;TO CREATE SFDS
;	MOVEI	T1,0		;TO NOT CREATE SFDS
;	PUSHJ	P,ENTPTH
;	RETURN HERE ALWAYS (PTHBUF SET UP FOR PATH. UUO)

ENTPTH:	PUSHJ	P,.SAVE3##	;SAVE P1 AND P2 AND P3
	MOVEI	P3,(T1)		;SAVE FLAG TO CREATE SFDS
	HRRZ	T1,U.PATH+.FXDIR;GET PROG NUMBER
	CAIN	T1,UNIPRG	;IS IT #
	HRRZ	T1,PPN		;YES--CORRECT FOR ACTUAL NO.
	HRRM	T1,U.PATH+.FXDIR;STORE BACK CORRECTED NUMBER
	SETZM	PTHBUF+.PTFCN	;IGNORED ON ENTER
	MOVEI	T1,.PTSCN	;/SCAN:NO
	MOVEM	T1,PTHBUF+.PTSWT;STORE THE SWITCH
	SKIPN	T1,U.PATH+.FXDIR;GET PPN
	MOVE	T1,PPN		;USE TARGET PPN
	MOVEM	T1,PTHBUF+.PTPPN;STORE IN PATH
	MOVEI	P1,PTHBUF+.PTPPN+1	;WHERE PATH GOES
	MOVEI	P2,U.PATH+.FXDIR+2	;WHERE PATH COMES FROM
	HRLI	P1,-<.FXLND-1>		;INIT MAX LOOP CNTR
ENTPT1:	SKIPN	(P2)		;ANOTHER SFD GIVEN?
	POPJ	P,		;NO. DONE
	SETZM	(P1)		;MAKE END OF LIST
	MOVE	T1,(P2)		;GET NAME OF SFD
	JUMPE	P3,ENTPT5	;JUMP IF DOESNT WANT SFDS MADE
	MOVEI	T2,17		;MODE
	MOVE	T3,UFDFSN	;STR NAME
	SETZM	T4		;NO BUFFERS
	OPEN	IOC,T2		;OPEN STR
	  POPJ	P,		;A FATE TOO EVIL TO CONSIDER
	MOVSI	T2,'SFD'	;EXTENSION IS SFD
	SKIPGE	T3,U.SFDP	;/SFDPROT SPECIFIED?
	  SETZM	T3		;NO - ASSUME STANDARD
	ANDI	T3,777		;MASK OUT JUNK
	LSH	T3,^D27		;SLING OVER TO LEFT HALF
	MOVEI	T4,PTHBUF	;PATH POINTER
	ENTER	IOC,T1		;TRY TO ENTER SFD
	  SKIPA			;CAN NOT--SEE WHY
	JRST	ENTPT4		;WE WON.
	HRRZ	T3,T2		;GET ERROR CODE
	CAIE	T3,ERFBM%	;IS FILE BEING MODIFIED?
	CAIN	T3,ERCSD%	;OR DOES IT EXIST YET?
	JRST	ENTPT4		;MODIFIED OR EXITSING -- ALL OK
	CAIE	T3,ERLVL%	;LEVEL ERROR?
	JRST	ENTPT2		;NO
	WARN	SND,<SFDs nested too deeply>,,E.SND
	JRST	ENTPT3		;FINISH UP
ENTPT2:	WARN	SEF,<SFD enter failure >,,E.SEF
ENTPT3:	SETZ	P3,		;DON'T CREATE ANY MORE SFDS
	MOVE	T1,(P2)		;RESTORE SFD NAME
ENTPT4:	CLOSE	IOC,0		;CLOSE OUT THE SFD
ENTPT5:	MOVEM	T1,(P1)		;STORE SFD NAME SO SFDS NEXT CORRECTLY
	ADDI	P2,2		;POINT TO NEXT NAME
	AOBJN	P1,ENTPT1	;LOOP OVER THE PATH
	RELEAS	IOC,		;RELEASE CHANNEL
	POPJ	P,

E.SEF:	PUSH	P,T3		;SAVE ERROR CODE
	MOVEI	T1,"("		;START WITH
	PUSHJ	P,.TCHAR##	; PARANTHESIS
	POP	P,T1		;GET ERROR CODE BACK
	PUSHJ	P,.TOCTW##	;PRINT IT
	MOVEI	T1,")"		;SURROUND ERROR CODE
	PUSHJ	P,.TCHAR##	; PRINT CLOSING PARANTHESIS

E.SND:	MOVEI	T1,[ASCIZ /; file: /]
	PUSHJ	P,.TSTRG##	;PRINT DELIMITING TEXT
	MOVE	T1,UFDFSN	;STRUCTURE NAME
	PUSHJ	P,.TSIXN##	;PRINT IT
	PUSHJ	P,.TCOLN##	;PRINT A COLON
	MOVE	T1,(P2)		;GET SFD NAME
	PUSHJ	P,.TSIXN##	;TYPE THAT OUT TOO
	MOVEI	T1,[ASCIZ /.SFD/] ;WE KNOW THE EXTENSION
	PUSHJ	P,.TSTRG##	;SO TELL THE USER
	MOVEI	T1,[PTHBUF]	;POINT TO PATH. BLOCK
	PJRST	.TDIRB##	;PRINT PATH AND RETURN
SUBTTL	Structure routines -- STRCHK - Check recomp, empty S/L, etc.


STRCHK:	PUSHJ	P,STRNXT	;GET NEXT STR TO RECOMPUTE USAGE ON
	  JRST	STRCH1		;DONE
	PUSHJ	P,UFDRCP	;SET UP UFDSET AND DO IT
	JRST	STRCHK		;LOOP
STRCH1:	TRZN	F,R.ASTR	;ARE ANY STR'S DEFINED IN SEARCH LIST?
	JRST	STRCH2		;NO, WARN SO
	TRNN	F,R.ACRE	;ARE ANY CREATES ALLOWED?
	WARN	SNC,<Search list does not allow creates>
	POPJ	P,		;RETURN
STRCH2:	WARN	SLE,<Search list is empty>
	POPJ	P,		;RETURN
SUBTTL	Structure routines -- STRPUT - Store structure name


STRPUT:	MOVE	T2,T1		;GET STR NAME
	MOVE	T1,[-STRMAX,,QTATAB] ;AOBJN POINTER TO TABLE

STRPU1:	SKIPN	(T1)		;ENTRY IN USE?
	JRST	STRPU2		;NO
	CAME	T2,(T1)		;ALREADY IN TABLE?
	AOBJN	T1,STRPU1	;NO--KEEP CHECKING
	POPJ	P,		;RETURN

STRPU2:	MOVEM	T2,(T1)		;STORE STR NAME
	POPJ	P,		;RETURN
SUBTTL	Structure routines -- STRNXT - Return next structure


STRNXT:	MOVE	T2,[-STRMAX,,QTATAB] ;AOBJN POINTER TO TABLE
	SKIPN	T1,(T2)		;GET AN ENTRY
	AOBJN 	T2,.-1		;LOOP 'TIL WE FIND ONE
	JUMPGE	T2,.POPJ##	;RETURN IF TABLE EMPTY
	SETZM	(T2)		;ZERO OUT ENTRY
	JRST	.POPJ1##	;AND RETURN
SUBTTL	Structure routines -- STRQTA - Check for /QUOTA on structure


STRQTA:	PUSHJ	P,QTASTR	;SEE IF IN QTATAB
	  SKIPL	U.QTA		;/QUOTA?
	AOS	(P)		;SKIP
	POPJ	P,		;RETURN

QTASTR:	MOVE	T2,[-STRMAX,,QTATAB] ;AOBJN POINTER TO TABLLE
	CAME	T1,(T2)		;WANT TO RECOMPUTE ON THIS STR?
	AOBJN	T2,.-1		;LOOP THROUGH EACH ENTRY
	JUMPGE	T2,.POPJ##	;RETURN OF NO MATCH
	SETZM	(T2)		;MARK THIS ONE DONE
	JRST	.POPJ1##	;AND SKIP
SUBTTL	TTY I/O -- TTYPMT - Prompt


TTYPMT:	PUSH	P,T1		;SAVE PROMPT TEXT
	PUSHJ	P,TTYECH	;SET TTY ECHO
	PUSHJ	P,.TNEWL##	;TYPE A CRLF IF NEEDED
	POP	P,T1		;RESTORE T1
	PUSHJ	P,.TSTRG##	;TYPE PROMPT STRING
	PJRST	.TOOUT##	;FORCE OUTPUT
SUBTTL	TTY I/O -- TTYGET - Read a character


;CALLED ONLY FROM SCAN -- MAY CHANGE NO AC'S

TTYGET:	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	TRNE	F,R.PTYJ	;PTY JOB?
	JRST	TTGET2		;YES -- GO INTO TI WAIT
	MOVEI	P2,TTYSLP	;NUMBER OF MINS. TO SLEEP
TTGET1:	SKPINL			;ANYTHING THERE??
	  SKIPA			;NO--LOOP
	JRST	TTGET2		;YES--GO GET IT
	MOVE	P1,[HB.RTL!HB.RWJ!^D60000]
	SKIPE	.JBDDT##	;DEBUGGING?
	HRRI	P1,^D10000	;YES--WAIT 10 SECONDS MAX
	HIBER	P1,		;HIBER FOR 1 MIN.
	  JRST	TTGET2		;TINY MONITOR
	SKPINL
	  SKIPA
	JRST	TTGET2
	SOJG	P2,TTGET1	;LOOP FOR A WHILE
	FATAL	(WFS,<Waiting for >,EF.SIL,E.WFS)

TTGET2:	INCHWL	C		;GET A CHAR. INTO C
	SKIPG	.VQUOT##	;QUOTING WITH CONTROL-V?
	POPJ	P,		;YES--RETURN NOW
	CAIE	C,.CHCNC	;CONTROL-C?
	CAIN	C,.CHCNZ	;OR CONTROL-Z?
	PJRST	RICC		;YES--GO EXIT
	POPJ	P,		;RETURN


E.WFS:	MOVE	T1,HELP		;POINT TO HELP TEXT
	PUSHJ	P,.TSTRG##	;TYPE IT
	MOVEI	T1,[ASCIZ /; please start over/]
	PJRST	.TSTRG##	;TYPE END OF ERROR AND RETURN


; SET TERMINAL ECHO STATUS
TTYNEC:	TDZA	T1,T1		;SET TTY NO ECHO
TTYECH:	MOVEI	T1,1		;SET TTY ECHO
	TLNN	F,FL.BAT	;BATCH PTYS DON'T NEED TO TURN OFF ECHO
	PUSHJ	P,.TECHO##	;TOGGLE ECHO STATUS
	POPJ	P,		;RETURN
SUBTTL	TTY I/O -- TTYPUT - Write a character


;CALLED ONLY FROM SCAN -- MAY CHANGE NO AC'S

TTYPUT:	SKIPL	DETFLG		;DETACHED?
	OUTCHR	T1		;NO, WRITE THIS CHARACTER
	POPJ	P,		;RETURN
SUBTTL	PSI routines -- PSINIT - Initialization


PSINIT:	MOVEI	T1,PSIBLK	;ADDRESS OF INTERRUPT VECTOR
	PIINI.	T1,		;INITIALIZE THE PSI SYSTEM
	  WARN	PIF,<PIINI. UUO failed>

	MOVEI	T1,PSIDET	;ADDRESS OF INTERRUPT SERVICE ROUTINE
	MOVEM	T1,DETINB+.PSVNP;PUT IT IN THE INTERRUPT VECTOR
	MOVX	T1,PS.VDS	;DISMISS ADDITIONAL REQUESTS
	MOVEM	T1,DETINB+.PSVFL; FOR THIS CONDITION

	HRREI	T1,.PCDAT	;GET CONDITION=ATTACH/DETACH
	MOVSI	T2,DETINB-PSIBLK;GET VECTOR OFFSET,,0
	SETZ	T3,		;GET PRIORITY=0
	MOVE	T4,[PS.FON+PS.FAC+T1]
	PISYS.	T4,		;TURN ON PSI, ADD NEW CONDITION
	  WARN	PSF,<PISYS. UUO failed>
	POPJ	P,		;RETURN
SUBTTL	PSI routines -- PSIDET - Handle ATTACH/DETACH conditions


; COME HERE WHEN THE JOB ATTACHES OR DETACHES.  LOCATION DETFLG IS THE
;	.PSVIS (STATUS) WORD IN THE INTERRUPT CELL.  IT WILL BE SET TO
;	MINUS ONE ON A DETACH.

PSIDET:	DEBRK.			;DISMISS THE INTERRUPT
	  FATAL	DBF,<DEBRK. UUO failed>
	POPJ	P,		;NO INTERRUPT IN PROGRESS
SUBTTL	UFD setup -- UFDSET - Call .UFD to mount/setup STR/UFD


;SUBROUTINE TO SET UP A UFD FOR USE
;ARGS:	P1=ADDRESS OF AUXACC DATA
;
;IF T4=-1 ASSUME NO UFD DESIRED - PERFORM OTHER OPERATIONS
;
;CALL	PUSHJ	P,UFDSET
;ERROR	DONT PROCEED (MESSAGE TYPED)
;OK	STR IS IN SEARCH LIST (WARNING MAY BE TYPED)
;
UFDSET:	MOVE	T1,.AUSTR(P1)	;GET STR NAME
	MOVEM	T1,UFDFSN	;SAVE STR NAME
	PUSHJ	P,GETLOK	;GET UFD INTERLOCK
	PUSHJ	P,UFDINI	;SETUP ARG BLOCK
	SETZM	UFDARG+.UFQTR	;NO RESERVED QUOTA
	MOVE	T1,.AULIN(P1)	;FCFS QUOTA
	MOVEM	T1,UFDARG+.UFQTF
	MOVE	T1,.AUOUT(P1)	;LOGGED OUT QUOTA
	MOVEM	T1,UFDARG+.UFQTO
	MOVE	T1,.AURES(P1)	;RESERVED QUOTA
	MOVEM	T1,UFDARG+.UFQTR
	MOVE	T1,.AUBIT(P1)	;STRUCTURE STATUS BITS
	MOVEM	T1,UFDARG+.UFSTS
	MOVE	T1,PPN		;GET THE PPN TO USE
	TLNE	F,FL.GPN	;GENERATE A PROGRAMMER NUMBER?
	TRZ	T1,-1		;YES--START WITH 400000
	MOVEM	T1,UFDARG+.UFPPN ;SET IT
	MOVE	T1,XPDDTM	;UFD EXPIRATION
	MOVEM	T1,UFDARG+.UFDED ;SAVE
	MOVE	T1,U.UFDP	;GET /UFDPROTECTION
	MOVEM	T1,UFDARG+.UFPRO ;SAVE (-1=NONE SPECIFIED)
	MOVEI	T1,UFDTYO	;ERROR TYPER
	MOVEM	T1,UFDARG+.UFTYO ;SAVE
	MOVX	T1,UF.LGI!UF.NLK!UF.AIS!INSVL.(.UFMNT,UF.FNC) ;MOUNT AND
				; SET LOGGED IN (HAVE INTERLOCK)
	TLNE	F,FL.WLD	;WILDCARDED PPN?
	TXZ	T1,UF.AIS	;YES--THEN STR CAN'T BE IN THE S/L
	TLZE	F,FL.GPN	;GENERATE A UNIQUE PROGRAMMER NUMBER?
	TXO	T1,UF.WLD	;YES--TELL UFDSET
	MOVEM	T1,UFDARG+.UFFLG ;SAVE FLAGS
	MOVE	T1,UFDARG+.UFSTR ;GET STR NAME
	PUSHJ	P,STRQTA	;NEED TO RECOMPUTE QUOTAS?
	  TDZA	T2,T2		;NO
	MOVX	T2,UF.ARD	;YES
	IORM	T2,UFDARG+.UFFLG ;SET FLAG (MAYBE)
	MOVEI	T1,UFDARG	;POINT TO ARGS
	PUSHJ	P,.UFD##	;SET IT UP
	  JRST	UFDDON		;ERROR--JUST FINISH UP
	MOVE	T1,UFDARG+.UFFLG ;GET THE FLAG WORD
	TXNE	T1,UF.NDL	;RIPNDL TURNED ON FOR THIS UFD?
	SETOM	UFDNDL		;YES
	TXNE	T1,UF.NUE	;NO UFD EXIST?
	JRST	UFDDON		;YES--NO UFD
	TRO	F,R.ASTR	;NO--GOT A UFD
	MOVE	T1,UFDARG+.UFCDT ;CREATION DATE
	MOVE	T2,UFDARG+.UFCTM ;CREATION TIME
	CAMGE	T1,UFDDAT	;OLD?
	JRST	UFDDON		;YES.
	CAME	T1,UFDDAT	;SAME?
	JRST	UFDEXB		;NO--NEW. UPDATE.
	CAMGE	T2,UFDTIM	;SAME DATE. TIME OLD?
	JRST	UFDDON		;NO.
UFDEXB:	MOVEM	T1,UFDDAT	;STORE NEWEST TIME
	MOVEM	T2,UFDTIM	;AND DATE
UFDDON:	MOVX	T1,UF.WLD	;GET THE WILD PPN BIT
	TDNN	T1,UFDARG+.UFFLG ;WAS IT ON?
	PJRST	CLRLOK		;NO--RELEASE INTERLOCK AND RETURN
	MOVE	T1,UFDARG+.UFPPN ;YES--GET REAL PPN USED
	MOVEM	T1,PPN		;SAVE FOR LOGIN
	MOVEM	T1,.MYPPN##	;SAVE FOR SCAN
	PJRST	CLRLOK		;RELEASE INTERLOCK AND RETURN
SUBTTL	UFD setup -- UFDRCP - Recompute disk usage on random structures


UFDRCP:	MOVEM	T1,UFDFSN	;SAVE STR NAME
	PUSHJ	P,GETLOK	;GET UFD INTERLOCK
	PUSHJ	P,UFDINI	;SETUP ARG BLOCK
	SETOM	UFDARG+.UFQTR	;DON'T
	SETOM	UFDARG+.UFQTF	; SET
	SETOM	UFDARG+.UFQTO	;  QUOTAS
	MOVE	T1,PPN		;GET THE PPN TO USE
	MOVEM	T1,UFDARG+.UFPPN ;SET IT
	MOVE	T1,U.UFDP	;GET /UFDPROTECTION
	MOVEM	T1,UFDARG+.UFPRO ;SAVE (-1=NONE SPECIFIED)
	MOVEI	T1,UFDTYO	;ERROR TYPER
	MOVEM	T1,UFDARG+.UFTYO ;SAVE
	MOVX	T1,UF.NLK!UF.ARD!INSVL.(.UFRDU,UF.FNC) ;ALWAYS RECOMPUTE
	MOVEM	T1,UFDARG+.UFFLG ;SAVE FLAGS
	MOVEI	T1,UFDARG	;POINT TO ARGS
	PUSHJ	P,.UFD##	;SET IT UP
	  JRST	UFDDON		;ERROR--JUST FINISH UP
	PJRST	CLRLOK		;RELEASE INTERLOCK AND RETURN
SUBTTL	UFD setup -- UFDDMO - Dismount a structure


UFDDMO:	PUSH	P,T1		;SAVE THE FLAG BITS
	PUSHJ	P,UFDINI	;SETUP ARG BLOCK
	POP	P,T1		;RESTORE FLAG BITS
	IORX	T1,UF.LGO!UF.TSP!INSVL.(.UFDMO,UF.FNC) ;DISMOUNT
	MOVEM	T1,UFDARG+.UFFLG ;SAVE FLAGS
	SETOM	UFDARG+.UFPPN	;DEFAULT PPN
	SETOM	UFDARG+.UFJOB	;DEFAULT JOB
	SETOM	UFDARG+.UFQTR	;DON'T
	SETOM	UFDARG+.UFQTF	; SET
	SETOM	UFDARG+.UFQTO	;  QUOTAS
	SETOM	UFDARG+.UFPRO	;DON'T CHANGE UFD PROTECTION
	MOVEI	T1,UFDTYO	;ERROR TYPER
	MOVEM	T1,UFDARG+.UFTYO ;SAVE
	MOVEI	T1,UFDARG	;POINT TO ARGS
	PJRST	.UFD##		;SET IT UP
SUBTTL	UFD setup -- UFDTYO - Handle typeout of errors from .UFD


UFDTYO:	SKIPE	.JBDDT		;DEBUGGING?
	JRST	UFDTY1		;YES, BE VERBOSE
	HRRZ	T1,UFDARG+.UFPFX ;GET PREFIX
	CAIE	T1,'MNT'	;MOUNT MSG?
	CAIN	T1,'AJL'	;ADD S/L MSG?
	POPJ	P,		;YES--TOO VERBOSE
	CAIE	T1,'DMO'	;DISMOUNT MSG?
	CAIN	T1,'NUC'	;NO UFD CREATED MSG?
	POPJ	P,		;YES--WE DONT WANT EITHER
	MOVE	T2,COMIDX	;GET THE COMMAND INDEX
	TXNE	T2,CM.KJB	;KJOB COMMAND
	CAIE	T1,'QTA'	; AND QUOTA MSG?
	TRNA			;NO - PROCEED
	POPJ	P,		;YES - SKIP IT
	CAIN	T1,'RDU'	;RECOMPUTING?
	AOSN	RDUFLG		;YES--ALREADY SEEN IT?
	CAIA			;OK
	POPJ	P,		;YES--ONCE IS ENOUGH
UFDTY1:	HLRZ	T1,UFDARG+.UFPFX ;GET ERROR CHAR
	PUSHJ	P,.TCHAR##	;TYPE
	HRRZ	T1,UFDARG+.UFPFX ;ERROR PREFIX
	HRLI	T1,'LGN'	;PREFIX
	PUSHJ	P,.TSIXN##	;TYPE
	PUSHJ	P,.TSPAC##	;SPACE OVER
	MOVE	T1,UFDARG+.UFTXT ;ADDESS OF TEXT
	PUSHJ	P,.TSTRG##	;TYPE
	HLRZ	T1,UFDARG+.UFPFX ;ERROR CHAR
	CAIN	T1,"["		;INFORMATIONAL?
	PUSHJ	P,.TRBRK##	;YES--CLOSE IT
	PUSHJ	P,.TCRLF##	;CRLF
	POPJ	P,		;AND RETURN
SUBTTL	UFD setup -- UFDINI - Initialize block


UFDINI:	MOVE	T1,[UFDARG,,UFDARG+1] ;SETUP BLT
	SETZM	UFDARG		;CLEAR FIRST
	BLT	T1,UFDARG+.UFSIZ-1 ;ZERO THEM ALL
	MOVE	T1,UFDFSN	;GET STR NAME
	MOVEM	T1,UFDARG+.UFSTR ;SAVE STRUCTURE
	SETOM	UFDARG+.UFPPN	;DEFAULT PPN
	SETOM	UFDARG+.UFJOB	;AND JOB
	POPJ	P,		;RETURN
SUBTTL	UFD setup -- ADDSTR - Add a structure to search list


ADDSTR:	MOVE	T1,.AUSTR(P1)	;GET STR NAME
	MOVEM	T1,UFDFSN	;SAVE IT
	PUSHJ	P,UFDINI	;SET UP BLOCK
	MOVEI	T1,UFDTYO	;GET TYPER
	MOVEM	T1,UFDARG+.UFTYO ;SAVE
	MOVX	T1,.UFAJL	;ADD TO SEARCH LIST
	DPB	T1,[POINTR UFDARG+.UFFLG,UF.FNC] ;STORE
	MOVEI	T1,UFDARG	;POINT TO ARGS
	PUSHJ	P,.UFD##	;ADD THE STR
	  JFCL			;DONT CARE
	POPJ	P,		;AND RETURN
SUBTTL	UFD setup -- GETLOK - Get UFD interlock


GETLOK:	TLNE	F,FL.WLD	;WILDCARD PROGRAMMER NUMBER?
	POPJ	P,		;YES - NO NEED TO GET INTERLOCK
	PUSHJ	P,UFDINI	;SETUP BLOCK
	MOVSI	T1,UFDSEC	;SECOND TO WAIT FOR INTERLOCK
	SKIPE	.JBDDT##	;DEBUGGING?
	MOVEI	T1,1		;DON'T WAIT SO LONG
	TLNE	F,FL.BAT	;BATCH?
	LSH	T1,1		;YES--TWICE AS TOUGH
	HRRI	T1,^D10		;MESSAGE AFTER 10 SECONDS
	MOVEM	T1,UFDARG+.UFLOK ;SAVE LOCK TIMER
	MOVEI	T1,LOKTYO	;TYPER
	MOVEM	T1,UFDARG+.UFTYO ;SET
	MOVX	T1,.UFSUI	;SET UFD INTERLOCK
	DPB	T1,[POINTR UFDARG+.UFFLG,UF.FNC] ;STORE
	MOVEI	T1,UFDARG	;POINT TO BLOCK
	SETOM	CCWAIT		;DONT ALLOW ^C
	PUSHJ	P,.UFD##	;GET THE INTERLOCK
	  TLNN	F,FL.BAT	;BATCH?
	POPJ	P,		;NO--GIVE IN AND GET HIM GO
	REQUE	UBT,<UFD interlock busy too long> ;YES--TRY AGAIN LATER

LOKTYO:	MOVE	T1,UFDARG+.UFERR ;GET ERROR CODE
	CAIN	T1,UFUBT%	;BUSY TOO LONG?
	POPJ	P,		;YES--NO MESSAGE
	PJRST	UFDTYO		;ELSE TYPE THE STANDARD WAY
SUBTTL	UFD setup -- CLRLOK - Clear the UFD interlock


CLRLOK:	TLNE	F,FL.WLD	;WILDCARD PROGRAMMER NUMBER?
	POPJ	P,		;YES - NO INTERLOCK TO CLEAR
	PUSHJ	P,UFDINI	;SETUP BLOCK
	MOVX	T1,.UFCUI	;CLEAR INTERLOCK
	DPB	T1,[POINTR UFDARG+.UFFLG,UF.FNC] ;STORE CODE
	MOVEI	T1,UFDARG	;POINT TO ARGS
	PUSHJ	P,.UFD##	;CLEAR THE INTERLOCK
	  JFCL			;DONT CARE
	PJRST	CTLCOK		;CHECK/CLEAR ^C
SUBTTL	Usage entry creation -- USGATT - Attach


USGATT:	TLNE	F,FL.BYP	;BYPASS THE ACCOUNTING SYSTEM?
	POPJ	P,		;YES
	PUSHJ	P,SETTNL	;FIND TERMINAL DESIGNATOR, LINE NO., NODE NAME
	MOVEI	T1,UA$TJN+1	;LENGTH OF DATA BLOCK
	MOVEI	T2,UGATT$	;MAKE AN ENTRY
	PUSHJ	P,USGQUE	;LOAD ACCOUNTING SPECIFIC DATA IN THE UUO BLOCK
	PUSH	P,T2		;SAVE UUO AC FOR LATER
	MOVEI	T2,UGATT$	;ATTACH MESSAGE TYPE
	MOVEM	T2,UA$TYP(T1)
	MOVE	T2,[SIXBIT /LOGIN/]
	MOVEM	T2,UA$PRG(T1)	;PROGRAM NAME
	MOVE	T2,.JBVER	;VERSION NUMBER OF LOGIN
	MOVEM	T2,UA$VER(T1)
	MOVE	T2,THSJOB	;GET THE JOB NUMBER
	MOVE	T2,MONLNO	;LINE NUMBER
	MOVEM	T2,UA$LIN(T1)	;STORE THE LINE NUMBER
	MOVE	T2,MONNOD	;NODE NAME
	MOVEM	T2,UA$NOD(T1)
	MOVE	T2,MONTDE	;TERMINAL DESIGNATOR
	MOVEM	T2,UA$TDE(T1)
	MOVE	T2,ATTJBN	;GET TARGET JOB
	MOVEM	T2,UA$TJN(T1)	
	POP	P,T1		;GET UUO AC
	QUEUE.	T1,		;CREATE SESSION ENTRY
	  PJRST	QUEERR		;REPORT ERROR
	POPJ	P,		;RETURN
SUBTTL	Usage entry creation -- USGLOG - Login


USGLOG:	TLNE	F,FL.BYP	;BYPASS THE ACCOUNTING SYSTEM?
	POPJ	P,		;YES
	PUSHJ	P,SETTNL	;FIND TERMINAL DESIGNATOR, LINE NO., NODE NAME
	MOVEI	T1,UL$TDE+1	;LENGTH OF DATA BLOCK
	MOVEI	T2,UGLGN$	;MAKE AN ENTRY
	PUSHJ	P,USGQUE	;LOAD ACCOUNTING SPECIFIC DATA IN THE UUO BLOCK
	PUSH	P,T2		;SAVE UUO AC FOR LATER
	MOVEI	T2,UGLGN$	;MESSAGE TYPE
	MOVEM	T2,UL$TYP(T1)
	MOVE	T2,[SIXBIT /LOGIN/]
	MOVEM	T2,UL$PRG(T1)	;PROGRAM NAME
	MOVE	T2,.JBVER	;VERSION NUMBER
	MOVEM	T2,UL$VER(T1)
	HRLI	T2,U.ACTS	;ACCOUNT STRING
	HRRI	T2,UL$ACT(T1)
	MOVE	T3,U.ACTS	;GET FIRST WORD
	AOSE	T3		;SKIP IF NONE GIVEN
	BLT	T2,UL$ACE(T1)
	PUSH	P,T1		;SAVE T1
	PUSHJ	P,.GTNOW##	;GET CURRENT UDT
	POP	P,T2		;RESTORE BLOCK POINTER
	EXCH	T1,T2		;SWAP
	MOVEM	T2,UL$BEG(T1)
	MOVEI	T2,ULJTI$	;DEFAULT TO A TIMESHARING LOGIN
	MOVEM	T2,UL$JTY(T2)
	TLNN	F,FL.BAT	;IS THIS A BATCH JOB?
	JRST	USGLO1		;NO
	MOVEI	T2,ULJBA$	;YES. INDICATE A BATCH JOB
	MOVEM	T2,UL$JTY(T1)
	MOVE	T2,U.BSEQ	;BATCH SEQUENCE NUMBER
	MOVEM	T2,UL$BSQ(T1)
	MOVE	T2,U.BNAM	;BATCH JOB NAME
	MOVEM	T2,UL$BNM(T1)
	MOVE	T2,U.BREQ	;BATCH REQUEST ID
	MOVEM	T2,UL$BRI(T1)
USGLO1:	HRLI	T2,U.RMRK	;SESSION REMARK
	HRRI	T2,UL$RMK(T1)
	MOVE	T3,U.RMRK	;GET FIRST WORD
	AOSE	T3		;SKIP IF NONE GIVEN
	BLT	T2,UL$RME(T1)
	LDB	T2,[POINTR AENTRY+.AESCD,AE.SCD]
	MOVEM	T2,UL$CLS(T1)	;SCHEDULING CLASS
	MOVE	T2,PPN		;USER'S PPN
	MOVEM	T2,UL$PPN(T1)
	MOVE	T2,NAME
	MOVEM	T2,UL$NM1(T1)
	MOVE	T2,NAME2
	MOVEM	T2,UL$NM2(T1)
	MOVE	T2,THSJOB	;GET THE JOB NUMBER
	MOVE	T2,MONLNO	;LINE NUMBER
	MOVEM	T2,UL$LIN(T1)	;STORE THE LINE NUMBER
	MOVE	T2,MONNOD	;NODE NAME
	MOVEM	T2,UL$NOD(T1)
	MOVE	T2,MONTDE	;LINE DESIGNATOR
	MOVEM	T2,UL$TDE(T1)
	POP	P,T1		;GET UUO AC
	QUEUE.	T1,		;CREATE SESSION ENTRY
	  PJRST	QUEERR		;REPORT ERROR
	POPJ	P,		;RETURN
SUBTTL	Usage entry creation -- USGQUE - Set up QUEUE. UUO blocks


; LOAD THE QUEUE. UUO BLOCK WITH ACCOUNTING-FUNCTION SPECIFIC DATA
; CALL:	MOVE	T1, DATA BLOCK LENGTH
;	MOVE	T2, ACCOUNTING SUB-FUNCTION CODE
;	PUSHJ	P,USGQUE
;	<RETURN>
;
; ON RETURN, THE QUEUE. UUO BLOCK, RESPONSE BLOCK, AND DATA BLOCK
; WILL BE ZEROED AND FILLED IN WITH THE APPROPRIATE DATA.  T1 WILL
; POINT TO THE DATA BLOCK AND T2 WILL CONTAIN THE UUO AC TO BE USED
; WITH THE QUEUE. UUO.

USGQUE:	PUSH	P,T1		;SAVE DATA BLOCK LENGTH
	PUSH	P,T2		;SAVE SUB-FUNCTION CODE
	MOVEI	T1,.QUMAE	;ACCOUNTING FUNCTION
	MOVEI	T2,0		;CENTRAL STATION OPR
	MOVE	T3,[RSPLEN,,RSPBLK] ;RESPONSE BLOCK POINTER
	MOVEI	T4,USGTIM	;TIMEOUT
	PUSHJ	P,QUEINI	;SET UP QUEUE. UUO ARGUMENT BLOCK
	MOVE	T2,[QA.IMM!<1,,.QBAFN>] ;BLOCK TYPE (ACCOUNTING FUNCTION)
	POP	P,T3		;GET SUB-FUNCTION CODE BACK
	DMOVEM	T2,(T1)		;SAVE WORD PAIR
	ADDI	T1,2		;ADVANCE POINTER
	POP	P,T2		;GET DATA BLOCK LENGTH
	HRLZS	T2		;PUT IN LH
	HRRI	T2,.QBAET	;BLOCK TYPE (ACCOUNTING DATA)
	MOVEI	T3,DATBLK	;DATA BLOCK ADDRESS
	DMOVEM	T2,(T1)
	MOVSI	T2,-QUEBLK+2(T1) ;COMPUTE LENGTH OF QUEUE. UUO BLOCK
	HRRI	T2,QUEBLK	;SET UP UUO AC
	MOVEI	T1,DATBLK	;NOW POINT TO DATA BLOCK
	POPJ	P,		;AND RETURN
SUBTTL	Usage entry creation -- USGSES - Session


USGSES:	TLNE	F,FL.BYP	;BYPASS THE ACCOUNTING SYSTEM?
	POPJ	P,		;YES
	MOVEI	T1,US$RME+1	;LENGTH OF DATA BLOCK
	MOVEI	T2,UGSES$	;MAKE AN ENTRY
	PUSHJ	P,USGQUE	;LOAD ACCOUNTING SPECIFIC DATA IN THE UUO BLOCK
	PUSH	P,T2		;SAVE UUO AC FOR LATER
	MOVEI	T2,UGSES$	;MESSAGE TYPE
	MOVEM	T2,US$TYP(T1)
	MOVE	T2,[SIXBIT /LOGIN/]
	MOVEM	T2,US$PRG(T1)	;PROGRAM NAME
	MOVE	T2,.JBVER	;VERSION NUMBER
	MOVEM	T2,US$VER(T1)
	HRLI	T2,U.ACTS	;NEW ACCOUNT STRING
	HRRI	T2,US$ACT(T1)
	MOVE	T3,U.ACTS	;GET FIRST WORD
	AOSE	T3		;SKIP IF NONE GIVEN
	BLT	T2,US$ACE(T1)
	PUSH	P,T1		;SAVE T1
	PUSHJ	P,.GTNOW##	;GET CURRENT UDT
	POP	P,T2		;RESTORE BLOCK POINTER
	EXCH	T1,T2		;SWAP
	MOVEM	T2,US$BEG(T1)	;SESSION START DATE/TIME
	HRLI	T2,U.RMRK	;NEW SESSION REMARK
	HRRI	T2,US$RMK(T1)
	MOVE	T3,U.RMRK	;GET FIRST WORD
	AOSE	T3		;SKIPE IF NONE GIVEN
	BLT	T2,US$RME(T1)
	POP	P,T1		;GET UUO AC
	QUEUE.	T1,		;CREATE SESSION ENTRY
	  PJRST	QUEERR		;REPORT ERROR
	POPJ	P,		;RETURN
SUBTTL	Usage entry creation -- USGVAL - Validate an account string


USGVAL:	TLNE	F,FL.BYP	;BYPASS THE ACCOUNTING SYSTEM?
	POPJ	P,		;YES
	MOVEI	T1,UV$ACE+1	;LENGTH OF DATA BLOCK
	MOVEI	T2,UGVAL$	;DO VALIDATION
	PUSHJ	P,USGQUE	;LOAD ACCOUNTING SPECIFIC DATA IN THE UUO BLOCK
	PUSH	P,T2		;SAVE UUO AC FOR LATER
	MOVEI	T2,UGVAL$	;FUNCTION CODE
	MOVEM	T2,-1(T1)	;FUDGE HERE
	MOVEM	T2,UV$TYP(T1)	;PUT THE MESSAGE TYPE IN THE IPCF SEND
	MOVE	T2,PPN		;GET THE PPN TO BE VALIDATED
	MOVEM	T2,UV$PPN(T1)
	HRLI	T2,U.ACTS	;WHERE TO BLT THE ACCOUNT FROM
	HRRI	T2,UV$ACT(T1)	;WHERE TO BLT THE ACCOUNT TO
	MOVE	T3,U.ACTS	;GET FIRST WORD
	AOSE	T3		;SKIP IF NONE GIVEN
	BLT	T2,UV$ACE(T1)
	POP	P,T1		;GET UUO AC
	QUEUE.	T1,		;CREATE SESSION ENTRY
	  PJRST	QUEERR		;REPORT ERROR
	MOVEI	T1,RSPBLK	;POINT TO THE RESPONSE BLOCK
	SKIPN	UC$ACT(T1)	;DO WE HAVE AN ACCOUNT STRING?
	POPJ	P,		;NO--USE WHAT WE HAD FIRST
	HRLI	T2,UC$ACT(T1)	;SETUP BLT
	HRRI	T2,U.ACTS	;INTO OUR ACCOUNT STRING
	BLT	T2,U.ACTS+7	;COPY IT OVER
	POPJ	P,		;AND RETURN WITH NEW ACCOUNT STRING
SUBTTL	WTO routines -- WTOINI - Initialize WTO message


WTOINI:	PUSH	P,T1		;SAVE "TYPE" TEXT (-- LOGIN FOO --)
	MOVE	T1,[Z.BWTO,,Z.BWTO+1] ;SET UP BLT
	SETZM	Z.BWTO		;CLEAR FIRST WORD
	BLT	T1,Z.EWTO-1	;CLEAR ENTIRE BLOCK
	POP	P,WTOTYP	;SAVE
	MOVE	T1,[POINT 7,WTOBFO] ;BYTE POINTER
	MOVEM	T1,WTOPTR	;SAVE
	MOVEI	T1,WTOCHN	;BYTE COUNT
	MOVEM	T1,WTOCTR	;SAVE
	MOVEI	T1,WTOTYO	;SPECIAL TYPEOUT ROUTINE
	PUSHJ	P,.TYOCH##	;TELL SCAN
	MOVEM	T1,WTOSAV	;SAVE OLD TYPER
	POPJ	P,		;RETURN


WTOTYO:	SOSLE	WTOCTR		;COUNT CHARACTERS
	IDPB	T1,WTOPTR	;STORE
	POPJ	P,		;RETURN

SUBTTL	WTO routines -- WTOSND - Send a WTO to OPR


WTOSND:	SKIPE	.JBDDT##	;DEBUGGING?
	PJRST	WTOCTY		;YES--DON'T BOTHER THE OPERATOR
	MOVE	T1,WTOSAV	;GET SAVED CHARACTER TYPER
	PUSHJ	P,.TYOCH##	;UPDATE SCAN
	MOVX	T1,.QUWTO	;FUNCTION CODE
	DPB	T1,[POINTR WTOBLK+.QUFNC,QF.FNC] ;STORE
	SETOM	WTOBLK+.QUNOD	;CENTRAL SITE OPR
	SETZM	WTOBLK+.QURSP	;NO RESPONCE BLOCK
	HLLZ	T1,WTOTYP	;GET "TYPE" LENGTH
	HRRI	T1,.QBTYP	;AND BLOCK CODE
	MOVEM	T1,WTOBLK+.QUARG
	HRRZ	T1,WTOTYP	;GET ADDRESS OF TEXT
	MOVEM	T1,WTOBLK+.QUARV
	MOVX	T1,<INSVL.(<WTOCHN/5>,QA.LEN)!INSVL.(.QBMSG,QA.TYP)>
	MOVEM	T1,WTOBLK+.QUARG+2
	MOVEI	T1,WTOBFO	;GET TEXT BUFFER ADDRESS
	MOVEM	T1,WTOBLK+.QUARV+2
	MOVE	T1,[WTOLEN,,WTOBLK] ;SET UP UUO ACS
	QUEUE.	T1,		;SEND TO OPR
	  SKIPA	T1,WTOSAV	;FAILED--MUST RESET CHARACTER STICKER
	JRST	.POPJ1##	;RETURN
	PUSHJ	P,.TYOCH##	;TELL SCAN
;	PJRST	WTOCTY		;REPORT ON THE CTY
SUBTTL	WTO routines -- WTOCTY - Send text to the CTY if OPR not available


WTOCTY:	MOVEI	T1,WTOTYO	;SPECIAL TYPEOUT ROUTINE
	PUSHJ	P,.TYOCH##	;TELL SCAN
	MOVEM	T1,WTOSAV	;SAVE FOR LATER
	PUSHJ	P,.TCRLF##	;APPEND A CRLF TO THE OPR BUFFER
	MOVE	T1,[POINT 7,WTOBFC] ;BYTE POINTER
	MOVEM	T1,WTOPTR	;SAVE
	MOVEI	T1,WTOCHN	;BYTE COUNT
	MOVEM	T1,WTOCTR	;SAVE
	PUSHJ	P,.TCRLF##	;START WITH A CRLF
	MOVEI	T1,[ASCIZ /-- /]
	PUSHJ	P,.TSTRG##	;STORE IN CTY BUFFER
	HRRZ	T1,WTOTYP	;POINT TO "TYPE" TEXT
	PUSHJ	P,.TSTRG##	;STORE IN CTY BUFFER
	MOVEI	T1,[ASCIZ / at /]
	PUSHJ	P,.TSTRG##	;STORE TEXT
	PUSHJ	P,.GTNOW##	;GET CURRENT UDT
	PUSHJ	P,.TDTTM##	;STORE IN BUFFER
	MOVEI	T1,[ASCIZ / --/]
	PUSHJ	P,.TSTRG##	;STORE TRAILING DASHES
	PUSHJ	P,.TCRLF##	;APPEND A CRLF
	MOVE	T1,WTOSAV	;GET CALLER'S SAVED CHARACTER TYPER
	PUSHJ	P,.TYOCH##	;TELL SCAN
	MOVE	T1,[3,,T2]	;SET UP UUO AC
	MOVEI	T2,.TOOUS	;FUNCTION CODE
	MOVSI	T3,'CTY'	;DEVICE
	SKIPN	.JBDDT##	;DON'T BOTHER THE OPERATOR IF DEBUGGING
	IONDX.	T3,UU.PHY	;GET UDX
	  MOVNI	T3,1		;-1 FOR OUR TERMINAL
	MOVEI	T4,WTOBFC	;POINT TO CTY BUFFER
	TRMOP.	T1,		;SEND TO THE CTY
	  POPJ	P,		;CAN DO NO MORE AT THIS POINT
	MOVEI	T4,WTOBFO	;POINT TO OPR BUFFER
	TRMOP.	T1,		;SEND TO THE CTY
	  JFCL			;IGNORE ERRORS AT THIS POINT
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- ACCLOG - Perform LOGMAX and BATMAX checking


ACCLOG:	MOVSI	T1,(AC.MAX)	;ALWAYS DO LOGMAX CHECKING
	TLNN	F,FL.BAT	;BATCH?
	JRST	ACCLO1		;NO
	MOVE	T2,[F%MPB&<-1,,0>!.GTFET] ;CHECK MPB SUPPORT
	GETTAB	T2,		;ASK MONITOR
	  MOVEI	T2,0		;ASSUME NOT
	TRNE	T2,F%MPB&<0,,-1> ;MPB MONITOR?
	TLO	T1,(AC.BMX)	;YES--DO BATMAX CHECKING
ACCLO1:	ACCLG.	T1,		;SEE IF WE CAN GET ACCESS
	  SKIPA	T2,T1		;FAILED--COPY ERROR CODE
	POPJ	P,
	CAIL	T2,ACLLEN	;KNOWN ERROR CODE?
	MOVEI	T2,0		;NO
	JRST	ACLTAB(T2)	;BARF APPROPRIATELY

ACLTAB:	STOP	UAE,<Unknown ACCLG. UUO error >,EF.WTO!EF.SIL,E.UAE
	REQUE	JCE,<Job capacity exceeded>,EF.SIL
	REQUE	BJC,<Batch job capacity exceeded>,EF.SIL
	STOP	ARG,<Illegal argument detected>,EF.WTO!EF.SIL
	STOP	JLG,<Decrement tried with JLOG on>,EF.WTO!EF.SIL
	STOP	DCR,<Decrement tried with PD.LGN on>,EF.WTO!EF.SIL
ACLLEN==.-ACLTAB

E.UAE:	PUSH	P,T1		;SAVE ERROR CODE
	MOVEI	T1,"("		;OPEN PARANTHESIS
	PUSHJ	P,.TCHAR##	;PRINT IT
	POP	P,T1		;GET ERROR CODE BACK
	PUSHJ	P,.TOCTW##	;PRINT IT
	MOVEI	T1,")"		;CLOSE PARANTHESIS
	PJRST	.TCHAR##	;PRINT IT AND RETURN
SUBTTL	Miscellaneous routines -- ATTJOB - ATTACH the job


ATTJOB:	INFO	ATJ,<Attaching to job >,,E.ATJ
	MOVE	T1,THSJOB	;LOAD OUR CURRENT JOB NUMBER
	TLNE	F,FL.LGN	;ARE WE LOGGED IN?
	INFO	DJB,<Detaching job >,,.TDECW##
	MOVEI	T1,CRLFPD	;PRINT A DOT
	MOVE	T2,ATTUAC	;GET ATTACH UUO AC
	TXNE	T2,AT.UMM	;MONITOR MODE ATTACH?
	PUSHJ	P,.TSTRG##	;MAKE IT LOOK GOOD
	PUSHJ	P,.TOOUT##	;FORCE OUTPUT
	MOVE	T1,ATTUAC	;SET UP UUO AC
	ATTACH	T1,		;ATTACH JOB TO TTY
	  JRST	NOATT		;WOOPS, COULDNT!
	POPJ	P,		;RETURN


E.ATJ:	MOVE	T1,ATTJBN	;GET TARGET JOB
	PUSHJ	P,.TDECW##	;PRINT IT
	PUSHJ	P,.TSPAC##	;SPACE OVER
	MOVE	T1,PPN		;GET TARGET PPN
	PUSHJ	P,.TPPNW##	;PRINT IT
	MOVE	T1,ATTSTS	;GET JOBSTS FOR TARGET JOB
	TXNN	T1,JB.URN	;RUNNING?
	JRST	E.ATJ1		;NO
	HRLZ	T1,ATTJBN	;GET TARGET JOB
	HRRI	T1,.GTPRG	;WANT PROGRAM NAME
	GETTAB	T1,		;ASK MONITOR
	  SETZ	T1,		;NOT TODAY
	JUMPE	T1,E.ATJ1	;DON'T TYPE "RUNNING JUNK"
	PUSH	P,T1		;SAVE PROGRAM NAME
	MOVEI	T1,[ASCIZ/ running /];GET TEXT
	PUSHJ	P,.TSTRG##	;TYPE
	POP	P,T1		;GET PROGRAM NAME BACK
	PUSHJ	P,.TSIXN##	;TYPE PROGRAM NAME
E.ATJ1:	MOVEI	T1,[ASCIZ/ in user mode/]
	MOVE	T2,ATTUAC	;GET ATTACH UUO AC
	TXNE	T2,AT.UMM	;MONITOR MODE?
	MOVEI	T1,[ASCIZ/ in monitor mode/]
	PJRST	.TSTRG##
SUBTTL	Miscellaneous routines -- ATTLGL - Check for a legal ATTACH


ATTLGL:	MOVEI	T1,.GTPPN	;GETTAB ARGUMENT
	HRL	T1,ATTJBN	;GET TARGET PPN
	GETTAB	T1,		;ASK MONITOR FOR PPN
	  PJRST	NOATT		;CAN'T GET IT
	CAME	T1,PPN		;SAME PPN?
	PJRST	NOATT		;NO
	HRRZ	T1,ATTJBN	;GET TARGET JOB NUMBER
	TRMNO.	T1,		;SEE OF SOMEONE ALREADY THERE
	  SKIPA			;OK IF JOB IS DETACHED
	PJRST	NOATT		;DON'T DETACH JOB--SQUATTER'S RIGHTS
	MOVN	T1,ATTJBN	;DO MORE CHECKING ON JOB
	JOBSTS	T1,		;GET JOB STATUS
	  PJRST	NOATT		;NOT THERE??
	JUMPGE	T1,.POPJ##	;JUMP IF JNA NO SET
	MOVNI	T1,1		;-1 FOR OUR TTY
	GETLCH	T1		;READ TTY BITS (REDUNDANT SUPER-PARANOID CALL)
	CAMN	T1,[-1]		;ARE WE DETACHED?
	PJRST	NOATT		;YES--THEN DON'T ALLOW ATTACH TO HAPPEN
	TRZ	T1,.UXTRM	;STRIP OFF UDX BIT
	HRL	T1,ATTJBN	;GET TARGET JOB NUMBER
	MOVSM	T1,ATTUAC	;SAVE AS LINE#,,JOB#
	HRLZ	T2,ATTJBN	;GET JOB NUMBER
	HRRI	T2,.GTST2	;GETTAB TABLE NUMBER
	GETTAB	T2,		;GET SECOND JOB STATUS WORD
	  SETZ	T2,		;??
	MOVN	T3,ATTJBN	;GET -TARGET JOB NUMBER
	JOBSTS	T3,		;READ JOB STATUS
	  JRST	NOATT		;SHOULDN'T HAPPEN
	MOVEM	T3,ATTSTS	;SAVE RESULT
	TRNN	T2,1B26		;ALLOW JOB MONITOR LEVEL?
	SKIPE	U.MODE		;USER REQUESTED MONITOR MODE?
	TXNN	T3,JB.URN	;RUNNING?
	SKIPA	T3,[AT.UMM]	;NO--GIVE HIM A DOT
	MOVX	T3,AT.UUM	;INDICATE USER MODE
	IORM	T3,ATTUAC	;COMPLETE ATTACH UUO AC
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- AVLCHK - Check system availability


AVLCHK:	MOVE	T1,STATES	;GET STATES WORD
	TXNE	T1,ST%NOP	;IS THERE AN OPERATOR?
	INFO	NOC,<No operator coverage>
	TLNE	F,L.OPR!L.SOPR	;OPR OR HIS SUB?
	TLNE	F,FL.BAT	;AND NON-BATCH JOB?
	SKIPA			;NO--CONTINUE
	POPJ	P,		;SYSTEM AVAILABLE
	TXNE	T1,ST%NLG	;NO LOGIN?
	STOP	SNA,<System not available>
	MOVE	T2,TTBITS	;GET GETLCH BITS
	TXNE	T2,GL.DSL!GL.REM ;NON-LOCAL?
	TXNN	T1,ST%NRL	;AND STATES SAYS LOCAL ONLY?
	SKIPA	T2,COMIDX	;NO--GET COMMAND BITS
	REQUE	NRU,<No remote users>
	TLNN	F,FL.BAT	;BATCH?
	TXNE	T2,CM.ATT	;ATTACH COMMAND?
	POPJ	P,		;YES--DONE
	TXNE	T1,ST%BON	;BATCH ONLY ONES ALLOWED?
	FATAL	OBU,<Only batch users may LOGIN>
	POPJ	P,		;SYSTEM AVAILABLE TO THIS USER
SUBTTL	Miscellaneous routines -- BANNER - Print LOGIN banner


BANNER:	MOVEI	T1,[ASCIZ/Job /]
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	MOVE	T1,THSJOB	;GET JOB NUMBER
	PUSHJ	P,.TDECW##	;PRINT IT
	PUSHJ	P,.TSPAC##	;SPACE OVER
	PUSHJ	P,.TSPAC##	;AGAIN
	MOVSI	T3,-5		;AOBJN POINTER
BANNE1:	HRLZ	T1,T3		;GET OFFSET
	ADD	T1,[%CNFG0]	;FORM GETTAB ARGUMENT
	GETTAB	T1,		;GET NEXT WORD OF MONITOR NAME
	  SETZ	T1,		;SHOULDN'T HAPPEN
	MOVEM	T1,CONFIG(T3)	;SAVE WORD
	AOBJN	T3,BANNE1	;LOOP FOR ENTIRE MONITOR NAME
	MOVEI	T1,CONFIG	;POINT TO NAME
	PUSHJ	P,.TSTRG##	;PRINT IT
	PUSHJ	P,.TSPAC##	;SPACE OVER
	PUSHJ	P,.TSPAC##	;AGAIN
	MOVE	T1,MYTTY	;GET TTY NAME
	PUSHJ	P,.TSIXN##	;PRINT IT
	PJRST	.TCRLF##	;PRINT A CRLF AND RETURN
SUBTTL	Miscellaneous routines -- CHRTRN - Translate 8-bit ASCII strings


; TRANSLATE 8-BIT ASCII STRINGS TO 6-BIT OR 7-BIT STRINGS
; CALL:	MOVE	T1, ADDRESS OF 8-BIT STRING
;	MOVE	T2, BYTE POINTER TO DESTINATION
;	MOVE	T3, # CHARACTERS
;	PUSHJ	P,CHRTRN

CHRTRN:	MOVE	T4,[TRNBLK,,TRNBLK+1] ;SET UP BLT
	SETZM	TRNBLK		;CLEAR FIRST WORD
	BLT	T4,TRNBLK+.CHDB2 ;CLEAR OUT BLOCK
	MOVX	T4,CH.FBR!CH.RAI ;GET BITS
	TXO	T4,CH.IGN	;*** TEMP ***
	MOVEM	T4,TRNBLK+.CHFLG ;DO FALLBACK REPRESENTATION AND RAISE CASE
	HRLI	T1,(POINT 8)	;MAKE B.P.
	MOVEM	T1,TRNBLK+.CHSB1 ;SAVE SOURCE B.P.
	MOVEM	T2,TRNBLK+.CHDB1 ;AND DEST. B.P.
	DPB	T3,[POINTR (TRNBLK+.CHSCT,CH.SCT)] ;SET FOR UUO
	DPB	T3,[POINTR (TRNBLK+.CHDCT,CH.DCT)] ;SET FOR UUO
	LDB	T3,[POINT 6,T2,11] ;GET BYTE SIZE
	MOVX	T4,CH.6BT	;INCASE SIXBIT
	CAIN	T3,6		;TRANSLATING TO SIXBIT?
	IORM	T4,TRNBLK+.CHFLG ;YES
	MOVEI	T1,TRNBLK	;SET UP UUO AC
	CHTRN.	T1,		;TRANSLATE STRING
	  CAIN	T1,CHDCE%	;DESTINATION BYTE COUNT RUN OUT?
	POPJ	P,		;RETURN
	CAIN	T1,TRNBLK	;UUO IMPLEMENTED?
	JRST	CHRTRX		;NO--DO IT THE HARD WAY
	LDB	T2,TRNBLK+.CHSB1 ;GET TERMINATING CHARACTER
	CAIN	T1,CHILC%	;ILLEGAL CHARACTER?
	JUMPE	T2,.POPJ##	;NULS ARE REALLY OK
	STOP	(STE,<String translation error; >,,E.STE)


E.STE:	PUSH	P,T1		;SAVE ERROR CODE
	CAIN	T1,TRNBLK	;UUO IMPLEMENTED?
	MOVNI	T1,1		;NO
	CAIL	T1,CHRELN	;KNOWN ERROR CODE?
	MOVEI	T1,0		;NO
	MOVE	T1,CHRETB(T1)	;AND ASSOCIATED TEXT
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	POP	P,T1		;TRIM STACK
	CAIGE	T1,CHRELN	;CHECK AGAIN
	POPJ	P,		;RETURN
	PUSHJ	P,.TOCTW##	;PRINT ERROR CODE
	MOVEI	T1,")"		;CLOSE
	PJRST	.TCHAR##	;PRINT AND RETURN

	[ASCIZ /CHTRN. UUO not implemeted/]
CHRETB:	[ASCIZ /CHTRN. UUO error (/]
	[ASCIZ /Address check/]
	[ASCIZ /Illegal byte pointer/]
	[ASCIZ /Unknown or reserved flag bit specified/]
	[ASCIZ /Illegal character encountered/]
	[ASCIZ /Destination count exhausted prematurely/]
	[ASCIZ /Invalid bit combination specified/]
CHRELN==.-CHRETB
CHRTRX:	MOVX	T1,CH.6BT	;BIT TO TEST
	TDNN	T1,TRNBLK+.CHFLG ;TRANSLATING TO SIXBIT?
	TDZA	T1,T1		;NO
	MOVEI	T1," "		;OFFSET FOR SIXBIT
	PUSH	P,T1		;SAVE
CHRTR1:	LDB	T1,[POINTR (TRNBLK+.CHSCT,CH.SCT)] ;GET ASCIZ8 BYTE LENGTH
	LDB	T2,[POINTR (TRNBLK+.CHDCT,CH.DCT)] ;GET DEST BYTE LENGTH
CHRTR2:	SOJL	T1,.POPJ##	;RETURN IF SOURCE RUNS OUT
	ILDB	T3,TRNBLK+.CHSB1 ;GET A SOURCE CHARACTER
	JUMPE	T3,CHRTR4	;HANDLE END OF STRING
	ADD	T3,[POINT 7,CHAR8] ;MAKE POINTER TO TRANSLATION TABLE
CHRTR3:	ILDB	T4,T3		;GET NEXT TRANSLATION CHARACTER
	JUMPE	T4,CHRTR2	;NONE, TRY NEXT SOURCE BYTE
	SUB	T4,(P)		;ADJUST
	IDPB	T4,TRNBLK+.CHDB1 ;STORE IN DESTINATION STRING
	SOJG	T2,CHRTR3	;LOOP
CHRTR4:	SKIPN	T4,(P)		;GET OFFSET
	IDPB	T4,TRNBLK+.CHDB1 ;MAKE ASCIZ DESTINATION IF NECESSARY
	POP	P,(P)		;TRIM STACK
	POPJ	P,		;RETURN
; THIS TABLE IS ONLY NEEDED FOR RUNNING LOGIN UNDER A 7.02 MONITOR.
; IT WILL BE REMOVED WITH THE NEXT RELEASE OF TOPS-10.
;
;FORMAT:
;	EACH WORD IS A 0-3 CHARACTER ASCIZ (7-BIT) STRING, WHICH IS THE
;	FALLBACK REPRESENTATION OF THE CORRESPONDING 8-BIT CHARACTER.
;	THE DEFINITION OF THESE FALLBACK REPRESENTATIONS IS CURRENTLY
;	TAKEN FROM DEC STANDARD 169, UNTIL THE INTERNATIONAL STANDARD
;	IS FINALLY ACCEPTED.
;
; INDEX BY THE 8-BIT ASCII CHARACTER FOR WHICH THE FALLBACK REPRESENTATION
; IS DESIRED.

;SOME HELPER MACROS

DEFINE ONE41 < BYTE (7) <.-CHAR8> >
DEFINE UPCASE < BYTE (7) <<.-CHAR8>&137> >
DEFINE ESCSEQ < BYTE (7) .CHESC, <<.-CHAR8>^!300> >

CHAR8:
REPEAT "`"+1,< ONE41 >			;0-140
REPEAT ^D26,< UPCASE >			;LOWER CASE ALPHABET
REPEAT 5,< ONE41 >			;REMAINDER OF 7-BIT SET
REPEAT ^D32,< ESCSEQ>			;8-BIT CONTROL CHARACTERS
	EXP	0				;RESERVED 240
	ASCIZ	\!\				;SP03	241
	ASCIZ	\C\				;SC04	242
	ASCIZ	\L\				;SC02	243
	EXP	0				;RESERVED 244
	ASCIZ	\Y\				;SC05	245
	EXP	0				;RESERVED 246
	ASCIZ	\SC\				;SM24	247
	ASCIZ	\O\				;SC01	250
	ASCIZ	\(C)\				;SM52	251
	ASCIZ	\A\				;SM21	252
	ASCIZ	\<<\				;SP17	253
	EXP	0				;RESERVED 254
	EXP	0				;RESERVED 255
	EXP	0				;RESERVED 256
	EXP	0				;RESERVED 257
	ASCIZ	\O\				;SM19	260
	ASCIZ	\+\				;SA02	261
	ASCIZ	\2\				;NS02	262
	ASCIZ	\3\				;NS03	263
	EXP	0				;RESERVED 264
	ASCIZ	\U\				;SM17	265
	ASCIZ	\PR\				;SM25	266
	ASCIZ	\.\				;SM26	267
	EXP	0				;RESERVED 270
	ASCIZ	\1\				;NS01	271
	ASCIZ	\O\				;SM20	272
	ASCIZ	\>>\				;SP18	273
	ASCIZ	\1/4\				;NF04	274
	ASCIZ	\1/2\				;NF01	275
	EXP	0				;RESERVED 276
	ASCIZ	\?\				;SP16	277
	ASCIZ	\A\				;LA14	300
	ASCIZ	\A\				;LA12	301
	ASCIZ	\A\				;LA16	302
	ASCIZ	\A\				;LA20	303
	ASCIZ	\A\				;LA18	304
	ASCIZ	\A\				;LA28	305
	ASCIZ	\AE\				;LA52	306
	ASCIZ	\C\				;LC42	307
	ASCIZ	\E\				;LE14	310
	ASCIZ	\E\				;LE12	311
	ASCIZ	\E\				;LE16	312
	ASCIZ	\E\				;LE18	313
	ASCIZ	\I\				;LI14	314
	ASCIZ	\I\				;LI12	315
	ASCIZ	\I\				;LI16	316
	ASCIZ	\I\				;LI18	317
	EXP	0				;RESERVED 320
	ASCIZ	\N\				;LN20	321
	ASCIZ	\O\				;LO14	322
	ASCIZ	\O\				;LO12	323
	ASCIZ	\O\				;LO16	324
	ASCIZ	\O\				;LO20	325
	ASCIZ	\O\				;LO18	326
	ASCIZ	\OE\				;LO52	327
	ASCIZ	\O\				;LO62	330
	ASCIZ	\U\				;LU14	331
	ASCIZ	\U\				;LU12	332
	ASCIZ	\U\				;LU16	333
	ASCIZ	\U\				;LU18	334
	ASCIZ	\Y\				;LY18	335
	EXP	0				;RESERVED 336
	ASCIZ	\SS\				;LS61	337
	ASCIZ	\A\				;LA13	340
	ASCIZ	\A\				;LA11	341
	ASCIZ	\A\				;LA15	342
	ASCIZ	\A\				;LA19	343
	ASCIZ	\A\				;LA17	344
	ASCIZ	\A\				;LA27	345
	ASCIZ	\AE\				;LA51	346
	ASCIZ	\C\				;LC41	347
	ASCIZ	\E\				;LE13	350
	ASCIZ	\E\				;LE11	351
	ASCIZ	\E\				;LE15	352
	ASCIZ	\E\				;LE17	353
	ASCIZ	\I\				;LI13	354
	ASCIZ	\I\				;LI11	355
	ASCIZ	\I\				;LI15	356
	ASCIZ	\I\				;LI17	357
	EXP	0				;RESERVED 360
	ASCIZ	\N\				;LN19	361
	ASCIZ	\O\				;LO13	362
	ASCIZ	\O\				;LO11	363
	ASCIZ	\O\				;LO15	364
	ASCIZ	\O\				;LO19	365
	ASCIZ	\O\				;LO17	366
	ASCIZ	\OE\				;LO51	367
	ASCIZ	\O\				;LO61	370
	ASCIZ	\U\				;LU13	371
	ASCIZ	\U\				;LU11	372
	ASCIZ	\U\				;LU15	373
	ASCIZ	\U\				;LU17	374
	ASCIZ	\Y\				;LY17	375
	EXP	0				;RESERVED 376
	EXP	0				;RESERVED 377
SUBTTL	Miscellaneous routines -- CTXINI/CTXUUO - Execute context UUOs


CTXINI:	MOVE	T2,[Z.CTXB,,Z.CTXB+1] ;SET UP BLT
	SETZM	Z.CTXB		;CLEAR FIRST WORD
	BLT	T2,Z.CTXE-1	;CLEAR CONTEXT DATA STORAGE
	MOVEI	T2,CTXBLK	;POINT TO UUO BLOCK
	TLZ	T1,(CT.LEN)	;CLEAR OUT JUNK
	TLO	T1,.CTMAX	;INCLUDE UUO BLOCK LENGTH
	MOVEM	T1,.CTFNC(T2)	;SAVE
	MOVEI	T1,CTXDLN	;DATA BUFFER LENGTH
	MOVEM	T1,.CTDBL(T2)
	MOVEI	T1,CTXDAT	;DATA BUFFER ADDRESS
	MOVEM	T1,.CTDBA(T2)
	POPJ	P,		;RETURN


CTXUUO:	MOVEI	T1,CTXBLK	;SET UP UUO AC
	CTX.	T1,		;SET QUOTAS
	  CAIN	T1,CTXBLK	;AC CHANGED (UUO NOT IMPLEMENTED)?
	JRST	.POPJ1##	;RETURN
	MOVE	T2,T1		;COPY AC
	MOVEI	T1,CTXDAT	;PERHAPS TEXT IN DATA BUFFER
	TXNE	T2,CT.ETX	;ERROR TEXT RETURNED?
	JRST	CTXERR		;YES
	MOVEI	T1,[ASCIZ /Context-run failed; error code = /]
	TXNE	T2,CT.RUN	;RUN UUO ERROR?
	JRST	CTXERR		;YES
	MOVEI	T1,[ASCIZ /Unknown CTX. UUO failure/]
	SETZ	T2,		;CLEAR JUNK LEFT IN THE AC

CTXERR:	WARN	CTX,<>,,E.CTX
	POPJ	P,		;RETURN

E.CTX:	PUSH	P,T2		;PRESERVE ERROR AC
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	POP	P,T2		;GET AC BACK
	TXNN	T2,CT.RUN	;RUN UUO ERROR?
	POPJ	P,		;NO
	LDB	T1,[POINTR T2,CT.ERR] ;GET ERROR CODE
	PJRST	.TOCTW##	;PRINT IT AND RETURN
SUBTTL	Miscellaneous routines -- CTYCHK - Check CTY status


CTYCHK:	TLZ	F,FL.CTY	;INIT CTY FLAG
	MOVE	T1,[%CNFLN]	;GETTAB ARGUMENT
	GETTAB	T1,		;GET FRCLIN LINE NUMBER
	  POPJ	P,		;CAN'T
	MOVE	T2,[%CNPTY]	;NOW MUST GET CTY LINE NUMBER
	GETTAB	T2,		; FROM THE MONITOR
	  POPJ	P,		;CAN'T
	HLRZS	T2		;PUT IN RH FOR COMPARE
	HRRZ	T3,TTBITS	;GET OUR UDX
	TRZ	T3,.UXTRM	;CONVERT TO A LINE NUMBER
	CAIL	T3,(T1)		;WITHIN THE RANGE
	CAIL	T3,(T2)		; OF ONE OF THE CTYS?
	POPJ	P,		;NO
	TLO	F,FL.CTY	;REMEMBER FOR LATER
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- DAYTIM - Print time, date, and weekday


DAYTIM:	MSTIME	T1,		;GET TIME OF DAY
	IDIVI	T1,^D60000	;TO MINUTES
	IDIVI	T1,^D60		;NOW BREAK IN MINS AND HRS
	PUSH	P,T2		;SAVE MINUTES
	MOVEI	T2,"0"		;ZERO FILL
	PUSHJ	P,.TDEC2##	;TYPE HOURS
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	POP	P,T1		;MINUTES
	MOVEI	T2,"0"		;ZERO FILL
	PUSHJ	P,.TDEC2##	;TYPE
	MOVEI	T1,[ASCIZ /   /] ;THREE SPACES
	PUSHJ	P,.TSTRG##	;PRINT THEM
	PUSHJ	P,.TDATN##	;AND CURRENT DATE
	MOVEI	T1,[ASCIZ /   /] ;THREE SPACES
	PUSHJ	P,.TSTRG##	;PRINT THEM
	MOVE	T1,SAVEDA	;DAY OF WEEK
	MOVE	T1,WEEKDA(T1)	;POINT TO ASCIZ TEXT
	PUSHJ	P,.TSTRG##	;TYPE DAY OF WEEK
	PJRST	.TCRLF##	;END LINE WITH A CRLF AND RETURN


WEEKDA:	[ASCIZ /Wednesday/]
	[ASCIZ /Thursday/]
	[ASCIZ /Friday/]
	[ASCIZ /Saturday/]
	[ASCIZ /Sunday/]
	[ASCIZ /Monday/]
	[ASCIZ /Tuesday/]
SUBTTL	Miscellaneous routines -- TRMCLS - Clear screen function


IFE CLSDEF,<			;MAKE /NOCLEAR THE DEFAULT
TRMCLS:	SKIPG	U.CLEA		;WAS /CLEAR GIVEN?
	POPJ	P,		;NO - RETURN
>
IFN CLSDEF,<			;MAKE /CLEAR THE DEFAULT
TRMCLS:	SKIPN	U.CLEA		;WAS /NOCLEAR GIVEN?
	POPJ	P,		;YES - RETURN
>
	MOVE	T1,TTBITS	;GET TTY BITS
	TXNN	T1,GL.ITY	;PTY?
	TLNE	F,FL.BAT	;OR BATCH?
	POPJ	P,		;YES, FORGET IT
	DMOVE	T1,[EXP <2,,T2>,<.TOTRM>]
	SETO	T3,		;THIS TERMINAL
	TRMOP.	T1,		;GET THE TERMINAL TYPE
	  POPJ	P,		;ERROR
	MOVSI	T2,-CLSMAX	;SET UP AN AOBJN POINTER
	CAME	T1,CLSTRM(T2)	;MATCH?
	AOBJN	T2,.-1		;LOOP
	JUMPG	T2,.POPJ##	;POSITIVE: NO MATCH
	PUSH	P,T2		;SAVE THE TERMINAL TYPE INDEX
	PUSHJ	P,.TOOUT##	;FORCE OUT THE LAST OUTPUT

	MOVEI	T2,.TOSOP	;FUNCTION
	SETO	T3,		;THIS TERMINAL
TRMCL1:	MOVE	T1,[2,,T2]	;LENGTH,,ADDRESS
	TRMOP.	T1,		;OUTPUT COMPLETE?
	  JRST	TRMCL2		;YES - HANG UP THE PHONE
	MOVEI	T1,1		;SLEEP TIME
	SLEEP	T1,		;ZZZZZZ
	JRST	TRMCL1		;TRY AGAIN

TRMCL2:	DMOVE	T1,[EXP <3,,T2>,<.TOOSU+.TOSET>]
	SETZ	T4,		;
	TRMOP.	T1,		;CLEAR CTRL/O
	  JFCL			;OH WELL, WE TRIED
	POP	P,T1		;RESTORE THE TERMINAL TYPE INDEX
	MOVE	T1,CLSOUT(T1)	;GET THE CHARACTER SEQUENCE
	PUSHJ	P,.TSTRG##	;WRITE THIS STRING
	PJRST	.TOOUT##	;FORCE OUT THE LAST OUTPUT AND RETURN
DEFINE	CLSMAC,<
	X	DAS21,	CLS100
	X	VK100,	CLS100
	X	VT05,  	CLS05
	X	VT06,	CLS05
	X	VT50,	CLS52
	X	VT52,	CLS52
	X	VT61,	CLS52
	X	VT100,	CLS100
	X	VT101,	CLS100
	X	VT102,	CLS100
	X	VT103,	CLS100
	X	VT125,	CLS100
	X	VT180,	CLS100
	X	VT185,	CLS100
	X	VT220,	CLS100
	X	VT240,	CLS100
	X	VT241,	CLS100
>  ;END DEFINE CLSMAC


;NOW GENERATE THE TABLE OF TERMINAL NAMES

DEFINE X(A,B),<
	XLIST
	SIXBIT	/A/
	LIST
>  ;END DEFINE X

CLSTRM:	CLSMAC
CLSMAX==.-CLSTRM


;NOW GENERATE THE TABLE OF CHARACTER STRING ADDRESSES

DEFINE X(A,B),<
	XLIST
	EXP	B
	LIST
>  ;END DEFINE X

CLSOUT:	CLSMAC
CLS05:	BYTE (7) .CHCRB,.CHDEL,.CHDEL,.CHDEL,.CHDEL
	BYTE (7) .CHCUN,.CHDEL,.CHDEL,.CHDEL,.CHDEL,0

CLS52:	BYTE (7) .CHESC,"H",.CHESC,"J",0

CLS100:	BYTE (7) .CHESC,"[","H",.CHESC,"[","J",0
SUBTTL	Miscellaneous routines -- DELTMP - Delete TMP files


DELTMP:	SKIPN	U.TEMP		;WANT TO DELETE TMP FILES?
	POPJ	P,		;NOPE
	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	MOVE	T1,[DELSPC,,WILDBK] ;SET UP BLT
	BLT	T1,WILDBK+.FXLEN-1 ;COPY THE FILESPEC
	MOVE	T1,THSJOB	;GET OUR JOB NUMBER
	PUSHJ	P,.MKPJN##	;MAKE CCL REPRESENTATION
	HRLM	T1,WILDBK+.FXNAM ;SET FILE NAME
	MOVX	T1,FX.NOM!FX.PRT ;/OKNONE AND /OKPROT
	IORM	T1,WILDBK+.FXMOD;FORCE SWITCH TO BE
	IORM	T1,WILDBK+.FXMOM; SET ON ALL CALLS TO WILD
	MOVEM	PP,WILDBK+.FXDIR ;SET PPN IN BLOCK
	SETOM	WILDBK+.FXBFR	;NO /BEFORE
	SETOM	WILDBK+.FXSNC	;NO /SINCE
	SETZM	WILDPT		;CLEAR MEMORY FOR FIRST CALL
	SETZB	P1,P2		;CLEAR FILES DELETED AND BLOCKS FREED

DELTM1:	PUSHJ	P,INIFIL	;INIT STORAGE FOR FILE I/O
	MOVE	T1,[FO.ASC+FO.PRV+.FODLT] ;DELETE USING PRIVS
	MOVEM	T1,FOP+.FOFNC
	MOVEM	PP,FOP+.FOPPN	;IN BEHALF PPN
	MOVE	T1,[4,,[[WILDBK],,0
			OPN,,LEB
			.FXLEN,,.RBMAX
			IOC,,WILDPT]]
	PUSHJ	P,.LKWLD##	;LOOK FOR FILE
	  JRST	DELTM2		;ALL DONE
	PUSHJ	P,DELFIL	;DELETE THE FILE
	  JRST	DELTM1		;FAILED
	ADD	P2,T1		;COUNT THE BLOCKS FREED
	AOJA	P1,DELTM1	;COUNT THE FILE DELETED AND LOOP

DELTM2:	SKIPE	T1,P1		;GET FILES DELETED
	INFO	DTF,<Deleted >,,E.DTF
	POPJ	P,		;RETURN


E.DTF:	MOVE	T1,P1		;GET FILE COUNT
	PUSHJ	P,.TDECW##	;PRINT IT
	MOVEI	T1,[ASCIZ / TMP file/] ;ASSUME ONLY ONE
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	MOVEI	T1,[ASCIZ /s; /]
	CAIE	P1,1		;CHECK IT
	MOVEI	T1,[ASCIZ /; /]
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	MOVE	T1,P2		;GET BLOCK COUNT
	PUSHJ	P,.TDECW##	;PRINT BLOCKS FREED
	MOVEI	T1,[ASCIZ / blocks freed/]
	PJRST	.TSTRG##	;PRINT TEXT AND RETURN
; SCAN BLOCK FOR DSK:*.TMP[,,*,*,*,*,*]/PHYSICAL/OKNONE/OKPROT
DELSPC:	EXP	<'DSK   '>	;.FXDEV
	EXP	<'   ???'>	;.FXNAM
	XWD	777777,0	;.FXNMM
	XWD	'TMP',-1	;.FXEXT
	<FX.DIR!FX.PHY!FX.NOM!FX.PRT> ;.FXMOD
	<FX.DIR!FX.PHY!FX.NOM!FX.PRT> ;.FXMOM
	EXP	<0,,0>,-1	;.FXDIR/.FXDIM
	EXP	<'*     '>,0	;SFD #1
	EXP	<'*     '>,0	;SFD #2
	EXP	<'*     '>,0	;SFD #3
	EXP	<'*     '>,0	;SFD #4
	EXP	<'*     '>,0	;SFD #5
	BLOCK	.FXLEN-<.-DELSPC>
SUBTTL	Miscellaneous routines -- DETJOB - Report detached jobs


DETJOB:	SKIPN	JOBCNT		;HAVE ANY JOBS?
	POPJ	P,		;NO
	PUSHJ	P,.TNEWL##	;START OFF WITH A NEW LINE
	MOVE	T1,JOBCNT	;GET COUNT OF JOBS
	PUSHJ	P,.TDECW##	;PRINT NUMBER
	MOVE	T2,JOBCNT	;GET COUNT AGAIN
	MOVEI	T1,[ASCIZ / detached jobs logged in under /]
	CAIN	T2,1		;ONLY ONE?
	MOVEI	T1,[ASCIZ / detached job logged in under /]
	PUSHJ	P,.TSTRG##	;PRINT IT
	MOVE	T1,PP		;GET TARGET PPN
	PUSHJ	P,.TPPNW##	;PRINT IT
	PUSHJ	P,.TCOLN##	;PRINT A COLON
	PUSHJ	P,.TCRLF##	;TERMINATE LINE
	PUSHJ	P,MAPINI	;INIT JOBMAP POINTER
DETJO1:	PUSHJ	P,MAPNXT	;GET THE NEXT JOB
	  POPJ	P,		;DONE
	PUSHJ	P,DETSTS	;PRINT SOME INFO
	JRST	DETJO1		;LOOK FOR ANOTHER JOB
SUBTTL	Miscellaneous routines -- DETSTS - Print detached job status


DETSTS:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVEI	P1,(T1)		;COPY JOB NUMBER
	MOVEI	T1,[ASCIZ/  Job /]
	PUSHJ	P,.TSTRG##	;PRINT TEXT
	MOVEI	T1,(P1)		;GET JOB NUMBER
	PUSHJ	P,.TDECW##	;PRINT IT
	PUSHJ	P,.TSPAC##	;SPACE
	HRLZI	T1,(P1)		;GET JOB NUMBER
	HRRI	T1,.GTPRG	;GET PROGRAM NAME
	GETTAB	T1,		;ASK MONITOR
	  MOVEI	T1,0		;NOT TODAY
	PUSHJ	P,.TSIXN##	;PRINT PROGRAM NAME
	MOVN	T1,P1		;GET NEGATIVE JOB NUMBER
	JOBSTS	T1,		;FIND STATE
	  PJRST	.TCRLF##	;CAN'T--FINISH LINE
	TXNE	T1,JB.URN	;RUNNING?
	SKIPA	T1,[[ASCIZ/ running/]]
	MOVEI	T1,[ASCIZ/ stopped/]
	PUSHJ	P,.TSTRG##	;PRINT STATE
	PJRST	.TCRLF##	;PRINT A CRLF AND RETURN
SUBTTL	Miscellaneous routines -- ERRMSG - Error message handler


ERRMSG:	MOVEM	T1,ERRACS+1	;SAVE T1
	MOVE	T1,[2,,ERRACS+2];SETUP BLT
	BLT	T1,ERRACS+16	;EXCLUDE F(0) AND P(17)
	HRRZ	P1,(P)		;GET ADDRESS OF ARGS FROM CALL
	POP	P,(P)		;GET EXTRA PUSHJ OFF THE STACK
	PUSHJ	P,.VERBO##	;GET VERBOSITY BITS
	MOVE	P2,1(P1)	;GET FLAGS
	PUSH	P,T1		;SAVE THEM FOR LATER
	PUSHJ	P,.TNEWL##	;TYPE A CRLF IF NEEDED
	TXNE	P2,EF.REQ	;REQUE BATCH JOB?
	MOVE	T1,["?",,[ASCIZ/?(5)/]]
	TXNE	P2,EF.SYS	;SYSTEM FAILURE
	MOVE	T1,["?",,[ASCIZ/?(4)/]] ;YES--DATA FOR THAT
	TXNE	P2,EF.ERR	;FATAL ERROR
	MOVE	T1,["?",,[ASCIZ/?(3)/]]
	TXNE	P2,EF.WRN	;WARNING?
	MOVE	T1,["%",,[ASCIZ/%/]]
	TXNE	P2,EF.INF	;INFORMATIONAL
	MOVE	T1,["[",,[ASCIZ/[/]]
	TLNN	F,FL.BAT	;BATCH JOB?
	JRST	[HLRZ  T1,T1	;NO--PUT CHAR IN RH
		 PUSHJ P,.TCHAR## ;TYPE IT
		 JRST  ERMSG1]	;CONTINUE
	HRRZ	T1,T1		;CLEAR LH
	PUSHJ	P,.TSTRG##	;TYPE THE MESSAGE

ERMSG1:	MOVE	T1,(P)		;GET VERBOSITY BITS
	TXNN	T1,JWW.PR	;/MESSAGE:PREFIX?
	JRST	ERMSG2		;NO
	HRRZ	T1,(P1)		;GET PREFIX
	HRLI	T1,'LGN'	;INCLUDE OUR NAME
	PUSHJ	P,.TSIXN##	;TYPE IN SIXBIT

ERMSG2:	PUSHJ	P,.TSPAC##	;PRINT A SPACE
	POP	P,T1		;GET VERBOSITY BITS
	TXNN	T1,JWW.FL	;/MESSAGE:FIRST?
	JRST	ERMSG3		;NO
	HRRZ	T1,1(P1)	;GET TEXT ADDRESS
	PUSHJ	P,.TSTRG##	;YES--PRINT THE STRING
	HLRZ	T1,(P1)		;GET MORE ADDRESS
	JUMPE	T1,ERMSG3	;NONE
	PUSH	P,P2		;SAVE FLAGS
	PUSH	P,T1		;SAVE IT
	MOVE	16,[ERRACS+1,,1];RESTORE ACS
	BLT	16,16		;..
	PUSHJ	P,@(P)		;CALL CONTINUATION ROUTINE
	POP	P,(P)		;FIX STACK
	POP	P,P2		;RESTORE FLAGS
ERMSG3:	TXNE	P2,EF.WTO	;WTO THIS ERROR?
	PUSHJ	P,ERRWTO	;YES--DO IT NOW
	TXNE	P2,EF.INF	;INFORMATION?
	PUSHJ	P,.TRBRK##	;YES
	PUSHJ	P,.TCRLF##	;CRLF
ERMSGX:	TXNE	P2,EF.FMT	;FORMAT ERROR? (LET HIM RETRY)
	JRST	ERMSG6		;YES
	TXNE	P2,EF.ERR!EF.SYS!EF.REQ	;FATAL?
	JRST	ERMSG4		;YES--GO FLUSH USER
	MOVE	16,[ERRACS+1,,1];RESTORE ACS
	BLT	16,16		;..
	POPJ	P,		;AND RETURN

ERMSG4:	PUSHJ	P,.TCRLF##	;DO A CRLF
	TXNE	P2,EF.SIL!EF.FMT ;SUPRESS NOTICE.TXT OR FORMAT ERROR?
	JRST	ERMSG5		;YES
	MOVE	T1,[SIXBIT /LOGIN/]
	SETNAM	T1,		;CLEAR JACCT
	MOVX	T1,CM.ATT!CM.LOG ;BITS TO TEST
	TDNE	T1,COMIDX	;ATTACH OR LOGIN COMMANDS?
	PUSHJ	P,NOTICE	;YES--PRINT NOTICE.TXT
	PUSHJ	P,STRMES	;AND DO /STR IF DESIRED
ERMSG5:	PJRST	FLUSH		;AND DIE

ERMSG6:	PUSHJ	P,.CLRBF##	;CLEAR TYPE-AHEAD
	MOVSI	P2,(CM.LOG)	;BIT TO TEST
	TLNN	F,FL.BAT	;BATCH?
	TDNN	P2,COMIDX	;LOGIN COMMAND?
	PJRST	FLUSH		;GIVE UP NOW
	SOSG	P2,LOGTRY	;ANOTHER CHANCE??
	PJRST	FLUSH		;NO, BYE-BYE
	JRST	RESTAR		;TRY AGAIN
; ROUTINE TO SEND ERROR TEXT TO OPR.  CALLED ONLY BY ERRMSG.
ERRWTO:	MOVE	T1,[LGELEN,,LGETXT] ;LENGTH,,ADDRESS OF "TYPE" TEXT
	TXNE	P2,EF.ACF	;ACCESS FAILURE?
	MOVE	T1,[LGALEN,,LGATXT] ;YES--USE SPECIAL "TYPE" TEXT
	PUSHJ	P,WTOINI	;INIT WTO FACILITIES
	HRRZ	T1,1(P1)	;GET TEXT ADDRESS
	PUSHJ	P,.TSTRG##	;STORE IN WTO BUFFER
	HLRZ	T1,(P1)		;GET MORE ADDRESS
	JUMPE	T1,ERRWT1	;NONE
	PUSH	P,P2		;SAVE FLAGS
	PUSH	P,T1		;SAVE IT
	MOVE	16,[ERRACS+1,,1];RESTORE ACS
	BLT	16,16		;..
	PUSHJ	P,@(P)		;CALL CONTINUATION ROUTINE
	POP	P,(P)		;FIX STACK
	POP	P,P2		;RESTORE FLAGS
	PUSHJ	P,.TSTRG##	;STORE IN WTO BUFFER
ERRWT1:	TXNE	P2,EF.ACF	;ACCESS FAILURE?
	PUSHJ	P,ERRACF	;YES--APPEND LOTS OF JUNK
	PUSHJ	P,WTOSND	;SEND TO OPR
	  CAIA			;FAILED
	POPJ	P,		;OK
ERRWO:	TXNE	P2,EF.ACF	;ACCESS FAILURE?
	POPJ	P,		;RETURN QUIETLY
	MOVEI	T1,[ASCIZ/; Please call the operator/]
	PJRST	.TSTRG##		;THE TEXT W/O THE WTO


LGETXT:	ASCIZ/LOGIN error/	;NORMAL ERROR "TYPE" TEXT
LGELEN==.-LGETXT

LGATXT:	ASCIZ/LOGIN access failure/ ;ACCESS ERROR "TYPE" TEXT
LGALEN==.-LGATXT
ERRACF:	PUSHJ	P,.TCRLF##	;START WITH A CRLF
	MOVEI	T1,[ASCIZ /Job /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,THSJOB	;GET OUR JOB NUMBER
	PUSHJ	P,.TDECW##
	MOVEI	T1,[ASCIZ / on /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,MYTTY	;GET OUR TTY NAME
	PUSHJ	P,.TSIXN##
	MOVEI	T1,[ASCIZ / executing a /]
	PUSHJ	P,.TSTRG##
	HRRZ	T1,COMIDX	;GET INVOKING COMMAND INDEX
	MOVE	T1,COMLST(T1)	;AND ASSOCIATED NAME
	PUSHJ	P,.TSIXN##
	MOVEI	T1,[ASCIZ / command/]
	PUSHJ	P,.TSTRG##
	PUSHJ	P,.TCRLF##
	MOVEI	T1,[ASCIZ /Target PPN: /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,PP
	PUSHJ	P,.TPPNW##
	SKIPE	NEWTTY		;HAVE A NEW TTY?
	PUSHJ	P,[MOVEI T1,[ASCIZ /   New terminal: /]
		   PUSHJ P,.TSTRG##
		   MOVE	 T1,NEWTTY
		   PJRST .TSIXN##]
	MOVEI	T1,[ASCIZ /   Name: /]
	PUSHJ	P,.TSTRG##
	MOVEI	T1,USERID
	PUSHJ	P,.T8STR##
	PUSHJ	P,.TCRLF##
	MOVEI	T1,[ASCIZ /Accounting PPN: /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,AENTRY+.AEPPN
	PUSHJ	P,.TPPNW##
	MOVEI	T1,[ASCIZ /   Name: /]
	PUSHJ	P,.TSTRG##
	MOVEI	T1,AENTRY+.AENAM
	PUSHJ	P,.T8STR##
	PJRST	.TCRLF##
SUBTTL	Miscellaneous routines -- FAILUR - Check for access failures


FAILUR:	MOVE	T1,LOGTRY	;GET ATTEMPTS AT LOGGING IN
	CAIL	T1,RETRYN	;BELOW THE UNCONDITIONAL FAILURE THRESHOLD?
	TDZA	T1,T1		;YES
	MOVNI	T1,1		;ELSE ACCESS WILL NEVER BE GRANTED NOW
	MOVEM	T1,FAILFL	;SET FLAG ACCORDINGLY
	JUMPE	T1,.POPJ##	;RETURN IF A REASONABLE NUMBER OF FAILURES
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- GENTIM - Generate day-of-week and times data


GENTIM:	TLZ	F,FL.WKD	;CLEAR WEEKDAY FLAG
	PUSHJ	P,.GTNOW##	;GO GET TODAYS DATE
	HLRZ	T1,T1		;SAVE THE DAY
	IDIVI	T1,7		;FIGURE OUT THE DAY
	CAIL	T2,3		;SATURDAY??
	CAILE	T2,4		;OR SUNDAY??
	TLO	F,FL.WKD	;NO--FLAG AS WEEKDAY
	MOVEM	T2,SAVEDA	;SALT AWAY
	MSTIME	T1,
	IDIV	T1,[EXP ^D1000*^D60*^D60]
	MOVSI	T2,400000	;MAKE A BIT FOR THE CURRENT HOUR
	TLNN	F,FL.WKD	;WEEKDAY?
	MOVEI	T2,4000		;NO. USE LOW 12 BITS
	TLNN	F,FL.WKD	;WEEKDAY?
	ASH	T1,-1		;NO. USE TWO-HOUR SHIFTS
	MOVNS	T1
	LSH	T2,0(T1)	;PUT BIT IN TUNE WITH TIME
	MOVEM	T2,NOWBIT	;SAVE.
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- ISBATC - Determine if a batch job


; SUBROUTINE TO DETERMINE IF JOB NUMBER IN T1 IS A BATCH JOB
; CALL:	MOVE	T1, JOB
;	PUSHJ	P,ISBATC
;	  <NON-SKIP>		;NOT A BATCH JOB
;	<SKIP>			;A BATCH JOB

ISBATC:	PUSH	P,T1		;SAVE JOB NUMBER
	HRLZS	T1		;PUT IN LH
	HRRI	T1,.GTLIM	;GETTAB TABLE
	GETTAB	T1,		;READ LIMIT WORD
	  SETZ	T1,		;ASSUME NOT
	TXNE	T1,JB.LBT	;A BATCH JOB?
	AOS	-1(P)		;YES
	POP	P,T1		;RESTORE JOB NUMBER
	POPJ	P,		;AND RETURN
SUBTTL	Miscellaneous routines -- ISOPSR - Determine if a subjob of OPSER


; CALL:	PUSHJ	P,ISOPSR
;	  <NON-SKIP>		;NOT AN OPSER SUBJOB
;	<SKIP>			;SUBJOB OF OPSER

ISOPSR:	SETO	T1,		;THIS JOB
	CTLJOB	T1,		;WHO CONTROLS ME?
	  POPJ	P,		;I DUNNO
	MOVE	T2,T1		;REMEMBER CNTRL JOB NO.
	TRMNO.	T1,		;WHERE'S HIS TTY AT?
	  POPJ	P,		;DUNNO
	GETLCH	T1		;WHAT KIND OF TERMINAL
	TXNE	T1,GL.ITY	;PTY?
	POPJ	P,		;YES--PROBABLY BATCON
	HRLZ	T1,T2		;GET JOB NO.
	HRRI	T1,.GTPRG	;SET UP FOR GETTAB
	GETTAB	T1,		;GET PROGRAM NAME
	  POPJ	P,		;A REAL LOSER
	CAMN	T1,[SIXBIT /OPSER/]
	AOS	(P)		;YES
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- KSYCHK - Check pending KSYS


KSYCHK:	MOVE	T1,[%NSKTM]	;FIND OUT IF SYSTEM IS DOWN
	GETTAB	T1,
	  SETZ	T1,
	JUMPE	T1,.POPJ##	;RETURN IF KSYS NOT SET
	JUMPG	T1,KSYCH1	;JUMP IF SYSTEM GOING DOWN SOON
	MOVE	T1,TTBITS	;GET TTY BITS
	TLNN	F,L.OPR!L.SOPR	;IF OPR OR SUB OF OPR OR 1,2
	TXNN	T1,GL.REM!GL.DSL ;OR LOCAL TTY
	POPJ	P,		;THEN LET HIM IN ANYWAY
	STOP	TIO,<Timesharing is over>
KSYCH1:	CAIGE	T1,^D24*^D60	;OVER A DAY TO GO?
	INFO	TCI,<Timesharing will cease in >,,E.TCI
	POPJ	P,		;RETURN

E.TCI:	PUSH	P,T1		;SAVE MINUTES TILL KSYS
	IDIVI	T1,^D60		;GET HOURS
	MOVE	T4,T2		;SAVE REMAINDER (MINUTES)
	JUMPE	T1,E.TCI1	;SEE IF HOURS NONZERO
	PUSHJ	P,.TDECW##	;YES. PRINT HOURS
	MOVEI	T1,[ASCIZ/ hours /]
	PUSHJ	P,.TSTRG##
E.TCI1:	MOVE	T1,T4		;GET MINUTES
	PUSHJ	P,.TDECW##
	MOVEI	T1,[ASCIZ/ minutes at /]
	PUSHJ	P,.TSTRG##	;TYPE
	MSTIME	T1,		;GET NOW
	IDIVI	T1,^D60*^D1000	;MAKE MINUTES
	POP	P,T2		;RESTORE KSYS TIMER
	ADD	T1,T2		;COMBINE
	CAILE	T1,^D24*^D60	;WRAP AROUND?
	SUBI	T1,^D24*^D60	;YES--FIX UP
	IMULI	T1,^D60*^D1000	;BACK INTO MILLISECONDS FOR SCAN
	PJRST	.TTIME##	;TYPE AND RETURN
SUBTTL	Miscellaneous routines -- LGLACT/LGLRMK - Check strings


; CHECK ACCOUNT AND REMARK STRINGS FOR LEGAL CHARACTERS
LGLACT:	TDZA	T4,T4		;ACCOUNT ENTRY
LGLRMK:	MOVEI	T4,1		;REMARK ENTRY
	MOVE	T2,[POINT 7,.NMUL##] ;BYTE POINTER TO STORAGE
	MOVEI	T3,.AACLC	;MAXIMUM LENGTH
LGLXXX:	ILDB	T1,T2		;GET A CHARACTER
	JUMPE	T1,.POPJ##	;RETURN IF END OF STRING
	CAIGE	T1,176		;RANGE
	CAIGE	T1," "		; CHECK
	PUSHJ	P,LGLXX1	;NO GOOD
	SOJGE	T3,LGLXXX	;LOOP FOR ALL
	SKIPN	T4		;SKIP IF REMARK STRING
	FATAL	ATL,<Account string too long>,EF.FMT
	MOVEI	T1,.CHNUL	;GET A NUL
	IDPB	T1,T2		;TERMINATE STRING
	POPJ	P,		;AND RETURN
LGLXX1:	SKIPN	T4		;SKIP IF REMARK STRING
	FATAL	ICA,<Illegal character >,EF.FMT,E.ICA
	MOVEI	T1,"\"		;REPLACE BAD CHARACTER WITH A BACKSLASH
	DPB	T1,T2		;UPDATE STRING
	POPJ	P,		;RETURN

E.ICA:	PUSH	P,T1		;SAVE BAD CHARACTER
	MOVEI	T1,""""		;GET QUOTES
	PUSHJ	P,.TCHAR##	;PRINT THEM
	POP	P,T1		;GET BAD CHARACTER BACK
	PUSHJ	P,.TFCHR##	;PRINT FUNNY CHARACTER
	MOVEI	T1,""""		;GET QUOTES AGAIN
	PUSHJ	P,.TCHAR##	;PRINT THEM
	MOVEI	T1,[ASCIZ / in account string/]
	PJRST	.TSTRG##	;PRINT TEXT AND RETURN
SUBTTL	Miscellaneous routines -- LOGJOB - LOGIN the job


LOGJOB:	SETOM	CCWAIT		;DISABLE CONTROL-C
	MOVE	T1,[-5,,LGNBLK]	;SET UP UUO AC
	LOGIN	T1,		;LOG THE JOB IN
	SKIPN	T1,AENTRY+.AEPGR ;FORCING PROGRAM-TO-RUN?
	PJRST	CTLCOK		;NO--LET CONTROL-C THROUGH AND RETURN
	ADDI	T1,AENTRY	;INDEX INTO PROFILE
	SKIPN	1(T1)		;A FILE NAME THERE?
	PJRST	CTLCOK		;NO--RELEASE CONTROL-C INTERLOCK AND RETURN
	MOVEI	T2,RUNBLK	;POINT TO RUN UUO BLOCK
	SKIPN	T3,0(T1)	;GET DEVICE
	MOVSI	T3,'SYS'	;DEFAULT
	MOVEM	T3,.RNDEV(T2)
	MOVE	T3,1(T1)	;FILE NAME
	MOVEM	T3,.RNNAM(T2)
	HLLZ	T3,2(T1)	;EXTENSION
	MOVEM	T3,.RNEXT(T2)
	MOVSI	T3,3(T1)	;START OF PPN/PATH SPEC
	HRRI	T3,RUNPTH+.PTPPN ;MAKE A BLT POINTER
	BLT	T3,RUNPTH+.PTMAX-1 ;COPY
	MOVEI	T3,RUNPTH	;POINT TO PATH BLOCK
	SKIPE	.PTPPN(T3)	;HAVE A PPN?
	MOVEM	T3,.RNPPN(T2)	;POINT RUN UUO BLOCK AT IT
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- MAILCH - Check for mail


MAILCH:	TLNN	F,FL.WLD	;WILD PROGRAMMER?
	SKIPE	UFDNDL		;NO DELETE ON FOR SOME UFD?
	POPJ	P,		;YES--DON'T CHECK FOR MAIL
	SKIPE	U.MAIL		;USER REQUEST MAIL CHECKING?
	TLNE	F,FL.BAT	;YES--BUT NOT FOR BATCH
	POPJ	P,		;RETURN
	PUSHJ	P,INIFIL	;INITIALIZE I/O DATA STORAGE
	MOVE	T1,[MAILDV]	;DEVICE
	MOVEM	T1,OPN+.OPDEV
	MOVE	T1,[MAILFN]	;FILE NAME
	MOVEM	T1,LEB+.RBNAM
	MOVSI	T1,(MAILEX)	;FILE EXTENSION
	MOVEM	T1,LEB+.RBEXT
	MOVE	T1,[MAILPP]	;PPN
	CAMN	T1,[EXP -1]	;USE PPN FROM ACCOUNTING ENTRY?
	MOVE	T1,AENTRY+.AEPPN ;YES
	MOVEM	T1,LEB+.RBPPN
	OPEN	IOC,OPN		;OPEN A CHANNEL
	  POPJ	P,		;ASSUME NO NEW MAIL
	LOOKUP	IOC,LEB		;LOOKUP THE FILE
	  JRST	MAIL1		;NOT THERE
	MOVX	T1,RB.DEC	;BIT TO TEST
	TDNN	T1,LEB+.RBTYP	;ARE THE RDH WORDS VALID?
	JRST	MAIL1		;NO
	LDB	T1,[POINTR LEB+.RBTYP,RB.DTO] ;GET DATA "OTS" CODE
	LDB	T2,[POINTR LEB+.RBFFB,RB.ACW] ;GET APPLICATION BITS
	CAIN	T1,.RBOMS	;WAS FILE WRITTEN BY THE DEC-10 MAILER (MS)?
	TRNN	T2,MAILBT	;DOES NEW MAIL EXIST?
	JRST	MAIL1		;NO
	INFO	YHM,<You have new mail; to receive it, type MAIL>,,
MAIL1:	RELEAS	IOC,		;RELEASE THE CHANNEL
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- MAPJOB - Map all jobs with same PPN


MAPJOB:	PUSH	P,T1		;SAVE SUBROUTINE
	MOVE	T1,[JOBMAP,,JOBMAP+1] ;SET UP BLT
	SETZM	JOBMAP		;CLEAR FIRST WORD
	BLT	T1,JOBMAP+<^D512/^D36>-1 ;CLEAR ENTIRE BIT MAP
	SETZM	JOBCNT		;INIT COUNT OF JOBS
	MOVE	T1,[%NSHJB]	;ARGUMENT
	GETTAB	T1,		;HIGHEST JOB LOGGED IN
	  MOVEI	T1,^D511	;ASSUME THE MAX
MAPJO1:	CAMN	T1,THSJOB	;THIS JOB?
	JRST	MAPJO2		;YES--IGNORE IT
	HRLZ	T2,T1		;GET JOB NUMBER
	HRRI	T2,.GTPPN	;GETTAB TABLE NUMBER
	GETTAB	T2,		;READ PPN
	  JRST	MAPJO2		;DON'T CARE ABOUT THIS ONE
	CAMN	T2,PP		;SAME PPN?
	PUSHJ	P,@(P)		;CALL SUBROUTINE TO VALIDATE JOB
	  JRST	MAPJO2		;IGNORE THIS ONE
	MOVE	T2,T1		;GET JOB NUMBER
	IDIVI	T2,^D36		;COMPUTE WORD IN BIT MAP
	MOVNS	T3		;NEGATE
	MOVSI	T4,400000	;GET A BIT
	LSH	T4,(T3)		;POSITION IT
	IORM	T4,JOBMAP(T2)	;INDICATE THIS JOB HAS SAME PPN
	AOS	JOBCNT		;COUNT THE JOB
MAPJO2:	SOJG	T1,MAPJO1	;LOOP FOR ALL JOBS
	POP	P,(P)		;PRUNE STACK
	PJRST	MAPINI	;RESET POINTERS AND RETURN
; ROUTINE TO RESET POINTERS INTO THE BIT MAP.  MUST BE CALLED
; PRIOR TO CALLING MAPNXT.
MAPINI:	MOVSI	T1,-<^D512/^D36> ;AOBJN POINTER
	MOVEM	T1,JOBPTR	;SAVE
	POPJ	P,		;RETURN


; ROUTINE TO RETURN THE NEXT JOB FROM THE BIT MAP
MAPNXT:	MOVE	T1,JOBPTR	;GET POINTER TO MAP
MAPNX1:	MOVE	T2,JOBMAP(T1)	;GET A WORD
	JFFO	T2,.+2		;FIND FIRST BIT
	JRST	MAPNX2		;WORD EMPTY?
	HRRZS	T2,T1		;ISOLATE MAP WORD
	IMULI	T1,^D36		;36 JOBS PER WORD ARE MAPPED
	ADDI	T1,(T3)		;T1=JOB NUMBER FROM MAP
	MOVNS	T3		;NEGATE
	MOVSI	T4,400000	;GET A BIT
	LSH	T4,(T3)		;POSITION
	ANDCAM	T4,JOBMAP(T2)	;CLEAR THE BIT
	MOVEM	T1,JOBNUM	;SAVE LAST JOB NUMBER FOUND
	JRST	.POPJ1##	;RETUR
MAPNX2:	AOBJP	T1,.POPJ##	;ADVANCE POINTER
	MOVEM	T1,JOBPTR	;SAVE
	JRST	MAPNX1		;TRY THE NEXT WORD
SUBTTL	Miscellaneous routines -- NEWPPN/OLDPPN - Change PPN


NEWPPN:	SKIPA	T1,PPN		;NEW PPN
OLDPPN:	MOVE	T1,HLPPPN	;OLD PPN
	TLNE	F,FL.LGN	;LOGGED IN?
	POPJ	P,		;THEN NOTHING TO DO
	HRRZ	T2,T1		;GET PROGRAMMER NUMBER
	CAIN	T2,UNIPRG	;GENERATING A UNIQUE PROGRAMMER NUMBER?
	HRRI	T1,0		;YES
	MOVEM	T1,.MYPPN##	;UPDATE SCAN
	TRNE	T1,-1		;A REAL PPN?
	CHGPPN	T1,		;YES
	  JFCL			;SHOULDN'T FAIL
	POPJ	P,		;RETURN
SUBTTL	Miscellaneous routines -- CHKLPN - check Logged-in PPN

;THIS ROUTINE CHECKS TO SEE IF THE LOGGED-IN PPN MATCHES THE
;CURRENT PPN.  IF THEY DO, ALL IS FINE.  IF NOT, ATTEMPT TO
;USE CHGPPN TO GO BACK HOME.  IF CHGPPN FAILS, OR THE LOGGED-IN PPN
;IS ZERO, ASSUME THAT THE MONITOR DOESN'T KNOW .GTLPN AND PUNT.

CHKLPN:	SETZM	PRVPPN		;CLEAR PREVIOUS-PPN HOLDER
	SKIPE	T1,LPNPPN	;GET LOGGED-IN PPN - IS IT NONZERO?
	CAMN	T1,PPN		;YES - IS IT SAME AS CURRENT PPN?
	POPJ	P,		;YES, OR .GTLPN NOT IN MONITOR - GIVE UP
	CHGPPN	T1,		;NO - TRY TO CHANGE IT
	  POPJ	P,		;FAILED..OH WELL, WE TRIED - GIVE UP
	MOVE	T2,PPN		;GET OLD PPN
	MOVEM	T2,PRVPPN	;STORE IT AWAY
	MOVEM	T1,PPN		;MAKE OUR IDEA OF PPN MATCH MONITOR'S...
	MOVE	PP,T1		;...
	MOVEM	T1,.MYPPN##	;ALSO TEACH SCAN ABOUT THE CHANGE SO THAT
				;HE'LL FIND SWITCH.INI IN THE RIGHT PLACE
	POPJ	P,		;GO BACK

;TYPLPN DISPLAYS THE "PIVOTING BACK" MESSAGE".

TYPLPN:	SKIPE	U.NMSG		;ARE WE BEING QUIET?
	SKIPN	PRVPPN		;DID WE ACTUALLY GO ANYWHERE?
	POPJ	P,		;NO - DONT SAY ANYTHING
	INFO	PBT,<Pivoting back to >,,TYPL.1
TYPL.0:	POPJ	P,		;ALL DONE

TYPL.1:	MOVE	T1,LPNPPN	;GET WHERE WE'RE GOING
	PUSHJ	P,.TPPNW##	;TYPE THAT
	MOVEI	T1,[ASCIZ / from /] ;GET 'FROM' STRING
	PUSHJ	P,.TSTRG##	;TYPE THAT TOO
	MOVE	T1,PRVPPN	;GET SAVED COPY OF WHERE WE WERE
	PJRST	.TPPNW##	;TELL THE USER AND RETURN
SUBTTL	Miscellaneous routines -- OTHJOB - Report other jobs same PPN


OTHJOB:	TLNE	F,FL.WLD	;WILDCARD PPN?
	POPJ	P,		;YES--BETTER NOT BE ANY OTHERS
	MOVEI	T1,.POPJ1##	;ALL MATCHES SUCCEED
	PUSHJ	P,MAPJOB	;BUILD A BIT MAP OF OTHER JOBS
	SKIPN	T1,JOBCNT	;FOUND ANY JOBS?
	POPJ	P,		;NO
	INFO	JSP,<Other jobs same PPN>,,E.JSP
	POPJ	P,		;RETURN

E.JSP:	MOVE	T1,PPN		;GET PPN
	CAMN	T1,ALPPPN	;IS IT [1,2]?
	POPJ	P,		;YES--SKIP THIS STUFF
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	TRZ	F,R.COMA	;CLEAR COMMA FLAG
E.JSP1:	PUSHJ	P,MAPNXT	;GET NEXT JOB NUMBER
	  POPJ	P,		;DONE
	CAMN	T1,THSJOB	;THIS JOB?
	JRST	E.JSP1		;YES--IGNORE IT
	PUSH	P,T1		;SAVE JOB NUMBER
	TROE	F,R.COMA	;COMMA TYPED YET?
	PUSHJ	P,.TCOMA##	;TYPE A COMMA
	POP	P,T1		;RESTORE JOB NUMBER
	PUSHJ	P,.TDECW##	;PRINT IT
	JRST	E.JSP1		;LOOP FOR ALL JOBS
SUBTTL	Miscellaneous routines -- PTHCHK - Check a path spec


PTHCHK:	SKIPN	.FXDEV(T1)	;DID USER TYPE ANYTHING?
	JRST	.POPJ1##	;NO--CHECK NO FURTHER
	MOVX	T2,FX.NDV	;BIT TO TEST
	TDNN	T2,.FXMOD(T1)	;NO DEVICE (SCAN DEFAULTED TO 'DSK')?
	POPJ	P,		;BAD PATH SPEC
	SKIPN	.FXNAM(T1)	;FILE NAME IS ILLEGAL
	SKIPE	.FXEXT(T1)	;EXTENSION IS ILLEGAL
	POPJ	P,		;GIVE UP
	MOVSI	T3,-.FXLND	;ENTRIES IN A FULL PATH SPEC
	ADD	T3,T1		;BASE ADDR OF PATH SPEC
PTHCH1:	SKIPN	.FXDIR(T3)	;WAS A DIRECTORY GIVEN?
	JRST	PTHCH2		;NO, WE'VE REACHED END OF LIST
	AOSE	.FXDIM(T3)	;YES, WERE WILD CARDS GIVEN?
	JRST	.POPJ##		;YES, MUSTN'T DO THAT
	AOJ	T3,
	AOBJN	T3,PTHCH1	;LOOP TO CHECK ENTIRE PATH
PTHCH2:	HLLZ	T2,.FXDIR(T1)	;GET PROJECT NUMBER
	SKIPN	T2		;ZERO?
	HLLM	PP,.FXDIR(T1)	;YES--DEFAULT IT
	HRRZ	T2,.FXDIR(T1)	;GET PROGRAMMER NUMBER
	SKIPN	T2		;ZERO?
	HRRM	PP,.FXDIR(T1)	;YES--DEFAULT IT
	JRST	.POPJ1##	;GIVE GOOD RETURN
SUBTTL	Miscellaneous routines -- PPNCHK - Check for illegal PPNs


PPNCHK:	MOVSI	T2,-PPNLEN	;AOBJN POINTER
PPNCH1:	MOVE	T1,@PPNTAB(T2)	;GET A PPN
	TLNE	F,FL.WLD	;WILDCARDED PPN?
	CAIE	T1,UNIPRG	;UNIQUE PROGRAMMER?
	SKIPA			;NO
	JRST	PPNCH2		;LET 10,# THROUGH
	TLNN	T1,-1		;HAVE A PROJECT NUMBER
	HLL	T1,PP		;NO--INCLUDE OURS
	CAMN	T1,PP		;A MATCH?
	FATAL	MLP,<May not LOGIN using >,EF.FMT,.TPPNW##
PPNCH2:	AOBJN	T2,PPNCH1	;LOOP THROUGH TABLE
	POPJ	P,		;RETURN


PPNTAB:	EXP	[XWD 0,UNIPRG]	;[*,#]
	EXP	[XWD 0,DEFPRG]	;[*,777777]
	EXP	MFDPPN		;[1,1]
	EXP	QUEPPN		;[3,3] (SEE OLD REACT.MAC)
PPNLEN==.-PPNTAB		;LENGTH OF TABLE
SUBTTL	Miscellaneous routines -- QUEERR - Process QUEUE. UUO errors


QUEERR:	PUSH	P,T1		;SAVE T1
	MOVE	T1,[PUSHJ P,ERRMSG] ;INSTRUCTION TO CALL ERROR HANDLER
	MOVEM	T1,QERBLK+0
	SETZM	QERBLK+1	;XWD MOR,'PFX'
	MOVE	T1,[EF.ERR+QERTXT] ;TYP!FLG![ASCIZ\TXT\]
	MOVEM	T1,QERBLK+2
	POP	P,T1		;GET UUO AC BACK
	TXNE	T1,QU.RBT!QU.RBR;RESPONSE BLOCK RETURNED?
	JRST	QUEER1		;YES
	MOVE	T2,T1		;COPY ERROR CODE
	CAIL	T2,QUEELN	;KNOWN ERROR CODE?
	MOVEI	T2,0		;NO
	XCT	QUEETB(T2)	;ISSUE APPROPRIATE MESSAGE (NEVER RETURNS)
QUEER1:	MOVEI	T4,3		;MUST EAT THE FIRST THREE CARACTERS
	ADJBP	T4,[POINT 7,RSPBLK] ; OF THE SIX CHARACTER PREFIX
	SETZ	T2,		;CLEAR RESULT
	MOVEI	T3,3		;CHARACTER COUNT
QUEER2:	ILDB	T1,T4		;GET A CHARACTER
	SUBI	T1," "		;MAKE SIXBIT
	LSH	T2,6		;MAKE ROOM
	IOR	T2,T1		;INCLUDE CHARACTER
	SOJG	T3,QUEER2	;LOOP
	MOVEM	T2,QERBLK+1	;SAVE
	ILDB	T1,T4		;POINT PAST THE SPACE
	MOVE	T2,[POINT 7,QERTXT] ;BYTE POINTER TO STORAGE
	MOVEI	T3,^D20*5	;CHARACTER COUNT
QUEER3:	ILDB	T1,T4		;GET A CHARACTER
	CAIE	T1,.CHLFD	;LINE FEED?
	CAIN	T1,.CHCRT	;CARRIAGE RETURN?
	MOVEI	T1,.CHNUL	;YES--WE DON'T DO MULTI-LINE STUFF
	IDPB	T1,T2		;PUT A CHARACTER
	SKIPE	T1		;DONE?
	SOJG	T3,QUEER3	;LOOP THROUGH RESPONSE BUFFER
	PUSHJ	P,QERBLK	;GENERATE ERROR MESSAGE (NEVER RETURN)


QUEETB:	STOP	(UQE,<Unknown QUEUE. UUO error >,,E.QUE)
	STOP	(IAL,<Illegal argument list>,,)
	STOP	(IFC,<Illegal function code>,,)
	STOP	(NFC,<No monitor free core>,,)
	STOP	(ADC,<Address check>,,)
	FATAL	(CNR,<Component not running; no system pid>,,)
	FATAL	(EFO,<Fatal error returned from component>,,)
	FATAL	(IMO,<Invalid message from component>,,)
	STOP	(NPV,<Not privileged>,,)
	FATAL	(NRA,<No response from [SYSTEM]ACCOUNTING>,,)
QUEELN==.-QUEETB

E.QUE:	PUSH	P,T1		;SAVE ERROR CODE
	MOVEI	T1,"("		;TYPE LEFT
	PUSHJ	P,.TCHAR##	; PARANTHESIS
	POP	P,T1		;GET ERROR CODE BACK
	PUSHJ	P,.TOCTW##	;TYPE IT
	MOVEI	T1,")"		;TYPE RIGHT
	PJRST	.TCHAR##	; PARANTHESIS AND RETURN
SUBTTL	Old LOGIN cruft


NOTBAT:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVNI	T1,1		;-1 FOR OUR TTY
	GETLCH	T1		;READ TTY BITS
	TXNE	T1,GL.CNE!GL.HDP!GL.LCP ;SOME FLAVOR OF NO ECHO?
	TXO	T1,GL.HDP	;CALL IT HALF DUPLEX
	MOVEM	T1,TTBITS	;SAVE
	PUSHJ	P,FNDCTL	;FIND CONTROLLING JOB NUMBER
	 JRST	TTYDET		;CAN'T
	  JRST	BJSJ		;BATCH JOB SUBJOB
	HRLZ	T1,T3		;T1=SIXBIT LINE NUMBER
	CAME	T3,[SIXBIT/CTY/]	;SKIP IF ATTACHED CTY
	CAMN	T3,SAVOPR	;IS IT THE OPR?
	TLO	F,L.SOPR	;FLAG SUBJOB OF OPR.
	SETZ	T3,
	MOVE	T4,[POINT 6,T1]
	JUMPN	T1,ISPTY1	;JUMP IF NOT CTY
	MOVX	T3,%CNPTY
	GETTAB	T3,
	  SETO	T3,
	HLRES	T3		;T3=OFFSET FOR FIRST PTY
	SUBI	T3,1		;-1=LINE NUMBER OF CTY
	JUMPGE	T3,ISPTY2	;JUMP IF HAVE CTY LINE NUMBER
	MOVX	T3,GL.CTY	;NO, FAKE TTBITS
	JRST	ISPTY3		;WE KNOW ITS THE CTY

ISPTY1:	ILDB	P1,T4
	JUMPE	P1,ISPTY2	;JUMP IF NO MORE CHARS
	LSH	T3,3
	ADDI	T3,-20(P1)
	JRST	ISPTY1

TTYDET:	SKIPA	T3,[GL.REM+GL.DSL]	;MAKE HIM NON-LOCAL

ISPTY2:	GETLCH	T3		;GET LINE BITS FOR CONTROL JOB TTY
ISPTY3:	TXNE	T3,GL.CNE!GL.HDP!GL.LCP ;SOME FLAVOR OF NO ECHO?
	TXO	T3,GL.HDP	;CALL IT HALF DUPLEX
	MOVEM	T3,CNTLJT	;SAVE LINE BITS FOR CONTROL JOB TTY
	MOVEM	T2,CNTLJP	;SAVE CONTROLLER'S PPN
	MOVE	T1,TTBITS	;GET OUR TTY BITS
	TXNN	T1,GL.ITY	;PTY?
	POPJ	P,		;NO--DONE
	TRO	F,R.PTYJ	;MARK AS A PTY JOB
	MOVE	T1,[2,,[EXP .TOFSP,-1]]
	TRMOP.	T1,		;READ FULL SCNSER PTY STATUS
	  MOVEI	T1,0		;ASSUME NOT
	SKIPN	T1		;WAS IT SET?
	TXO	T3,GL.HDP	;NO--THEN MUST ASSUME HDX
	MOVEM	T3,CNTLJT	;UPDATE BITS
	POPJ	P,		;RETURN

BJSJ:	TDO	F,[FL.BSJ,,R.PTYJ] ;SET BATCH PTY
	MOVEM	T2,CNTLJP	;CONTROLLING PPN=PPN OF BATCH JOB
	MOVX	T3,GL.REM	;PRETEND REMOTE
	MOVEM	T3,CNTLJT	;SAVE FAKE TTY BITS
	POPJ	P,		;RETURN
;ROUTINE TO FIND JOB'S ULTIMATE CONTROLLER FOR PURPOSES OF ACCESS CHECKING
;STOP SCANNING IF REACH: [1,2] JOB, TOP LEVEL JOB, DETACHED JOB, OR BATCH JOB
;CALL:	PUSHJ	P,FNDCTL
;	 CPOPJ IF CAN'T FIND JOB (ASSUME WE'RE DETACHED)
;	  CPOPJ1 IF BATCH JOB SUBJOB (ASSUME REMOTE)
;	    CPOPJ2 WITH AC'S SET UP AS FOLLOWS:
;		T1=CONTROLLING JOB NUMBER
;		T2=CONTROLLING JOB'S PPN
;		T3=CONTROLLING JOB'S PHYSICAL TTY NAME
FNDCTL:	SETO	T1,		;FIRST, GET IMMEDIATE CONTROLLING JOB
	CTLJOB	T1,		;..
	  SKIPA			;ASSUME WE'VE BECOME DETACHED
	JUMPGE	T1,FNDCT1
	MOVE	T1,THSJOB	;GET OUR JOB NUMBER
	TLNN	F,FL.LGN	;ARE WE LOGGED IN?
	TDZA	T2,T2		;NO
	GETPPN	T2,		;YES--GET OUR PPN
	  JFCL
	GETLIN	T3,		;GET OUR TTY NAME
	TLNN	T3,-1		;ATTACHED?
	POPJ	P,		;NO
	JRST	CPOPJ2		;RETURN

FNDCT1:	HRLZ	T3,T1		;GET THIS JOB'S TTY DDB ADDRESS
	HRRI	T3,.GTTTY	;..
	GETTAB	T3,		;..
	  JRST	CPOPJ
	PEEK	T3,		;GET PHYSICAL TTY NAME
				;REMOVED 3 INSTRUCTIONS
	PUSH	P,T1		;SAVE T1
	MOVE	T1,T2		;SAVE LAST PPN IN CASE SON-OF-OPR
	HRLZ	T2,(P)		;GET THIS JOB'S PPN (JOB # ON STACK)
	HRRI	T2,.GTPPN	;..
	GETTAB	T2,
	  SETZ	T2,
	CAMN	T2,ALPPPN	;HAVE WE HIT A [1,2] JOB YET?
	  JRST	SONOPR		;YES: WE'RE SON-OF-OPR
	HRRZ	T1,(P)		;GET JOB NO. BACK AGAIN
	PUSHJ	P,ISBATC	;IS THIS JOB A BATCH JOB?
	  JRST	NOTBSJ
	POP	P,T1		;FIX UP STACK
	JRST	CPOPJ1		;WE'RE A BATCH JOB SUBJOB

NOTBSJ:	MOVE	T1,(P)		;RESTORE T1 FOR A BIT
	CTLJOB	T1,		;ANOTHER LEVEL?
	  JRST	TPOPJ		;RESTORE T1 AND RETURN
	AOJE	T1,TOPLVL	;IF T1=-1 WE'VE HIT TOP LEVEL
	TLO	F,L.MANY	;FLAG MORE THAN ONE SUPERIOR
	POP	P,T3		;ADJUST STACK
	SOJA	T1,FNDCT1	;GO THRU NEXT LEVEL


SONOPR:	TLO	F,L.SOPR	;REMEMBER WE'RE SPAWN OF OPR
	MOVE	T2,T1		;USE LAST NON-[1,2] PPN AS CONTROLLER
	TLNN	F,L.MANY	;UNLESS [1,2] IS IMMEDIATE CONTROLLER
	  MOVE	T2,ALPPPN	;IN WHICH CASE USE [1,2]
TOPLVL:	POP	P,T1		;JOB # WE WANT IS ON STACK
CPOPJ2:	AOS	(P)
CPOPJ1:	AOSA	(P)		
TPOPJ:	POP	P,T1		;RESTORE T1
CPOPJ:	POPJ	P,
; INIT QUEUE. UUO ARGUMENT AND RESPONSE BLOCKS
; CALL:	MOVE	T1, FLAGS AND FUNCTION CODES
;	MOVE	T2, NODE
;	MOVE	T3, RESPONSE BLOCK LENGTH,,ADDRESS
;	MOVE	T4, TIMEOUT IN SECONDS
;	PUSHJ	P,QUEINI
;	<RETURN>
;
; ON RETURN, T1 WILL POINT TO THE FIRST FREE WORD IN THE QUEUE. UUO BLOCK

QUEINI:	PUSHJ	P,.SAVE1##	;SAVE P1
	HRRZ	P1,MONVER	;GET MONITOR VERSION
	CAIGE	P1,703		;QUEUE. UUO SUPPORT TIMEOUT?
	SETZ	T4,		;NO
	MOVE	P1,[QUEBLK,,QUEBLK+1] ;SET UP BLT
	SETZM	QUEBLK		;CLEAR FIRST WORD
	BLT	P1,QUEBLK+QUELEN-1 ;CLEAR ENTIRE QUEUE. UUO BLOCK
	MOVE	P1,[RSPBLK,,RSPBLK+1] ;SET UP BLT
	SETZM	RSPBLK		;CLEAR FIRST WORD
	BLT	P1,RSPBLK+RSPLEN-1 ;CLEAR ENTIRE RESPONSE BLOCK
	MOVE	P1,[DATBLK,,DATBLK+1] ;SET UP BLT
	SETZM	DATBLK		;CLEAR FIRST WORD
	BLT	P1,DATBLK+DATLEN-1 ;CLEAR ENTIRE BLOCK
	MOVEI	P1,QUEBLK	;POINT TO QUEUE. UUO BLOCK
	SKIPE	T3		;RESPONSE BLOCK GIVEN?
	TXO	T1,QF.RSP	;YES--TELL THE MONITOR
	SKIPE	T4		;SETTING A TIMEOUT VALUE?
	TXO	T1,<INSVL. (.QUTIM+1,QF.HLN)> ;YES
	MOVEM	T1,.QUFNC(P1)	;STORE FUNCTION CODE
	MOVEM	T2,.QUNOD(P1)	;STORE OPR NODE
	MOVEM	T3,.QURSP(P1)	;STORE RESPONSE BLOCK POINTER
	SKIPE	T4		;TIMING THIS REQUEST?
	MOVEM	T4,.QUTIM(P1)	;SET TIMEOUT VALUE
	MOVEI	T1,.QUTIM+1(P1)	;POINT TO FIRST FREE WORD IN BLOCK
	SKIPN	T4		;BUT MUST ADJUST FIRST FREE OFFSET
	SOS	T1		;IF NOT TIMING THE REQUEST
	POPJ	P,		;RETURN
SUBTTL	Low segment variables


PDPLST:	IOWD	PDLSIZ,PDL

KLGMSG:	ASCIZ	/
.KJOB
./

CRLFPD:	ASCIZ	/
./

	XLIST
	LIT
	LIST

	RELOC	0

ZZBEG:!				;START OF BLT TO ZERO

Z.XITB:!			;START OF PROGRAM EXIT DATA TO BE PRESERVED
RUNBLK:	BLOCK	6		;RUN UUO BLOCK
RUNPTH:	BLOCK	.PTMAX		;PLACE FOR RUN PATH BLOCK
Z.XITE:!			;END OF PROGRAM EXIT DATA TO BE PRESERVED

INTBLK:	BLOCK	4		;CONTROL-C INTERCEPT BLOCK
CCWAIT:	BLOCK	1		;IF 0 DO CONTROL-C WHEN TYPED. IF -1 WAIT.
CCTYPE:	BLOCK	1		;-1 IF CONTROL-C TYPED.
PSIBLK:!			;INTERRUPT VECTOR FOR PSI
DETINB:	BLOCK	.PSVIS+1	;INTERRUPT CELL FOR ATTACH/DETACH
DETFLG==DETINB+.PSVIS		;FLAG FOR DETACHED JOB
HELP:	BLOCK	1		;POINTER TO HELP STRING
IPCFLG:	BLOCK	1		;IPCF FLAGS
FMPID:	BLOCK	1		;MY PID
TOPID:	BLOCK	1		;SENDER'S PID
IPCPTR:	BLOCK	1		;POINTER TO MESSAGE
IPCMSG:	BLOCK	1		;FUNCTION FOR [SYSTEM]IPCF TO DO
IPCJOB:	BLOCK	1		;JOB TO DO IT TO
IPCQTA:	BLOCK	1		;IPCF QUOTA
NODBLK:!			;START OF NODE. UUO BLOCK
NODLEN:	BLOCK	1		;LENGTH OF NODE UUO ARGUMENT BLOCK
NODLOC:	BLOCK	2		;NODE NUMBER
NODDEV:	BLOCK	2		;NUMBER OF DEVICES,,DEVICE TYPE
RDUFLG:	BLOCK	1		;RECOMPUTING DISK USAGE TYPEOUT FLAG
CONFIG:	BLOCK	5		;CONFIGURATION NAME
PTHBUF:	BLOCK	.PTMAX		;PATH. UUO BLOCK
UFDFSN:	BLOCK	1		;FILE STRUCTURE NAME
UFDARG:	BLOCK	.UFSIZ		;ARGS TO .UFD IN UFDSET.MAC
PDL:	BLOCK	PDLSIZ		;PUSH DOWN LIST
AENTRY:	BLOCK	.AEMAX		;DATA FROM ACCT.SYS
GOBBLK:	BLOCK	.DFGST+1	;GOBSTR UUO BLOCK
MONVER:	BLOCK	1		;MONITOR VERSION
MFDPPN:	BLOCK	1		;PPN FOR MFD
SYSPPN:	BLOCK	1		;PPN FOR SYS
HLPPPN:	BLOCK	1		;PPN FOR LOGGED OUT JOBS
QUEPPN:	BLOCK	1		;PPN FOR SPOOLED OUTPUT
ALPPPN:	BLOCK	1		;PPN FOR FULL FILE ACCESS
UFDPRT:	BLOCK	1		;STANDARD UFD PROTECTION
LOGTRY:	BLOCK	1		;TRIES AT LOGGING IN
TTBITS:	BLOCK	1		;TELETYPE DESCRIPTOR
STATES:	BLOCK	1		;SYSTEM STATES
STATS2:	BLOCK	1		;SECOND STATES WORD
JIFFIE:	BLOCK	1		;CLOCK TICKS PER SECOND
IAMLGO:	BLOCK	1		;0 IF LOGIN, -1 IF LOGOUT (BEFORE 7.04)
PRGNAM:	BLOCK	1		;NAME OF THIS PROGRAM
JLOGTM:	BLOCK	1		;JOB LOGGED IN TIME
BATLIM:	BLOCK	1		;BATCH LIMIT WORD
FRCLIN:	BLOCK	1		;LINE NUMBER OF FRCLIN
ENQLOK:	BLOCK	1		;NON-ZERO IF OUTSTANDING LOCKS
KCTNUM:	BLOCK	1		;KILO-CORE-TICKS
DSKRDS:	BLOCK	1		;DISK READS
DSKWTS:	BLOCK	1		;DISK WRITES
TOTBLK:	BLOCK	1		;TOTAL BLOCKS
RUNTIM:	BLOCK	1		;RUN TIME
LOCSTA:	BLOCK	1		;LOCAL STATION NUMBER
JOBSTA:	BLOCK	1		;JOB'S STATION NUMBER
CURDTM:	BLOCK	1		;CURRENT DATE/TIME
XPDDTM:	BLOCK	1		;UNIVERSAL DATE/TIME EXPIRATION DATE
L.OJCS:	BLOCK	1
L.MXJB:	BLOCK	1
L.HJIU:	BLOCK	1
LPNPPN:	BLOCK	1		;LOGGED-IN PPN
PRVPPN:	BLOCK	1		;PREVIOUS PPN (AFTER PIVOTING BACK)
NOWBIT:	BLOCK	1		;TIME OF DAY AS A BIT
SAVEDA:	BLOCK	1		;SAVED DATE
MYTTY:	BLOCK	1		;NAME OF MY TTY
NEWTTY:	BLOCK	1		;NEW TTY FOR REATTACH
TTYUDX:	BLOCK	1		;UDX OF MY TTY
UFDDAT:	BLOCK	1		;DATE OF MOST RECENT UFD
UFDTIM:	BLOCK	1		;AND ITS TIME
UFDNDL:	BLOCK	1		;0 IF UFD CAN BE RENAMED, -1 IF IT CAN NOT
THSJOB:	BLOCK	1		;THIS JOB NUMBER
DEVPTR:	BLOCK	1		;POINTER TO DEVTAB
MONLNO:	BLOCK	1		;LINE NUMBER FOR USAGE ACCOUNTING
MONNOD:	BLOCK	1		;NODE NAME FOR USAGE ACCOUNTING
MONTDE:	BLOCK	1		;TERMINAL DESIGNATOR FOR USAGE ACCOUNTING
QTACNT:	BLOCK	1		;COUNTER FOR QTATAB ENTRY
QTANUM:	BLOCK	1		;NUMBER OF ACTUAL QTATAB ENTRIES
				;*** DO NOT SEPARATE ***
QTAUUO:	BLOCK	.FSDSO		;STRUUO DEFINE STRUCTURE BLOCK
QTATAB:	BLOCK	STRMAX*.DFJBL	;TABLE OF STRS TO RECOMPUTE
				;*** END OF DO NOT SEPARATE ***
LSTSTR:	BLOCK	1		;LAST STR FOR /QUOTA
STRMSK:	BLOCK	1		;STR MASK FOR /QUOTA
BATSTR:	BLOCK	1		;STRUCTURE FOR BATCH DELETION
BATPPN:	BLOCK	1		;DIRECTORY FOR BATCH DELETION
BATTOT:	BLOCK	1		;TOTAL NUMBER OF BLOCKS
BATNQC:	BLOCK	1		;TOTAL BLOCKS UNCHECKED (NQC)
BATDFL:	BLOCK	1		;NUMBER OF FILES DELETED
BATQTO:	BLOCK	1		;QUOTA OUT

WILDBK:	BLOCK	.FXLEN		;WILD BLOCK
WILDPT:	BLOCK	1		;WILD POINTER
WLDARG:	BLOCK	4		;ARGBLOCK FOR WILD

Z.CTXB:!			;START OF CONTEXT DATA TO ZERO
CTXBLK:	BLOCK	.CTMAX		;UUO ARGUMENT BLOCK
CTXDAT:	BLOCK	CTXDLN		;DATA BUFFER
Z.CTXE:!			;END OF CONTEXT DATA TO ZERO

IO.ZB:!				;START OF I/O DATA STORAGE TO ZERO
FOP:	BLOCK	.FOMAX		;FILOP BLOCK
   OPN==FOP+.FOIOS
LEB:	BLOCK	.RBMAX		;LOOKUP/ENTER BLOCK
PTH:	BLOCK	.PTMAX		;PATH BLOCK
RFS:	BLOCK	.FOFMX		;RETURNED FILESPEC BLOCK
RNB:	BLOCK	4		;RENAME BLOCK
IO.ZE:!				;END OF I/O DATA STORAGE TO ZERO

;***START OF BLOCK SET TO 0 ON CALLS TO SCAN

Z.STRT:	BLOCK	0		;START OF BLT

NOTSPC:	BLOCK	.FXLEN		;/NOTE SPEC
LIBSPC:	BLOCK	.FXLEN		;/LIB SPEC
TYPSPC:	BLOCK	.FXLEN		;TEMP FOR TYPE
U.PATH:	BLOCK	.FXLEN		;AREA FOR USER'S PATH SPEC
DEVTAB:	BLOCK	DVICES*2	;TABLE OF DEV PHYS AND LOG NAMES
U.SPL:	BLOCK	1		;SPOOL REQUEST
U.WAT:	BLOCK	1		;WATCH REQUEST
U.DPRI:	BLOCK	1		;DISK PRIORITY

Z.END:!			;END OF BLT
;***START OF BLOCK SET TO -1 ON CALLS TO SCAN

OOBEG:!				;START OF BLT FOR SCAN

U.ATT:	BLOCK	1		;ATTACH ASK OR IGNORE
U.BINT:	BLOCK	1		;BATCH OPERATOR INTERVENTION
U.BNAM:	BLOCK	1		;BATCH JOB NAME
U.BSEQ:	BLOCK	1		;BATCH SEQUENCE NUMBER
U.BSTR:	BLOCK	1		;BATCH STREAM NUMBER
U.BREQ:	BLOCK	1		;BATCH REQUEST ID
U.ACTS:	BLOCK	10		;ACCOUNT STRING
U.RMRK:	BLOCK	10		;REMARK STRING
U.TIME:	BLOCK	1		;TIME LIMIT REQUEST
U.CORE:	BLOCK	1		;CORE LIMIT
U.NAME:	BLOCK	2		;/NAME
U.NEW:	BLOCK	1		;NEW BIT
U.NOTC:	BLOCK	1		;/NOTICE
U.NWAT:	BLOCK	1		;/NOWATCH
U.PASS:	BLOCK	1		;/PASSWORD
U.DFER:	BLOCK	1		;DEFERRED SPOOLING BIT
U.SYS:	BLOCK	1		;SYS BIT
U.DFUL:	BLOCK	1		;DISK FULL CONDTION
U.LIMI:	BLOCK	1		;1 IF /NOGUIDELINE, 0 IF /GUIDELINE
U.GUID:	BLOCK	1		;1 IF /GUIDELINE, 0 IF /NOGUIDELINE
U.CPPL:	BLOCK	1		;CURRENT PHYSICAL PAGE LIMIT
U.CVPL:	BLOCK	1		;CURRENT VIRTUAL PAGE LIMIT
U.SFDC:	BLOCK	1		;IF SFD CREATION IS DESIRED
U.SFDP:	BLOCK	1		;PROTECTION FOR CREATED SFD'S
U.UFDP:	BLOCK	1		;PROTECTION FOR CREATED UFD'S
U.DFPR:	BLOCK	1		;DEFAULT FILE PROTECTION
U.DFBU:	BLOCK	1		;DEFAULT BUFFERS COUNT
U.DFBB:	BLOCK	1		;DEFAULT BIGBUF
U.BYPA:	BLOCK	1		;BYPASS ACCOUNTING FILES
U.MAIL:	BLOCK	1		;MAILCHECK SWITCH
U.MODE:	BLOCK	1		;ATTACH MODE (MONITOR=0, USER=1)
U.SCAN:	BLOCK	1		;SCAN SWITCH FOR PATH UUO
U.STR:	BLOCK	1		;STRUCTURE SWITCH
U.QTA:	BLOCK	1		;FOR RECOMPUTING DISK USAGE ON STRS IN JSL
U.STA:	BLOCK	1		;STATION NUMBER
U.CLEA:	BLOCK	1		;CLEAR SCREEN
U.DISC:	BLOCK	1		;DISCONNECT LINE
U.KJOB:	BLOCK	1		;TYPE OF KJOB (BATCH, FAST)
U.NMSG:	BLOCK	1		;NO NOT PRINT KJOB MESSAGES
U.TEMP:	BLOCK	1		;DO NOT CHECK FOR .TMP FILES

U.ALTM:	BLOCK	1		;ALTMODE CONVERSION
U.BLNK:	BLOCK	1		;DO NOT TYPE BLANK LINES
U.CRLF:	BLOCK	1		;FREE CRLF AT RIGHT MARGIN
U.DBRK:	BLOCK	1		;DEBREAK (2741 TERM.)
U.DISP:	BLOCK	1		;DISPLAY MODE
U.ECHO:	BLOCK	1		;COMMAND LEVEL ECHO
U.LCP:	BLOCK	1		;LOCAL COPY
U.8BIT:	BLOCK	1		;EIGHTBIT
U.ESCA:	BLOCK	1		;ESCAPE CHARACTER
U.FILL:	BLOCK	1		;FILLER CLASS
U.FFHO:	BLOCK	1		;HOME ON FF
U.FFSI:	BLOCK	1		;SIMULATE FF WITH LF'S
U.FFST:	BLOCK	1		;STOP ON FF'S
U.FORM:	BLOCK	1		;TTY HAS FORM FEEDS
U.GAG:	BLOCK	1		;ALLOW SENDS ONLY AT MON. MODE OR RIGHT MARGIN
U.LC:	BLOCK	1		;TTY HAS LOWER CASE
U.LENG:	BLOCK	1		;TTY PAGE LENGTH
U.PAGE:	BLOCK	1		;^S-^Q MODE
U.PGSZ:	BLOCK	1		;PAGE SIZE
U.QUOT:	BLOCK	1		;QUOTE
U.RSPD:	BLOCK	1		;RECEIVE SPEED
U.RTC:	BLOCK	1		;/RTCOMPATABILITY
U.SBEL:	BLOCK	1		;TTY SBELL
U.SETT:	BLOCK	1		;/SETTTY /NOSETTY
U.SPED:	BLOCK	1		;XMIT/RCV SPEED
U.STOP:	BLOCK	1		;TTY STOP N
U.SSTO:	BLOCK	1		;TTY SSTOP N
T.STOP:	BLOCK	1		;TTY STOP BIT (NOT SET BY SCAN)
T.SSTO:	BLOCK	1		;TTY SSTOP BIT (NOT SET BY SCAN)
U.TABS:	BLOCK	1		;TTY HAS HARDWARE TABS
U.TAPE:	BLOCK	1		;XON STARTS PTR
U.TIDY:	BLOCK	1		;TTY IS TIDY
U.TTDE:	BLOCK	1		;DEFER TTY OUTPUT
U.TYPE:	BLOCK	1		;/TYPE
U.UC:	BLOCK	1		;TTY HAS UPPER CASE
U.UNPA:	BLOCK	1		;UNPAUSE CHARACTER
U.WDTH:	BLOCK	1		;CARRIAGE WIDTH
U.XONX:	BLOCK	1		;TTY XONXOFF
U.XSPD:	BLOCK	1		;XMIT SPEED

OOMAX:!			;END OF BLT FOR SCAN
;***END OF BLOCK SET TO -1 ON CALLS TO SCAN
RPERCT:	BLOCK	1		;FLAG FOR FILES FOUND WITH ERRORS
LSTPPN:	BLOCK	1		;LAST ACCESS PPN
LSTACC:	BLOCK	1		;LAST ACCESS UDT
LSTFLG:	BLOCK	1		;LAST ACCESS FLAGS
PASSWD:	BLOCK	.APWLW		;PASSWORD
NEWPSW:	BLOCK	.APWLW		;NEW PASSWORD
CHKPSW:	BLOCK	.APWLW		;CHECK PASSWORD
QUEBLK:	BLOCK	QUELEN		;QUEUE. UUO ARGUMENT BLOCK
RSPBLK:	BLOCK	RSPLEN		;QUEUE. UUO RESPONSE BLOCK
DATBLK:	BLOCK	QUELEN		;QUEUE. UUO DATA BLOCK
USERID:	BLOCK	.AANLW		;USER NAME
QERBLK:	BLOCK	3		;QUEUE. UUO ERROR BLOCK
QERTXT:	BLOCK	^D20+1		;QUEUE. UUO ERROR TEXT
TDATE:	BLOCK	1		;TODAY'S DATE
SAVOPR:	BLOCK	1		;PLACE TO SAVE NAME OF OPR'S TTY
SAOFST:	BLOCK	1		;STARTING ADDRESS OFFSET FOR SCAN
COMIDX:	BLOCK	1		;INVOKING COMMAND BIT,,INDEX
COMNAM:	BLOCK	1		;INVOKING COMMAND NAME (FOR OPTION SCANNING)
REPARS:	BLOCK	1		;REPARSE FLAG
FAILFL:	BLOCK	1		;LOGIN FAILURE FLAG
CNTLJT:	BLOCK	1		;CONTROLLING JOB'S LINE CHARACTERISTICS
CNTLJP:	BLOCK	1		;CONTROLLING JOB'S PPN
ATTJBN:	BLOCK	1		;JOB NUMBER TO ATTACH
ATTSTS:	BLOCK	1		;JOBSTS RESULT FOR ATTACH
ATTUAC:	BLOCK	1		;ATTACH UUO AC
INISCN:	BLOCK	1		;-1 IF IN .OSCAN
JOBCNT:	BLOCK	1		;COUNT OF JOBS IN JOBMAP
JOBPTR:	BLOCK	1		;AOBJN POINTER TO JOBMAP
JOBNUM:	BLOCK	1		;LAST JOB NUMBER FOUND BY MAPNXT
JOBMAP:	BLOCK	<^D512/^D36> 	;BIT MAP OF OTHER JOBS SAME PPN
TRNBLK:	BLOCK	.CHDB2+1	;CHTRN. UUO ARGUMENT BLOCK
ERRACS:	BLOCK	20		;SAVED AC'S DURING ERROR PROCESSOR

Z.BWTO:!			;START OF WTO AREA TO ZERO
WTOTYP:	BLOCK	1		;LENGTH,,ADDRESS OF "TYPE" TEXT
WTOSAV:	BLOCK	1		;SAVED CHARACTER TYPER
WTOPTR:	BLOCK	1		;BYTE POINTER
WTOCTR:	BLOCK	1		;BYTE COUNTER
WTOBFC:	BLOCK	<WTOCHN/5>+1	;STORAGE FOR WTO TO CTY TEXT
WTOBFO:	BLOCK	<WTOCHN/5>+1	;STORAGE FOR WTO TO OPR TEXT
WTOBLK:	BLOCK	.QUARV+3	;WTO MESSAGE BLOCK
WTOLEN==.-WTOBLK		;LENGTH OF BUFFER
Z.EWTO:!			;END OF WTO AREA TO ZERO
;***ARGUMENT BLOCK FOR LOGIN UUO****
LGNBLK:!			;START OF LOGIN UUO BLOCK
PPN:	BLOCK	1		;USERS PPN
PRIVWD:	BLOCK	1		;PRIV WORD
NAME:	BLOCK	1		;FIRST HALF OF USER NAME
NAME2:	BLOCK	1		;SECOND HALF OF USER NAME
CHGNO:	BLOCK	1		;CHARGE NUMBER
;;***END OF LOGIN WORD

ZZMAX:!				;END OF BLT TO ZERO

	END	START
