TITLE	NULL - COVER MODULE

COMMENT	\

THIS MODULE REPRESENTS WORK DONE BY HARVARD UNIVERSITY AND OTHERS IN THE
PUBLIC DOMAIN. THEREFORE, THIS MODULE IS NOT COPYRIGHTED BY DIGITAL
EQUIPMENT CORP.

\

PRGEND
	UNIVERSAL TULIP - PARAMETER FILE FOR USE WITH TULIP
	SUBTTL	E.A.TAFT/EJW/EAT	--	12-APR-75

	SEARCH	JOBDAT, MACTEN, UUOSYM	;STANDARD DEFINITIONS
	SALL			;PRETTY LISTINGS
	.DIRECT	FLBLST		;PRETTIER LISTINGS

IF1,<	END >

ND	FTBIG,-1		;ON FOR FEATURES LIKE MPX, SFD'S, ETC.
ND	FTDBUG,0		;ON TO ASSEMBLE CONSISTANCY CHECK CODE
ND	FTCREF,0		;OFF TO ELIMINATE A LOT OF USELESS CREFAGE
ND	FTCMU,0			;ON FOR STUFF LIKE CMUPPN PRINTING

GLOB	<FTDBUG,FTCREF,FTCMU,FTIMP>;TO LET LOADER FIND INCONSISTANCIES

;MACRO TO ASSEMBLE VERSION NUMBERS IN STANDARD DEC FORM
XP(%%%TLP,0)			;FIRST TIME THROUGH, NEEDS A VALUE

DEFINE VERSION(V,U,E,W,VAL) <
	%VVERS==V
	%VUPDA=="U"&77
	%VEDIT==E
	%VWHO==	W
DEFINE VERSTR <
	XX	V,U,E,W
>
IFNB <VAL>,<
VAL==	BYTE	(3) W (9) V (6) "U" (18) E
>IFB <VAL>,<
	LOC	137
	BYTE	(3) W (9) V (6) "U" (18) E
	RELOC
>
	XP(%%%TLP,%%%TLP)	;ENSURE THAT TULIP VERSION ENTERS SYMBOL TABLE
>
	VERSION(1,B,6,0,%TULIP)	;ASSIGN VERSION # FOR THOSE INTERESTED
	XP(%%%TLP,%VVERS)	;AND MAKE SPECIAL NOTE OF MAJOR VERSION
;ACCUMULATOR ASSIGNMENTS FOR UUO HANDLER PACKAGE.
;ALL AC'S ARE PROTECTED OVER UUO CALLS, EXCEPT FOR
;CERTAIN FLAGS IN THE FLAG REGISTER DESIGNATED FOR USE BY THE
;UUO HANDLER ALONE.

;*** GROUPED AC'S SHOULD NOT BE SEPARATED ***

	F=	0	;FLAGS

	T1=	1	;UTILITY AND SCRATCH.  USED FOR ARGUMENT PASSING
	T2=	2	;  AND RETURNING.  THESE ACCUMULATORS NOT NORMALLY
	T3=	3	;  PROTECTED ACROSS SUBROUTINE CALLS.
	T4=	4	;

	P1=	5	;PROTECTED REGISTERS.  NOT NORMALLY MODIFIED
	P2=	6	;  BY CALLED ROUTINES EXCEPT FOR "CONSTRUCTIVE"
	P3=	7	;  UPDATING OF VALUES IN REGISTERS USED AT
	P4=	10	;  HIGHER LEVELS.

	U1=	14	;HOLDS E FIELD OF UUO		*** PROTECTED
	U2=	15	;SECOND TEMP FOR UUO HANDLERS	*** BY UUO
	U3=	16	;HOLDS AC FIELD OF UUO		*** ROUTINES.

	P=	17	;PUSHDOWN POINTER

;MACRO FOR DEFINING FLAGS IN THE RH OF THE FLAG REGISTER.
;NOTE THAT ONLY ONE OTHER SUBPROGRAM (BESIDES TULIP.MAC) MAY INVOKE
;THE "FLAG" MACRO TO OBTAIN UNIQUE FLAGS.

	DEFINE	FLAG(L) <
IRP L	<IFNDEF L,<L==	1B<$FLAGN==$FLAGN-1>>
>>

	$FLAGN==^D36		;WE ASSIGN FLAGS FROM THE RIGHT


;FLAGS USED IN THE UUO HANDLER

	FLAG	(LZEFLG)	;LEADING ZEROES NOT TO BE SUPPRESSED
	SUBTTL	FILE MACRO

;MACRO FOR DEFINING A FILE BLOCK.
;   FORMAT IS AS FOLLOWS:
;	FILE	CH,DIR,LOC,<SPEC(ARG),SPEC(ARG), ... ,SPEC(ARG)
;		,SPEC(ARG),SPEC(ARG)>,<EXTRA, ... ,EXTRA>
;   WHERE THE FOLLOWING ARGUMENTS ARE REQUIRED:
;	CH =	USER CHANNEL NUMBER
;	DIR =	DIRECTION (I=INPUT, O=OUTPUT)
;	LOC =	WHERE BLOCK WILL RESIDE AT RUNTIME.
;   ALL OTHER PARAMETERS ARE OPTIONAL:
;	SPEC(ARG) MAY BE ANY OF THE FOLLOWING:
;	    DEV(N)	DEVICE NAME IS N (DEFAULT = DSK)
;	    NAME(N)	FILE NAME IS N (DEFAULT = BLANK)
;	    EXT(N)	FILE EXTENSION IS N (DEFAULT = BLANK)
;	    PPN(N)	PROJECT-PROGRAMMER NUMBER (DEFAULT=0)
;			 NOTE: COMMAS MAY NOT BE USED IN N, SO EITHER DEFINE A
;			 SYMBOL OR USE THE FORM PPN(1B17+4) FOR [1,4]
;	    STATUS(S)	INITIAL FILE STATUS (DEFAULT = 0)
;	    OPEN(L)	L IS LABEL OF USER-SUPPLIED ERROR ROUTINE
;			FOR HANDLING OPEN ERROR (DEFAULT= ILERI1,ILERO1)
;	    LOOKUP(L)	LOOKUP ERROR (DEFAULT = ILERI2,ILERO2)
;	    ENTER(L)	ENTER ERROR (SAME FIELD AS LOOKUP)
;	    INPUT(L)	INPUT ERROR (DEFAULT = ILERI3,ILERO3)
;	    OUTPUT(L)	OUTPUT ERROR (SAME FIELD AS INPUT)
;	    EOF(L)	END-OF-FILE (DEFAULT = ILERI3,ILERO3)
;	    OTHER(L)	LOW-SEGMENT LOCATION OF MATING FILE BLOCK
;			IF INPUT AND OUTPUT TO BE DONE ON THE SAME CHANNEL
;	    <INST(<I>)>	PROGRAMMER-SUPPLIED BYTE INPUT/OUTPUT INSTRUCTION
;			(DEFAULT = PUSHJ P,I1BYTE OR O1BYTE)
;	    BUFIO(L)	ROUTINE CALLED TO DO BUFFER INPUT/OUTPUT
;			(DEFAULT = I1BUFF/O1BUFF)
;	EXTRA	THESE ARE VALUES THAT WILL BE MOVED TO THE LOSEG AFTER THE
;		REST OF THE FILE BLOCK IS SET UP. THE FIRST ONE WILL HAVE THE
;		BE OFFSET BY FILFEX WORDS FROM THE START OF THE BLOCK, THE
;		SECOND BY FILFEX+1, ETC. N. B. THIS EXTRA SPACE MUST BE
;		ALLOCATED IN THE LOSEG FILE BLOCK!!
;   EACH COMMA IN THE FILE MACRO MUST IMMEDIATELY PRECEDE A SPECIFIER.

;MACRO FOR DEFINING A PSEUDO-FILE BLOCK
;   FORMAT IS AS FOLLOWS:
;	PFILE	LOC,<INST>,<EXTRA>
;   WHERE THE FOLLOWING ARGUMENTS ARE REQUIRED:
;	LOC =	WHERE BLOCK WILL RESIDE AT RUNTIME
;	INST =	INSTRUCTION TO EXECUTE TO READ/WRITE 1 BYTE
;	EXTRA =	OPTIONAL LIST OF EXTRA WORDS TO BE ASSEMBLED IN
;		THE INITIAL FILE BLOCK, EXACTLY AS IN THE FILE MACRO,
;		EXCEPT THAT THE OFFSET IS FILPEX.
DEFINE FILE(CH,DIR,LOC,SP,EXTRA) <
	.XCREF
	$DEFLT	<DEV>,SIXBIT/DSK/
	$DEFLT	<NAME,EXT>,SIXBIT//
	$DEFLT	<STATUS,OTHER,PPN>,0
	$DEFLT	<OPEN>,ILER'DIR'1##
	$DEFLT	<LOOKUP>,ILER'DIR'2##
	$DEFLT	<INPUT,EOF>,ILER'DIR'3##
	$DEFLT	<INST>,<PUSHJ	P,DIR'1BYTE##>
	$DEFLT	<BUFIO>,DIR'1BUFF##
IRP SP	<CONC F$,SP>
	ZZ==	<$FIBTS==0>
	$FILOC==.
	RELOC	.+2	;;FILL IN THESE LATER ON
	ALWNZ<V$INST>	;;FILXCT--INPUT/OUTPUT A CHAR INSTRUCTION
	IFNZ<0>		;;FILBAK--BACKUP INPUT CHARACTER
	IFNZ<0>		;;FILCUR--CURRENT INPUT CHARACTER
	IFNZ<<CH>B12>	;;FILCHN--FILE CHANNEL NUMBER
	IFNZ<V$STAT>	;;FILSTS--INITIAL FILE STATUS
	IFNZ<V$DEV>	;;FILDEV--DEVICE NAME
IFIDN<DIR><I>,<
	ALWNZ<V$OTHER,,LOC+FILHDR> ;;FILHDP--INPUT HEADER PTR FOR OPEN
>
IFIDN<DIR><O>,<
	ALWNZ<LOC+FILHDR,,V$OTHER> ;;FILHDP--OUTPUT HEADER PTR FOR OPEN
>
IFIDN<DIR><A>,<
	ALWNZ<LOC+FILHDR,,LOC+FILHDR> ;;FILHDP--HEADER PTR FOR APPEND
>
	IFNZ<V$NAME>	;;FILNAM--FILE NAME
	IFNZ<V$EXT>	;;FILEXT--EXTENSION
	IFNZ<0>		;;FILDAT--DATE, PROT, MODE, ETC.
	IFNZ<V$PPN>	;;FILPP1--PROJ-PROG FOR LOOKUP/ENTER
	IFNZ<V$PPN>	;;FILPPN--PROG-PROG FOR RESTORING FILPP1
	IFNZ<0>		;;FILHDR--RING POINTER
	IFNZ<0>		;;FILPTR--BYTE POINTER
	IFNZ<0>		;;FILCTR--BYTE COUNTER
IFN FTBIG,<
	IFNZ<0>		;;FILMPX--MULTIPLEX CHANNEL UNIVERSAL IO INDEX
>
	ALWNZ<V$BUFI>	;;FILBIO--BUFFER IO ROUTINE
	ALWNZ<V$OPEN,,V$LOOK> ;;FILER1--OPEN,,LOOKUP/ENTER ERROR DISPATCH
	ALWNZ<V$EOF,,V$INPUT> ;;FILER2--EOF,,INPUT/OUTPUT ERROR DISPATCH
IFNB <EXTRA>,<IRP EXTRA<
	ALWNZ<EXTRA>		;;ANY NUMBER OF ADDITIONAL WORDS
>>
	$FILC1==.
	RELOC	$FILOC
	EXP	$FIBTS	;;FHDBTS--REL. LOCATIONS OF NONZERO WORDS
	-ZZ,,LOC	;;FHDLOC--FOR SETTING UP FILE BLOCK
	RELOC	$FILC1
	.CREF
>
	DEFINE	$DEFLT(L,V) <
IRP L	<DEFINE	V$'L	<V>>
>
	DEFINE	F$DEV(N)	<DEFINE	V$DEV	<SIXBIT/N/>>
	DEFINE	F$NAME(N)	<DEFINE	V$NAME	<SIXBIT/N/>>
	DEFINE	F$EXT(N)	<DEFINE	V$EXT	<SIXBIT/N/>>
	DEFINE	F$PPN(N)	<DEFINE V$PPN	<N>>
	DEFINE	F$STAT(N)	<DEFINE	V$STAT	<N>>
	DEFINE	F$OPEN(L)	<DEFINE	V$OPEN	<L>>
	DEFINE	F$LOOK(L)	<DEFINE	V$LOOK	<L>>
	SYN	F$LOOK,F$ENTER
	DEFINE	F$INPU(L)	<DEFINE	V$INPU	<L>>
	SYN	F$INPU,F$OUTP
	DEFINE	F$BUFI(L)	<DEFINE V$BUFI	<L>>
	DEFINE	F$EOF(L)	<DEFINE	V$EOF	<L>>
	DEFINE	F$OTHER(L)	<DEFINE V$OTHE	<L+FILHDR>>
	DEFINE	F$INST(I)	<DEFINE	V$INST	<I>>

DEFINE PFILE(LOC,INST,EXTRA) <
	.XCREF
	ZZ==	<$FIBTS==0>
	$FILOC==.
	RELOC	.+2	;;THESE WILL BE FILLED LATER
	ALWNZ<INST>	;;FILXCT--INPUT/OUTPUT A CHAR INSTRUCTION
	IFNZ<0>		;;FILBAK--BACKUP INPUT CHARACTER
	IFNZ<0>		;;FILCUR--CURRENT INPUT CHARACTER
	IFNZ<0>		;;FILCHN--OTHER STUFF FOR UUO HANDLER
IFNB <EXTRA>,<IRP EXTRA <
	ALWNZ<EXTRA>	;;ANY NUMBER OF ADDITIONAL WORDS
>>
	$FILC1==.
	RELOC	$FILOC
	EXP	$FIBTS	;;FHDBTS--REL. LOCATIONS OF NONZERO WORDS
	-ZZ,,LOC	;;FHDLOC--FOR SETTING UP PSEUDO-FILE BLOCK
	RELOC	$FILC1
	.CREF
>

DEFINE IFNZ(WORD) <
IFN <WORD>,<
	WORD
	$FIBTS==$FIBTS!1B<ZZ>
>
	ZZ==	ZZ+1
>

DEFINE ALWNZ(WORD) <
	WORD
	$FIBTS==$FIBTS!1B<ZZ>
	ZZ==	ZZ+1
>
;MNEMONICS FOR RELATIVE LOCATIONS IN A FILE BLOCK

	PHASE	0		;DEFINE OFFSET SYMBOLS
FILXCT::!BLOCK	1		;INSTRUCTION TO XCT TO INPUT/OUTPUT A BYTE
FILBAK::!BLOCK	1		;BACKUP CHARACTER
FILCUR::!BLOCK	1		;CURRENT CHARACTER
FILCHN::!BLOCK	1		;CHANNEL # IN BITS 9-12 (IF REAL FILE BLOCK)
	  BAKFLG==1B35		;BACKUP FLAG
FILPEX::!			;START OF EXTRA DATA IN PSEUDO FILE BLOCKS
PBSIZE::!			;PSEUDO-FILE LENGTH, NOT COUNTING EXTRA DATA

;THE FOLLOWING LOCATIONS ARE PRESENT ONLY IN A REAL FILE BLOCK

FILSTS::!BLOCK	1		;INITIAL CHANNEL FILE STATUS
FILDEV::!BLOCK	1		;DEVICE NAME IN SIXBIT
FILHDP::!BLOCK	1		;[LH]OUTPUT, [RH]INPUT POINTER TO RING HEADER
FILNAM::!BLOCK	1		;FILE NAME IN SIXBIT
FILEXT::!BLOCK	1		;[LH] EXTENSION, [RH] ACCESS DATE, ERROR CODE
FILDAT::!BLOCK	1		;PROTECTION, MODE, TIME, DATE
FILPP1::!BLOCK	1		;PPN, SIZE, OTHER JUNK (CLOBBERED BY LOOKUP,ENTER)
FILPPN::!BLOCK	1		;PROJECT,PROGRAMMER NUMBER (MOVED TO FILPP1)
FILHDR::!BLOCK	1		;CURRENT BUFFER POINTER		*** BUFFER
FILPTR::!BLOCK	1		;BYTE POINTER			*** RING
FILCTR::!BLOCK	1		;BYTE COUNTER			*** HEADER
IFN FTBIG,<
FILMPX::!BLOCK	1		;UNIVERSAL IO INDEX		*** MPX DATA
>
FILBIO::!BLOCK	1		;[LH] RESERVED [RH] BUFFER IO ROUTINE
FILER1::!BLOCK	1		;[LH] OPEN [RH] LOOKUP/ENTER ERROR DISPATCH
FILER2::!BLOCK	1		;[LH] EOF [RH] INPUT/OUTPUT ERROR DISPATCH
FILFEX::!			;START OF USER'S EXTRA DATA
FBSIZE::!			;FILE BLOCK LENGTH, NOT COUNTING EXTRA DATA
	DEPHASE			;BACK TO NORMAL DEFINITIONS

;HISEG DEFINITIONS. USERS SHOULD HAVE NO NEED FOR THIS.
	FHDBTS==0	;NONZERO MARKING BITS FOR SETTING UP FILE BLOCK
	FHDLOC==1	;AOBJN POINTER FOR SETTING UP FILE BLOCK
	FHDOFS==2	;OFFSET OF FIRST REAL DATA WORD IN HISEG BLOCK
	SUBTTL	STRING/TABLE ACCUMULATION MACROS

;DEFINITIONS NEEDED TO APPEND ITEMS TO A LIST AND THEN EXTRACT
;THEM ALL FOR ASSEMBLY IN A SINGLE PLACE

DEFINE APPEND(DEF,ITEM) <
	DEFINE DEF(XX,MORE) <XX DEF,<ITEM,MORE>>
>
DEFINE EXPAND(DEF,OP) <
	DEFINE $OPMAC(A,ITEM) <IRP ITEM <IFNB <ITEM>,<OP>>>
	DEF($OPMAC)
>

REPEAT 0,<
USAGE:
  APPEND(NAME)  --  INITIALIZE A LIST CALLED "NAME"
  NAME(APPEND,ITEM)  --  APPEND THE STRING "ITEM" TO THE LIST "NAME"
  EXPAND(NAME,OPERATION)  --  PERFORM THE "OPERATION" ON ALL "ITEM"S
				IN THE LIST "NAME"

EXAMPLE:

INITIALIZE:
	APPEND(FOO)

APPEND ITEMS TO LIST
	FOO(APPEND,123)
	FOO(APPEND,"X")
	FOO(APPEND,76543)

EXPAND LIST:
	EXPAND(FOO,<PRINTX ITEM>)

EXPAND LIST USING DIFFERENT OPERATION:
FOOLST:	EXPAND(FOO,<EXP ITEM>)
> ;END REPEAT 0
	SUBTTL	CHARACTER CONSTANTS

	NULL==	000	;CHAR CODE FOR NULL
	BELL==	007	;BELL
	TAB==	011	;TAB
	LF==	012	;LINE FEED
	VT==	013	;VERTICAL TAB
	FF==	014	;FORM FEED
	CR==	015	;CARRIAGE RETURN
	CTRLZ==	032	;CONTROL-Z
	ALT==	033	;ALTMODE
	DBLQ==	042	;DOUBLE QUOTE
	SNGLQ==	"'"	;SINGLE QUOTE
	LPAREN=="("	;LEFT PAREN
	RPAREN==")"	;RIGHT PAREN
	COMMA==	","	;COMMA
	SEMI==	";"	;SEMICOLON
	LANGLE=="<"	;LEFT ANGLE BRACKET
	RANGLE==">"	;RIGHT ANGLE BRACKET
	LSQUAR=="["	;LEFT SQUARE BRACKET
	RSQUAR=="]"	;RIGHT SQUARE BRACKET
	RUBOUT==177	;RUBOUT

	CRLF==	<CR>B28+LF ;CARRIAGE RETURN, LINE FEED
	SUBTTL	ATTRIBUTES OF ALL ASCII CHARACTERS

REPEAT 0,<
THE MACRO CALL:
	CLASS	NAME,<DESCRIPTION>
DEFINES "NAME" TO BE A CHARACTER CLASS AND ASSIGNS IT THE VALUE
OF THE NEXT CLASS BIT FROM THE RIGHT.  "DESCRIPTION" IS ONE OR
MORE OF THE FOLLOWING (SEPARATED BY COMMAS):
	RANGE <L1,U1,L2,U2, ... ,LN,UN>
DECLARES ALL CHARACTERS WITH CODES IN RANGES L1-U1, L2-U2, ... ,
LN-UN (INCLUSIVE) TO BE IN THE CLASS BEING DEFINED.
	CODES <A,B, ... ,N>
DECLARES THE CHARACTERS WITH CODES A, B, ... ,N TO BE IN THE
CLASS BEING DEFINED.

USER PROGRAMS MAY DEFINE CHARACTER CLASSES IN ADDITION TO THE
ONES DEFINED IN TULIP.  THE "CLASS" MACRO IS CALLED IN EXACTLY
THE SAME MANNER AS SHOWN BELOW.  THIS SHOULD BE DONE EITHER
AT THE BEGINNING OF THE USER'S PROGRAM (IF IT CONSISTS OF ONLY
ONE FILE) OR IN A SEPARATE UNIVERSAL FILE SEARCHED BY ALL THE
USER MODULES.  IF THIS IS DONE, THE "CHRTAB" MACRO MUST BE
CALLED SOMEWHERE IN ONE OF THE USER PROGRAMS TO ASSEMBLE THE
CHARACTER CLASS TABLE (PREFERABLY IN A REGION OF HIGH-SEGMENT
RELOCATION).  HOWEVER, IF NO ADDITIONAL CLASSES ARE DEFINED, THE
CHRTAB MACRO NEED NOT BE CALLED (THOUGH IT WILL DO NO HARM).
IN ANY EVENT, NEITHER TULIP NOR TULLIB NEED BE MODIFIED OR
REASSEMBLED.
> ;END REPEAT 0

	APPEND	($CLASS)	;INITIALIZE DEFINITION MACRO

DEFINE CLASS(NAME,DESC) <
IFNDEF NAME,<		;;ONLY DO THIS ONCE
	NAME==	1B<^D36-<$CHFLN==$CHFLN+1>>
IFG $CHFLN-^D18,<PRINTX ?TOO MANY CHARACTER CLASSES>

	$CLASS	(APPEND,<<CLASS(NAME,<DESC>)>>)
>>
	$CHFLN==0		;INIT CLASS NUMBER

;DECLARE ALL CHARACTER CLASSES DEFINED IN TULIP

	CLASS	LETTER,<RANGE<"A","Z",141,172>>
	CLASS	DIGIT,<RANGE<"0","9">>
	CLASS	BLANK,<CODES<" ",TAB,NULL>>
	CLASS	BREAK,<CODES<BELL,LF,VT,FF,CTRLZ,ALT>>
	CLASS	LGLSIX,<RANGE<040,137>>

;THIS IS THE MACRO THAT EVENTUALLY ASSEMBLES THE CHARACTER CLASS TABLE

DEFINE CHRTAB <
	.XCREF			;CLEAN UP CREF LISTING

;FIRST, DETERMINE THE CODES FOR EACH OF THE ASCII CHARACTERS AND
;   STORE THEM AS $CDXXX, WHERE XXX IS THE ASCII CHARACTER CODE.

	SALL

;SET $CDXXX TO ZERO INITIALLY, FOR XXX=0-177

	ZZ==	-1
REPEAT 200,<
	CONC	($CD,\<ZZ==ZZ+1>,==0)
>

;DETERMINE THE CLASSES ASSOCIATED WITH EACH CHARACTER

DEFINE CLASS(NAME,DESC) <
	$THSCL==NAME		;;REMEMBER CURRENT CLASS
IRP DESC <			;;DO EACH OPERATION FOR THIS CLASS
	DESC
>>

;  RANGE <L1,U1,L2,U2, ... ,LN,UN> DECLARES ALL CHARACTERS
;   WITH CODES IN RANGES L1-U1, L2-U2, ... , LN-UN TO BE IN
;   CURRENT CLASS

DEFINE RANGE(L) <
	$RNGCT==0
IRP L	<
IFN <$RNGCT==1-$RNGCT>,<
	ZZ==	L
>
IFE $RNGCT,<
REPEAT <L>-ZZ+1,<
	CONC	($CD,\ZZ,==$THSCL!$CD,\ZZ)
	ZZ==	ZZ+1
>>>>

;  CODES <A,B,C,D,E> DECLARES CHARACTERS WITH CODES A,B,C,D,E
;   TO BE IN CURRENT CLASS

DEFINE CODES(L) <
IRP L	<
	CONC	($CD,\L,==$THSCL!$CD,\L)
>>

;STILL IN "CHRTAB" MACRO DEFINITION
;NOW INVOKE THE "$CLASS" MACRO TO DEFINE $CD0-$CD177

	EXPAND	($CLASS,CONC ITEM)

;ASSEMBLE CHARACTER FLAG TABLE ITSELF

CHRTAB::BYTE($CHFLN)	$CD0,$CD1,$CD2,$CD3,$CD4,$CD5,$CD6,$CD7,$CD10,$CD11,$CD12,$CD13,$CD14,$CD15,$CD16,$CD17,$CD20,$CD21,$CD22,$CD23,$CD24,$CD25,$CD26,$CD27,$CD30,$CD31,$CD32,$CD33,$CD34,$CD35,$CD36,$CD37,$CD40,$CD41,$CD42,$CD43,$CD44,$CD45,$CD46,$CD47,$CD50,$CD51,$CD52,$CD53,$CD54,$CD55,$CD56,$CD57,$CD60,$CD61,$CD62,$CD63,$CD64,$CD65,$CD66,$CD67,$CD70,$CD71,$CD72,$CD73,$CD74,$CD75,$CD76,$CD77,$CD100,$CD101,$CD102,$CD103,$CD104,$CD105,$CD106,$CD107,$CD110,$CD111,$CD112,$CD113,$CD114,$CD115,$CD116,$CD117,$CD120,$CD121,$CD122,$CD123,$CD124,$CD125,$CD126,$CD127,$CD130,$CD131,$CD132,$CD133,$CD134,$CD135,$CD136,$CD137,$CD140,$CD141,$CD142,$CD143,$CD144,$CD145,$CD146,$CD147,$CD150,$CD151,$CD152,$CD153,$CD154,$CD155,$CD156,$CD157,$CD160,$CD161,$CD162,$CD163,$CD164,$CD165,$CD166,$CD167,$CD170,$CD171,$CD172,$CD173,$CD174,$CD175,$CD176,$CD177

	ZZ==	-1		;CLEAN UP SYMBOL TABLE
REPEAT 200,<
	CONC	(PURGE $CD,\<ZZ==ZZ+1>)
>

	XALL
	.CREF			;RESTORE CREF OUTPUT

	$NCHFL==:$CHFLN		;NUMBER OF CLASSES, FOR OUTSIDE USE
	$NBYPW==:^D36/$NCHFL	;NUMBER OF CHAR CLASS BYTES / WORD
	$CFMSK==:1_$NCHFL-1	;MASK FOR ALL CLASS BITS
> ;END CHRTAB MACRO DEF
	SUBTTL	DEFINITION OF USER UUO'S

REPEAT 0,<
THE MACRO CALL:
	UUO (UUONAME,DISPATCH,SUBUUOS)
DEFINES THE UUO "UUONAME" TO BE THE NEXT USER UUO IN SEQUENCE
AND REMEMBERS "DISPATCH" AND "SUBUUOS" (IF PRESENT) FOR EVENTUAL
EXPANSION TO YIELD THE UUO DISPATCH TABLE.  "DISPATCH", IF PRESENT,
SPECIFIES THE LABEL TO WHICH THE UUO IS TO BE DISPATCHED (WHICH
MUST BE INTERNAL TO TULLIB OR THE USER'S PROGRAM).  IF ABSENT,
IT IS DEFAULTED TO "U" CONCATENATED WITH THE UUO NAME.  "SUBUUOS",
IF PRESENT, SPECIFIES THE NAMES OF UP TO 16 SUB-UUOS OF "UUONAME"
TO BE DISTINGUISHED BY THE CONTENTS OF THE AC FIELD OF THE UUO.
SEE THE DEFINITIONS BELOW FOR REQUIRED SYNTAX.  IF "DISPATCH" IS
ABSENT, THE SUBUUOS ARE AUTOMATICALLY DISPATCHED TO THE LABEL
"U" CONCATENATED WITH THE SUBUUO NAME, FOR EACH INDIVIDUAL SUBUUO.
IF "DISPATCH" IS PRESENT, ALL SUBUUOS ARE DISPATCHED TO "DISPATCH"
AND THE CODE DISPATCHED TO IS RESPONSIBLE FOR DISTINGUISHING 
BETWEEN SUBUUOS.

USER PROGRAMS MAY DEFINE UUOS AND SUBUUOS IN ADDITION TO THE
ONES DEFINED IN TULIP.  THE UUO MACRO IS CALLED IN EXACTLY
THE SAME MANNER AS SHOWN BELOW.  THIS SHOULD BE DONE EITHER
AT THE BEGINNING OF THE USER'S PROGRAM (IF IT CONSISTS OF ONLY
ONE FILE) OR IN A SEPARATE UNIVERSAL FILE SEARCHED BY ALL THE
USER MODULES.  IF THIS IS DONE, THE "UUOTAB" MACRO MUST BE
CALLED SOMEWHERE IN ONE OF THE USER PROGRAMS TO ASSEMBLE THE
UUO DISPATCH TABLE (PREFERABLY IN A REGION OF HIGH-SEGMENT
RELOCATION).  HOWEVER, IF NO ADDITIONAL UUOS ARE DEFINED, THE
UUOTAB MACRO NEED NOT BE CALLED (THOUGH IT WILL DO NO HARM).
IN ANY EVENT, NEITHER TULIP NOR TULLIB NEED BE MODIFIED OR
REASSEMBLED.
> ;END REPEAT 0

	APPEND	($UUOS)		;INITIALIZE DEFINITION MACRO

DEFINE UUO(NAME,LABEL,SUBS) <
IFNDEF NAME,<			;;ONLY DO THIS ONCE
	$UUON==$UUON+1		;;USE NEXT OPCODE
IFB <SUBS>,<			;;DEFINE NAME ONLY FOR USED UUOS
	OPDEF	NAME	[<$UUON>B8]
>IFNB <SUBS>,<
	ZZ==	0
	SUBS
IFN FTDBUG,<$'OP==ZZ>		;;MAX SUBUUO # FOR RANGE CHECK
IFG ZZ-20,<
	PRINTX	?TOO MANY SUBUUOS OF NAME
>>
	$UUOS	(APPEND,<<$UUO(NAME,LABEL,<SUBS>)>>)
>> ;END UUO MACRO DEF

DEFINE SUUO(NAME,LABEL) <
	OPDEF	NAME	[BYTE(9)$UUON(4)ZZ]
	ZZ==	ZZ+1
>

	$UUON==	-1		;INIT UUO OPCODE
;DECLARE ALL UUOS AND SUBUUOS USED BY TULIP

	UUO	(UUO000,CPOPJ)	;;ILLEGAL UUO 000
	UUO	(FWRT,,<	;;WRITE TO FILE
	  SUUO	(WCH)		;;WRITE ONE CHARACTER
	  SUUO	(WCHI)		;;WRITE ONE CHARACTER IMMEDIATE
	  SUUO	(W2CH)		;;WRITE TWO CHARACTERS (ASCII ONLY)
	  SUUO	(W2CHI)		;;WRITE TWO CHARACTERS IMMEDIATE (ASCII ONLY)
	  SUUO	(WASC)		;;WRITE ASCII STRING
	  SUUO	(EWASC)		;;WRITE ASCII STRING TO ERROR DEVICE
	  SUUO	(DIASC)		;;WRITE ASCII EDIT LIST
	  SUUO	(EDIASC)	;;WRITE ASCII EDIT LIST TO ERROR DEVICE
	  SUUO	(DISIX)		;;WRITE SIXBIT EDIT LIST
	  SUUO	(EDISIX)	;;WRITE SIXBIT EDIT LIST TO ERROR DEVICE
	  SUUO	(EWSIX)		;;WRITE SIXBIT STRING TO ERROR DEVICE
	>)
	UUO	(WSIX)		;;WRITE SIXBIT STRING (AC FIELD = LENGTH)
	UUO	(WDEC)		;;WRITE DECIMAL NUMBER (AC FIELD = LENGTH)
	UUO	(WDECI)		;;WRITE DECIMAL NUMBER IMMEDIATE
	UUO	(WOCT)		;;WRITE OCTAL NUMBER
	UUO	(WOCTI)		;;WRITE OCTAL NUMBER IMMEDIATE
	UUO	(FUTIL,UFUTIL,<	;;FILE UTILITY UUOS
	  SUUO	(FISEL)		;;SELECT INPUT FILE BLOCK
	  SUUO	(FOSEL)		;;SELECT OUTPUT FILE BLOCK
	  SUUO	(FIOPEN)	;;PERFORM INPUT OPEN AND LOOKUP
	  SUUO	(FOOPEN)	;;PERFORM OUTPUT OPEN AND ENTER
	  SUUO	(FIGET)		;;PERFORM JUST INPUT OPEN
	  SUUO	(FOGET)		;;PERFORM JUST OUTPUT OPEN
	  SUUO	(FLOOK)		;;PERFORM JUST INPUT LOOKUP
	  SUUO	(FENT)		;;PERFORM JUST OUTPUT ENTER
	  SUUO	(FICLOS)	;;PERFORM INPUT CLOSE AND RELEASE
	  SUUO	(FOCLOS)	;;PERFORM OUTPUT CLOSE AND RELEASE
	  SUUO	(FICLS)		;;PERFORM JUST INPUT CLOSE
	  SUUO	(FOCLS)		;;PERFORM JUST OUTPUT CLOSE
	  SUUO	(FREL)		;;PERFORM JUST RELEASE (INPUT OR OUTPUT)
	  SUUO	(..DMMY)	;;DUMMY
	  SUUO	(..DMMZ)	;;ANOTHER TO MAKE FAPEND LOOK LIKE OUTPUT
	  SUUO	(FAPEND)	;;PERFORM OPEN, LOOKUP/ENTER, AND SET FOR APPEND
	>)
;TULIP UUO DECLARATIONS (CONT'D)

	UUO	(FUTL2,,<	;;MORE FILE UTILITY UUOS
	  SUUO	(FSETUP)	;;SETUP LOW-SEGMENT FILE BLOCK
	  SUUO	(WNAME)		;;WRITE SIXBIT NAME WITHOUT TRAILING BLANKS
	  SUUO	(WPPN)		;;WRITE [PROJ,PROG] NUMBER
	  SUUO	(WNAMX)		;;WRITE FILENAME.EXTENSION
	  SUUO	(WFNAME)	;;WRITE DEVICE:FILENAME.EXTENSION[PROJ,PROG]
	  SUUO	(RCH)		;;READ NEXT CHARACTER
	  SUUO	(CCH)		;;FETCH CURRENT CHARACTER
	  SUUO	(LCH)		;;READ PREVIOUS CHARACTER
	  SUUO	(RFLG)		;;READ ATTRIBUTE FLAGS FOR GIVEN CHAR
	  SUUO	(RCHF)		;;READ NEXT CHAR AND FLAGS
	  SUUO	(CCHF)		;;FETCH CURRENT CHAR WITH FLAGS
	  SUUO	(LCHF)		;;READ PREVIOUS CHAR AND FLAGS
	>)
	UUO	(FERROR,UFERRO,< ;;ERROR PRINTOUT UUOS
	  SUUO	(WERIOP)	;;  OPEN
	  SUUO	(WEROOP)	;;    "
	  SUUO	(ERRIOP)	;;    "
	  SUUO	(ERROOP)	;;    "
	  SUUO	(WERLK)		;;  LOOKUP/ENTER
	  SUUO	(WERENT)	;;    "
	  SUUO	(ERRLK)		;;    "
	  SUUO	(ERRENT)	;;    "
	  SUUO	(WERIN)		;;  INPUT/OUTPUT
	  SUUO	(WEROUT)	;;    "
	  SUUO	(ERRIN)		;;    "
	  SUUO	(ERROUT)	;;    "
	>)

IFG $UUON-37,<
	PRINTX	?TOO MANY USER UUOS
>
;THIS IS THE MACRO THAT EVENTUALLY ASSEMBLES THE UUO DISPATCH TABLE

DEFINE UUOTAB <
;;GENERATE MAIN UUO DISPATCH TABLE

DEFINE $UUO(OP,LABEL,SUBS) <
IFB <LABEL>,<
	UUOD	(U'OP)		;;USE U'UUONAME IF LABEL NOT SPECIFIED
>
IFNB <LABEL>,<
	UUOD	(LABEL)		;;USE SPECIFIED LABEL IF GIVEN
>> ;;END $UUO MACRO DEF

	INTERN	UUOTAB
	HWDGEN	(UUOTAB,<EXPAND($UUOS,CONC ITEM)>,UUOD)

IFN FTDBUG,<$UUOMX==:$UUON>	;;MAX OPCODE, FOR DEBUGGING

;;GENERATE SUB-UUO DISPATCH CODE AND TABLES

DEFINE $UUO(OP,LABEL,SUBS) <
IFNB <SUBS>,<IFB <LABEL>,<
U'OP:
IFN FTDBUG,<
	CAIL	U3,$'OP		;;CHECK FOR SUBUUO IN RANGE
	JRST	SUBUER##	;;ERROR, GO COMPLAIN
>
	MOVEI	U2,2*<X'OP-UUOTAB>(U3) ;;RE-INDEX TO SUBUUO TABLE
	JRST	UUODSP##	;;RE-DISPATCH

	HWDGEN	(X'OP,<SUBS>,UUOD) ;;GENERATE SUBUUO DISPATCH TABLE
>>> ;;END $UUO MACRO DEF

DEFINE SUUO(OP,LABEL) <
IFB <LABEL>,<
	UUOD	(U'OP)		;;USE U'SUBUUO NAME IF LABEL NOT GIVEN
>
IFNB <LABEL>,<
	UUOD	(LABEL)		;;OTHERWISE, USE GIVEN NAME
>> ;;END SUUO MACRO DEF

	EXPAND	($UUOS,CONC ITEM)
> ;END UUOTAB MACRO DEF
	SUBTTL	USEFUL MACROS AND OPDEFS

;PERFORM INITIALIZATION OF THE UUO PACKAGE.
;   EVERY PROGRAM SHOULD BEGIN WITH THE FOLLOWING:
;	MOVE	P,[PUSHDOWN POINTER]
;	START

DEFINE START <
	SALL			;;SUPPRESS EXPANSION OF MOVX TYPES
	PUSHJ	P,USTART##	;;AND FIRE UP UUO PROCESSOR
>

;SAVE CALL FROM TOTAL DESTRUCTION BELOW

	OPDEF	MCALL	[CALL]	;USED MAINLY SITE SPECIFIC UUOS

;CALL AND RETURN FROM A SUBROUTINE

	OPDEF	CALL	[PUSHJ P,]
	OPDEF	RETURN	[POPJ P,]

;SAVE A LIST OF REGISTERS ON THE STACK

DEFINE SAVE(L) <
IRP L	<
	  PUSH	  P,L
>>

;RESTORE A LIST OF REGISTERS FROM THE STACK.  THEY SHOULD BE LISTED
;IN REVERSE ORDER OF THE CORRESPONDING SAVE.

DEFINE RESTORE(L) <
IRP L	<
	  POP	  P,L
>>

;DECLARE A GLOBAL SYMBOL
;   IF THE SYMBOL IS NOT DEFINED ON PASS 1 (E.G. AS A LABEL), IT
;   WILL STILL EXIST IN MACRO'S SYMBOL TABLE AT THE BEGINNING OF
;   PASS 2, BUT THE IFNDEF WILL BE TRUE, EVEN IF THE SYMBOL IS ALSO
;   A BUILT-IN OPCODE.  ALSO, MACRO CANNOT PURGE A PARTIALLY-DEFINED
;   SYMBOL;  HENCE THE NEED TO GIVE IT A VALUE BEFORE PURGING IT.

DEFINE GLOBAL(S) <
IF1,<	INTERN	S>
IF2,<IFNDEF S,<
	SYN	T1,S		;;GETS AROUND PROBLEM OF BLANKS BETWEEN
				;;  SYMBOL AND "=="
	PURGE	S
	EXTERN	S
>>>

;CONCATENATE UP TO FOUR QUANTITIES FOR ASSEMBLY ANYWHERE

	DEFINE	CONC(A,B,C,D) <A'B'C'D>
;MACRO FOR GENERATING A HALFWORD DISPATCH TABLE.
;   GIVEN A MACRO DEFINITION OF THE FORM:
;DEFINE MACRO <
;	SUBMAC	(LABEL1)
;	SUBMAC	(LABEL2)
;	 ...
;	SUBMAC	(LABELN)
;>
;   THE MACRO CALL:
;	HWDGEN	(LABEL,MACRO,SUBMAC,PREFIX)
;   GENERATES A DISPATCH TABLE OF THE FORM:
;LABEL:	PREFIXLABEL1 ,, PREFIXLABEL2
;	PREFIXLABEL3 ,,  ...
;	 ...	     ,, PREFIXLABELN
;   THE "LABEL" AND "PREFIX" ARGUMENTS MAY BE LEFT BLANK.

DEFINE HWDGEN(LABEL,MACRO,SUBMAC,PREFIX) <
	ZZ==	0	;;		;INIT ENTRY COUNTER
IFB <LABEL>,<
	ZZ==	2	;;		;SUPPRESS LABEL GENERATION IF BLANK
>
	DEFINE	SUBMAC(ARG,X,Y,Z) <;;	;ALLOW AND IGNORE EXTRA ARGS
	GLOBAL	(PREFIX''ARG)	;;	;DECLARE ARGUMENT GLOBAL
IFE ZZ,<
	DEFINE	$HWD(B) <	;;	;GENERATE LABEL IF REQUIRED
LABEL:	PREFIX''ARG	,, B	;;	;LEAVE RH VARIABLE FOR NEXT CALL
>>
IFN ZZ,<IFE ZZ&1,<	;;		;ARG IS DESTINED FOR LH OF WORD
	DEFINE	$HWD(B) <
	PREFIX''ARG	,, B	;;	;LEAVE RH VARIABLE FOR NEXT CALL
>>
IFN ZZ&1,<	;;			;ARG IS DESTINED FOR RH OF WORD
	$HWD	(PREFIX''ARG)	;;	;ASSEMBLE AND LIST THE WORD
	DEFINE	$HWD(B) <>	;;	;RESET FOR NEXT WORD
>>
	ZZ==	ZZ+1	;;		;INCREMENT ENTRY COUNTER
>;;					;END DEF OF SUBMAC WITHIN HWDGEN
	MACRO	;;			;ASSEMBLE THE TABLE
	$HWD	(0)	;;		;POLISH OFF LAST WORD IF REQ'D
>;;					;END DEF OF HWDGEN
;MACROS FOR GENERATING PRODUCTION TABLES.
;   A PRODUCTION TABLE IS IN THE FORM:
;TABLE:	XWD	T1,D$TABL
;	PROD(	..	..	..)
;	 ...	...	...		;ANY NUMBER OF PRODUCTIONS
;N$TABL:A.POPJ,,A.ACT1			;DISPATCH TABLE FOR ALL ACTIONS
;	A.ACT2,,A.ACT3			;  USED IN THE ABOVE PRODUCTIONS
;	 ...

;   THIS IS GENERATED THROUGH THE FOLLOWING MACRO CALLS:
;	TBLBEG	(NAME)
;   NAME = LABEL OF BEGINNING OF TABLE.  THIS IS USED IN THE CALL TO LEXINT.
;   THIS ASSEMBLES THE FIRST WORD OF THE TABLE, WHICH IS THE INDEXED
;   POINTER OFF TO THE ACTION DISPATCH TABLE.

;	PROD(	TEST	,ACTION	,SCAN,NEXT)
;   TEST = A CHARACTER CODE, OR A UNION OF CHARACTER CLASSES ENCLOSED
;	IN ANGLE BRACKETS, POSSIBLY PRECEDED BY "-".
;   ACTION = THE NAME OF AN ACTION ROUTINE (WHICH NEED NOT BE IN THE
;	SAME SUBPROGRAM).  THIS ACTION ROUTINE IS ACTUALLY CALLED A.ACTION.
;   SCAN = ONE OF "*", "_", OR " ", INDICATING FORWARD, REVERSE, OR NO
;	SCAN AFTER ACTION ROUTINE IS EXECUTED.  NOTE THAT LEXINT NOW
;	HAS ONLY A ONE-CHARACTER BACKUP CAPABILITY, BUT FOR ANY SOURCE
;	OF INPUT.
;   NEXT = LABEL OF NEXT PRODUCTION TO BE INTERPRETED.

;	TBLEND
;   THIS MACRO CALL IS REQUIRED!  IT FINISHES OFF THE TABLE BY GENERATING
;   THE HALFWORD ACTION DISPATCH TABLE AND PURGING ALL THE ACTION DEFINITIONS
;   IN PREPARATION FOR ASSEMBLING A NEW TABLE.
	DEFINE	TBLBEG(NAME) <
	INTERN	NAME
IFE FTDBUG,<
NAME:	XWD	T4,D$'NAME		;POINTER TO ACTION DISPATCH TBL
>
IFN FTDBUG,<
	XWD	T3,A$'NAME	;PTR TO ACTION NAME TBL, FOR TRACE
NAME:	400000+T3,,D$'NAME	;POINTER TO ACTION DISPATCH TBL
>
	PHASE	0	;;		;SO LABELS ARE RELATIVE TO BASE
	$ACTN==<N$POPJ==0>	;;	;INIT SOME VARIABLES
;; INITIALIZE THE $NWACT MACRO, WHICH ACCUMULATES NAMES OF ALL ACTIONS USED
	REDEF	<
	$ACT	(POPJ)
>
	DEFINE	$TBLFN <	;;	;THIS REMEMBERS THE NAME OF THE TABLE
	HWDGEN	(D$'NAME,<$NWACT<REPEAT 1,>>,$ACT,A.)
IFN FTDBUG,<
	DEFINE	$ACT(A) <;;	;THIS GENERATES AN ACTION NAME TABLE
A$'NAME:<ASCII/A/>&777777777400
	DEFINE	$ACT(B) <
	<ASCII/B/>&777777777400
>>
	$NWACT	<REPEAT 1,>
>>>
	DEFINE	PROD(TEST,ACTION,SCAN,NEXT) <
	$ANG==	<$NEG==0>	;;	;INIT SOME VARIABLES
IFNB <ACTION>,<IFNDEF N$'ACTION,<
	ZZ==	<$ACTN==$ACTN+1>;;	;ASSIGN NEXT ACTION NUMBER
	SYN	ZZ,N$'ACTION
	$NWACT	REDEF,<	$ACT	(ACTION) ;;REMEMBER NAME OF ACTION
>>>
IRPC TEST <TSTANG( TEST)>	;;	;TEST FOR ANGLE BRACKETS
	$TESTF==EXP	TEST	;;	;GET VALUE OF TEST FIELD
IFL $TESTF,<	;;			;IF TEST FIELD NEGATIVE
	$TESTF==-$TESTF	;;		;THEN NEGATE IT
	$NEG==	1	;;		;AND SET "-" FLAG
>
IFN $TESTF&NEGBIT,<	;;		;TEST FOR SG
	$NEG==	1
	$TESTF==0
>
IFNB <NEXT>,<$NEXT==NEXT>	;;	;IF NEXT NONBLANK, USE IT
IFB <NEXT>,<$NEXT==.+1>	;;		;ELSE USE .+1
	BYTE(1)IFIDN<SCAN><*>,<1>,IFIDN<SCAN><_>,<1>,$ANG,$NEG(6)IFNB<ACTION>,<N$'ACTION>(8)$NEXT(18)$TESTF
>

	DEFINE	TBLEND <
IFG .-377,<
	PRINTX	?PRODUCTION TABLE OVER 256 WORDS LONG
>
IFG $ACTN-77,<
	PRINTX	?OVER 63 ACTIONS IN ONE TABLE EXCEEDS WIDTH OF FIELD
>
	DEPHASE
	$TBLFN	;;			;GENERATE ACTION DISPATCH TABLE
	DEFINE	$ACT(S) <	;;	;PURGE ALL THE ACTION NUMBERS
	PURGE	N$'S
>
	$NWACT	<REPEAT 1,>
>

	DEFINE	REDEF(THIS) <
	DEFINE	$NWACT(OP,NEW) <
	OP	<THIS''NEW>
>>

	DEFINE	TSTANG(C) <
IFE ASCII\C\-2017B11,<$ANG==1>
>
;FORMAT OF A PRODUCTION WORD
;   BIT 0	- "*" BIT - MUST BE SIGN
;   BIT 1	- "_" BIT
;   BIT 2	- 0=CHAR TEST, 1=CLASS TEST
;   BIT 3	- "-" BIT
;   BITS 4-9	- ACTION NUMBER
;   BITS 10-17	- NEXT PRODUCTION
;   BITS 18-35	- CHAR OR FLAG BITS TO BE TESTED

	SCNBIT==1B0	;"*" BIT
	RSCBIT==1B1	;"_" BIT
	CLSBIT==1B2	;CHAR/CLASS BIT
	NEGBIT==1B3	;"-" BIT
	SG==	NEGBIT	;"SIGMA" DEFINED AS -<>



	END
