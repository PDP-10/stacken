TITLE	CISNUP - Snoop on CI Traffic
SUBTTL	Joseph A. Dziedzic /JAD	29-Jul-88


	SEARCH	JOBDAT, MACTEN, UUOSYM, KLPPRM, SCAPRM, SNUP
	.REQUI	REL:SNUP
	SALL

	LOC	.JBVER		;GET TO .JBVER
	EXP	1		;STORE A VERSION NUMBER
	RELOC
	SUBTTL	SNOOP Package Definitions

;Monitor data storage locations

	MONREF	<DATE>		;SYSTEM DATE IN INTERNAL FORMAT
	MONREF	<.CPCPN>	;OUR CPU NUMBER
	MONREF	<SAVT>		;USEFUL AC SAVE ROUTINE
	MONREF	<SSEC1>		;NICE WAY TO GET INTO SECTION 1
	MONREF	<SBLIST>	;SYSTEM BLOCK LIST HEADER
	MONREF	<PBLIST>	;PATH BLOCK LIST HEADER

;Breakpoints

	BRKPNT	CISPKR,PKTRCV	;BREAK TO RECORD PACKET RECEIVED
	BRKPNT	CISPKX,PKTXMT	;BREAK TO RECORD PACKET TRANSMITTED
	SUBTTL	Definitions

;ACs while in non-breakpoint code

	T1=1			;4 TEMPORARY ACS
	T2=2
	T3=3
	T4=4
	P1=5			;4 PRESERVED (USED BY COLCID)
	P2=6
	P3=7
	P4=10
	P5=11
	P6=12
	P=17			;PUSHDOWN LIST POINTER

;ACs while in breakpoint code are defined by SNUP, with the exception of:

	%Q2==%M			;Q2 NOT KNOWN TO SNUP
	%Q3==%U			;DITTO FOR Q3

;I/O channels

	LOG==1			;LOG FILE CHANNEL

;PI device definitions

	PI.ON==200		;TURN ON PI SYSTEM
	PI.OFF==400		;TURN OFF PI SYSTEM

;Number of maximal-sized blocks to allocate for track buffer

	TRKBKS==^D30		;MAKE A REASONABLE GUESS

;KLIPA CI operation codes

	OP.SDG==1		;SEND DATAGRAM
	OP.SMS==2		;SEND MESSAGE
	OP.RMT==40		;ON IN REMOTELY GENERATED RESPONSES
	SUBTTL	Tracking Log File Format

;The log file has two sections.  The first contains a number of
;blocks which contain information needed to convert a Connect ID
;to a Process Name string.  The second contains copies of all CI
;messages sent/received by the KLIPA software in the -10 (note
;that the KLIPA sends/receives some messages without the knowledge
;of the -10).

;CID info block format

	.ORG	0

.CILNK:!BLOCK	1		;LINK WORD (ONLY USED BY CITATL)
.CINOD:!BLOCK	1		;CI NODE NUMBER
.CICID:!BLOCK	1		;CONNECT ID
.CIPNS:!BLOCK	C%PNLW		;PROCESS NAME STRING
.CILEN:!			;LENGTH OF INFO BLOCK

	.ORG


;Track record format

	.ORG	0
.TKLEN:!BLOCK	1		;<R/X FLAG>B0 + <CPU>B3 + <OUR NODE>B11 +
				; <LENGTH OF ENTRY>B35
.TKDTM:!BLOCK	1		;SYSTEM DATE/TIME
.TKPKT:!			;START OF PACKET
				;MAX OF C%DGSZ/C%MGSZ WORDS HERE
	.ORG
	SUBTTL	Data Storage

PDLIST:	BLOCK	100		;PUSHDOWN LIST

TRKBUF:	BLOCK	1		;ADDRESS OF TRACKING BUFFER
TRKPTR:	BLOCK	1		;PUTTER INTO TRACKING BUFFER
TRKBSY:	BLOCK	1		;BUSY INTERLOCK ON TRACKING BUFFER

WRTBUF:	BLOCK	1		;ADDRESS OF "WRITE TO LOG FILE" BUFFER

CIDBUF:	BLOCK	.CILEN		;CID INFO BUFFER

CCLOCK:	BLOCK	1		;CONTROL-C INDICATOR
INTBLK:	XWD	4,CCINT		;LENGTH, WHERE TO GO ON INTERRUPT
	ER.ICC			;TYPE OF INTERRUPT
	EXP	0,0		;OLD PC AND CLASS

PKTADR:	BLOCK	1		;ADDRESS OF LAST PACKET
ENTLEN:	BLOCK	1		;LENGTH OF LAST PACKET
PKTRCD:	BLOCK	1		;NUMBER OF PACKETS RECORDED

OVERFL:	BLOCK	1		;NUMBER OF TIMES BUFFER OVERFLOWED

OBUF:	BLOCK	3		;BUFFER CONTROL BLOCK FOR LOG FILE
	SUBTTL	Initialization

START:	JFCL			;NO CCL ENTRY
	RESET			;RESET THE WORLD
	MOVE	P,[IOWD 100,PDLIST] ;SET UP A STACK

	HLRZ	T1,.JBSA	;GET ORIGINAL CORE SIZE
	MOVEM	T1,.JBFF	;RESET IN CASE OF RESTART

	OUTSTR	[ASCIZ /Initializing
/]
	PUSHJ	P,GETINF##	;LOOK UP SYMBOLS AND ETC.

;Compute size of tracking/write buffers and allocate space for them

	MOVEI	T1,C%DGSZ	;GET MAXIMUM DATAGRAM SIZE
	MOVEI	T2,C%MGSZ	;GET MAXIMUM MESSAGE SIZE
	CAMGE	T1,T2		;KEEP THE LARGEST IN T1
	MOVE	T1,T2
	IMULI	T1,TRKBKS	;TIMES NUMBER OF BLOCKS TO ALLOCATE
	MOVE	T2,T1		;GET A SECOND COPY
	LSH	T2,1		;TIMES TWO
	EXCH	T2,.JBFF	;SWAP WITH OLD .JBFF
	MOVEM	T2,TRKBUF	;SAVE START OF AREA
	MOVEM	T2,TRKPTR	; AND PUTTER
	MOVEM	T2,WRTBUF	; AND I/O BUFFER
	ADDM	T1,WRTBUF	;ADJUST
	ADDB	T2,.JBFF	;BUMP POINTER
	SUBI	T2,1		;BACK OFF
	CAMG	T2,.JBREL	;NEED THE SPACE?
	JRST	.+3		;NOPE
	CORE	T2,		;YES, ASK FOR IT
	  HALT	.		;SORRY
	SETOM	TRKBSY		;INITIALIZE LOCK ON BUFFER TO FREE STATE

;Allocate a buffer ring for writing the log file

	OPEN	LOG,[EXP .IOIMG, SIXBIT /DSK/, <XWD OBUF,0>]
	  HALT	.		;NO CAN DO
	OUTBUF	LOG,2		;BUILD THE BUFFER RING (2 SHOULD BE ENOUGH)
	MOVE	T1,[SIXBIT /CISNUP/] ;GET FILE NAME
	MOVSI	T2,'DAT'	;EXTENSION
	SETZB	T3,T4		;TAKE THESE DEFAULTS
	ENTER	LOG,T1		;ENTER THE FILE
	  HALT	.		;NO CAN DO
	OUTPUT	LOG,		;DUMMY FIRST OUTPUT

	OUTSTR	[ASCIZ	/Collecting CID information
/]
	PUSHJ	P,COLCID	;COLLECT CID INFO

	OUTSTR	[ASCIZ /Inserting breakpoints
/]
	MOVEI	T1,INTBLK	;POINT AT CONTROL-C INTERCEPT CONTROL BLOCK
	MOVEM	T1,.JBINT	;SAVE ADDRESS FOR MONITOR
	SETOM	CCLOCK		;LOCK AGAINST CONTROL-C
	SETZ	T1,		;NEED USRIO SO CAN CONTROL PI SYSTEM
	TRPSET	T1,		; SO BE CHEAP AND DO A TRPSET
	  HALT	.		;ERROR
	PUSHJ	P,XWRSNP##	;GET NOSY, BUT DON'T REDUCE CORE SIZE
	OUTSTR	[ASCIZ /Breakpoints inserted; type <CR> to stop
/]

LOOP:	SKIPLE	CCLOCK		;CONTROL-C TYPED?
	JRST	QUIT		;YES, QUIT NOW
	PUSHJ	P,WRTDAT	;WRITE ANY NEW DATA TO THE LOG FILE
	INCHRS	T1		;SEE IF ANYTHING THERE
	JRST	LOOP1		;NOPE
	TDZA	T1,T1		;REMEMBER TO TYPE SUMMARY
QUIT:	SETO	T1,		;NO SUMMARY WANTED
	OUTSTR	[ASCIZ /Terminating session/]
	JUMPN	T1,QUIT1	;JUMP IF NO SUMMARY WANTED
	OUTSTR	[ASCIZ /; recorded /]
	MOVE	T1,PKTRCD	;NUMBER RECORDED
	PUSHJ	P,TDECW		;PRINT IT
	OUTSTR	[ASCIZ / packets/]
QUIT1:	OUTSTR	[ASCIZ /
/]
	REMBRK			;REMOVE BREAKPOINTS
	UNDBRK			;UNDEFINE BREAKPOINTS
	CLOSE	LOG,		;CLOSE THE FILE
	SETZM	.JBINT		;CEASE INTERCEPTIONS
	EXIT			;DONE

LOOP1:	SKIPLE	CCLOCK		;CONTROL-C TYPED?
	JRST	QUIT		;YES, QUIT NOW
	SKIPG	T1,OVERFL	;ANY OVERFLOWS?
	JRST	LOOP2		;NOPE
	OUTSTR	[ASCIZ /%Buffer overflow during last second by /]
	PUSHJ	P,TDECW		;PRINT T1
	OUTSTR	[ASCIZ /
/]
	SETZM	OVERFL		;CLEAR THE FLAG

LOOP2:	MOVEI	T1,1		;GRAB A FEW ZZZ'S
	SLEEP	T1,		;(SNORE)
	JRST	LOOP		;SEE IF ANYTHING TO DO

TDECW:	IDIVI	T1,^D10		;SPLIT OFF DIGITS
	HRLM	T2,(P)		;STORE ON STACK
	SKIPE	T1		;DONE?
	PUSHJ	P,TDECW		;NO, RECURSE
	HLRZ	T1,(P)		;GET A DIGIT
	ADDI	T1,"0"		;ASCII-IZE IT
	OUTCHR	T1		;OUTPUT IT
	POPJ	P,		;RETURN
;Write any new data to the log file

WRTDAT:	MOVE	T1,TRKPTR	;GET TRACKING BUFFER PUTTER
	CAMN	T1,TRKBUF	;ANYTHING BEEN LOGGED?
	POPJ	P,		;NO, RETURN
	CONO	PI,PI.OFF	;PREVENT KAFS
	SKIPGE	TRKBSY		;WAIT UNTIL BUFFER IS AVAILABLE FOR OUR USE
	AOSE	TRKBSY		;THEN GRAB THE LOCK
	JRST	.-2		;...
	MOVE	T1,TRKPTR	;GET THE PUTTER
	SUB	T1,TRKBUF	;DETERMINE HOW MANY WORDS WERE FILLED
	MOVS	T2,TRKBUF	;SOURCE OF BLT
	HRR	T2,WRTBUF	;DESTINATION
	MOVE	T3,T1		;COPY LENGTH
	ADD	T3,WRTBUF	;COMPUTE END +1
	BLT	T2,-1(T3)	;COPY THE DATA
	MOVE	T2,TRKBUF	;RESET PUTTER
	MOVEM	T2,TRKPTR	;...
	SETOM	TRKBSY		;DONE WITH BUFFER
	CONO	PI,PI.ON	;ALLOW INTERRUPTS AGAIN

	MOVN	T4,T1		;NEGATE COUNT OF WORDS TO LOG
	HRLZS	T4		;MAKE AN AOBJN WORD TO THE BUFFER
	HRR	T4,WRTBUF	;GET ADDRESS OF WRITE BUFFER
	MOVE	T1,(T4)		;GET A WORD
	PUSHJ	P,WRTWRD	;WRITE A WORD
	AOBJN	T4,.-2		;LOOP FOR ALL WORDS IN BUFFER
	MOVE	T1,[XWD 1,T2]	;SET UP TO UPDATE RIB
	MOVE	T2,[XWD LOG,.FOURB] ;CHANNEL,,FUNCTION
	FILOP.	T1,		;DO IT
	  JFCL			;WE DID OUR BEST
	POPJ	P,		;RETURN
	SUBTTL	Collect CID Info

COLCID:	MOVE	T1,[.PAGSC,,T2]	;MAP SECTION 0/1 TOGETHER
	MOVEI	T2,1		;JUST ONE ARGUMENT
	MOVE	T3,[PA.GMS+<0,,1>] ; SO WE CAN USE XMOVEIS
	PAGE.	T1,		;DO IT
	  HALT	.		;ERROR
	XJRST	[1,,.+1]	;DO THIS IN SECTION 1 FOR MONITOR DATA REFS
	MOVE	P1,SBLIST	;GET ADDRESS OF SYSTEM BLOCK LIST
	MOVSI	P2,-C%SBLL	;SET TO LOOP THROUGH SYSTEM BLOCK LIST
COLCI1:	MOVE	T1,P1		;COPY ADDRESS
	PEEK	T1,		;SNEAK A PEEK
	SKIPN	P3,T1		;COPY ADDRESS TO P3, SEE IF A BLOCK THERE
	JRST	COLCI8		;NO, TRY NEXT ENTRY IN SB ARRAY
	XMOVEI	T1,.SBPIN(P3)	;GET ADDRESS OF PATH BLOCK INFO WORD
	PEEK	T1,		;SNEAK A PEEK
	TRNN	T1,-1		;ANY PATH BLOCKS?
	JRST	COLCI8		;NO
	HLRZS	T1		;GET INDEX OF FIRST PATH BLOCK
COLCI3:	ADD	T1,PBLIST	;ADD IN ADDRESS OF ARRAY
	SUBI	T1,1		;ACCOUNT FOR 1-BASED INDICES
	PEEK	T1,		;SNEAK A PEEK
	SKIPN	P4,T1		;GET ADDRESS OF FIRST PATH BLOCK
	HALT	.		;ERROR
	XMOVEI	T1,.PBFCB(P4)	;GET ADDRESS OF FIRST CONNECTION BLOCK
	PEEK	T1,		;SNEAK A PEEK
	SKIPN	P5,T1		;ANY CONNECTION BLOCKS?
	JRST	COLCI7		;NO, TRY NEXT PATH BLOCK
	XMOVEI	T1,.PBPCB(P4)	;GET ADDRESS OF ASSOCIATED PCB
	PEEK	T1,		;SNEAK A PEEK
	XMOVEI	T1,.PCONN(T1)	;GET ADDRESS OF PORT'S LOCAL NODE NUMBER
	PEEK	T1,		;SNEAK A PEEK
	MOVE	P6,T1		;SAVE LOCAL NODE NUMBER
COLCI4:	XMOVEI	T1,.PBDPN(P4)	;GET ADDRESS OF DESTINATION PORT NUMBER WORD
	PEEK	T1,		;SNEAK A PEEK
	MOVEM	T1,CIDBUF+.CINOD ;SAVE NODE NUMBER
	XMOVEI	T1,.CBDCI(P5)	;GET ADDRESS OF DESTINATION CONNECT ID
	PEEK	T1,		;SNEAK A PEEK
	MOVEM	T1,CIDBUF+.CICID ;SAVE IN CIDBUF
	XMOVEI	T1,.CBDPN(P5)	;ADDRESS OF DESTINATION PROCESS NAME STRING
	MOVSI	T2,-C%PNLW	;LENGTH OF STRING IN WORDS
COLCI5:	MOVE	T3,T1		;COPY ADDRESS
	PEEK	T3,		;GET CONTENTS
	MOVEM	T3,CIDBUF+.CIPNS(T2) ;SALT AWAY
	ADDI	T1,1		;POINT AT NEXT WORD
	AOBJN	T2,COLCI5	;LOOP FOR ALL
	PUSHJ	P,WRTCID	;WRITE CID BUFFER

	MOVEM	P6,CIDBUF+.CINOD ;SAVE AWAY LOCAL NODE NUMBER
	XMOVEI	T1,.CBSCI(P5)	;GET ADDRESS OF SOURCE CONNECT ID
	PEEK	T1,		;SNEAK A PEEK
	MOVEM	T1,CIDBUF+.CICID ;SAVE IN CIDBUF
	XMOVEI	T1,.CBSPN(P5)	;ADDRESS OF SOURCE PROCESS NAME STRING
	MOVSI	T2,-C%PNLW	;LENGTH OF STRING IN WORDS
COLCI6:	MOVE	T3,T1		;COPY ADDRESS
	PEEK	T3,		;GET CONTENTS
	MOVEM	T3,CIDBUF+.CIPNS(T2) ;SALT AWAY
	ADDI	T1,1		;POINT AT NEXT WORD
	AOBJN	T2,COLCI6	;LOOP FOR ALL
	PUSHJ	P,WRTCID	;WRITE CID BUFFER

	XMOVEI	T1,.CBANB(P5)	;ADDRESS OF NEXT CONNECTION BLOCK
	PEEK	T1,		;SNEAK A PEEK
	SKIPE	P5,T1		;A NEXT BLOCK?
	JRST	COLCI4		;YES, LOOK AT THAT ONE
COLCI7:	XMOVEI	T1,.PBIDX(P4)	;GET ADDRESS OF PATH BLOCK INFO WORD
	PEEK	T1,		;SNEAK A PEEK
	LDB	T1,[POINT 12,T1,23] ;GET SECOND BYTE (NEXT PATH BLOCK INDEX)
	JUMPN	T1,COLCI3	;LOOP IF MORE PATH BLOCKS
COLCI8:	AOBJP	P2,COLCI9	;JUMP IF WE'VE DONE ALL SYSTEM BLOCKS
	AOJA	P1,COLCI1	;NO, ADVANCE TO NEXT SYSTEM BLOCK ENTRY AND LOOP
COLCI9:	SETO	T1,		;GET A -1
	JRST	@[0,,WRTWRD]	;LEAVE SECTION 1 AND WRITE MARKER

;Write out CID buffer

WRTCID:	MOVSI	T4,-.CILEN	;LENGTH OF BUFFER
	MOVE	T1,CIDBUF(T4)	;GET A WORD
	PUSHJ	P,WRTWRD	;WRITE IT
	AOBJN	T4,.-2		;LOOP
	POPJ	P,		;RETURN
	SUBTTL	Miscellaney

;Write one word in T1 to the log file

WRTWRD:	SOSGE	OBUF+.BFCTR	;ROOM FOR MORE OUTPUT?
	JRST	WRTWR1		;NO
	IDPB	T1,OBUF+.BFPTR	;YES, STORE IT
	POPJ	P,		;RETURN

WRTWR1:	OUT	LOG,		;WRITE THE BUFFER
	JRST	WRTWRD		;NO ERRORS
	HALT	.		;ERROR!


;Control-C intercept routine

CCINT:	MOVMS	CCLOCK		;NOTE CONTROL-C OCCURRED
	PUSH	P,INTBLK+.EROPC	;PUSH PC ON STACK
	SETZM	INTBLK+.EROPC	;ALLOW ANOTHER INTERRUPT
	POPJ	P,		;RETURN TO INTERRUPTED ROUTINE
	SUBTTL	Monitor Snoop Code

;Here on packet received

PKTRCV:	PUSHJ	%P,@SAVT(%R)	;SAVE TEMPORARY AC'S
	SETZ	%T1,		;MARK PACKET RECEIVED
	JRST	PKTCOM(%R)	;JOIN COMMON FLOW

;Here on packet transmitted

PKTXMT:	PUSHJ	%P,@SAVT(%R)	;SAVE TEMPORARY AC'S
	SETO	%T1,		;MARK PACKET TRANSMITTED
;	JRST	PKTCOM(%R)	;JOIN COMMON FLOW

;Here to log the packet

PKTCOM:	PUSHJ	%P,@SSEC1(%R)	;NEED TO BE EXTENDED TO ACCESS PACKET
	LDB	%T2,PKYOP(%R)	;GET OPCODE
	TRZ	%T2,OP.RMT	;STRIP REMOTE FLAG
	CAIE	%T2,OP.SDG	;DATAGRAM?
	CAIN	%T2,OP.SMS	;OR MESSAGE?
	SKIPA			;YES, WE'RE INTERESTED
	POPJ	%P,		;NO, WE'RE NOT INTERESTED
	CONO	PI,PI.OFF	;TURN OFF PI SYSTEM
	SKIPGE	TRKBSY(%R)	;DON'T TIE UP MEMORY WITH RMW CYCLES
	AOSE	TRKBSY(%R)	;WAIT UNTIL BUFFER IS NOT BUSY AT UUO LEVEL
	JRST	.-2(%R)		;...
	MOVEM	%Q2,PKTADR(%R)	;REMEMBER PACKET ADDRESS FOR DEBUGGING
	LDB	%T2,PKYLEN(%R)	;GET THE PACKET LENGTH
	SKIPN	%T2		;IF ZERO LENGTH,
	MOVEI	%T2,4*4		; ASSUME SHORT PACKET SENT INTERNALLY
	MOVE	%T3,.PKSTS(%Q2)	;GET STATUS BYTE
	TXNN	%T3,PF.FMT	;HIGH DENSITY MODE?
	JRST	PKTCM1(%R)	;NO, PACKET CONTAINS WORD COUNT
	ADDI	%T2,3		;ROUND UP BYTE COUNT
	IMULI	%T2,2		;TIMES TWO
	IDIVI	%T2,^D9		; DIVIDED BY 9 (4.5 BYTES/WORD)
PKTCM1:	ADDI	%T2,.TKPKT	;ADD IN OVERHEAD
	MOVEM	%T2,ENTLEN(%R)	;SAVE PACKET LENGTH
	MOVE	%T3,WRTBUF(%R)	;DETERMINE FREE SPACE LEFT IN BUFFER
	SUB	%T3,TRKPTR(%R)	;...
	CAMLE	%T2,%T3		;ROOM FOR THIS PACKET?
	JRST	NOROOM(%R)	;NO, SORRY
	AOS	PKTRCD(%R)	;COUNT ANOTHER PACKET RECORDED
	MOVE	%T3,%Q2		;COPY THE PACKET ADDRESS (SOURCE)
	MOVE	%T4,TRKPTR(%R)	;COPY PUTTER (DESTINATION)
	ADDI	%T4,.TKPKT	;BUMP PAST OVERHEAD WORDS
	ADD	%T4,%R		;RELOCATE TO EXEC ADDRESS
	EXTEND	%T2,[XBLT](%R)	;COPY THE DATA INTO THE TRACKING BUFFER
	MOVE	%T2,ENTLEN(%R)	;RETRIEVE ENTRY LENGTH
	MOVE	%T3,TRKPTR(%R)	;GET POINTER TO THIS RECORD
	ADD	%T3,%R		;RELOCATE TO EXEC ADDRESS
	ADDM	%T2,TRKPTR(%R)	;ADVANCE POINTER PAST THIS ENTRY
	DPB	%T1,[POINT 1,%T2,0](%R) ;STORE RECEIVE (0)/TRANSMIT(1) FLAG
	MOVE	%T1,@.CPCPN(%R)	;GET CPU NUMBER
	DPB	%T1,[POINT 3,%T2,3](%R) ;STORE CPU NUMBER
	MOVE	%T1,.PCONN(%Q3)	;GET LOCAL NODE NUMBER
	DPB	%T1,[POINT 8,%T2,11](%R) ;STORE LOCAL NODE NUMBER
	MOVEM	%T2,.TKLEN(%T3)	;STORE LENGTH WORD
	MOVE	%T2,@DATE(%R)	;GET SYSTEM DATE IN INTERNAL FORMAT
	MOVEM	%T2,.TKDTM(%T3)	;STORE UPTIME
	SETOM	TRKBSY(%R)	;LET UUO LEVEL GET AT THE BUFFER
	CONO	PI,PI.ON	;RE-ENABLE PI SYSTEM
	POPJ	%P,		;RETURN

NOROOM:	AOS	OVERFL(%R)	;COUNT AN ERROR
	SETOM	TRKBSY(%R)	;LET UUO LEVEL GET AT THE BUFFER
	CONO	PI,PI.ON	;RE-ENABLE PI SYSTEM
	POPJ	%P,		;RETURN

PKYOP:	POINT	8,3(%Q2),23	;POINT PKSOP, .PKSTS(Q2), PKPOP
PKYLEN:	POINT	20,4(%Q2),35	;POINT PKSLEN, .PKLEN(Q2), PKPLEN
	SUBTTL	The End

DEAD:	HALT	.
	END	START
