	TITLE	OBJECT	Type out Enter Passive connect strings.
	SUBTTL	Tarl Neustaedter
	SEARCH	DCN,MACSYM,D36PAR,SCPAR
	$ONLY==I.LUO!I.GTT
	$INIT	OBJ

OPDEF ADR2PG	[LSH -11]

XP PAGNUM,100		        ;MAX NUMBER OF PAGES TO MAP
XP PAGLOC,400		        ;WHERE WE START MAPPING THEM
$BLOCK PAGTAB,PAGNUM	        ;TABLE DEFINING WHAT PAGES ARE MAPPED WHERE
			        ;FORMAT: LH, NUMBER OF USERS OF PAGE,
			        ;	 RH, MONITOR PAGE NUMBER

START:	$SETUP		        ;INITIALIZE
;First, map in all of DECnet. We know that we will be using it, and
;we might as well have it mapped contiguosly.
	GTTAB. T2,[%DNPTR]      ;GET POINTER TO BIT TABLE
	TLZ T2,400000		;%%%%
	PEEK T2,	        ;GET THE ACTUAL POINTER
	HLRO T2,T2	        ;GET NEGATIVE NUMBER OF WORDS IN TABLE
	IMUL T2,[-^D36*4]	;CONVERT TO NUMBER OF WORDS ALLOCATED
	GTTAB. T1,[%DNLOC]	;GET POINTER TO DECNET FREECORE
	TLZ T1,400000		;%%%%
	PEEK T1,	        ;GET THE ACTUAL POINTER
	CALL MAPMON	        ;MAP IT IN
	GTTAB. P1,[%DNNDT]	;GET POINTER TO SCTNDT
	TLZ P1,400000		;%%%%
	ADDI P1,16		;** CROCK - GET POINTER TO SCTASQ
	PEEK P1,		;NOW HAVE POINTER TO FIRST SLB.

NXTSLB:	MOVE T1,P1		;GET MONITOR'S POINTER TO SLB
	MOVEI T2,SL.CBP		;GET ME ENOUGH SLB TO FIND SLCBP
	CALL MAPMON		;MAP IT IN
	MOVE P1,T1		;SAVE POINTER TO SLB
	LOAD T1,SLCBP,(P1)	;GET CONNECT BLOCK POINTER
	JUMPE T1,TYPSL9		;IF NONE, TRY FOR NEXT
	MOVEI T2,CB.LEN		;GET ME THE FULL CONNECT BLOCK
	CALL MAPMON		;MAP IN THE CONNECT BLOCK
	MOVE P2,T1		;SAVE POINTER TO THE CONNECT BLOCK
	LOAD T1,SLSJB,(P1)	;GET POINTER TO SJB
	MOVEI T2,SJ.JOB		;GET AS FAR AS THE JOB NUMBER
	CALL MAPMON		;MAP HIM IN TOO.
	MOVE P3,T1		;SAVE THE POINTER TO THE SJB
	LOAD T1,SJJOB,(P3)	;GET THE JOB NUMBER
	TSTRG. [ASCIZ \Job \]	;HEADER
	TDECW. T1,		;TYPE OUT THE JOB NUMBER
	JUMPE T1,[MOVE T1,[SIXBIT 'NRTSER']
		JRST NXTSL1]
	MOVS T1,T1		;JOB IN LEFT HALF
	HRRI T1,.GTPRG		;FUNCTION IN RIGHT HALF
	GTTAB. T1,T1		;FIND OUT THE PROGRAM NAME
NXTSL1:	TCHRI. "("		;OPEN PARENS
	TSIXN. T1,		;TYPE OUT PROGRAM NAME
	TCHRI. ")"		;CLOSE PARENS
	TCHRI. .CHTAB		;TAB OVER A LITTLE
	LOAD T1,CBNAM,(P2)	;GET NODE NAME THIS WANTS
	SKIPN T1		;DO WE HAVE A VALUE?
	MOVSI T1,'*  '      	;NOPE, WILDCARD
	TSIXN. T1,		;TYPE IT OUT IN SIXBIT
	TSTRG. [ASCIZ \::\]	;TYPE OUT NODE SEPERATOR
	MOVEI T1,CB.DST(P2)	;POINTER TO DESTINATION PDB
	CALL TYPPDB		;TYPE IT OUT
	TCHRI. "="		;SEPERATE FROM SOURCE
	MOVEI T1,CB.SRC(P2)	;POINTER TO SOURCE PDB
	CALL TYPPDB		;TYPE IT OUT
	LOAD T2,CBUCT,(P2)	;GET USER ID BYTECOUNT
	JUMPE T2,TYPSL2		;NONE, TRY PASSWORD
	TSTRG. [ASCIZ \/USER:\]	;NOISE
	MOVEI T1,CB.UID(P2)	;WHERE THE STRING IS
	CALL TYP8		;TYPE IT OUT FROM 8BIT ASCII
TYPSL2:	LOAD T2,CBPCT,(P2)	;GET PASSWORD BYTE COUNT
	JUMPE T2,TYPSL3		;IF NONE, TRY ACCOUNT
	TSTRG. [ASCIZ \/PASSWORD:\]
	MOVEI T1,CB.PSW(P2)	;POINTER TO PASSWORD STRING
	CALL TYP8
TYPSL3:	LOAD T2,CBACT,(P2)	;GET ACCOUNT BYTE COUNT
	JUMPE T2,TYPSL4		;IF NONE, TRY USER DATA
	TSTRG. [ASCIZ \/ACCOUNT:\]
	MOVEI T1,CB.ACC(P2)	;POINTER TO ACCOUNT STRING
	CALL TYP8
TYPSL4:	LOAD T2,CBCCT,(P2)	;GET USER DATA BYTE COUNT
	JUMPE T2,TYPSL5		;TRY MORE
	TSTRG. [ASCIZ \/DATA:\]
	MOVEI T1,CB.UDA(P2)	;POINTER TO USER DATA
	CALL TYP8
TYPSL5:
	TCRLF.			;END OF LINE
TYPSL9:
	LOAD P1,SLASQ,(P1)	;GET POINTER TO NEXT SLB IN QUEUE
	JUMPN P1,NXTSLB		;AND TYPE IT OUT IF IT EXISTS
	EXIT

;TYPPDB - Type out BEGSTR PB in a readable format
;	Format 0:	#nnn
;	Format 1:	xxxx
;	Format 2:	[nn,nn]xxxx
;Call
;	T1/ Pointer to PB
;Return
;	RET

TYPPDB:	CALL .SAVE1##		;WORK REGISTER
	MOVE P1,T1		;SAVE POINTER TO PDB
	LOAD T1,PBFOR,(P1)	;GET FORMAT TYPE
	CAILE T1,2		;MAKE SURE IT IS A FORMAT WE RECOGNIZE
	 $DIE BPF,<Bad PDB format type>
	JRST @.+1(T1)		;DISPATCH TO CORRECT TYPEOUT ROUTINE
	IFIW TYPFO0		;FORMAT 0
	IFIW TYPFO1		;FORMAT 1
	IFIW TYPFO2		;FORMAT 2

TYPFO0:	TCHRI. "#"		;INDICATE NUMBER
	LOAD T1,PBOBJ,(P1)	;GET OBJECT NUMBER
	TDECW. T1,		;TYPE IT OUT IN DECIMAL
	RET			;RETURN

TYPFO2:	TCHRI. "["		;OPEN PPN FIELD
	LOAD T1,PBGRP,(P1)	;GET GROUP CODE
	TOCTW. T1,		;TYPE IT OUT IN OCTAL
	TCHRI. ","		;SEPERATE
	LOAD T1,PBUSR,(P1)	;GET USER CODE
	TOCTW. T1,		;TYPE IT OUT
	TCHRI. "]"		;CLOSE BRACKET

TYPFO1:	TCHRI. """"		;TYPE A QUOTE
	LOAD T2,PBNCT,(P1)	;GET COUNT OF BYTES IN NAME STRING
	MOVEI T1,PB.NAM(P1)	;POINTER TO STRING
	CALL TYP8		;AND TYPE IT OUT IN 8 BIT
	TCHRI. """"		;CLOSE QUOTE
	RET
;TYP8 - Type an 8 bit string.
;Call
;	T1/ Pointer to string
;	T2/ Number of bytes to type
;Return
;	RET

TYP8:	HRLI T1,(POINT 8,)	;MAKE POINTER A BYTE POINTER
TYP81:	SOJL T2,.POPJ##		;RETURN WHEN DONE
	ILDB T3,T1		;GET A BYTE
	TCHRI. (T3)		;TYPE IT OUT
	JRST TYP81		;AND LOOP


;MAPMON - Map monitor pages into user space
;Call
;	T1/ Beginning address in monitor desired
;	T2/ Size
;Return
;	T1/ Pointer in monitor space to buffer


MAPMON:	PUSHJ P,.SAVE4##	;SAVE SOME WORKING SPACE
	MOVSI P4,1		;FLAG WE ARE MAPPING PAGES
MAPMO0:	MOVE P1,T1		;SAVE STARTING ADDRESS
	LDB P2,[POINT 9,P1,35]	;GET MODULO PAGE BITS
	ADD P2,T2		;ADD IN SIZE
	ADR2PG P2,		;CONVERT TO PAGES
	ADDI P2,1		;AND ROUND UP (ALWAYS!)
	CAIL P2,40		;MAKE SURE NO RIDICULOUS SIZED REQUEST
	 $DIE RSZ,<Ridiculous sized request to MAPMON>
	ADR2PG T1,		;CONVERT ADDRESS TO PAGE NUMBER
	MOVE P3,[IOWD PAGNUM,PAGTAB] ;AOBJN POINTER TO PAGTAB
MAPMO1:	AOBJP P3,MAPMAK		;AT END OF LIST, JUST MAP IT IN.
	HRRZ T3,(P3)		;GET A PAGE NUMBER
	CAME T1,T3		;IS THIS THE PAGE WE ARE LOOKING FOR?
	 JRST MAPMO1		;NOPE, KEEP ON LOOKING.
;Check to see if we have all pages contiguous here
	MOVE T2,P2		;FIND OUT NUMBER OF PAGES TO CHECK
	MOVE T4,P3		;COPY AOBJN POINTER FOR OUR PURPOSES
MAPMO2:	SOJLE T2,MAPMO3		;IF END, ALL PAGES ARE ALREADY MAPPED.
	ADDI T1,1		;INCREMENT PAGE WE ARE INTERESTED IN
	AOBJP T4,MAPMAK		;IF WE RUN OVER, NOT ALL PAGES ARE MAPPED
	HRRZ T3,(T4)		;GET NEXT PAGE FROM TABLE
	CAMN T1,T3		;IS THIS THE PAGE WE NEED?
	 JRST MAPMO2		;YES, TRY FOR NEXT PAGE
	MOVE T1,P1		;FAILED, GET BACK ORIGINAL ADDRESS
	ADR2PG T1,		;CONVERT TO PAGE NUMBER
	JRST MAPMO1		;AND KEEP ON TRYING

;Here when all pages are mapped in.
;P1/ Original requested address
;P2/ Number of pages to be mapped
;P3/ Entry in PAGTAB where pages start.
;P4/ Flag indicating mapping or unmapping pages.

MAPMO3:	MOVSI T1,1		;LEFT HALF ONE, TO INCREMENT NUMBER OF USERS
	MOVN T2,P2		;GET NUMBER OF ENTRIES TO MARK
	MOVS T2,T2		;LEFT HALF FOR AOBJN POINTER
	HRRI T2,P3		;RIGHT HALF TO TABLE
MAPMO4:	ADDM T1,(P3)		;INCREMENT NUMBER OF USERS OF PAGE
	AOBJN T2,MAPMO4		;LOOP UNTIL ALL ARE INCREMENTED
	MOVEI T2,-PAGTAB(P3)	;GET OFFSET INTO PAGTAB FOR FIRST PAGE
	ADDI T2,PAGLOC		;CONVERT TO VIRTUAL PAGE NUMBER
	MOVE T1,P1		;GET ORIGINAL REQUESTED ADDRESS
	DPB T2,[POINT 9,T1,26]	;CONVERT TO VIRTUAL MAPPED ADDRESS
	RET			;AND RETURN

;Here when the pages we need are not mapped in.
;P1/ Original address requested
;P2/ Number of pages to do

MAPMAK:
;Turn interrupts off for this entire thing.
;First, find the number or contiguous free slots in PAGTAB that we need
	MOVE P3,[IOWD PAGNUM,PAGTAB] ;AOBJN POINTER TO TABLE SLOTS
MAPMK1:	AOBJP P3,MAPMK9		;IF END OF LIST AND HERE, WE FAILED
	SKIPE (P3)		;IS THIS SLOT EMPTY?
	 JRST MAPMK1		;NOPE, KEEP ON LOOKING.
	DMOVE T2,P2		;NUMBER OF PAGES TO DO, POINTER TO PAGTAB
MAPMK2:	SOJLE T2,MAPMK3		;DECREMENT NUMBER OF PAGES TO GO
	AOBJP T3,MAPMK9		;IF END OF LIST, WE LOSE
	SKIPN (P3)		;IS THIS SLOT EMPTY?
	 JRST MAPMK2		;YES, KEEP ON TRYING
	MOVE P3,T3		;NO, HAVE OTHER ROUTINE USE THIS POINTER
	JRST MAPMK1		;AND LOOK FOR ANOTHER EMPTY SLOT

MAPMK3:	MOVEI T3,-PAGTAB(P3)	;GET OFFSET INTO PAGTAB
	ADDI T3,PAGLOC		;CONVERT INTO USER PAGE NUMBER
	MOVN T2,P2		;GET NUMBER OF PAGES TO DO
	LDB T1,[POINT 18,P1,26]	;GET MONITOR PAGE NUMBER
	HRLM T1,T3		;SAVE FOR PAGE UUO
	MOVE T1,[.PAGSP,,T2]	;PAGE UUO ARGUMENTS
	PAGE. T1,		;AND MAP THE STUFF IN
	 $ERROR PUF,<PAGE. uuo failed, reason >,.TOCTW##,T1
;Now the pages are mapped in, lets mark in PAGTAB the fact that we did.
	HLRZ T1,T3		;GET MONITOR PAGE NUMBER
	MOVS T2,T2		;NEGATIVE PAGES TO DO IN LH
	HRR T2,P3		;POINTER TO OUR SLOT IN PAGTAB
MAPMK4:	MOVEM T1,(T2)		;SAVE PAGE NUMBER IN PAGTAB
	ADDI T1,1		;INCREMENT MONITOR PAGE NUMBER
	AOBJN T2,MAPMK4		;AND LOOP
	JRST MAPMO3		;AND MARK THOSE PAGES AS BEING IN USE

MAPMK9:	$ERROR NEP,<Not enough free pages>

	END START
