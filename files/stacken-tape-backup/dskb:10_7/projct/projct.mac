TITLE	PROJCT - PROGRAM TO CONVERT PROJCT.ACT TO PROJCT.SYS FOR VALIDATION - V1(11)



;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1979,1980,1984,1986.
;ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.


	SUBTTL	AECARLSON/AEC/BAH/JMF   29-Jan-81
	SALL
	SEARCH	UUOSYM,MACTEN,ACTSYM

	PRJVER==1		;MAJOR VERSION
	PRJEDT==11		;EDIT LEVEL
	PRJMIN==0		;MINOR VERSION
	PRJWHO==0		;LAST MODIFIER

	LOC	137

	VRSN.	(PRJ)

	RELOC


COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1979,1986.ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO


	X==4
	MASK==5
	T1==6
	T2==7
	FIELD==10
	A==11
	D==12
	ERRTYP==13
	TBLPTR==14
	B==15
	C==16
	P==17		;PUSHDOWN LIST POINTER




	SUBTTL	EDIT HISTORY

;2	CORRECT MASK FOR WILD-CARD PPN'S, ALLOW WILD CARDS IN ACCOUNT STRING.
;3	CONVERT LOWER CASE TO UPPER CASE IF FTCASECONVERT IS ON FROM ACTSYM.
;4	REPORT FILOP. ERROR CODES WHEN LOOKUP/ENTER FAILS.
;5	ACCEPT SOS LINE NUMBERED PROJCT.ACT
;6	USE ASSEMBLY PARAMETER "PRJWPB" INSTEAD OF ABSOLUTE 200'S
;7	LONG LINES COULD OVERFLOW OUTREC, COUNT CHARACTERS
;10	RANGE CHECK ACCOUNT STRING LENGTH.  CHANGE THE WAY SWITCHES ARE (NOT)
;	HANDLED.  IMPLEMENT /DEFAULT TO SET DEFAULT ACCOUNT STRING
;11	SAVE SPACE IN PROJCT.SYS IF PRJWPB .GT. 200. ALLOW PPN ENTRIES TO
;	CROSS BLOCK BOUNDRIES.  THESE CHANGES CONSTITUTE FORMAT VERSION 2.
;
	SUBTTL	MACROS AND DEFINITIONS

	DEFINE	CRLF(X),<
	   IFE <X>,  <OUTSTR [BYTE(7) 12,15,0,0,0]>
	   IFE <X-1>,<OUTSTR [BYTE(7) 12,15,0,0,0]>
	   IFE <X-2>,<OUTSTR [BYTE(7) 12,15,15,0,0]>
	   IFE <X-3>,<OUTSTR [BYTE(7) 12,15,15,15,0]>
	> ; END CRLF MACRO



ACVERS==2			;VERSION OF THE PROJCT.SYS FILE
	SUBTTL	MAIN PROGRAM

PROJCT:	RESET
	CRLF	2
	MOVE	P,[IOWD 100,STACK] ;INITIALIZE STACK POINTER
	MOVEI	T1,[OUTSTR [ASCIZ/PROGRAM NOT RESTARTABLE./]
		    CRLF 2
		    EXIT]
	HRRM	T1,.JBSA##	;DON'T ALLOW "START" AFTER FIRST RUNNING
	MOVE	T1,[6,,INPFIL]	;SET UP FILOP. PARMS
	FILOP.	T1,		;LOCATE AND OPEN THE INPUT FILE.
	JRST	FIL1ER		;IF AN ERROR, GO PROCESS IT.
	MOVE	T1,[6,,OUTFIL]	;SET UP OUTPUT FILOP PARMS
	FILOP.	T1,		;LOCATE AND OPEN THE OUTPUT FILE.
	JRST	FIL2ER		;IF AN ERROR, GO PROCESS IT.
	MOVE	T1,[6,,MAPFIL]	;SET UP FILOP. PARMS
	FILOP.	T1,		;LOCATE AND OPEN TEMP MAP FILE.
	JRST	FIL3ER		;IF AN ERROR, GO PROCESS IT.
	SETZ	FIELD,		;SET FIELD INDICATOR TO [P,PN]
	MOVEI	TBLPTR,TABLE	;INIT TBLPTR WITH TABLE ADDRESS.
	SETO	ERRTYP,		;INDICATE NO ERRORS.
GETBYT:	PUSHJ	P,INBYTE	;GO GET A BYTE OF DATA
	JRST	@PROCES(T2)	;GO PROCESS THE BYTE.
	
FIL1ER:	OUTSTR	[ASCIZ/PROJCT.ACT/]
	JRST	FILECM		;END ERROR MESSAGE

FIL2ER:	OUTSTR	[ASCIZ/PROJCT.SYS/]
	JRST	FILECM		;END ERROR MESSAGE

FIL3ER:	OUTSTR	[ASCIZ/PROJCT.MAP/]
FILECM:	OUTSTR	[ASCIZ/ FILOP. ERROR, ERROR CODE = /]
	MOVE	T2,T1
	LSH	T2,-3
	ADDI	T2,"0"
	CAIE	T2,"0"
	OUTCHR	T2
	ANDI	T1,7
	ADDI	T1,"0"
	OUTCHR	T1
	CRLF
	JRST	FINISH

	SUBTTL ROUTINES - [ BRACKET, ] BRACKET, & ALPHA CHARS ROUTINES.

LBRKT:	JRST	@LBFLD(FIELD)	;GO PROCESS [ BRACKET BY FIELD
LBPPN:	AOSG	LBCNT		;MAKE SURE ONLY 1 [ FOR PPN
	JRST	GETBYT		;IF SO, IGNORE IT.
	MOVEI	ERRTYP,8	;ELSE TOO MANY ['S, SO 
	JRST	ERROR		;GO PROCESS THE ERROR.

LBFLD:	0,,LBPPN
	0,,STOREC
	0,,[MOVEI ERRTYP,21
	    JRST ERROR]



RBRKT:	JRST	@RBFLD(FIELD)	;GO PROCESS ] BRACKET BY FIELD
RBPPN:	AOSG	RBCNT		;MAKE SURE ONLY 1 ] FOR PPN
	JRST	GETBYT		;IF SO, IGNORE IT.
	MOVEI	ERRTYP,9	;ELSE TOO MANY ]'S, SO
	JRST	ERROR		;GO PROCESS THE ERROR.
	
RBFLD:	0,,RBPPN
	0,,STOREC
	0,,[MOVEI ERRTYP,21
	    JRST ERROR]


ALPHA:	JRST	@ALFLD(FIELD)	;GO PROCESS ALPHA BY FIELD
ALPPN:	MOVEI	ERRTYP,0	;IF ALPHA IN PPN, THEN ERROR
	JRST	ERROR		;SO GO PROCESS IT.

ALFLD:	0,,ALPPN
	0,,STOREC
	0,,STOREC

	SUBTTL CR.LF - ROUTINE TO PROCESS CARRIAGE RETURNS AND LINE FEEDS.

CR:	JRST	@CRFLD(FIELD)	;PROCESS CARRIAGE RETURN BY FIELD.
CRPPN:	MOVEI	ERRTYP,1	;IF CR IN PPN FIELD, THEN ERROR
	JRST	ERROR		;SO GO PROCESS IT.
CRA.S.:	SKIPE	AS.LEN		;CHECK THE A.S. LENGTH
	JRST	CRASOK		;IF A.S. NOT NULL,THEN CONTINUE.
	MOVEI	ERRTYP,12	;ELSE GENERATE AN ERROR CODE.
	JRST	ERROR		;  AND GO PROCESS THE ERROR.
CRASOK:	PUSHJ	P,BUILD		;GO GENERATE A TABLE ENTRY
NXTBYT:	PUSHJ	P,INBYTE	;SKIP ALL BYTES
	CAIGE	T2,40		;  THAT ARE BREAK CHARACTERS.
	JRST	NXTBYT		;SKIP THIS BYTE
	PUSHJ	P,RESETA	;GO RESET THE POINTERS AND COUNTERS.
	SOSLE	ORCSIZ		;MAKE SURE THERE IS ROOM FOR CHARACTER
	DPB	T2,OUTPTR	;SAVE LAST BYTE AT START OF STRING.
	JRST	@PROCES(T2)	;GO PROCESS THE DATA

CRFLD:	0,,CRPPN
	0,,CRA.S.
	0,,[SKIPE CS.LEN	;CAN'T HAVE NULL SWITCHES
	    JRST CRA.S.		;SEE IF ACCOUNT STRING IS OK
	    MOVEI ERRTYP,15	;GENERATE AN ERROR
	    JRST ERROR]

	SUBTTL NUMBER - ROUTINE TO PROCESS NUMERICS BY FIELD.

NUMBER:	JRST	@NBFLD(FIELD)	;GO PROCESS NUMERICS BY FIELD
NBPPN:	CAIG	T2,67		;MAKE SURE DIGIT IS OCTAL.
	JRST	DIGOK		;IF SO, THEN CONTINUE
	MOVEI	ERRTYP,2	;ELSE GENERATE THE ERROR CODE,
	JRST	ERROR		;AND GO PROCESS THE ERROR.
DIGOK:	IDPB	T2,PPNPTR	;SAVE POSSIBLE P,PN VALUE
	AOS	PPNCNT		;ADD 1 TO NUMBER BYTE COUNT
	MOVE	C,PPNCNT	;LOAD AC C WITH BYTE COUNT
	CAIG	C,6		;IS # OF BYTES > 6 ?
	JRST	GETBYT		;IF NOT, RETURN TO GET MORE DATA.
	MOVEI	ERRTYP,7	;ELSE LOAD ERROR CODE
	JRST	ERROR		;AND GO PROCESS THE ERROR.
	
NBFLD:	0,,NBPPN		;IF NUMBER IS IN A.S. FIELD OR /SWTCH.
	0,,STOREC		;   FIELD, THEN JUST SAVE IT IN
	0,,STOREC		;   THE FIELD SAVE AREAS.

	SUBTTL COMMA - ROUTINE TO PROCESS COMMA'S.

COMMA:	JRST	@CMFLD(FIELD)	;GO PROCESS COMMAS BY FIELD
CMPPN:	AOSG	CMCNT		;IF COMMA IN PPN FIELD, ADD 1 TO COMMA
	JRST	CHKLEN		;COUNT, IF 0 THEN WE SHOULD HAVE 'P'
				; VALUE, SO MAKE SURE BYTE COUNT > 0.
	MOVEI	ERRTYP,3	;ELSE, MORE THEN 1 COMMA IN PPN, SO
	JRST	ERROR		;GO PROCESS THE ERROR
CHKLEN:	SKIPE	PPNCNT		;IF NUMBER BYTE COUNT STILL 0
	JRST	CVRTP		;THEN THATS AN ERROR, SO
	MOVEI	ERRTYP,4	;SET UP ERROR CODE
	JRST	ERROR		;AND GO PROCESS THE ERROR
CVRTP:	PUSHJ	P,CV2OCT	;GO CONVERT THE STRING TO OCTAL BINARY
	HRLM	C,P.PN		;SAVE THE 'P' FIELD IN OUTPUT TABLE
	HRLM	MASK,PPNMSK	;SAVE THE 'P' MASK FOR WILD-CARDING.
	JRST	GETBYT		;GO GET SOME MORE DATA
CMA.S.:	SKIPE	AS.LEN		;MAKE SURE A.S. FIELD NOT NULL.
	JRST	ALENOK		;IF NOT, THEN CONTINUE PROCESSING.
	MOVEI	ERRTYP,12	;ELSE GENERATE ERROR CODE,
	JRST	ERROR		;  AND GO PROCESS THE ERROR.
ALENOK:	PUSHJ	P,BUILD		;GO BUILD AN ENTRY IN TABLE
	MOVEI	FIELD,1		;RESET THE FIELD POINTER TO A.S.
	JRST	GETBYT		;GO GET THE NEXT BYTE.

CM.SWT:	SKIPE	CS.LEN		;MAKE SURE /SWTCH. FIELD NOT NULL.
	JRST	CMA.S.		;IF NOT, GO CHECK ACCOUNT STRING
	MOVEI	ERRTYP,15	;ELSE GENERATE AN ERROR CODE,
	JRST	ERROR		;  AND GO PROCESS THE ERROR

CMFLD:	0,,CMPPN
	0,,CMA.S.
	0,,CM.SWT

	SUBTTL EQUALS - ROUTINE TO PROCESS = SIGN DELIMITER.

EQUALS:	AOSG	EQCNT		;MAKE SURE THERE IS ONLY 1
	JRST	@EQFLD(FIELD)	;PROCESS THE = BY FIELD.
	MOVEI	ERRTYP,5	;ELSE TOO MANY ='S, SO ERROR.
	JRST	ERROR		;  GO PROCESS IT.
EQPPN:	SKIPE	PPNCNT		;MAKE SURE PN LENGTH NOT 0
	JRST	CVRTPN		;IF NOT, THEN GO CONVERT TO BINARY.
	MOVEI	ERRTYP,6	;ELSE 0 LENGTH IS AN ERROR,
	JRST	ERROR		;SO GO PROCESS IT.
CVRTPN:	PUSHJ	P,CV2OCT	;CONVERT PN TO OCTAL BINARY.
	HRRM	C,P.PN		;AND SAVE IT IN TABLE
	HRRM	MASK,PPNMSK	;SAVE THE 'PN' MASK FOR WILD-CARDING.
	SKIPL	C,P.PN		;PICK UP LAST PPN.
	CAML	C,PPNSAV	;COMAPRE AGAINST LAST PPN.
	JRST	CHKHI		;IF NOT LESS, THEN CHECK HIGH
	MOVEI	ERRTYP,13	;   GENERATE AN ERROR CODE,
	JRST	ERROR		;   AND GO PROCESS THE ERROR.
CHKHI:	CAME	C,PPNSAV	;IF NEW PPN = OLD PPN, THEN CONTINUE.
	PUSHJ	P,BLDREC	;   ELSE GO BUILD OUTPUT BUFFER
	MOVEI	FIELD,1		;SET FIELD TO ACCOUNT STRING FIELD.
	JRST	GETBYT		;GO PROCESS THE NEXT BYTE.

EQFLD:	0,,EQPPN
	0,,STOREC
	0,,[MOVEI ERRTYP,21
	    JRST ERROR]

	SUBTTL SLASH - ROUTINE TO PROCESS /SWITCH FIELDS.

SLASH:	AOSG	SLCNT		;CHECK FOR CONSECUTIVE
	JRST	SLOK		;  SLASHES. IF NONE, CONTINUE.
SLERRP:	MOVEI	ERRTYP,23	;ELSE GENERATE ERROR CODE,
	JRST	ERROR		;AND GO PROCESS THE ERROR.
SLOK:	JRST	@SLFLD(FIELD)	;GO PROCESS THE / BY FIELD.
SLA.S.:	SKIPE	AS.LEN		;MAKE SURE IT'S AFTER THE ACCOUNT STRING
	JRST	SLOK1		;SO FAR SO GOOD
	MOVEI	ERRTYP,12	;NULL ACCOUNT STRING
	JRST	ERROR		;GO PROCESS THE ERROR
SLOK1:	MOVEI	FIELD,2		;SET UP /SWTCH. FIELD.
	JRST	GETBYT		;GO GET THE NEXT BYTE.

SLFLD:	0,,SLERRP
	0,,SLA.S.
	0,,SLERRP
	SUBTTL STOREC - ROUTINE TO STORE CHARS IN A.S. & /SWITCH SAVE AREAS.

STOREC:	JRST	@STFLD(FIELD)	;STORE BYTES ACCORDING TO THE FIELD.
STA.S.:	SKIPL	WLASFL		;"*" SEEN IN A.S. FIELD
	JRST	[MOVEI ERRTYP,22 ;* NOT LAST
		 JRST ERROR]	;REPORT ERROR
	CAIN	T2,"*"		;IS THIS THE WILD CARD
	SETZM	WLASFL		;YES, MARK WE'VE SEEN IT
	IDPB	T2,AS.PTR	;SAVE THE BYTE IN AS.FLD
	AOS	AS.LEN		;BUMP AS. LENGTH BY 1
	MOVEI	A,^D40		;CHECK THE LENGTH
	CAMLE	A,AS.LEN	;OF ACCOUNT FIELD, IF LESS THEN 40
	JRST	GETBYT		;THEN CONTINUE PROCESSING.
	MOVEI	ERRTYP,16	;ELSE GENERATE AN ERROR CODE,
	JRST	ERROR		;AND GO PROCESS THE ERROR.
ST.SWT:	AOS	A,CS.LEN	;GET LENGTH
	CAIG	A,5		;ONLY SAVE FIRST 5 CHARACTERS
	IDPB	T2,CS.PTR	;TUCK IT AWAY FOR BUILD
	JRST	GETBYT		;GO GET THE NEXT BYTE

STFLD:	0,,0
	0,,STA.S.
	0,,ST.SWT



	SUBTTL WLDCRD - [P,PN] WILD-CARD INITIALIZATION ROUTINE.

WLDCRD:	JRST	@WLFLD(FIELD)		;PROCESS ?,* BY FIELD.
WLPPN:	CAIN	T2,"*"			;WILD CARD THE ENTIRE FIELD?
	JRST	WLPPN2			;YES
	IDPB	T2,PPNPTR		;STORE THE WILD CARD CHARACTER
	AOS	C,PPNCNT		;COUNT CHARACTERS, GET COUNT SO FAR
	CAIG	C,6			;MORE THAN ALLOWED?
	JRST	GETBYT			;NO, GET NEXT CHARACTER
WLPPN1:	SETZM	.WILD			;HERE ON ERROR, NO WILD CARDS SEEN
	MOVEI	ERRTYP,7		;TOO MANY DIGITS/WILDCARDS IN P,PN
	JRST	ERROR			;GO PROCESS THE ERROR
WLPPN2:	SKIPE	PPNCNT			;BEEN HERE BEFORE?
	JRST	WLPPN1			;YES, ONLY ONE * ALLOWED, NOT ALLOWED
					; WITH DIGITS
	MOVEI	T2,"?"			;FILL FIELD WITH WILD CARD CHARACTERS
	MOVEI	C,6			;P,PN WIDTH
	MOVEM	C,PPNCNT		;NOTE THAT WE HAVE BEEN HERE
WLPPN3:	IDPB	T2,PPNPTR		;STORE WILD CARD
	SOJG	C,WLPPN3		;FILL THE ENTIRE FIELD
	JRST	GETBYT			;GET NEXT CHARACTER

WLFLD:	0,,WLPPN
	0,,[SETOM WLDASF		;MARK EITHER ? OR *
	    JRST STA.S.]		;AND INCLUDE IT
	0,,[MOVEI ERRTYP,21
	    JRST ERROR]
	SUBTTL BUILD - ROUTINE TO BUILD ACCOUNT STRING TABLE ENTRY'S.

	;BUILD PPN AND ACCOUNT STRING TABLE ENTRY'S

BUILD:	MOVE	T1,AS.LEN	;PICK UP AS. LENGTH IN BYTES
	ADDI	T1,4		;ROUND OFF BYT CNT TO NEXT WORD.
	PUSH	P,T2		;SAVE CHARACTER AROUND DIVIDE
	IDIVI	T1,5		;CALC LENGTH IN WORDS
	POP	P,T2		;RESTORE CHARACTER CLOBBERED BY IDIVI
	ADDI	T1,4		;ADD LENGTHS OF PPN, MASK, AND LENGTH.
	MOVE	A,T1		;LOAD THE LENGTH INTO A
	ADD	A,TBLSIZ	;ADD CURRENT TABLE LENGTH
	CAIGE	A,PRJWPB	;MAKE SURE WE ARE STILL IN BUFFER.
	JRST	AS.FIT		;IF SO, THEN CONTINUE.
	MOVE	C,P.PN		;GET CURRENT PPN
	PUSHJ	P,BLDREC	;FORCE OUT THIS BUFFER LOAD
	JRST	BUILD		;AND START AGAIN
AS.FIT:	HRRZM	T1,0(TBLPTR)	;AND SAVE IT IN TABLE
	ADDM	T1,TBLSIZ	;ADD A.S. LENGTH TO BUFFER LENGTH.
	SUBI	T1,1		;CALC BLT END ADDRESS-1
	ADD	T1,TBLPTR	;   PARAMETER.
	MOVE	B,AS.LEN	;GET CHARACTER COUNT AGAIN
	HRLZM	B,3(TBLPTR)	;SAVE ACCOUNT LENGTH IN TABLE.
	HRRI	B,4(TBLPTR)	;SET UP BLT DESTINATION ADDRESS
	HRLI	B,AS.FLD	;SET UP BLT SOURCE ADDRESS.
	BLT	B,(T1)		;MOVE ACCOUNT STRING TO TABLE.
	MOVE	B,P.PN		;PICK UP THE PPN
	TLZ	B,400000	;-1 IS ILLEGAL FOR A PROJECT NUMBER, WILDCARDING
				; COULD HAVE TURNED ON THE SIGN BIT
	MOVEM	B,1(TBLPTR)	;  AND SAVE IT IN THE TABLE.
	MOVE	B,PPNMSK	;PICK UP THE WILD-CARD PPN MASK.
	MOVEM	B,2(TBLPTR)	;   SAVE IT IN THE TABLE.
	MOVE	X,CS.LEN	;GET SWITCH LENGTH IF ANY
	JUMPE	X,NOSWT		;NONE TO WORRY ABOUT
	CAILE	X,5		;ONLY CHECK FIRST 5 CHARACTERS
	MOVEI	X,5		;LOWER LIMIT
	MOVE	A,[ASCII/DEFAU/] ;ONLY DEFINED SWITCH FOR NOW
	AND	A,[BYTE (7) 177,0,0,0,0
		   BYTE (7) 177,177,0,0,0
		   BYTE (7) 177,177,177,0,0
		   BYTE (7) 177,177,177,177,0
		   BYTE (7) 177,177,177,177,177]-1(X)
	CAME	A,SWTCH.	;CHECK FOR /DEFAULT
	JRST	[MOVEI ERRTYP,24 ;UNKNOWN SWITCH
		JRST ERROR]
	SKIPE	WLDASF		;NO WILDCARDS ALLOWED IN DEFAULT
	JRST	[MOVEI ERRTYP,25
		JRST ERROR]
	MOVEI	A,1B35		;FLAG DEFAULT ACCOUNT STRING FOR PPN
	IORM	A,3(TBLPTR)	;LIGHT FLAG BIT FOR ACTDAE
NOSWT:	HRRI	TBLPTR,1(T1)	;POINT TO NEXT TABLE ENTRY
	PUSHJ	P,RESETB	;GO RESET SOME POINTERS AND COUNTERS.
	POPJ	P,		;RETURN TO CALLER

	SUBTTL INBYTE - ROUTINE TO READ TEMP STORAGE FILE.

INBYTE:	SOSGE	IBFCNT		;MAKE SURE THERE IS DATA IN BUFFER.
	JRST	READ		;IF NOT, GO GET A BLOCK.
	ILDB	T2,IBFPTR	;ELSE PICK UP A BYTE
	PUSH	P,T2		;CANNOT CLOBBER REGISTERS HERE
	MOVEI	T2,1B35		;LINE NUMBER FLAG
	TDNE	T2,@IBFPTR	;DID WE JUST STEP INTO A LINE NUMBER
	JRST	[ANDCAM T2,@IBFPTR ;YES, CLEAR IT SO WE DON'T GET BACK HERE
		 POP P,T2	;CLEAN STACK
		 PUSHJ P,INBYTE	;EAT UP THE REST OF THE LINE NUMBER
		 PUSHJ P,INBYTE	;...
		 PUSHJ P,INBYTE	;...
		 PUSHJ P,INBYTE	;...
		 PUSHJ P,INBYTE	;EAT THE <TAB> BETWEEN LINE NUMBER AND DATA
		 JRST INBYTE]	;AND GET FIRST REAL DATA BYTE FROM THIS LINE
	POP	P,T2		;RESTORE CHARACTER AFTER LINE NUMBER CHECK
IFN FTCASECONVERT,<
	CAIG	T2,"Z"+" "	;LOWER CASE Z
	CAIGE	T2,"A"+" "	;RANGE CHECK INPUT
	CAIA			;NOT LOWER CASE
	SUBI	T2," "		;CONVERT TO UPPER CASE
>
	CAIGE	T2," "		;DO NOT SAVE BREAK CHARACTERS.
	POPJ	P,		;CONTROL CHAR, RETURN
	SOSLE	ORCSIZ		;MAKE SURE THERE IS ROOM FOR CHARACTER
	IDPB	T2,OUTPTR	;AND SAVE IT (FOR POSSIBLE ERROR MSG)
	POPJ	P,		;RETURN TO CALLER
READ:	IN	X,		;GET A BLOCK OF DATA
	JRST	INBYTE		;IF NO ERROR, THEN CONTINUE
	STATZ	X,IO.EOF	;WAS ERROR END OF FILE ?
	JRST	ENDJOB		;IF SO, THEN FINISH THE JOB
	OUTSTR	[ASCIZ\I/O ERROR OCCURED WHILE READING INPUT FILE.\]
	CRLF
	OUTSTR	[ASCIZ/PROCESSING TERMINATED./]
	CRLF
	JRST	FINISH		;GO RETRN TO MONITOR.

	SUBTTL ERROR - ROUTINE TO PROCESS ERRORS MESSAGES.

ERROR:	CAIE	T2,15		;SPIN UNTIL END OF LINE
	CAIN	T2,12		;...
	JRST	BRKCHR		;IF SO, THEN WRITE OUT THE ERROR MSG.
	PUSHJ	P,INBYTE	;ELSE GO GET ANOTHER BYTE.
	JRST	ERROR		;AND CHECK FOR BREAK AGAIN.
BRKCHR:	SETZ	C,		;GENERATE A NULL BYTE,
	IDPB	C,OUTPTR	;AND SAVE IT IN OUTPUT MSG.
	OUTSTR	OUTREC		;PRINT THE BAD DATA,
	CRLF			;SEPARATE LINES
	OUTSTR	@ERMSG(ERRTYP)	;   AND THE ERROR MESSAGE.
	IOR	ERRTYP,.WILD	;MERGE ERROR TYPE AND WILD FLAG.
	CAIN	ERRTYP,13	;DID WE PRINT '[P,PN] OUT OF SEQ' MSG ?
	OUTSTR	WLDMSG		;IF SO,,PRINT EXPLANATION.
	CRLF	2		;SKIP 2 LINES.
FNDCHR:	PUSHJ	P,INBYTE	;GO GET A BYTE OF DATA.
	CAIGE	T2,40		;IS IT VALID ?
	JRST	FNDCHR		;IF NOT, THEN SKIP IT.
	PUSHJ	P,RESETA	;GO RESET SOME POINTERS AND COUNTERS.
	PUSHJ	P,RESETB	;AND GO DO IT SOME MORE...
	SOSLE	ORCSIZ		;MAKE SURE THERE IS ROOM FOR CHARACTER
	DPB	T2,OUTPTR	;SAVE CURRENT BYTE.
	JRST	@PROCES(T2)	;THEN GO PROCESS THE DATA.

	SUBTTL BLDREC - ROUTINE TO MANAGE THE OUTPUT BUFFER AND TABLE MAP.

BLDREC:	AOSE	FSTREC		;IS THIS THE FIRST TIME THROUGH ?
	JRST	NOTFST		;IF NOT, DO NOT DO INITIALIZATION.
	PUSHJ	P,WRTHDR	;ELSE WRITE OUT A DUMMY HEADER.
	MOVEM	C,PPNSAV	;SAVE THE NEW PPN
	POPJ	P,		;RETURN TO CALLER
NOTFST:	SKIPG	TBLSIZ		;MAKE SURE THERE IS DATA IN BUFFER.
	JRST	DONTBD		;IF NOT, THEN DONT BUILD OUTPUT BUFFER.
	MOVEI	B,PRJWPB	;SET AC B TO DISK BLOCK SIZE
	SUB	B,BLKSIZ	;SUBTRACT CURRECT BLOCK SIZE
	CAMGE	B,TBLSIZ	;IS THERE ROOM IN BUFR FOR TABLE?
	PUSHJ	P,WRTBFR	;IF NOT, THEN WRITE BUFR & GET ANOTHER.
	MOVE	B,TBLSIZ	;PICK UP [P,PN] BLOCK SIZE
	HRLM	B,TABLE		;SAVE AS OFFSET TO NEXT [P,PN].
	HRRZ	B,BLKSIZ	;PICK UP CURRENT BLOCK SIZE.
	ADDI	B,OTBFR		;CALC BUFFER ADDRESS FOR TABLE (DEST)
	MOVE	D,B		;LOAD D WITH DEST START ADDRESS
	HRLI	B,TABLE		;PICK UP BLT SOURCE ADDRESS.
	ADD	D,TBLSIZ	;CALC DEST END ADDRESS
	SUBI	D,1		;CALC DEST END ADDRESS - 1
	BLT	B,0(D)		;MOVE TABLE TO OUTPUT BUFFER.
	MOVE	D,BLKSIZ	;CHECK AND SEE IF WE ARE AT THE
	CAILE	D,1		;   BEGINNING OF THE OUTPUT BUFFER.
	JRST	NOMAP		;   IF NOT, THEN DO NOT MAKE A MAP ENTRY
	HRLZ	B,BLKCNT	;PICK UP RELATIVE BLOCK ADDRESS.
	MOVE	D,MAPPTR	;PICK UP CURRENT MAP PONTER
	MOVEM	B,MAP.+1(D)	;SAVE OFFSET,,BLOCK# IN MAP.
	MOVE	B,PPNSAV	;PICK UP PPN OF ENTRY
	TLZ	B,400000	;SIGN BIT IS NEVER LEGAL FOR A PPN BUT
				; WILDCARDING MIGHT TURN IT ON
	MOVEM	B,MAP.(D)	;SAVE PPN ENTRY # IN MAP
	ADDI	D,2		;POINT TO NEXT MAP ENTRY
	MOVEM	D,MAPPTR	;AND SAVE IT FOR NEXT INSERT.
	CAIL	D,PRJWPB	;ARE WE STILL IN CURRENT BUFFER?
	PUSHJ	P,WRTMAP	;IF NOT, THEN WRITE MAP BUFFER.
NOMAP:	HRRZ	B,TBLSIZ	;PICK UP TABLE SIZE.
	ADDM	B,BLKSIZ	;ADD IT TO CURRENT BLOCK SIZE.
	SETZM	TBLSIZ		;ZERO CURRENT TABLE SIZE
	MOVEI	TBLPTR,TABLE	;RESET CURRENT TABLE POINTER.
DONTBD:	MOVEM	C,PPNSAV	;SAVE THE NEW PPN
	POPJ	P,		;RETURN TO CALLER
WRTHDR:
IFN <PRJWPB-200>,<		;IF LOGICAL BLOCKS ARE BIGGER THAN PHYSICAL ONES
	MOVNI	A,200		;HEADERS ARE ONLY 1 REAL DISK BLOCK
	HRLM	A,OTCCW		;CLOBBER IO WORD COUNT
	PUSHJ	P,WRTBFR	;WRITE ONLY 1 DISK BLOCK
	MOVNI	A,PRJWPB	;RESTORE LOGICAL DISK BLOCK SIZE
	HRLM	A,OTCCW		;STORE
	POPJ	P,		;AND RETURN
> ; OTHERWISE, WRTHDR = WRTBFR

WRTBFR:	OUT	5,OTCCW		;WRITE OUT THE BUFFER
	JRST	.+3		;IF OUTPUT OK, CONTINUE
	OUTSTR	[ASCIZ\I/O ERROR WRITING PROJCT.SYS FILE.\]
	JRST	FINISH
	SETZM	OTBFR		;ZERO THE CURRENT BLOCK SIZE
	MOVE	A,[OTBFR,,OTBFR+1] ;SET UP SOURCE,,DEST BLT PARMS
	BLT	A,OTBFR+PRJWPB-1	;ZERO THE OUTPUT BUFFER.
	AOS	BLKSIZ		;ADD 1 TO BLOCK SIZE
	AOS	BLKCNT		;ADD 1 TO BLOCK COUNT
	POPJ	P,		;RETURN TO CALLER

WRTMAP:	OUT	6,MPCCW		;WRITE OUT THE MAP BUFFER.
	JRST	.+3		;IF OUTPUT OK, CONTINUE.
	OUTSTR	[ASCIZ\I/O ERROR WRITING TEMP MAP FILE.\]
	JRST	FINISH		;GO EXIT FROM PROGRAM
	AOS	MAPCNT		;ADD 1 TO MAP BLOCK COUNTER.
	SETZM	MAPPTR		;ZERO THE CURRENT MAP POINTER
	SETZM	MAP.		;ZERO THE FIRST WORD OF MAP BUFFER.
	MOVE	A,[MAP.,,MAP.+1] ;   SET UP SOURCE,,DEST BLT PARMS
	BLT	A,MAP.+PRJWPB-1	;   AND ZERO THE REST OF MAP BUFFER.
	POPJ	P,		;RETURN TO CALLER.

	SUBTTL ENDJOB - ROUTINE TO PERFORM END-OF-JOB FUNCTIONS.

ENDJOB:	SKIPL	FSTREC		;HAS THE OUTPUT FILE BEEN INITLZED?
	JRST	FILEOK		;IF SO, THEN CONTINUE OEF PROCESSING.
	MOVE	C,P.PN		;PICK UP THE CURRENT [P,PN].
	PUSHJ	P,BLDREC	;GO INITIALIZE THE OUTPUT FILE.
FILEOK:	SKIPG	TBLSIZ		;IS THERE ANYTHING IN TEMP OUTPUT BUFR ?
	JRST	CHKBLK		;IF NOT, GO CHECK REAL OUTPUT BUFFER.
	MOVE	C,[377777,,-1] ;ELSE SET [P,PN] TO 377777,,777777
	PUSHJ	P,BLDREC	;AND GO BUILD THE OUTPUT BUFFER.
CHKBLK:	MOVE	C,BLKSIZ	;CHECK AND SEE IF WE ARE AT THE START
	CAILE	C,1		;OF THE NEXT OUTPUT BUFFER.
	PUSHJ	P,WRTBFR	;IF NOT, THEN WRITE CURRENT BUFFER.
	SKIPE	B,MAPPTR	;PICK UP  THE DATA MAP POINTER.
	PUSHJ	P,WRTMAP	;WRITE OUT THE LAST PARTIAL MAP BUFFER.
	USETO	5,1		;POINT TO FIRST OUTPUT BLOCK.
	MOVEI	10,ACVERS	;PICK UP VERSION NUMBER.
	MOVEM	10,OTBFR	;SAVE IT IN HEADER BLOCK.
	MOVE	10,MAPCNT	;PICK UP # OF MAP BLOCKS WRITTEN.
	JUMPE	10,[OUTSTR [ASCIZ/NO MAP BLOCKS WRITTEN/]
		    JRST FINISH]
	SUBI	10,1		;SUBTRACT 1 TO MAKE RIGHT
	IMULI	10,PRJWPB	;MULTIPLY BY BLOCK SIZE.
	ADDB	10,B		;ADD LAST BLOCK SIZE
	MOVEM	10,OTBFR+1	;SAVE IT IT HEADER BLOCK
	MOVEI	10,PRJWPB	;GET NUMBER OF WORDS THIS WAS ASSEMBLED FOR
	MOVEM	10,OTBFR+3	;STORE FOR ACTDAE CHECKS
	MOVE	10,BLKCNT	;PICK UP POINTER TO NEXT BLOCK
	MOVEM	10,OTBFR+2	;SAVE IT IN HEADER BLOCK
	PUSHJ	P,WRTHDR	;WRITE OUT THE HEADER BLOCK
	SUBI	10,2		;BLOCK NUMBER - 2
	IMULI	10,<PRJWPB/200>	;* NUMBER OF BLOCKS PER BUFFER
	USETO	5,2(10)		; + 2 = REAL DISK BLOCK ADDRESS
	USETI	6,1		;POINT TO FIRST MAP BLOCK.
GETMAP:	IN	6,OTCCW		;READ A MAP BLOCK
	JRST	.+3		;IF OK, THEN CONTINUE
	OUTSTR	[ASCIZ\I/O ERROR READING TEMP MAP FILE.\]
	JRST	FINISH		;GO END THE PROGRAM
IFN <PRJWPB-200>,<		;IF MORE THAT 1 REAL DISK BLOCK PER LOGICAL ONE
	CAIGE	B,PRJWPB	;SEE IF DOING LAST (PARTIAL) MAP BLOCK
	JRST	[MOVN A,B	;YES, ONLY WRITE OUT WHAT IS NEEDED
		 HRLM A,OTCCW	;TO SAVE DISK SPACE IF PRJWPB IS VERY LARGE
		 JRST .+1]	;RESUME INLINE
	SUBI	B,PRJWPB	;ADJUST COUNT
>
	PUSHJ	P,WRTBFR	;GO WRITE OUT THE MAP BLOCK.
	SOSLE	MAPCNT		;CHECK MAP COUNTER.
	JRST	GETMAP		;IF MORE MAP BLOCKS, GO GET THEM.

FINISH:	CLOSE	4,		;CLOSE THE MASTER INPUT FILE.
	CLOSE	5,		;CLOSE THE PROJCT.SYS FILE.
	CLOSE	6,		;CLOSE THE TEMP MAP FILE.
	CRLF
	OUTSTR	[ASCIZ/END OF JOB./]
	CRLF
	EXIT

	SUBTTL CV2OCT - ROUTINE TO CONVERT [P,PN] TO BINARY OCTAL.

CV2OCT:	MOVEM	TBLPTR,SAVE		;SAVE CONTENTS OF AC TBLPTR
	MOVEM	B,SAVE+1		;SAVE CONTENTS OF AC B
	MOVE	B,[POINT 7,PPN]	;PICK UP PPN POINTER
	MOVEM	B,PPNPTR		;AND SAVE IT.
	MOVE	13,PPNCNT		;SAVE PPNCNT FOR POSSIBLE WLDCRD CHECK
	SETZ	C,			;SET RESULT AC TO 0
	SETO	MASK,			;CLEAR OUT WILD-CARD MASK.
OCTLOP:	LSH	C,3			;SHIFT RESULT AC LEFT 3 BITS
	LSH	MASK,3			;SHIFT MASK AC LEFT 3 BITS.
	ILDB	TBLPTR,B		;PICK UP AN ASCII DIGIT
	CAIN	TBLPTR,"?"		;IS THIS A ? WILD-CARD ?
	JRST	[TRO C,7
		JRST OCTL.1]		;NOTE IN RESULT
	SUBI	TBLPTR,60		;CONVERT IT TO BINARY
	ADD	C,TBLPTR		;ADD BINARY DIGIT TO RESULT
	TRO	MASK,7			;SET MASK BITS TO 111.
OCTL.1:	SOSE	PPNCNT			;SUBTRACT 1 FROM BYTE COUNT
	JRST	OCTLOP			;IF NOT 0, CONVERT SOME MORE.
OCTL.2:	MOVE	TBLPTR,SAVE		;RESTORE AC TBLPTR
	MOVE	B,SAVE+1	;RESTORE AC B
	POPJ	P,			;RETURN TO MAIN ROUTINE


	SUBTTL RESET (A & B) - ROUTINES TO RE-INITIALIZE DATA AREAS & PTRS.

RESETA:	MOVE	C,[POINT 7,OUTREC,6] ;RESET THE ERROR MSG
	MOVEM	C,OUTPTR	;OUTPUT BUFFER POINTER
	MOVEI	C,40*5		;NUMBER OF CHARACTERS IN OUTREC
	MOVEM	C,ORCSIZ	;SAVE
	SETOM	CMCNT		;RESET THE COMMA COUNTER
	SETOM	LBCNT		;RESET THE LEFT BRACKET COUNTER
	SETOM	RBCNT		;RESET THE RIGHT BRACKET COUNTER
	SETOM	EQCNT		;RESET THE EQUAL SIGN COUNTER
	SETOM	.WILD		;RESET THE WILD-CARD FLAG.
	SETO	ERRTYP,		;INDICATE NO ERRORS
	SETZ	FIELD,		;INDICATE [P,PN] FIELD
	POPJ	P,		;RETURN TO CALLER
	
RESETB:	MOVE	C,[POINT 7,SWTCH.] ;RESET THE SWITCH POINTER
	MOVEM	C,CS.PTR	;...
	MOVE	C,[POINT 7,AS.FLD] ;    ACCOUNT STRING
	MOVEM	C,AS.PTR	;     BYTE POINTERS.
	SETZM	AS.FLD		;ZERO OUT
	MOVE	C,[AS.FLD,,AS.FLD+1] ; ACCOUNT STRING
	BLT	C,AS.FLD+7	;         SAVE AREA.
	SETZM	AS.LEN		;SET ACCOUNT STRING LENGTH TO 0
	SETOM	WLASFL		;NO "*" SEEN NOW
	SETZM	WLDASF		;NO WILD CARDED ASSOUNT STRING
	SETOM	SLCNT		;RESET THE SLASH COUNTER
	SETZM	CS.LEN		;ZERO /SWTCH. LENGTH
	SETZM	SWTCH.		;ZERO OUT
	POPJ	P,		;RETURN TO CALLER.

	SUBTTL DATA - RPOGRAM DATA AREAS, POINTERS, AND I/O BUFFERS.

.WILD:	EXP	-1
SLCNT:	EXP	-1
CMCNT:	EXP	-1
LBCNT:	EXP	-1
RBCNT:	EXP	-1
EQCNT:	EXP	-1
FSTREC:	EXP	-1
WLASFL:	EXP	-1
WLDASF:	0,,0
PPNMSK:	0,,0
MAPPTR:	0,,0
BLKCNT:	0,,1
MAPCNT:	0,,0
TBLSIZ:	0,,0
TABLE:	BLOCK	PRJWPB
SWTCH.:	BLOCK	1
AS.LEN:	0,,0
AS.FLD:	BLOCK	10
P.PN:	0,,0
PPNSAV:	0,,0
STACK:	BLOCK	100
PPNCNT:	0,,0
PPN:	BLOCK	2
SAVE:	BLOCK	2
CS.LEN:	0,,0
ORCSIZ:	EXP	40*5
OUTREC:	BLOCK	40
OUTPTR:	POINT	7,OUTREC
AS.PTR:	POINT 	7,AS.FLD
PPNPTR:	POINT	7,PPN
CS.PTR:	POINT	7,SWTCH.

ERMSG:	[ASCIZ/NON-NUMERIC BYTE ENCOUNTERED IN [P,PN] FIELD./]
	[ASCIZ/[P,PN] FIELD TERMINATED BY CR!LF./]
	[ASCIZ/NON-OCTAL DIGIT ENCOUNTERED IN [P,PN] FIELD./]
	[ASCIZ/MULTIPLE COMMA'S ENCOUNTERED IN [P,PN] FIELD./]
	[ASCIZ/NULL PROJECT NUMBER ENCOUNTERED IN [P,PN] FIELD./]
	[ASCIZ/MULTIPLE EQUAL SIGNS ILLEGAL./]
	[ASCIZ/NULL PROGRAMMER NUMBER ENCOUNTERED IN [P,PN] FIELD./]
	[ASCIZ/LENGTH OF PPN EXCEEDS 6 DIGITS./]
	[ASCIZ/MULTIPLE ['S ENCOUNTERED IN [P,PN] FIELD./]
	[ASCIZ/MULTIPLE ]'S ENCOUNTERED IN [P,PN] FIELD./]
	[ASCIZ/NULL ACCOUNT STRING ENCOUNTERED IN A.S. FIELD./]
	[ASCIZ/SPECIFIED [P,PN] IS NOT IN ASCENDING [P,PN] SEQUENCE./]
	[ASCIZ/HISTORICAL ERROR, YOU SHOULDN'T GET THIS./]
	[ASCIZ\NULL /SWTCH. FIELD ILLEGAL.\]
	[ASCIZ/ACCOUNT FIELD LENGTH EXCEEDS 39 CHARACTERS./]
	[ASCIZ/EQUAL (=) SIGN MISSING FROM ACCOUNT STRING FIELD./]
	[ASCIZ/ILLEGAL WILD-CARD SYNTAX IN [P,PN] FIELD./]
	[ASCIZ/ILLEGAL CHARACTER IN SWITCH FIELD./]
	[ASCIZ/WILD-CARD * NOT LAST IN A.S. FIELD./]
	[ASCIZ/SWITCH IMPROPERLY PLACED./]
	[ASCIZ/UNKNOWN SWITCH SPECIFIED./]
	[ASCIZ/DEFAULT ACCOUNT STRING MAY NOT CONTAIN WILD-CARDS./]
WLDMSG:	BYTE(7) 12,15,127,111,114	;LF,CR,W,I,L
	ASCIZ/D-CARD CHARACTERS  * AND ?  EQUAL ZERO./
	
INPFIL:	4,,.FORED
	.IOASL
	SIXBIT/DSK/
	0,,IBCB
	0,,-1
	0,,INFILE
INFILE:	SIXBIT/PROJCT/
	SIXBIT/ACT/
	0,,0
	0,,0
IBCB:	0,,0
IBFPTR:	0,,0
IBFCNT:	0,,0
	
OUTFIL:	5,,.FOWRT
	.IODMP
	SIXBIT/DSK/
	0,,0
	0,,0
	0,,OTFILE
OTFILE:	SIXBIT/PROJCT/
	SIXBIT/SYS/
	0,,0
	0,,0
	
MAPFIL:	6,,.FOSAU
	.IODMP
	SIXBIT/DSK/
	0,,0
	0,,0
	0,,MPFILE
MPFILE:	SIXBIT/PROJCT/
	SIXBIT/MAP/
	0,,0
	0,,0

	
OTCCW:	IOWD	PRJWPB,OTBFR	
	0,,0
OTBFR:
BLKSIZ:	0,,1
	BLOCK	PRJWPB-1

MPCCW:	IOWD	PRJWPB,MAP.
	0,,0
MAP.:	BLOCK	PRJWPB

	LALL
PROCES:	REPEAT	12,<	0,,GETBYT>
	0,,CR
	0,,GETBYT
	0,,GETBYT
	0,,CR
	REPEAT	23,<	0,,GETBYT>
	REPEAT	11,<	0,,STOREC>
	0,,WLDCRD
	0,,STOREC
	0,,COMMA
	0,,STOREC
	0,,STOREC
	0,,SLASH
	REPEAT 	12,<	0,,NUMBER>
	0,,STOREC
	0,,STOREC
	0,,LBRKT
	0,,EQUALS
	0,,RBRKT
	0,,WLDCRD
	0,,STOREC
	REPEAT	32,<	0,,ALPHA>
	0,,LBRKT
	0,,STOREC
	0,,RBRKT
	REPEAT	40,<	0,,STOREC>
	0,,GETBYT
	0,,GETBYT

	END	PROJCT
