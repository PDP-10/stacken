;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976,1984,1986.
;ALL RIGHTS RESERVED.
;

	SUBTTL	SAVE FILE ROUTINES
;
; BOOT FILE PROCESSING ROUTINE
;
SAVGRC:	MOVE P2,[POINT 8,SCRBUF] ;POINT TO SCRATCH
	MOVEM P2,INPTR
	SETZB P1,P3		;ZERO BYTE COUNTS
	CALL GETCHR		;GET A CHARACTER
	 JRST CRET		;EOF - EXIT
	JUMPL C,SAVGR1		;GO SAVE <-WC,,ADDR>
	HRRZI	T2,0(C)		; MAKE A REAL TRANSFER WORD
	JRST SAVGR2		; LOAD THE TRANSFER WORD IN THE FILE
SAVGR1:	HLRE P1,C		;SAVE THE WORD COUNT
	MOVEI T2,1(C)		;COMPUTE ADDRESS+1
SAVGR2:
	LDB T1,[POINT 8,T2,35]
	IDPB T1,P2
	LDB T1,[POINT 8,T2,27]
	IDPB T1,P2
	LDB T1,[POINT 8,T2,19]
	IDPB T1,P2
	LDB T1,[POINT 8,T2,11]
	IDPB T1,P2		;SAVE 4-BYTE ADDRESS
	ADDI P3,4
	JUMPGE C,SAVGR4		;ALL DONE IF TRANSFER WORD
SAVGR3: CALL GETCHR		;GET DATA
	 ERRI <PREMATURE END-OF-FILE>,CRET
	LDB T1,[POINT 8,C,35]	;PUT BITS 28-35 IN -11 BUFFER
	IDPB T1,P2
	LDB T1,[POINT 8,C,27]	;PUT BITS 20-27 IN -11 BUFFER
	IDPB T1,P2
	LDB T1,[POINT 8,C,19]	;PUT BITS 12-19 IN -11 BUFFER
	IDPB T1,P2
	LDB T1,[POINT 8,C,11]	;PUT BITS 4-11 IN -11 BUFFER
	IDPB T1,P2
	LDB T1,[POINT 4,C,3]	;PUT BITS 0-3 IN -11 BUFFER
	IDPB T1,P2
	ADDI P3,5		;ADD TO -11 BYTE COUNT
	AOJL P1,SAVGR3		;CONTINUE UNTIL WORD COUNT EXHAUSTED
SAVGR4:	MOVE C,P3		;END OF RECORD - COPY OUTPUT BYTE COUNT
	RETSKP			;RETURN, BYTE COUNT IN C
;
SAVEIR:
	RETURN
SAVPRC:
SAVPBY:
SAVEOR:
	ERRI <SAVE FILE OUTPUT NOT IMPLEMENTED>,CRET
SUBTTL	RAMGRC --  CONVERT ASCIIZED RAM FILE TO BINARY 7-JUL-76/RAB

; HERE TO GET A BYTE FROM THE CONVERTED FILE
; THE BYTE IS RETURNED IN AC "C". "RAMGBY" ALWAYS TAKES A SKIP RETURN.

RAMGBY:
	ILDB	C,INPTR		; CURRENT BYTE TO "C"
	RETSKP			; OFF INTO THE COSMIC VOID

; HERE TO CONVERT ONE LINE OF THE INPUT FILE AND RETURN THE BYTE COUNT IN "C"
; COMMENTS, NULL LINES, AND ZERO COMMANDS ARE IGNORED. CHARACTERS
; WHICH BEGIN A LINE OTHER THAN "C", "D", "Z", OR ";" ARE FLAGGED AS
; ERRORS AND THAT LINE IS IGNORED. "RAMGRC" ALWAYS TAKES A SKIP RETURN,
; EXCEPT ON END-OF-FILE, WHERE IT TAKES A DIRECT RETURN.

RAMGRC:	JUMPN	IC,CRET		; EXIT IF E-O-F FLAG SET
	MOVE	P4,[POINT 16,SCRBUF]
	SETZ	P3,0		; RESET THE BYTE COUNT
	CALL	GETCHR		; READ THE FIRST CHARACTER OF THIS LINE
	 JRST RAMEOF		; E-O-F -- EXIT
	JUMPE	C,RAMGRC	; IGNORE NULLS
	CAIE	C,.CHLFD	; NEW-LINE?
	CAIN	C,.CHCRT	; CARRIAGE-RETURN?
	JRST	RAMGRC		; YES -- IGNORE NULL LINE
	CAIN	C,"C"		; C(RAM)?
	JRST	RAMCRM		; YES
	CAIN	C,"D"		; D(RAM)?
	JRST	RAMDRM		; YES
	CAIE	C,"Z"		; Z(ERO CRAM)?
	CAIN	C,";"		; COMMENT?
	SKIPA	0,0		; YES, SKIP OVER ERROR
	 ERRI	<ILLEGAL RAM INPUT CHARACTER>,RAMSKP
	;

; HERE TO GET OVER A NULL LINE. THE LINE IS SCANNED UNTIL A
; <NEW-LINE> CHARACTER IS SEEN AND CONTROL IS PASSED TO "RAMGRC"

RAMSKP:
	CALL	RAMNUL		; GET OVER THE NULL LINE
	JRST	RAMGRC		; AND LOOK AT THE NEXT LINE

; HERE TO READ OVER A NULL OR ERRONEOUS LINE IN THE INPUT FILE

RAMNUL:
	CALL	GETCHR		; READ A CHARACTER
	 JRST	RAMEOF		; DONE -- GO GET THE NEXT LINE
	CAIE	C,.CHLFD	; IS THIS A NEW-LINE?
	JRST	RAMNUL		; NO -- GO GET THE NEXT CHARACTER
	RETURN			; YES -- EXIT

; HERE TO PROCESS THE CRAM ADDRESS (FLAG IT WITH 1B16)

RAMCRM:
	CALL	RAMCNT		; GET THE WORD COUNT
	CALL	RAMCRA		; CONVERT THE ADDRESS
	JRST	RAMCMN		; DO COMMON CODE

; HERE TO PROCESS THE DRAM WORD

RAMDRM:
	CALL	RAMCNT		; GET THE WORD COUNT
	CALL	RAMWRD		; CONVERT THE ADDRESS
	JRST	RAMCMN		; CONVERT THE DATA

; HERE TO GET OVER THE BYTE COUNT AND PROCESS THE REST OF THE LINE

RAMCNT:
	MOVE	P2,P4		; SAVE THE BYTE POINTER IN P2
	CALL	RAMWRD		; CONVERT THE WORD COUNT
	JUMPE	P1,RMCNTN	; IGNORE NULL LINES
	SUBI	P3,2		; RESET THE BYTE COUNT
	MOVE	P4,P2		; RESET THE BYTE POINTER
	LSH	P1,-^D8		; STRAIGHTEN THE WORD COUNT OUT
	MOVE	P2,P1		; WORD COUNT TO P2
	RETURN			; WORD COUNT IN P2
RMCNTN:
	HRRI	T1,RAMSKP	; GET OVER NULL LINE
	HRRM	T1,0(P)		; FUDGE RETURN ADDRESS
	RETURN			; SO
RAMCMN:
	CALL	RAMWRD		; CONVERT THE WORD
	SOJN	P2,RAMCMN	; AND LOOP TILL DONE
	CALL	RAMNUL		; END THIS LINE
RAMEOL:
	MOVE	C,P3		; BYTE COUNT TO "C"
	MOVE	T1,[POINT 8,SCRBUF]
	MOVEM	T1,INPTR	; SET UP THE BYTE POINTER
	RETSKP			; BYTE COUNT FOR THIS LINE IS IN "C"

; HERE TO PROCESS END OF FILE

RAMEOF:
	SETO	IC,0		; FLAG THE E-O-F
	MOVEI	P3,2		; BYTE COUNT TO P3
	MOVX	T1,1B<15-7>	; FLAG THE XFER ADDRESS
	MOVEM	T1,SCRBUF	; SET IT IN THE BUFFER
	JRST	RAMEOL		; EXIT THRU RAMEOL

; HERE TO CONVERT THE CRAM ADDRESS

RAMCRA:
	TXO	F,F.CRMA	; SAY THIS IS A CRAM ADDRESS

; HERE TO CONVERT ONE WORD

RAMWRD:
	SETZ	P1,0		; CLEAR P1
	CALL	RAMCHR		; CONVERT THE FIRST CHARACTER
	 JRST	RAMEND		; END OF THIS WORD
	MOVE	P1,T2		; SAVE IT IN "P1"
	CALL	RAMCHR		; CONVERT THE SECOND CHARACTER
	 JRST	RAMEND		; END OF THIS WORD
	LSH	P1,^D6		; POSITION PREVIOUS
	IOR	P1,T2		; AND STASH IT AWAY
	CALL	RAMCHR		; CONVERT THE THIRD CHARACTER
	 JRST	RAMEND		; END OF THIS WORD
	LSH	P1,^D6		; POSITION PREVIOUS
	IOR	P1,T2		; FINISH THE WORD UP
RAMEND:
	CAIE	C,.CHLFD	; WAS THE LAST CHARACTER A <NEW-LINE>?
	CAIN	C,","		; OR A COMMA?
	JRST	RAMENX		; YES -- JUST EXIT
	CALL	GETCHR		; NO -- GET OVER THE TRAILING WHATEVER
	 ERRI	<PREMATURE END-OF-FILE>,CRET
	CAIE	C,.CHLFD	; IS IT A <NEW-LINE>?
	CAIN	C,","		; OR A <COMMA>?
	JRST	RAMENX		; YES -- ALL OK
	 ERRI	<ILLEGAL RAM FILE FORMAT>,CRET
RAMENX:
	TXZE	F,F.CRMA	; WAS THIS A CRAM ADDRESS?
	IORI	P1,1B<35-15>	; YES -- FLAG IT
	LDB	T1,[POINT 8,P1,27]
	LSH	P1,^D8		; FINISHED -- SWAP THE BYTES
	IOR	P1,T1		; SET THE HIGH BYTE
	IDPB	P1,P4		; LOAD THE BYTE
	ADDI	P3,2		; INCREMENT THE BYTE COUNT
	RETURN			; AND EXIT

; HERE TO CONVERT A SINGLE CHARACTER

RAMCHR:
	CALL	GETCHR		; GET A CHARACTER
	 ERRI	<PREMATURE END-OF-FILE>,CRET
	JUMPE	C,RAMCHR	; FLUSH NULLS
	CAIE	C,.CHTAB	; TAB?
	CAIN	C,40		; SPACE?
	JRST	RAMCHR		; YES -- FLUSH THOSE TOO
	CAIN	C,.CHCRT	; CARRIAGE RETURN?
	JRST	RAMCHR		; YES -- FLUSH IT
	CAIE	C,","		; COMMA?
	CAIN	C,.CHLFD	; NEW-LINE?
	 RETURN			; YES -- GIVE EOL RETURN
	CAIGE	C,75		; IS THIS CHARACTER LEGAL?
	 ERRI	<ILLEGAL RAM CHARACTER>,RAMCHR
	MOVE	T2,C		; PUT THE CHARACTER IN AC "T2"
	ANDI	T2,77		; CONVERT THE CHARACTER
	RETSKP			; SKIP RETURN

RAMEIR:
	RETURN			; INTO THE GREAT BEYOND

RAMPRC:
RAMPBY:
RAMEOR:
	ERRI	<RAM FILE OUTPUT NOT IMPLEMENTED>,CRET
	SUBTTL	7-BIT-ASCII ROUTINES
;
; 7-BIT ASCII ROUTINES
;
DSAGRC:
	MOVE P2,[POINT 7,SCRBUF] ;POINT TO SCRATCH
	MOVEM P2,INPTR		;SAVE THE FRESH POINTER FOR FETCHING BYTES
	SETZ P1,		;NO BYTES YET
DSAGR1:
	CALL GETCHR		;GET A CHARACTER FROM INPUT
	 JRST DSAGR3		;EOF-- THAT'S IT IF NULL RECORD
	JUMPE C,DSAGR1		;IGNORE NULLS
	CAIE C,.CHFFD		;<FF> OR
	TXNE F,F.IBCR		;IMBEDDED <CR><LF>'S?
	 AOJA P1,DSAGR2		;YES-- PUT CHAR AWAY
	CAIN C,.CHCRT		;<CR>?
	 JRST DSAGR1		;YES-- IGNORE
	CAIE C,.CHLFD		;<LF>?
	CAIN C,.CHCNS		;SINGLE SPACE?
	 JRST DSAGR4		;YES-- END OF RECORD
	IDPB C,P2		;NO-- STORE BYTE
	AOJA P1,DSAGR1		; AND GET ANOTHER
;
DSAGR2:
	IDPB C,P2		;STORE BYTE
	CAIE C,.CHLFD		;<LF>?
	CAIN C,.CHFFD		; OR <FF>?
	 JRST DSAGR4		;YES-- END OF RECORD
	JRST DSAGR1		;NO-- GET NEXT CHARACTER
;
DSAGR3:
	JUMPE P1,CRET		;EOF-- DONE NOW IF NULL RECORD
DSAGR4:
	MOVE C,P1		;END OF RECORD-- COPY THE BYTE COUNT
	RETSKP			;AND SKIP BACK FROM DSAGRC
;
;
DSAEOR:
	CAIE C,.CHFFD		;LAST CHAR = <FF>?
	TXNE F,F.IBCR!F.TIBC	;IMBEDDED CR'S?
	 RETURN			;YES-- DON'T ADD ANY
	MOVEI C,.CHCRT		;GET <CR>
	CALL @PBYTAB(OM)	;AND OUTPUT IT
	MOVEI C,.CHLFD		;AND THE <LF>
	TXNE F,F.LFSS!F.TLFS	;LINE-FEED = SINGLE SPACE?
	 MOVEI C,.CHCNS		;YES-- USE SINGE-SPACE (^S)
	CALLR @PBYTAB(OM)	; AND RETURN FROM DSAEOR
	SUBTTL	DOS-BINARY ROUTINES
;
; DOS-BINARY ROUTINES
;
DSBGRC:
	SETZM INCHK		;RESET INPUT CHECKSUM
DSBGR1:
	CALL GETBYT		;GET AN INPUT BYTE
	 RETURN			;THAT'S ALL, FOLKS
	JUMPE C,DSBGR1		;LOOP FOR NON-ZERO BYTE
	CAIE C,1		;FIRST BYTE= 1?
BADBLK:	 ERRI <BAD BLOCK FORMAT>,DSBGR1
	CALL GETBYT		;GET THE HIGH BYTE OF THE 1
	 ERRI <PREMATURE END-OF-FILE>,CRET
	JUMPN C,BADBLK		;MUST BE ZERO
	CALL GET2BY		;GET BYTE COUNT WHICH FOLLOWS
	 ERRI <PREMATURE END-OF-FILE>,CRET
	SUBI C,4		;REAL BYTE COUNT, LESS OVERHEAD WORDS
	RETSKP			;RETURN, BYTE COUNT IN C
;
;
DSBEIR:
	CALL GETBYT		;GET THE CHECKSUM
	 ERRI <PREMATURE END-OF-FILE>,CRET
	MOVE T1,INCHK		;ALL TOGETHER NOW
	TXNE T1,377		; SHOULD BE ZERO BYTE
	 ERRI <BAD CHECKSUM>,CRET
	RETURN			;OK FROM DSBEIR
;
;
DSBPRC:
	SETZM OUTCHK		;RESET OUTPUT CHECKSUM
	MOVEI C,1		;FIRST BYTES =1,0
	CALL PUT2BY		;PUT 'EM AWAY
	MOVEI C,4(P1)		;GET THE BYTE COUNT BACK
	CALLR PUT2BY		;PUT THE WORD AWAY, AND RETURN FROM DSBPRC
;
;
DSBEOR:
	MOVN C,OUTCHK		;GET OUTPUT CHECKSUM
	CALL PUTBYT		;PUT IT AWAY
	MOVX C,0		;NULL
	CALL PUT2BY		;2 BYTES OF NULL
	CALL PUT2BY		;4 BYTES OF NULL
	CALLR PUT2BY		;6 BYTES OF NULL, AND RETURN
	SUBTTL	IMAGE-BINARY ROUTINES
;
; IMAGE-BINARY ROUTINES
;
IMBGRC:
	SETZ P1,		;RESET BYTE COUNT
	MOVE P2,[POINT 8,SCRBUF] ;POINT TO SCRATCH
	MOVEM P2,INPTR		;SAVE THE POINTER FOR GET BYTES,ALSO
	MOVE P3,RCDSIZ		;COPY RECORD-SIZE, ALSO
	TXNN F,F.ADDR		;NO ADDRESS WORDS ON OUTPUT?
	 JRST IMBGR1		;YES-- SKIP THEM
	MOVE T1,INADR		;GET CURRENT INPUT ADDRESS
	IDPB T1,P2		;STORE THE LOW BYTE ADDRESS
	LSH T1,-^D8		;GET HIGH BYTE
	IDPB T1,P2		;STORE THAT,TOO
	SUBI P3,2		;DECREMENT RECORD COUNT
IMBGR1:
	CALL GETBYT		;GET AN INPUT BYTE
	 JRST IMBGR2		;EOF-- FINISH OFF
	IDPB C,P2		;STORE THE BYTE
	ADDI P1,1		;BUMP COUNT
	SOJG P3,IMBGR1		;COUNT DOWN ONE FROM RECORD SIZE
IMBGR2:
	JUMPE P1,CRET		;ZERO BYTES-- RETURN ON EOF
	ADDM P1,INADR		;BUMP ADDRESS
	TXNE F,F.ADDR		;NO ADDRESSES?
	 ADDI P1,2		;NO-- ADD TWO BYTES OF ADDRESS
	MOVE C,P1		;COPY BYTE COUNT
	RETSKP			;SKIP BACK FROM IMBGRC
;
;
SAVGBY:
DSAGBY:
IMBGBY:
	ILDB C,INPTR		;GET A BYTE FROM SCRBUF
	RETSKP			;ALWAYS OK
;
;
IMBPRC:
	TXNN F,F.ADDR		;ADDRESSES IN FILE?
	 TDZA T1,T1		;NO-- SKIP NOT
	MOVEI T1,2		;YES-- SKIP 2 BYTES
	MOVEM T1,OUTADR		;SAVE THAT COUNT
	RETURN			;RETURN FROM IMBPRC
;
;
IMBPBY:
	SOSGE OUTADR		;SKIPED ADDRESS YET?
	 CALL PUTBYT		;YES-- PUT THE BYTE AWAY
	RETURN			;FROM IMBPBY
	SUBTTL	COMMON I/O ROUTINES
;
; GET2BY -- GET A WORD FROM TWO BYTES OF INPUT
;
GET2BY:
	CALL GETBYT		;GET FIRST BYTE
	 RETURN			;JUST GIVE UP
	HRLM C,(P)		;SAVE THE BYTE ON STACK
	CALL GETBYT		;GET HIGH BYTE
	 RETURN			;EOF-- RETURN +1
	LSH C,^D8		;SHIFT TO HIGH BYTE
	HLRZ T1,(P)		;GET LOW BYTE AGAIN
	IOR C,T1		;SAVE ASSEMBLED WORD
	RETSKP			;FROM GET2BY
;
; GETBYT -- GET AN 8-BIT BYTE FROM INPUT
;
GETBYT:
	SKIPGE C,IC		;GET OLD BYTE, IF ANY
	 JRST GETBY2		;GOT IT-- GO ON
	CALL GETWRD		;DON'T HAVE IT-- GET NEXT TWO BYTES
	 RETURN			;EOF-- RETURN +1
	TXOA C,1B0		;NOTE WE HAVE A BYTE HERE
GETBY2:	 LSH C,-^D8		;GET HIGH BYTE
	MOVE IC,C		;AND SAVE THE WORD FOR NEXT CALL
	ANDI C,377		;TRIM TO A BYTE
	ADDM C,INCHK		;ACCUMULATE INPUT CHECKSUM
	RETSKP			;FROM GETBYT
;
; GETWRD -- GET A WORD FROM INPUT FILE
;
GETWRD:
	SETZ IC,		;NO LONGER A BYTE TO INPUT
	CALLRX GETCHR		;GET THE NEXT CHAR
;
; GETCHR -- GET A CHARACTER FROM THE INPUT FILE
;
GETCHR:
IF TOPS-10, <
	CALLR	FILIN		; READ A BYTE AND RETURN
>		; END CONDITIONAL ON TOPS-10
IF TOPS-20, <
	HRRZ T1,INJFN		;GET THE INPUT JFN
	BIN			;GET THE BYTE
>		; END CONDITIONAL ON TOPS-20

GETEOF:
	MOVE C,T2		;GET THE CHARACTER TO C
CRET1:
	 AOS(P)			;SKIP RETURN
CRET:
	RETURN			;RETURN +1
;
; PUT2BY -- PUT 2 BYTES FROM A WORD INTO OUTPUT FILE
;
PUT2BY:
	HRLM C,(P)		;SAVE THE CHARACTER
	CALL PUTBYT		;STORE LOW BYTE
	HLRZ C,(P)		;GET THE WORD AGAIN
	LSH C,-^D8		;BUT HIGH BYTE THIS TIME
	CALLRX PUTBYT		;STORE IN OUTPUT, RETURN FROM PUT2BY
;
; PUTBYT -- PUT BYTE IN OUTPUT FILE
;
PUTBYT:
	ANDI C,377		;TRIM TO A BYTE
	ADDM C,OUTCHK		;ACCUMULATE OUTPUT CHECKSUM
	JUMPL OC,PUTBY2		;SKIP IF ALREADY A BYTE TO OUTPUT
	TXO C,1B0		;NOPE-- SAY WE HAVE A BYTE
	MOVE OC,C		; AND SAVE IT
	RETURN			;FROM PUTBYT
;
PUTBY2:
	LSH C,^D8		;SHIFT NEW BYTE TO HIGH BYTE
	IOR C,OC		;PUT IN THE LOW BYTE FROM LAST CALL
	SETZ OC,		; AND RESET THE BYTE
	CALLRX PUTWRD		;PUT WORD, AND RETURN FROM PUTBYT
;
; PUTWRD -- PUT A WORD IN OUTPUT FILE
;
PUTWRD:
	EXCH C,OC		;GET OUTPUT BYTE, IF ANY
	SKIPGE C		;ANY LEFT-OVER BYTE?
	 CALL PUTCHR		;YES-- OUTPUT IT
	MOVE C,OC		;GET THE CURRENT CHARACTER
	SETZ OC,		;RESET THE OLD CHARACTER
	CALLRX PUTCHR		;OUTPUT THE CURRENT WORD
;
; PUTCHR -- PUT A CHARACTER IN THE OUTPUT FILE
;
PUTCHR:
IF TOPS-10, <
	CALLR	FILOUT		; PUT IT IN THE FILE AND EXIT
>		; END CONDITONAL ON TOPS-10
IF TOPS-20,<
	HRRZ T1,OUTJFN		;GET OUTPUT FILE JFN
	MOVE T2,C		;ALSO CURRENT CHARACTER
	BOUT			;DO THE BYTE OUTPUT
	RETURN			;ALL DONE
;
; HERE ON TOPS-20 EOF TRAP
;
EOFTRP:
	HRRZ T1,CHN1PC		;GET PC OF TRAP
	MOVEI T2,CRET		;ASSUME EOF FROM GETCHR
	CAIN T1,GETEOF		;EOF FROM GETCHR?
	 JRST EOFTRX		;YES-- RETURN +1
;
	HLRZ T1,CMDJFN		;GET INPUT JFN
	GTSTS			;GET STATUS
	TXNN T2,GS%EOF		;EOF ON COMMAND FILE?
	 ERR <UNEXPECTED END-OF-FILE TRAP>
	TMSG <[END OF COMMAND FILE]
>
	MOVEI T2,CMDRST		;RE-INIT COMMAND
EOFTRX:
	MOVEM T2,CHN1PC		;STORE RETURN PC
	DEBRK			;EXIT FROM INTERRUPT
;
>		; END CONDITIONAL ON TOPS-20
;
DEFGRC==<DEFPRC==<DEFEIR==<DEFEOR==<DEFGBY==<DEFPBY==< CRET >>>>>>
DSAPRC==<DSAEIR==<RSAEIR==<RSAEOR==<RSBEIR==<RSBEOR==< CRET >>>>>>
IMBEIR==<IMBEOR==< CRET >>
;
DSBGBY==<RSAGBY==<RSBGBY==< GETBYT >>>
RSAGRC==<RSBGRC==< GETWRD >>
DSBPBY==<RSAPBY==<RSBPBY==< PUTBYT >>>
RSAPRC==<RSBPRC==< PUTWRD >>
DSAPBY==< PUTCHR >

END	XWD	3,ENTVEC
