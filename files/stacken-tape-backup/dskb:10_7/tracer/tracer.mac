	TITLE	TRACER - Disk trace routine
	SUBTTL	John C. Hallyburton, Jr. 28-Feb-80/JCH

;COPYRIGHT (C) 1979,1980 BY DIGITAL EQUIPMENT CORPORATION,
;MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

	SEARCH	UUOSYM,MACTEN,SNUP
	.REQUIRE SNUP
	SALL

T1=1
T2=2
T3=3
T4=4
P1=5
P2=6
P3=7
P4=10
P=17

; Things as stuffed in at snoop level

OPRSEQ==0	; Sequence
OPRTIM==1	; Jiffy timestamp
OPRJOB==2	; Job number of requestor
OPRUUO==3	; UUO causing request
OPRBLK==4	; Block to be accessed
OPRLOG==5	; Unit logical name
OPRDES==6	; Description of blocks per whatever
OPRPRG==7	; Program running
OPRMVS==10	; Monitor value of S
OPRFBN==11	; File block number
OPRFIL==12	; Filename
OPREXT==13	; Extension
OPRPPN==14	; PPN
OPRSIZ==15	; # blocks to be transferred, 1B0==write
RECLEN==OPRSIZ+1; Record length (stuffed at snoop level)

BUFSIZ=300*RECLEN	; Buffer size must be multiple of RECLEN

	ARRAY PDL[PLEN],BUFFER[BUFSIZ],OBUF[3],UUOJOB[^D200]
	INTEGER %IN,SEQIN,INTLCK

D=1	;I/O channel

TIM==020
PI==004
USRMOD==10000			; User mode PC bit
	OPDEF	RDTIME[DATAI TIM,]
	OPDEF	PIOFF[CONO PI,400]
	OPDEF	PION[CONO PI,200]

	DEFINE	GETMAC(MAC,AC),<;; Macro to define macros
	DEFINE	GET'MAC(NAME,OFFSET),<
	MOVE	%T1,AC
	ADD	%T1,NAME(%R)
	MOVE	%T1,(%T1)	;;NAME(AC)
IFNB <OFFSET>,<
	MOVEM	%T1,OFFSET(%T2)	;;STORE IT
	      >
>>
	GETMAC	UNI,%U,		; Define GETUNI
	GETMAC	DEV,%F,		; Define GETDEV
	GETMAC	CHN,%P1,	; Define GETCHN

	MONREF	<UNIBLK,UNILOG,UNIDES,JBTPRG,DEVBLK>
	MONREF	<TIME,DEVFIL,DEVEXT,DEVPPN,PJOBN,DEVREL>
	MONREF	<.UPMP,CHNNUM,.CPJOB>

IO=20			; WRITE=1, READ=0
IOSMON=400000		; MONITOR I/O==1

IO.MON=400000		; FOR OUR RECORDS
IO.WRT=200000		;  "   "     "

	BRKPNT	STRTI5,COLECT,4
	BRKPNT	PTHFIL,SAVUUO,11,	;PTHFIL+11
	BRKPNT	PTHFIL,GETUUO,16,	;PTHFIL+16

TRACER:	JFCL
	RESET
	MOVE	P,[IOWD PLEN,PDL]
	MOVSI	P1,(CAIA)
	MOVEM	P1,XCTSNP##+1	; We DO want data after .JBFF
	OPEN	D,[EXP 10,'TRACE ',<OBUF,,0>]
	  JRST	NOPEN
	ENTER	D,[EXP 'DSKFIL','BIN   ',0,0]
	  JRST	NOENT
	OUTBUF	D,4
	MTREW.	D,
	MTREW.	D,
	PUSHJ	P,GETINF##
	MOVEI	T1,1
	HPQ	T1,
	  JFCL
	SETZM	%IN
	SETOM	INTLCK
	SETZM	SEQIN
	MOVEI	T1,424		; UUO ADDRESS
	ADDM	T1,.UPMP	; MAKE IT FETCHABLE
	PUSHJ	P,XCTSNP##
	SETZM	P1
	MOVEI	P2,BUFFER
	OUTSTR	[ASCIZ /
Type ^Z to stop snooping! /]

LOOK1:	INCHSL	T1
	JRST	LOOK2
	CAIE	T1,32
	JRST	LOOK1
	CLOSE	D,
	REMBRK
	UNDBRK
	EXIT

LOOK2:	CAMGE	P1,SEQIN
	JRST	PROC1		;WE'VE DONE SOMETHING
	MOVEI	T1,100
	HIBER	T1,
	  JRST	-1
	JRST	LOOK1		;CHECK FOR MORE

;Something happened at snoop level.  Output our version.

PROC1:	MOVE	T1,OPRSEQ(P2)
	PUSHJ	P,.OUT
	TRNN	T1,777
	PUSHJ	P,T1OUT
	MOVE	T1,OPRTIM(P2)
	PUSHJ	P,.OUT
	MOVE	T2,OPRLOG(P2)
	PUSHJ	P,SIXTO5
	PUSHJ	P,.OUT		; DRIVE ID
	MOVE	T2,OPRSIZ(P2)
	SETZM	T1
	LSHC	T1,2
	PUSHJ	P,.OUT		; MONITOR I/O, WRITE BITS
	SETZM	T1
	LSHC	T1,^D34
	PUSHJ	P,.OUT
	MOVE	T1,OPRBLK(P2)
	PUSHJ	P,.OUT		; PHYSICAL BLOCK NUMBER
	MOVE	T1,OPRUUO(P2)
	PUSHJ	P,.OUT		; UUO OF REQUEST
	SETZM	T1
	PUSHJ	P,.OUT		; SPARE
	LDB	T1,[POINT 6,OPRDES(P2),26]
	PUSHJ	P,.OUT		; CONTROLLER TYPE
	LDB	T1,[POINT 3,OPRDES(P2),32]
	PUSHJ	P,.OUT		; UNIT TYPE
	MOVE	T1,OPRMVS(P2)
	PUSHJ	P,.OUT		; DEVIOS(F)
	MOVE	T1,OPRFBN(P2)
	PUSHJ	P,.OUT		; BLOCK NUMBER
	MOVE	T1,OPRJOB(P2)
	PUSHJ	P,.OUT		; JOB NUMBER
	MOVE	T2,OPRPRG(P2)
	PUSHJ	P,SIXTO5	; CONVERT PART OF NAME
	PUSHJ	P,.OUT		; PROGRAM RUNNING (PART 1)
	LSHC	T1,6
	ADDI	T1,40
	LSH	T1,^D29
	PUSHJ	P,.OUT		; PROGRAM RUNNING (PART 2)
	MOVE	T2,OPRFIL(P2)
	PUSHJ	P,SIXTO5
	PUSHJ	P,.OUT		; FILENAME (PART 1)
	LSH	T2,-1
	PUSH	P,T2
	MOVE	T2,OPREXT(P2)
	PUSHJ	P,SIXTO5	; EXT<JNK><JNK>
	LSH	T1,-^D14	; <NUL><NUL>EXT
	ADD	T1,(P)		; X<NUL>EXT
	ADD	T1,[40B6+"."B13]; PART 2 OF FILENAME
	POP	P,(P)		; BYE
	PUSHJ	P,.OUT		; FILENAME (PART 2)
	MOVE	T1,OPRPPN(P2)
	PUSHJ	P,.OUT		; PPN
	ADDI	P2,RECLEN
	CAIN	P2,BUFFER+BUFSIZ 
	MOVEI	P2,BUFFER
	AOJA	P1,LOOK1	; TRY AGAIN

SIXTO5:	SETZM	T1
	MOVEI	T4,5
SIXTO:	LSHC	T1,6
	ADDI	T1,40
	LSH	T1,1
	SOJG	T4,SIXTO
	POPJ	P,

.OUT:	SOSG	OBUF+2
	JRST	.OUT2
.OUT1:	IDPB	T1,OBUF+1
	POPJ	P,
.OUT2:	OUT	D,
	JRST	.OUT1
	GETSTS	D,T1
	OUTSTR	[ASCIZ /
? Output error !/]
	EXIT


NOPEN:	OUTSTR	[ASCIZ /
? OPEN failure for device TRACE/]
	JRST	PLAYIT

NOENT:	OUTSTR	[ASCIZ /
? ENTER failure/]
PLAYIT:	OUTSTR	[ASCIZ /
[ Output is to TRACE:DSKFIL.BIN]/]
	EXIT

T1OUT:	IDIVI	T1,^D10
	PUSH	P,T2
	JUMPE	T1,[OUTSTR [ASCIZ /
/]
		    JRST .+2]
	PUSHJ	P,T1OUT
	POP	P,T1
	ADDI	T1,"0"
	OUTCHR	T1
	POPJ	P,

	SUBTTL	Breakpoint routine

COLECT:	PUSH	%P,%T1
	PUSH	%P,%T2
	PIOFF
	MOVEI	%T2,10000	;AVOID KAF'ING
COLOOP:	AOSE	INTLCK(%R)	;OK?
	JRST	[SOJG %T2,COLOOP(%R)
		 JRST SKIPIT(%R)](%R)
	MOVE	%T2,%IN(%R)
	CAIL	%T2,BUFSIZ
	SETZM	%T2
	ADDI	%T2,BUFFER(%R)	; Point to next slot to use
	MOVEM	%S,OPRMVS(%T2)
	GETCHN	(CHNNUM)
	TLZ	%T1,-1		; CLEAR OUT FLAGS
	TLNE	%S,IO
	TLO	%T1,IO.WRT
	TLNE	%S,IOSMON
	TLO	%T1,IO.MON
	MOVEM	%T1,OPRSIZ(%T2)
	AOS	%T1,SEQIN(%R)
	MOVEM	%T1,OPRSEQ(%T2)
	MOVE	%T1,@TIME(%R)
	MOVEM	%T1,OPRTIM(%T2)
	MOVE	%T1,@.UPMP(%R)	; GET UUO
	MOVEM	%T1,OPRUUO(%T2)
	GETDEV	(DEVBLK,OPRBLK)
	GETUNI	(UNIDES,OPRDES)
	GETUNI	(UNILOG,OPRLOG)
	GETDEV	(DEVREL,OPRFBN)
	LDB	%T1,@PJOBN(%R)
	MOVEM	%T1,OPRJOB(%T2)
	ADD	%T1,JBTPRG(%R)
	MOVE	%T1,(%T1)
	MOVEM	%T1,OPRPRG(%T2)
	GETDEV	(DEVFIL,OPRFIL)
	GETDEV	(DEVEXT,OPREXT)
	GETDEV	(DEVPPN,OPRPPN)
	SUBI	%T2,BUFFER(%R)
	ADDI	%T2,RECLEN	;STEP TO NEXT BUFFER ITEM
	MOVEM	%T2,%IN(%R)
	SETOM	INTLCK(%R)
SKIPIT:	PION
	POP	%P,%T2
	POP	%P,%T1
	POPJ	%P,

SAVUUO:	PUSH	%P,%J
	PUSH	%P,%T1
	MOVE	%J,@.CPJOB(%R)
	MOVE	%T1,@.UPMP(%R)	; GET USER'S UUO
	ADD	%J,%R
	MOVEM	%T1,UUOJOB(%J)	; SAVE USER'S UUO
	POP	%P,%T1
	POP	%P,%J
	POPJ	%P,

GETUUO:	PUSH	%P,%J
	PUSH	%P,%T1
	MOVE	%J,@.CPJOB(%R)
	ADD	%J,%R
	MOVE	%T1,UUOJOB(%J)	; GET USER'S UUO
	MOVEM	%T1,@.UPMP(%R)	; SAVE BACK IN PAGE MAP
	POP	%P,%T1
	POP	%P,%J
	POPJ	%P,

	END	TRACER
