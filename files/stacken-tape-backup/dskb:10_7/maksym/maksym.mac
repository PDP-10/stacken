TITLE	MAKSYM - Program to Create Symbols for Monitor Data Structures
SUBTTL	J. Dziedzic /JAD	26-Mar-87


	SEARCH	JOBDAT, MACTEN, UUOSYM, SCNMAC
	SALL			;SUPPRESS MACRO EXPANSIONS
	.TEXT	"/SEGMENT:LOW /SEARCH REL:SCAN, REL:HELPER"


;This program reads a monitor file (or the running monitor) and
;creates a DDT file usable with the $Y command in DDT to define
;the various data structures such as UDBs, KDBs, etc.


;Version information

	MKSVER==3		;MAJOR VERSION
	MKSMIN==0		;MINOR VERSION
	MKSEDT==6		;EDIT NUMBER
	MKSWHO==0		;WHO LAST EDITTED

	LOC	.JBVER
	VRSN.	MKS		;STORE VERSION NUMBER
	RELOC			;BACK TO RELOCATABLE
	SUBTTL	Revision History


COMMENT	|

Edit		Motivation

1	JAD, 12-Jul-84.  Create first version to facilitate looking at
	7.02 crash dumps from auto configure monitors.

2	JAD, 31-Jul-84.  Add the code to read crash files.
	Not yet complete.

3	JAD, 4-Dec-84.  Since I didn't bump the monitor version
	for the CI LIR monitor, use a different test to see if the
	monitor supports the new disk KDB format.

4	JAD, 13-Jan-85.  Update for tools tape.

5	JAD, 25-Mar-85.  Add /CACHESIZE: switch, fix magtape KDB
	names so they are more reasonable.

6	JAD, 26-Mar-87.  Fix to work with 7.04 monitor (new disk
	and tape KDB/UDB formats).  7.04 ONLY!

|; END OF COMMENT
	SUBTTL	Standard Definitions


;AC's

	FL=0			;FLAGS REGISTER
	T1=1			;4 TEMPORARY AC'S
	T2=2
	T3=3
	T4=4
	P1=5			;4 PRESERVED AC'S
	P2=6
	P3=7
	P4=10
	N==P3			;.SCAN'S WORD INPUT AC
	C==P4			;.SCAN'S CHARACTER INPUT AC
	F=14			;DDB POINTER
	J=15			;KDB POINTER
	U=16			;UDB POINTER
	P=17			;PDL POINTER


;Flags in FL (36-bit definitions)



;I/O channels

	DI==1			;INPUT
	DO==2			;OUTPUT


;Feature tests

ND	FTSA1D,0		;SA10 DISK SUPPORT


;Cache data

	CS.HIT==37B4		;HIT COUNT
	CS.PPN==17777B17	;PHYSICAL PAGE NUMBER
	CS.VPN==777777B35	;VIRTUAL PAGE NUMBER


;Miscellanous

	.LNPDL==100		;SIZE OF STACK
	.PGSIZ==1000		;SIZE OF A PAGE

	KDBNAM==0		;SIXBIT NAME OF KONTROLLER
	KDBNXT==1		;LINK TO NEXT KDB OF THIS TYPE
	KDBIUN==4		;INITIAL POINTER TO UNITS
	KDBFUN==5		;FINAL POINTER TO UNITS
	UDBNAM==0		;SIXBIT NAME OF UNIT
	UDBDDB==7		;POINTER TO ASSOCIATED DDB

	ABSTAB==410		;ABSOLUTE ADDRESS OF GETTAB IMMEDIATE TABLE

DEFINE	PG2BLK(AC),<
	LSH	AC,2		;;CONVERT FROM PAGE NUMBER TO BLOCK NUMBER
>; END DEFINE PG2BLK

DEFINE	ADR2PG(AC),<
	LSH	AC,-^D9		;;CONVERT FROM ADDRESS TO PAGE NUMBER
>; END DEFINE ADR2PG

DEFINE	PG2ADR(AC),<
	LSH	AC,^D9		;;CONVERT FROM PAGE NUMBER TO ADDRESS
>; END DEFINE ADRP2G
	SUBTTL	Initialization


MAKSYM:	JFCL			;NO CCL ENTRY
	RESET			;RESET ALL I/O
	MOVE	P,[IOWD .LNPDL, PDLIST] ;SET UP THE STACK

	SETZM	ZCORE		;ZERO OUT IMPURE STORAGE
	MOVE	T1,[XWD ZCORE, ZCORE+1] ;...
	BLT	T1,EZCORE	;ZEROES TO END

	HLRZ	T1,.JBSA	;GET FIRST FREE ADDRESS PAST LOW SEGMENT
	HRRZM	T1,.JBFF	;START CORE ALLOCATOR THERE
	HRRZM	T1,PAGSTA	;...

	MOVE	T1,[XWD .LNISC, ISCARG] ;POINT AT SCANNER ARGUMENTS
	PUSHJ	P,.ISCAN##	;INITIALIZE COMMAND SCANNER PACKAGE
	SUBTTL	Ready the Input File


MAINLP:	MOVE	T1,PAGSTA	;START OF PAGE ALLOCATOR
	SUBI	T1,1		;BACK OFF BY ONE
	CAMLE	T1,.JBREL	;NEED TO GIVE SOME BACK?
	CORE	T1,		;YES, DO SO
	  JFCL			;WE TRIED

	SETOM	S.MIN		;PRESET SWITCH AREA
	MOVE	T1,[XWD S.MIN,S.MIN+1] ;...
	BLT	T1,S.EMIN	;-1 TO END
	RELEAS	DI,		;CLOSE DOWN OPEN FILES
	RELEAS	DO,		;...
	PUSHJ	P,.RUNCM##	;HANDLE /RUN IF SET

	SETZM	SPEC		;ZERO OUT FILE SPEC BLOCK
	MOVE	T1,[XWD SPEC, SPEC+1] ;...
	BLT	T1,SPEC+.FXLEN-1 ;ZEROES TO END

	MOVE	T1,[XWD .LNPSC, PSCARG] ;POINT AT ARGUMENT BLOCK
	PUSHJ	P,.PSCAN##	;CALL PARTIAL MODE SCANNER
	  OUTSTR [ASCIZ |File: |]

;SEE IF USER TYPED AN END OF FILE AND HANDLE AS APPROPRIATE

	CAXG	C,.CHEOF	;SEE IF EOF
	JRST	[PUSHJ P,.ALDON## ;YES, HANDLE NORMAL CASES
		 CAXG  C,.CHEOF ;THEN CHECK AGAIN
		 PUSHJ P,.MNRET## ;YES, RETURN TO MONITOR
		 JRST  MAINLP]	;THEN START OVER AGAIN

;READ THE FILE SPEC FROM THE USER

	PUSHJ	P,.FILIN##	;GET FILE SPEC
	JUMPN	T1,GETOPT	;JUMP IF SOMETHING INPUT

;HERE IF NOTHING TYPED BEFORE THE SEPARATOR.  THE ONLY LEGAL
;CASES ARE /RUN AND INDIRECT COMMAND FILES.

	CAIN	C,"@"		;SEE IF INDIRECT
	PUSHJ	P,.GTIND##	;YES, SETUP INDIRECT
	JUMPLE	C,MAINLP	;IF END OF LINE, GO DO MORE
	PJRST	E.ILSC##	;OTHERWISE, GIVE ERROR
;HERE TO CHECK OPTIONS FILE AND READ THE USER FILE SPEC

GETOPT:	JUMPG	C,E.INCL##	;ERROR IF MORE ON LINE
	MOVEI	T1,SPEC		;POINT TO SPEC AREA
	MOVEI	T2,.FXLEN	;...
	PUSHJ	P,.GTSPC##	;COPY IT IN

	SKIPLE	S.MON		;/MONITOR?
	JRST	DOIT		;YES, SKIP ALL THE INPUT FILE STUFF
	SKIPN	SPEC+.FXNAM	;MAKE SURE A NAME SPECIFIED
	JRST	MAINLP		;NOT, ASK AGAIN
	HRLOI	T1,'EXE'	;GET DEFAULT EXTENSION
	SKIPN	SPEC+.FXEXT	;ANYTHING SPECIFIED?
	MOVEM	T1,SPEC+.FXEXT	;NO, DEFAULT IT

;CALL THE .SCAN UTILITY ROUTINE TO CONVERT THE SCAN BLOCK INTO
;AN OPEN AND LOOKUP/ENTER BLOCK

	MOVE	T1,[XWD .FXLEN, SPEC] ;LENGTH,,ADDRESS OF FILE SPEC
	MOVEI	T2,DIOPBK	;OPEN BLOCK ADDRESS
	MOVE	T3,[XWD .RBMAX, LOKBLK] ;LENGTH,,ADDRESS OF LOOKUP BLOCK
	PUSHJ	P,.STOPN##	;SET UP OPEN BLOCKS
	  JRST	BADFIL		;IMPROPERLY FORMATTED FILE SPEC

;OPEN THE INPUT FILE

	MOVEI	T1,.IODMP	;DATA MODE
	MOVEM	T1,DIOPBK+.OPMOD ;SAVE I/O MODE WORD
	OPEN	DI,DIOPBK	;OPEN THE FILE
	  JRST	DIOERR		;ERROR
	MOVEI	T1,.RBPRV	;DON'T NEED A LONG LOOKUP
	MOVEM	T1,LOKBLK+.RBCNT ;SAVE COUNT
	LOOKUP	DI,LOKBLK	;LOOKUP THE FILE
	  JRST	DILERR		;ERROR
;READ THE FIRST PAGE OF THE FILE AND MAKE SURE IT'S AN .EXE FILE

	SKIPG	T1,S.CACH	;GET /CACHESIZE: VALUE
	MOVX	T1,AD.CSZ	;NOT SPECIFIED, GET DEFAULT
	MOVNS	T1		;MAKE AN AOBJN WORD
	HRLZM	T1,CSHPTR	;STORE IT FOR LATER
	PUSHJ	P,CSHINI	;INITIALIZE THE CACHE

	SETZ	T1,		;ASK FOR PAGE 0
	PUSHJ	P,REDPAG	;...
	  JRST	RIOERR		;ERROR
	HLRZ	T2,(T1)		;GET CODE WORD
	CAIE	T2,.SVDIR	;DIRECTORY?
	JRST	NOTEXE		;NO
	MOVE	T2,(T1)		;GET WORD COUNT
	TRNN	T2,1		;ODD COUNT?
	JRST	NOTEXE		;NO, NOT .EXE FORMAT
	MOVNI	T2,-1(T2)	;GET -VE WORD COUNT FOR DIRECTORY
	HRLI	T2,EXEDIR	;WHERE DIRECTORY WILL BE STORED
	MOVSM	T2,DIRPTR	;SAVE POINTER TO DIRECTORY
	HRRES	T2		;GET -VE COUNT AGAIN
	MOVMS	T2		;MAKE IT POSITIVE
	MOVSI	T1,1(T1)	;SET TO BLT PAGE TO DIRECTORY BUFFER
	HRRI	T1,EXEDIR	;WHERE TO BLT TO
	BLT	T1,EXEDIR-1(T2)	;MOVE THE DIRECTORY

;CHECK FILE CONSISTANCY AND SET UP FOR GETTAB AND PEEK SIMULATION

	PUSHJ	P,SETDSK	;SET FOR GETTAB AND PEEK SIMULATION
	SUBTTL	Ready the Output File


DOIT:	OPEN	DO,DOPNBK	;OPEN THE OUTPUT CHANNEL
	  JRST	DOOERR		;ERROR
	HLLZS	DENTBK+1	;CLEAR RH OF DATE
	SETZM	DENTBK+2	;CLEAR PRIVILEGE
	SETZM	DENTBK+3	;CLEAR PPN/PATH POINTER
	ENTER	DO,DENTBK	;ENTER THE OUTPUT FILE
	  JRST	DOEERR		;ERROR
	OUTBUF	DO,2		;JUST NEED 2 BUFFERS
	MOVEI	T1,TYPOUT	;NOW SET UP NEW OUTPUT ROUTINE ADDRESS
	PUSHJ	P,.TYOCH##	;CALL .TOUTS

;Defeat echo of $Y files as the first command in the file

	MOVEI	T1,[ASCIZ |"" Turning off echo of a long command file"

1M[Q<FOO:4000000+FOO1M
|]
	PUSHJ	P,.TSTRG##	;SAVE OLD $1M MASK, SET NEW
	SUBTTL	Perform ONCE-Only Initialization


	SUBTTL	Process Disk Data Structures


DODISK:	MOVE	T1,[.TYDSK,,.GTKDB] ;GET FIRST DISK KDB
	PUSHJ	P,DOGTAB	; FROM WHOMEVER
	MOVE	J,T1		;COPY TO STANDARD AC
DISK.1:	PUSHJ	P,.TOCTW##	;TYPE KDB ADDRESS IN OCTAL
	MOVEI	T1,"<"		;GET THE SYMBOL DEFINITION CHARACTER
	PUSHJ	P,.TCHAR##	;TYPE IT
	MOVEI	T1,KDBNAM(J)	;ADDRESS OF KONTROLLER NAME
	PUSHJ	P,DOPEEK	;SNEAK A PEEK
	HRRI	T1,'KDB'	;MAKE A NAME FOR IT
	PUSHJ	P,.TSIXN##	;TYPE IN SIXBIT
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	PUSHJ	P,.TCRLF##	;TYPE A CARRIAGE RETURN-LINE FEED
	MOVEI	T1,KDBIUN(J)	;(KNOWN) OFFSET FOR AOBJN POINTER TO UNITS
	PUSHJ	P,DOPEEK	;ASK THE MONITOR
	MOVE	P1,T1		;COPY THE POINTER
DISK.2:	HRRZ	T1,P1		;GET ADDRESS OF NEXT UNIT'S ADDRESS
	PUSHJ	P,DOPEEK	;ASK THE MONITOR
	JUMPE	T1,DISK.3	;JUMP IF NOTHING THERE
	MOVE	U,T1		;GET THE UDB ADDRESS
	PUSHJ	P,.TOCTW##	;TYPE IN OCTAL
	MOVEI	T1,"<"		;GET THE SYMBOL DEFINITION CHARACTER
	PUSHJ	P,.TCHAR##	;TYPE IT
	MOVEI	T1,UDBNAM(U)	;GET THE UDB ADDRESS AGAIN
	PUSHJ	P,DOPEEK	;SEE WHAT THE NAME IS
	PUSHJ	P,.TSIXN##	;TYPE IN SIXBIT
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	PUSHJ	P,.TCRLF##	;TYPE A CARRIAGE RETURN-LINE FEED
DISK.3:	AOBJN	P1,DISK.2	;LOOP FOR REMAINING UNITS
	MOVEI	T1,KDBNXT(J)	;ADDRESS OF LINK TO NEXT KDB
	PUSHJ	P,DOPEEK	;ASK THE MONITOR
	SKIPE	J,T1		;GET THE NEXT KDB ADDRESS
	JRST	DISK.1		;LOOP FOR OTHERS
	SUBTTL	Process Magtape Data Structures


DOTAPE:	MOVE	T1,[.TYMTA,,.GTKDB] ;GET ADDRESS OF FIRST MAGTAPE KDB
	PUSHJ	P,DOGTAB	;DO THE GETTAB
	SKIPN	J,T1		;ARE THERE ANY TAPES?
	JRST	DONE		;NO, THEN WE'RE DONE
TAPE.1:	MOVE	T1,J		;GET KDB ADDRESS
	PUSHJ	P,.TOCTW##	;TYPE IN OCTAL
	MOVEI	T1,"<"		;GET THE SYMBOL DEFINITION CHARACTER
	PUSHJ	P,.TCHAR##	;TYPE IT
	MOVEI	T1,KDBNAM(J)	;GET THE KDB ADDRESS AGAIN
	PUSHJ	P,DOPEEK	;SEE WHAT THE NAME IS
	LDB	P2,[POINT 6,T1,17] ;SAVE FOR LATER USE
	HRRI	T1,'KDB'	;MAKE THE NAME THE SAME AS DISK KDBS
	PUSHJ	P,.TSIXN##	;TYPE IN SIXBIT
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	PUSHJ	P,.TCRLF##	;TYPE A CARRIAGE RETURN-LINE FEED
	MOVEI	T1,KDBIUN(J)	;ADDRESS OF FIRST UNIT IN TABLE
	PUSHJ	P,DOPEEK	;SNEAK A PEEK
	MOVE	P1,T1		;SAVE THE POINTER IN P1
	MOVEI	T1,KDBFUN(J)	;ADDRESS OF FINAL UNIT
	PUSHJ	P,DOPEEK	;SNEAK A PEEK
	MOVE	P2,T1		;COPY IT HERE
TAPE.2:	MOVE	T1,P1		;GET ADDRESS OF NEXT UNIT'S ADDRESS
	PUSHJ	P,DOPEEK	;SNEAK A LOOK
	SKIPN	U,T1		;IS THERE A UNIT?
	JRST	TAPE.3		;NO
	MOVE	T1,U		;GET UDB ADDRESS
	PUSHJ	P,.TOCTW##	;TYPE IN OCTAL
	MOVEI	T1,"<"		;GET THE SYMBOL DEFINITION CHARACTER
	PUSHJ	P,.TCHAR##	;TYPE IT
	MOVEI	T1,UDBNAM(U)	;GET THE UDB ADDRESS AGAIN
	PUSHJ	P,DOPEEK	;GET THE UNIT NAME
	PUSHJ	P,.TSIXN##	;TYPE IN SIXBIT
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	PUSHJ	P,.TCRLF##	;TYPE A CARRIAGE RETURN-LINE FEED
	MOVEI	T1,UDBDDB(U)	;ADDRESS OF LINK TO DDB
	PUSHJ	P,DOPEEK	;SNEAK A PEEK
	SKIPN	F,T1		;SAVE DDB ADDRESS IN F
	JRST	TAPE.3		;NO DDB, SKIP ON
	MOVE	T1,F		;GET DDB ADDRESS
	PUSHJ	P,.TOCTW##	;TYPE IN OCTAL
	MOVEI	T1,"<"		;GET THE SYMBOL DEFINITION CHARACTER
	PUSHJ	P,.TCHAR##	;TYPE IT
	MOVE	T1,F		;GET THE DDB ADDRESS AGAIN
	PUSHJ	P,DOPEEK	;GET NAME FROM DDB
	MOVEI	T2,'D'		;GET CHARACTER FOR DDB
	DPB	T2,[POINT 6,T1,11] ;REPLACE THE 'T' WITH A 'D'
	PUSHJ	P,.TSIXN##	;TYPE IN SIXBIT
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	PUSHJ	P,.TCRLF##	;TYPE A CARRIAGE RETURN-LINE FEED
TAPE.3:	CAMGE	P1,P2		;DONE ALL THE UNITS ON THIS KDB?
	AOJA	P1,TAPE.2	;NO, DO NEXT UNIT
	MOVEI	T1,KDBNXT(J)	;ADDRESS OF LINK TO NEXT KDB
	PUSHJ	P,DOPEEK	;TAKE A LOOK
	SKIPE	J,T1		;GET THE NEXT KDB ADDRESS
	JRST	TAPE.1		;LOOP FOR MORE
	JRST	DONE		;ALL DONE
	SUBTTL	Here When Done


DONE:	MOVEI	T1,[ASCIZ |FOO1MFOOK

"" Command file has completed"
|]
	PUSHJ	P,.TSTRG##	;TURN $Y ECHO BACK THE WAY IT WAS
	CLOSE	DO,		;CLOSE THE OUTPUT CHANNEL
	RELEAS	DO,		;RELEASE THE OUTPUT CHANNEL
	EXIT			;EXIT
	SUBTTL	Set to Simulate GETTAB and PEEK for Crash File


;Routine to set up variables needed to simulate GETTABs and PEEKs
;on the crash file.
;Call:
;	PUSHJ	P,SETDSK
;Return:
;	CPOPJ always

SETDSK:	MOVEI	T1,267777	;INIT END OF UNMAPPED AREA
	MOVEM	T1,VMHUA	;SAVE FOR SIMPEK
	MOVEI	T1,740000	;INIT START OF PER-PROCESS AREA
	MOVEM	T1,PERPRB	;SAVE FOR SIMPEK
	MOVEI	T1,777777	;INIT END OF PER-PROCESS AREA
	MOVEM	T1,PERPRE	;SAVE FOR SIMPEK
	MOVEI	T1,ABSTAB	;ADDRESS OF GETTAB IMMEDIATE TABLE
	PUSHJ	P,DOPEEK	;SNEAK A PEEK
	TLNE	T1,-1		;MAKE SURE LH IS ZERO
	JRST	CFIGET		;NO, ERROR
	JUMPE	T1,CFIGET	;DITTO IF ZERO
	PUSH	P,T1		;SAVE ADDRESS FOR A BIT
	ADDI	T1,.GTSLF	;ADD IN OFFSET TO GETTAB IMMEDIATE
	PUSHJ	P,DOPEEK	;SNEAK A PEEK
	POP	P,T2		;RESTORE REMEMBERED ADDRESS
	CAIE	T2,(T1)		;SEE IF IT MATCHES
	JRST	CFIGET		;NO
	HRRZM	T1,OFSGTB	;SAVE OFFSET FOR LATER USE
	LDB	T1,[POINTR T1,SL.MAX] ;GET MAXIMUM ITEM
	MOVEM	T1,MAXGTB	;SAVE IT
	PUSHJ	P,DOGTAB	;SIMULATE GETTAB
	LSH	T1,1		;TIMES TWO
	ADDX	T1,%CCTOS	;GET HIS EXEC MAP ADDRESS
	PUSHJ	P,DOGTAB	;SIMULATE GETTAB
	ADDI	T1,.PGSIZ	;WITH KL PAGING, MAP IS IN FOLLOWING PAGE
	MOVEM	T1,.CPMAP	;SAVE ADDRESS OF BOOT CPU'S EXEC MAP
	MOVX	T1,%VMPPB	;START OF PER-PROCESS AREA
	PUSHJ	P,DOGTAB	;SIMULATE GETTAB
	SKIPE	T1		;KNOWN?
	MOVEM	T1,PERPRB	;YES, RESET BEGINNING OF PER-PROCESS AREA
	POPJ	P,		;RETURN
	SUBTTL	Data Retrieval Routines


;Routine to perform a GETTAB on the running monitor or a crash file.
;Call:
;	T1/ Item to GETTAB
;	PUSHJ	P,DOGTAB
;Return:
;	CPOPJ always, with:
;	T1/ Returned value or zero

DOGTAB:	SKIPG	S.MON		;/MONITOR?
	JRST	SIMTAB		;NO, SIMULATE GETTAB
	GETTAB	T1,		;ASK THE MONITOR
	  SETZ	T1,		;WON'T TELL US!
	POPJ	P,		;RETURN


;Routine to perform a PEEK on the running monitor or a crash file.
;Call:
;	T1/ Address to peek at
;	PUSHJ	P,DOPEEK
;Return:
;	CPOPJ always, with:
;	T1/ Contents of that address or zero

DOPEEK:	SKIPG	S.MON		;/MONITOR?
	JRST	SIMPEK		;NO, SIMULATE PEEK
	PEEK	T1,		;ASK THE MONITOR
	POPJ	P,		;RETURN
;Routine to simulate a GETTAB on a crash file.
;Call:
;	T1/ Item to GETTAB
;	PUSHJ	P,SIMTAB
;Return:
;	CPOPJ always, with:
;	T1/ Returned value or zero

SIMTAB:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	P1,T1		;COPY DESIRED ITEM TO P1
	HRRZS	T1		;KEEP JUST TABLE NUMBER
	CAMLE	T1,MAXGTB	;IN RANGE OF MAXIMUM?
	JRST	RETZER		;NO, RETURN A ZERO
	ADD	T1,OFSGTB	;GET CORE ADDRESS
	PUSHJ	P,SIMPEK	;SNEAK A PEEK AT IT
	LDB	T2,[POINTR T1,SL.MAX] ;GET MAXIMUM ITEM
	HLRZ	T3,P1		;GET REQUESTED ITEM
	CAMLE	T3,T2		;REQUESTED ITEM WITHIN TABLE?
	JRST	RETZER		;NO, RETURN A ZERO
	LDB	T1,[POINTR T1,SL.ADR] ;GET ADDRESS
	ADD	T1,T3		;ADD IN OFFSET TO DESIRED ITEM
	PJRST	SIMPEK		;SNEAK A PEEK AT IT AND RETURN

RETZER:	SETZ	T1,		;GET A ZERO
	POPJ	P,		;RETURN
;Routine to simulate a PEEK on a crash file.
;Call:
;	T1/ Address to peek at
;	PUSHJ	P,SIMPEK
;Return:
;	CPOPJ always, with:
;	T1/ Contents or address of zero

SIMPEK:	TLZ	T1,-1		;CLEAR JUNK
	CAMG	T1,VMHUA	;UNMAPPED ADDRESS?
	PJRST	REDADR		;YES
	CAML	T1,PERPRB	;IN PER-PROCESS AREA?
	CAMLE	T1,PERPRE
	SKIPA			;NO
	PJRST	RETZER		;YES, RETURN A ZERO
	PUSH	P,T1		;SAVE REQUESTED ADDRESS
	ADR2PG	T1		;CONVERT TO A PAGE NUMBER
	PUSH	P,T1		;SAVE THE FLAG
	HRRZS	T1		;KEEP JUST THE OFFSET IN EXEC MAP
	ADD	T1,.CPMAP	;ADD IN ADDRESS OF EXEC MAP
	PUSHJ	P,SIMPEK	;GET RECURSIVE
	POP	P,T2		;RESTORE FLAG
	ANDI	T1,17777	;KEEP JUST 13-BIT PHYSICAL PAGE NUMBER
	PG2ADR	T1		;CONVERT TO AN ADDRESS
	POP	P,T2		;RESTORE ORIGINAL ADDRESS
	ANDI	T2,.PGSIZ-1	;KEEP JUST IN-PAGE PORTION
	ADD	T1,T2		;COMPUTE PHYSICAL ADDRESS
	PJRST	REDADR		;READ THAT ADDRESS AND RETURN
;Routine to read a physical address from the .EXE file.
;Call:
;	T1/ Address
;	PUSHJ	P,REDADR
;Return:
;	CPOPJ if address not contained in file
;	CPOPJ1 if address contained in file, with:
;	T1/ Contents of address

REDADR:	PUSH	P,T1		;SAVE THE ENTIRE ADDRESS
	ADR2PG	T1		;CONVERT ADDRESS TO A PAGE NUMBER
	MOVE	T2,DIRPTR	;GET AOBJN POINTER TO EXE DIRECTORY
REDA.1:	LDB	T3,[POINTR .SVPPC(T2),SV%PPN] ;GET PROCESS PAGE NUMBER
	LDB	T4,[POINTR .SVPPC(T2),SV%REP] ;GET REPEAT COUNT
	ADD	T4,T3		;COMPUTE RANGE OF PAGES IN THIS DIRECTORY ENTRY
	CAMGE	T1,T3		;STILL A CHANCE OF FINDING THIS PAGE?
	JRST	REDA.3		;NO, SINCE DIRECTORY IS MONOTONICALLY INCREASING,
				; THIS PAGE ISN'T CONTAINED IN THE FILE
	CAML	T1,T3		;WITHIN RANGE OF THIS DIRECTORY ENTRY?
	CAMLE	T1,T4		;...
	JRST	REDA.2		;NO, KEEP LOOKING
	SUB	T1,T3		;YES, COMPUTE PAGE OFFSET FROM START
	LDB	T3,[POINTR .SVFPF(T2),SV%FPN] ;GET FILE PAGE NUMBER
	JUMPE	T3,REDA.4	;GO IF ALLOCATED BUT ZERO
	ADD	T1,T3		;COMPUTE FILE PAGE NUMBER
	PUSHJ	P,REDPAG	;READ THAT PAGE INTO CORE
	  JRST	RETZER		;ERROR
	POP	P,T2		;RESTORE ENTIRE ADDRESS
	DPB	T2,[POINT 9,T1,35] ;SET LINE NUMBER IN PAGE
	MOVE	T1,(T1)		;GET THE CONTENTS
	POPJ	P,		;RETURN THEM TO CALLER

REDA.2:	AOBJN	T2,.+1		;ADJUST DIRECTORY POINTER
	AOBJN	T2,REDA.1	;LOOP FOR REMAINING ENTRIES
REDA.3:	SOS	-1(P)		;DIDN'T FIND THIS ADDRESS, SET FOR NON-SKIP RETURN
REDA.4:	POP	P,T1		;CLEAN UP THE STACK
	SETZ	T1,		;GET A ZERO
	JRST	.POPJ1##	;RETURN TO CALLER
;Routine to read a page from the EXE file.
;Call:
;	T1/ File page number
;	PUSHJ	P,REDPAG
;Return:
;	CPOPJ always

REDPAG:	PUSHJ	P,.SAVE2##	;SAVE P1-P2
	MOVE	P1,T1		;COPY PAGE NUMBER
	MOVE	P2,CSHPTR	;GET POINTER TO CACHE

	LDB	T1,[POINTR CACHE(P2),CS.PPN] ;GET PHYSICAL PAGE NUMBER
	CAME	T1,P1		;MATCH?
	AOBJN	P2,.-2		;NO, LOOP
	JUMPGE	P2,REDP.1	;JUMP IF NOT FOUND IN CACHE
	LDB	T1,[POINTR CACHE(P2),CS.HIT] ;GET HIT COUNT
	ADDI	T1,1		;BUMP IT
	CAXGE	T1,1_WID(CS.HIT) ;EXCEEDED FIELD SIZE?
	DPB	T1,[POINTR CACHE(P2),CS.HIT] ;NO, STORE IT BACK
	LDB	T1,[POINTR CACHE(P2),CS.VPN] ;GET VIRTUAL PAGE NUMBER
	PG2ADR	T1		;CONVERT TO AN ADDRESS
	JRST	.POPJ1##	;SKIP RETURN

REDP.1:	MOVE	P2,CSHPTR	;NOW FIND AN ENTRY TO RE-USE
	MOVX	P3,.INFIN	;GREATEST HIT COUNT
	SETO	P4,		;INDEX INTO CACHE
REDP.2:	LDB	T1,[POINTR CACHE(P2),CS.HIT] ;GET HIT COUNT
	CAML	T1,P3		;LESS THAN BEST SO FAR?
	JRST	REDP.3		;NO
	MOVE	P3,T1		;YES, REMEMBER LOWEST
	HRRZ	P4,P2		;AND COUNT
REDP.3:	AOBJN	P2,REDP.2	;LOOP THROUGH REST OF CACHE
;HERE WITH P4 = POINTER TO BEST SLOT TO RE-USE IN CACHE

	LDB	T1,[POINTR CACHE(P4),CS.VPN] ;GET OUR PAGE NUMBER
	JUMPN	T1,REDP.4	;JUMP IF IT EXISTS
	PUSHJ	P,CREPAG	;CREATE A PAGE
	  HALT	.		;ERROR
	DPB	T1,[POINTR CACHE(P4),CS.VPN] ;STORE PAGE NUMBER
REDP.4:	DPB	P1,[POINTR CACHE(P4),CS.PPN] ;STORE PHYSICAL PAGE NUMBER
	MOVEI	T2,1		;INIT THE HIT COUNT
	DPB	T2,[POINTR CACHE(P4),CS.HIT] ;...
	PG2BLK	P1		;CONVERT TO A BLOCK NUMBER
	USETI	DI,1(P1)	;POSITION FOR INPUT
	PG2ADR	T1		;CONVERT VIRTUAL PAGE NUMBER TO AN ADDRESS
	SUBI	T1,1		;MAKE IT ADDRESS-1
	HRLI	T1,-.PGSIZ	;MAKE IT AN IOWD
	SETZ	T2,		;TERMINATE I/O LIST
	IN	DI,T1		;READ THE PAGE
	JRST	REDP.5		;NO ERRORS
	SETO	T1,1		;GET -1
	DPB	T1,[POINTR CACHE(P4),CS.PPN] ;MAKE THIS ENTRY LOOK INVALID
	JRST	RIOERR		;REPORT I/O ERROR AND RETURN

REDP.5:	MOVEI	T1,1(T1)	;IOWD BACK TO AN ADDRESS
	JRST	.POPJ1##	;SKIP RETURN
	SUBTTL	Cache Routines


;Routine to initialize the cache.  Returns any pages already used
;for stuff and zeroes the database.
;Call:
;	PUSHJ	P,CSHINI
;Return:
;	CPOPJ ALWAYS

CSHINI:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVSI	P1,-MX.CSZ	;MAXIMUM SIZE OF CACHE
CSHI.1:	LDB	T1,[POINTR CACHE(P1),CS.VPN] ;GET VIRTUAL PAGE NUMBER
	JUMPE	T1,CSHI.2	;JUMP IF THIS ENTRY NOT USED
	PUSHJ	P,RELPAG	;RELEASE THAT PAGE
CSHI.2:	SETO	T1,		;GET -1
	DPB	T1,[POINTR CACHE(P1),CS.PPN] ;MAKE TESTS ON PAGE NUMBER FAIL
	AOBJN	P1,CSHI.1	;LOOP FOR REMAINING PAGES
	POPJ	P,		;RETURN
;Routine to create a page.
;Call:
;	PUSHJ	P,CREPAG
;Return:
;	CPOPJ IF ERROR
;	CPOPJ1 IF SUCCESS WITH:
;	T1/ Virtual page number

CREPAG:	MOVE	T3,.JBREL	;WHERE NEXT PAGE WILL COME FROM
	MOVEI	T4,.PGSIZ(T3)	;UPDATE .JBFF
	MOVEM	T4,.JBFF	;...
	ADDI	T3,.PGSIZ-1	;...
	ADR2PG	T3		;CONVERT TO PAGE NUMBER
	MOVEI	T2,1		;JUST ONE PAGE
	MOVE	T1,[.PAGCD,,T2]	;POINT AT ARGUMENTS
	PAGE.	T1,		;CREATE THE PAGE
	  POPJ	P,		;ERROR, RETURN
	HRRZ	T1,T3		;GET PAGE NUMBER
	JRST	.POPJ1##	;SKIP RETURN
;Routine to destroy a page.
;Call:
;	T1/ Virtual page number
;	PUSHJ	P,RELPAG
;Return:
;	CPOPJ ALWAYS

RELPAG:	MOVE	T3,T1		;COPY PAGE NUMBER HERE
	TXO	T3,PA.GAF	;SET THE "DESTROY" FLAG
	MOVEI	T2,1		;JUST ONE PAGE
	MOVE	T1,[.PAGCD,,T2]	;POINT AT ARGUMENTS
	PAGE.	T1,		;DESTROY IT
	  JFCL			;WE DID OUR BEST
	POPJ	P,		;RETURN
	SUBTTL	Miscellaneous


;Routine to output one character to the output file.
;Call:
;	T1/ Character to output
;	PUSHJ	P,TYPOUT
;Return:
;	CPOPJ always

TYPOUT:	SOSGE	OBUF+.BFCTR	;STILL ROOM?
	JRST	TYPO.1		;NO
	IDPB	T1,OBUF+.BFPTR	;YES, STORE THE BYTE
	POPJ	P,		;RETURN

TYPO.1:	OUT	DO,		;FLUSH THIS BUFFER
	JRST	TYPOUT		;NO ERRORS, PROCEED
	OUTSTR	[ASCIZ /
?Output error for MAKSYM.DDT
/]
	EXIT			;CROAK
	SUBTTL	Error Routines


DOOERR:	OUTSTR	[ASCIZ |
?OPEN failed for device DSK:
|]
	EXIT			;CROAK


DOEERR:	OUTSTR	[ASCIZ |
?ENTER failed for DSK:MAKSYM.DDT
|]
	EXIT			;CROAK

DIOERR:	OUTSTR	[ASCIZ |
?OPEN failed for input file device
|]
	JRST	MAINLP		;TRY AGAIN

DILERR:	OUTSTR	[ASCIZ |
?LOOKUP failure for input file
|]
	JRST	MAINLP		;TRY AGAIN

BADFIL:	OUTSTR	[ASCIZ |
?Incorrectly formatted file specification
|]
	JRST	MAINLP		;TRY AGAIN

RIOERR:	OUTSTR	[ASCIZ |
?Read error for input file
|]
	EXIT			;CROAK

NOTEXE:	OUTSTR	[ASCIZ |
?Input file not in .EXE format
|]
	JRST	MAINLP		;TRY AGAIN

CFIGET:	OUTSTR	[ASCIZ |
?Can't find GETTAB information in crash file
|]
	JRST	MAINLP		;TRY AGAIN
	SUBTTL	.SCAN argument blocks


;For call to .ISCAN

ISCARG:	XWD	     0,      0	;NO MONITOR COMMANDS
	XWD	     0,      0	;NO CCL ENTRY
	XWD	     0,      0	;CHARACTER OUTPUT ROUTINE
.LNISC==.-ISCARG		;LENGTH OF .ISCAN ARGUMENT BLOCK


;For call to .PSCAN

PSCARG:	IOWD	SWTCHL, SWTCHN	;IOWD POINTER TO SWITCH NAMES
	XWD	SWTCHD, SWTCHM	;
	XWD	     0, SWTCHP	;ETC
	XWD	     1, HLPTXT	;ADDRESS OF HELP MESSAGE
.LNPSC==.-PSCARG		;LENGTH OF .PSCAN ARGUMENT BLOCK


DM	CSZ,^D100,^D25,^D50

DEFINE	SWTCHS,<

SP	*CACHESIZE,S.CACH,.SWDEC##,CSZ,
SN	*MONITOR,S.MON

>; END DEFINE SWTCHS

	DOSCAN	(SWTCH)		;INVOKE THE SWITCH TABLE MACROS
DEFINE	HLPMSG,<
	XLIST			;TURN OFF LISTING
	ASCIZ	|

Type the name of a monitor crash  dump  file,  or  /MONITOR  to  extract
information from the running monitor.

Optional switches which may be specified with a crash dump file are:

/CACHESIZE:n        Cache the "n" most  recently  used  pages  from  the
                    crash dump file;  default for "n" is 25.

|
	LIST
>; END HLPMSG

HLPTXT:	HLPMSG			;GENERATE HELP TEXT
	SUBTTL	Impure Storage


PDLIST:	BLOCK	.LNPDL		;THE PDL

NEWKDB:	BLOCK	1		;NON-ZERO IF NEW (7.02 CI LIR) KDB FORMAT

S.MIN:!				;START OF SWITCH AREA
S.CACH:	BLOCK	1		;CACHE SIZE
S.MON:	BLOCK	1		;+1 IF /MONITOR TYPED
S.EMIN==.-1			;END OF SWITCH AREA

SPEC:	BLOCK	.FXLEN		;SCANNER FILE SPEC

DOPNBK:	.IOASC			;CHANNEL DO OPEN BLOCK
	SIXBIT	/DSK/		;LOGICAL DSK:
	XWD	OBUF, 0		;OUTPUT ONLY

DENTBK:	SIXBIT	/MAKSYM/	;FILE
	SIXBIT	/DDT/		;EXTENSION
	0			;PROTECTION
	0			;PPN

OBUF:	BLOCK	3		;OUTPUT BUFFER CONTROL BLOCK

DIOPBK:	.IODMP			;CHANNEL DI OPEN BLOCK
	SIXBIT	/DSK/		;FILLED IN BY WILD
	0			;DUMP MODE I/O

ZCORE:!				;START OF ZEROED AREA
LOKBLK:	BLOCK	.RBMAX		;LOOKUP BLOCK

DIRPTR:	BLOCK	1		;AOBJN POINTER TO EXE FILE DIRECTORY
EXEDIR:	BLOCK	.PGSIZ		;WHERE THE DIRECTORY IS STORED

OFSGTB:	BLOCK	1		;OFFSET FOR GETTAB INFORMATION
MAXGTB:	BLOCK	1		;MAXIMUM GETTAB TABLE
.CPMAP:	BLOCK	1		;ADDRESS OF BOOT CPU'S EXEC MAP
VMHUA:	BLOCK	1		;HIGHEST UNMAPPED ADDRESS
PERPRB:	BLOCK	1		;START OF PER-PROCESS AREA
PERPRE:	BLOCK	1		;END OF PER-PROCESS AREA

CSHPTR:	BLOCK	1		;AOBJN POINTER BASED ON /CACHESIZE:
PAGSTA:	BLOCK	1		;WHERE TO START ALLOCATING PAGES

CACHE:	BLOCK	MX.CSZ		;SPACE TO CACHE MAXIMUM NUMBER OF PAGES
EZCORE==.-1			;END OF ZEROED AREA

	END	MAKSYM		;THE END
