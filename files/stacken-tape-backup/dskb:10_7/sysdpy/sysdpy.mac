SUBTTL	SYSDPY %704(653) DYNAMIC SYSTAT FOR DISPLAYS	20-OCT-87
SUBTTL /PMW/RDH/GAT


;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1981,1982,1984,1985,1986,1987. ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
	SUBTTL	VERSION INFORMATION

SEARCH	SYSDPU			;SYSDPY'S CHEAP COPIES OF MONITOR'S SYMBOLS
SEARCH	JOBDAT,MACTEN,UUOSYM	;SYMBOL DEFINITIONS
SEARCH	GLXMAC,QSRMAC,ORNMAC	;FOR QUEUES SYMBOLS


COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1970,1987. ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO


SALL				;PRETTIER LISTINGS
.DIREC	FLBLST			;PRETTIER LISTINGS



;THE VERSION NUMBERS

MAJVER==704	;MAJOR (RELEASE) VERSION
MINVER==0	;MINOR (MAINTENANCE) LEVEL
EDTVER==653	;EDIT LEVEL
CSTVER==0	;CUSTOMER EDIT LEVEL

LOC	.JBVER
BYTE	(3)CSTVER(9)MAJVER(6)MINVER(18)EDTVER
RELOC
	SUBTTL	EDIT HISTORY

;EDIT LEVEL 471 TO 472

;EDIT 1  SYSVBX DID NOT RUN WITHOUT A CORE ARGUMENT ,AS  CORE
;	  EXPANSION WAS DONE AFTER A LOCK UUO

;EDIT 2 ASSIGN AND INIT VALUES WERE NO LONGER PRINTED BY VERSION471
;	 FOR DEVICES

;EDIT LEVEL 472 TO 474

;EDIT 3 UNMARKED ADD SUPPORT FOR VM SYSTEMS

;EDIT 4 ALWAYS USE REFRESH MODE FOR VM DISPLAY

;EDIT 5 USE IMGIN FOR SIZE OF LOW SEGMENTS ON VM SYSTEMS

;EDIT 6 FOR NONSHARABLE SEGMENTS ON VM SYSTEMS USE RIGHT HAND
;	9 BITS OF LEFT HALF WORD OF JBTSWP ENTRY

;EDIT 7 UPDATE HELP TEXT FOR M COMMAND AND ADD HELP TEXT
;	FOR USERS WITHOUT SPY OR PEEK PRIV. USINF F COMMAND

;EDIT 8 UPDATE SECOND LINE OF VM DISPLAY

;EDIT 9  DISPLAY WARNINGS ONLY ONCE
;	 TO THE NORMAL DISPLAY
;	ENTRY IN THE N DISPLAY

;EDIT 10 REPORT K OR P IN SWAP STATISTICS

;EDIT 11 THE AMOUNT OF SWAPPING SPACE USED IS COMPUTED WRONLY
;	 FOR KI SYSTEMS

;EDIT 12 THE SWAP ERROR COUNT IS COMPUTED IN THE WRONG WAY
;	 THIS MAY GIVE UNREASONABLY HIGH NUMBER OF ERRORS

;EDIT 13 INCREASE THE SLEEP TIME OF SYSDPY FROM 5 TO 10 SECONDS

;EDIT 14 SINCE VERSION 50665 MSK4KS IS 13 BITS

;EDIT 15 UNPRIVILIGED USERS DID NOT GET AN AUTOMATIC SCREEN REFRESH
;	 AFTER A WARNING

;EDIT 16 NEW VM DATA IN JOBVRT INTEGRATED

;EDIT 17 SINCE 678 LOAD JBT VRT IS OKAY SO UPDATE PGDATA LOGIC
;EDIT LEVEL 505 TO 506

;EDIT 18 CORRECT PRINTOUT OF VM DATA FOR INDIVIDUAL JOBS
;	 AND UPDATE SOME COMMENTS

;EDIT 19 PRINT CORRECT SWAPPING RATIO CORRECT EDIT 11
;	 AND USE RIGHT ACCU

;EDIT 20 LINE NUMBER OF JOBS IS WRONG FOR MONITORS OLDER
;	 THAN 503 NOT HAVING THE GETTAB ENTRY FOR DDBLDB

;EDIT 21 CORRECT CODE PRINTING LIMIT VALUES FOR SYSTEM
;	 AND USER PAGING RATES.NOTE: THIS EDIT IS NOT MARKED IN THE
;	 SOURCE

;EDIT 22 PRINT CORRECT SYSTEM PAGING RATE
;	 NOTE: EDIT NOT MARKED IN LISTING

;EDIT 507 VTO5-B DOES NOT WORK ON DC72 AT 2400 BAUD AS FILL CHARACTER
;	  0 DISAPPEARS THIS IS DUE TO THE DC72 BEING ASSEMBLED
;	  FEATURE SWITCH FTTOFN .NEQ. 0
;	  THIS EDIT IS ONLY FOR DOCUMENTATION

;EDIT 510 GIVE STRANGE OPERATING SYSTEMS AND UNPRIVILIGED USERS A CHANCE
;	  TO SEE LINE NUMBERS BY USING THE TRMNO. AND DEVNAM UUO

;EDIT 511 ADAPT TO NEW NUMTAB FORMAT USE LOAD 721 AS THE TRANSACTION
;	  NUMTAB CONTAINS ENTRY TYPE VALUE

;EDIT 512 BELIEVE IN NEW DEVJOB ENTRY IN DDB'S

;EDIT 513 MAKE F DISPLAY PAGEABLE

;EDIT 514 CORRECT DEVICE LOGIC FOR 602

;EDIT 515 CLEAN UP CHARACTER INPUT LOGIC

;EDIT 516 MAKE C FILE A UNIVERSAL

;EDIT 517 CLEAN UP ERRORS IN PAGED F DISPLAY

;EDIT 520 WAIT A LITTLE BETWEEN DISPLAYS SO ONE CAN
;	   READ THE DISPLAY

;EDIT 521 REFRESH THE SREEN WHEN CHANGING THE DISPLAY PROGRAM

;EDIT 522 FIX THE DISAPEARING M DISPLAY

;EDIT 523 FIX REFRESH PROBLEM

;EDIT 524	ONLY ESCAPE COULD ESCAPE FROM A FROZEN SCREEN ALLOW ANY
;		CHARACTER
;EDIT 525	USE HRRZ FOR GETTING MONVER

;EDIT 526	PEEK FACILITY WAS NOT RECOGNIZED

;EDIT 527	DONOT DISPLAY AN EMPTY F DISPLAY SCREEN

;EDIT 530	ADAPT TO CHANGED JUMPPT MACRO

;EDIT 531	UNPRIVILIGED JOBS GET DATA FOR CPU1 ON A SINGLE
;		CPU SYSTEM

;EDIT 532	ADD HISEG SIZE TO MONITOR SIZE

;edit 533	search universal jobdat file for jobdat symbols

;edit 534	jobs locked into core cannot refresh the screen

;edit	535	too many " dev by how headers" are printed when
;		display ends at bottom of a column

;edit 536	d display hangs for unpriviliged users

;edit 537	d display contains extra right paren between w column
;		and swap ratio column
;edit 540	add vt61 support
;edit	541	add vt50 supprot
;edit	542	add vt52 support
;edit	543	add network topology "wt" display
;edit	544	add network statistics display
;edit	545	add individual print line for one job on normal display
;edit	546	add control R and A for VT61 support
;edit	547	make edits 540 thru 547 work
;edit	550	make edit 542 work
;edit	551	Fix averages of edit 544
;edit	552	Fix DEVJOB so owner of device is correct
;EDIT	553	VT50 CANNOT (IN GENERAL) CURSOR ADDRESS; NTAVG VALUE FOR
;		"\" DISPLAY WRONG (MONITOR INFORMATION STILL ALMOST
;		USELESS HOWEVER); "T" HISTOGRAM POWERS OF 2 OFF BY ONE;
;		"DEVICE BY HOW" FIELD TOO SMALL FOR "HOW" FOR 5 & 6 CHAR
;		DEVICE NAMES (IF 72-COLUMN TERMINAL ONLY 2 COLUMNS CAN
;		NOW FIT ON SCREEN); DON'T SHOW HISEG STUFF ON VT50 SINCE
;		IT CONFLICTS WITH DEV BY HOW FIELD (AND NEITHER WORKS AS
;		A RESULT); ALLOW FOR 3-DIGIT NODE NUMBERS IN "T" DIS-
;		PLAY; IMPLEMENT "O" COMMAND TO TOGGLE SUPPRESSION OF
;		[OPR] JOBS ON "N" AND "M" DISPLAYS

;EDIT	554	FIX ^A AND ^R COMMANDS - ALSO, IF REVERSE VIDEO MODE
;		AND REFRESHING, REFRESH SCREEN IN NORMAL MODE THEN GO
;		BACK TO REVERSE VIDEO FOR UPDATING; ON EXIT CLEAR BOTH.
;EDIT	555	GETTAB THE PJOBN INFO (7.01) IF POSSIBLE; DON'T SHOW THE
;		DUMMY DDB'S USED FOR TAPE LABELING; SHOW TTY DDB'S NOT
;		CONTROLLING A JOB (I.E., IN USE AS AN I/O DEVICE)

;EDIT	556	USE .GTNDB TABLE IF EXTANT FOR NDB POINTERS. CLEANUP.

;EDIT	557	DON'T PRINT INCREMENTAL SYSTEM UPTIMES
;		CALL VERSION 434

;EDIT	560	PRINT TRUE USER MEMORY AVAILABLE. ADD "L" COMMAND
;		TO LOG THE SCREEN IN LPT:SYSDPY.LOG[-].

;EDIT	561	ADD "Q" COMMAND TO LIST THE QUEUES, COMPRESS "T"
;		DISPLAY TO ALLOW FOR MORE NEIGHBORS. ADD (KL ONLY)
;		RH20 AND PI USAGE DISPLAYS TO "N" DISPLAY.

;EDIT	562	ADD "N+" AND "N-" COMMANDS. SHOW SECOND UNIT OF DUAL-
;		PORTED DISKS IN "F" DISPLAY. (NOTE THAT THIS DEPENDS ON
;		DSKCHR RETURNING THE SECOND PORT INFORMATION, WHICH
;		IT DOESN'T IN EARLY 7.00 MONITORS. DATE PRINTED WRONG.
;		SHOW CACHE SWEEPS ON KS-10 ALSO. "J" DISPLAY DIDN'T DO
;		INCREMENTAL RUNTIMES CORRECTLY. NEW VALUES FOR GALAXY
;		SYMBOLS. LOG TO DSK:SYSDPY.LOG INSTEAD. CLEAR BOTTOM OF
;		SCREEN ON EXIT (GENERAL VOTE SEEMS TO PREFER THIS OVER
;		CLEARING ENTIRE SCREEN AND POSITIONING TO HOME).

;SYSDPY %434(562) RELEASED WITH 7.01 MONITOR

;563	BCM	8-JAN-81	SPR 10-30327
;	MAKE PICKING UP THE HELP FILE ON HLP: WORK

;564	RDH	15-MAY-81	(GAT  SPR 10-30418)
;	ALLOW FOR MEMTAB AND PAGTAB IN PHYMAX CALCULATION.

;565	RDH	2-AUG-81	NO SPR
;	WHEN LOOKING FOR ALTERNATE DISK PORT, DON'T BE CONFUSED BY FLAG
;	BITS (1B0) IN UDB ADDRESS.

;566	RCB	21-AUG-81	NO SPR
;	ADD SYSANS FOR VT100'S IN ANSII MODE

;567	RDH	12-OCT-81
;	HANDLE NETWORK ("\" DISPLAY) LENGTH .GT. 2**9
;
;570	G. TREMBLAY	15-DEC-81	SPR 10-31707
;	REMOVE CODE FROM ROUTINE "INACTC" THAT LOOKS FOR "HB"
;	STATE IN QTAB. (THIS ALSO REMOVES TYPO: ACCUMULATER "C"
;	SHOULD OF BEEN "D")
;
;571	G. TREMBLAY	18-DEC-81	SPR 10-30777
;	ADD CONDITIONAL ASSEMBLY CODE AROUND THE DEFINITION
;	LINES THAT REFERENCE SYMBOL "X2SIZE"
;
;572	G.TREMBLAY	23-FEB-82	SPR 10-31193,31484
;	FIX >100%s DURING INCREMENTAL VIRTUAL MEMORY DISPLAY(I,M,%)
;
;573	G. TREMBLAY	23-FEB-82	SPR 10-31166
;	PRINT LOGMAX IN "Log'd in:" MSG
;
;574	G. TREMBLAY	11-MAR-82	
;	CORRECT CALCULATION OF ASR TO INCLUDE LOCKED SEGMENT
;	SIZES INTO MAXMAX. ALSO ONLY ADD HIGH SEGMENTS INTO ACTUSE
;	ONCE. (SYSDPY/SYSTAT's ASR ARE THE SAME NOW)
;
;576	G. TREMBLAY	15-MAR-82	SPR 10-31393
;	TRY TO GET QUASAR'S PID EACH "Q" COMMAND IF NOT SUCCESSFUL
;	DURING SYSDPY INITIALIZATION.
;
;577	A RIZZOLO	8-JUN-82
;	ADD CODE TO GIVE A DISPLAY OF BOTH DECNET LINK STATUS
;	AND DECNET NODE STATUS (SPECIAL MESSAGES FOR ANSI TERMINALS).
;
;600	G. TREMBLAY	22-JUL-82	SPR 10-32709
;	ADD NEW COMMAND ^N TO SYSDPY TO TOGGLE NON-IDLE JOBS.
;
;601	G. TREMBLAY	18-JAN-83	NO SPR
;	GETTAB LDBDCH OFFSET TO CORRECT "T" DISPLAY
;
;602	G. TREMBLAY	28-APR-83	NO SPR
;	REMOVE OLD "GODLY" DEBUGGING CODE.
;
;603	G.TREMBLAY	28-APR-83	NO SPR
;	LET SYSDPY SEARCH GALAXY UNIVERSALS FOR SYMBOL DEFINITIONS.
;
;604	TARL		28-APR-83
;	UPDATE SYSDPY TO USE NEW DNET. UUO FORMAT PER MCO 10716
;
;605	G. TREMBLAY	25-JUL-83	10-33739
;	FIX ILL MEM REFERENCES CAUSED BY EDIT 563 WHEN ACCESSING
;	EXTERNAL HELP FILE.
;
;606	G. TREMBLAY	6-AUG-83	SPR 10-34051
;	CORRECT SYSDPY'S CPU IDLE TIMES TO BE EQUAL TO
;	NULL TIME MINUS LOST TIME.
;
;607	RDH		27-NOV-83
;	ADD "MTAI/MTAO" PER-CPU FIELDS; ADD DECNET BYTE COUNTS (RENAME "NET"
;	TO "ANF", ADD "DCN" FOR DECNET); ADD CHUNK COUNTS TO "TTY CNK:"; ADD
;	IPCF STATISTICS; REVAMP "JOBS:" DISPLAY (COMPRESS IT); ADD "^" COMMAND
;	TO "SKIP" FIRST PART OF SYSTEM STATISTICS (ALSO INVALID-DELAY FOR
;	DECNET); REFORMAT "F" DISPLAY (MINOR CHANGE); USE "!" FOR IDLE
;	SUPPRESSION IN BOTH JOB AND DECNET DISPLAY.
;	SUPPRESS "PHYMAX" (CAN'T GET IT RIGHT FOR 7.02); REVAMP CALCULATIONS
;	FOR ACTUSE/PHYUSE/VIRUSE; CHANGE LOCK ("V") TO CACHED NON-CONTIGUOUS
;	NON-EVM MEMORY (MINIMUM LOAD ON SYSTEM); FIX TYPEOUT OF USER NAME
;	("S" DISPLAY) TO ALWAYS TYPE ENTIRE NAME WITH EMBEDDED BLANKS;
;	ALWAYS UNLOCK FOR "Q" DISPLAY; FIX "F" DISPLAY FOR NON-DUAL-PORTED
;	SYSTEMS (E.G., KS10) WITH FTDUAL=0; CLEAR "L" ON EXIT (AVOID
;	"I/O TO UNASSIGNED CHANNEL" ON CONTINUE COMMAND AFTER ^Z).
;
;SYSDPY %435(607) RELEASED WITH 7.02 MONITOR


;
;610	GAT		24-FEB-84	SPR 10-33672
;	UPDATE EDIT 600 TO DISPLAY JOBS THAT WERE NON-IDLE BETWEEN SYSDPY
;	PASSES. ALLOW A RUNTIME THRESHOLD VALUE TO BE INPUTTED
;	TO DISPLAY NON-IDLE JOBS WHOS' RUNTIME EXCEED THE
;	THRESHOLD VALUE. CHANGE COMMAND FROM "^N" TO "!"
;	COMMAND FORM: "n!" WHERE THRESHOLD = n/100 SECONDS.
;
;611	GAT	18-JUN-84	SPR 10-33292
;	ADD AUTO ROLL TO "Q" DISPLAY.
;
;612	RDH	22-JUN-84	NO SPR
;	"CPOPJ" FROM ROUTINE GET0 IF NO GETTAB TABLE BASE ADDRESS IS FOUND.
;	(M.DECN=0 DOES THIS, CAUSES LOOP, ILL MEM REF, ETC.)
;
;613	RDH	9-JUL-84
;	FIRST 7.03 SYSDPY. REMOVE "SEEKS" FROM FILE DISPLAY IN ORDER TO
;	EXPAND OTHER COLUMNS; ADD "PR" AND "PW" (PAGING I/O) TO SWAP
;	DISPLAY.
;
;614	RDH	23-OCT-84
;	MORE 7.03 UPDATING.
;
;615	RDH	5-NOV-84
;	MORE 7.03 UPDATING; ADD MORE DECNET OBJECT TYPES.
;
;616	RDH	13-FEB-85
;	MORE 7.03 UPDATING; ADD EVEN MORE DECNET OBJECT TYPES; EXPAND "M"
;	DISPLAY COLUMNS TO HANDLE LARGER JOB SIZES (HOWEVER STILL NEEDS
;	JBTVRT GETTAB'ABLE, SO FOR NOW "VIRTUAL" IS SAME AS "PHYSICAL").
;
;617	RDH	11-APR-85
;	USE JBTVIR FOR VIRTUAL PROGRAM SIZES (ALSO FIXES "SWP" DISPLAY).
;
;620	RDH	23-MAY-85
;	ADD "ETH" LINE TO SYSTEM DISPLAY.
;
;621	RDH	5-JUN-85
;	DI/TI WRONG (DDB ADDRESS NOW IN JBTDDB). DISPLAY UNREASONABLY-
;	LARGE KSYS TIMES AS DAYS:HOURS:MINUTES
;
;622	WXD	25-JUN-85
;	ADD "E" COMMAND TO LIST ETHERNET STATISTICS.  ALSO ADD "EE"
;	EVENT WAIT CODE FOR ETHERNET EVENT WAIT.
;
;623	JAD	28-JUN-85
;	ADD "K" COMMAND TO LIST CI NETWORK STATISTICS.
;
;624	CJA	1-JUL-85
;	ADD "Z" COMMAND TO LIST LAT SERVER STATISTICS.
;
;625	RDH	21-AUG-85
;	ADD "THISIM" ROUTINE TO PRINT DISPLAY-SPECIFIC-HEADER-TEXT AND
;	THEN THE NORMAL "THISIS" SYSTEM HEADER, UPDATE MOST DISPLAYS TO
;	USE NEW ROUTINE.
;
;626	WXD	29-AUG-85
;	FIX ETHERNET DISPLAY TO PRINT KONTROLLER NAMES CORRECTLY.
;
;627	LEO	9-SEP-85
;	Do Copyrights.
;
;630	WXD	16-SEP-85.
;	PRINT OUT ETHERNET CHANNEL NUMBER FROM NEW VALUE RETURNED BY
;	FUNCTION .ETRCI OF ETHNT. UUO.
;
;631	WXD	24-SEP-85.
;	EDIT 626 BROKE INCREMENTAL DISPLAY OF ETHERNET COUNTERS.
;
;632	WXD	2-DEC-85.
;	FIX BUG IN ETHRPL WHICH WASN'T STORING THE CHANNEL ID IN THE
;	ETHNT. ARGUMENT BLOCK.
;
;633	RDH	5-MAR-86
;	KS/DECNET IS INSANE. DON'T TRY TO DISPLAY "DCN" FIELD.
;
;634	RDH	7-MAR-86
;	"DCN" COUNTS DON'T INCLUDE ETHERNET COUNTS (ETHERNET DOESN'T KEEP
;	THE COUNTS IN THE "DL" BLOCK LIKE EVERYONE ELSE - GRRR!!!!)
;
;635	JAD	27-MAR-86
;	SPACING ON SINGLE CPU CI STATUS DISPLAY IS INCORRECT.
;
;BEGIN VERSION 704
;
;	650	JAD	22-AUG-86
;	TEACH SYSDPY ABOUT NEW FORMAT OF JBTSGN.
;
;	651	JMF	21-MAY-87
;	SYSDPY REPORTS THAT JOBS WITH SPY SEGMENT ARE VIRTUAL
;
;	652	RCB	20-OCT-87
;	READ ANF/ETHERNET PROTOCOL FROM THE .GTNTP GETTAB FOR "E" DISPLAY.
;	ALSO FIX THE "OPR" FIELD OF "T" DISPLAY.
;
;	653	LWS	2-Aug-88
;	ADD "FRU" (FREE CORE USED) LINE IN "N" DISPLAY.
;
;END OF EDIT HISTORY
	SUBTTL	AC ASSIGNMENTS
;
;NOTE THAT HELP PROGRAM USES ACS 0-6 IN UNUSUAL WAY

M=0
A=1
B=2
C=3
D=<T4==4>
J=<P4==5>
JS=<XCUR==6>
P1==6
P2==3
R=<YCUR==7>
N=<X==10>
N1=11
F=12
BP=13
T1=14
T2=15
CH=16
P=17

.XCREF	M,A,B,C,D,J,JS,R,N,N1,BP,T1,T2,CH,P  ;SAVE SOME PAPER

;I/O CHANNELS
TTY==1		;NORMAL DISPLAY OUTPUT (CHARACTER TERMINAL)
DIS==1		;VIDEO DISPLAY
HLP==3		;HELP FILE CHANNEL
LOG==4		;SCREEN LOGGING CHANNEL
	SUBTTL	DISPLAY PARAMETERS

V.DVT6==0	;DIGITAL VT06
V.DV5A==1	;DIGITAL VT05A
V.DV5B==2	;DIGITAL VT05B
V.DVBX==3	;DIGITAL VB10C
V.DV61==4	;DIGITAL VT61 DISPLAY
V.DV50==5	;DIGITAL VT50 DISPLAY
V.DV52==6	;DIGITAL VT52 DISPLAY
V.ANSI==7	;DIGITAL VT100 DISPLAY
V.DHZL==20	;HAZELTINE 2000
V.DDLT==21	;DELTA DATA TELTERM
;RECOMMEND CUSTOMERS ASSIGN NEGATIVE VALUES

ND	V.DISP,V.ANSI		;DEFAULT TO VT100/ANSI TERMINALS
IFE V.DISP-V.DVT6,<
	TITLE	SYSDPY -- SYSTEM DISPLAY FOR DIGITAL VT06 DISPLAY TERMINAL

	XSIZE==^D72		;WIDTH OF SCREEN
	YSIZE==^D25		;HEIGHT OF SCREEN

ND	UPDNJB,^D20		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D100		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CFILL==177		;FILLER CODE
	CDOWN==12		;CURSOR DOWN
	CUP==32			;CURSOR UP
	CLEFT==31		;CURSOR LEFT
	CRIGHT==30		;CURSOR RIGHT
	HOMEUP==35		;CURSOR TO HOME
	ERASE==37		;ERASE TO END OF SCREEN
	EREOL==36		;ERASE TO END OF LINE
>;	END OF	IFE V.DISP-V.DVT6
IFE <V.DISP-V.DV5A>*<V.DISP-V.DV5B>,<
IFE V.DISP-V.DV5A,<
	TITLE	SYSDPA -- SYSTEM DISPLAY FOR DIGITAL VT05A DISPLAY TERMINAL>
IFE V.DISP-V.DV5B,<
	TITLE	SYSDPB -- SYSTEM DISPLAY FOR DIGITAL VT05B DISPLAY TERMINAL>

	XSIZE==^D72
	YSIZE==^D20

ND	UPDNJB,^D15		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D1000		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CFILL==0
	CDOWN==12
	CUP==32
	CLEFT==31
	CRIGHT==30
	HOMEUP==35
	ERASE==37
	EREOL==36
>;	END OF IFE <V.DISP-V.DV5A>*<V.DISP-V.DV5B>
IFE V.DISP-V.DVBX, <
	TITLE	SYSVBX -- SYSTEM DISPLAY FOR DIGITAL VB10C INCREMENTAL PRECISION DISPLAY

	XSIZE==^D72
	YSIZE==^D25

ND	UPDNJB,^D20		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D10000		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CDOWN==12
	CUP==32
	CLEFT==31
	CRIGHT==30
	HOMEUP==35
	ERASE==37
	EREOL==36
>;	END OF	IFE V.DISP-V.DVBX
IFE V.DISP-V.DV50,<
	TITLE	SYSV50 -- SYSTEM DISPLAY FOR DIGITAL VT50 DECSCOPE

	XSIZE==^D80
	YSIZE==^D12

ND	UPDNJB,^D8		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D10000		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CUP=="A"_^D9 + .CHESC
;	CDOWN=="B"_^D9 + .CHESC
	CDOWN==12
	CRIGHT=="C"_^D9 + .CHESC
;	CLEFT=="D"_^D9 + .CHESC
	CLEFT==010
	HOMEUP=="H"_^D9 + .CHESC
	ERASE=="J"_^D9 + .CHESC
	EREOL=="K"_^D9 + .CHESC
>;	END V.DISP-V.DV50
IFE V.DISP-V.DV52,<
	TITLE	SYSV52 -- SYSTEM DISPLAY FOR DIGITAL VT52 DECSCOPE

	XSIZE==^D80
	YSIZE==^D24

ND	UPDNJB,^D20		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D10000		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CUP=="A"_^D9 + .CHESC
	CDOWN=="B"_^D9 + .CHESC
	CRIGHT=="C"_^D9 + .CHESC
	CLEFT=="D"_^D9 + .CHESC
	HOMEUP=="H"_^D9 + .CHESC
	ERASE=="J"_^D9 + .CHESC
	EREOL=="K"_^D9 + .CHESC
>;	END V.DISP-V.DV52
IFE V.DISP-V.DV61,<
	TITLE	SYSV61 -- SYSTEM DISPLAY FOR DIGITAL VT61 DECSCOPE

	XSIZE==^D80
	YSIZE==^D24

ND	UPDNJB,^D20		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D10000		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CUP=="A"_^D9 + .CHESC
	CDOWN=="B"_^D9 + .CHESC
	CRIGHT=="C"_^D9 + .CHESC
	CLEFT=="D"_^D9 + .CHESC
	HOMEUP=="H"_^D9 + .CHESC
	ERASE=="J"_^D9 + .CHESC
	EREOL=="K"_^D9 + .CHESC
>;	END V.DISP-V.DV61
IFE V.DISP-V.ANSI,<		;
	TITLE	SYSANS -- SYSTEM DISPLAY FOR ANSI TERMINALS (SUCH AS VT100)

	XSIZE==^D80
	YSIZE==^D24

ND	UPDNJB,^D20		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D10000		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CUP=="A"_^D18 + "["_^D9 +  .CHESC
	CDOWN=="B"_^D18 + "["_^D9 + .CHESC
	CRIGHT=="C"_^D18 + "["_^D9 + .CHESC
	CLEFT=="D"_^D18 + "["_^D9 + .CHESC
	HOMEUP=="H"_^D18 + "["_^D9 + .CHESC
	ERASE=="J"_^D18 + "["_^D9 + .CHESC
	EREOL=="K"_^D18 + "["_^D9 + .CHESC
>;	END V.DISP-V.ANSI
IFE V.DISP-V.DHZL, <
	TITLE	SYSHZL -- SYSTEM DISPLAY FOR HAZELTINE 2000 DISPLAY TERMINAL

	XSIZE==^D74
	YSIZE==^D27

ND	UPDNJB,^D20		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D10000		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CDOWN==12
	CUP==32
	CLEFT==31
	CRIGHT==30
	HOMEUP==35
	ERASE==37
	EREOL==36
>;	END OF	IFE V.DISP-V.DHZL
IFE V.DISP-V.DDLT, <
	TITLE	SYSDLT -- SYSTEM DISPLAY FOR DELTA DATA TELTERM DISPLAY TERMINAL

	XSIZE==^D80
	YSIZE==^D27

ND	UPDNJB,^D20		;NUMBER OF JOBS TO +-
ND	NSYSYS,1		;LINE TO START SYSTEM DISPLAY IN "N"
ND	REPRAT,^D10000		;NUMBER OF PASSES BEFORE REFRESH FORCED

	CDOWN==12
	CUP==32
	CLEFT==31
	CRIGHT==30
	HOMEUP==35
	ERASE==37
	EREOL==36
>;	END OF	IFE V.DISP-V.DDLT
	SUBTTL	ASSEMBLY PARAMETERS

ND	FTNET,-1	;DEFAULT NETWORK DISPLAY ON

ND	PDLEN,^D20	;PUSH DOWN STACK LENGTH
ND	JIFSEC,^D60	;LINE FREQ IF NO GETTAB
ND	INTVAL,^D10	;NUMBER OF SECONDS BETWEEN UPDATES
ND	RELOCK,^D1000	;# PASSES BEFORE CANCELLING /V
ND	DSKBKL,.DCMAX	;LENGTH OF DSKCHR BLOCK
ND	SWPTLN,^D16	;LENGTH OF SWAPPING UNIT TABLE
ND	XDBLEN,^D64	;SCRATCH DATA BLOCK LENGTH
ND	IPCPAG,377	;IPCF PAGE TO USE
ND	MAXNDS,20	;MAXIMUM NUMBER OF CI NODES
ND	NOSTCT,25	;NUMBER OF STATISTICS COUNTERS
HSIZE==^D39
SUBTTL PARAMETERS AND DEFINITIONS

;FLAGS (LH OF F)

FL.SUP==1	;SUPPRESS OUTPUT
FL.DEV==2	;DEVICE HEADER OUTPUT
FL.GOD==4	;I AM [1,N]
FL.FLS==10	;TOGGLE FOR FLASHING LINES
FL.INC==20	;TOGGLE DISPLAY OF INCREMENTAL STATISTICS
FL.DOR==40	;DORMANT SEG TABLE BEING PRINTED
FL.SCN==100	;NEW SCANNER SERVICE (FOR TTYTAB LAYOUT)
FL.SPY==200	;SPY UUO DONE SUCCESSFULLY
FL.EOL==400	;SYNC FOR CLEAR EOL IN OUTPUT
FL.LOG==1000	;LOGGING EACH SCREEN
FL.REF==2000	;ONE FOR FULL REFRESH PASS, 0 FOR PARTIAL
FL.PDOR==4000	;FIRST OR SECOND HISEG PASS
FL.NBK==10000	;NON-BLANK LINE
FL.HLP==20000	;LAST TYPEIN WAS JUNK--FLASH HELP
FL.PEK==40000	;PEEK UUO DONE SUCCESSFULLY
FL.NHED==100000	;NO HEADING ON 2ND COLUMN
FL.LOCK==200000	;JOB IS LOCKED INTO CORE
FL.CRF==400000	;GIVE A FREE CRLF AT RIGHT MARGIN IF NEEDED

;FLAGS (RH OF F)

FR.JOB==1B18	;JOBS ONLY (MULTI-COLUMN) IN "N" DISPLAY
FR.SJB==1B19	;EXPANDED JOB (72 CHARS WIDE), NO SYSTEM STUFF
FR.ALT==1B20	;SINGLE PASS ALTMODE
FR.SKP==1B21	;SKIP FIRST PART OF SYSTEM DISPLAY
FR.DIS==1B22	;DISPLAY INITIALIZED
FR.KIX==1B23	;RUNNING ON A KI-10
FR.KIP==1B24	;CORE ALLOCATION IS IN PAGES
FR.PDB==1B25	;FLAG FOR SPY TABLE INITILIZATION
FR.VMM==1B26	;"M" OPTION DISPLAY
FR.IDL==1B27	;SUPPRESS IDLE JOBS
FR.NRM==1B28	;DISPLAY NORMAL PROGRAM AGAIN
FR.OPR==1B30	;SUPPRESS [OPR] JOBS
FR.PCT==1B31	;DISPLAY RUNTIME IN PERCENTAGE
FR.NSF==1B32	;NEW HIGH SEGMENT TABLE FORMAT
FR.RVD==1B33	;REVERSE VIDEO
FR.RVR==1B34	;REVERSE VIDEO REFRESH RESET
FR.ALR==1B35	;ALARM MODE

	;STATUS BITS TO INITIALIZE

	;STATUS BITS TO PRESERVE
FX.MSK==FL.GOD!FL.FLS!FL.INC!FL.SCN!FL.SPY!FL.LOG!FL.REF!FL.HLP!FL.PEK!FL.LOCK,,FR.SJB!FR.ALT!FR.DIS!FR.KIX!FR.KIP!FR.RVD!FR.RVR!FR.ALR!FR.IDL!FR.SKP!FR.OPR!FR.PCT!FR.NSF
OPDEF	IFIW	[1B0]
	.NODDT	IFIW

OPDEF	CALL	[PUSHJ	P,]
OPDEF	RETURN	[POPJ	P,]

DEFINE	HEX(NUM),<
	..X==0
	IRPC(NUM),<
		...X==-1
		IFIDN <NUM><0>,<...X==^D00>
		IFIDN <NUM><1>,<...X==^D01>
		IFIDN <NUM><2>,<...X==^D02>
		IFIDN <NUM><3>,<...X==^D03>
		IFIDN <NUM><4>,<...X==^D04>
		IFIDN <NUM><5>,<...X==^D05>
		IFIDN <NUM><6>,<...X==^D06>
		IFIDN <NUM><7>,<...X==^D07>
		IFIDN <NUM><8>,<...X==^D08>
		IFIDN <NUM><9>,<...X==^D09>
		IFIDN <NUM><A>,<...X==^D10>
		IFIDN <NUM><B>,<...X==^D11>
		IFIDN <NUM><C>,<...X==^D12>
		IFIDN <NUM><D>,<...X==^D13>
		IFIDN <NUM><E>,<...X==^D14>
		IFIDN <NUM><F>,<...X==^D15>

		IFL	...X,<
			PRINTX ?Illegal Hexadecimal digit
			STOPI>
		..X==..X*^D16 + ...X>
	..X>

DEFINE	SET	(LT,RT,TOP,BOT,NEXT,TABS)<
	PUSHJ	P,SETUP
	XX=10
	RADIX	10
	BYTE	(7)LT-1(7)RT-LT(5)TOP-1,BOT-1(2)NEXT(10)TABS-TAB0
	RADIX	XX
>

DEFINE	TABSET	(TABS)<
	PUSHJ	P,TSETUP
	EXP	TABS-TAB0
>

DEFINE	CHANGE	(LT,RT,TOP,BOT,NEXT,TABS)<
	FIN
	SET	LT,RT,TOP,BOT,NEXT,TABS
>

DEFINE FIN <
	TLO	F,FL.NHED	;SET TO SUPPRESS SECOND HEADING
	PUSHJ	P,CRLF		;CLEAR ALL REMAINING SPACE
	SKIPL	LINE
	JRST	.-2
	TLZ	F,FL.NHED
>

DEFINE	HEADER(TEXT,%L) <
	CALL	SETHDR		;REMEMBER HEADER CODE
	JRST	%L		;SKIP HEADER
	PUSH	P,M		;;SAVE M
	TEXT
	POP	P,M		;;GET REGISTER BACK
	RETURN
%L:
>
	SUBTTL	PSEUDO OPERATIONS

;THE FOLLOWING MACROS ALLOW THE DEFINITION OF PSEUDO OPCODES

;OPCODES

.OPTXT==0		;TEXT TO BE PRINTED
.OPGTD==1		;PRINT GETTAB X,Y IN DECIMAL
.OPNWL==2		;A NEW LINE
.OPSTP==3		;END OF PSEUDO PROGRAM
.OPPLD==4		;PRINT LEFT HALF IN DECIMAL
.OPPRD==5		;PRINT RIGHT HALF IN DECIMAL
.OPGTB==6		;GETTAB VALUE
.OPPFS==7		;PRINT A FLOAT SCALED
.OPTAB==10		;PRINT ATAB CHARACTER
.OPLPA==11		;PRINT A LEFT PAREN
.OPRPA==12		;PRINT A RIGHT PAREN
.OPPER==13		;PRINT A PERIOD
.OPPLS==14		;PRINT A PLUS SIGN
.OPPRP==15		;PRINT RIGHT DECIMAL PADDED

.OPMAX==15		;LAST ONE
	DEFINE	.TXT(TEXT)
<	BYTE	(9).OPTXT(9)0(18)[ASCIZ \TEXT\]
>
	DEFINE	.PGTBD(X,Y)
<	BYTE	(9).OPGTD(9)X(9)0(9)Y
>
	DEFINE	.NWLIN
<	BYTE	(9).OPNWL(27)0
>
	DEFINE	.END
<	BYTE	(9).OPSTP(27)0
>
	OPDEF	.PLD[4B8]
	OPDEF	.PRD[5B8]
	DEFINE	.GTB(X,Y,WHERE)
<	BYTE	(9).OPGTB(9)X(18)Y
	Z	WHERE
>
	OPDEF	..PRDP[15B8]

	DEFINE	.PRDP(WHERE,FACTOR)
<	..PRDP	WHERE
	EXP	FACTOR
>

	OPDEF	..PFLS[7B8]
	DEFINE	.PFLS(WHERE,SCALE)
<	..PFLS	WHERE
	EXP	SCALE
>
	DEFINE	.INL(%L)
<	MOVEI	A,.+2		;;GET PSEUDO PC
	JRST	PSEUDO		;;AND START PSEUDO INTERPRETATION
>
	DEFINE	.TAB
<	BYTE	(9).OPTAB(27)0
>
	DEFINE	.LPA
<	BYTE	(9).OPLPA(27)0
>
	DEFINE	.RPA
<	BYTE	(9).OPRPA(27)0
>
	DEFINE	.PER
<	BYTE	(9).OPPER(27)0
>
	DEFINE	.PLS
<	BYTE	(9).OPPLS(27)0
>
SUBTTL TOP LEVEL PROGRAM
;START HERE

SYSDPY:	JFCL			;ALLOW FOR CCL ENTRY
	SETZB	0,ZER		;CLEAR OUT SCRATCH
	MOVE	A,[ZER,,ZER+1]
	BLT	A,LZER
	MOVEI	17,1		;CLEAR
	BLT	17,16		; ACS
	MOVE	P,[IOWD PDLEN,PDLST]  ;INITIALIZE PDL POINTER
	SETZ	F,		;NO FLAGS
	SETOM	.FRAJR		;AUTOMATIC ROLL FEATURE
	JUMPPT	A,,KA10		;SEE IF KI-10
	TRO	F,FR.KIX!FR.KIP	;YES--SET FLAG
KA10:	MOVE	A,[%CNVER]	;GET MONITOR VERSION
	GETTAB	A,		;GET MONITOR VERSION VIA UUO!!
	 SETZM	A		;VERY OLD!!
	MOVEM	A,MONVER	;  TESTS
	HRRZS	A		;KEEP JUST DEC VERSION
	CAILE	A,70307		;MONITOR HAVE NEW HIGH SEGMENT TABLE FORMAT?
	TROA	F,FR.NSF	;YES
	TRZ	F,FR.NSF	;NO
	MOVX	A,%CNDJB	;ASK MONITOR FOR
	GETTAB	A,		;PJOBN/DEVJOB INFORMATION
	 MOVE	A,[POINT 9,20,35]  ;6-SERIES MONITORS
	HRRM	A,PJOBNO	;SAVE DEVJOB INDEX
	HLLM	A,PJOBNP	;AND POINTER TO JOB NUMBER IN SAME
SYSD00:	MOVX	A,%CNPGS	;GET "PAGE" SIZE
	PUSHJ	P,GETZ		;FROM MONITOR
	JFFO	A,.+1		;COUNT BITS
	MOVN	B,B		;NEGATIVE LEADING ZEROS
	ADDI	B,^D35		;POSITIVE TRAILING ZEROS
	MOVEM	B,P2WLSH	;SO CAN LSH @P2WLSH
	MOVN	B,B		;NEGATIVE
	HRRZM	B,W2PLSH	;SO CAN LSH @W2PLSH
	SETZM	DUAL		;ASSUME ONE CPU
	MOVE	A,[%CNSTS]	;GET STATUS WORD
	PUSHJ	P,GETA		;IN A
	TLNE	A,(ST%DUL)	;A DUAL PROCESSOR SYSTEM
	SETOM	DUAL		;YES FLAG IT
	MOVE	A,[%CNTIC]	;NO OF TICKS PER SECOND
	PUSHJ	P,GET		;GETTAB PRESENT?
	  MOVEI	A,JIFSEC	;NO, PRESET JIFFY CLOCK
	MOVEM	A,TCKSEC
	MOVEI	A,NORMAL	;SET NORMAL PROGRAM ON ENTRY
	MOVEM	A,PROGRM	;SAVE DISPLAY PROGRAM ADDRESS
	RESET			;RESET THE WORLD
	HRROI	A,.GTPRV	;GET OUR PRIVS
	PUSHJ	P,GETZ		; FROM MONITOR
	TXNE	A,JP.SPM	;SEE IF CAN SPY ON MONITOR
	TLO	F,FL.GOD	;YES--SET GOD FLAG
	PUSHJ	P,OPNTTY	;OPEN THE TTY CHANNEL
	MOVE	A,XGETTS	;GETTAB SELF TABLE
	PUSHJ	P,GETZ		;GET IT
	JUMPE	A,START		;OK?
	MOVEM	A,GTTSLF	;SAVE SELF POINTER
	MOVE	A,XPDBPT	;PTR TO PTR TO PDB'S
	PUSHJ	P,GETZ		;GET PTR TO PDB'S
	SKIPLE	A		;SKIP IF ABSENT
	TDO	A,[XWD N1,400000];SET BIT FOR SPYING
	SKIPL	A		;SEE IF SWAPPING PDBS
	JRST	SYSD03		;NO--CONTINUE
	TRNE	F,FR.KIX	;SEE IF KI-10
	MOVEI	A,0		;KI SWAP PDB--CLEAR POINTER
SYSD03:	MOVEM	A,PDBPTR	;AND SAVE FOR SPYING
	MOVE	A,XSYSSZ	;HOW MUCH TO ASK FOR IN SPY
	PUSHJ	P,GETA
	MOVEI	A,-1(A)
	CAILE	A,377777	;MORE THAN 17 BITS WORTH?
	MOVEI	A,377777	;YES, REDUCE TO THE MAX
	MOVEM	A,SPYSIZ	;REMEMBER HOW MUCH EXEC VIRTUAL WE HAVE
	SPY	A,		;ASK FOR IT
	 JRST	SYSD04		;CAN'T HAVE IT
	TLOA	F,FL.SPY	;GOT IT. REMEMBER IT
SYSD04:	SETZM	SPYSIZ		;NO SPYING THIS TIME
	HRRZ	A,GTTSLF	;GET A NON ZERO LOCATION
	PUSHJ	P,MPEEK		;PEEK OR SPY
	SKIPE	A		;  0, PEEK FAILED
	TLO	F,FL.PEK	;  ELSE SHOW PEEK WORKS

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

START:	PUSHJ	P,IJBDAT	;READ SYSTEM PARAMETERS
	SKIPN	TTYFLG		;CAN WE GET TTY DATA
	TLNE	F,FL.PEK!FL.SPY	;SPYING OR PEEKING POSSIBLE?
	JRST	START0		;YES THEN NO SURPRISES
	MOVEI	A,NOSPPK	;NO SPY OR PEEK WARNING
	MOVEM	A,PROGRM	;SET THE PROGROM WORD
START0:	MOVEI	A,CCINT		;SETUP ^C INTERCEPT
	MOVEM	A,.JBINT	; TO RELEASE /V MODE
	SETZM	CCIOPC		;  CLEAR OLD PC ON RESTART
;(START OF EDIT 1 PART 1)
	IFE	V.DISP-V.DVBX,<
	MOVEI	A,1		;PREPARE TO LOCK LOW SEGMENT
	LOCK	A,		;TRY TO LOCK
	JRST	[OUTSTR	[ASCIZ	/?LOCK FAILED
/]
		EXIT]
>	;END OF IFE V.DISP-V.DVBX	(END OF EDIT 1 PART1)
;	LOOP HERE TO REFRESH ENTIRE SCREEN

SYSTT0:	TLNN	F,FL.GOD	;SEE IF GOD
	TRNE	F,FR.NRM	;DO NOT GO TO ALTMOD WHEN
	SKIPA			;EITHER GODLY OR GETTING NORMAL
	TRO	F,FR.ALT	;NO--TIME TO STOP AUTO UPDATES
SYSTT1:	TLO	F,FL.REF	;SHOW FULL-REFRESH PASS
	MOVE	A,[XWD 240240,240240]
	MOVEM	A,DBUF
	MOVE	A,[XWD DBUF,DBUF+1]
	BLT	A,DBFEND
	PUSHJ	P,CLEAR		;CLEAR SCREEN AT FIRST
	MOVNI	A,REPRAT
	MOVEM	A,REPS
IFN	V.DISP-V.DVBX,<
	PUSHJ	P,HOME
	PUSHJ	P,FRCOUT	;FORCE OUTPUT
> ;END OF IFN V.DISP-V.DVBX
IFE	V.DISP-V.DHZL, <
	PUSHJ	P,HOME		;PUT OUT A SECOND HOME FOR HAZELTINE
> ;END OF IFE V.DISP-V.DHZL

;	LOOP HERE TO UPDATE SCREEN

REENT:	IFN	V.DISP-V.DVBX,<
	PUSHJ	P,HOME
	PUSHJ	P,FRCOUT	;FORCE OUTPUT
> ;END OF IFN V.DISP-V.DVBX
	TDZ	F,[-1-FX.MSK]	;CLEAR MOST FLAGS
IFE	<V.DISP-V.DV61>*<V.DISP-V.ANSI>,<   ;IF SYSV61 OR SYSANS
	TLNN	F,FL.REF	;REFRESH PASS?
	TRZN	F,FR.RVR	;NO - TIME TO RETURN TO REVERSE VIDEO?
	CAIA			;LEAVE VIDEO ALONE
	PUSHJ	P,RVIDEO	;NEED TO RESTORE REVERSE VIDEO AFTER REFRESH
> ;END OF IFE V.DISP-V.DV61 OR SYSANS
REENT0:	SETOM	NLTYPD		;FLAG SOMETHING TYPED
	CALL	@PROGRM		;GO TO CURRENT DISPLAY PROGRAM
	SKIPN	NLTYPD		;ANYTHING TYPED
	JRST	REENT0		;NO GET NEXT PAGE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;HERE AT END OF SCREEN CONSTRUCTION TO OUTPUT SCREEN AND DO OVERHEAD

FINIS:	FIN			;COMPLETE SCREEN
	TLCN	F,FL.FLS	;COMPLEMENT FLASHER
	TLNN	F,FL.HLP	;SEE IF HELP ADVISED
	JRST	FINISH		;NO-SKIP ADVISORY
	SET	55,XSIZE+1,YSIZE,YSIZE+1,0,TAB0
	MOVEI	M,[ASCIZ / Type H for Help/]
	PUSHJ	P,MSG
FINISH:	TLNE	F,FL.LOG	;LOGGING SCREENS?
	PUSHJ	P,LISCR		;YES, LIST THIS SCREEN

IFE	<V.DISP-V.ANSI>*<V.DISP-V.DV5A>*<V.DISP-V.DV5B>*<V.DISP-V.DV61>*<V.DISP-V.DV52>,<
	TLNN	F,FL.REF	;SEE IF REFRESH CYCLE
	JRST	FINISQ		;NO--USE DIRECT CURSOR ADDRESSING
				;YES--DO IT THE LONG WAY
> ;END OF IFE <V.DISP-V.ANSI>*<V.DISP-V.DV5A>*<V.DISP-V.DV5B>*<V.DISP-V.DV61>*<V.DISP-V.DV52>
IFE	<V.DISP-V.ANSI>*<V.DISP-V.DVT6>*<V.DISP-V.DV5A>*<V.DISP-V.DV5B>*<V.DISP-V.DV61>*<V.DISP-V.DV50>*<V.DISP-V.DV52>,<
;	BUFFER DUMP ROUTINE FOR INCREMENTAL POSITIONING DISPLAYS (VT06)

	MOVE	BP,[POINT 9,DBUF]
	PUSHJ	P,HOME
	SETZB	C,D		;CURRENT CURSOR POS
	SETZM	LINE
FIN5:	SETZM	COL
	TLZ	F,FL.EOL

FIN4:	PUSHJ	P,GETCH
	CAIN	T2,400!" "	;TEST FOR BLANK CHANGED TO BLANK
	MOVEI	T2," "		;  YES, CONVERT TO NORMAL BLANK
	TRNE	T2,400		;TEST FOR *SOMETHING* CHANGE TO BLANK
	MOVEI	T2,200!" "	;  YES, SHOW IT AS SUCH
	MOVE	CH,T2
	TRZN	CH,200		;NEW?
	TLNE	F,FL.EOL	;OR CONSIDERING BLANK LINE?
	PUSHJ	P,FINR		;YES
	AOS	T1,COL		;COUNT COLUMNS
	CAIGE	T1,XSIZE	;DONE LINE?
	JRST	FIN4

FIN3B:	TLNN	F,FL.EOL	;CLEAR LINE IN ORDER?
	JRST	FIN6		;NO
	MOVX	CH,EREOL	;END OF LINE
	PUSHJ	P,DPYOUT
IFE	<V.DISP-V.DV5B>*<V.DISP-V.DVT6>,<
	PUSHJ	P,FILLIT	;ADD FILLERS
> ;END OF IFE <V.DISP-V.DV5B>*<V.DISP-V.DVT6>

FIN6:	AOS	T1,LINE
	CAIGE	T1,YSIZE	;DONE WITH LAST LINE?
	JRST	FIN5		;NO
	JRST	FINSLP
>;	END OF	IFE V.DISP-V.DVT6/DV51/DV5B/DV61/DV50/DV52/ANSI
IFE	<V.DISP-V.ANSI>*<V.DISP-V.DV5A>*<V.DISP-V.DV5B>*<V.DISP-V.DV61>*<V.DISP-V.DV52>*<V.DISP-V.DHZL>*<V.DISP-V.DDLT>,<
;
;	BUFFER DUMP ROUTINE FOR ABSOLUTE POSITIONING DISPLAYS
;		(HAZELTINE 2000, DELTA DATA TELTERM, VT05)

FINISQ:	SETZB	XCUR,YCUR
	MOVSI	J,-<XSIZE*YSIZE-1> ;GET # OF CHARACTERS, -1
	MOVE	BP,[POINT 9,DBUF]
FINIS0:	ILDB	T2,BP
	CAIN	T2,400!" "	;TEST FOR BLANK CHANGED TO BLANK
	JRST	[MOVEI CH," "	;  YES, GET 'NORMAL' BLANK
		 DPB   CH,BP	;CLEAR BIT IN CHAR BUFFER
		 JRST  FINIS1]	;  & CONTINUE
	TRNE	T2,400		;TEST FOR *SOMETHING* CHANGED TO BLANK
	MOVEI	T2,200!" "	;  YES, CONVERT TO CHANGED BLANK
	TRZN	T2,200
FINIS1:	AOBJN	J,FINIS0
	JUMPGE	J,FINSLP
	DPB	T2,BP
	HRRZ	C,J
	IDIVI	C,XSIZE
	EXCH	C,D
IFE	V.DISP-V.DDLT, <
	CAIN	T2," "		;TEST FOR DELTA-DATA BLANK
	PUSHJ	P,DPYSPC	;  YES, GO LOOK FOR SPECIAL HANDLING
> ;END OF IFE V.DISP-V.DDLT
	CAIE	D,(YCUR)
	PUSHJ	P,DPYPOS
	CAIE	C,(XCUR)
	PUSHJ	P,DPYX
	MOVEI	CH,(T2)
	PUSHJ	P,DPYOUT
IFE V.DISP-V.DDLT, <
	CAIE	T2,23		;TEST FOR DELTA-DATA "CLEAR LINE"
	JRST	FINIS2		;  NO, JUMP
	SOS	XCUR		;BACK UP X-POSITION FOR NO-UPDATE
	MOVE	D,LASTCR(YCUR)	;GET LAST CHARACTER WRITTEN ON SCREEN
	MOVEM	XCUR,LASTCR(YCUR) ;  & UPDATE TO NEW POSITION
	SUB	D,XCUR		;  MINUS WHERE LAST CHARACTER WILL BE
	MOVMS	D		;GET MAGNITUDE OF CURSOR MOVEMENT
	ASH	D,-1		;  DIVIDE BY 2
	PUSHJ	P,DPYFIL	;PUT OUT A FILL CHARACTER
	SOJG	D,.-1		;REPEAT AS NECESSARY
FINIS2:	CAIGE	XCUR,XSIZE-1	;TEST FOR END OF DELTA-DATA LINE
	AOJA	XCUR,FINIS3	;  NO, UPDATE X-POSITION & JUMP
	MOVEM	XCUR,LASTCR(YCUR) ;SHOW CURRENT LAST-CHARACTER
	SETZ	XCUR,		;SHOW AT LEFT SIDE OF NEXT LINE
	AOJA	YCUR,FINIS1	;  NO, UPDATE Y-POSITION & REPEAT
FINIS3:	CAMLE	XCUR,LASTCR(YCUR) ;TEST FOR HIGHER VALUE
	MOVEM	XCUR,LASTCR(YCUR) ;  YES, UPDATE L/C POSITION
	JRST	FINIS1			;  & REPEAT
>;	END OF	IFE V.DISP-V.DDLT
IFN V.DISP-V.DDLT, <
	AOJA	XCUR,FINIS1	;UPDATE POSITION & REPEAT
>;	END OF	IFN V.DISP-V.DDLT
>;	END OF  <V.DISP-V.DV5A>*<V.DISP-V.DV5B>*<V.DISP-V.DHZL>*<V.DISP-V.DDLT>
IFE V.DISP-V.DVBX, <
	MOVE	A,[353535,,353535]
	MOVE	B,DISBES	;CLOBBER OLD JUMP
	MOVEM	A,(B)
	MOVEM	A,1(B)
	MOVE	A,[POINT 9,DBUF]	;POINT AT TEMP AREA
	MOVE	B,[POINT 6,DISBUF]	;POINT AT DISPLAY BUFFER
	MOVEI	J,YSIZE		;LINE COUNTER
DLP1:	MOVEI	JS,XSIZE	;COL. COUNTER
DLP2:	ILDB	CH,A		;GET NEXT CHARACTER
	TRZE	CH,400		;CLEAR BLANK CODE
	MOVEI	CH," "		;CONVERT TO SPACE
	ANDI	CH,177		;MASK TO ASCII
	CAIGE	CH,40		;SEE IF CONTROL
	JRST	DCNTRL		;YES--GO HANDLE
	CAIGE	CH,100		;SEE IF ALPHA
	JRST	DOK		;NO--MUST BE OK
	CAILE	CH,132		;SEE IF ALPHA
	JRST	DCNTRL		;NO--HANDLE
	SUBI	CH,100		;YES--CONVERT TO DISPLAY CODE
DOK:	PUSHJ	P,DSTORE	;STORE IN DISPLAY VECTOR
	SOJG	JS,DLP2		;LOOP ACROSS LINE
	MOVEI	CH,34		;STORE NEW-LINE
	PUSHJ	P,DSTORE	;  SEQUENCE
	MOVEI	CH,33		;  ..
	PUSHJ	P,DSTORE	;  ..
	SOJG	J,DLP1		;LOOP FOR ALL LINES
	MOVEI	CH,40		;GET A BLANK
DLP3:	HLRZ	C,B		;SEE IF AT MIDDLE OF WORD
	CAIN	C,300600	; ..
	JRST	DDONE		;YES--PROCEED
	IDPB	CH,B		;NO--STUFF A BLANK
	JRST	DLP3		;LOOP UNTIL DONE
DDONE:	MOVEI	CH,37		;STORE ESCAPE
	IDPB	CH,B		;  CODE
	MOVEI	CH,160000	;ESCAPE TO MODE 7
	HRRM	CH,(B)		; ..
	MOVEI	CH,DISPLA	;JUMP TO START
	MOVEM	CH,1(B)		; ..
	HRRZM	B,DISBES	;STORE NEW END LOCATION
	HRLI	B,2(B)		;START DOWN TWO
	MOVE	A,[353535,,353535]
	MOVEM	A,2(B)		;CLEAR REST OF BUFFER
	ADDI	B,3		;COMPLETE BLT POINTER
	BLT	B,DISBEN-1	;CLEAR REST OF BUFFER
	TRON	F,FR.DIS	;SEE IF INITIALIZED YET
	OUTPUT	DIS,[DISPLA
		     0]
	JRST	FINSLP		;AND PROCEED
;HERE ON SPECIAL CHARACTER
DCNTRL:	CAIL	CH,140		;SEE IF LOWER
	CAILE	CH,172		;  CASE ALPHA
	JRST	NOTLC		;NO--TRY AGAIN
	SUBI	CH,140		;CONVERT TO DISPLAY CODE
SIO:	PUSH	P,CH		;SAVE CHARACTER
	MOVEI	CH,36		;YES--SWITCH TO L.C.
	PUSHJ	P,DSTORE	; ..
	POP	P,CH		;RESTORE CHARACTER
	PUSHJ	P,DSTORE	;STORE IT
	MOVEI	CH,35		;BACK TO U.C.
	JRST	DOK		;AND STORE THAT
NOTLC:	CAIN	CH,133
	JRST	OBRAK
	CAIN	CH,135
	JRST	CBRAK
	CAIN	CH,136
	JRST	UPARRO
	MOVEI	CH,0		;ELSE GIVE UP
	JRST	DOK		;PRINT INDIRECT
OBRAK:	MOVEI	CH,53		;GET CHAR
	JRST	SIO		;GO STORE AND SHIFT BACK
CBRAK:	MOVEI	CH,54		;GET CHAR
	JRST	SIO		;GO STORE AND SHIFT BACK
UPARRO:	MOVEI	CH,46		;GET CHAR
	JRST	SIO		;GO STORE AND SHIFT BACK

;ROUTINE TO STORE IF ROOM
DSTORE:	HRRZ	T1,B		;GET ADDRESS
	CAIGE	T1,DISBEN-5	;SEE IF NEAR END
	IDPB	CH,B		;NO--STORE
				; AND FALL INTO POPJ P,

HOME:				;ROUTINE TO HOME UP THE SCREEN
CLEAR:				;ROUTINE TO CLEAR THE SCREEN
HOMDWN:				;ROUTINE TO POSITION TO BOTTOM OF SCREEN

	POPJ	P,		;JUST RETURN
>;	END OF IFE V.DISP-V.DVBX
FINSLP:
IFN V.DISP-V.DVBX,<
	PUSHJ	P,HOME		;RETURN TO HOME POSITION
	PUSHJ	P,FRCOUT	;FORCE OUTPUT
	TLZE	F,FL.REF	;TEST FOR REFRESH PASS
	JRST	HIBER0		;GO RIGHT NOW
>;	END OF IFN V.DISP-V.DVBX
	TLNN	F,FL.LOCK	;SEE IF /V MODE
	JRST	FINSL0		;NOT V MODE
	AOSL	RELCKC		;COUNT TO AUTO UNLOCK
	CALL	UNLOCK		;UNLOCK JOB
FINSL0:	CALL	GETOPR		;GET DATA FROM OPR
	SKIPA			;NO DATA THERE
	PJRST	FINX		;PROCESS OPERATOR REQUEST
	SKIPG	J,HIBTIM	;GET WAIT TIME
	MOVEI	J,INTVAL*^D1000	;NONE, USE DEFAULT
	TLO	J,(HB.RTL!HB.RTC)  ;WAKE UP ON TTY ACTIVITY
	HIBER	J,
	 PUSHJ	P,[ANDI	J,-1	;HIBER FAILED, MS TO SLEEP
		IDIVI	J,^D1000;SECONDS TO SLEEP
		SLEEP	J,	;SLEEP
		POPJ	P,]	;DO NORMAL STUFF
HIBER0:	MOVEI	J,"N"		;NORMAL TO GO NOW?
	TRNE	F,FR.NRM	;IF SO DESIRED
	JRST	FINX		;DO AS IF N WAS TYPED
	PJRST	FINOPR		;FINISH ANY REQUESTS
;FINOPR IS USED TO PROCES ALL THE OPERATOR CHARACTERS
;THIS CODE EXITS TO REENT OR SYSTT0

FINOPR:	CALL	GETOPR		;SEE IF ANY INPUT
	SKIPA			;(NO) DO EXIT LOGIC
	JRST	FINX		;PROCESS CHARACTER
	TRNN	F,FR.ALT	;STARTING TO WAIT
	JRST	FINOP0		;NOPE STILL BUSY
FREEZE:	INCHRW	J		;WAIT FOR INPUT
	JRST	FINX		;HERE TO GO AFTER WE GOT CHAR
FINOP0:	TLNE	F,FL.REF	;REFRESH WISHED
	JRST	SYSTT1		;YES DO IT
	TLNE	F,FL.GOD	;SEE IF GOD
	TLNN	F,FL.LOCK	;SEE IF LOCKED
	AOSGE	REPS
	JRST	REENT
	JRST	SYSTT0

;FINX IS ENTERED WITH A COMMAND CHARACTER IN J

FINX:	TRZ	F,FR.ALT	;UNFREEZE THE SCREEN
	CAIL	J,"A"+40	;SEE IF LOWER CASE
	CAILE	J,"Z"+40	; ALPHABETIC
	SKIPA			;NO LEAVE ALONE
	SUBI	J,40		;YES--CONVERT TO UPPER CASE
	MOVSI	A,-CHRN		;SEARCH CONTROL CHARACTER TABLE
FINXCL:	HLRZ	B,CHRTAB(A)	;GET NEXT CANDIDATE
	CAIE	B,(J)		;SEE IF MATCH
	CAIN	B,PRGFLG(J)	;OR MATCH ON PROGRAM
	JRST	FINXCX		;YES--GO HANDLE
	AOBJN	A,FINXCL	;NO--TRY NEXT
				;NOT IN TABLE--

;HERE FOR SPECIAL PROCESSING OF A DIGIT

	CAIL	J,"0"		;CHECK THE RANGE
	CAILE	J,"9"		; 0-9
	JRST	FINXC1		;NO
	SUBI	J,"0"		;CONVERT TO DECADE DIGIT
	EXCH	J,NUMBER	;GET ACCUMULATED NUMBER SO FAR
	IMULI	J,^D10		;SHIFT OVER A DECADE
	ADDB	J,NUMBER	;MAKE NEW NUMBER
	AOS	NUMFLG		;NOTE EXPLICIT NUMBER TYPED IN
	JRST	FINOPR		;KEEP GOING
FINXC1:	CAIL	J,40		;SKIP IF NOT CONTROL
	TLO	F,FL.HLP	;NOT FOUND--SET HELP MESSAGE FLAG
	JRST	FINOPR		;AND TRY NEXT ONE
FINXCX:	TLZ	F,FL.HLP	;CLEAR HELP NEEDED FLAG
	SKIPGE	B,CHRTAB(A)	;GET PROGRAM ADDRESS OR SUBROUTINE
	JRST	FINXC0		;ONLY SET DISPLAY ADDRESS
	CALL	(B)		;DO ACTION CODE
	SETZM	NUMBER		;RESET COMMAND NUMBER PREFIX
	SETZM	NUMFLG		;AND NUMBER TYPED FLAG
	PJRST	FINOPR		;GET ANOTHER COMMAND
FINXC0:	PUSHJ	P,REFRSH	;GET A FRESH SCREEN
	SETZM	FIRJOB		;ALWAYS START AT THE END
FINXC9:	HRRM	B,PROGRM	;STORE FINAL DISPLAY ADDRESS
	JRST	FINOPR		;AND SEE WHAT MORE IN STORE

;GETOPR GET A CHARACTER IN J IF THERE IS ANY TYPED
;BY THE OPERATOR. RETURN A CONTROL C CHARACTER
;IF CCIOPC IS .NEQ. 0

GETOPR:	SKIPN	CCIOPC		;DO NOT LOSE CHARACTER
LOSER:	INCHRS	J		;GET ONE IF ANY
	SKIPE	CCIOPC		;NO CHARACTER AND NO ^C
SETCNC:	AOSA	(P)		;PREPARE THE SKIP RETURN
	RETURN			;NORMAL RETURN NOTHING THERE
	SKIPE	CCIOPC		;A NORMAL CHARACTER?
	MOVEI	J,.CHCNC	;NO GET CONTROL C
	RETURN


;NDECW  --  INPUT A DECIMAL NUMBER FROM OPERATOR
;
;RETURNS NUMBER IN AC N; COUNT OF DIGITS TYPED IN AC N1

NDECW:	SETZB	N,N1		;INITIALIZE COUNTS
NDECW0:	INCHWL	CH		;READ IN A CHARACTER
	CAIL	CH,"0"		;VALID DECIMAL DIGIT?
	CAILE	CH,"9"		;. . .
	 POPJ	P,		;NOPE, ALL DONE
	IMULI	N,^D10		;YES, NEXT DECADE
	ADDI	N,-"0"(CH)	;ADD IN THIS DECADE
	AOJA	N1,NDECW0	;AND COUNT DIGITS
;TABLE FOR ACTION CHARACTER DISPATCH

PRGFLG==400000		;SIGN BIT FLAGS THIS IS A DISPLAY PROGRAM

	DEFINE	DISPLAY(A,B)<
	PRGFLG+A,,B>

CHRTAB:	XWD	" ",CPOPJ	;UPDATE SCREEN IMMEDIATELY
	XWD	"-",DWNJOB	;BACK UP JOBS BY 20.
	XWD	"+",UPJOB	;MOVE UP JOBS BY 20.
	XWD	.CHCNC,ALLDON	;IF ^C, GO EXIT
	XWD	.CHCNZ,ALLDON	;IF ^Z, GO EXIT
	XWD	.CHESC,ALTMOD	;ALTMOD, FREEZE THE SCREEN
	XWD	"V",STLOCK	;TOGGLE LOCK/UNLOCK HPQ 0/1 STATUS
	XWD	"R",REFRSH	;IMMEDIATE REFRESH ON THE SCREEN
	XWD	"W",WAITIM	;READ WAIT TIME
	XWD	"I",TGLINC	;TOGGLE INCREMENTAL STATISTICS
	XWD	"A",ALTJOB	;AUTO ROLL JOBS
	XWD	"L",LOGSCR	;SCREEN LOGGING
	XWD	"S",TGLSJB	;TOGGLE SYSTEM OR EXPANDED JOBS IN "N"
	XWD	"O",TGLOPR	;TOGGLE [OPR] SUPPRESSION
	XWD	"!",TGLIDL	;TOGGLE NON-IDLE JOBS
	XWD	"#",TGLTTY	;TOGGLE TTY OUTPUT FLAG
	XWD	"%",TGLPCT	;TOGGLE RUNTIME OR PERCENTAGE
	XWD	"^",TGLSKP	;TOGGLE SKIP/ADVANCE OF SYSTEM IN "N"

IFE <V.DISP-V.DV61>,<
	XWD	.CHCNR,RVIDEO
	XWD	.CHCNA,ALARM
>
IFE <V.DISP-V.ANSI>,<		;
	XWD	.CHCNR,RVIDEO	;
>				;
IF2,<
IFNDEF DEVPRG,<DEVPRG=FILPRG>
IFNDEF MEMPRG,<MEMPRG=NORMAL>
>

;TABLE FOR SCREEN SELECTOR
	DISPLAY	"N",NORMAL	;NORMAL DISPLAY
	DISPLAY	"F",FILPRG	;FILE SYSTEM DISPLAY
	DISPLAY	"D",DEVPRG	;DEVICES DISPLAY
	DISPLAY	"J",JOBPRG	;JOBS
	DISPLAY	"M",MEMPRG	;MEMORY AND SWAPPER
	DISPLAY	"H",HELP	;HELP TEXT
IFN FTNET,<
	DISPLAY "C",DCNSTA	; List DECNET LINK Status
	DISPLAY	"*",DCNNOD	; Node Status
	DISPLAY "T",NETPRG	;DISPLAY THE NETWORK TOPOLOGY
	DISPLAY	"\",NETSTT	;DISPLAY THE NETWORK STATISTICS
	DISPLAY "E",ETHDPY	;ETHERNET DISPLAY
	DISPLAY "Z",LATDPY	;LAT SERVER DISPLAY
>
	DISPLAY	"K",CISTAT	;DISPLAY CI STATISTICS
	DISPLAY	"Q",QUEPRG	;DISPLAY THE QUEUES
CHRN==.-CHRTAB
;HERE WHEN USER TYPES +, TO ADVANCE JOBS BY 20.

UPJOB:	SKIPG	A,NUMBER	;USER GIVE EXPLICIT SKIP VALUE?
	MOVEI	A,UPDNJB	;NO, USE DEFAULT INCREMENT
	TRNE	F,FR.VMM	;VM TYPE OF DISPLAY
	SUBI	A,2		;IN THAT CASE 2 LINES ARE LOST
	ADDM	A,FIRJOB	;ADVANCE
	JRST	MOVJOB		;GO TO COMMON ROUTINE

;HERE WHEN USER TYPES -, TO BACK UP JOBS BY 20.

DWNJOB:	SKIPG	A,NUMBER	;USER GIVE EXPLICIT SKIP VALUE?
	MOVEI	A,UPDNJB	;NO, USE DEFAULT INCREMENT
	MOVN	A,A		;AND MAKE IT A DECREMENT
	TRNE	F,FR.VMM	;VM DISPLAY ON
	ADDI	A,2		;THEN TWO LESS
	ADDM	A,FIRJOB	;RETARD
	SKIPGE	FIRJOB		;SEE IF TOO FAR
	SETZM	FIRJOB		;YES--SET TO START
MOVJOB:	SETZM	.FRAJR		;CLEAR AUTO ROLL FEATURE
	HRRZ	A,PROGRM	;GET DISPLAY PROGRAM
	CAIL	A,MEMPRG	;IF DISPLAY IS
	CAILE	A,NORMAL	;NOT J/M/N
	POPJ	P,		;THEN NO JOB LIMIT CHECK (E.G., H DISPLAY)
	MOVE	A,XHGHJB	;GET GETTAB PARM FOR HIGHEST ACTIVE JOB
	PUSHJ	P,GETZ		;GO TRY TO READ IT FROM SYSTEM
	SKIPN	A		;  GOT IT, SKIP
	MOVE	A,JOBN		;  ERROR, GET HIGHEST JOB NUMBER
	SUB	A,FIRJOB	;MINUS FIRST JOB TO BE DISPLAYED
	SUBI	A,UPDNJB-1	;MINUS # OF JOBS DISPLAYED, MINUS 1
	SKIPGE	A		;SKIP IF JOBS FOR ENTIRE SCREEN
	ADDM	A,FIRJOB	;  ELSE BACK FIRST JOB # DOWN
	SKIPGE	FIRJOB		;TEST FOR TOO FAR BACK
	SETZM	FIRJOB		;  YES, LEAVE IT AT ZERO
	RETURN
;HERE WHEN A TYPED TO FLAG FOR AUTO JOB ROLL
;EACH PASS WILL ADVANCE TO NEXT PAGE OF JOBS UNTIL DONE
;THEN START OVER WITH 1.  STOP MODE WITH A, +, -.

ALTJOB:	SETCMM	.FRAJR		;TOGGLE ROLL FLAG
	RETURN


;HERE WHEN USER TYPES #, TO TOGGLE FLAG WHICH DETERMINES
;WHETHER TTYS DISPLAY FOR OPERATORS OR FOR CLEMENTS

TGLTTY:	SETCMM	REALTT		;TOGGLE FLAG
	RETURN


;TOGGLE SUPPRESSION OF [OPR] JOBS

TGLOPR:	TRC	F,FR.OPR	;TOGGLE [OPR] SUPPRESSION FLAG
	POPJ	P,		;RETURN


;TOGGLE WHETHER J/M/N DISPLAY RUNTIME OR PERCENTAGE

TGLPCT:	TRC	F,FR.PCT	;TOGGLE PERCENTAGE FLAG
	POPJ	P,		;THAT'S THAT.


;TOGGLE WHETHER EXPANDED JOB (USER NAME, DISK READS/WRITES) OR
;USUAL SYSTEM DISPLAY IN "N" DISPLAY

TGLSJB:	TRC	F,FR.SJB	;TOGGLE SYSTEM/JOB FLAG
	PJRST	REFRSH		;AND MARK A REFRESH NEEDED


;TOGGLE WHETHER TO SKIP THE FIRST PART OF THE SYSTEM STATISTICS IN THE "N"
;DISPLAY (I.E., GO DIRECTLY TO STR/MNFT/FREE AND DEV/BY/HOW DISPLAYS
;TOGGLE WHETHER TO SKIP "NON-VALID" DELAY LINKS IN DECNET DISPLAY

TGLSKP:	TRC	F,FR.SKP	;TOGGLE THE "SKIP" FLAG
	POPJ	P,		;AND CONTINUE


;TOGGLE SUPPRESSION OF IDLE JOBS/ETC

TGLIDL:	SKIPE	A,NUMFLG	;[610] WAS NUMBER TYPED?
	MOVE	A,NUMBER	;[610] YES, USE IT FOR THRESHOLD VALUE
	IMUL	A,TCKSEC	;[610] CONVERT JIFFIES TO SECONDS
	IDIVI	A,^D100		;[610]  AND THEN TO 1/100 SECONDS
	MOVEM	A,TRSHLD	;[610] SAVE THRESHOLD VALUE
	SKIPN	A		;[610] WAS NUMBER GIVEN?
	TRC	F,FR.IDL	;[610] NO, JUST TOGGLE
	SKIPE	A		;[610] ELSE, IF NUMBER WAS GIVEN
	TRO	F,FR.IDL	;[610] SET "!"
	POPJ	P,		;[610]
;HERE WHEN ^C INTERCEPT

CCTYPD:	PUSH	P,A		;SAVE AN AC
	HRRZ	A,CCIOPC	;GET PC IN QUESTION
	CAIE	A,LOSER		;GOING TO LOOSE A CHARACTER
	CAIN	A,FREEZE	;SEE IF HUNG ON AN ALTMODE
CCTYPC:	MOVEI	A,FINX		;YES--GO LOOK AT INPUT
	HRRM	A,CCIOPC	;SAVE NEW OR OLD PC
	POP	P,A		;RESTORE THE AC
	JRSTF	@CCIOPC		;JUST RETURN AND CATCH IN MAIN
				;LOOP.  DON'T CLEAR IN CASE OF LOOP.


;HERE WHEN USER TYPES ^C OR ^Z, TO EXIT TO MONITOR

ALLDON:	IFE	V.DISP-V.DV61,<	;IF VT61
	TRNE	F,FR.RVD	;IN REVERSE VIDEO?
	PUSHJ	P,RVIDEO	;YES, CLEAR IT (EXIT WITH NORMAL VIDEO)
	TRNE	F,FR.ALR	;IN "ALARM"ING MODE?
	PUSHJ	P,ALARM		;YES, CLEAR IT
> ;END OF IFE V.DISP-V.DV61
IFE V.DISP-V.ANSI,<		;IF VT100
	TRNE	F,FR.RVD	;IN REVERSE VIDEO?
	PUSHJ	P,RVIDEO	;YES, CLEAR IT (EXIT WITH NORMAL VIDEO)
> ;END OF IFE V.DISP-V.ANSI
	PUSHJ	P,HOMDWN	;HOME DOWN SCREEN
	TLNE	F,FL.LOG	;LOGGING SCREENS?
	CLOSE	LOG,		;YES, CLOSE OFF FILE
	TLZE	F,FL.LOG	;LOGGING SCREENS?
	RELEAS	LOG,		;YES, LEGGO OF LOG DEVICE
	RESET			;  & RESET EVERYTHING ELSE, TOO
ALLDNE:	MOVN	J,MYJOB		;GET NEGATIVE OF CURRENT JOB #
	JOBSTS	J,		;FIND OUT ABOUT ME
	  MOVEI	J,0		;  ERROR, SET FLAGS TO ZERO
	TXNE	J,JB.ULI	;TEST FOR LOGGED IN
	JRST	DOEXIT		;  YES, GO EXIT
	SKIPE	J		;(SKIP MSG IF NO JOBSTS UUO)
	OUTSTR	KJMSG		;GIVE A 'KJOB' & A LOGOUT
	LOGOUT			;  DITTO
KJMSG:	ASCII	/.KJOB/		;MESSAGE FOR END OF PROGRAM
	BYTE	(7) 15, 12, ".", 0, 0 ;  DITTO
DOEXIT:	EXIT	1,		;RETURN TO MONITOR, WITH .CONT PRIVILEGES
	TLZ	F,FL.LOCK	;CLEAR LOCK (RESET DID IT)
	PUSHJ	P,OPNTTY	;RE-OPEN TTY CHANNEL
	JRST	START		;     NOW START FROM THE TOP
ALTMOD:	TRC	F,FR.ALT	;YES--SET FLAG
	RETURN			;FLAG JUST CLEARED OR SET

STLOCK:	MOVX	J,LK.LLS!LK.LNE!LK.LNP!LK.LLC  ;MINIMUM-OVERHEAD LOCK FLAGS
	TLCE	F,FL.LOCK	;TEST FOR LOCKED NOW
	JRST	UNLOCK		;  YES, GO RESET & UNLOCK
IFN V.DISP-V.DVBX,<
	LOCK	J,		;ATTEMPT TO LOCK US
	  JFCL			;  FAILED
>;	END OF IFN V.DISP-V.DVBX
	HRROI	A,.GTRTD	;REAL TIME WORD
	PUSHJ	P,GETZ		;GO GET IT
	LDB	A,[POINTR A,JR$HPC]  ;USER LEVEL SET HPQ COMMAND
	MOVEM	A,HPQCMD	;REMEMBER IT
	MOVEI	A,1		;GET FLAGS FOR HPQ #1
	SKIPN	HPQCMD		;IN NOT ALREADY IN HPQ,
	HPQ	A,		;GET IN A HPQ (MAYBE)
	  JFCL			;       & IGNORE FAILURES
	MOVNI	A,RELOCK	;SET FOR AUTO UNLOCK
	MOVEM	A,RELCKC	; IN CASE OPER FORGETS
	SKIPN	A,HIBTIW	;GET OPERATOR-SPECIFIED WAIT TIME
	MOVEI	A,^D1000	;NONE, USE DEFAULT (SHORT)
	MOVEM	A,HIBTIM	;SET WAIT TIME
	RETURN

UNLOCK:	TLZ	F,FL.LOC	;WE ARE UNCONDITIONALLY UNLOCKED NOW!
IFN V.DISP-V.DVBX,<
	UNLOK.	J,		;ATTEMPT TO UNLOCK MYSELF
	  JRST	SYSDPY		;  FAILED, DO IT VIA 'RESET'
>;	END OF IFN V.DISP-V.DVBX
	MOVEI	A,0		;GET FLAGS FOR HPQ #0
	SKIPN	HPQCMD		;IF NOT SET HPQ COMMAND
	HPQ	A,		;REQUEST NORMAL CPU PRIORITY
	  JFCL			;  IGNORE ERROR RETURN
	MOVE	A,HIBTIW	;GET OPERATOR-SPECIFIED WAIT TIME
	MOVEM	A,HIBTIM	;AND RESET WAIT TIME
	RETURN

TGLINC:	TLC	F,FL.INC	;TOGGLE INCREMENTAL FLAG
	POPJ	P,		;THAT'S THAT
REFRSH:	TLO	F,FL.REF	;FORCE A REFRESH
IFN	<V.DISP-V.ANSI>*<V.DISP-V.DV61>,<POPJ P,> ;IF NOT VT61 JUST RETURN, ELSE
IFE	<V.DISP-V.ANSI>*<V.DISP-V.DV61>,< ;CHECK FOR REVERSE VIDEO
	TRNN	F,FR.RVD	;IN REVERSE VIDEO?
	POPJ	P,		;NO, JUST RETURN TO REFRESH
	TRO	F,FR.RVR	;YES, RESTORE IT LATER
	JRST	RVIDEO		;AND CANCEL IT FOR REFRESH
> ;END OF IFE V.DISP-V.DV61 OR V.ANSI


;WAITIM  --  SET WAIT TIME BETWEEN SCREEN UPDATES

WAITIM:	MOVE	N,NUMBER	;PICK UP COMMAND ARGUMENT
	CAILE	N,^D60		;MAX OF (APPROX) ONE MINUTE
	MOVEI	N,^D60		;SET MAX
	IMULI	N,^D1000	;CONVERT TO MILLISECONDS
	CAIG	N,0		;IF USER TYPED EXPLICIT 0
	MOVEI	N,1		;THEN MAKE INTO ONE TICK (NOT INFINITY)
	SKIPN	NUMFLG		;BY THE WAY, AN EXPLICIT NUMBER WAS TYPED?
	SETZ	N,		;NO, RETURN TO DEFAULT
	MOVEM	N,HIBTIM	;SET WAIT TIME
	MOVEM	N,HIBTIW	;AND REMEMBER OPERATOR GAVE IT
	POPJ	P,		;RETURN WITH NEW WAIT TIME SET
;SCREEN LOGGING COMMAND AND SUPPORT

LOGSCR:	TLNE	F,FL.LOG	;ALREADY LOGGING?
	POPJ	P,		;YES, NOOP
	MOVE	A,[LOGFLP,,FLPBLK]  ;MAKE A COPY OF THE PROTOTYPE
	BLT	A,FLPBLK+FLPLEN-1   ;LOG FILE FILOP. BLOCK
	MOVE	A,[LOGLKE,,LKEBLK]  ;MAKE A COPY OF THE PROTOTYPE
	BLT	A,LKEBLK+LKELEN-1   ;LOG FILE ENTER BLOCK
	MOVE	A,[FLPLEN,,FLPBLK]  ;FILOP. ARG POINTER
	FILOP.	A,		;APPEND SCREEN LOG
	 JRST	NOLOGS		;ERROR, FORGET IT
	TLO	F,FL.LOG	;GOT IT, NOTE WE ARE NOW LOGGING
;	SETOM	LOGSCT		;SUPPRESS LEADING <FF>
	POPJ	P,		;RETURN READY AND WILLING

LOGFLP:	FO.PRV!<LOG,,.FOAPP>	;CHANNEL,,APPEND
	.IOASL			;ASCII MODE
	'DSK   '		;ON DEVICE DSK:
	LOGOHD,,0		;OUTPUT RING HEADER
	0,,0			;DEFAULT NUMBER OF BUFFERS
	0,,LKEBLK		;ADDRESS OF ENTER BLOCK

	FLPLEN==.-LOGFLP

LOGLKE:	3			;LENGTH OF BLOCK
	0			;PATH [-]
	'SYSDPY'		;FILENAME SYSDPY
	'LOG   '		;EXTENSION .LOG

	LKELEN==.-LOGLKE
LISCR:	MOVEI	T2,.CHFFD	;FORMFEED
	PUSHJ	P,LISCH		;TO START THINGS OFF
	SETZB	A,COL		;START AT COLUMN 0
	SETZM	LINE		;IN LINE 0
	MOVEI	B," "		;FOR SPACE FILL

LISCR2:	PUSHJ	P,GETCH		;GET NEXT SCREEN CHARACTER
	TRNE	T2,400		;*SOMETHING* BLANKED OUT?
	MOVEI	T2," "		;YES, LIST AS BLANK THEN
	ANDI	T2,177		;JUST THE CHARACTER
	CAIN	T2," "		;A BLANK?
	AOJA	A,LISCR5	;YES, COUNT UP (MAYBE SUPPRESS)
	JUMPE	A,LISCR4	;OUTPUT CHAR UNLESS SAVED BLANKS
	EXCH	T2,B		;IN WHICH CASE
	PUSHJ	P,LISCH		;LIST BLANKS INSTEAD
	SOJG	A,.-1		;UNTIL CAUGHT UP WITH WHERE SHOULD BE
	EXCH	B,T2		;RETREIVE REAL CHARACTER
LISCR4:	PUSHJ	P,LISCH		;OUTPUT CHARACTER
LISCR5:	AOS	T1,COL		;ADVANCE COLUMN COUNTER
	CAIGE	T1,XSIZE	;UNTIL THIS LINE FINISHED
	JRST	LISCR2		;MORE OF THIS LINE TO GO
	MOVEI	T2,.CHCRT	;A <CR>
	PUSHJ	P,LISCH		;TO END THIS LISTING LINE
	MOVEI	T2,.CHLFD	;AND A <LF>
	PUSHJ	P,LISCH		;TO END THE <CR><LF>
	SETZB	A,COL		;NO BLANKS, START OF LINE
	AOS	T1,LINE		;ADVANCE TO NEXT LINE
	CAIGE	T1,YSIZE	;DONE YET?
	JRST	LISCR2		;NOPE, DO ANOTHER LINE
	POPJ	P,		;YES - SCREEN OUTPUT


LISCH:	SOSGE	LOGOHD+2	;ROOM FOR ANOTHER CHARACTER?
	JRST	LISCH2		;NO, ASK MONITOR FOR NEXT BUFFER
	IDPB	T2,LOGOHD+1	;STUFF THIS CHARACTER
	POPJ	P,		;DONE

LISCH2:	OUTPUT	LOG,		;ASK FOR NEXT BUFFER
	JRST	LISCH		;ASSUME GOT ONE . . .
	SUBTTL	VARIOUS "ERROR" MESSAGES

;SPY OR PEEK PRIVILEGES ARE REQUIRED FOR CERTAIN FUNCTIONS

NOPRIV:
NOSPPK:	SET	1,XSIZE,1,YSIZE,0,TAB4
	MOVEI	M,NOSPTX	;WARNING
	CALL	MSG		;SET UP THE MESSAGE
	JRST	ADVICE		;TELL COMMON EXIT

NOSPTX:	ASCIZ	\You do not have either PEEK or SPY privileges.
\


;"\" COMMAND BUT FTCMSR TURNED OFF IN MONITOR

NOCMSR:	SET	1,XSIZE,1,YSIZE,0,TAB4	;STANDARD (FULL) SCREEN
	MOVEI	M,NOCMTX	;SAY WHY IT FAILS
	PUSHJ	P,MSG		;TELL USER
	PJRST	ADVICE		;COMMON EXIT

NOCMTX:	ASCIZ	\This monitor does not support network statistics.
\


;"K" COMMAND BUT FTSCA TURNED OFF IN MONITOR

NOSCA:	SET	1,XSIZE,1,YSIZE,0,TAB4 ;STANDARD (FULL) SCREEN
	MOVEI	M,NOSCTX	;SAY WHY IT FAILS
	PUSHJ	P,MSG		;TELL USER
	PJRST	ADVICE		;COMMON EXIT

NOSCTX:	ASCIZ	\This monitor does not support Systems Communications Architecture.
\

NOCIP:	SET	1,XSIZE,1,YSIZE,0,TAB4 ;STANDARD (FULL) SCREEN
	MOVEI	M,NOCITX	;SAY WHY IT FAILS
	PUSHJ	P,MSG		;TELL USER
	PJRST	ADVICE		;COMMON EXIT

NOCITX:	ASCIZ	\This monitor does not have any CI-20 interfaces.
\
;"L" COMMAND CAN'T ENTER/APPEND "LOG" FILE

NOLOGS:	SET	1,XSIZE,1,YSIZE,0,TAB4
	MOVEI	M,NOLOTX	;ERROR TEXT
	PUSHJ	P,MSG		;SHOW ON SCREEN
	PJRST	ADVICE		;AND CAP OFF

NOLOTX:	ASCIZ\? Can't create/append log file DSK:SYSDPY.LOG[-]
\



;COMMON ADVICE PRINTER

ADVICE:	MOVEI	M,ADVTXT	;GET ADVICE TEXT ADDRESS
	CALL	MSG		;AND PRINT IT
	TRO	F,FR.NRM	;AND RETURN TO NORMAL
	TRZ	F,FR.ALT	;DO NOT GET STUCK BY $ MODE
	TLZ	F,FL.REF	;WAIT A SECOND
	RETURN

ADVTXT:	ASCIZ	\
This display will be automatically replaced by the normal display.
Type any command to effect immediate replacement.
\
	SUBTTL	"H" -- DISPLAY HELP MESSAGE

HELP:	PUSHJ	P,THISIS	;GIVE HEADER LINE
	PUSHJ	P,CRLF		;BLANK LINE FOR NEATNESS
	TABSET	TAB7		;NORMAL TAB STOPS
	MOVE	A,FIRJOB	;COUNT OF "JOBS" TO SKIP
	MOVEM	A,EATCNT	;SET FOR EMSG
	SKIPN	HLPADR		;ALREADY GOT HELP TEXT?
	JRST	HELP0		;NO, LOOK FOR IT ON DISK
	MOVE	M,HLPADR	;GET HELP TEXT INTO M
	JRST	HELP7		;AND GO TYPE IT OUT

HELP0:	MOVEI	A,.IODMP	;NO, PREPARE TO READ IT IN
	MOVSI	B,'HLP'		;FROM HLP:
	SETZ	C,		;(IN DUMP MODE)
	OPEN	HLP,A		;OPEN HELP DEVICE
	 JRST	HELP6		;HMMMMM . . .

;NOTICE THAT AT THIS POINT PECULIAR AC USEAGE APPEARS
;AC'S 0 TO 6 ARE USED BUT NOT AS M/A/B/C/D/J/JS . . .

	MOVEI	.RBCNT,.RBSIZ	;LENGTH OF LOOKUP BLOCK
	SETZ	.RBPPN,		;DEFAULT PATH
	MOVE	.RBNAM,['SYSDPY']  ;NAME OF HELP FILE
	MOVSI	.RBEXT,'HLP'	;AND ITS EXTENSION
	LOOKUP	HLP,.RBCNT	;SEE IF HLP:SYSDPY.HLP EXISTS
	 JRST	[HRRZ	N,.RBEXT;ERROR CODE
		CAIN	N,ERFNF%;FILE NOT FOUND?
		JRST	HELP6	;YES, USE OUR TEXT
		MOVEI	M,[ASCIZ\? LOOKUP error (\] ;MESSAGE
		PUSHJ	P,MSGOCT;TELL USER OF WOES
		MOVEI	M,[ASCIZ\) for help file HLP:SYSDPY.HLP\]
		JRST	HELP7]	;CAP OFF ERROR
	MOVE	A,.RBSIZ	;GET SIZE OF FILE

;NOW WE RETURN TO MORE RATIONAL AC USAGE . . .

	MOVN	C,A		;FOR IOWD
	MOVE	B,.JBFF		;ADDRESS FOR HELP TEXT
	ADDI	A,1		;GUARANTEE TRAILING <NUL>
	ADDB	A,.JBFF		;ALLOCATE SPACE
	CAMG	A,.JBREL	;HAVE WE ROOM?
	JRST	HELP1		;YES
	CORE	A,		;NO, ASK FOR SOME MORE
	 JRST	[MOVEI	M,[ASCIZ\? Insufficient memory for reading help file text!
\]				;TELL USER OF WOES
		JRST	HELP7]	;GO DISPLAY TEXT
	MOVE	A,.JBFF		;RESTORE AC A FROM CORE UUO

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

HELP1:	MOVS	C,C		;START IOWD
	HRRI	C,-1(B)		;FINISH IOWD
	SETZ	D,		;FINISH COMMAND LIST
	IN	HLP,C		;READ HELP FILE
	SKIPA			;GOT IT
	 JRST	[MOVEI	M,[ASCIZ\? I/O error reading HLP:SYSDPY.HLP
\]				;MORE WOES
		JRST	HELP7]	;GO TELL USER
	MOVEM	B,HLPADR	;SAVE ADDRESS OF HELP TEXT
	RELEAS	HLP,		;DITCH I/O CHANNEL
	SUB	A,B		;GET BACK LENGTH
	SUBI	A,1		;REAL FILE LENGTH
	IMULI	A,5		;COUNT OF 7-BIT ASCII BYTES
	TLO	B,(POINT 7,)	;MAKE INTO BYTE POINTER
	MOVE	C,B		;COPY FOR RE-WRITTING
HELP2:	ILDB	CH,B		;GET CHARACTER
	JUMPE	CH,HELP3	;SKIP OVER NULLS
	IDPB	CH,C		;OK CHARACTER, STORE IT
HELP3:	SOJG	A,HELP2		;LOOP BACK FOR REST OF MESSAGE
	MOVEI	CH,0		;NOW WE WANT A <NUL>
	IDPB	CH,C		;TO TERMINATE HELP TEXT
	MOVE	M,HLPADR	;ADDRESS OF HELP TEXT
	JRST	HELP7		;GO SET TO TYPE IT OUT

HELP6:	MOVEI	M,HLPTXT	;USE OUR OWN MINI-HELP TEXT
HELP7:	PUSHJ	P,EMSG		;LIST ASCIZ TEXT
	PUSHJ	P,CHKDON	;SEE HOW SCREEN FARED
	JRST	HELP		;NOT SO GOOD, TRY AGAIN
	POPJ	P,		;REASONABLY WELL, GO SHOW IT
;AND OUR VERY OWN HELP TEXT

HLPTXT:	ASCIZ	n+	Advance screen by "n" or approximately one screen-full
n-	Retreat screen by "n" or approximately one screen-full
A	Toggle Auto roll of all jobs
C	List DECNET link status
E	List Ethernet status
F	List file system statistics
H	List this text
I	List incremental statistics (where applicable)
J	List only jobs (in multiple columns)
K	List CI network status
L	Log screens into file DSK:SYSDPY.LOG[-] (Close on ^Z)
M	List virtual memory data
N	List normal (some of everything) status
O	Toggle suppression of [OPR] jobs in "N" & "M" display
Q	List the system queues
R	Refresh entire screen immediately
S	Toggle System or expanded job statistics in "N" display
T	Topology for network display
V	Toggle cpu and core priority
Z	List LAT server statistics
nW	Set wait time to "n" decimal seconds
\	Display network statistics
n!	Toggle non-idle jobs; "n" specifies runtime threshold = n/100 seconds
#	Toggle PTY number or controlling job number
%	Toggle runtime or percentage of cpu
^	Toggle skipping system statistics in "N" display
*	List DECNET node status
^A	Toggle alarm (flashing) mode (if applicable)
^C	Terminate SYSDPY execution
^R	Toggle reverse video updating (if applicable)
^Z	Terminate SYSDPY execution
<ESC>	Freeze screen as is (any subsequent command will thaw)
SPACE	Update screen display immediately

	SUBTTL	"N" DISPLAY, SOME OF EVERYTHING

;MEMPRG IS THE START OF THE DISPLAY PROGRAM FOR A VM SYSTEM
;NORMAL IS THE START FOR THE CLASSIC SYSTEM DISPLAY
;THE CONTROL FLOW IS REGULATED BY THE FLAG FR.VMM
;ONCE THIS FLAG HAS BEEN SET BY MEMPRG THEN NORMAL
;CAN DO THE JOB. NOTE: THAT IF THE SYSTEM DOES NOT
;SUPPORT VM THAT THE VM DISPLAY AND NORMAL DISPLAY ARE
;IDENTICAL.

MEMPRG:	TROA	F,FR.VMM	;FLAG EXPANDED MEMORY DISPLAY
				;AND SKIP INTO NORMAL
JOBPRG:	TRO	F,FR.JOB	;FLAG JOBS ONLY
				;AND FALL INTO NORMAL
NORMAL:	PUSHJ	P,STROLL	;START DISPLAY VARIABLES
	SETOM	NLTYPD		;MARK THAT LINES HAVE BEEN TYPED
	TRZ	F,FR.NRM	;ONLY WHEN NORMAL FORGET FLAG
	PUSHJ	P,WNDJOB	;SET JOB WINDOW
	SETZM	JBUBZR		;CLEAR FIRST JOB USAGE WORD
	MOVE	A,[JBUBZR,,JBUBZR+1]  ;BLT POINTER TO
	BLT	A,JBUEZR	;CLEAR ALL JOB USAGE FIGURES
	TRNE	F,FR.VMM	;DOING VM DISPLAY?
	JRST	NORMLA		;YES, DO INCREMENTALS IN ROUTINE THISIZ
	PUSHJ	P,GUPTIM	;GET SYSTEM UPTIME
	SUB	A,UPTIME	;A:= INCREMENTAL UPTIME
	ADDM	A,UPTIME	;UPDATE TOTAL UPTIME
	TLNN	F,FL.INC	;WANT INCREMENTAL OR TOTAL?
	MOVE	A,UPTIME	;TOTAL
	MOVEM	A,UPTINC	;SAVE INCREMENTAL UPTIME FOR OTHERS
NORMLA:	MOVE	A,[%NSHJB]	;HIGHEST JOB NUMBER IN USE
	PUSHJ	P,GET		;READ FROM MONITOR
	 MOVE	A,JOBN		;???
	MOVEM	A,JBNMAX	;REMEMBER IT
	PUSHJ	P,GJBDAT	;READ ALL THE JOB DATA
	MOVN	J,JBNMAX	;GET MAX JOB IN USE
	HRLZ	J,J		;MAKE "IOWD" INDEX POINTER
	HRRI	J,1		;START WITH JOB 1
	SUBTTL	"N" DISPLAY -- JOBS

NORML0:	TLOE	F,FL.NHED	;GOT HEADER YET?
	JRST	NORML2		;YES
	TRNE	F,FR.VMM	;DOING VM DISPLAY?
	PUSHJ	P,PAGSYS	;YES, TYPE SOME LEADING INFORMATION
	MOVEI	M,[ASCIZ /Job  Who  Where What/]
	CALL	MSG		;PRINT PART OF MESSAGE
	TRNE	F,FR.VMM	;IS VIRTUAL M THERE
	JRST	NORML1		;YES THEN ALL SET
	MOVEI	M,[ASCIZ /  #/]
	CALL	MSG		;PRINT MESSAGE
	CALL	KAYPAG		;KAYS OR PAGES
NORML1:	MOVEI	M,[ASCIZ /     Virtual          Physical       PGR  /]
	TRNE	F,FR.VMM	;DOING MEMORY DISPLAY?
	PUSHJ	P,MSG		;YES
	MOVEI	M,[ASCIZ / State Runtime/]
	CALL	MSG		;PRINT THE END OF THE LINE
	MOVEI	M,[ASCIZ\     Reads   Writes    User\]
	TRNN	F,FR.JOB!FR.VMM	;IN "J" OR "M" DISPLAY?
	TRNN	F,FR.SJB	;NO, "N" DISPLAY, IN EXPANDED JOBS?
	CAIA			;NO, THEN NO DISK READS/WRITES/ETC.
	PUSHJ	P,MSG		;YES, EXTRA HEADER
	PUSHJ	P,CRLF		;CAP OFF HEADER LINE
NORML2:	MOVE	JS,@JBSTS
	TXNN	JS,JS$JNA
	JRST	NORMNJ

NORML3:	AOS	JBNUSE		;COUNT JOBS IN USE
	TXNE	JS,JS$LOG	;JOB LOGGED IN?
	AOS	JBNLOG		;YES, COUNT LOGGED-IN JOBS
	HRRZM	J,CLINE		;WE ARE AT THIS LINE
	PUSHJ	P,SETVIS	;DETERMINE VISIBLITY
	HRRZ	N,J		;GET THE JOB NUMBER
	SKIPE	VISIBL		;NEXT SCREEN DISPLAY CAN SHOW IT
	CAMGE	N,FIRJOB
	TLO	F,FL.SUP	;NO, SUPPRESS THIS JOB
	PUSHJ	P,INCRTL	;[610] COMPUTE INCREMENTALS FOR THIS JOB
	TRNE	F,FR.IDL	;[610] SUPPRESS IDLE JOBS?
	PUSHJ	P,IDLEJB	;[610] YES, SEE IF JOB IDLE AND SUPPRESS IT
NL3A:	TRNN	F,FR.OPR	;WANT TO SUPPRESS [OPR] JOBS?
	JRST	NORML4		;NO, ALWAYS SHOW
	MOVE	A,@JBPPN	;YES, GET JOB'S PPN
	CAMN	A,OPRPPN	;IS THIS AN [OPR] JOB?
	TLOA	F,FL.SUP	;YES, SUPPRESS THIS JOB

NORML4:	TLNE	F,FL.SUP	;WANT TO SUPPRESS THIS JOB?
	JRST	SYSL0E		;YES, JUST GATHER FIGURES
	PUSHJ	P,DECPRT	;PRINT THE JOB NUMBER
	PUSHJ	P,TAB		;AND TERMINATE WITH A <TAB>
	MOVE	A,@JBPPN	;GET THE JOB'S PPN
;	CAMN	A,LOGPPN	;TEST FOR [2,5]
;	JRST	[PUSHJ P,STRWHO	;  YES, PRINT **,** CAUSE WE DON'T KNOW
;		 JRST  SYSL0D]
	CAMN	A,OPRPPN	;TEST FOR [1,2]
	JRST	[MOVE  A,[SIXBIT/[OPR]/] ;YES, PRINT [OPR]
		 PUSHJ P,SIXBP
		 JRST  SYSL0D]
	CAMN	A,ME		;TEST FOR MY PPN
	JRST	[MOVE  A,[SIXBIT/[SELF]/] ;YES, PRINT [SELF]
		 PUSHJ P,SIXBP
		 JRST  SYSL0D]
	PUSHJ	P,PNTPPN	;PRINT PRJ-PRG #
SYSL0D:	PUSHJ	P,TAB
SYSL0E:	SKIPN	A,TTYFLG	;DO WE DECIDE HE IS DETACHED?
	JRST	SYS3LD		;YES HE LOSES
	JUMPL	A,SYS2LD	;JUMP IF PRIVILEGED TOPS10 STYLE
	HRRZ	A,J		;GET JOB NUMBER
	TRMNO.	A,		;GET LINE UDX
	JRST	SYS3LD		;CAN ONLY BE DETACHED
	CAME	A,CTYNDX	;IS IT CTY
	JRST	SYS1LD		;NO GO ON
	MOVSI	A,(SIXBIT .CTY.);SAY CTY
	JRST	SYS3LD		;THAT'S ALL
SYS1LD:	DEVNAM	A,		;GET THE DEVICE NAME
	SETZM	A		;ZAP NAME ON FAILURE
	JRST	SYS3LD		;PRINT IT
SYS2LD:	MOVE	A,@TTLDB
SYS3LD:	PUSHJ	P,PTYCTL	;CHANGE TO CONTROLLING JOB IF PTY
	TLNN	A,-1		;ATTACHED TO A TTY?
	AOS	JBNDET		;COUNT DETACHED JOBS
	TLNE	F,FL.SUP	;OUTPUT FOR THIS JOB?
	JRST	SYSL2		;NO
	TLNN	A,-1
	TLO	A,'DET'
	HLRZ	CH,A		;COPY L.H. OF NAME AS R.H. OF AC
	CAIN	CH,'TTY'	;TEST FOR 'TTYNN'
	HRLZ	A,A		;  YES, CONVERT TO 'NN   '
	TRNN	A,-1
	JRST	SYSL1G
	HRRZ	CH,A
	LSH	A,-14
	HRR	A,CH
	LSH	A,14
	TRNE	A,-1
	SOS	COL		;BACK UP ONE IF NO ROOM
SYSL1G:	PUSHJ	P,SIXTAB	;PRINT SIXBIT MSG FOLLOWED BY TAB
	MOVE	A,@JBPRG	;GET THE PROGRAM NAME
	PUSHJ	P,SIXTAB	;PRINT SIXBIT MSG FOLLOWED BY TAB
SYSL2:	PUSHJ	P,VMHILO	;GET PHY AND VIRT LOW AND HIGH SIZES
	ADDM	N,PHYUSE	;COUNT TOTAL (NON-SHARED) PHYSICAL IN USE
	ADDM	N1,VIRUSE	;COUNT TOTAL (NON-SHARED) VIRTUAL IN USE
	ADDM	BP,SHRSAV	;COUNT TOTAL MEMORY SAVED BY SHARING
	PUSHJ	P,INACTC	;TEST FOR ACTIVE PROGRAM
	 PUSHJ	P,ACTVC		;YES, COUNT UP IT'S CONTRIBUTION
	TLNN	F,FL.SUP	;SEE IF SUPPRESSED
	CALL	PGDATA		;TYPE PAGING DATA
TSTATE:	MOVSI	A,'^W '		;"COMMAND WAIT"
	TXNE	JS,JS$RUN	;RUN BIT ON?
	MOVSI	A,'CW '		;YES, CHANGE INDICATION
	TXNE	JS,JS$CMW	;JOB IN COMMAND WAIT?
	JRST	TSTAT9		;YES. SAY SO REGARDLESS OF STATE
	MOVSI	A,'OW '		;"OPERATOR WAIT FOR DEVICE"
	TXNE	JS,JS$OWD	;JOB IN DEVICE ERROR WAIT?
	JRST	TSTAT9		;YES, SAY SO
	MOVSI	A,'^D '		;"DAEMON (.DCORE) WAIT"
	TXNE	JS,JS$JDC	;JOB WAITING FOR DAEMON?
	JRST	TSTAT9		;YES, TELL USER THAT
	MOVSI	A,'^C '		;"CONTROL-C (HALT) STATE"
	JUMPGE	JS,TSTAT9	;IF JOB IS NOT RUNNING SAY HALTED
	MOVSI	A,'RU '		;"RUN/GET[SEG]/MERGE COMMAND/UUO"
	MOVX	N,J2$IGS	;THE "IN GETSEG" BIT
	TXNN	JS,JS$RUU	;IN A RUN UUO OR COMMAND?
	TDNE	N,@JBST2	;OR IN A GETSEG (MERGE) UUO OR COMMAND?
	JRST	TSTAT8		;YES, SAY THAT THEN (AND COUNT ACTIVE)
	LDB	B,[POINTR JS,JS$WST]  ;GET JOB WAIT STATE QUEUE
	IDIVI	B,3		;THREE QUEUE NAMES PER WORD
	IMULI	C,^D12		;EQUALS 12 BITS PER WORD
	MOVE	A,QTAB(B)	;WORD HOLDING QUEUE CODES
	LSH	A,(C)		;LEFT JUSTIFY QUEUE CODE NAME
	AND	A,[7777B11]	;MASK OFF ANY OTHER CODES
	MOVS	B,A		;PUT IN RH(B) FOR EASE OF CHECKING
	CAIE	B,'SL '		;IN SLEEP QUEUE?
	JRST	TSTAT0		;NO, CHECK FOR TI
	MOVX	N,J2$HIB	;THE "IN A HIBER" BIT
	TDNN	N,@JBST2	;PROGRAM IN A HIBER OR A SLEEP?
	JRST	TSTAT8		;IN A SLEEP, COUNT SLEEPY JOB
	MOVSI	A,'HB '		;IN A HIBER, INDICATE ACCORDINGLY
	TXNE	JS,JS$CLK	;ALSO GOT A CLOCK REQUEST PENDING?
	MOVSI	A,'HS '		;YES, "HIBER WITH A SLEEP TIME"
	JRST	TSTAT8		;COUNT UP A SLEEPY JOB
TSTAT0:	CAIE	B,'DI '		;IN DISK I/O WAIT?
	CAIN	B,'IO '		;OR RANDOM I/O WAIT?
	JRST	TSTAT1		;YES, SEE WHICH DIRECTION
	CAIE	B,'TI '		;IN TERMINAL I/O WAIT?
	JRST	TSTAT2		;NO, CHECK FOR OTHER STATES

;TTY'S MUST BE HANDLED SPECIAL SINCE FOR THEM IO$OUT IS IGNORED

	MOVE	B,['TWTITO']	;YES
	PUSHJ	P,IOWTT		;CHECK IF TTY IS IN OR OUT BLOCKED
	MOVS	B,A		;GET STATE BACK INTO B AGAIN
	CAIE	B,'TI '		;IN TERMINAL INPUT STATE?
	JRST	TSTAT7		;NO, COUNT COUNT I/O BLOCKED
	JRST	TSTAT8		;YES, COUNT AS SLEEPY JOB


TSTAT1:	CAIN	B,'DI '		;IN DISK I/O WAIT?
	MOVE	B,['DWDIDO']	;YES
	CAIN	B,'IO '		;RANDOM I/O WAIT?
	MOVE	B,['IOINOU']	;YES
	PUSHJ	P,IOWCK		;PICK APPROPRIATE STATE
	JRST	TSTAT7		;NO, COUNT I/O BLOCK JOBS


TSTAT2:	CAIE	B,'RN '		;IN THE RN QUEUE(S)?
	JRST	TSTAT3		;NO--GO ON
	LDB	B,[POINTR @JBRTD,JR$HPQ]  ;YES, GET HPQ (IF ANY)
	JUMPE	B,TSTAT6	;NOT IN HPQ
	TRZN	B,10		;HPQ .GE. 10?
	TROA	B,' H0'		;NO, PRINT AS HN
	ADDI	B,' 00'		;YES, PRINT AS NN
	LSHC	A,^D36+^D24	;LEFT JUSTIFY SIXBIT IN A
	JRST	TSTAT6		;COUNT RN JOBS
TSTAT3:	CAIE	B,'EW '		;EVENT WAIT?
	JRST	TSTAT7		;EVERYTHING ELSE COUNTS AS ACTIVE
				; BUT "BLOCKED" (EVEN NA)
	LDB	B,[POINTR @JBST2,J2$WEW]  ;ESLEEP (EVENT WAIT) CODE
	CAIN	B,EW$TKW	;MAGTAPE KONTROLLER WAIT?
	MOVSI	A,'EK '		;YES, "EVENT KONTROLLER WAIT"
	CAIN	B,EW$REW	;MAGTAPE REWIND?
	MOVSI	A,'ER '		;YES, "EVENT REWIND WAIT"
	CAIN	B,EW$LBL	;LABEL PROCESSING WAIT?
	MOVSI	A,'EL '		;YES, "EVENT LABEL WAIT"
	CAIN	B,EW$NET	;ANF-10 NETWORK WAIT?
	MOVSI	A,'EN '		;YES, "EVENT NETWORK WAIT"
	CAIE	B,EW$FEI	;FRONT END INPUT WAIT?
	CAIN	B,EW$FEO	;OR FRONT END OUTPUT WAIT?
	MOVSI	A,'EF '		;YES, "EVENT FRONT-END WAIT"
	CAIN	B,EW$D60	;DN60 WAIT?
	MOVSI	A,'E6 '		;YES, "EVENT DN60 WAIT"
	CAIN	B,EW$DCN	;DECNET NETWORK WAIT?
	MOVSI	A,'ED '		;YES, "EVENT DECNET WAIT"
	CAIN	B,EW$ETH	;ETHERNET WAIT?
	MOVSI	A,'EE '		;YES, "EVENT ETHERNET WAIT"
	MOVX	N,J2$EWS	;EVENT WAIT SATISFIED BIT
	TDNN	N,@JBST2	;JOB READY TO WAKE UP?
	JRST	TSTAT8		;NO, COUNT AS A SLEEPY JOB
	MOVSI	A,'ES '		;YES, CALL "EVENT WAIT SATISFIED"
	JRST	TSTAT7		;COUNT AS ACTIVE, BUT NOT IN RN QUEUE(S)
TSTAT6:	AOS	JRNRN		;JOBS IN ACTIVE RN STATE
TSTAT7:	AOS	JRNIO		;JOBS ACTIVE OR IO BLOCKED
TSTAT8:	AOS	JRNSL		;JOBS ACTIVE BUT SLEEPING
TSTAT9:	TLNE	F,FL.SUP	;SUPPRESSING OUTPUT?
	JRST	TSTATL		;YES, NO OUTPUT
	PUSHJ	P,SIXBP
	TXNN	JS,JS$LCK	;SEE IF LOCKED
	JRST	TSTATL		;NO--PROCEED
	MOVEI	CH,"&"		;INDICATE LOCKED
	PUSHJ	P,TYO		;OUTPUT IT
	SKIPN	@JBSGN		;SEE IF HI-SEG LOGIC
	JRST	SYSL1E		;NO--FINISH UP
TSTATL:	PUSHJ	P,GETSGN	;GET HIGH SEGMENT DATA
	SKIPN	A		;JOB HAVE A HISEG?
	JRST	[PUSHJ	P,SPACE
		JRST	SYSL1E]
	JUMPL	A,SYSL1S	;JUMP IF SPYING
	PUSH	P,J		;SAVE J
	MOVE	J,A
	SKIPE	B,@JBPRG	;AN OBSOLETED SEGMENT?
	JRST	SYSL1A		;NO-CHECK IF IT'S A NON CUSP HISEG
	MOVEI	CH,"@"
	MOVE	B,@JBSTS
	TXNE	B,JS$SHR	;IS IT SHARABLE?
	JRST	SYSL1B		;YES-FLAG JOB WITH @
	JRST	SYSL1F		;NO-MUST BE PRIVATE
SYSL1S:	MOVEI	CH,"+"		;GET A "+"
	PUSHJ	P,TYO		;OUTPUT IT TO SHOW SPYING
	JRST	SYSL1E		;  CONTINUE ON
SYSL1A:	MOVE	B,@JBPPN	;GET HISEG OWNER
	MOVEI	CH,"#"		;PREPARE TO FLAG JOB WITH #
	CAMN	B,OLDPPN
	MOVEI	CH,"O"
	CAMN	B,NEWPPN
	MOVEI	CH,"N"
	CAMN	B,SYSPPN	;CUSP?
SYSL1F:	MOVEI	CH," "		;PRINT A SPACE
SYSL1B:	PUSHJ	P,TYO		;PRINT @ OR #
	POP	P,J		;RESTORE J & A
SYSL1E:	PUSHJ	P,GETSGN	;GET HIGH SEGMENT NUMBER
	MOVE	N,JOBVIR	;GET JOB'S VIRTUAL MEMORY SIZE(S)
	SKIPG	A		;DOES JOB HAVE A REAL HIGH SEGMENT?
	TRZ	N,-1		;NO HIGH SEGMENT OR SPY SEGMENT
	SETZB	CH,A		;ZAP BOTH V AND SW WORD
	CAME	N,JOBPHY	;SAME AS PHYSICAL SIZE(S)?
	MOVEI	CH,"V"		;NO, FLAG JOB AS VIRTUAL
SYSL2E:	PUSHJ	P,LHPSWP	;PRINT STATE AND "SW"/"SF" AS APPROPRIATE
	MOVE	A,JITIM		;[610] INCREMENTAL RUNTIME
	TLNN	F,FL.INC	;[610] INCREMENTAL OR TOTALS?
	MOVE	A,@JTTIM	;TOTALS
	TRNN	F,FR.PCT	;RUNTIME OR PERCENTAGE?
	JRST	SYSL2T		;RUNTIME, JUST TYPE IT
	MOVE	B,UPTINC	;PERCENTAGE, GET UPTIME
	MOVEM	B,TEMP		;AND STORE FOR CMPDNA
	PUSHJ	P,CMPDNA	;PRINT OUT PERCENTAGE OF CPU
	PUSHJ	P,PERCNT	;WITH A PERCENT SIGN FOR CUTENESS
	CAIA			;DON'T BOTHER PRINTING TIME NOW
SYSL2T:	PUSHJ	P,TCKTIM	;JUST PRINT THE RUNTIME
	TRNN	F,FR.SJB	;EXPANDED JOB DISPLAY?
	JRST	SYSL5		;NO

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;PRINT DISK READS AND WRITES

	PUSHJ	P,TAB		;YES, TAB OVER TO DISK READS COLUMN
	MOVE	N,JIRCT		;[610] INCREMENTAL READS
	TLNN	F,FL.INC	;[610] INCREMENTAL OR TOTALS?
	MOVE	N,@JTRCT	;TOTALS
	PUSHJ	P,DECB8		;PRINT DISK READS
	PUSHJ	P,TAB		;TAB OVER TO NEXT COLUMN
	MOVE	N,JIWCT		;[610] INCREMENTAL WRITES
	TLNN	F,FL.INC	;[610] INCREMENTAL OR TOTALS?
	MOVE	N,@JTWCT	;TOTALS
	PUSHJ	P,DECB8		;PRINT DISK WRITES

;PRINT USER NAME NOW

	PUSHJ	P,TAB		;TAB OVER TO USER NAME COLUMN
	MOVE	A,@JBNM1	;FIRST HALF OF THE USER NAME
	PUSHJ	P,SIXB6		;TYPE IT OUT
	SKIPE	A,@JBNM2	;SECOND HALF OF THE USER NAME
	PUSHJ	P,SIXB6		;TYPE ALL OF IT OUT IF NON-BLANK

;END OF JOBS DISPLAY

SYSL5:	PUSHJ	P,CRLF		;CAP OFF THIS JOB'S DISPLAY LINE
NORMNJ:	TLZ	F,FL.SUP	;CLEAR DISPLAY SUPPRESS FOR NEXT JOB
	AOBJN	J,NORML0	;LOOP FOR ALL JOBS
	CALL	SETEND		;SET SLINE VARIABLE TO ADAPT TO EMPTY SCREEN
	TRNE	F,FR.JOB!FR.SJB!FR.VMM  ;JOBS ONLY?
	POPJ	P,		;YES, THEN ALL DONE
	JRST	NSYS00		;GO DO "N" DISPLAY SYSTEM STUFF
;SUBROUTINE TO CONVERT TTY NUMBER TO CONTROLLING JOB NUMBER
;IF CONTROLLED OVER A PTY (5.03 AND MORE RECENT ONLY)
;CALL:	MOVE	A,'TTYNN'
;	PUSHJ	P,PTYCTL
;	RETURN WITH TTYNN OR JOBNN
;USES B,C,D,R

PTYCTL:	TLNN	A,-1		;SEE IF DETACHED
	POPJ	P,		;YES--LEAVE ALONE
	HRLZ	C,A		;GET TTY NUMBER (0 IF CTY)
	MOVEI	B,0		;CLEAR ACCUMULATOR
	LSH	C,3		;CONVERT TO
	LSHC	B,3		; BINARY FROM
	JUMPN	C,.-2		; SIXBIT
	CAML	B,PTYOFS	;SEE IF PTY
	CAML	B,PTYMAX	; DRIVEN
	POPJ	P,		;NO--RETURN
	SUB	B,PTYOFS	;YES--GET PTY NUMBER
	MOVEI	R,10		;CONVERT TO OCTAL
	PUSHJ	P,MAKSIX	; SIXBIT
	HRLI	B,'PTY'		;CHANGE TO DEVICE NAME
	SKIPE	REALTT		;TEST FOR PTY DISPLAY
	JRST	PTYXIT		;  YES, JUMP
	DEVTYP	B,1B19		;PHYSICAL DEVICE--GET JOB OWNER
	  POPJ	P,		;ERROR RETURN IF PRE 5.03
	LSH	B,-11		;GET JOB NUMBER
	ANDI	B,777		;REMOVE JUNK
	JUMPE	B,CPOPJ		;IF NOT CONNECTED, GIVE UP
	MOVEI	R,12		;CONVERT TO DECIMAL
	PUSHJ	P,MAKSIX	; SIXBIT
	HRLI	B,'JOB'		;ADD JOB PREFIX
PTYXIT:	MOVE	A,B		;CHANGE ANSWER
	POPJ	P,		;RETURN

;SUBROUTINE TO CONVERT BINARY TO SIXBIT IN ARBITRARY RADIX
;ARG/ANSWER IN B (0-777)
;USES C,D  RADIX IN R

MAKSIX:	MOVE	D,[POINT 6,B,17]	;PRESET POINTER
MAKSX1:	IDIVI	B,(R)		;OLD FASHIONED WAY
	HRLM	C,(P)
	SKIPE	B
	PUSHJ	P,MAKSX1
	HLRZ	C,(P)
	ADDI	C,'0'
	IDPB	C,D
	POPJ	P,
;SUBROUTINE TO FIND 1ST. JOB USING A SEGMENT
;CALL	MOVE	J,SEGMENT NO.
;	PUSHJ	P,SEGSCN
;	NONE FOUND RETURN
;	FOUND
;AC'S B & C DESTROYED
;AC J IS RESPECTED

SEGSCN:	PUSH	P,A		;PRESERVE FROM CORRUPTION
	MOVN	B,JOBN
	HRLZS	B
	HRR	B,JBSGN		;PREPARE AOBJN PTR. FOR SCANNING JBTSGN
HIGH06:	HRRZ	A,(B)		;GET SEGMENT NO.
	PUSHJ	P,CNVSGN	;CONVERT IT TO USEFUL FORMAT
	CAIE	A,(J)		;DOES IT MATCH WITH CURRENT ONE?
HIGH6A:	AOBJN	B,HIGH06	;NO-DO AGAIN
	POP	P,A		;RESTORE A
	SKIPGE	B		;WE HAVE A MATCH?
CPOPJ1:	AOS	(P)		;YES - SKIP RETURN
	POPJ	P,		;NO-NONE FOUND RETURN



;SUBROUTINE SEGLOK CHECKS IF A SEGMENT IS LOCKED IN CORE
; J=JOB # OR HIGH SEG #
; N=SIZE OF SEGMENT
; UPDATES MAXMAX TO INCLUDE LOCKED SEG SIZE
; ALWAYS NON-SKIP RETURN

SEGLOK:	SETOM	LOKCHK		;FLAG THAT WE WERE HERE
	PUSH	P,B		;SAVE B
	MOVE	B,@JBSTS	;GET STATUS WORD
	TXNE	B,JS$LCK	;SEE IF LOCKED
	ADDM	N,MAXMAX	;YES,UPDATE MAXMAX W/ SIZE OF LOCKED SEG
	POP	P,B		;(NO)RESTORE B
	POPJ	P,		;RETURN
;SUBROUTINE TO CHECK IF A SEGMENT IS INACTIVE
;INACTIVE IS DEFINED AS RUN BIT OFF OR SL/TI/EW STATE
;ARGS	J=SEGMENT NUMBER IN RH
;NON-SKIP RETURN IF ACTIVE, SKIP RETURN IF INACTIVE

INACTC:	SKIPL	D,@JBSTS	;SKIP IF RUN BIT ON
	JRST	CPOPJ1		;OFF, INACTIVE
	LDB	D,[POINT 5,D,14]	;GET WAIT STATE CODE
	CAMN	D,SLQ		;IN "SL" STATE?
	JRST	CPOPJ1		;YES, ONE MATCHES, INACTIVE
	CAME	D,TIQ		;IN "TI" STATE?
	CAMN	D,EWQ		;OR "EW" STATE?
	AOS	(P)		;YES, MATCHES, INACTIVE
	POPJ	P,		;NO, MUST BE ACTIVE



;SUBROUTINE ACTVC ADDS UP CURRENT JOB'S CONTRIBUTION TO ACTUSE
;CALL WITH A/SEGMENT INDEX FOR @SGCNT

ACTVC:	HLRZ	N,JOBPHY	;LOSEG PHYSICAL SIZE
	JUMPLE	A,ACTVC3	;ONLY COUNT HISEGS THAT EXIST
	MOVX	N1,SGC$AC	;THE HISEG-COUNTED FLAG
	TDNN	N1,@SGCNT	;HAS THE HISEG ALREADY GIVEN TO ACTUSE?
	ADD	N,JOBPHY	;NO, FIRST TIME, ADD IN HISEG PHYSICAL SIZE
	IORM	N1,@SGCNT	;MARK THE HISEG'S CONTRIBUTION
ACTVC3:	ADD	N,JOBPPG	;ADD MONITOR PER-PROCESS SPACE OVERHEAD
	ANDI	N,777777	;STRIP OFF LH GARBAGE
	ADDM	N,ACTUSE	;ACCUMULATE PHYSICAL ACTIVE MEMORY USAGE
	POPJ	P,		;ALL DONE
;SUBROUTINE IDLEJB SUPPRESSES IDLE JOBS
;IDLE JOB = JOB HAS ACCUMULATED NO RUNTIME AND NO DISK READS/WRITES
;ARGS	J=JOB NUMBER (RH)

IDLEJB:	MOVE	A,TRSHLD	;[610] GET THRESHOLD VALUE
	SUB	A,JITIM		;[610] SUBTRACT INCREMENTAL RUNTIME
	SKIPGE	A		;[610] NOT ENOUGH FOR US
	POPJ	P,		;[610] MEETS THRESHOLD REQUIREMENTS, SHOW JOB
	SKIPE	TRSHLD		;[610] IF THRESHOLD WAS GIVEN, BUT NOT EXCEEDED
	TLO	F,FL.SUP	;[610]  THEN FORCE JOB TO IDLE, OTHERWISE CHECK FOR
	SKIPN	JIRCT		;[610] ANY DISK READS
	SKIPE	JIWCT		;[610]   OR WRITES?
	POPJ	P,		;[610] YES, NON-IDLE JOB
	TLO	F,FL.SUP	;[610] MUST BE IDLE, SUPPRESS JOB
	POPJ	P,		;[610] RETURN



;SUBROUTINE INCRTL COMPUTES INCREMENTAL RUNTIME AND DISK I/O ON A
;PER JOB BASIS AND STORES THE RESULTS IN THE "JIXXX" JOB TABLES.

INCRTL:	MOVE	A,@JBTIM	;[610] COMPUTE INCREMENTALS FOR THIS JOB
	SUB	A,@JTTIM	;[610] A := INCREMENTAL RUN TIME
	JUMPGE	A,INCR2		;[610] VALID?
	MOVE	A,@JBTIM	;[610] NO! JOB HAS CHANGED, USE TOTAL AS INCREMENTAL
	SETZM	@JTTIM		;[610] ZERO RUNTIME,
	SETZM	@JTRCT		;[610]   DISK READS
	SETZM	@JTWCT		;[610]     AND WRITES TOTALS
INCR2:	ADDM	A,@JTTIM	;[610] UPDATE TOTAL
	MOVEM	A,JITIM		;[610] SAVE INCREMENTAL
	MOVE	A,@JBRCT	;[610] PICK UP DISK READS
	ANDX	A,RC.TTL	;[610] REDUCE TO JOB TOTAL
	SUB	A,@JTRCT	;[610] A := INCREMENTAL DISK READS
	ADDM	A,@JTRCT	;[610] UPDATE TOTAL
	MOVEM	A,JIRCT		;[610] SAVE INCREMENTAL
	MOVE	A,@JBWCT	;[610] DISK WRITES
	ANDX	A,WC.TTL	;[610] REDUCE TO JOB TOTAL
	SUB	A,@JTWCT	;[610] A := INCREMENTAL DISK WRITES
	ADDM	A,@JTWCT	;[610] UPDATE TOTAL
	MOVEM	A,JIWCT		;[610] SAVE INCREMENTAL
	POPJ	P,
;VMHILO COMPUTE PHYSICAL AND VIRTUAL HIGH AND LOW DATA
;THIS SHOULD BE COMPATIBLE WITH THE CORE COMMAND OUTPUT
;
;RETURNS:
;
;	N/		NON-SHARABLE PHYSICAL SIZE
;	N1/		NON-SHARABLE VIRTUAL SIZE
;
;	JOBPHY		LOW,,HIGH PHYSICAL SEGMENT SIZES
;	JOBVIR		LOW,,HIGH VIRTUAL SEGMENT SIZES
;	JOBPPG		MONITOR PER-PROCESS PAGES FOR THIS JOB

VMHILO:	SETZ	N1,		;ASSUME NO HIGH SEG
	LDB	N,[POINTR @JBIMI,JP$IMI]  ;GET LOW SEG "IMGIN" SIZE
	PUSHJ	P,GETSGN	;GET JBTSGN ENTRY
	JUMPLE	A,VMHIL2	;SPYING OR NO HIGH SEG
	HRRZ	BP,A		;SEGMENT NUMBER ONLY
	EXCH	J,BP		;POINT J AT SEGMENT INDEX
	TXNN	A,JS$SHR	;SHARABLE??
	JRST	VMHIL0		;NOPE OTHER ARITHMETIC
	LDB	N1,[POINTR @JBIMI,JP$IMI]  ;GET SHARABLE HISEG "IMGIN"  SIZE
	JRST	VMHIL1		;ALL SET

VMHIL0:	HLRZ	N1,@JBSWP	;GET NON-SHARABLE HISEG SIZE
	SUB	N,N1		;REDUCE LOW SEG SIZE
VMHIL1:	EXCH	BP,J		;RESTORE JOB NUMBER
VMHIL2:	HRL	N1,N		;MAKE LOW,,HIGH PHYSICAL SIZES
	MOVEM	N1,JOBPHY	;REMEMBER PHYSICAL SIZES
	LDB	N,[POINTR @JBVIR,JP$IMV]  ;GET LO SEG VIRTUAL SIZE
	TXNN	A,JS$SHR	;SHARABLE HIGH SEGMENT?
	LDB	N1,[POINTR @JBVIR,JP$HMV]  ;GET NON-SHARABLE HI SEG VIRTUAL SIZE
	HRL	N1,N		;MAKE LOW,,HIGH VIRTUAL SIZES
	MOVEM	N1,JOBVIR	;REMEMBER VIRTUAL SIZES
	LDB	N,[POINTR @JBPDB,JP$PPP]  ;JOB'S PER-PROCESS PAGES
	MOVEM	N,JOBPPG	;REMEMBER MONITOR OVERHEAD PAGES
	LDB	N,[POINTR @JBIMI,JP$NZS]  ;JOB'S NON-ZERO-SECTION MAP COUNT
	ADDM	N,JOBPPG	;SECTION-MAPS COUNT AS MONITOR OVERHEAD PAGES
	HLRZ	N,JOBPHY	;LOSEG PHYSICAL SIZE
	HLRZ	N1,JOBVIR	;LOSEG VIRTUAL SIZE
	JUMPLE	A,VMHIL6	;WAS THERE A HISEG?
	SUB	A,JOBN		;YES, OFFSET FOR "SEGMENT ONLY" TABLE
	SKIPE	@SGCNT		;IS THIS THE FIRST USAGE?
	JRST	VMHIL4		;NO - COUNT UP SAVED-BY-SHARING USAGE
	ADD	N,JOBPHY	;ACCOUNT FOR FIRST USER OF PHYSICAL HISEG
	ADD	N1,JOBVIR	;ACCOUNT FOR FIRST USER OF VIRTUAL HISEG
	TDZA	BP,BP		;NO MEMORY SAVED HERE
VMHIL4:	HRRZ	BP,JOBPHY	;RETURN "SHRSAV" MEMORY SIZE IN "BP"
VMHIL5:	AOSA	@SGCNT		;COUNT USERS OF THIS SEGMENT
VMHIL6:	SETZ	BP,		;NO MEMORY SAVED IF NO HISEG
	ADD	N,JOBPPG	;RETURN "PHYUSE" MEMORY SIZE IN "N"
	ANDI	N,777777	;STRIP OFF LH GARBAGE
	ADD	N1,JOBPPG	;RETURN "VIRUSE" MEMORY SIZE IN "N1"
	ANDI	N1,777777	;STRIP OFF LH GARBAGE
	POPJ	P,		;RETURN WITH MEMORY SIZES
;IOWCK  --  DETERMINE IF I/O WAIT JOB IS IN OR OUT BLOCKED
;CALL IS:
;
;	MOVX	B,SIXBIT/XXYYZZ/
;	PUSHJ	P,IOWCK
;	RETURN
;
;WHERE 'XX' IS THE INDETERMINATE (NO PEEK OR SPY) STATE, 'YY' IS THE
;INPUT STATE, AND 'ZZ' IS THE OUTPUT STATE.

IOWCK:	MOVE	A,@JBDDB	;[621] ADDRESS OF I/O BLOCKED DDB
	ADDI	A,$DVIOS	;OFFSET INTO DEVIOS WORD
	PUSHJ	P,MPEEK		;READ THE DEVICE I/O STATUS WORD
	JUMPE	A,IOWCK5	;IF 0 THEN NO PRIVS
	TXNE	A,IO$OUT	;DOING INPUT OR OUTPUT?
	LSH	B,^D12		;OUTPUT
	LSH	B,^D12		;INPUT
IOWCK5:	HLLZ	A,B		;GET I/O CODE IN A
	TLZ	A,77		;AND ONLY 2 CHARS WORTH
	POPJ	P,		;RETURN WITH STATE IN A

;SPECIAL KROCK IOWCK FOR TTY'S SINCE THEY WORK DIFFERENTLY

IOWTT:	MOVE	A,@JBDDB	;[621] ADDRESS OF I/O BLOCKED TTY DDB
	ADDI	A,$DVIOS	;OFFSET INTO DEVIOS WORD
	PUSHJ	P,MPEEK		;READ THE DEVICE I/O STATUS WORD
	JUMPE	A,IOWTT5	;IF 0 THEN NO PRIVS
	SKIPGE	A		;DOING INPUT OR OUTPUT?
	LSH	B,^D12		;OUTPUT
	LSH	B,^D12		;INPUT
IOWTT5:	HLLZ	A,B		;GET I/O CODE IN A
	TLZ	A,77		;AND ONLY 2 CHARS WORTH
	POPJ	P,		;RETURN WITH TTY STATE IN A
;SUBROUTINE TO PRINT A MSG. FOLLOWED "SW" IF SEGMENT SWAPPED & NOT FRAGMENTED
; OR "SF" IF SWAPPED & FRAGMENTED, OR NOTHING IF IN CORE & NOT FRAGMENTED
;CALL	MOVE	JS,JOB/HISEG STATUS
;	MOVEI	CH,CHAR	;VALUE TO BE APPENDED
;	PUSHJ	P,LOPSWP
;	ALWAYS GOOD RETURN
;AC'S A,BP,CH ARE DESTROYED
;AC JS IS RESPECTED  *******MSG TO BE PRINTED MUSTN'T EXCEED 4 CHS.********
;DSKUSE IS UPDATED TO REFLECT SWAPPED MEMORY

LHPSWP:	PUSH	P,CH		;SAVE APPENDENDUM
	SETZ	A,		;INITIALLY ASSUME WHOLE JOB IS IN CORE
	TXNN	JS,JS$SWP	;IS LOSEG SWAPPED?
	JRST	LHPSW2		;NO - GO CHECK OUT THE ASSOCIATED HISEG (IF ANY)
	LDB	N,[POINTR @JBIMO,JP$IMI]  ;YES - GET LOSEG SIZE ON DISK
	ADD	N,JOBPPG	;PLUS OVERHEAD (LOW SEG ONLY)
	ADDM	N,DSKUSE	;ADD TO TOTAL SPACE USED ON SWAPPING SPACE
	MOVEI	A,'S  '		;PREPARE TO PRINT "S"
	SKIPGE	@JBSWP		;IS SEG FRAGMENTED?
	MOVEI	A,'SF '		;YES - INDICATE SWAPPED & FRAGMENTED
LHPSW2:	PUSH	P,A		;SAVE A
	PUSHJ	P,GETSGN	;GET JBTSGN DATA
	MOVE	N,A		;COPY HERE
	POP	P,A		;RESTORE A
	JRST	LHPSW7		;NO HISEG (OR SPYSEG)
	PUSH	P,J		;SAVE JOB INDEX
	HRRZ	J,N		;POSITION "SEG" INDEX
	MOVE	CH,@JBSTS	;GET HISEG STATUS
	TXNN	CH,JS$SWP	;IS HISEG SWAPPED?
	JRST	LHPSW6		;NO - NOTHING FURTHER HERE
	LDB	N,[POINTR @JBIMO,JP$IMI]  ;YES - GET HISEG SIZE ON DISK
	EXCH	A,J		;SGCNT WANTS SEG INDEX IN AC "A"
	SUB	A,JOBN		;AND SGCNT IS A "SEGMENT ONLY" TABLE TO BOOT!
	MOVE	CH,@SGCNT	;GET COUNT OF HISEG'S USERS
	ADD	A,JOBN		;MAKE BACK INTO REAL INDEX
	EXCH	J,A		;REPOSITION SWAP CODE IN "A"
	CAIN	CH,1		;IF THIS IS FIRST USER (COURTESY VMHILO),
	ADDM	N,DSKUSE	;ADD TO TOTAL SPACE USED ON SWAPPING SPACE
	CAIN	A,'SF '		;LOW SEG ALREADY WORST CASE?
	JRST	LHPSW6		;YES
	MOVEI	A,'S  '		;NO, THEN MINIMUM IS "S"WAPPED
	SKIPGE	@JBSWP		;IS HISEG FRAGMENTED?
	MOVEI	A,'SF '		;YES, ADVANCE TO "S"WAPPED "F"RAG'ED
LHPSW6:	POP	P,J		;RESTORE JOB INDEX
LHPSW7:	MOVS	A,A		;REPOSITION SWAPPING CODE (IF ANY)
	CAIE	A,0		;IF ANYTHING WAS SWAPPED THEN
	PUSHJ	P,SIXBP		;PRINT "S" OR "SF"
	POP	P,CH		;GET APPENDENDUM BACK
	SKIPE	CH		;ANYTHING TO PRINT?
	CALL	TYO		;(YES) DO IT
	JRST	TAB		;PRINT TAB & EXIT
	SUBTTL	"N" DISPLAY  --  GENERAL SYSTEM STATISTICS

NSYS00:	CALL	WNDSYS		;WINDOW FOR SYSTEM DATA
NSYS01:	PUSHJ	P,CONFIG	;SHORT FORM OF "THISIS"
	CALL	CRLF		;START A NEW LINE
	TRNE	F,FR.SKP	;WANT TO SKIP FIRST PART?
	JRST	STRLP		;YES, GO DIRECTLY TO STR/DEV STUFF
	PUSHJ	P,PDATIM
	MOVEI	M,[ASCIZ/ UP:/]	;IDENTIFY DATA
	PUSHJ	P,MSG		;TYPE OUT TEXT
	MOVE	A,UPTIME	;ALWAYS PRINT TOTAL UPTIME
	PUSHJ	P,TCKTIM	;TYPE OUT UPTIME
	PUSHJ	P,CRLF		;END LINE
	SUBTTL	"N" DISPLAY -- CPU USAGE STATISTICS

CPULP:	MOVE	A,[%CNCPU]	;MAX CPU'S MONITOR BUILT FOR
	PUSHJ	P,GET		;FIND OUT
	 JRST	[MOVEI	A,1	;ASSUME 1
		SKIPE	DUAL	;UNLESS 1077/1088/1099
		MOVEI	A,2	;IN WHICH CASE IS 2 CPU'S
		JRST	.+1]	;CONTINUE
	MOVEM	A,CPMAX		;SAVE FOR LOOP EXIT
	SUBI	A,1		;FLAG, .GT. 0 IF MULTI-CPU
	MOVEM	A,CPMNY		;REMEMBER FOR DOORBELL ETC.
	MOVE	A,[%CNBCP]	;FIND OUT BOOT CPU
	PUSHJ	P,GETZ		;ON GENERAL PRINCIPLES
	MOVEM	A,CPBTS		;AND REMEMBER IT
	MOVE	A,[%CCTYP]	;FIND OUT CPU TYPE FOR CPU0
	PUSHJ	P,GETZ		;READ IT
	CAIE	A,.CCKSX	;[633] ON A KS-10?
	TDZA	M,M		;[633] NO
	SETO	M,		;[633] YES
	MOVEM	M,CPKS10	;[633] FLAG KS'EDNESS
	CAIE	A,.CCKLX	;ON A KL-10?
	CAIN	A,.CCKSX	;OR A KS-10?
	SETOM	CPCSH		;YES, WATCH CACHE FLUSHES
	MOVEI	M,[ASCIZ/ (+)/]	;INDICATE "INCREMENTAL" NUMBERS
	TLNE	F,FL.INC	;INCREMENTAL OR TOTAL?
	PUSHJ	P,MSG		;INCREMENTAL, TELL USER
	MOVEI	M,[ASCIZ/	ID	OV	LS	 UPTIME	CTX	UUO/]
	PUSHJ	P,MSG		;LABEL COLUMNS
	MOVEI	M,[ASCIZ/	DBL/]  ;DOORBELLS/SEC
	SKIPLE	CPMNY		;MULTI-CPU?
	PUSHJ	P,MSG		;YES, ADD COLUMN FOR DOORBELLS/SEC
	MOVEI	M,[ASCIZ/	CSH/]  ;CACHE SWEEP COUNT
	SKIPE	CPCSH		;WATCHING CACHE FLUSHES?
	PUSHJ	P,MSG		;YES, ADD COLUMN
	PUSHJ	P,CRLF		;END HEADER LINE
	SETOM	CPU		;START WITH CPU-1

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

CPULP0:	AOS	J,CPU		;ADVANCE TO NEXT CPU
	CAML	J,CPMAX		;EXCEEDED SYSTEM MAX?
	JRST	CPULP9		;END CPU STUFF
	ASH	J,1		;INDEX INTO %CCXXX/%CVXXX TABLES
	MOVE	A,[%CCLOG]	;CPU LOGICAL NAME
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GET		;GET THIS CPU'S NAME
	 MOVE	A,['CPU?  ']	;FAILED?
	MOVEM	A,CPNAM(J)	;SAVE IT
	PUSHJ	P,SIXBP		;AND TYPE IT OUT

;MAKE SURE CPU IS RUNNING, ABORT DISPLAY IF NOT

	SETZ	M,		;ASSUME CPU IS OK
	MOVE	A,[%CCOKP]	;CPU "OK" WORD
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	CAILE	A,0		;CPU RUNNING OK IF .LE. 0
	MOVEI	M,[ASCIZ/	(Not Running)/]  ;SAY NOT RUNNING
	MOVE	A,[%CVRUN]	;CPU RUN/SCHEDULING WORD
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;SEE WHAT MONITOR THINKS
	TXNE	A,CV%RUN	;"NOT RUNNING JOBS"?
	MOVEI	M,[ASCIZ/	(Not Scheduling)/]  ;NO
	TXNE	A,CV%SPD	;SUSPENDED (SHOULDN'T HAPPEN TO RUNNING SYSTEM)
	MOVEI	M,[ASCIZ/	(Suspended (???))/]
	TXNE	A,CV%DET	;DETACHED?
	MOVEI	M,[ASCIZ/	(Detached)/]
	TXNE	A,CV%RMV	;REMOVED?
	MOVEI	M,[ASCIZ/	(Removed)/]
CPULP1:	MOVEM	M,CPOKF(J)	;SAVE GOODNESS FOR OTHERS ALSO
	JUMPE	M,CPULP2	;IF NO ERROR PROCEDE WITH CPU STUFF
	PUSHJ	P,MSG		;TELL USER OF WOES
	JRST	CPULP7		;THAT'S IT FOR THIS CPU

;CPU IS RUNNING, SET UPTIME FOR CALCULATING INCREMENTAL VALUES

CPULP2:	MOVE	A,[%CVUPT]	;CPU UPTIME
	ADD	A,J		;OFFSET FOR CURRENT CPU
	PUSHJ	P,GETZ		;GET WHAT'S THERE
	SUB	A,CPUPT(J)	;A := INCREMENTAL VALUE
	ADDM	A,CPUPT(J)	;UPDATE TOTALS TABLE
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,CPUPT(J)	;WANT TOTALS
	MOVEM	A,TEMP		;SAVE IT

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;SHOW CPU IDLE (NO JOBS TO RUN) TIME

	PUSHJ	P,TAB		;TAB OVER TO THE COLUMN
	MOVE	A,[%CVLST]	;CPU LOST TIME
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	SUB	A,CPLST(J)	;A := INCREMENTAL VALUE
	ADDM	A,CPLST(J)	;UPDATE TOTALS TABLE
	MOVEM	A,TEMP1		;SAVE INCR LOST TIME
	MOVE	A,[%CVNUL]	;CPU NULL (IDLE) TIME
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	SUB	A,CPNUL(J)	;A := INCREMENTAL VALUE
	SUB	A,CPLST(J)	;SUBTRACT INCR LOST TIME
	ADDM	A,CPNUL(J)	;UPDATE TOTALS TABLE
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,CPNUL(J)	;WANT TOTALS
	PUSHJ	P,CALCNA	;CALCULATE PERCENT IDLE TIME
	PUSHJ	P,DECB2		;PRINT PERCENT IDLE TIME

;SHOW CPU OVERHEAD (INTERRUPT LEVEL, SCHEDULER, ETC.) TIME

	PUSHJ	P,TAB		;TAB OVER TO THE COLUMN
	MOVE	A,[%CVOHT]	;CPU OVERHEAD TIME
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	SUB	A,CPOHT(J)	;A := INCREMENTAL VALUE
	ADDM	A,CPOHT(J)	;UPDATE TOTALS TABLE
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,CPOHT(J)	;WANT TOTALS
	PUSHJ	P,CALCNA	;CALCULATE PERCENT OVERHEAD TIME
	PUSHJ	P,DECB2		;PRINT PERCENT OVERHEAD TIME

;SHOW CPU LOST (JOBS RUNNABLE, BUT COULDN'T) TIME

	PUSHJ	P,TAB		;TAB OVER TO THE COLUMN
	MOVE	A,TEMP1		;GET INCR LOST TIME
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,CPLST(J)	;WANT TOTALS
	PUSHJ	P,CALCNA	;CALCULATE PERCENT LOST TIME
	PUSHJ	P,DECB2		;PRINT PERCENT LOST TIME

;SHOW CPU UPTIME

	PUSHJ	P,TAB		;SPACE OVER FOR UPTIME
	MOVE	A,TEMP		;GET THIS CPU UPTIME
	PUSHJ	P,TCKTIM	;PRINT UPTIME

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;SHOW CPU CONTEXT SWITCHES PER SECOND

	PUSHJ	P,TAB		;TAB OVER TO CONTEXT SWITCHS
	MOVE	A,[%CVTJC]	;CONTEXT SWITCH COUNT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	SUB	A,CPTJC(J)	;A := INCREMENTAL VALUE
	ADDM	A,CPTJC(J)	;UPDATE TOTALS TABLE
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,CPTJC(J)	;WANT TOTALS
	PUSHJ	P,CALCPT	;CALCULATE CONTEXT SWITCHES PER SECOND
	PUSHJ	P,DECB3		;PRINT CONTEXT SWITCHES PER SECOND

;SHOW CPU MONITOR CALLS ("UUO'S") PER SECOND

	PUSHJ	P,TAB		;TAB OVER TO UUOS
	MOVE	A,[%CVTUC]	;UUO COUNT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	SUB	A,CPTUC(J)	;A := INCREMENTAL VALUE
	ADDM	A,CPTUC(J)	;UPDATE TOTALS TABLE
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,CPTUC(J)	;WANT TOTALS
	PUSHJ	P,CALCPT	;CALCULATE UUOS PER SECOND
	PUSHJ	P,DECB3		;PRINT UUOS PER SECOND

;SHOW INTER-CPU DOORBELLS PER SECOND (IF APPLICABLE)

	SKIPN	CPMNY		;ON A MULTI-CPU SYSTEM?
	JRST	CPULP5		;NO
	PUSHJ	P,TAB		;YES, TAB OVER TO DOORBELLS COLUMN
	MOVE	A,[%CVNDB]	;NUMBER OF TIMES DOORBELL RUNG
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	SUB	A,CPNDB(J)	;A := INCREMENTAL VALUE
	ADDM	A,CPNDB(J)	;UPDATE TOTALS TABLE
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,CPNDB(J)	;WANT TOTALS
	PUSHJ	P,CALCPT	;CALCULATE DOORBELLS PER SECOND
	PUSHJ	P,DECB3		;PRINT DOORBELLS PER SECOND

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;SHOW CPU CACHE SWEEPS PER SECOND (IF APPLICABLE)

CPULP5:	SKIPN	CPCSH		;WATCHING CACHE FLUSHES?
	JRST	CPULP7		;NO, NO CACHE SWEEPS THEN
	PUSHJ	P,TAB		;YES, TAB OVER
	MOVE	A,[%CVCSN]	;CACHE SWEEPS SINCE RELOAD
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	SUB	A,CPCSN(J)	;A := INCREMENTAL VALUE
	ADDM	A,CPCSN(J)	;UPDATE TOTALS TABLE
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,CPCSN(J)	;WANT TOTALS
	PUSHJ	P,CALCPT	;CALCULATE CACHE SWEEPS PER SECOND
	PUSHJ	P,DECB3		;PRINT CACHE SWEEPS PER SECOND

;CALCULATE CPU CLOCK RATE IN CASE BPA STUFF TURNED ON

	MOVE	A,[%CCEBS]	;EBOX TICKS PER SECOND
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ IT
	IDIV	A,[^D500000]	;CONVERT TO MHZ FOR BPA STUFF
	CAIGE	A,0		;JUST TO MAKE SURE
	SETZ	A,		;. . .
	MOVEM	A,CPMHZ(J)	;SAVE CPU CLOCK RATE

CPULP7:	PUSHJ	P,CRLF		;END OF THIS LINE

	JRST	CPULP0		;CHECK OUT ANY MORE CPU'S

CPULP9:!
	SUBTTL	"N" DISPLAY  --  FILE AND SWAPPING I/O COUNTS

CPUIO:	TABSET	TAB1IO		;SET NEAT TABS FOR I/O
	MOVEI	M,[ASCIZ\	DSKI	DSKO	SWPI	SWPO	MTAI	MTAO
\]				;COLUMN HEADER
	PUSHJ	P,MSG		;LABEL COLUMNS
	SETOM	CPU		;START WITH CPU -1

CPUIO0:	AOS	J,CPU		;NEXT CPU
	CAML	J,CPMAX		;REACHED END YET?
	JRST	CPUIO9		;YES, EXIT THIS STUFF
	ASH	J,1		;DOUBLE WORD INDEX
	SKIPE	CPOKF(J)	;IS CPU RUNNING OK?
	JRST	CPUIO0		;CPU KNOWN NOT RUNNING
	MOVE	A,CPNAM(J)	;GET THIS CPU'S NAME
	PUSHJ	P,SIXTAB	;AND TYPE IT OUT

;LIST FILE BLOCKS PER SECOND INPUT

	MOVE	A,[%CVFBI]	;FILE BLOCKS INPUT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ FROM MONITOR
	SUB	A,CPFBI(J)	;A := INCREMENTAL
	ADDM	A,CPFBI(J)	;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL MODE?
	MOVE	A,CPFBI(J)	;TOTAL
	PUSHJ	P,CALCTT	;CALCULATE PER-SECOND FIGURE
	PUSHJ	P,DECB4		;PRINT PER-SECOND FILE READS

;LIST FILE BLOCKS PER SECOND OUTPUT

	PUSHJ	P,TAB		;SPACE OVER
	MOVE	A,[%CVFBO]	;FILE BLOCKS OUTPUT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ FROM MONITOR
	SUB	A,CPFBO(J)	;A := INCREMENTAL
	ADDM	A,CPFBO(J)	;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,CPFBO(J)	;TOTALS
	PUSHJ	P,CALCTT	;CALCULATE PER-SECOND FILE WRITES
	PUSHJ	P,DECB4		;PRINT PER-SECOND FILE WRITES

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;LIST SWAP BLOCKS PER SECOND INPUT

CPUIO2:	PUSHJ	P,TAB		;SPACE OVER
	MOVE	A,[%CVSBI]	;SWAP BLOCKS INPUT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ FROM MONITOR
	SUB	A,CPSBI(J)	;A := INCREMENTAL
	ADDM	A,CPSBI(J)	;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,CPSBI(J)	;TOTAL
	PUSHJ	P,CALCTT	;CALCULATE PER-SECOND SWAP READS
	PUSHJ	P,DECB4		;PRINT PER-SECOND SWAP READS

;LIST SWAP BLOCKS PER SECOND OUTPUT

	PUSHJ	P,TAB		;SPACE OVER
	MOVE	A,[%CVSBO]	;SWAP BLOCKS OUTPUT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ FROM MONITOR
	SUB	A,CPSBO(J)	;A := INCREMENTAL
	ADDM	A,CPSBO(J)	;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,CPSBO(J)	;TOTALS
	PUSHJ	P,CALCTT	;CALCULATE PER-SECOND SWAP WRITES
	PUSHJ	P,DECB4		;PRINT PER-SECOND SWAP WRITES

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;LIST MAGTAPE "BLOCKS" PER SECOND INPUT

CPUIO5:	PUSHJ	P,TAB		;SPACE OVER
	MOVE	A,[%CVTFI]	;TAPE FRAMES INPUT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ VALUE
	SUB	A,CPTFI(J)	;A := INCREMENTAL TAPE FRAMES READ
	ADDM	A,CPTFI(J)	;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,CPTFI(J)	;TOTALS
	IDIVI	A,^D5 * ^D128	;CONVERT TO "BLOCKS" (APPROXIMATELY)
	PUSHJ	P,CALCTT	;CALCULATE PER-SECOND TAPE READS
	PUSHJ	P,DECB4		;PRINT PER-SECOND TAPE READS

;LIST MAGTAPE BLOCKS PER SECOND OUTPUT

	PUSHJ	P,TAB		;SPACE OVER
	MOVE	A,[%CVTFO]	;TAPE FRAMES OUTPUT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ VALUE
	SUB	A,CPTFO(J)	;A := INCREMENTAL TAPE FRAMES WRITTEN
	ADDM	A,CPTFO(J)	;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,CPTFO(J)	;TOTALS
	IDIVI	A,^D5 * ^D128	;CONVERT TO "BLOCKS" (APPROXIMATELY)
	PUSHJ	P,CALCTT	;CALCULATE PER-SECOND TAPE WRITES
	PUSHJ	P,DECB4		;PRINT PER-SECOND TAPE WRITES

;CAP OFF THIS CPU I/O STATISTICS

	PUSHJ	P,CRLF		;END OF LINE
	JRST	CPUIO0		;LOOP FOR NEXT CPU

CPUIO9:!			;END OF CPU DISK I/O
	SUBTTL	"N" DISPLAY  --  KL-10 RH20 CHANNEL USAGE

;IT SHOULD BE NOTED (LEST CONFUSION ARISE) THAT THE PERCENTAGES CAL-
;CULATED HERE ARE NOT RH20 USAGE, BUT RATHER RH20 TO MBOX USAGE, AND
;AS SUCH CAN VARY WIDELY (COMME, PAR EXAMPLE, A FACTOR OF TEN) FROM WHAT
;ONE MIGHT INTUITIVELY EXPECT THE NUMBERS TO BE. TYPICALLY THE MORE THE
;SYSTEM IS BEAT UPON (CHANNELS ACTIVE, SWEEPING CACHE, ETC.) THE HIGHER
;THE CHANNEL PERCENTAGES WILL BE FOR THE SAME (!) AMOUNT OF THROUGHPUT.

CPUCH:	TABSET	TAB1CP		;SET NEAT TABS
	MOVEI	M,[ASCIZ\	CH0	CH1	CH2	CH3	CH4	CH5	CH6	CH7
\]				;COLUMN HEADER
	MOVEM	M,CPHDR		;SAVE FOR FIRST OCCURENCE
	SETOM	CPU		;START WITH CPU -1

;LOOP OVER EACH CPU IN SYSTEM

CPUCH0:	AOS	J,CPU		;NEXT CPU
	CAML	J,CPMAX		;DONE LAST ONE YET?
	JRST	CPUCH9		;YES, EXIT CHANNEL PERCENTAGES
	ASH	J,1		;%CCXXX/%CVXXX DOUBLE WORD INDEX
	SKIPE	CPOKF(J)	;IS CPU RUNNING OK?
	JRST	CPUCH0		;CPU KNOWN NOT RUNNING
	MOVE	A,[%CVBPF]	;SEE IF PERF ANAL COUNTS BEING KEPT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;AND READ MONITOR'S COUNTER FLAG
	JUMPGE	A,CPUCH0	;SKIP THIS CPU IF NOT COUNTING
	MOVE	A,[%CCBPA]	;PERF ANAL COUNT SUBTABLE POINTER
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ FROM CDB
	JUMPE	A,CPUCH0	;NONE FOR THIS CPU
	TXNN	A,777B8		;GOT A LENGTH?
	JRST	CPUCH0		;NO, SKIP THIS CPU
	HRLZM	A,CPRLX		;SAVE REL OFFSET INTO CDB
	SKIPE	M,CPHDR		;GIVEN COLUMN HEADER YET?
	PUSHJ	P,MSG		;NO, LABEL THE COLUMNS
	SETZM	CPHDR		;NOTE COLUMNS HAVE BEEN IDENTIFIED
	MOVE	A,CPNAM(J)	;NOW GET THIS CPU'S NAME
	PUSHJ	P,SIXBP		;TYPE IT OUT
	MOVE	JS,[-10,,%CVCH0];PRESET JS INDEX FOR RH20 CHANNELS
	PUSHJ	P,CPLQR		;DO ALL THE WORK
	JRST	CPUCH0		;TRY FOR ANOTHER CPU

CPUCH9:!			;END OF KL-10 CHANNEL USAGE
	SUBTTL	"N" DISPLAY -- KL-10 PI CHANNEL USAGE

CPUPI:	TABSET	TAB1CP		;SET NEAT TABS
	MOVEI	M,[ASCIZ\	PI0	PI1	PI2	PI3	PI4	PI5	PI6	PI7
\]				;COLUMN HEADER
	MOVEM	M,CPHDR		;SAVE FOR FIRST OCCURENCE
	SETOM	CPU		;START WITH CPU -1

;LOOP OVER EACH CPU IN SYSTEM

CPUPI0:	AOS	J,CPU		;NEXT CPU
	CAML	J,CPMAX		;DONE LAST ONE YET?
	JRST	CPUPI9		;YES, EXIT PI PERCENTAGES
	ASH	J,1		;%CCXXX/%CVXXX DOUBLE WORD INDEX
	SKIPE	CPOKF(J)	;IS CPU RUNNING OK?
	JRST	CPUPI0		;CPU KNOWN NOT RUNNING
	MOVE	A,[%CVBPF]	;SEE IF PERF ANAL COUNTS BEING KEPT
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;AND READ MONITOR'S COUNTER FLAG
	JUMPGE	A,CPUPI0	;SKIP THIS CPU IF NOT COUNTING
	MOVE	A,[%CCBPA]	;PERF ANAL COUNT SUBTABLE POINTER
	ADD	A,J		;OFFSET FOR THIS CPU
	PUSHJ	P,GETZ		;READ FROM CDB
	JUMPE	A,CPUPI0	;NONE FOR THIS CPU
	TXNN	A,777B8		;GOT A LENGTH?
	JRST	CPUPI0		;NO, SKIP THIS CPU
	HRLZM	A,CPRLX		;SAVE REL OFFSET INTO CDB
	SKIPE	M,CPHDR		;GIVEN COLUMN HEADER YET?
	PUSHJ	P,MSG		;NO, LABEL THE COLUMNS
	SETZM	CPHDR		;NOTE COLUMNS HAVE BEEN IDENTIFIED
	MOVE	A,CPNAM(J)	;NOW GET THIS CPU'S NAME
	PUSHJ	P,SIXBP		;TYPE IT OUT
	MOVE	JS,[-10,,%CVPI0];PRESET JS INDEX FOR PI CHANNELS
	PUSHJ	P,CPLQR		;DO ALL THE WORK
	JRST	CPUPI0		;TRY FOR ANOTHER CPU

CPUPI9:	JRST	NETLA		;END OF KL-10 PI USAGE
;STUFF FOR CPU STATISTICS ABOVE

;CPLQR  --  LOOP THROUGH KL10 PERF ANAL SUBTABLE PRINTING PERCENTAGES

CPLQR0:	ADDI	JS,3		;SUBTABLE IS IN 4 WORD BLOCKS
CPLQR:	HRLZI	A,(JS)		;SUBTABLE ITEM
	ADD	A,CPRLX		;RELOCATE INTO %CVXXX TABLE
	HRRI	A,.GTC0V(J)	;RELOCATE INTO CDB (GETTAB)
	PUSHJ	P,GET4		;READ 4 WORDS
	 PJRST	CRLF		;IT'S ALL OVER
	ASHC	A,-^D12		;A'B := TOTAL ELAPSED TIME IN USEC
	ASHC	C,-^D12		;C'D := CPU CYCLES / 2
	DMOVE	N,A		;HOLD ELAPSED TIME
	DSUB	A,@CIELT(J)	;A'B := INCREMENTAL ELAPSED TIME
	DMOVEM	N,@CIELT(J)	;SET NEW TOTAL ELAPSED TIME
	TLNE	F,FL.INC	;INCREMENTAL OR TOTAL?
	DMOVE	N,A		;N'N1 := ELAPSED TIME (USEC)
	DMOVE	A,C		;TEMP COPY
	DSUB	A,@CIELC(J)	;A'B := INCREMENTAL PERF COUNT
	DMOVEM	C,@CIELC(J)	;SET NEW TOTAL PERF COUNT
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	DMOVE	A,C		;A'B := PERF COUNT
	DMUL	A,[EXP 0,^D20000]  ;PERCENTAGE FIGURE
				; (CPU CYCLES * ^D100 * ^D100)
	DDIV	A,CPMHD(J)	;DIVIDE BY CLOCK RATE (IN MHZ)
	DMOVE	C,A		;DDIV WANTS QUAD WORD
	SETZB	A,B		;A'B'C'D := PERF USEC COUNT * ^D10000
	DDIV	A,N		;A'B := PERCENTAGE (HUNDREDTHS)
	ASHC	C,1		;ROUND UP
	DSUB	C,N		;(DON'T HAVE DCAM??)
	CAILE	C,0		;HALFWAY TO NEXT POINT?
	ADDI	B,1		;YES
	MOVE	N,B		;PUT WHERE DECOUT CAN FIND IT
	PUSHJ	P,TAB		;SEPARATE COLUMNS
	PUSHJ	P,CPCPT		;TYPE OUT PERCENTAGE
	AOBJN	JS,CPLQR0	;LOOP FOR REST OF LINE
	PJRST	CRLF		;CAP OFF LINE
;CDB SUBTABLE INDEX POINTERS

CIELT:	Z	CP0PAV(JS)	;CPU0 PERF ITEMS (ELAPSED)
CIELC:	Z	CP0PAV+2(JS)	;CPU0 PERF ITEMS (COUNT)
	Z	CP1PAV(JS)	;CPU1 PERF ITEMS (ELAPSED)
	Z	CP1PAV+2(JS)	;CPU1 PERF ITEMS (COUNT)
	Z	CP2PAV(JS)	;CPU2 PERF ITEMS (ELAPSED)
	Z	CP2PAV+2(JS)	;CPU2 PERF ITEMS (COUNT)
	Z	CP3PAV(JS)	;CPU3 PERF ITEMS (ELAPSED)
	Z	CP3PAV+2(JS)	;CPU3 PERF ITEMS (COUNT)
	Z	CP4PAV(JS)	;CPU4 PERF ITEMS (ELAPSED)
	Z	CP4PAV+2(JS)	;CPU4 PERF ITEMS (COUNT)
	Z	CP5PAV(JS)	;CPU5 PERF ITEMS (ELAPSED)
	Z	CP5PAV+2(JS)	;CPU5 PERF ITEMS (COUNT)
	SUBTTL	"N" DISPLAY -- ANF NETWORK BYTE I/O STATISTICS

NETLA:	TABSET	TAB1NT		;SET TO NET I/O TABS

;INPUT BYTES PER SECOND PROCESSED

	MOVE	A,[%NTBYI]	;TOTAL INPUT BYTES PROCESSED
	PUSHJ	P,GETZ		;READ FROM MONITOR
	JUMPE	A,NETLA9	;SKIP ANF SUMMARY IF NOTHING THERE
	MOVEI	M,[ASCIZ\ANF In:\] ;IDENTIFY ANF SUMMARY
	PUSHJ	P,MSG		;PREFIX INPUT COUNT
	SUB	A,NABYI		;A := INCREMENTAL
	ADDM	A,NABYI		;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,NABYI		;TOTALS
	PUSHJ	P,CMPCTT	;BYTES PER SECOND

;OUTPUT BYTES PROCESSED PER SECOND

	MOVEI	M,[ASCIZ\	Out:\] ;PREFIX OUT
	PUSHJ	P,MSG		;TELL USER
	MOVE	A,[%NTBYO]	;TOTAL OUTPUT BYTES PROCESSED
	PUSHJ	P,GETZ		;READ FROM MONITOR
	SUB	A,NABYO		;A := INCREMENTAL
	ADDM	A,NABYO		;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTALS?
	MOVE	A,NABYO		;TOTALS
	PUSHJ	P,CMPCTT	;BYTES PER SECOND

;MONITOR FREE CORE USED

	MOVEI	M,[ASCIZ\	Cor:\] ;PREFIX MSG
	MOVE	A,[%NTCOR]	;NETWORK CORE IN USE
	PUSHJ	P,GETZ		;READ FROM MONITOR
	MOVE	N,A		;POSITION FOR DECPRT
	PUSHJ	P,MSGDEC	;TYPE OUT PREFIX AND MESSAGE

;CAP OFF LINE

	PUSHJ	P,CRLF		;END OF ANF NET I/O STATISTICS

NETLA9:!

;FALL INTO NETLD
	SUBTTL	"N" DISPLAY -- DECNET NETWORK BYTE I/O STATISTICS

NETLD:	TABSET	TAB1NT		;SET TO NET I/O TABS

;FIRST TRACK DOWN THE NETWORK BYTES

	SKIPE	CPKS10		;[633] ON A KS-10?
	JRST	NETLD9		;[633] YES, FORGET IT (KS/DECNET IS INSANE)
	MOVE	A,[%DNRCH]	;BASE OF DECNET'S CIRCUIT BLOCKS
	PUSHJ	P,GETZ		;READ MONITOR/GETTAB VALUE
	JUMPE	A,NETLD9	;NO BYTES IF NO CIRCUIT BLOCKS!
	MOVEI	M,[ASCIZ\DCN In:\] ;IDENTIFY DECNET SUMMARY
	PUSHJ	P,MSG		;PREFIX INPUT COUNT
	SETZB	C,D		;INITIAL BYTE COUNTS ACCUMULATED
NETLD1:	PUSHJ	P,MPEEK		;GET ADDRESS OF NEXT CIRCUIT BLOCK
	SKIPN	J,A		;PROTECT CURRENT CIRCUIT BLOCK ADDRESS
	JRST	NETLD3		;NO MORE CIRCUIT BLOCKS, PRINT COUNT
	ADDI	A,$RCDLB	;OFFSET TO ASSOCIATED DLL BLOCK
	PUSHJ	P,MPEEK		;GET ADDRESS OF DLL BLOCK FOR THIS CIRCUIT
	PUSH	P,A		;SAFE COPY OF DLL BLOCK
	ADDI	A,$DLBYR	;OFFSET TO BYTES RECEIVED
	PUSHJ	P,MPEEK		;READ BYTES RECEIVED ON THIS CIRCUIT
	ADD	C,A		;AND ACCUMULATE DECNET BYTES RECEIVED
	POP	P,A		;RETRIEVE ADDRESS OF DLL BLOCK AGAIN
	ADDI	A,$DLBYS	;OFFSET TO BYTES SENT
	PUSHJ	P,MPEEK		;READ BYTES SENT ON THIS CIRCUIT
	ADD	D,A		;AND ACCUMULATE DECNET BYTES SENT
	MOVE	A,J		;RESET BASE ADDRESS OF CIRCUIT BLOCK
	ADDI	A,$RCNXT	;OFFSET TO POINTER TO NEXT CIRCUIT BLOCK
	JRST	NETLD1		;LOOP BACK FOR REST OF THE CIRCUIT BLOCKS

;[634] COUNT IN ETHERNET BYTES ALSO

NETLD3:	PUSH	P,D		;[634] PRESERVE OUTPUT COUNT TO DATE
	PUSH	P,C		;[634] PRESERVE INPUT COUNT TO DATE
	PUSHJ	P,ETHRCL	;[634] READ IN LIST OF ETH-0/ETC.
	 JRST	NETLD7		;[634] NONE, NO ETHERNET?
	MOVE	T1,RCLBUF	;[634] GET ETH-0 CHANNEL ID
	PUSHJ	P,ETHRPL	;[634] READ ETH-0 PORTAL LIST
	 JRST	NETLD7		;[634] FAILED??? NO ETHERNET COUNTS THEN.
	MOVSI	P1,-RPLBFL	;[634] AOBJN INDEX COUNTER FOR PORTAL LIST
NETLD4:	MOVE	T1,RPLBUF(P1)	;[634] NEXT "PORTAL ID"
	PUSHJ	P,ETHRPI	;[634] READ PORTAL INFORMATION
	 JRST	NETLD5		;[634] FAILED, SKIP THIS PORTAL
	HRRZ	T2,RPIBUF+.EIPPI;[634] PORTAL PROTOCOL
	CAIE	T2,60003	;[634] IS THIS DECNET (PROTOCOL 60-03)?
	JRST	NETLD5		;[634] NOPE, SKIP IT
	MOVE	T1,RPLBUF(P1)	;[634] YUP, GET PORTAL ID BACK AGAIN
	PUSHJ	P,ETHRPC	;[634] AND READ THE PORTAL COUNTERS
	 JRST	NETLD5		;[634] FAILED???
	MOVE	T2,RPCBUF+.ECPBR;[634] DECNET/ETHERNET BYTES RECEIVED
	ADDM	T2,0(P)		;[634] ACCUMULATE TOTAL DECNET BYTES
	MOVE	T2,RPCBUF+.ECPBX;[634] DECNET/ETHERNET BYTES TRANSMITTED
	ADDM	T2,-1(P)	;[634] ACCUMULATE TOTAL DECNET BYTES
NETLD5:	AOBJN	P1,NETLD4	;[634] LOOP FOR ALL PORTALS

;INPUT BYTES PER SECOND PROCESSED

NETLD7:	POP	P,A		;[634] RETRIEVE DECNET BYTES RECEIVED
	SUB	A,NDBYI		;A := INCREMENTAL
	ADDM	A,NDBYI		;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,NDBYI		;TOTALS
	PUSHJ	P,CMPCTT	;BYTES PER SECOND

;OUTPUT BYTES PROCESSED PER SECOND

	MOVEI	M,[ASCIZ\	Out:\] ;PREFIX OUT
	PUSHJ	P,MSG		;TELL USER
	POP	P,A		;RETRIEVE ACCUMULATE OUTPUT TOTAL
	SUB	A,NDBYO		;A := INCREMENTAL
	ADDM	A,NDBYO		;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTALS?
	MOVE	A,NDBYO		;TOTALS
	PUSHJ	P,CMPCTT	;BYTES PER SECOND

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;MESSAGE BLOCK USAGE (MOST USEFUL "CONCISE" MEMORY VALUE FOR DECNET)

	MOVE	A,[%DNCHB]	;GETTAB POINTER TO READ
	PUSHJ	P,GETZ		;BASE POINTER TO DECNET "CH" POOL(S)
	ADDI	A,$CHLEN	;SKIP OVER EVENT BLOCKS, POINT TO MSG BLOCKS
	MOVE	J,A		;SAVE BASE ADDRESS
	SETZ	N,		;ACCUMULATE CORE ALLOCATION
	ADDI	A,$CHALC	;OFFSET TO ALLOCATED QUANTITIES
	PUSHJ	P,MPEEK		;GET ALLOCATION
	LDB	N,[POINTR A,CH$NUM]  ;N := NUMBER OF CHUNKS ALLOCATED
	MOVEM	N,TEMP		;SAVE FOR PERCENTAGE CALCULATION
	MOVE	A,J		;CH BLOCK AGAIN
	ADDI	A,$CHAVL	;OFFSET TO COUNT OF CHUNKS AVAILABLE
	PUSHJ	P,MPEEK		;GET COUNT OF CHUNKS REMAINING
	SUBB	N,A		;N := COUNT OF MSG BLOCKS IN USE
	MOVEI	M,[ASCIZ\	Blk:\] ;PREFIX MSG
	PUSHJ	P,MSGDEC	;TYPE OUT PREFIX AND MESSAGE
	MOVEI	M,[ASCIZ\/\]	;SEPARATE WITH A "/"
	MOVE	N,TEMP		;N := COUNT OF MESSAGE BLOCKS ALLOCATED
	PUSHJ	P,MSGDEC	;CAP OFF MESSAGE BLOCK SUMMARY
	MOVEI	CH,"="		;SEPARATE ABSOLUTE USAGES
	PUSHJ	P,TYO		; FROM FOLLOWING PERCENTAGE
	PUSHJ	P,CMPCNA	;TYPE OUT PERCENTAGE IN USE
	MOVEI	CH,"%"		;TELL USER IT IS
	PUSHJ	P,TYO		;A PERCENTAGE VALUE

;CAP OFF LINE

	PUSHJ	P,CRLF		;END OF NET I/O STATISTICS

NETLD9:!

;FALL INTO NETLE
	SUBTTL	"N" DISPLAY -- ETHERNET BYTE I/O STATISTICS

NETLE:	TABSET	TAB1NT		;SET TO NET I/O TABS

;INPUT BYTES PER SECOND

	MOVE	A,[%EIBYR]	;ETHERNET BYTES RECEIVED
	PUSHJ	P,GETZ		;QUERY THE MONITOR
	JUMPE	A,NETLE9	;PUNT IF NO ACTIVITY (ASSUME NO KLNI)
	MOVEI	M,[ASCIZ\ETH In:\]  ;IDENTIFY ETHERNET ACTIVITY
	PUSHJ	P,MSG		;START UP LINE OF DISPLAY
	SUB	A,NEBYI		;A:=INCREMENTAL BYTES RECEIVED
	ADDM	A,NEBYI		;UPDATE TO-DATE TOTALS
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS?
	MOVE	A,NEBYI		;TOTALS
	PUSHJ	P,CMPCTT	;LIST BYTES RECEIVED PER SECOND

;ETHERNET BYTES SENT PER SECOND

	MOVEI	M,[ASCIZ\	Out:\]  ;PREFIX XMIT COUNT
	PUSHJ	P,MSG		;IDENTIFY NEXT COLUMN
	MOVE	A,[%EIBYX]	;TOTAL BYTES TRANSMITTED
	PUSHJ	P,GETZ		;READ FROM MONITOR
	SUB	A,NEBYO		;A:=INCREMENTAL
	ADDM	A,NEBYO		;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTALS OR TOTALS?
	MOVE	A,NEBYO		;TOTALS
	PUSHJ	P,CMPCTT	;LIST BYTES XMITED PER SECOND

;ETHERNET DATAGRAMS/SECOND (IN/OUT)

	MOVEI	M,[ASCIZ\	Dgm:\]  ;PREFIX DATAGRAMS
	PUSHJ	P,MSG		;TELL USER
	MOVE	A,[%EIDGR]	;TOTAL DATAGRAMS RECEIVED
	PUSHJ	P,GETZ		;READ FROM MONITOR
	SUB	A,NEDGI		;A:=INCREMENTAL
	ADDM	A,NEDGI		;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTALS OR TOTALS?
	MOVE	A,NEDGI		;TOTALS
	PUSHJ	P,CMPCTT	;LIST DATAGRAMS RECEIVED PER SECOND
	MOVEI	M,[ASCIZ\/\]	;SEPARATE WITH A "/"
	PUSHJ	P,MSG		;LIST
	MOVE	A,[%EIDGX]	;DATAGRAMS XMITED
	PUSHJ	P,GETZ		;READ FROM MONITOR
	SUB	A,NEDGO		;A:=INCREMENTAL
	ADDM	A,NEDGO		;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTALS OR TOTALS?
	MOVE	A,NEDGO		;TOTALS
	PUSHJ	P,CMPCTT	;DATAGRAMS TRANSMITTED PER SECOND

;CAP OFF LINE

	PUSHJ	P,CRLF		;END OF ETHERNET STATISTICS

NETLE9:

;FALL INTO TTYLP
	SUBTTL	"N" DISPLAY -- TTY CHARACTER I/O STATISTICS

TTYLP:	TABSET	TAB1TT		;CHANGE TAB STOPS FOR TTY STATS
	MOVEI	M,[ASCIZ/TTY In:/] ;SHOW TTY STATISTICS
	PUSHJ	P,MSG		;PREPARE USER

;INPUT CHARACTERS RECEIVED

	MOVE	A,[%SCNRI]	;TOTAL RECEIVED CHARACTERS
	PUSHJ	P,GETZ		;READ IT
	SUB	A,SCNRI		;A := INCREMENTAL VALUE
	ADDM	A,SCNRI		;UPDATE TOTALS
	TLNN	F,FL.INC	;WANT INCREMENTALS OR TOTALS
	MOVE	A,SCNRI		;TOTALS
	PUSHJ	P,CMPCTT	;RECEIVED CHARACTERS PER SECOND

;OUTPUT CHARACTERS TRANSMITTED

	MOVEI	M,[ASCIZ/	Out:/]  ;SHOW OUTPUT
	PUSHJ	P,MSG		;PREPARE USER
	MOVE	A,[%SCNXI]	;TOTAL CHARACTERS SENT
	PUSHJ	P,GETZ		;READ IT
	SUB	A,SCNXI		;A := INCREMENTAL
	ADDM	A,SCNXI		;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTALS OR TOTALS?
	MOVE	A,SCNXI		;TOTALS
	PUSHJ	P,CMPCTT	;TRANSMITTED CHARACTERS PER SECOND

;CHUNKS IN USE (PERCENTAGE)

	MOVE	A,[%CNTTC]	;TOTAL CHUNKS COUNT
	PUSHJ	P,GETZ		;READ IT
	HLREM	A,TEMP		;SAVE TOTAL FOR PERCENTAGE CALC
	MOVE	A,[%CNTTN]	;TOTAL NUMBER OF FREE CHUNKS
	PUSHJ	P,GETZ		;READ IT
	MOVN	A,A		;ACTUALLY WANT CHUNKS USED
	ADD	A,TEMP		;A := CHUNKS USED
	MOVE	N,A		;N := CHUNKS USED
	MOVEI	M,[ASCIZ/	Cnk:/]  ;LABEL IT
	PUSHJ	P,MSGDEC	;TYPE OUT CHUNKS IN USE
	MOVEI	M,[ASCIZ\/\]	;SEPARATE WITH A "/"
	MOVE	N,TEMP		;N := TOTAL CHUNKS ALLOCATED
	PUSHJ	P,MSGDEC	;DISPLAY "USE/ALLOC"
	MOVEI	CH,"="		;SEPARATE ABSOLUTE VALUE
	PUSHJ	P,TYO		; FROM PERCENTAGE FOLLOWING
	PUSHJ	P,CMPCNA	;TYPE OUT PERCENTAGE CHUNKS USED
	MOVEI	CH,"%"		;TELL USER THAT NUMBER
	PUSHJ	P,TYO		;IS A PERCENTAGE

	PUSHJ	P,CRLF		;END OF TTY STATISTICS

TTYLP9:!

;FALL INTO IPCF STATISTICS
	SUBTTL	"N" DISPLAY -- IPCF STATISTICS

IPCLP:	MOVE	A,[%IPCTS]	;GETTAB ARGUMENT TO
	PUSHJ	P,GETZ		;READ TOTAL IPCF PACKETS SENT
	JUMPE	A,IPCLP9	;IF NONE AT ALL, JUST DISAPPEAR

;TOTAL PACKETS SENT, PER MINUTE

	MOVEI	M,[ASCIZ\IPCF S:\]  ;IDENTIFY IPCF STUFF
	PUSHJ	P,MSG		;TELL USER
	SUB	A,IPCTS		;A := INCREMENTAL PACKETS SENT
	ADDM	A,IPCTS		;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,IPCTS		;TOTAL
	IMULI	A,^D60		;LIST PER MINUTE
	PUSHJ	P,CMPCTT	;IPCF PACKETS PER MINUTE

;TOTAL PACKETS OUTSTANDING

	MOVE	A,[%IPCTO]	;GETTAB ARGUMENT TO
	PUSHJ	P,GETZ		;READ IPCF PACKETS OUTSTANDING
	MOVE	N,A		;POSITION IN "N" FOR DECPRT
	MOVEI	M,[ASCIZ\	Out:\]  ;PREFIX
	PUSHJ	P,MSGDEC	;LIST OUTSTANDING IPCF

;IPCF RATE

	MOVEI	M,[ASCIZ\	W/P:\]  ;IDENTIFY WORDS/PAGES PER MINUTE
	PUSHJ	P,MSG		;TO THE USER
	MOVE	A,[%IPTWT]	;GETTAB ARGUMENT TO
	PUSHJ	P,GETZ		;READ TOTAL WORDS TRANSFERED
	SUB	A,IPTWT		;A := INCREMENTAL WORDS
	ADDM	A,IPTWT		;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,IPTWT		;TOTAL
	IMULI	A,^D60		;LIST PER MINUTE
	PUSHJ	P,CMPCTT	;PRINT WORDS PER MINUTE
	MOVEI	CH,"/"		;SEPARATE FROM PAGES
	PUSHJ	P,TYO		;WITH A "/" CHARACTER
	MOVE	A,[%IPTPT]	;GETTAB ARGUMENT TO
	PUSHJ	P,GETZ		;READ TOTAL PAGES TRANSFERED
	SUB	A,IPTPT		;A := INCREMENTAL PAGES
	ADDM	A,IPTPT		;UPDATE TOTALS
	TLNN	F,FL.INC	;INCREMENTAL OR TOTALS?
	MOVE	A,IPTPT		;TOTALS
	IMULI	A,^D60		;LIST PER MINUTE
	PUSHJ	P,CMPCTT	;PRINT PAGES PER MINUTE

;CAP OFF IPCF DISPLAY

	PUSHJ	P,CRLF		;END OF LINE

IPCLP9:!

;FALL INTO MEMORY UTILIZATION STATISTICS
	SUBTTL	"N" DISPLAY -- MEMORY AVAILABILITY AND JOB LOADING STATISTICS

MEMLP:	MOVX	A,%NSCMX	;GET CORMAX VALUE
	PUSHJ	P,GETA		;FROM MONITOR
	MOVEM	A,CORMAX	;SAVE FOR MOMENT
	MOVEM	A,N		;HOLD HERE ALSO
	MOVX	A,%NSMXM	;GET MAX USER MEMORY SPACE
	PUSHJ	P,GETA		;FROM MONITOR
	MOVEM	A,MAXMAX	;SAVE FOR MOMENT
	MOVX	A,%CNNWC	;TOTAL (MAX) WORDS OF MEMORY
	PUSHJ	P,GETA		;READ FROM MONITOR
	MOVE	B,A		;HOLD ONTO IT FOR A MOMENT
	HLRZ	A,B		;"SECTIONS" USED BY PHYSICAL MEMORY
	LSH	A,@P2WLSH	;CONVERT TO WORDS USED FOR MAPPING
	SUB	B,A		;ALLOW FOR MEMTAB
	SUB	B,A		;ALLOW FOR PAGTAB
	MOVX	A,%CNSIZ	;GET SIZE OF MONITOR LOW SEG
	PUSHJ	P,GETA		;FROM MONITOR
	SUB	B,A		;SUBTRACT FROM TOTAL
	MOVX	A,%CNMXF	;GET FINAL VIRTUAL ADDRESS
	PUSHJ	P,GETZ		;OF MONITOR HIGHSEG
	JUMPE	A,MEMLP1	;IF PRE-7.01335 USE OLD VALUE
	SUB	B,A		;REMOVE FROM PHYSICAL MEM AVAILABLE
	MOVX	A,%CNVSH	;GET FIRST VIRTUAL ADDRESS
	PUSHJ	P,GET		;OF MONITOR HIGH SEGMENT
	 MOVEI	A,453000	;DEFAULT
	ADD	B,A		;ALLOW FOR MONITOR HIGH SEGMENT
	JRST	MEMLP2		;B := MAX POSSIBLE MAXMAX
MEMLP1:	MOVX	A,%CNHSL	;OLD (PRE-HIGHSEG-LDB DAYS) LENGTH
	PUSHJ	P,GETA		;OF MONITOR HIGH SEG
	SUB	B,A		;B := MAX POSSIBLE MAXMAX
MEMLP2:	MOVEM	B,PHYMAX	;REMEMBER IT

;CORMAX := MAXIMUM SINGLE USER PHYSICAL MEMORY AVAILABLE
;MAXMAX := MAXIMUM TOTAL USER PHYSICAL MEMORY AVAILABLE (INCL LOCKED)
;PHYMAX := MAXIMUM PHYSICAL MEMORY AVAILABLE AFTER MONITOR
;
;CORMAX .LE. MAXMAX .LE. PHYMAX (MAXMAX .LT. PHYMAX MEANS SOMEONE HAS
;PUT SOME MEMORY OFFLINE - I.E., THERE IS A HOLE IN MEMORY SOMEWHERE)

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;PRINT THE VARIOUS PHYSICAL MEMORY VALUES

	MOVEI	M,[ASCIZ /Mem:/]
	LSH	N,@W2PLSH	;MAXIMUM SINGLE USER SIZE
	PUSHJ	P,MSGDEC	;ISSUE
	MOVE	A,MAXMAX	;MAXIMUM USER SPACE AVAILABLE
	CAMN	A,CORMAX	;CORMAX SAME AS MAXMAX
	CAME	A,B		;AS WELL AS PHYMAX?
	CAIA			;NO
	JRST	MEMLP4		;ALL THREE THE SAME
	MOVEI	M,[ASCIZ \/\]
	MOVE	N,A		;GET CORMAX WHERE DECOUT WANTS IT
	LSH	N,@W2PLSH	;CONVERT TO PAGE COUNT
	CAMN	A,CORMAX	;CORMAX AND MAXMAX THE SAME?
	PUSHJ	P,MSG		;YES, THEN PHYMAX DIFFERENT
	CAME	A,CORMAX	;CORMAX AND MAXMAX THE SAME?
	PUSHJ	P,MSGDEC	;NO, LIST MAXMAX AS WELL
;RDH	MOVE	N,B		;GET PHYMAX FOR DECOUT
;RDH	LSH	N,@W2PLSH	;AND MAKE INTO PAGE COUNT
;RDH	MOVEI	M,[ASCIZ\/\]	;SEPARATOR
;RDH	CAME	A,B		;MAXMAX AND PHYMAX THE SAME?
;RDH	PUSHJ	P,MSGDEC	;NO, LIST PHYMAX AS WELL THEN
;RDH				;WE CAN'T GET IT "RIGHT" ANYMORE, SO PUNT IT

;NOW LIST MEMORY SPACE SAVED BY SHARING PAGES (HIGHSEGS)

MEMLP4:	MOVEI	M,[ASCIZ / Shr:/]
	MOVE	N,SHRSAV	;MEMORY SAVED BY SHARING
	PUSHJ	P,MSGDEC	;PRINT MEM SAVED BY SHARING

;DISPLAY ACTIVE JOB LOADING

	MOVEI	M,[ASCIZ\ JRN:\]  ;JOBS RUNNING
	MOVE	N,JRNRN		;JOBS IN RN STATE
	PUSHJ	P,MSGDEC	;LIST THEM
	MOVEI	M,[ASCIZ\/\]	;SEPARATE FROM
	MOVE	N,JRNIO		;JOBS RUNNING OR IO BLOCKED
	PUSHJ	P,MSGDEC	;LIST THEM
	MOVEI	M,[ASCIZ\/\]	;SEPARATE FROM
	MOVE	N,JRNSL		;JOBS NOT ^C'ED
	PUSHJ	P,MSGDEC	;LIST THEM

	PUSHJ	P,CRLF		;START A NEW LINE FOR SWAPPING

;CONTINUED ON NEXT PAGE
	SUBTTL	"N" DISPLAY -- SWAPPING AND VIRTUAL MEMORY USAGE

SWPLP:	MOVEI	M,[ASCIZ/Use:/]
	MOVE	N,PHYUSE	;PHYSICAL (WORKING SET) MEMORY
	PUSHJ	P,MSGDEC	;TELL USER
	MOVEI	M,[ASCIZ\/\]	;SEPARATE WITH A "/"
	MOVE	N,VIRUSE	;TOTAL VIRTUAL PROGRAM SIZES
	CAME	N,PHYUSE	;SAME AS PHYSICAL TOTALS?
	PUSHJ	P,MSGDEC	;NO, TYPE VIRTUAL USE ALSO
	MOVEI	M,[ASCIZ/ Swp:/]
	MOVE	N,VIRUSE	;TOTAL VIRTUAL PROGRAM SIZE
	SUB	N,PHYUSE	;LESS THAT PHYSICALLY USED
	ADD	N,DSKUSE	;PLUS PHYSICAL STUFF SWAPPED
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ \/\]
	MOVE	A,XK4SWP
	PUSHJ	P,GETA
	MOVE	N,A
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ/ ASR:/];GET MESSAGE FOR ACTIVE SWAPPING RATIO
	PUSHJ	P,MSG		;PREFIX ACTIVE SWAPPING RATIO
	MOVE	N,ACTUSE	;TOTAL ACTIVE USER MEMORY (P)
	MOVE	A,MAXMAX	;TOTAL AVAILABLE PHYSICAL MEMORY (W)
	LSH	A,@W2PLSH	;TOTAL AVAILABLE PHYSICAL MEMORY (P)
	IMULI	N,^D100		;CONVERT TO HUNDREDTHS OF PERCENT
	IDIV	N,A		;N:=ASR * ^D100
	PUSHJ	P,CPCPT		;TYPE OUT "PERCENTAGE"
	PUSHJ	P,CRLF		;NEW LINE

;[653] FREE CORE USED DISPLAY
	MOVE	N,[%CNFRU]	;GET NUMBER OF CORE BLOCKS USED
	GETTAB	N,
	  SETZ	N,
	LSH	N,2		;CONVERT TO WORDS
	PUSH	P,N
	MOVEI	M,[ASCIZ/FRU:/]
	PUSHJ	P,MSGDEC	;TYPE CORE USED
	MOVE	N,[%CNFRE]	;GET AOBJN POINTER TO BIT MAP
	GETTAB	N,
	  SETZ	N,
	HLRES	N
	MOVNS	N
	IMULI	N,^D36*^D4	;CONVERT TO WORDS
	PUSH	P,N
	MOVEI	M,[ASCIZ\/\]
	PUSHJ	P,MSGDEC	;TYPE TOTAL
	MOVEI	CH,"="
	PUSHJ	P,TYO
	POP	P,TEMP		;GET TOTAL
	POP	P,A		;GET USED
	PUSHJ	P,CMPDNA	;TYPE PERCENTAGE
	MOVEI	CH,"%"
	PUSHJ	P,TYO
	PUSHJ	P,CRLF

;CONTINUED ON NEXT PAGE
	SUBTTL	"N" DISPLAY -- SCHEDULE, KSYS, AND ERROR COUNTERS

;CONTINUED FROM PREVIOUS PAGE

ERRLP:	SETO	J,		;INITIALIZE COUNTER

;CHECK KSYS (SYSTEM SHUTDOWN) TIMER

	MOVX	A,%NSKTM	;KSYS TIMER
	PUSHJ	P,GETZ		;GET MINUTES TILL KSYS
	JUMPE	A,ERRLP1	;SKIP IF NO KSYS TIMER IN EFFECT
	MOVEI	M,[ASCIZ\KSYS:+\]  ;WARN USER
	CAIGE	A,0		;KSYS ALREADY EXPIRED?
	MOVEI	M,[ASCIZ\KSYS:-\]  ;YES, SO INDICATE
	MOVMS	N,A		;POSITION POSITIVE COUNT OF MINUTES
	PUSHJ	P,MSPDHM	;GIVE KSYS TIMER

;CHECK FOR SYSTEM-WIDE HARDWARE ERRORS

ERRLP1:	MOVX	A,%SYERR	;GET HARDWARE ERROR COUNT
	PUSHJ	P,GETZ		;  OR 0
	MOVEI	M,[ASCIZ/HDE:/]	;HARDWARE ERROR HEADER
	SKIPE	N,A		;MOVE TO AC
	PUSHJ	P,MSPDEC	;PRINT IF NON-ZERO

;CHECK FOR ANY JOB AND/OR DEBUG MONITOR STOPCD'S

	MOVX	A,%SYNDS	;GET SOFTWARE DEBUG STOPS
	PUSHJ	P,GETZ		;  OR 0
	MOVE	B,A		;SAVE AWAY
	MOVX	A,%SYNJS	;GET SOFTWARE JOB STOPS
	PUSHJ	P,GETZ		;  OR 0
	MOVEI	M,[ASCIZ/STP:/]	;SOFTWARE ERROR HEADER
	SKIPN	N,B		;MOVE TO AC
	SKIPE	A		; IF NON-ZERO
	PUSHJ	P,MSPDEC	;  PRINT
	MOVEI	M,[ASCIZ\/\]	;SEPARATE DEBUG AND JOB
	SKIPE	N,A		;GET DEBUG STOPCODES
	PUSHJ	P,MSPDEC	;PRINT IF ANY

;CHECK FOR SYSTEM MAIN MEMORY PARITY ERRORS

	MOVX	A,%NSTPE	;TOTAL SYSTEM MEMORY PARITY ERRORS
	PUSHJ	P,GETZ		;READ FROM MONITOR
	MOVEI	M,[ASCIZ/MPE:/]	;PARITY ERROR HEADER
	SKIPE	N,A		;ANY PARITY ERRORS?
	PUSHJ	P,MSPDEC	;YES, LIST THE COUNT

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;CHECK FOR FILE SYSTEM RETRIEVAL INFORMATION BLOCK ERRORS

	MOVX	A,%LDTOT	;TOTAL FILE SYSTEM RIB ERRORS
	PUSHJ	P,GETZ		;SEE HOW IT'S DOING
	MOVEI	M,[ASCIZ/RIB:/]	;RIB ERROR HEADER
	SKIPE	N,A		;IF ANY RIB ERRORS
	PUSHJ	P,MSPDEC	;TELL OPERATOR

;SHOW COUNT OF POKE.'S DONE TO MONITOR IF NON-ZERO

	MOVX	A,%CNPUC	;JOB,,COUNT OF POKE.'S
	PUSHJ	P,GETZ		;READ FROM MONITOR
	JUMPE	A,ERRLP6	;SKIP IF NO POKE.'S HAVE BEEN DONE
	MOVEI	M,[ASCIZ/POK:/]	;POKE COUNT HEADER
	HRRZ	N,A		;COUNT OF POKE.'S
	PUSHJ	P,MSPDEC	;PRINT OUT COUNT OF POKE.'S
	MOVEI	M,[ASCIZ\/\]	;SEPARATOR
	HLRZ	N,A		;JOB WHICH LAST POKE.'ED
	PUSHJ	P,MSGDEC	;TYPE THAT TOO
ERRLP6:

;SHOW CURRENT RUNNING SCHEDULE (STATES) IF NON-ZERO

	MOVX	A,%CNSTS	;GET SYSTEM STATES
	PUSHJ	P,GETZ		;FROM MONITOR
	ANDI	A,1777		;REDUCE TO SCHEDULING PARMS
	MOVEI	M,[ASCIZ/SCH:/]	;SHOW OPR SCHEDULING
	SKIPE	N,A		;IF NON-ZERO
	PUSHJ	P,MSPOCT	;SOME SORT OF SCHED SET

	CAIL	J,0		;IF NEGATIVE, NOTHING TYPED
	PUSHJ	P,CRLF		;END OF THIS LINE
;HERE TO PRINT RESPONSE MEASURES

REPEAT	0,<	;DON'T BOTHER, SINCE NO ONE SEEMS TO KNOW WHAT
		;THEY ARE, LET ALONE CARE.

	MOVEI	M,[ASCIZ /RSP:/];HEADER FOR RESPONSES
	SETZM	CPU		;SET FOR CPU0
;LOOP TO PRINT RESPONSE FOR EACH CPU
RSPLP1:	SKIPE	CPU		;IF FIRST CPU OR
	SKIPE	DUAL		;SEVERAL CPU'S THEN
	SKIPA			;PRINT
	JRST	RSP1C		;ELSE SKIP IT
	MOVEI	A,%CVRNX	;NO. OF RESPONSES SINCE STARTUP
	PUSHJ	P,GETRSP	;GET FROM MONITOR REL TABLE
	  JRST RSP1C		;NOT PRESENT FOR THIS CPU
	PUSH	P,A		;SAVE TOTAL NO. OF RESPONSES
	MOVEI	A,%CVRSX	;SUM OF RESPONSE TIMES IN JIFFIES
	PUSHJ	P,GETRSP	;GET FROM MONITOR REL TABLE
	  JRST	RSP1B		;NOT PRESENT FOR THIS CPU
	MOVE	N,A		;MOVE TO N FOR PNTSEC ROUTINE
	MUL	A,A		;GET SQUARE OF SUM OF RESPONSES
	PUSH	P,A		;SAVE FOR STANDARD DEV
	PUSH	P,B		; ..
	IDIV	N,-2(P)		;AVERAGE RSP=SUM/NUMBER(IN JIFFIES)
	PUSHJ	P,PNTSEC	;PRINT IN SECONDS + TENTHS
	POP	P,N1		;RESTORE SQUARE OF SUM
	POP	P,N		; ..
	MOVEI	M,[ASCIZ / /]	;SEPARATE AVER FROM STAND DEV
	MOVEI	A,%CVRLX	;SUM OF SQUARES OF RESPONSES
	PUSHJ	P,GETRSP	;GET FROM MONITOR REL TABLE
	  JRST	RSP1B		;NOT THERE
	MOVE	B,A		;POSITION
	MOVEI	A,%CVRHX	;ASK FOR HIGH SUM OF SQUARES
	PUSHJ	P,GETRSP	;FROM MONITOR
	  JRST	RSP1B		;(STRANGE!)
	MUL	B,(P)		;MULT BY NUMBER
	IMUL	A,(P)		; BOTH HALVES
	ADD	A,B		;INCLUDE CROSS CARRY
	MOVE	B,C		;POSITION LOW HALF
	SETCMM	N		;COMPLEMENT SQUARE OF SUM
	MOVNS	N1		; ..
	SKIPN	N1		;HANDLE CARRY
	ADDI	N,1		; YES
	TLZ	N1,(1B0)	;GOT (N,N1)=-SQ.SUM
	ADD	B,N1		;ADD TO N*SUM SQ.
	ADD	A,N		; ..
	TLZE	B,(1B0)		;SEE IF CARRY
	ADDI	A,1		;YES. GOT (A,B)=N*SUM SQ.-SQ.SUM
	PUSHJ	P,ISQRT		;COMPUTE N=SQRT((A,B))
	IDIV	N,(P)		;DIVIDE BY NUMBER; N=STD.DEV
	PUSHJ	P,PNTSEC	;PRINT AS SECONDS PLUS TENTHS
	POP	P,A		;REMOVE NO.
	MOVEI	M,[ASCIZ /+/]	;SEPARATE CPU0 AND CPU1 STUFF
	AOS	CPU		;STEP TO NEXT CPU
	JRST	RSPLP1		;GO SEE IF EXISTS	
;HERE WHEN PRINTED MEAN AND STANDARD DEV FOR ALL CPUS
RSP1B:	POP	P,A		;REMOVE NUMBER
RSP1C:	MOVEI	M,[ASCIZ " #/M:"]	;HEADER FOR NUMBER OF RESPONSES
	MOVE	T1,UPTIME	;UP TIME IN JIFFIES
	IDIV	T1,TCKSEC	;NO. OF SECONDS UP
	IDIVI	T1,^D60		;NO. OF MINUTES UP
	MOVEM	T1,TEMP		;STORE FOR CMPCNA
	SETZM	CPU		;START WITH CPU0
RSPLP2:	SKIPE	CPU		;IF FIRST CPU OR
	SKIPE	DUAL		;SEVERAL CPU'S
	SKIPA			;THEN PRINT
	JRST	RSP2		;ELSE SKIP
	MOVEI	A,%CVRNX	;NO. OF RESPONSES FOR THIS CPU
	PUSHJ	P,GETRSP	;GET FROM MONITOR TABLE
	  JRST	RSP2		;NOT THERE
	PUSHJ	P,CMPDFA	;PRINT NO. RESPONSES PER MIN
	MOVEI	M,[ASCIZ /+/]	;SEPARATE CPUS WITH +
	AOS	CPU		;STEP TO NEXT CPU
	JRST	RSPLP2		;TRY NEXT CPU

;HERE WHEN PRINTED FOR ALL CPUS
RSP2:	PUSHJ	P,CRLF

> ;END OF REPEAT 0 FROM PREVIOUS PAGE
	SUBTTL	"N" DISPLAY -- JOBS-IN-USE STATISTICS

PRJOB:	MOVEI	M,[ASCIZ /Job:/]
	MOVE	N,JBNLOG	;COUNT OF JOBS LOGGED-IN
	PUSHJ	P,MSGDEC	;TELL USER
	MOVE	N,JBNUSE	;TOTAL JOBS IN USE
	SUB	N,JBNLOG	;N := NUMBER OF NOT-LOGGED-IN JOBS
	JUMPE	N,PRJOB2	;IF BLANK, DON'T BOTHER
	MOVEI	M,[ASCIZ\+\]	;SEPARATE WITH A "+" CHARACTER
	PUSHJ	P,MSGDEC	;LIST SEPARATE NOT-LOGGED-IN JOBS
PRJOB2:	MOVE	A,[%CNLMX]	;LOGMAX
	PUSHJ	P,GETZ		;GET IT
	JUMPN	A,PRJOB4	;IF ZERO,
	MOVE	A,JOBN		;USE JOBMAX
	SUBI	A,1		;MINUS ONE (NUL JOB)
PRJOB4:	MOVE	N,A		;SET UP FOR OUTPUT
	MOVEI	M,[ASCIZ \/\]	;SEPARATOR
	PUSHJ	P,MSGDEC	;OUTPUT IT
	MOVE	N,JOBN		;GET JOBMAX
	SUBI	N,1		;LESS NULL JOB
	CAMG	N,A		;LOGMAX .LT. JOBMAX?
	JRST	PRJOB6		;NO, LEAVE IT ALONE
	MOVEI	M,[ASCIZ\/\]	;YES, SEPARATE LOGMAX FROM JOBMAX
	PUSHJ	P,MSGDEC	;AND LIST JOBMAX AS WELL
PRJOB6:	MOVEI	M,[ASCIZ / Det:/]
	MOVE	N,JBNDET	;NUMBER OF DETACHED JOBS
	PUSHJ	P,MSGDEC	;INFORM USER
	PUSHJ	P,CRLF		;START ON A NEW LINE

;FALL INTO STRUCTURE DISPLAY
	SUBTTL	"N" DISPLAY -- DISK STRUCTURES

STRCL==<XSIZE-^D40>/^D20	;NUMBER OF STR COLUMNS ON SCREEN

STRLP:	SKIPL	A,LINE		;OFF BOTTOM OF SCREEN?
	CAILE	A,YSIZE-2	;ROOM FOR AT LEAST ONE LINE OF STRS?
	JRST	STRLP9		;NO, NO STRUCTURES DISPLAY
	TABSET	TAB1ST		;SET UP STRUCTURE COLUMNS
	SETZM	CURFS		;INITIALIZE SYSSTR LOOP
	MOVEI	J,STRCL		;NUMBER OF COLUMNS
	MOVEI	M,[ASCIZ/Struc  Mnt  Free    /]  ;COLUMN HEADER
	PUSHJ	P,MSG		;LABEL COLUMN
	SOJG	J,.-2		;LABEL ALL COLUMNS

;LOOP FOR ALL STRUCTURES IN SYSTEM

STRLP1:	PUSHJ	P,CRLF		;START A FRESH LINE
	MOVEI	J,STRCL		;RESET COLUMN COUNTER
STRLP3:	MOVE	A,CURFS		;LAST STRUCTURE
	SYSSTR	A,		;SEE WHAT'S NEXT
	 JRST	STRLP8		;???
	JUMPE	A,STRLP8	;0 IS END
	MOVEM	A,CURFS		;SAVE FOR NEXT ITERATION
	MOVEM	A,DSKBLK	;SETUP FOR DSKCHR
	MOVE	B,[DSKBKL,,DSKBLK]  ;POINTER FOR DSKCHR TO
	DSKCHR	B,		;RETURN STRUCTURE INFORMATION
	 JRST	STRLP8		;??? CAN'T FAIL HERE
	PUSHJ	P,SIXTAB	;ISSUE STRUCTURE NAME, <TAB>
	MOVE	N,DSKBLK+.DCSMT	;STRUCTURE MOUNT COUNT
	PUSHJ	P,DECPRT	;TYPE IT OUT
	PUSHJ	P,TAB		;SPACE OVER
	MOVE	N,DSKBLK+.DCFCT	;FREE BLOCKS COUNT
	PUSHJ	P,DECPRT	;TYPE IT OUT ALSO
	SOJE	J,STRLP1	;END OF SCREEN?
	PUSHJ	P,TAB		;NO, ADVANCE TO NEXT COLUMN
	JRST	STRLP3		;AND DO ANOTHER STRUCTURE

STRLP8:	CAIE	J,STRCL		;AT START OF A LINE?
	PUSHJ	P,CRLF		;NO, CAP OFF CURRENT LINE

STRLP9:!			;END OF STRUCTURES DISPLAY
	SUBTTL	"N" DISPLAY -- DEVICES ASSIGNED OR IN USE

DEVCL==<XSIZE-^D40>/^D13	;NUMBER OF DEVICE COLUMNS

DEVLP:	SKIPL	A,LINE		;IF NOT OFF BOTTOM OF SCREEN
	CAILE	A,YSIZE-2	;THEN ROOM FOR AT LEAST ONE LINE OF DEV?
	JRST	DEVLP9		;NO, FORGET THE DEVICES DISPLAY
	TABSET	TAB1DV		;SET DEVICE COLUMNS
	MOVEI	J,DEVCL		;NUMBER OF DEVICE COLUMNS
	MOVEM	J,CPHDR		;MARK NO HEADER OUTPUT YET
	MOVE	A,XDVLST	;GET THE BASE OF THE DDB CHAIN
	CALL	GET		;GET THE VALUE
	JRST	DEVLP9		;END OF DEVICES DISPLAY
DEVLP1:	TLNN	A,-1		;IS THIS THE END OF THE DDB LIST
	JRST	DEVLP8		;END OF DEVICES DISPLAY
	HLRZ	D,A		;GET THE DDB ADDRESS
	MOVEI	A,$DVMOD(D)
	PUSHJ	P,MPEEK		;SPY OR PEEK
	MOVE	B,A		;(EDIT 2) REMEMBER THE DEVMOD ENTRY
	TXNE	A,DV$ASC!DV$ASP	;IN USE BY ANYONE?
	TXNE	A,DV$TTA!DV$DSK	;SHOW TTY'S NOT CONTROLLING JOBS
	JRST	DEVLP6		;LOOK AT NEXT DEVICE
	MOVEI	A,@PJOBNO	;GET ADDRESS OF DEVJOB WORD
	PUSHJ	P,MPEEK		;SPY OR PEEK
	MOVE	C,A		;GET A COPY OF THE RESULT
	MOVEI	A,$DVNAM(D)
	PUSHJ	P,MPEEK		;SPY OR PEEK
	HLRZ	BP,A
	CAIN	BP,'PTY'
	JRST	DEVLP6		;LOOK AT NEXT DEVICE
	TRZ	BP,77		;ONLY FIRST TWO CHARACTERS
	CAIN	BP,'''L '	;TAPE LABEL PROCESSOR DUMMY DDB?
	JRST	DEVLP6		;YES, DON'T CLUTTER UP SCREEN
	SKIPN	CPHDR		;PRINTED COLUMN HEADER YET?
	JRST	DEVLP2		;YES, JUST PRINT DEVICE
	MOVEI	M,[ASCIZ /Dev   By How	/]  ;DEVICE HEADER
	PUSHJ	P,MSG		;LABEL COLUMN
	SOJG	J,.-2		;LABEL ALL COLUMNS
	PUSHJ	P,CRLF		;END COLUMN HEADERS
	EXCH	J,CPHDR		;MARK HEADER AS HAVING BEEN PRINTED

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

DEVLP2:	PUSHJ	P,SIXTAB	;PRINT SIXBIT DEVICE NAME FOLLOWED BY TAB
	LDB	N,PJOBNP	;GET JOB NUMBER OWNING DDB
	JUMPE	N,[MOVEI M,[ASCIZ/Det	/] ;IF "ASSIGNED" TO JOB 0
		PUSHJ	P,MSG	;SAY DEVICE IS DETACHED
		JRST	DEVLP3]	;CAP OFF
	PUSHJ	P,DECPRT	;SHOW OWNER JOB NUMBER
	PUSHJ	P,TAB		;TAB OVER TO "HOW" COLUMN
	MOVEI	CH,"A"		;IN CASE "A"SSIGNED
	TXNE	B,DV$ASC	;IS DEVICE ASSIGNED BY CONSOLE COMMAND?
	PUSHJ	P,TYO		;YES (OR REASSI CALLI)
	MOVEI	CH,"I"		;IN CASE "I"NITED OR OPENED
	TXNE	B,DV$ASP	;IS DEVICE IN USE FOR I/O?
	PUSHJ	P,TYO		;YES
DEVLP3:	SOJG	J,DEVLP4	;UNLESS STILL ROOM ON SCREEN
	PUSHJ	P,CRLF		;END THIS LINE
	TROA	J,DEVCL		;AND RESET COLUMN COUNT
DEVLP4:	PUSHJ	P,TAB		;JUST TAB OVER TO NEXT COLUMN
DEVLP6:	MOVEI	A,$DVSER(D)
	PUSHJ	P,MPEEK		;SPY OR PEEK
	JRST	DEVLP1

DEVLP8:	CAIE	J,DEVCL		;IN MIDDLE OF A LINE?
	PUSHJ	P,CRLF		;YES, CAP IT OFF

DEVLP9:!			;END OF DEVICES DISPLAY

	POPJ	P,		;END OF "N" DISPLAY
	SUBTTL	"F" -- FILE SYSTEM DISPLAY PROGRAM

FILPRG:	CALL	STROLL		;START THE ROLL CALL
	MOVEI	M,[ASCIZ\Disk Status for\]  ;FILE SYSTEM HEADER PREFIX
	PUSHJ	P,THISIM	;OUTPUT HEADER
	TABSET	TAB4FS		;FILE SYSTEM TABS
	PUSHJ	P,SETVIS	;DETERMINE INITIAL SCREEN VISIBILITY
	HEADER	<	MOVEI	M,[ASCIZ .Unit or F/S	Free	BR	BW	DR	DW	MR	MW.]
	CALL	IMSG		;PRINT HEADER
	CALL	ICRLF		;AND A NEW LINE
>
	SETZM	CURFS		;INITIALIZE STRUCTURE "INDEX"
	SETZM	SWPTAB		;INITIALIZE SWAP UNIT TABLE
	MOVE	A,[SWPTAB,,SWPTAB+1]  ;BLT POINTER TO
	BLT	A,SWPTAB+SWPTLN-A  ;BLAST THE SWAP UNIT TABLE

FLFSL:	MOVE	A,CURFS
	SYSSTR	A,
	  JFCL
	JUMPE	A,FILEXI	;NONE OR ALL DONE
	MOVEM	A,CURFS
	MOVEM	A,DSKBLK
	PUSHJ	P,ISIXBP	;TYPE STRUCTURE NAME
	MOVE	A,[XWD DSKBKL,DSKBLK]	;SET FOR DISK CHARACTERISTICS UUO
	DSKCHR	A,		;FOR THE STRUCTURE FIRST
	 JRST	FILEXI		;SHOULDN'T FAIL
	MOVEI	M,[ASCIZ / Mnt:/]
	CALL	IMSG		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCSMT	;GET MOUNT COUNT
	CALL	IDECPR		;PRINT IF VISIBLE
	CALL	ITAB		;TAB OVER TO "FREE" COLUMN
	MOVE	N,DSKBLK+.DCFCT	;GET BLOCKS LEFT
	PUSHJ	P,IDECPR	;ON STR
	CALL	ICRLF		;END OF STRUCTURE

;FALL INTO FLUNL
;LIST INFO ON EACH UNIT WITHIN FILE STRUCTURE

FLUNL:	MOVE	A,DSKBLK+.DCUPN	;START WITH FIRST UNIT WITHIN FILE STRUCTURE
FLUNL0:	MOVEM	A,DSKBLK	;SET FOR DSKCHR
	MOVE	A,[XWD DSKBKL,DSKBLK]  ;ARG POINTER FOR DSKCHR TO
	DSKCHR	A,		;READ LOGICAL UNIT INFORMATION
	 JRST	FLFSL		;SHOULD NEVER HAPPEN
	MOVEM	A,DSKBLK	;SAVE BITS
	CALL	ISPACE		;INDENT A SPACE FOR NEATNESS
	MOVE	A,DSKBLK+.DCUPN	;UNIT PHYSICAL NAME
	SKIPL	N,DSKBLK+.DCPAS	;IS THIS UNIT IN THE ACTIVE SWAP LIST?
	SKIPE	CURUN2		;(IGNORE IF ALTERNATE PORT)
	CAIA			;NO
	MOVEM	A,SWPTAB(N)	;FLAG SWAPPING UNIT
	CALL	ISIXBP		;PRINT IF VISIBLE
	MOVEI	M,[ASCIZ /(/]	;PREPARE FOR UNIT LOGICAL NAME
	CALL	IMSG		;PRINT IF VISIBLE
	SKIPE	CURUN2		;LOOKING AT SECOND PORT?
	SKIPA	A,['..... ']	;YES, THEN SO INDICATE
	MOVE	A,DSKBLK+.DCULN	;NO, READ STRUCTURE UNIT NAME
	CALL	ISIXBP		;PRINT IF VISIBLE
	MOVEI	M,[ASCIZ /)	/]
	CALL	IMSG		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCUNT	;UNIT FREE BLOCKS
	SKIPN	CURUN2		;IF LOOKING AT ALTERNATE PORT NO FREE
	CALL	IDECPR		;MAIN PORT, PRINT IF VISIBLE
	CALL	ITAB		;ALWAYS TAB OVER
	MOVE	N,DSKBLK+.DCBRC	;BUFFERED READ COUNT
	CALL	IDECTAB		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCBWC	;BUFFERED WRITE COUNT
	CALL	IDECTAB		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCDRC	;DUMP READ COUNT
	CALL	IDECTAB		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCDWC	;DUMP WRITE COUNT
	CALL	IDECTAB		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCMRC	;MONITOR READ COUNT
	SUB	N,DSKBLK+.DCSRC	;DISCOUNT SWAP READS
	SUB	N,DSKBLK+.DCPRC	;DISCOUNT PAGE READS TOO
	CALL	IDECTAB		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCMWC	;MONITOR WRITE COUNT
	SUB	N,DSKBLK+.DCSWC	;DISCOUNT SWAP WRITES
	SUB	N,DSKBLK+.DCPWC	;DISCOUNT PAGE WRITES TOO
	CALL	IDECTAB		;PRINT IF VISIBLE

	CALL	ICRLF		;NEW LINE IF VISIBLE
	TRNE	F,FR.SKP	;SKIP THE ERROR/ETC STUFF?
	JRST	FLUNL7		;YEAH
;LIST THE PER-UNIT ERROR INFORMATION

FLUNL2:	TLZ	F,FL.NBK+FL.DEV
	HLLZ	A,DSKBLK
	TLZ	A,BITMSK
	JUMPE	A,FLUNL5
	MOVSI	C,-BITTL
FLUNL3:	SKIPGE	A
	PUSHJ	P,PRTBIT
	LSH	A,1
	AOBJN	C,FLUNL3

;HERE TO DO 5.03 OR LATER UNIT ERROR INFO

FLUNL5:	MOVSI	C,-UER2TL
FLUNL6:	HLRZ	A,UER2T1(C)
	HRRZ	M,UER2T1(C)	;ERROR IDENTIFICATION TEXT
	TLO	F,FL.CRF	;ADVANCE TO NEW LINE IF NEEDED
	SKIPE	N,DSKBLK(A)	;PICK UP ERROR INFO (IF ANY)
	PUSHJ	P,@UER2T3(C)	;PRINT OUT ERROR INFO
	TLZ	F,FL.CRF	;CLEAR FREE CRLF FLAG
	AOBJN	C,FLUNL6
	TLZE	F,FL.NBK+FL.DEV	;HAVE WE TYPED ANYTHING ON THIS LINE?
	PUSHJ	P,ICRLF		;YES, WE NEED A NEW LINE IF VISIBLE

FLUNL7:	SKIPE	A,DSKBLK+.DCALT	;MULTI-PORTED DISK UNIT?
	CAMN	A,CURUN2	;HAVE WE WRAPPED TO THE "PRIME" UNIT YET?
	JRST	FLUNL8		;ADVANCE TO NEXT UNIT IN F/S
	MOVE	N,DSKBLK+.DCUPN	;NO, GET THIS UNIT PHYSICAL NAME
	SKIPN	CURUN2		;IS THIS "PRIME" UNIT?
	MOVEM	N,CURUN2	;YES, REMEMBER PRIME UNIT NAME
	JRST	FLUNL0		;TYPE UNIT INFO FOR ALTERNATE PORT

FLUNL8:	SETZM	CURUN2		;NO LONGER DOING ALTERNATE UNITS
	SKIPE	A,DSKBLK+.DCNUS	;NAME OF NEXT UNIT WITHIN FILE STRUCTURE
	JRST	FLUNL0		;TYPE UNIT INFO FOR NEXT UNIT
	JRST	FLFSL		;LOOP FOR NEXT STRUCTURE
FILEXI:	CALL	ICRLF		;A BLANK LINE FOR NEATNESS
	HEADER	<	MOVEI	M,[ASCIZ /Swap Unit	SR	SW	PR	PW	Used(/]
	CALL	MSG		;AND PRINT IT
	CALL	KAYPAG		;PRINT K OR P
	MOVEI	M,[ASCIZ /)/]	;RIGHT BRACKET
	CALL	IMSG		;FINISH IT NICELY
	CALL	ICRLF		;PRINT NEW LINE
>
	SETZM	CURUN2		;NO ALTERNATE PORTS YET
	MOVSI	D,-SWPTLN	;INITIALIZE INDEX INTO SWAPPING TABLE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

SWLP1:	SKIPN	A,SWPTAB(D)	;GET NEXT UNIT FROM SWAPPING (IF ANY)
	JRST	SWLP7		;BLANK HERE, TRY NEXT SLOT
SWLP2:	MOVEM	A,DSKBLK	;SAVE FOR DSKCHR
	CALL	ISIXBP		;PRINT IF VISIBLE
	MOVE	A,[XWD DSKBKL,DSKBLK]  ;DSKCHR UUO ARG POINTER TO
	DSKCHR	A,		;READ ALL ABOUT THIS SWAPPING UNIT
	 JFCL			;DUH?
	MOVEI	M,[ASCIZ /(/]	;GET LEFT-PAREN MESSAGE
	CALL	IMSG		;PRINT IF VISIBLE
	SKIPE	CURUN2		;LOOKING AT ALTERNATE PORT?
	SKIPA	A,['..... ']	;YES, SO INDICATE
	MOVE	A,DSKBLK+.DCULN	;NO, GET UNIT LOGICAL NAME
	CALL	ISIXBP		;PRINT IF VISIBLE
	MOVEI	M,[ASCIZ /)	/] ;GET RIGHT-PAREN & TAB MESSAGE
	CALL	IMSG		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCSRC	;SWAPPING BLOCKS READ
	CALL	IDECTAB		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCSWC	;SWAPPING BLOCKS WRITTEN
	PUSHJ	P,IDECTAB	;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCPRC	;PAGING BLOCKS READ
	CALL	IDECTAB		;PRINT IF VISIBLE
	MOVE	N,DSKBLK+.DCPWC	;PAGING BLOCKS WRITTEN
	CALL	IDECTAB		;PRINT IF VISIBLE
	SKIPE	CURUN2		;LOOKING AT MAIN OR ALTERNATE
	JRST	SWLP4		;ALTERNATE, HAS JUNK NUMBERS
	MOVE	A,DSKBLK+.DCK4S	;SWAPPING SPACE ALLOCATED ON UNIT
	MOVE	N,DSKBLK+.DCFKS	;SWAPPING SPACE LEFT ON UNIT
	TRNE	F,FR.KIP
	LSH	A,1
	MOVEM	A,TEMP
	SUBB	A,N
	CALL	IPRPCNT		;PRINT PERCENTAGE
SWLP4:	CALL	ICRLF		;END THE LINE NICELY

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;CHECK FOR SECOND PORT ACCESS TO THIS SWAPPING UNIT

	SKIPE	A,DSKBLK+.DCALT	;THIS UNIT HAVE AN ALTERNATE PORT?
	CAMN	A,CURUN2	;HAVE WE WRAPPED TO THE "PRIME" UNIT YET?
	JRST	SWLP7		;ADVANCE TO NEXT UNIT IN SWAPPING LIST
	MOVE	N,DSKBLK+.DCUPN	;THIS UNIT'S PHYSICAL NAME
	SKIPN	CURUN2		;IS THIS THE PRIME PORT?
	MOVEM	N,CURUN2	;YES, REMEMBER PRIME UNIT NAME
	JRST	SWLP2		;TYPE OUT ALTERNATE PORT STATISTICS

SWLP7:	SETZM	CURUN2		;CLEAR ALTERNATE-PORT FLAGS
	AOBJN	D,SWLP1		;LOOP FOR REST OF SWAPPING TABLE
;HERE TO CHECK FOR SWAP READ ERRORS

	MOVE	A,XSWPER
	PUSHJ	P,GETZ
	JUMPE	A,SWFIN
	MOVE	D,A
	CALL	ICRLF		;PRINT NEW LINE
	MOVEI	M,[ASCIZ /Swap errors: /]
	CALL	IMSG		;PRINT IF VISIBLE
	HLRZ	N,D
	CALL	IDECTAB		;PRINT IF VISIBLE
	MOVEI	M,[ASCIZ / CHK/]
	TXZE	D,IO$IMP
	CALL	IMSG		;PRINT IF VISIBLE
	MOVEI	M,[ASCIZ / DEV/]
	TXZE	D,IO$DER
	CALL	IMSG		;PRINT IF VISIBLE
	MOVEI	M,[ASCIZ / DAT/]
	TXZE	D,IO$DTE
	CALL	IMSG		;PRINT IF VISIBLE
	MOVEI	M,[ASCIZ /   Lost: /]
	HRRZ	N,D
	TRZ	N,070000	;ZAP TWO MORE ERROR BITS
	SKIPGE	VISIBLE		;CAN WE SEE IT?
	PUSHJ	P,MSGDEC
	CALL	ICRLF		;PRINT NEW LINE
SWFIN:	RETURN			;END OF DISPLAY PROGRAM
PRTBIT:	MOVEI	M,BITTAB(C)
	SKIPN	@M		;THIS BIT MEAN ANYTHING?
	POPJ	P,		;NO, NO TYPEOUT THEN
	PUSHJ	P,ISPACE	;WANT LEADING SPACE SEPARATOR
	PUSHJ	P,ISPACE	;AND ANOTHER
	PUSHJ	P,ISPACE	;AND ANOTHER
	PUSHJ	P,IMSG		;PRINT IF VISIBLE
	TLO	F,FL.NBK	;NOTE SOMETHING OUTPUT
	POPJ	P,		;RETURN HAVING PRINTED FLAG

PRTUED:	TLO	F,FL.NBK	;NOTE SOMETHING OUTPUT
	PUSH	P,M
	MOVE	M,RTEND		;GET RIGHT-HAND MARGIN
	SUB	M,COL		;M := SPACES LEFT ON SCREEN
	CAIGE	M,^D11		;REASONABLE AMOUNT LEFT?
	PUSHJ	P,IFRCL		;NO, FORCE NEW (INDENTED) LINE
	MOVEI	M,[ASCIZ /   Errors:/]
	TLON	F,FL.DEV
	PUSHJ	P,IMSG		;PRINT IF VISIBLE
	POP	P,M
	PUSHJ	P,ISPACE	;GET LEADING SPACE
	PUSHJ	P,IMSG		;PRINT IF VISIBLE
	PJRST	IDECPR		;PRINT IF VISIBLE

PRTUEO:	TLO	F,FL.NBK	;NOTE SOMETHING OUTPUT
	PUSH	P,M
	MOVE	M,RTEND		;GET RIGHT-HAND MARGIN
	SUB	M,COL		;M := SPACES LEFT ON SCREEN
	CAIGE	M,^D18		;REASONABLE AMOUNT LEFT?
	PUSHJ	P,IFRCL		;NO, FORCE NEW (INDENTED) LINE
	MOVEI	M,[ASCIZ /   Errors:/]
	TLON	F,FL.DEV
	PUSHJ	P,IMSG		;PRINT IF VISIBLE
	POP	P,M
	PUSHJ	P,ISPACE	;LEADING SPACE SEPARATOR
	PUSHJ	P,IMSG		;PRINT IF VISIBLE
	SKIPGE	VISIBL		;CAN WE SEE IT?
	PJRST	OCTPRT
	POPJ	P,
	BITMSK=77	;CLEAR, LEAVING BITS IN 777700,,0

BITTAB:	ASCIZ	/RHB/		;REREAD HOME BLOCKS
	ASCIZ	/OFL/		;UNIT IS OFFLINE
	ASCIZ	/HWP/		;HARDWARE WRITE PROTECT
	ASCIZ	/SWP/		;SOFTWARE WRITE PROTECT
	ASCIZ	/SAF/		;SINGLE-ACCESS FILE STRUCTURE
	Z			;ZERO MOUNT COUNT
	ASCIZ	/PRF/		;PRIVATE FILE STRUCTURE
	Z			;FIRST HALF OF DC.STS FIELD
	Z			;SECOND HALF OF DC.STS FIELD
	Z			;MULTIPLE SAT BLOCKS
	ASCIZ	/NNA/		;NO NEW ACCESSES
	ASCIZ	/AWL/		;WRITE-LOCKED FOR ALL JOBS
	Z			;NOT ASSIGNED
	Z			;NOT ASSIGNED
	ASCIZ	/2PT/		;DUAL-PORTED UNIT
BITTL==.-BITTAB
UER2T1:	XWD	.DCHDV,[ASCIZ /HDEV:/]
	XWD	.DCHDT,[ASCIZ /HDAT:/]
	XWD	.DCSDV,[ASCIZ /SDEV:/]
	XWD	.DCSDT,[ASCIZ /SDAT:/]
	XWD	.DCECT,[ASCIZ /RETRIES:/]
	XWD	.DCSER,[ASCIZ /SER:/]
	XWD	.DCRER,[ASCIZ /RER:/]
	XWD	.DCCER,[ASCIZ /CER:/]
	XWD	.DCPHG,[ASCIZ /PHUNG:/]
	XWD	.DCTHG,[ASCIZ /THUNG:/]
	XWD	.DCNHG,[ASCIZ /NTHUNG:/]
	XWD	.DCSHG,[ASCIZ /SHUNG:/]
	XWD	.DCHBN,[ASCIZ /LBN:/]
	XWD	.DCSOF,[ASCIZ /1CONI:/]
	XWD	.DCERR,[ASCIZ /2CONI:/]
	XWD	.DCSDI,[ASCIZ /1DATAI:/]
	XWD	.DCHDI,[ASCIZ /2DATAI:/]
UER2TL==.-UER2T1

UER2T3:	IFIW	PRTUED		;HDEV
	IFIW	PRTUED		;HDAT
	IFIW	PRTUED		;SDEV
	IFIW	PRTUED		;SDAT
	IFIW	PRTUED		;RETRIES
	IFIW	PRTUED		;SER
	IFIW	PRTUED		;RER
	IFIW	PRTUED		;CER
	IFIW	PRTUED		;PHUNG
	IFIW	PRTUED		;THUNG
	IFIW	PRTUED		;NTHUNG
	IFIW	PRTUED		;SHUNG
	IFIW	PRTUED		;LBN
	IFIW	PRTUEO		;1CONI
	IFIW	PRTUEO		;2CONI
	IFIW	PRTUEO		;1DATAI
	IFIW	PRTUEO		;2DATAI
SUBTTL "\" NETWORK STATISTICS DISPLAY PROGRAM

IFN	FTNET,<

X2SIZE==XSIZE/2

NETSTT:	MOVE	A,[<F%CMSR&777000000>+.GTFET]  ;GET FTCMSR
	PUSHJ	P,GETZ		;FROM MONITOR
	TRNN	A,<F%CMSR&777777>  ;IS FTCMSR TURNED ON?
	JRST	NOCMSR		;NO, THIS DISPLAY USELESS

;LINE 1

	MOVEI	M,[ASCIZ\ANF Statistics for\]  ;HEADER PREFIX
	PUSHJ	P,THISIM	;GIVE STANDARD HEADER LINE
	TABSET	TAB7		;NETWORK TABS

;LINE 2

	MOVEI	M,[ASCIZ /NTCOR=	/]
	PUSHJ	P,MSG
	MOVE	A,[%NTCOR]
	PUSHJ	P,GETA
	MOVEI	N,(A)
	PUSHJ	P,DECTAB
	MOVEI	M,[ASCIZ /NTMAX=	/]
	PUSHJ	P,MSG
	MOVE	A,[%NTMAX]
	PUSHJ	P,GETA
	MOVEI	N,(A)
	PUSHJ	P,DECTAB
	MOVEI	M,[ASCIZ /NTBAD=	/]
	PUSHJ	P,MSG
	MOVE	A,[%NTBAD]
	PUSHJ	P,GETA
	MOVEI	N,(A)
	PUSHJ	P,DECPRT
NETST4:	PUSHJ	P,CRLF

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;UN-NUMBERED CONTROL WINDOW

	SET	1,X2SIZE-1,3,12,0,TAB9A
	SETZM	NTRTL		;INITIALIZE RECEIVED TOTAL
	SETZM	NTXTL		;INITIALIZE TRANSMITTED TOTAL
	MOVEI	M,[ASCIZ /Unnumbered CTL	XMIT'ed	RECV'ed
/]
	PUSHJ	P,MSG
	MOVSI	J,-^D7			;MAX ENTRIES
UNPRT1:	MOVE	M,[[ASCIZ \0 DAP/DATA	\]
		[ASCIZ	/1 ACK	/]
		[ASCIZ	/2 NAK	/]
		[ASCIZ	/3 REP	/]
		[ASCIZ	/4 START	/]
		[ASCIZ	/5 STACK	/]
		[ASCIZ	/6 NODE ID	/]](J)
	PUSHJ	P,MSG
	MOVE	A,[%NTXTP]	;RECEVICE TABLE
	PUSHJ	P,GETA
	ADDI	A,(J)
	MOVSI	A,(A)
	HRRI	A,.GTNTP
	PUSHJ	P,GETA
	SUB	A,NTXTP(J)	;A := INCREMENTAL
	ADDM	A,NTXTP(J)	;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	SKIPA	N,NTXTP(J)	;TOTAL
	MOVE	N,A
	ADDM	N,NTXTL		;ACCUMULATE TOTAL SENT
	TRNN	J,-1		;DAP/DATA MESSAGES?
	MOVNM	N,NTXTH		;YES, REMEMBER FOR HISTOGRAM
	PUSHJ	P,DECTAB
	MOVE	A,[%NTRTP]
	PUSHJ	P,GETA
	ADDI	A,(J)
	MOVSI	A,(A)
	HRRI	A,.GTNTP
	PUSHJ	P,GETA
	SUB	A,NTRTP(J)	;A := INCREMENTAL
	ADDM	A,NTRTP(J)	;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	SKIPA	N,NTRTP(J)	;TOTAL
	MOVE	N,A
	ADDM	N,NTRTL		;ACCUMULATE TOTAL RECEIVED
	TRNN	J,-1		;DAT/DATA MESSAGES?
	MOVNM	N,NTRTH		;YES, REMEMBER FOR HISTOGRAM
	PUSHJ	P,DECPRT
	PUSHJ	P,CRLF
	AOBJN	J,UNPRT1

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;NUMBERED MESSAGE WINDOW

	SET	X2SIZE,XSIZE,3,12,0,TAB9B
	MOVEI	M,[ASCIZ /Numbered CTL	XMIT'ed	RECV'ed
/]
	PUSHJ	P,MSG
	MOVSI	J,-^D7
	HRRI	J,1
NUPRT1:	MOVE	M,[[ASCIZ /0	 /]
		[ASCIZ /1 CONNECT	/]
		[ASCIZ /2 DISCONNECT	/]
		[ASCIZ /3 NEIGHBORS	/]
		[ASCIZ /4 REQ CONFIG	/]
		[ASCIZ /5 CONFIG	/]
		[ASCIZ /6 DATA REQUEST	/]
		[ASCIZ /7 STATION CTL	/]](J)
	PUSHJ	P,MSG
	MOVE	A,[%NTXMT]	;RECEVICE TABLE
	PUSHJ	P,GETA
	ADDI	A,(J)
	MOVSI	A,(A)
	HRRI	A,.GTNTP
	PUSHJ	P,GETA
	SUB	A,NTXMT(J)	;A := INCREMENTAL
	ADDM	A,NTXMT(J)	;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	SKIPA	N,NTXMT(J)	;TOTAL
	MOVE	N,A
	ADDM	N,NTXTH		;ACCUMULATE TOTAL DATA SENT
	PUSHJ	P,DECTAB
	MOVE	A,[%NTRMT]
	PUSHJ	P,GETA
	ADDI	A,(J)
	MOVSI	A,(A)
	HRRI	A,.GTNTP
	PUSHJ	P,GETA
	SUB	A,NTRMT(J)	;A := INCREMENTAL
	ADDM	A,NTRMT(J)	;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	SKIPA	N,NTRMT(J)	;TOTAL
	MOVE	N,A
	ADDM	N,NTRTH		;ACCUMULATE TOTAL DATA RECEIVED
	PUSHJ	P,DECPRT
	PUSHJ	P,CRLF
	AOBJN	J,NUPRT1

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;HERE TO DO A HISTOGRAM OF MESSAGE LENGTHS

	SET	1,X2SIZE-1,11,YSIZE,0,TAB7
	MOVEI	M,[ASCIZ /XMIT'ed=/]
	PUSHJ	P,MSG
	MOVE	N,NTXTL		;TOTAL MESSAGES SENT
	PUSHJ	P,DECTAB
	MOVEI	M,[ASCIZ /Average=/]
	PUSHJ	P,MSG
	MOVE	N,NTXTL		;GET TOTAL SENT AGAIN
	MOVE	A,UPTINC	;UPTIME
	IDIV	A,TCKSEC
	IDIV	N,A
	PUSH	P,N+1
	PUSHJ	P,DECPRT
	MOVEI	CH,"."
	PUSHJ	P,TYO
	POP	P,N
	IMULI	N,^D100		;- SCALE REMAINDER
	IDIV	N,A		;
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ \/sec\]
	PUSHJ	P,MSG
	PUSHJ	P,CRLF

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

IFGE	<YSIZE-20>,<		;DON'T BOTHER FOR VT50'S, ETC.

;PRINT THE ACTUAL HISTOGRAM

	MOVEI	M,[ASCIZ / 2**N	0%   20%  40%  60%  80%  99%
/]
	PUSHJ	P,MSG
	MOVE	A,[%NTXDL]
	PUSHJ	P,GETA
	LDB	J,[POINT 9,A,8]	;NUMBER OF ENTRIES
	MOVNS	J
	MOVSI	J,(J)		;AOBJN POINTER
	HRRI	J,(A)		;TABLE INDEX
	SETZB	N,JS		;SETUP COUNT/INDEX
	MOVMS	NTXTH		;POSITIFY TOTAL DATA SENT
LEN2:	HRLI	A,1(J)		;OFF BY ONE
	HRRI	A,.GTNTP
	PUSHJ	P,GETA
	SUB	A,NTXDL(JS)	;A := INCREMENTAL
	ADDM	A,NTXDL(JS)	;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,NTXDL(JS)	;TOTAL
	IMULI	A,^D100
	IDIV	A,NTXTH		;SCALE BY TOTAL DATA SENT
	HRRI	N,1(JS)		;SIZE (LOG 2)
	MOVEI	CH," "		;LEADING SPACE
	CAIGE	N,^D10		;"EXPONENT" ONLY ONE DIGIT?
	PUSHJ	P,TYO		;YES, MAKE TWO FOR NEATNESS
	PUSHJ	P,DECPRT
	PUSHJ	P,SPACE
	MOVE	N,A
	MOVEI	CH,"0"		;LEADING 0
	CAIGE	N,^D10		;PERCENTAGE ONLY ONE DIGIT?
	PUSHJ	P,TYO		;YES, MAKE TWO FOR NEATNESS
	PUSHJ	P,DECPRT
	MOVEI	CH,"%"
	PUSHJ	P,TYO
	JUMPE	A,LEN3
	PUSHJ	P,TAB
	ADDI	A,3		;ROUNDING
	ASH	A,-2
	MOVEI	CH,"*"
	PUSHJ	P,TYO
	SOJG	A,.-1
LEN3:	PUSHJ	P,CRLF
	ADDI	JS,1		;INDEX TO INTERNAL TABLE
	AOBJN	J,LEN2

> ;END IFGE <YSIZE-20>

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;HERE TO DO THE HISTOGRAM OF RECEIVED MESSAGES

	SET	X2SIZE,XSIZE,11,YSIZE,0,TAB8
	MOVEI	M,[ASCIZ /RECV'ed=/]
	PUSHJ	P,MSG
	MOVE	N,NTRTL		;GET TOTAL RECEIVED
	PUSHJ	P,DECTAB
	MOVEI	M,[ASCIZ/Average=/]
	PUSHJ	P,MSG
	MOVE	N,NTRTL		;TOTAL RECEIVED AGAIN
	MOVE	A,UPTINC	;UPTIME
	IDIV	A,TCKSEC
	IDIV	N,A
	PUSH	P,N+1
	PUSHJ	P,DECPRT
	MOVEI	CH,"."
	PUSHJ	P,TYO
	POP	P,N
	IMULI	N,^D100		;- SCALE REMAINDER
	IDIV	N,A		;
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ \/sec\]
	PUSHJ	P,MSG
	PUSHJ	P,CRLF

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

IFGE	<YSIZE-20>,<		;DON'T BOTHER IF VT50'S, ETC.

	MOVEI	M,[ASCIZ / 2**N	0%   20%  40%  60%  80%  99%
/]
	PUSHJ	P,MSG
	MOVE	A,[%NTRDL]
	PUSHJ	P,GETA
	LDB	J,[POINT 9,A,8]	;NUMBER OF ENTRIES
	MOVNS	J
	MOVSI	J,(J)		;AOBJN POINTER
	HRRI	J,(A)		;TABLE INDEX
	SETZB	N,JS		;INITIALIZE COUNT/INDEX
	MOVMS	NTRTH		;POSITIFY TOTAL DATA RECEIVED
LEN5:	HRLI	A,1(J)		;OFF BY ONE
	HRRI	A,.GTNTP
	PUSHJ	P,GETA
	SUB	A,NTRDL(JS)	;A := INCREMENTAL VALUE
	ADDM	A,NTRDL(JS)	;UPDATE TOTAL
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,NTRDL(JS)	;TOTAL
	IMULI	A,^D100
	IDIV	A,NTRTH		;SCALE BY TOTAL DATA RECEIVED
	HRRI	N,1(JS)		;GET SIZE (LOG 2)
	MOVEI	CH," "		;LEADING SPACE
	CAIGE	N,^D10		;"EXPONENT" ONLY ONE DIGIT?
	PUSHJ	P,TYO		;YES, MAKE TWO FOR NEATNESS
	PUSHJ	P,DECPRT
	PUSHJ	P,SPACE
	MOVE	N,A
	MOVEI	CH,"0"		;LEADING 0
	CAIGE	N,^D10		;PERCENTAGE ONLY ONE DIGIT?
	PUSHJ	P,TYO		;YES, MAKE TWO FOR NEATNESS
	PUSHJ	P,DECPRT
	MOVEI	CH,"%"
	PUSHJ	P,TYO
	JUMPE	A,LEN6
	PUSHJ	P,TAB
	ADDI	A,3		;ROUNDING
	ASH	A,-2
	MOVEI	CH,"*"
	PUSHJ	P,TYO
	SOJG	A,.-1
LEN6:	PUSHJ	P,CRLF
	ADDI	JS,1		;OFFSET FOR INTERNAL TABLE
	AOBJN	J,LEN5

> ;END IFGE <YSIZE-20>

	POPJ	P,
SUBTTL "T" NETWORK DISPLAY OF THE TOPOLOGY

NETPRG:	MOVEI	M,[ASCIZ\ANF Topology for\]  ;HEADER TEXT PREFIX
	PUSHJ	P,THISIM	;GIVE STANDARD HEADER LINE
N.1:	TABSET	TAB7		;SET STANDARD TABS

NETPI0:	MOVE	A,[%CNNDB]	;GET THE GETTAB POINTER TO THE NDB'S
	PUSHJ	P,GET		;GET IT
	  CAIA
	JUMPN	A,NETPI2	;OK THERE IS A NETWORK
	SET	1,XSIZE,2,YSIZE,0,TAB4
	MOVEI	M,[ASCIZ \The T command can only be executed if:
1.The requester has SPY or PEEK privileges.
2. And the monitor was built for network support =603
\]
	CALL	MSG
	JRST	ADVICE

NETPI2:	TLNN	F,FL.SPY!FL.PEK	;IS THE USER PRIVILEGED
	JRST	NOPRIV		;NO
	PUSH	P,A		;SAVE FIRST NDB
	MOVSI	B,-NDBTLN	;NDB POINTERS TABLE LENGTH
NETPI4:	MOVE	A,NDBGTB(B)	;NEXT POINTER GETTAB TABLE INDEX
	GETTAB	A,		;(MUST GETTAB SINCE IN HIGH SEG)
	 JRST	NETPI5		;MUST BE PRE-7.01
	TLZ	A,37		;CLEAR INDEX AND INDIRECT BITS
	TRNE	B,-1		;FIRST ENTRY?
	ADDI	A,XDBBLK	;NO (NOT LENGTH) RELOCATE POINTER
	MOVEM	A,NDBPTB(B)	;SAVE IN NDB POINTER TABLE
	AOBJN	B,NETPI4	;LOOP
	MOVEI	A,N		;ADDRESS OF NEIGHBORS INFO
	HRRM	A,NDBNGN	;SET UP BYTE POINTER
NETPI5:	POP	P,A		;GET BACK FIRST NDB
	DPB	A,NDBNXT	;SAVE THE FIRST NDB POINTER
	SKIPG	N,FIRJOB	;ANY "+" COMMANDS SEEN?
	JRST	NETPI8		;NO
NETPI6:	PUSHJ	P,NXTNDB	;YES, SKIP THAT MANY NDB'S
	 JRST	[PUSHJ	P,DWNJOB  ;TOO MANY, BACKUP SOME
		 JRST	NETPI0]	;TRY AGAIN
	SOJG	N,NETPI6	;SKIP NODES
NETPI8:	CALL	STROLL
	SETOM	NLTYPD		;YES, WE TYPED

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	SKIPG	NETMNY		;LOTS OF NEIGHBORS SOMEWHERE?
	JRST	NETPR0		;NO, NORMAL DISPLAY
	SET	1,XSIZE,2,YSIZE,0,TAB6X  ;YES, COMPRESS SCREEN
	JRST	NETPR1		;AND BUILD DISPLAY
NETPR0:	SET	1,XSIZE,2,YSIZE,0,TAB6  ;NORMAL TOPOLOGY DISPLAY
NETPR1:	MOVEI	M,[ASCIZ \ Node	Neighbors	OPR	CTL	LAR	LAP	LMS	LMA	LMR	LMP
\]
	CALL	MSG
NETPR2:	SKIPGE	LINE		;FILLED SCREEN YET?
	 POPJ	P,		;YEAH, QUIT NOW
	PUSHJ	P,NXTNDB	;NO, ADVANCE TO NEXT NODE
	  JRST	[PUSHJ	P,CHKDON;SCREEN NICELY FILLED UP YET?
		JRST	NETPRG	;NO, TRY AGAIN
		POPJ	P,]	;YES, SCREEN OK TO SHOW
	LDB	A,NDBSNM	;GET THE NODE NAME ADDRESS
	PUSHJ	P,MPEEK		;GET NODE NAME
	PUSHJ	P,SIXBP
	MOVEI	CH,"("
	PUSHJ	P,TYO
	LDB	N,NDBNNM	;GET THE NODE NUMBER
	PUSHJ	P,OCTPRT
	MOVEI	M,[ASCIZ \)\]
	CALL	MSG
	PUSHJ	P,TAB
	SETZ	A,		;COUNT THE NEIGHBORS
	SKIPA	C,NDBNGH	;GET THE TOPOLOGY POINTER
NETPR4:	IBP	C		;ADVANCE TOPOLOGY POINTER
	LDB	N,C		;GET A NEIGHBOR ENTRY
	LDB	N,NDBNGN	;GET NODE NUMBER OF NEIGHBOR
	SKIPE	N
	PUSHJ	P,[TRNN N,700	;FULL THREE DIGITS?
		PUSHJ	P,SPACE	;NO MORE THAN TWO
		TRNN	N,770	;HOW MAY DIGITS
		PUSHJ	P,SPACE	;ONLY ONE
		PUSHJ	P,OCTPRT;PRINT OCTAL NODE NUMBER
		AOJA	A,COMMA];COUNT NEIGHBORS AND SEPARATE
	CAME	C,NDBNGL	;LAST NEIGHBOR?
	JRST	NETPR4		;NOT YET, KEEP GOING
	SUBI	A,<<XSIZE-40>/7>;SEE IF LOTS OF NEIGHBORS
	MOVEM	A,NETMNY	;(COMPRESS SCREEN IF .GT. 0)
	PUSHJ	P,TAB
	LDB	A,NDBOPR	;GET THE OPR ENTRY
	JUMPE	A,NETPR5	;NO OPR TERMINAL
	ADD	A,DCHOFF	;YES, POINT TO THE LDBDCH ENTRY IN THE LDB
	ADD	A,LTBOFF	;MAKE SURE OF RIGHT SECTION
	PUSHJ	P,MPEEK		;READ IT
	ANDI	A,777		;ONLY NINE BITS
	MOVEI	N,(A)		;COPY
	PUSHJ	P,OCTPRT

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

NETPR5:	PUSHJ	P,TAB
	LDB	N,NDBCTJ	;IS STATION CONTROL BUSY
	SKIPE	N
	PUSHJ	P,DECPRT	;YES, PRINT THE JOB NUMBER
	PUSHJ	P,TAB
	LDB	N,NDBLAR	;LAR
	PUSHJ	P,DECTAB
	LDB	N,NDBLAP	;LAP
	PUSHJ	P,DECTAB
	LDB	N,NDBLMS
	PUSHJ	P,DECTAB
	LDB	N,NDBLMA	;LMA
	PUSHJ	P,DECTAB
	LDB	N,NDBLMR	;LMR
	PUSHJ	P,DECTAB
	LDB	N,NDBLMP	;LMP
	PUSHJ	P,DECPRT
	PUSHJ	P,CRLF		;END OF LINE 1
	JRST	NETPR2		;DO NEXT NODE IN NETWORK



NXTNDB:	LDB	B,NDBNXT	;ADDRESS OF NEXT NDB
	JUMPE	B,CPOPJ		;0 TERMINATES LIST
	MOVE	C,NDBLEN	;LENGTH OF NDB
	CAILE	C,XDBLEN	;SMALL ENOUGH FOR US?
	 MOVEI	C,XDBLEN	;ONLY READ IN FIRST PART
	MOVN	C,C		;NEGATIVE LENGTH
	ASH	C,^D18		;AOBJN POINTER
NXTND1:	MOVE	A,B		;ADDRESS OF NDB WORD
	PUSHJ	P,MPEEK		;GET A WORD
	MOVEM	A,XDBBLK(C)	;STORE
	AOBJP	C,CPOPJ1	;EXIT IF LAST WORD
	AOJA	B,NXTND1	;GET NEXT WORD
SUBTTL LOCAL STORAGE FOR "T" DISPLAY

;LIST OF BYTE POINTERS TO BE GETTAB'ED FROM MONITOR (MATCHES NDBPTB)

NDBGTB:	%NDLEN			;LENGTH OF NDB
	%NDNXT			;ADDRESS OF NEXT NDB
	%NDNNM			;NODE NUMBER
	%NDSNM			;ADDRESS OF STATION NAME
	%NDNGH			;FIRST NEIGHBOR POINTER
	%NDNGL			;LAST NEIGHBOR POINTER
	%NDNGN			;NODE NUMBER IN %NDNGH
	%NDOPR			;ADDRESS OF OPR LDB IF ANY
	%NDCTJ			;STATION CONTROL JOB NUMBER
	%NDLAR			;LAST ACK RECEIVED
	%NDLAP			;LAST MESSAGE ACK'ED
	%NDLMS			;LAST MESSAGE SENT
	%NDLMA			;LAST MESSAGE ASSIGNED
	%NDLMR			;LAST MESSAGE RECEIVED
	%NDLMP			;LAST MESSAGE PROCESSED

	NDBTLN==.-NDBGTB

>;END FTNET
	SUBTTL	"K" DISPLAY OF CI STATISTICS

CISTAT:	MOVE	A,[<F%SCA&777000000>+.GTFET] ;GETTAB FOR SCA FEATURE TEST
	PUSHJ	P,GETZ		;GET IT FROM MONITOR
	TRNN	A,<F%SCA&777777> ;MONITOR SUPPORT SCA?
	JRST	NOSCA		;NO, THEN THIS IS USELESS
	SETZM	CIVARB		;CLEAR VARIABLES
	MOVE	A,[CIVARB,,CIVARB+1]
	BLT	A,CIVARE	;ZEROES TO END
	MOVE	A,[%CNCPU]	;GETTAB POINTER FOR NUMBER OF CPUS IN SYSTEM
	PUSHJ	P,GET		;GET IT
	  JRST	[MOVEI	A,1	;ASSUME 1
		 SKIPE	DUAL	;UNLESS 1077/1088/1099
		 MOVEI	A,2	;IN WHICH CASE IS 2 CPU'S
		 JRST	.+1]	;CONTINUE
	MOVN	P1,A		;COPY -VE NUMBER OF CPUS TO P1
	HRLZS	P1		;MAKE AN AOBJN POINTER
	MOVEM	P1,CPUPTR	;SAVE IT
	SETZ	N,		;INIT COUNT OF CI PORTS

CISTS1:	HRRZ	A,P1		;GET CPU NUMBER
	LSH	A,1		;TIMES TWO
	ADDX	A,%CCCIP	;GETTAB TO GET CI PORT BLOCK ADDRESS
	PUSHJ	P,GETZ		;GET IT OR ZERO
	SKIPE	A		;CI PORT ON THIS CPU?
	AOS	N		;YES, COUNT THEM UP
	MOVE	T1,[.SQLNN+1,,.SSGLN] ;SCS. FUNCTION TO GET LOCAL NODE NUMBER
	DPB	P1,[POINTR T1,SS.CPU] ;PLUG IN CPU NUMBER
	MOVEM	T1,SCSBLK+.SQFNC ;STORE IN BLOCK
	MOVEI	A,SCSBLK	;POINT AT ARGUMENTS
	SCS.	A,		;ASK MONITOR
	  SKIPA	A,[-1]		;ERROR, GET FUNNY NUMBER
	MOVE	A,SCSBLK+.SQLNN	;GET LOCAL NODE NUMBER
	MOVEM	A,CPULNN(P1)	;SAVE IT
	AOBJN	P1,CISTS1	;LOOP FOR REMAINING CPUS
	JUMPE	N,NOCIP		;JUMP IF NO CI PORTS ON SYSTEM

	MOVEI	M,[ASCIZ\CI Status of\]  ;LABEL OUR DISPLAY
	PUSHJ	P,THISIM	;FIRE UP HEADER LINE
	MOVEI	M,[ASCIZ /
Open Paths:
CI Node /]
	PUSHJ	P,MSG		;START HEADER
	MOVSI	P1,-MAXNDS	;SET TO PRINT COLUMNS
CISTS2:	PUSHJ	P,SPACE		;SPACE OVER
	HRRZ	N,P1		;GET NODE NUMBER
	PUSHJ	P,DECZ2		;PRINT IT
	AOBJN	P1,CISTS2	;LOOP FOR REMAINDER
	PUSHJ	P,CRLF		;END WITH CRLF

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVE	P1,CPUPTR	;GET AOBJN POINTER TO CPUS
CISTS3:	SKIPGE	CPULNN(P1)	;OUR NODE NUMBER KNOWN?
	JRST	CIST4A		;NO
	MOVEI	M,[ASCIZ /CPU/]	;[635] ASSUME MULTI-PROCESSOR CONFIGURATION
	SKIPN	DUAL		;[635] IS IT?
	MOVEI	M,[ASCIZ /    /];[635] NO, JUST PRINT 4 SPACES
	PUSHJ	P,MSG		;PRINT MESSAGE
	HRRZ	N,P1		;GET CPU NUMBER
	SKIPE	DUAL		;DON'T PRINT IF SINGLE PROCESSOR
	PUSHJ	P,DECPRT	;ADD CPU NUMBER
	MOVEI	M,[ASCIZ /    /] ;4 SPACES
	PUSHJ	P,MSG		;PRINT MESSAGE
	MOVSI	P2,-MAXNDS	;LOOP FOR EACH NODE

CISTS4:	PUSHJ	P,SPACE		;SPACE OVER TO CORRECT COLUMN
	MOVE	A,[.SQRPS+1,,.SSRPS] ;SET UP ARGUMENT BLOCK
	DPB	P1,[POINTR A,SS.CPU] ;PLUG IN CPU NUMBER
	MOVEM	A,SCSBLK+.SQFNC	;STORE
	HRRZM	P2,SCSBLK+.SQRPN ;NODE NUMBER
	MOVEI	T1,SCSBLK	;POINT AT ARGUMENTS
	SCS.	T1,		;ASK MONITOR
	  TDZA	A,A		;IF ERROR, ASSUME BOTH PATHS DOWN
	MOVE	A,SCSBLK+.SQRPS	;GET PATH STATUS
	TLZE	A,1		;PATH A OPEN?
	TLOA	A,"A"		;YES, MARK SO
	TLO	A," "		;NO
	TRZE	A,1		;PATH B OPEN?
	TROA	A,"B"		;YES, MARK SO
	TRO	A," "		;NO
	HRRZ	T1,SCSBLK+.SQRPN ;GET NODE NUMBER
	CAMN	T1,CPULNN(P1)	;IS THIS "OUR" NODE?
	MOVE	A,["-",,"-"]	;YES, PRINT DASHES TO INDICATE SUCH
	HLRZ	CH,A		;GET FIRST CHARACTER
	PUSHJ	P,TYO		;PRINT IT
	HRRZ	CH,A		;GET SECOND CHARACTER
	PUSHJ	P,TYO		;PRINT IT
	AOBJN	P2,CISTS4	;LOOP FOR REMAINING PATHS ON THIS CPU
	PUSHJ	P,CRLF		;NEW LINE
CIST4A:	AOBJN	P1,CISTS3	;LOOP FOR REMAINING CPUS

	MOVE	P1,CPUPTR	;SET TO SCAN CPU'S AGAIN
CISTS5:	MOVEI	P2,NOSTCT	;GET OFFSET IN STATISTICS COUNTERS BLOCK
	IMULI	P2,(P1)		;...
	HRLZ	A,P1		;GET CPU NUMBER
	HRRI	A,.DIACC	;FUNCTION TO READ CI STATISTICS COUNTERS
	MOVEM	A,CTRBLK(P2)	;STORE IN FIRST WORD
	MOVE	A,[7,,.DICRD]	;CHANNEL,,SUB-FUNCTION TO READ COUNTERS
	MOVEM	A,CTRBLK+1(P2)	;STORE IN SECOND WORD
	MOVSI	A,-NOSTCT	;-VE NUMBER OF WORDS
	HRRI	A,CTRBLK(P2)	;OFFSET
	SKIPL	CPULNN(P1)	;PUNT IF WE DON'T HAVE A CI PORT
	DIAG.	A,		;READ CI PORT COUNTERS
	  SETOM	CPULNN(P1)	;IF IT FAILED, ASSUME CI PORT WENT AWAY
	AOBJN	P1,CISTS5	;LOOP FOR REMAINING CPUS

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	TABSET	TABCI		;SET TAB STOPS
	MOVEI	M,[ASCIZ "
Packet counts:
	     XMT	 Avg/sec	     RCV	 Avg/sec	Discarded	    Node
"]
	PUSHJ	P,MSG		;PRINT HEADER
	MOVE	P1,CPUPTR	;GET POINTER AGAIN
CISTS6:	SKIPGE	CPULNN(P1)	;HAVE A CI PORT?
	JRST	CIST6A		;NO
	MOVEI	P2,NOSTCT	;GET OFFSET IN STATISTICS COUNTERS BLOCK
	IMULI	P2,(P1)		;...
	MOVEI	M,[ASCIZ /CPU/]	;GET MESSAGE
	SKIPE	DUAL		;MULTI-PROCESSOR CONFIGURATION?
	PUSHJ	P,MSG		;YES, PRINT MESSAGE
	HRRZ	N,P1		;GET CPU NUMBER
	SKIPE	DUAL		;DON'T PRINT IF SINGLE PROCESSOR
	PUSHJ	P,DECPRT	;ADD CPU NUMBER
	PUSHJ	P,TAB		;PRINT A TAB
	MOVE	N,CTRBLK+13(P2)	;GET TRANSMITTED PACKET COUNT
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+13(P2)	;YES, REMOVE BASE
	PUSHJ	P,DECB8		;PRINT IT
	PUSHJ	P,TAB		;ANOTHER TAB
	MOVE	N,CTRBLK+13(P2)	;GET TRANSMITTED PACKET COUNT AGAIN
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+13(P2)	;YES, REMOVE BASE
	MOVE	A,UPTINC	;GET UPTIME
	IDIV	A,TCKSEC	;DIVIDE BY TICKS/SECOND
	MOVEM	A,TEMP		;SAVE FOR USE AGAIN
	PUSHJ	P,CMPDDN	;PRINT 4 DIGITS, ".", 2 DIGITS
	PUSHJ	P,TAB		;PRINT A TAB
	MOVE	N,CTRBLK+14(P2)	;GET RECEIVED PACKET COUNT
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+14(P2)	;YES, REMOVE BASE
	PUSHJ	P,DECB8		;PRINT IT
	PUSHJ	P,TAB		;ANOTHER TAB
	MOVE	N,CTRBLK+14(P2)	;GET RECEIVED PACKET COUNT AGAIN
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+14(P2)	;YES, REMOVE BASE
	PUSHJ	P,CMPDDN	;PRINT 4 DIGITS, ".", 2 DIGITS
	PUSHJ	P,TAB		;ADD A TAB
	MOVE	N,CTRBLK+12(P2)	;GET DATAGRAMS DISCARDED
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+12(P2)	;YES, REMOVE BASE
	PUSHJ	P,SPACE		;SPACE OVER
	PUSHJ	P,DECB8		;PRINT IT
	PUSHJ	P,TAB		;ADD A TAB
	MOVEI	M,[ASCIZ /     /] ;AND A FEW SPACES
	PUSHJ	P,MSG		;...
	LDB	N,[POINT 8,CTRBLK+15(P2),31] ;GET SELECTED NODE
	CAIN	N,377		;-1 IN 8 BITS?
	JRST	[MOVEI	M,[ASCIZ /ALL/] ;YES, GET TEXT
		 PUSHJ	P,MSG	;PRINT IT
		 JRST	.+2]	;CONTINUE
	PUSHJ	P,DECZ2		;ADD SELECTED NODE
	PUSHJ	P,CRLF		;ADD CRLF
CIST6A:	AOBJN	P1,CISTS6	;LOOP FOR REMAINING CPUS

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVEI	M,[ASCIZ "
Statistics:
	   A ACK	   A NAK	   A NRS	   B ACK	   B NAK	   B NRS
"]
	PUSHJ	P,MSG		;PRINT HEADER
	MOVE	P1,CPUPTR	;GET POINTER AGAIN
CISTS7:	SKIPGE	CPULNN(P1)	;HAVE A CI PORT?
	JRST	CIST7A		;NO
	MOVEI	P2,NOSTCT	;GET OFFSET IN STATISTICS COUNTERS BLOCK
	IMULI	P2,(P1)		;...
	MOVEI	M,[ASCIZ /CPU/]	;GET MESSAGE
	SKIPE	DUAL		;MULTI-PROCESSOR CONFIGURATION?
	PUSHJ	P,MSG		;YES, PRINT MESSAGE
	HRRZ	N,P1		;GET CPU NUMBER
	SKIPE	DUAL		;DON'T PRINT IF SINGLE PROCESSOR
	PUSHJ	P,DECPRT	;ADD CPU NUMBER
	PUSHJ	P,TAB		;PRINT A TAB
	MOVE	N,CTRBLK+4(P2)	;GET A ACKS
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+4(P2)	;YES, REMOVE BASE
	PUSHJ	P,DECB8		;PRINT
	PUSHJ	P,TAB		;TAB
	MOVE	N,CTRBLK+5(P2)	;GET A NAKS
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+5(P2)	;YES, REMOVE BASE
	PUSHJ	P,DECB8		;PRINT
	PUSHJ	P,TAB		;TAB
	MOVE	N,CTRBLK+6(P2)	;GET A NRS
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+6(P2)	;YES, REMOVE BASE
	PUSHJ	P,DECB8		;PRINT
	PUSHJ	P,TAB		;TAB
	MOVE	N,CTRBLK+7(P2)	;GET B ACKS
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+7(P2)	;YES, REMOVE BASE
	PUSHJ	P,DECB8		;PRINT
	PUSHJ	P,TAB		;TAB
	MOVE	N,CTRBLK+10(P2)	;GET B NAKS
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+10(P2)	;YES, REMOVE BASE
	PUSHJ	P,DECB8		;PRINT
	PUSHJ	P,TAB		;TAB
	MOVE	N,CTRBLK+11(P2)	;GET B NRS
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+11(P2)	;YES, REMOVE BASE
	PUSHJ	P,DECB8		;PRINT
	PUSHJ	P,CRLF		;ADD CRLF
CIST7A:	AOBJN	P1,CISTS7	;LOOP FOR REMAINING CPUS

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVE	P1,CPUPTR	;GET POINTER AGAIN
	TLZ	F,FL.DEV	;NO HEADER PRINTED YET
CISTS8:	SKIPGE	CPULNN(P1)	;HAVE A CI PORT?
	JRST	CISTS0		;NO
	MOVEI	P2,NOSTCT	;GET OFFSET IN STATISTICS COUNTERS BLOCK
	IMULI	P2,(P1)		;...
	SETZ	N,		;ACCUMULATE TOTAL
	MOVSI	A,-7		;NUMBER OF ERROR COUNTERS
	HRR	A,P2		;OFFSET FOR THIS CPU
	ADD	N,CTRBLK+16(A)	;ADD IN THIS PAIR
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,CTRSAV+16(A)	;YES, REMOVE BASE
	AOBJN	A,.-3		;LOOP FOR ALL ERROR COUNTERS
	JUMPE	N,CISTS0	;JUMP IF NO ERRORS
	MOVEI	M,[ASCIZ /
Errors:
/]
	TLON	F,FL.DEV	;NEED THE HEADER?
	PUSHJ	P,MSG		;YES, PRINT IT
	MOVEI	M,[ASCIZ /CPU/]	;GET MESSAGE
	SKIPE	DUAL		;MULTI-PROCESSOR CONFIGURATION?
	PUSHJ	P,MSG		;YES, PRINT MESSAGE
	HRRZ	N,P1		;GET CPU NUMBER
	SKIPE	DUAL		;DON'T PRINT IF SINGLE PROCESSOR
	PUSHJ	P,DECPRT	;ADD CPU NUMBER
	PUSH	P,P1		;SAVE AN AC
	MOVSI	P1,-CTRLEN	;LENGTH OF ERROR COUNTERS TABLES
CISTS9:	MOVEI	T1,CTRBLK(P2)	;GET ADDRESS OF BLOCK
	ADD	T1,CTRGET(P1)	;ADD IN BYTE POINTER
	LDB	N,T1		;GET THE CURRENT VALUE
	ADDI	T1,CTRSAV-CTRBLK ;OFFSET TO SAVED AREA
	LDB	T2,T1		;GET THE PREVIOUS VALUE
	TLNE	F,FL.INC	;INCREMENTAL?
	SUB	N,T2		;YES, REMOVE BASE
	MOVE	M,CTRTXT(P1)	;GET ADDRESS OF TEXT
	SKIPE	N		;IF ANYTHING,
	PUSHJ	P,MSGDEC	; PRINT IT
	AOBJN	P1,CISTS9	;LOOP FOR ALL COUNTERS
	PUSHJ	P,CRLF		;END THE LINE
	POP	P,P1		;RESTORE P1
CISTS0:	AOBJN	P1,CISTS8	;LOOP FOR REMAINING CPUS

	MOVE	A,[CTRBLK,,CTRSAV] ;NOW COPY THE INFO TO THE SAVE AREA
	BLT	A,CTRSVE	;...
	RETURN			;END OF DISPLAY PROGRAM
;MACRO TO DEFINE CI ERROR COUNTER NAMES AND OFFSETS

DEFINE	CICTRS,<

CTR	<CRC:>,<POINT 36,16,35>
CTR	<MVR PAR:>,<POINT 18,17,17>
CTR	<CBUS PAR:>,<POINT 18,17,35>
CTR	<REG PLIPE:>,<POINT 18,20,17>
CTR	<DATA PLIPE:>,<POINT 18,20,35>
CTR	<CHN:>,<POINT 18,21,17>
CTR	<EBUS PAR:>,<POINT 18,21,35>
CTR	<SPR CHN:>,<POINT 18,22,17>
CTR	<CBUS AVL TMO:>,<POINT 18,22,35>
CTR	<SPR RCV ATTN:>,<POINT 18,23,17>
CTR	<SPR XMT ATTN:>,<POINT 18,23,35>
CTR	<XMT BFR PAR:>,<POINT 18,24,17>
CTR	<XMT TMO:>,<POINT 18,24,35>

>; END DEFINE CICTRS

DEFINE	CTR(TEXT,PTR),<PTR>

CTRGET:	CICTRS
CTRLEN==.-CTRGET		;LENGTH OF TABLES

DEFINE	CTR(TEXT,PTR),<[ASCIZ /  TEXT/]>

CTRTXT:	CICTRS
	SUBTTL	"E" DISPLAY OF ETHERNET STATUS

IFN FTNET,<
ETHDPY:	MOVEI	M,[ASCIZ |Ethernet Status of|]
	PUSHJ	P,THISIM	;FIRE UP SYSTEM HEADER LINE
	TABSET	TABETH		;ETHERNET TABS
	PUSHJ	P,ETHRCL	;READ ETHERNET CHANNEL LIST
	  POPJ	P,		;ERROR, RETURN
	SKIPL	P2,T1		;SAVE AOBJN POINTER TO LIST
	  POPJ	P,		;EMPTY LIST, RETURN
ND %NTNIP,<15,,.GTNTP>		;IN CASE NOT YET IN UUOSYM
	MOVX	A,%NTNIP	;GETTAB ITEM FOR ANF/ETHERNET PROTOCOL
	PUSHJ	P,GETZ		;GET PROTOCOL NUMBER OR ZERO
	HRLM	A,EPTANF	;PATCH THE TABLE WITH THE VALUE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;LOOP FOR EACH CIRCUIT IN THE SYSTEM

ETHDP0:	PUSHJ	P,CRLF		;BLANK LINE BEFORE DISPLAY
	MOVEI	M,[ASCIZ |Chan/Kont	State	  E-Net Address		  DgmXmt     DgmRcv|]
	PUSHJ	P,MSG		;...
	PUSHJ	P,CRLF		;END LINE
	SETZ	J,		;INCREMENTAL STATISTICS TABLE INDEX
	MOVE	T1,(P2)		;GET NEXT CHANNEL ID
	PUSHJ	P,ETHRCI	;READ CHANNEL INFO
	  JRST	ETHDPX		;ERROR, TRY NEXT CHANNEL
	MOVE	P1,T1		;SAVE AOBJN POINTER TO BUFFER
	MOVEI	M,[ASCIZ |ETH-|] ;OUTPUT CHANNEL STATUS LINE
	PUSHJ	P,MSG		;...
	MOVE	N,.EICNM(P1)	;GET ETHERNET CHANNEL NUMBER
	PUSHJ	P,DECPRT	;PRINT OUT
	PUSHJ	P,TAB		;TAB OVER TO STATUS COLUMN
	LDB	T1,[POINTR (ENTBLK+.ETCSW,ET.CON)] ;GET CHANNEL ONLINE FLAG
	MOVE	M,ONFSTS(T1)	;GET ADDRESS OF ONLINE/OFFLINE STRING
	PUSHJ	P,MSG		;PRINT STATUS
	PUSHJ	P,TAB		;TAB OVER TO ETHERNET ADDRESS COLUMN
	MOVEI	T1,.EICEA(P1)	;GET ADDRESS OF ETHERNET ADDRESS
	PUSHJ	P,EADPRT	;PRINT ETHERNET ADDRESS
	MOVE	T1,(P2)		;GET CHANNEL ID
	PUSHJ	P,ETHRCC	;READ CHANNEL COUNTERS
	  JRST	ETHDP1		;ERROR, SKIP DISPLAY
	MOVE	P1,T1		;SAVE AOBJN POINTER TO BUFFER
	PUSHJ	P,TAB		;TAB TO DATAGRAMS TRANSMITTED COLUMN
	PUSHJ	P,TAB		;...
	MOVE	N,.ECCDX(P1)	;GET DATAGRAMS TRANSMITTED COUNT
	TLNE	F,FL.INC	;WANT INCREMENTAL?
	SUB	N,DGMXMT(J)	;YES, COMPUTE VALUE
	PUSHJ	P,DECB8		;PRINT OUT
	PUSHJ	P,TAB		;TAB TO DATAGRAMS RECEIVED COLUMN
	MOVE	N,.ECCDR(P1)	;GET DATAGRAMS RECEIVED COUNT
	TLNE	F,FL.INC	;WANT INCREMENTAL?
	SUB	N,DGMRCV(J)	;YES, COMPUTE VALUE
	PUSHJ	P,DECB8		;PRINT OUT
	MOVE	N,.ECCDX(P1)	;GET DATAGRAMS TRANSMITTED COUNT
	MOVEM	N,DGMXMT(J)	;SAVE CURRENT VALUE
	MOVE	N,.ECCDR(P1)	;GET DATAGRAMS RECEIVED COUNT
	MOVEM	N,DGMRCV(J)	;SAVE CURRENT VALUE
	AOJ	J,		;UPDATE TABLE INDEX
ETHDP1:	PUSHJ	P,CRLF		;FINISH STATUS LINE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

ETHDP2:	MOVE	T1,(P2)		;GET CHANNEL ID
	PUSHJ	P,ETHRKL	;READ KONTROLLER LIST
	  JRST	ETHDP5		;ERROR, DO PORTAL LIST
	JUMPGE	T1,ETHDP5	;SKIP DISPLAY IF EMPTY LIST
	PUSH	P,P2		;SAVE CHANNEL LIST AOBJN POINTER
	MOVE	P2,T1		;SET UP KONTROLLER LIST AOBJN POINTER
ETHDP3:	MOVE	T1,(P2)		;GET KONTROLLER ID
	PUSHJ	P,ETHRKI	;READ KONTROLLER INFO
	  JRST	ETHDP4		;ERROR, TRY NEXT KONTROLLER
	MOVE	P1,T1		;SAVE AOBJN POINTER TO BUFFER
	PUSHJ	P,SPACE		;INDENT THE KONTROLLER
	PUSHJ	P,SPACE		; BY A TAD OR TWO
	DMOVE	T1,.EIKCP(P1)	;GET CPU NUMBER AND KONTROLLER TYPE
	MOVE	T4,.EIKNO(P1)	;AND KONTROLLER NUMBER
	PUSHJ	P,KTYPRT	;OUTPUT
	PUSHJ	P,TAB		;TAB OVER TO STATUS COLUMN
	LDB	T1,[POINTR (ENTBLK+.ETKSW,ET.KON)] ;GET KONTROLLER ONLINE FLAG
	MOVE	M,ONFSTS(T1)	;GET ADDRESS OF ONLINE/OFFLINE STRING
	PUSHJ	P,MSG		;PRINT STATUS
	PUSHJ	P,TAB		;TAB OVER TO ETHERNET ADDRESS COLUMN
	MOVEI	T1,.EIKHA(P1)	;GET ADDRESS OF ETHERNET ADDRESS
	PUSHJ	P,EADPRT	;PRINT ETHERNET ADDRESS
	MOVE	T1,(P2)		;GET KONTROLLER ID
	PUSHJ	P,ETHRKC	;READ KONTROLLER COUNTERS
	  JRST	ETHDP4		;ERROR, TRY NEXT KONTROLLER
	MOVE	P1,T1		;SAVE AOBJN POINTER TO BUFFER
	PUSHJ	P,TAB		;TAB TO DATAGRAMS TRANSMITTED COLUMN
	PUSHJ	P,TAB		;...
	MOVE	N,.ECKDX(P1)	;GET DATAGRAMS TRANSMITTED COUNT
	TLNE	F,FL.INC	;WANT INCREMENTAL?
	SUB	N,DGMXMT(J)	;YES, COMPUTE VALUE
	PUSHJ	P,DECB8		;PRINT OUT
	PUSHJ	P,TAB		;TAB TO DATAGRAMS RECEIVED COLUMN
	MOVE	N,.ECKDR(P1)	;GET DATAGRAMS RECEIVED COUNT
	TLNE	F,FL.INC	;WANT INCREMENTAL?
	SUB	N,DGMRCV(J)	;YES, COMPUTE VALUE
	PUSHJ	P,DECB8		;PRINT OUT
	MOVE	N,.ECKDX(P1)	;GET DATAGRAMS TRANSMITTED COUNT
	MOVEM	N,DGMXMT(J)	;SAVE CURRENT VALUE
	MOVE	N,.ECKDR(P1)	;GET DATAGRAMS RECEIVED COUNT
	MOVEM	N,DGMRCV(J)	;SAVE CURRENT VALUE
	AOJ	J,		;UPDATE TABLE INDEX
ETHDP4:	PUSHJ	P,CRLF		;FINISH STATUS LINE
	AOBJN	P2,ETHDP3	;LOOP BACK FOR ALL KONTROLLERS
	POP	P,P2		;RESTORE CHANNEL LIST AOBJN POINTER

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

ETHDP5:	MOVE	T1,(P2)		;GET CHANNEL ID
	PUSHJ	P,ETHRPL	;READ PORTAL LIST
	  JRST	ETHDPX		;SKIP DISPLAY IF ERROR
	JUMPGE	T1,ETHDPX	;SKIP DISPLAY IF EMPTY LIST
	PUSH	P,P2		;SAVE CHANNEL LIST AOBJN POINTER
	MOVE	P2,T1		;SET UP PORTAL LIST AOBJN POINTER
	PUSHJ	P,CRLF		;BLANK LINE BEFORE DISPLAY
	MOVEI	M,[ASCIZ |Protocol	State	Kont	   User	  DgmXmt	  DgmRcv    FQE|]
	PUSHJ	P,MSG		;PRINT SUBHEADER
	PUSHJ	P,CRLF		;END LINE
ETHDP6:	MOVE	T1,(P2)		;GET PORTAL ID
	PUSHJ	P,ETHRPI	;READ PORTAL INFO
	  JRST	ETHDP8		;ERROR, TRY NEXT PORTAL
	MOVE	P1,T1		;SAVE AOBJN POINTER TO BUFFER
	PUSHJ	P,SPACE		;INDENT PROTOCOL TYPES
	PUSHJ	P,SPACE		; BY A LITTLE BIT
	HRRE	N,.EIPPI(P1)	;GET PROTOCOL TYPE CODE
	PUSHJ	P,EPTPRT	;PRINT OUT
	PUSHJ	P,TAB		;TAB OVER TO STATUS COLUMN
	LDB	T1,[POINTR (ENTBLK+.ETPSW,ET.PON)] ;GET PORTAL ONLINE FLAG
	MOVE	M,ONFSTS(T1)	;GET ADDRESS OF ONLINE/OFFLINE STRING
	PUSHJ	P,MSG		;PRINT STATUS
	PUSHJ	P,TAB		;TAB OVER TO KONTROLLER COLUMN
	MOVE	T1,.EIPKS(P1)	;GET KONTROLLER ID
	PUSHJ	P,ETHRKI	;READ KONTROLLER INFO
	  JRST	ETHDP7		;ERROR, SKIP KONTROLLER COLUMN
	DMOVE	T1,RKIBUF+.EIKCP ;GET CPU NUMBER AND KONTROLLER TYPE
	MOVE	T4,RKIBUF+.EIKNO ;AND KONTROLLER NUMBER
	PUSHJ	P,KTYPRT	;OUTPUT
ETHDP7:	PUSHJ	P,TAB		;TAB OVER TO OWNER COLUMN
	SKIPN	.EIPJC(P1)	;PORTAL BELONG TO SYSTEM?
	JRST	[MOVEI	M,[ASCIZ |System|] ;YES, SAY SO
		 PUSHJ	P,MSG	;...
		 JRST	ETHDP8]	;AND CONTINUE
	MOVEI	M,[ASCIZ |Job |] ;OUTPUT JOB INFO
	PUSHJ	P,MSG		;...
	LDB	N,[POINT 9,.EIPJC(P1),35] ;GET JOB NUMBER
	PUSHJ	P,DECPRT	;OUTPUT
	MOVEI	M,[ASCIZ | Ctx |] ;OUTPUT CONTEXT INFO
	PUSHJ	P,MSG		;...
	LDB	N,[POINT 9,.EIPJC(P1),26] ;GET CONTEXT NUMBER
	PUSHJ	P,DECPRT	;OUTPUT

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

ETHDP8:	MOVE	T1,(P2)		;GET PORTAL ID
	PUSHJ	P,ETHRPC	;READ PORTAL COUNTERS
	  JRST	ETHDP9		;ERROR, SKIP DISPLAY
	MOVE	P1,T1		;SAVE AOBJN POINTER TO BUFFER
	PUSHJ	P,TAB		;TAB TO DATAGRAMS TRANSMITTED COLUMN
	MOVE	N,.ECPDX(P1)	;GET DATAGRAMS TRANSMITTED COUNT
	TLNE	F,FL.INC	;WANT INCREMENTAL?
	SUB	N,DGMXMT(J)	;YES, COMPUTE VALUE
	PUSHJ	P,DECB8		;PRINT OUT
	PUSHJ	P,TAB		;TAB TO DATAGRAMS RECEIVED COLUMN
	MOVE	N,.ECPDR(P1)	;GET DATAGRAMS RECEIVED COUNT
	TLNE	F,FL.INC	;WANT INCREMENTAL?
	SUB	N,DGMRCV(J)	;YES, COMPUTE VALUE
	PUSHJ	P,DECB8		;PRINT OUT
	PUSHJ	P,TAB		;TAB TO FREE QUEUE ERROR COLUMN
	MOVE	N,.ECPUU(P1)	;GET FREE QUEUE ERROR COUNT
	TLNE	F,FL.INC	;WANT INCREMENTAL?
	SUB	N,DGMFQE(J)	;YES, COMPUTE VALUE
	PUSHJ	P,DECB6		;YES, PRINT OUT
	MOVE	N,.ECPDX(P1)	;GET DATAGRAMS TRANSMITTED COUNT
	MOVEM	N,DGMXMT(J)	;SAVE CURRENT VALUE
	MOVE	N,.ECPDR(P1)	;GET DATAGRAMS RECEIVED COUNT
	MOVEM	N,DGMRCV(J)	;SAVE CURRENT VALUE
	MOVE	N,.ECPUU(P1)	;GET FREE QUEUE ERROR COUNT
	MOVEM	N,DGMFQE(J)	;SAVE CURRENT VALUE
	AOJ	J,		;UPDATE TABLE INDEX
ETHDP9:	PUSHJ	P,CRLF		;FINISH STATUS LINE
	AOBJN	P2,ETHDP6	;LOOP BACK FOR ALL PORTALS
	POP	P,P2		;RESTORE CHANNEL LIST AOBJN POINTER

ETHDPX:	AOBJN	P2,ETHDP0	;LOOP BACK FOR ALL CHANNELS
	POPJ	P,		;AND RETURN
;ROUTINE TO READ ETHERNET CHANNEL LIST

ETHRCL:	MOVE	T1,[.ETRCL,,4]	;SET UP ETHNT. TO READ LIST
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RCLBFL	;SIZE OF BUFFER
	MOVEI	T2,RCLBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN

;ROUTINE TO READ ETHERNET CHANNEL INFORMATION

ETHRCI:	MOVEM	T1,ENTBLK+.ETCSW ;STORE CHANNEL ID
	MOVE	T1,[.ETRCI,,4]	;SET UP ETHNT. TO READ CHANNEL INFO
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RCIBFL	;SIZE OF BUFFER
	MOVEI	T2,RCIBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN

;ROUTINE TO READ ETHERNET CHANNEL COUNTERS

ETHRCC:	MOVEM	T1,ENTBLK+.ETCSW ;STORE CHANNEL ID
	MOVE	T1,[.ETRCC,,4]	;SET UP ETHNT. TO READ CHANNEL COUNTERS
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RCCBFL	;SIZE OF BUFFER
	MOVEI	T2,RCCBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN

;ROUTINE TO READ ETHERNET KONTROLLER LIST

ETHRKL:	MOVEM	T1,ENTBLK+.ETCSW ;STORE CHANNEL ID
	MOVE	T1,[.ETRKL,,4]	;SET UP ETHNT. TO READ KONTROLLER LIST
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RKLBFL	;SIZE OF BUFFER
	MOVEI	T2,RKLBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN

;ROUTINE TO READ ETHERNET KONTROLLER INFORMATION

ETHRKI:	MOVEM	T1,ENTBLK+.ETCSW ;STORE KONTROLLER ID
	MOVE	T1,[.ETRKI,,4]	;SET UP ETHNT. TO READ KONTROLLER INFO
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RKIBFL	;SIZE OF BUFFER
	MOVEI	T2,RKIBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN
;ROUTINE TO READ ETHERNET KONTROLLER COUNTERS

ETHRKC:	MOVEM	T1,ENTBLK+.ETCSW ;STORE KONTROLLER ID
	MOVE	T1,[.ETRKC,,4]	;SET UP ETHNT. TO READ KONTROLLER COUNTERS
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RKCBFL	;SIZE OF BUFFER
	MOVEI	T2,RKCBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN

;ROUTINE TO READ ETHERNET PORTAL LIST

ETHRPL:	MOVEM	T1,ENTBLK+.ETCSW ;STORE CHANNEL ID
	MOVE	T1,[.ETRPL,,4]	;SET UP ETHNT. TO READ PORTAL LIST
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RPLBFL	;SIZE OF BUFFER
	MOVEI	T2,RPLBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN

;ROUTINE TO READ ETHERNET PORTAL INFORMATION

ETHRPI:	MOVEM	T1,ENTBLK+.ETCSW ;STORE PORTAL ID
	MOVE	T1,[.ETRPI,,4]	;SET UP ETHNT. TO READ PORTAL INFO
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RPIBFL	;SIZE OF BUFFER
	MOVEI	T2,RPIBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN

;ROUTINE TO READ ETHERNET PORTAL COUNTERS

ETHRPC:	MOVEM	T1,ENTBLK+.ETCSW ;STORE PORTAL ID
	MOVE	T1,[.ETRPC,,4]	;SET UP ETHNT. TO READ PORTAL COUNTERS
	MOVEM	T1,ENTBLK+.ETFCN ;...
	MOVEI	T1,RPCBFL	;SIZE OF BUFFER
	MOVEI	T2,RPCBUF	;ADDRESS OF BUFFER
	DMOVEM	T1,ENTBLK+.ETAR1 ;...
	PJRST	ETHRXL		;READ LIST AND RETURN

;ROUTINE TO READ ETHERNET LIST AND RETURN AOBJN POINTER

ETHRXL:	MOVEI	T1,ENTBLK	;READ ETHERNET LIST
	ETHNT.	T1,		;...
	  POPJ	P,		;ERROR
	MOVNS	T1		;MAKE AOBJN POINTER TO BUFFER
	HRLZS	T1		;...
	HRR	T1,ENTBLK+.ETAR2 ;...
	JRST	CPOPJ1		;RETURN
;ROUTINE TO PRINT OUT AN ETHERNET ADDRESS

EADPRT:	PUSH	P,[5]		;SET LOOP ITERATION COUNT
	HRLI	T1,(POINT 8,)	;BUILD BYTE POINTER TO ADDRESS
	PUSH	P,T1		;SAVE BYTE POINTER ON STACK
EADPR1:	ILDB	N,(P)		;GET NEXT HEX BYTE
	PUSHJ	P,HEXPRB	;PRINT OUT
	MOVEI	CH,"-"		;PRINT HYPHEN
	PUSHJ	P,TYO		;...
	SOSLE	-1(P)		;DECREMENT AND TEST ITERATION COUNT
	JRST	EADPR1		;LOOP BACK FOR FIRST 5 BYTES
	ILDB	N,(P)		;GET LAST BYTE OF ADDRESS
	POP	P,(P)		;CLEAN STACK
	POP	P,(P)		;...
	PJRST	HEXPRB		;OUTPUT LAST BYTE AND RETURN

;ROUTINE TO PRINT OUT AN ETHERNET PROTOCOL TYPE

EPTPRT:	JUMPL	N,EPPPRT	;JUMP IF PSEUDO-PROTOCOL TYPE CODE
	PUSH	P,N		;SAVE PROTOCOL TYPE ON STACK
	ANDI	N,177777	;MASK TO SIXTEEN BITS
	LSH	N,-^D8		;GET HIGH BYTE
	PUSHJ	P,HEXPRB	;PRINT IT OUT
	MOVEI	CH,"-"		;PRINT HYPHEN
	PUSHJ	P,TYO		;...
	MOVE	N,0(P)		;GET LOW BYTE OF PROTOCOL TYPE
	ANDI	N,377		;...
	PUSHJ	P,HEXPRB	;PRINT OUT
	MOVEI	N,EPTTAB	;ADDRESS OF NAME STRING TABLE
EPTPR2:	HLRZ	CH,0(N)		;GET PROTOCOL TYPE
	JUMPE	CH,EPTPR3	;DONE WHEN 0 ENCOUNTERED
	CAME	CH,0(P)		;IS THIS OURS?
	AOJA	N,EPTPR2	;NO, CHECK REST OF TABLE
	HRRZ	M,0(N)		;YES, GET ADDRESS OF NIFTY STRING
	PUSHJ	P,SPACE		;SPACE OVER A BIT
	PUSHJ	P,MSG		;AND TYPE OUT TEXT
EPTPR3:	POP	P,N		;ADJUST STACK
	POPJ	P,		;AND RETURN

EPTTAB:	HEX (6001),,[ASCIZ\DNA/MOP\]	;DNA LOAD/DUMP (MOP)
	HEX (6002),,[ASCIZ\RmtCon\]	;DNA Remote Console (MOP)
	HEX (6003),,[ASCIZ\DECnet\]	;DNA Routing
	HEX (6004),,[ASCIZ\LAT\]	;Local Area Terminal
	HEX (6005),,[ASCIZ\Diag's\]	;Diagnostics
	HEX (6006),,[ASCIZ\Customer\]	;Reserved for customer
	HEX (6007),,[ASCIZ\SCA\]	;System Comm Architecture
	HEX (9000),,[ASCIZ\Loopback\]	;Loopback testing
EPTANF:! HEX (000),,[ASCIZ\ANF-10\]	;ANF (Patched on the fly)
	0


EPPPRT:	MOVNS	N		;CONVERT TO POSITIVE OFFSET
	CAILE	N,EPPMAX	;IN RANGE?
	SETZ	N,		;NO, GET DEFAULT
	MOVE	M,EPPTAB(N)	;GET ADDRESS OF PSEUDO-PROTOCOL TYPE STRING
	PJRST	MSG		;PRINT PROTOCOL TYPE AND RETURN

EPPTAB:	[ASCIZ	|-???-|]	;UNKNOWN
	[ASCIZ	|-Inf-|]	;INFO
	[ASCIZ	|-Prm-|]	;PROMISCUOUS
	[ASCIZ	|-Unk-|]	;UNKNOWN PROTOCOL TYPES
EPPMAX==.-EPPTAB-1		;MAXIMUM PSEUDO-PROCOTOL TYPE CODE
;ROUTINE TO PRINT OUT AN ETHERNET KONTROLLER ID

KTYPRT:	PUSH	P,P1		;SAVE P1
	PUSH	P,T4		;SAVE KONTROLLER NUMBER
	PUSH	P,T1		;AND CPU NUMBER
	CAILE	T2,KTYMAX	;KONTROLLER TYPE IN RANGE?
	SETZ	T2,		;NO, GET DEFAULT
	MOVE	P1,KTYTAB(T2)	;GET KONTROLLER TABLE VALUE
	HRRZ	M,P1		;GET ADDRESS OF KONTROLLER TYPE STRING
	PUSHJ	P,MSG		;PRINT KONTROLLER TYPE
	POP	P,N		;GET BACK CPU NUMBER
	TLNN	P1,(KY.CPU)	;PRINT CPU NUMBER?
	JRST	KTYPR1		;NO, SKIP OVER
	MOVEI	CH,"-"		;GET HYPHEN
	PUSHJ	P,TYO		;PRINT
	PUSHJ	P,DECPRT	;PRINT CPU NUMBER
KTYPR1:	POP	P,N		;GET BACK KONTROLLER NUMBER
	TLNN	P1,(KY.KNO)	;PRINT KONTROLLER NUMBER?
	JRST	KTYPR2		;NO, SKIP OVER
	MOVEI	CH,"-"		;GET HYPHEN
	PUSHJ	P,TYO		;PRINT
	PUSHJ	P,DECPRT	;PRINT KONTROLLER NUMBER
KTYPR2:	POP	P,P1		;RESTORE P1
	POPJ	P,		;AND RETURN

KY.CPU==1B0			;PRINT CPU NUMBER
KY.KNO==1B1			;PRINT KONTROLLER NUMBER
KTYTAB:	KY.CPU+KY.KNO+[ASCIZ |???|]	;UNKNOWN KONTROLLER TYPE CODE
	KY.CPU+       [ASCIZ |NI|]	;KLNI
	KY.KNO+       [ASCIZ |UNA|]	;DEUNA
KTYMAX==.-KTYTAB-1		;MAXIMUM KONTROLLER TYPE CODE

;ONLINE/OFFLINE STATUS STRINGS

ONFSTS:	[ASCIZ	|Offline|]
	[ASCIZ	|Online|]
>; END IFN FTNET
	SUBTTL	"Z" DISPLAY OF LAT SERVER COUNTERS

IFN FTNET,<
LATDPY:	MOVEI	M,[ASCIZ /LAT Status on/]
	PUSHJ	P,THISIM	;FIRE UP HEADER LINE
	TABSET	TABLAT		;SELECT LAT TABS
	MOVEI	M,[ASCIZ /Server      Received     Xmitted  Re-Xmitted   Seq error     Ill msg    Ill slot
/]
	PUSHJ	P,MSG
	DMOVE	T1,[.LAQUA+1
		    .LASAS]	;SET UP TO FIND ALL SERVERS
	DMOVEM	T1,LASARG
	DMOVE	T1,[^D20*7	;SPACE FOR 20 SERVERS
		    LASBUF]
	DMOVEM	T1,LASARG+.LABCT
	SETZM	LASARG+.LAQUA	;ZERO MEANS LIST ALL SERVERS
	MOVEI	T1,LASARG
	LATOP.	T1,
	  POPJ	P,
	HLRZ	T1,LASARG+.LABCT	;GET COUNT OF WORDS RETURNED
	IDIVI	T1,^D7			;CONVERT TO NUMBER OF SERVERS
	MOVN	P2,T1
	HRLZS	P2		;MAKE AN AOBJN POINTER
	HRRI	P2,LASBUF	;TO POINT TO LIST OF SERVER NAMES
LATDP1:	PUSHJ	P,CRLF
	DMOVE	T1,[.LAQUA+1
		    .LASAS]	;SET UP ARGS TO GET LAT INFO
	DMOVEM	T1,LASARG
	DMOVE	T1,[^D26
		    LASCBF]
	DMOVEM	T1,LASARG+.LABCT
	HRROI	T1,1(P2)	;MAKE CANONICAL ASCIZ POINTER
	MOVEM	T1,LASARG+.LAQUA	;AS QUALIFIER
	MOVEI	T1,LASARG
	LATOP.	T1,		;OH WHELL
	  JFCL
	HRRZ	T1,LASCBF+5
	MOVEI	CH,"*"
	CAIE	T1,2
	MOVEI	CH," "
	PUSHJ	P,TYO
	MOVEI	M,1(P2)		;POINT TO SERVER NAME
	PUSHJ	P,MSG		;OUTPUT IT
	MOVEI	CH,"("
	PUSHJ	P,TYO
	MOVEI	M,LASCBF+14
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ /)
/]
	PUSHJ	P,MSG
	DMOVE	T1,[.LAQUA+1
		    .LASCO]	;SET UP ARGS TO GET LAT COUNTERS
	DMOVEM	T1,LASARG
	DMOVE	T1,[^D8
		    LASCBF]	;8 COUNTERS
	DMOVEM	T1,LASARG+.LABCT
	HRROI	T1,1(P2)	;MAKE CANONICAL ASCIZ POINTER
	MOVEM	T1,LASARG+.LAQUA	;AS QUALIFIER
	MOVEI	T1,LASARG
	LATOP.	T1,		;OH WHELL
	  JFCL
	MOVE	P1,[-6,,LASCBF]
LATDP2:	PUSHJ	P,TAB
	MOVE	N,(P1)
	PUSHJ	P,DECB8
	AOBJN	P1,LATDP2
	ADDI	P2,6
	AOBJN	P2,LATDP1
	POPJ	P,
>; END IFN FTNET
	SUBTTL	"Q" DISPLAY OF THE SYSTEM QUEUES

QUEPRG:	PUSHJ	P,UNLOCK	;DEFEAT "V" COMMAND, ALLOW IPCF TO WORK
	PUSHJ	P,STROLL	;[611] START DISPLAY VARIABLES
	SETOM	NLTYPD		;[611] MARK THAT LINES HAVE BEEN TYPED
	MOVEI	M,[ASCIZ\Queues for\]  ;HEADER TEXT PREFIX
	PUSHJ	P,THISIM	;IDENTIFY US
	PUSHJ	P,CRLF		;BLANK LINE FOR NEATNESS
	TABSET	TAB7		;SET NORMAL TAB STOPS
	PUSHJ	P,SETVIS	;[611] DETERMINE VISIBILITY
	MOVE	A,FIRJOB	;COUNT OF "JOBS" TO SKIP
	MOVEM	A,EATCNT	;SET FOR EMSG

;ASK [SYSTEM] QUASAR FOR A LISTING OF THE QUEUES

	MOVE	A,[1000,,IPCPAG];PAGE POINTER TO USE
	PUSHJ	P,RSTIPC	;CLEAR OUT ANY SPURIOUS IPCF PACKETS
	SKIPN	B,QSRPID	;PID FOR [SYSTEM] QUASAR
	JRST	QSRPD2		;NO PID--TRY AGAIN
PIDOK:	PUSHJ	P,CREPAG	;CREATE PAGE TO SEND TO QUASAR
	 JRST	QUEERR		;NO PAGE, NO QUEUES
	MOVX	N,LIQALL	;LIST ALL QUEUES
	MOVEM	N,QSRFLG	;SET IN FLAG WORD TO QUASAR
	MOVE	N,[QSRMSG,,<IPCPAG*1000>]  ;BLT POINTER TO
	BLT	N,<IPCPAG*1000>+QSRLEN-1  ;COPY QUASAR REQUEST MESSAGE
	PUSHJ	P,SNDIPC	;SEND REQUEST TO QUASAR
	 JRST	QUEERR		;QUE ERROR

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;NOW RECEIVE IPCF REPLY PACKET(S)

QUELOP:	PUSHJ	P,RECIPC	;GET ANSWER PACKET
	 JRST	QUEERR		;DOESN'T WORK
	CAME	B,IPCBLK+.IPCFS	;THIS PACKET FROM [SYSTEM]QUASAR?
	JRST	QUELOP		;NO, EAT IT
	MOVEI	C,<IPCPAG*1000>+.OHDRS  ;FIRST ARGUMENT ADDRESS

;LOOP OVER ARGUMENT BLOCKS WITHIN IPCF MESSAGE

QUELO1:
;MACRO %53A(1072) AND MACTEN %2(26) BLOW THE POINTR FORM:
;	LDB	D,[POINTR ARG.HD(C),AR.LEN]  ;LENGTH OF THIS ARGUMENT BLOCK
;	LDB	N,[POINTR ARG.HD(C),AR.TYP]  ;TYPE OF THIS ARGUMENT BLOCK
	HLRZ	D,ARG.HD(C)	;LENGTH OF ARG BLOCK
	HRRZ	N,ARG.HD(C)	;TYPE OF ARG BLOCK
	CAIN	N,.ORDSP	;OPR DISPLAY ARGUMENT?
	JRST	QUELO6		;YES, JUST EAT IT
	MOVEI	M,ARG.DA(C)	;START OF TEXT (ASCIZ) STRING
	HRLI	M,(POINT 7,)	;MAKE ASCII BYTE POINTER
	MOVE	N,EATCNT	;GET EAT COUNTER
	CAME	N,FIRJOB	;STARTED DISPLAY YET?
	JRST	QUELO4		;YES, PASS TEXT VERBATIM
QUELO3:	MOVE	N,M		;COPY OF BYTE POINTER
	ILDB	CH,N		;GET A CHARACTER
	CAIE	CH,.CHCRT	;A <CR>?
	JRST	QUELO4		;NO, REAL TEXT, DISPLAY IT
	IBP	M		;YES, EAT IT
	IBP	M		;AND ASSUMED <LF> FOLLOWING
	JRST	QUELO3		;CHECK FOR MORE BLANK LINES
QUELO4:	PUSHJ	P,EMSG		;NO - GO DISPLAY THE TEXT
QUELO6:	SOSG	<IPCPAG*1000>+.OARGC  ;MORE ARGUMENT BLOCKS?
	JRST	QUELOS		;NO, SEE IF MORE IPCF PACKETS
	ADD	C,D		;POINT TO NEXT ARGUMENT BLOCK
	JRST	QUELO1		;BACK TO TYPE IT
;LOOP OVER ALL IPCF PACKETS COMPRISING ANSWER FROM [SYSTEM]QUASAR

QUELOS:	MOVE	N,<IPCPAG*1000>+.OFLAG  ;QUASAR FLAGS
	TXNE	N,WT.MOR	;MORE TO COME?
	JRST	QUELOP		;YES, GO READ IT
	PUSHJ	P,CHKDON	;NO, SEE HOW THIS SCREEN FARED
	JRST	QUEPRG		;NOT SO GOOD
	POPJ	P,		;OK

QSRPD2:	PUSH	P,A		;SAVE A
	MOVX	A,%SIQSR	;GETTAB ARG TO
	PUSHJ	P,GETZ		;GET PID FOR [SYSTEM] QUASAR OR ZERO
	MOVEM	A,QSRPID	;SAVE IT
	POP	P,A		;RESTORE A
	SKIPE	B,QSRPID	;ANY GOOD?
	JRST	PIDOK		;YES -- LET'S CONTINUE
QUEERR:	MOVEI	M,[ASCIZ\? Queues cannot be listed
\]				;HORRIBLE ERROR MESSAGE
	PJRST	MSG		;GO LIST IT ON SCREEN
	SUBTTL DCNNOD - Display DECnet node status

DCNNOD:	SET	1,XSIZE,1,YSIZE,0,TAB7 ; Set the terminal up

	MOVEI	M,[ASCIZ |  DECnet Node Status for System |]; Use this one for NON-ANSI

	PUSHJ	P,MSG		; Output  as a message
	PUSHJ	P,CONFI0	; Output the system name
	PUSHJ	P,SPACE		; Type a space
	PUSHJ	P,PDATIM	; and the date and time


	SET	1,XSIZE,2,YSIZE,0,TABDNN ; Set up header tab stops

	MOVEI	M,[ASCIZ |Node	 Delay	Hops	Cost	Links	Address	   Circuit|]
	PUSHJ	P,MSG		; Output it as a message
	SET	1,XSIZE,3,YSIZE,0,TABDNN ; Set up for Job information
	MOVX	T1,DN.FLK!<.DNLNN,,^D1024+3> ; Known, list, length
	MOVEM	T1,KNONOD	; Get list of known nodes
	MOVEI	T1,KNONOD	; Get the address of the list
	DNET.	T1,		; do it
	 RETURN			; None there
	MOVE	P1,KNONOD+.DNCNT; Get the count of nodes returned
	SUB	P1,FIRJOB	; Do the right thing
	JUMPLE	P1,CPOPJ	; Return if none
	MOVE	P2,FIRJOB	; Get the first job

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

DCNND0:	MOVE	T1,KNONOD+.DNNMS(P2)  ; Get the first one on the list
	JUMPE	T1,DCNND5	; Do the next one if no name
	MOVEM	T1,NODSTA+.DNNAM; Save as node name for DNET. function
	MOVX	T1,<XWD .DNNDI,.DNNLN> ; Get the function code and length
	MOVEM	T1,NODSTA	; Save it
	MOVEI	T1,NODSTA	; Get the address of the block
	DNET.	T1,		; Get the information
	 JRST	DCNND5		; None available
	LDB	T1,[POINTR(NODSTA+.DNRTR,DN.RCH)] ; Get the valid flag
	TRNE	F,FR.SKP	;Checking for "skip" (valid delay)?
	JUMPE	T1,DCNND5	;Yes, then skip if it isn't

	TRNE	F,FR.IDL	; List all or just active (suppress idle)?
	JRST	[LDB	T1,[POINTR(NODSTA+.DNLLI,DN.VLD)] ; Get links
		JUMPE	T1,DCNND5	 ; If invalid, then skip it
		LDB	T1,[POINTR(NODSTA+.DNLLI,DN.LNK)] ; Get links
		JUMPE	T1,DCNND5	; If none and valid, then skip it
		JRST	.+1]		; Continue on below
	MOVE	A,NODSTA+.DNNAM	; Get the node name we used
	CALL	SIXBP		; Type it out
	CALL	TAB		; And position for the next one

	LDB	N,[POINTR(NODSTA+.DNLLI,DN.DLY)] ; Get the delay
	SKIPGE	NODSTA+.DNLLI	; Blank field if not valid info
	CALL	DECB6		; Type it in decimal
NODT1:	CALL	TAB		; And position for the next one
	LDB	N,[POINTR(NODSTA+.DNRTR,DN.HOP)] ; Get the number of hops away
	CALL	DECB3		; Type it out
	CALL	TAB		; And position to the next one
	LDB	N,[POINTR(NODSTA+.DNRTR,DN.CST)] ; Get the cost
	CALL	DECB3		; Type it out
	CALL	TAB		; And to the next column
	LDB	N,[POINTR(NODSTA+.DNLLI,DN.VLD)] ; Get the number of links
	SKIPE	N		; Anything there
	JRST	[LDB	N,[POINTR(NODSTA+.DNLLI,DN.LNK)] ; Getactive links
		JUMPE	N,.+1		; Nothing if zero
		CALL	DECB4		; Print it out
		JRST .+1]		; And do the next one
	CALL	TAB		; No, then position to the next column

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVE	A,NODSTA+.DNADR	; Node address
	IDIVI	A,2000		; A := "area"; B := "node number"
	JUMPE	A,[MOVEI M,[ASCIZ\   \]	;Place holder text
		PUSHJ	P,MSG		;Type it out
		JRST	DCNND2]		;And cap off with the local number
	MOVE	N,A		; N := area number
	PUSHJ	P,DECB2		; Type out two-digit number
	MOVEI	CH,"."		; Area separator
	PUSHJ	P,TYO		; Tell user the difference
DCNND2:	MOVE	N,B		; N := local node number
	PUSHJ	P,DECB4		; Type out four-digit node number
	PUSHJ	P,TAB		; Cap off address column, position to next
	SKIPN	NODSTA+.DNCKT	; Have an output circuit
	JRST	[MOVEI	M,[ASCIZ |     |]
		CALL	MSG		; Type it out
		JRST	DCNND3]		; And type out tab and next field
	MOVEI	M,NODSTA+.DNCKT	; Get the byte pointer back
	CALL	MSG		; Type it out
DCNND3:
;[604]	CALL	TAB		; Tab to right place
;[604]	LDB	T1,[POINTR(NODSTA+.DNRTR,DN.BNT)] ; Get the node type
;[604]	CAIGE	T1,2		; Is it legal
;[604]	 JRST	DCNND1		; Nope
;[604]	MOVE	M,[[ASCIZ |Phase II|]
;[604]		   [ASCIZ |Phase III|]
;[604]		   [ASCIZ |Phase IV|]]-2(T1) ; Get the phase number
;[604]	CALL	MSG
DCNND1:	CALL	CRLF		; Type a CRLF

DCNND5:	AOS	P2		; Increment index
	SOJGE	P1,DCNND0	; Loop for the next one
	POPJ	P,		; or return to caller

	POPJ	P,		; Return to caller
	SUBTTL DCNSTA - Display DECnet link status information

DCNSTA:	SET	1,XSIZE,1,YSIZE,0,TAB7 ; Set the terminal up

	MOVEI	M,[ASCIZ |  DECnet Link Status for System |] ; Use this one for NON-ANSI

	PUSHJ	P,MSG		; Output  as a message
	PUSHJ	P,CONFI0	;Type out node name and time
	PUSHJ	P,SPACE		;Type a space
	PUSHJ	P,PDATIM	;Type the date and time

	SET	1,XSIZE,2,YSIZE,0,TABDNL ; Set up to type header
	MOVEI	M,[ASCIZ |Job	 Node	Chn	State	  XMIT	  RCVD	DOBJ	SOBJ	Seg	XFLOW	RFLOW|]
	CALL	MSG			; To the TTY

DCNJOB:	SET	1,XSIZE,3,YSIZE,0,TABDNL	; Reset for Job INFO

	SKIPN 	P1,FIRJOB		; Have A first job
	SETZM	P1			; Place for job number
	HRLZS	P1			; Job number is in the left half
	MOVEM	P1,DNTBLK+.DNJCN	; Save the job number

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

DCNJB1:	MOVX	X,DN.FLS!<XWD .DNSLS,.DNSLN>; Get a block of the correct length for all
	MOVEM	X,DNTBLK		; Save it
; Please note that in order for this to work, You must save the contents of
; DNTBLK+.DNJCN if you use the UUO block for something else.  Or else it
; will do the next function with garbage in this word.

	MOVEI	X,DNTBLK		; Get the address of the block
	DNET.	X,			; Get the arguments
	 SKIPA				; Skip if he errors to us
	SKIPN	DNTBLK+.DNJCN		; Any jobs returned
	POPJ	P,			; No, then return to caller
	TRNN	F,FR.IDL		; Want to supress "idle" links?
	JRST	DCN.0			; No, print all links
	HRRZ	A,DNTBLK+.DNSTA		; Link status
	CAIN	A,'CW '			; Waiting for a connect?
	JRST	DCNJB1			; Yes, "idle", suppress
DCN.0:	HLRE	P1,DNTBLK+.DNJCN	; Get the job number in T1
	SKIPGE	P1			; Have a live one?
	JRST	[MOVEI	M,[ASCIZ |NRTSER|]
		CALL	MSG			; Output a line
		JRST	DCN.1]			; And continue on below
	MOVE	N,P1			; Get the job number
	PUSHJ	P,DECPRT		; Output a decimal number
DCN.1:	SKIPN	DNTBLK+.DNMPR		; Monitor process word?
	JRST	DCN.11			; no skip it.
	MOVEI	M,[ASCIZ |_|]		; Yes, type out additional info
	PUSHJ	P,MSG			; Type it out
	MOVE	N,DNTBLK+.DNMPR		; Get the process info (line number)
	PUSHJ	P,OCTPRT		; Print out an octal number
DCN.11:	CALL	TAB			; Go to the next column
	SKIPN	A,DNTBLK+.DNNOD		; Any node name
	JRST	[MOVEI	M,[ASCIZ |  --|]	; Get a string
		PUSHJ	P,MSG			; onto the terminal
		JRST	DCN.M]			; Do the next one
	CALL	SIXBP			; Output sixbit word
DCN.M:	CALL	TAB			; Go to the next column

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	HRRZ	N,DNTBLK+.DNJCN		; Get the channel
	CALL	DECB3			; Output it
	CALL	TAB			; Get to the next column
	HRLZ	A,DNTBLK+.DNSTA		; Get the status
	CALL	SPACE			; Space over to center within column
	CALL	SIXBP			; Output sixbit status word
	CALL	TAB			; And get to the next column
	HLRZ	N,DNTBLK+.DNMSG		; Get XMIT count
	JUMPE	N,DCN.NM		; And go to the Receive count
	CALL	DECB6			; Output it in Decimal
DCN.NM:	CALL	TAB			; Type a TAB
	HRRZ	N,DNTBLK+.DNMSG		; Get Received messages
	JUMPE	N,DCN.N2		; None, then don't output this
	CALL	DECB6			; Output the number in decimal
DCN.N2:	CALL	TAB			; Type a Tab
	HLRZ	N,DNTBLK+.DNOBJ		; Get the destination object type
	ANDI	N,377			; Make it 8-bits
	CALL	DCNTOB			; Type out object type
DCN.M1:	CALL	TAB			; Position it
	HRRZ	N,DNTBLK+.DNOBJ		; And the source
	ANDI	N,377			; Make it 8-bits
	CALL	DCNTOB			; Type out object type
DCN.M2:	CALL	TAB			; And on to the next column
	HRRZ	N,DNTBLK+.DNSEG		; Get the segment size
	CALL	DECB3			; And output it
	CALL	TAB			; And get to the next column
	HLRZ	T1,DNTBLK+.DNFLO	; Get the XMIT flow control option
	MOVE	M,FLOPTR(T1)		; Get the option
	CALL	MSG			; Output it
	CALL	TAB			; ANd type it out
	HRRZ	T1,DNTBLK+.DNFLO	; And the receive flow control option
	MOVE	M,FLOPTR(T1)		; Get the type
	CALL	MSG
	CALL	CRLF			; Output a CRLF
	JRST	DCNJB1			; DO the next job
;Type out DECnot object type names, or decimal object type if unknown

DCNTOB:	SETZ	M,			; No idea yet
	CAIG	N,DCNOTL		; Is it in our table?
	MOVE	M,DCNOTB(N)		; Get the object type name
	CAIN	N,^D63			; Is it DTR?
	MOVEI	M,[ASCIZ |DTR|]		; DTR/DTS
	CAIN	N,^D123			; PSTHRU?
	MOVEI	M,[ASCIZ |PST|]		; Get the passthrough task name
	CAIN	N,^D201			; TOPS-10/20 MS/MAIL?
	MOVEI	M,[ASCIZ |MAIL|]	; Get 36-bit mail name
	CAIN	N,^D255			; "-1" ?
	MOVEI	M,[ASCIZ | **|]		; Yeah, anything goes
	JUMPN	M,MSG			; Print out known object type name
	CALL	SPACE			; Elstwise one space for good form
	PJRST	DECPRT			; Print unknown object type numerically
;DCNOTB - DECnot object type table

DCNOTB:	[ASCIZ	|ANY|]		; 0 is any task
	[ASCIZ	|FAL|]		; 1 is FAL
	[ASCIZ	|URD|]		; 2 is Unit Record Devices
	[ASCIZ	|ATS|]		; 3 is application terminal service
	[ASCIZ	|CTS|]		; 4 is Command terminal Services
	[ASCIZ	|TCV|]		; 5 is RSX-11M Task control Version 1
	[ASCIZ	|OSI|]		; 6 Operator Services Interface
	[ASCIZ	|NRM|]		; 7 Node Resources Manager
	[ASCIZ	|70G|]		; 8 IMB 3270-BSC Gateway
	[ASCIZ	|80G|]		; 9 IBM 2780-BSC Gateway
	[ASCIZ	|90G|]		;10 IBM 3790-BSC Gateway
	[ASCIZ	|TPS|]		;11 TPS Application
	[ASCIZ	|RDA|]		;12 RT-11 DIBOL Application
	[ASCIZ	|T2TH|]		;13 TOPS-20 Terminal Handler
	[ASCIZ	|T2RS|]		;14 TOPS-20 Remote Spooler
	[ASCIZ	|TCV2|]		;15 RSX-11M Task control version 2
	[ASCIZ	|TLK|]		;16 TLK Utility
	[ASCIZ	|FAL|]		;17 FAL
	[ASCIZ	|RTL|]		;18 RSX-11M Remote Task Loader
	[ASCIZ	|NICE|]		;19 NICE process
	[ASCIZ	|MTP|]		;20 RSTS/E Media Transfer Program
	[ASCIZ	|HNCT|]		;21 RSTS/E Homogeneous Network CTH
	[ASCIZ	|MAIL|]		;22 Mail Listener
	[ASCIZ	|NRT|]		;23 NRT program
	[ASCIZ	|CTH|]		;24 Concentrator Terminal Handler
	[ASCIZ	|LBM|]		;25 Loop back mirror
	[ASCIZ	|ERCV|]		;26 Event Receiver
	[ASCIZ	|VPMU|]		;27 VAX/VMS Personal Message Utility
	[ASCIZ	|FTS|]		;28 FTS
	[ASCIZ	|PHON|]		;29 PHONE Utility
	[ASCIZ	|DDMF|]		;30 Distributed Data Management Facility
	[ASCIZ	|X25G|]		;31 X.25 Gateway server
	[ASCIZ	|UETP|]		;32 UETP
	[ASCIZ	|VMAI|]		;33 VAX/VMS MAIL utility
	[ASCIZ	|X29S|]		;34 X.29 Terminal server
	[ASCIZ	|CAL|]		;35 Calendar system
	[ASCIZ	|X25A|]		;36 X.25 Gateway access
	[ASCIZ	|SNAG|]		;37 SNA Gateway access
	[ASCIZ	|SNAR|]		;38 SNA RJE utility
	Z			;39
	Z			;40
	Z			;41
	[ASCIZ	|CTRM|]		;42 CTERM terminal protocol

	DCNOTL==.-DCNOTB	; Maximum



;FLOPTR - Pointers to output flow control options

FLOPTR:	POINT 7,[ASCIZ |     |]
	POINT 7,[ASCIZ | None|]
	POINT 7,[ASCIZ | Seg |]
	POINT 7,[ASCIZ | Msg |]
	SUBTTL	PAGE CREATE/DESTROY SUBROUTINES

;CREPAG  --  CREATE A PAGE
;CALL IS:
;
;	MOVX	A,<PAGE>
;	PUSHJ	P,CREPAG
;	 ERROR
;	NORMAL
;
;WHERE <PAGE> IS THE DESIRED PAGE NUMBER.
;
;ON ERROR THE PAGE COULD NOT BE CREATED (ERROR CODE IN M)
;
;ON NORMAL RETURN THE DESIRED PAGE IS CREATED AND ADDRESSABLE.
;
;USES M, N, N1

CREPAG:	HRRZ	N1,A		;DESIRED PAGE NUMBER
	MOVEI	N,1		;ONLY ONE ARGUMENT
	MOVE	M,[.PAGCD,,N]	;PAGE. ARGUMENT BLOCK TO
	PAGE.	M,		;CREATE A NEW PAGE
	 CAIN	M,PAGCE%	;ERROR UNLESS PAGE ALREADY EXISTED
	AOS	(P)		;SUCCESSFUL RETURN
	POPJ	P,		;RETURN AS APPROPRIATE



;DESPAG  --  DESTROY PAGE
;CALL IS:
;
;	MOVX	A,<PAGE>
;	PUSHJ	P,DESPAG
;	 ERROR
;	NORMAL
;
;WHERE <PAGE> IS THE DESIRED PAGE TO BE DESTROYED.
;
;ON ERROR THE PAGE COULD NOT BE MADE NON-EXISTANT
;
;ON NORMAL RETURN THE PAGE DOES NOT EXIST
;
;USES M, N, N1

DESPAG:	HRRZ	N1,A		;DESIRED PAGE NUMBER
	TXO	N1,PA.GAF	; (WANT TO DESTROY)
	MOVEI	N,1		;ONLY ONE ARGUMENT
	MOVE	M,[.PAGCD,,N]	;PAGE. ARGUMENT BLOCK TO
	PAGE.	M,		;DESTROY THE PAGE
	 CAIN	M,PAGME%	;ERROR ONLY IF PAGE ALREADY NON-EXTANT
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;RETURN AS APPROPRIATE
	SUBTTL	IPCF SEND/RECEIVE ROUTINES

;RSTIPC  --  RESET IPCF (CLEAR ANY "BOGUS" PAGES)
;CALL IS:
;
;	MOVX	A,<PAGE>
;	PUSHJ	P,RSTIPC
;	RETURN
;
;WHERE <PAGE> IS A SCRATCH PAGE AVAILABLE TO RECEIVE ANY STRAY
;IPCF PAGES.
;
;ON RETURN THERE ARE NO IPCF PAGES WAITING TO BE RECEIVED BY THIS
;JOB.
;
;USES M, N, N1

RSTIPC:	PUSHJ	P,DESPAG	;MAKE SURE PAGE AVAILABLE TO RECEIVE
	 POPJ	P,		;DUH?
	MOVX	N,IP.CFB!IP.CFV	;NON-BLOCKING RECEIVE
	MOVEM	N,IPCBLK+.IPCFL	;SET FLAGS WORD
	SETZM	IPCBLK+.IPCFS	;CLEAR SENDERS PID
	SETZM	IPCBLK+.IPCFR	;CLEAR RECEIVERS PID
	MOVEM	A,IPCBLK+.IPCFP	;SET WHERE TO RECEIVE PAGE
	MOVE	N,[.IPCFP+1,,IPCBLK]  ;IPCFR. ARGUMENT BLOCK TO
	IPCFR.	N,		;RECEIVE ANY PAGE (NON-BLOCKING)
	 POPJ	P,		;GOOD ENOUGH
	JRST	RSTIPC		;AH HA! MAKE SURE NO MORE PAGES LEFT
;RECIPC  --  RECEIVE IPCF PAGE, BLOCKING
;CALL IS:
;
;	MOVX	A,<PAGE>
;	PUSHJ	P,RECIPC
;	 ERROR
;	NORMAL
;
;WHERE <PAGE> IS THE DESIRED PAGE NUMBER TO RECEIVE THE IPCF
;MESSAGE PACKET.
;
;ON ERROR RETURN EITHER THE PAGE COULD NOT BE MADE AVAILABLE
;(DESTROYED) FOR RECEIVING OR AN IPCF FAILURE OCCURED
;
;ON NORMAL RETURN THE IPCF MESSAGE PACKET IS IN <PAGE> AND N
;CONTAINS THE IPCF "ASSOCIATED VARIABLE"
;
;USES M, N, N1

RECIPC:	PUSHJ	P,DESPAG	;MAKE SURE PAGE AVAILABLE
	 POPJ	P,		;IS NOT, ERROR
	MOVX	N,IP.CFV	;PAGE MODE (BLOCKING)
	MOVEM	N,IPCBLK+.IPCFL	;SET IPCF FLAGS
	SETZM	IPCBLK+.IPCFS	;CLEAR SENDERS PID
	SETZM	IPCBLK+.IPCFR	;CLEAR RECEIVERS PID
	MOVEM	A,IPCBLK+.IPCFP	;SET RECEIVE POINTER
	MOVE	N,[.IPCFP+1,,IPCBLK]  ;IPCFR. ARGUMENT POINTER TO
	IPCFR.	N,		;RECEIVE A PAGE
	 POPJ	P,		;ERROR
	JRST	CPOPJ1		;SUCCESS, MESSAGE IN PAGE <PAGE>
;SNDIPC  --  SEND AN IPCF MESSAGE PAGE
;CALL IS:
;
;	MOVX	A,<PAGE>
;	MOVX	B,<PID>
;	PUSHJ	P,SNDIPC
;	 ERROR
;	NORMAL
;
;WHERE <PAGE> IS THE PAGE NUMBER OF THE MESSAGE PAGE TO BE SENT,
;AND <PID> IS THE IPCF PID TO WHOM THE MESSAGE IS TO BE SENT.
;
;ON ERROR THE MESSAGE COULD NOT BE SENT (ERROR OTHER THAN RECEIVER
;OR SYSTEM FULL)
;
;ON NORMAL THE IPCF MESSAGE PAGE HAS BEEN SENT.
;
;USES M, N, N1

SNDIPC:	MOVX	N,IP.CFV	;PAGE MODE
	MOVEM	N,IPCBLK+.IPCFL	;SET FLAGS WORD
	SETZM	IPCBLK+.IPCFS	;CLEAR SENDERS PID
	MOVEM	B,IPCBLK+.IPCFR	;SET RECEIVERS PID
	MOVEM	A,IPCBLK+.IPCFP	;SET MESSAGE POINTER
SNDIPD:	MOVE	N,[.IPCFP+1,,IPCBLK]  ;IPCFS. ARGUMENT POINTER TO
	IPCFS.	N,		;SEND THE IPCF MESSAGE PAGE
	 CAIA			;MAYHAPS AN ERROR
	JRST	CPOPJ1		;PACKET SENT
	CAIE	N,IPCRR%	;RECEIVER FULL?
	CAIN	N,IPCRY%	;OR SYSTEM FULL?
	CAIA			;YES, NOT REALLY AN ERROR
	POPJ	P,		;ERROR
	MOVEI	N,1		;ONE SECOND
	SLEEP	N,		;TO WAIT FOR THINGS TO IMPROVE
	JRST	SNDIPD		;TRY ANOTHER SEND
SUBTTL SUBROUTINES FOR STATUS COMPUTATION

;SUBROUTINE TO READ JOB DATA AND VARIOUS PARAMETERS

IJBDAT:	MOVE	A,[%CNSTS]	;GET FEATURES
	CALL	GETZ		;IF ANY THERE
	MOVEI	B,^D50		;50 HERTZ??
	TXNN	A,ST%CYC	;IF 60 HERTZ THEN
	MOVEI	B,^D60		;CHANGE THE VALUE
	MOVEM	B,FREAK		;REMEMBER FREQUENCY
	MOVE	A,[%VMPPB]	;GETTAB INDEX TO
	PUSHJ	P,GETZ		;READ "PER-PROCESS" START ADDRESS
	HRLI	A,1		;*** HO HUM ASSUME SECTION 1
	HRRZM	A,VMPPB0	;SET SECTION-0 PER-PROCESS BEGIN ADDRESS
	MOVEM	A,VMPPB1	;SET SECTION-1 PER-PROCESS BEGIN ADDRESS
	MOVE	A,[%VMPPE]	;GETTAB INDEX TO
	PUSHJ	P,GETZ		;READ "PER-PROCESS" END (+1) ADDRESS
	HRLI	A,1		;*** HO HUM ASSUME SECTION 1
	HRRZM	A,VMPPE0	;SET SECTION-0 PER-PROCESS END ADDRESS
	MOVEM	A,VMPPE1	;SET SECTION-1 PER-PROCESS END ADDRESS
	MOVE	A,XDDBLD	;GET DDBLDB VALUE FROM THE SYSTEM
	PUSHJ	P,GETZ		;SEE IF GETTAB IMPLEMENTED
	MOVEM	A,VDDLDB	;REMEMBER THE VALUE
	PUSHJ	P,GUPTIM	;GET SYSTEM UPTIME
	MOVEM	A,UPTIME	;FOR INCREMENTAL DISPLAYS
	SETZM	TTYTAB		;FIND ADDRESS OF TTYTAB
	MOVEI	A,10		;TABLE INDEX FOR GETTAB UUO
	PUSHJ	P,GET0		;TRY TO GET THE SPY ADDRESS
	JRST	IJBDA1		;LOOK UP INDIVIDUALLY
	JRST	IJBDA1		;PEEK NEEDED
	MOVEM	N1,TTYTAB	;FOR LATER
IJBDA1:	PJOB	A,
	MOVEM	A,MYJOB		;GET JOB NUMBER
	SETOM	TTYFLG		;SUPPOSE TOPS10
	MOVE	A,[%CNMNT]	;TRY TO GET MONITOR TYPE
	CALL	GETZ		;GET IT OR A ZERO
	LDB	A,[POINT 6,A,23];GET MONITOR TYPE
	CAIE	A,1		;TOPS-10?
	JRST	IJBDA2		;NO TRY UUO'S
	TLNE	F,FL.PEK	;CLAIRVOYANT?
	JRST	IJBDA3		;YES THEN ALL SET
IJBDA2:	SETZM	TTYFLG		;ASSUME DETACHED
	MOVE	A,MYJOB		;GET LINE NUMBER OF MY JOB
	TRMNO.	A,		;TRY TO GET INDEX
	JRST	IJBDA3		;I CANNOT HELP YOU
	AOS	TTYFLG		;MAKE FLAG >0
	MOVSI	A,(SIXBIT /CTY/);GET INDEX OF CTY
	IONDX.	A,		;AND GET ITS INDEX
	SETOM	A		;ERROR NEVER MATCH
	MOVEM	A,CTYNDX	;REMEBER CTY INDEX

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

IJBDA3:	MOVE	A,XOPPN		;GET GETTAB PARAMETER
	PUSHJ	P,GETZ		;GO READ OPERATOR PPN
	SKIPE	A		;  SKIP IF ERROR
	MOVEM	A,OPRPPN	;ELSE STORE AWAY
	HRROI	A,.GTSTS	;MY STATUS
	PUSHJ	P,GETA
	HRROI	B,.GTPPN	;MY PPN
	GETTAB	B,
	  TLOA	B,-1		;NON DISK SYSTEM-FLAG AS UNGODLY
	CAMN	B,OPRPPN	;SEE IF OPERATOR
	TXNN	A,JS$LOG	;YES-LOGGED IN?
	SKIPA			;NOT GODLY
	TLO	F,FL.GOD	;WE'RE GOD
	MOVEM	B,ME
	MOVE	A,XOPR
	PUSHJ	P,GETA		;FIND OUT WHO'S OPERATOR
	MOVEM	A,OPR
	MOVE	A,XSPPN		;WHERE IS SYS
	PUSHJ	P,GETZ
	SKIPE	A
	MOVEM	A,SYSPPN	;IF NONE, DONT STORE
	MOVX	A,%LDOLD
	PUSHJ	P,GETZ
	MOVEM	A,OLDPPN
	MOVX	A,%LDNEW
	PUSHJ	P,GETZ
	MOVEM	A,NEWPPN
	MOVE	A,XLPPN		;GET GETTAB PARAMETER
	PUSHJ	P,GETZ		;GO READ LOGIN PPN
	SKIPE	A		;  SKIP IF ERROR
	MOVEM	A,LOGPPN	;ELSE STORE AWAY
	MOVX	A,%CNDCH	;FETCH LDBDCH OFFSET FOR "T" DISPLAY
	PUSHJ	P,GETZ		;GET IT OR ZERO
	SKIPN	A
	MOVEI	A,23		;DEFAULT TO 702
	MOVEM	A,DCHOFF	;SAVE IT
	MOVX	A,%CNLNP	;AOBJN POINTER TO LINTAB
	PUSHJ	P,GETZ		;FETCH
	HRRZS	A		;ISOLATE ADDRESS
	PUSHJ	P,MPEEK		;GET LDB ADDRESS
	TLZ	A,^-37		;ISOLATE
	HLLZM	A,LTBOFF	;SAVE AS LINTAB OFFSET

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVSI	B,LQTAB
	SETZ	C,		;CLEAR WORK AREA
QTLP:	MOVEI	A,.GTWSN	;GET Q TABLE FROM MONITOR
	HRL	A,B
	PUSHJ	P,GETZ
	JUMPE	A,QTLP1		;ZERO WHEN RUN OUT
	MOVEM	A,QTAB(B)	;STORE QUEUE SIXBIT
	MOVE	D,[POINT 12,QTAB(B)] ;GET BYTE-POINTER FOR QUEUE NAMES
	HRLI	C,-3		;GET AOBJN WORD FOR 3 ENTRIES / DATA ITEM
QTLP2:	ILDB	A,D		;GET NEXT QUEUE ENTRY
	CAIN	A,'SL'		;"SL" STATE?
	HRRZM	C,SLQ		;YES, REMEMBER Q CODE
	CAIN	A,'TI'		;"TI" STATE?
	HRRZM	C,TIQ		;YES, REMEMBER Q CODE
	CAIN	A,'EW'		;"EW" STATE?
	HRRZM	C,EWQ		;YES, REMEMBER Q CODE
	AOBJN	C,QTLP2		;LOOP OVER 3 ENTRIES PER WORD
	AOBJN	B,QTLP
QTLP1:
	MOVE	A,XSTATS
	PUSHJ	P,GETZ
	MOVEM	A,STATES
	JUMPE	A,DNTSTO	;DONT OVERRIDE TCKSEC IF GETTAB UUO UNDEFINED
	MOVEI	B,^D60
	TLNE	A,4000
	MOVEI	B,^D50
	MOVEM	B,TCKSEC
	TLNE	A,100		;NEW SCANNER SERVICE?
	TLO	F,FL.SCN	;YES. REMEMBER IT.
	TLNN	A,(6B9)		;SEE IF 5.03
	JRST	DNTSTO		;NO--SKIP PTY
	MOVE	A,XPTYCN	;YES--GET PTY RANGE
	PUSHJ	P,GETZ
	HLRZM	A,PTYOFS
	ADD	A,PTYOFS
	HRRZM	A,PTYMAX
DNTSTO:	MOVX	A,%SIQSR	;GETTAB ARGUMENT TO
	PUSHJ	P,GETZ		;GET THE PID FOR [SYSTEM]QUASAR
	MOVEM	A,QSRPID	;SAVE IT FOR QUEPRG
	MOVE	A,XSEGPT
	PUSHJ	P,GETA
	MOVEM	A,SEGPTR
	HLRE	B,A
	MOVNM	B,SEGN
	HRRZM	A,JOBN
	HRRZM	A,GT.JOB		;FOR 60722 LOAD AND ONWARDS
	ADD	A,SEGN
	HRRZM	A,BOTH
	HRRZM	A,GT.SEG		;FOR 60722 AND ONWARDS
	HRRZ	B,.JBFF
	MOVEM	B,ZERLOW
	SUBTTL CORE ALLOCATION

	MOVE	D,[-NTABLE,,TABLE]
GJB6:	LDB	A,PSPYTB	;SPYABLE TABLE (SPYTAB SET)?
	JUMPE	A,GJB4		;NO, INTERNAL SYSDPY TABLE
	LDB	A,PTABLE	;YES, GET THE GETTAB TABLE INDEX
	TRZ	F,FR.PDB	;PREVENT OLD DATA TO CLOBBER US
	TLNE	F,FL.SPY	;CAN WE SPY
	PUSHJ	P,GET0		;TRY IT
	JRST	GJB4		;NO CANNOT SPY
	JRST	GJB4		;NO SPY THERE
	TRZE	F,FR.PDB	;PDB DATA
	JRST	GJB4		;YES ALLOCATE CORE
	HRR	B,(D)		;GET THE TABLE POINTER
	HRRM	N1,(B)		;AND STORE THE SPY ADDRESS
	MOVEI	B,1		;GET SPY FLAG
	JRST	GJB5		;SKIP CORE STUUF
GJB4:	MOVE	A,.JBFF		;START ALLOCATING CORE
	HRRZ	B,(D)		;GET TABLE ADDRESS POINTER
	HRRM	A,(B)		;STORE THE ADDRESS
	LDB	B,PSIZE		;GET INDEX IN TABLE SIZE TABLE
	MOVE	B,TSIZE(B)	;GET THE SIZE
	ADD	B,A		;GET NEW FREE ADDRESS
	MOVEM	B,.JBFF		;AND ACCOUNT IT
	CAMG	B,.JBREL	;DO WE HAVE ENOUGH CORE
	JRST	GJB7		;YES ALL IS THERE
	CORE	B,		;GET IT IF NOT THERE THEN
	JRST	NOCOR		;THAT'S THE END
GJB7:	SETZ	B,		;NO SPYING
GJB5:	DPB	B,PSPY		;SET THE SPY FLAG
	AOBJN	D,GJB6		;PROCESS ALL TABLES
	HRRZ	A,SGCNT		;ADDRESS OF SEGMENT COUNT
	ADD	A,SEGN		;AND COMPUTE LAST ADDRESS FOR
	SOS	A		;FOR A BLT
	MOVEM	A,.SEGLS	;IN SET UP LOOP
;	SETZM	@ZERLOW		;CLEAR CORE
;	MOVE	A,ZERLOW
;	HRLS	A
;	ADDI	A,1
;ABOVE 4 INSTRUCTIONS LEFT OVER??? OR NEXT INSTRUCTION LOST???
	POPJ	P,

NOCOR:	OUTSTR	[ASCIZ /?Need More Core
/]
	RESET
	LOGOUT
GJBDAT:	MOVN	D,JOBN		;MINUS THE NUMBER OF JOBS
	HRLZS	D		;-JOBN,,0	FOR AOBJN
GJBL2:	SKIPN	B,TTYTAB	;CANN DATA BE SPIED?
	JRST	GJBL5		;NO GETTAB IT
	HLRZ	C,D		;GET JOB NUMBER
	ADD	B,D		;AND GET ADDRES
	MOVE	B,(B)		;ELSE DIRECTLY FROM SPY SEGMENT
	JRST	GJBL6		;SKIP GETTAB STUFF
GJBL5:	MOVS	B,D		;GET THE JOB NUMBER
	HRRI	B,10		;AND THE TABLE INDEX
	GETTAB	B,		;AND GET THE TTYTAB ENTRY
	JRST	GJB3
GJBL6:	LDB	J,TPCJOB	;IF OLD SCNSRF, GET JOB NO
	TLNE	F,FL.SCN	;NEW SCNSER?
	MOVEI	J,0(D)		;YES. DIFFERENT LAYOUT. GET JOB NO.
	SETZM	@TTLDB
	TLZ	B,-1
	JUMPE	B,GJBN2
	MOVEI	A,$DVNAM(B)	;GET TTY NAME
	PUSHJ	P,MPEEK		;GET THE WORD
	MOVEM	A,@TTLDB	;STORE IN TABLE
	MOVEI	A,$DVIOS(B)	;GET TTY DEVIOS
	PUSHJ	P,MPEEK		;GET THE WORD
	MOVEM	A,@TTIOS	;STORE
	TLNN	F,FL.SCN	;WHICH SCANNER LAYOUT?
	JRST	GJBN2		;OLD.
	MOVE	A,VDDLDB	;GET OFFSET
	ADDI	A,(B)		;AND GET ADDRESS
	PUSHJ	P,MPEEK		;GET THE VALUE
	TRNE	A,-1		;ANY LDB LINK?
	JRST	GJBN2		;YES. OK TO TYPE NAME.
	HRLM	A,@TTLDB
GJBN2:	AOBJN	D,GJBL2		;ALL JOBS

GJB3:	MOVE	J,MYJOB
	MOVE	A,@TTLDB
	CAME	A,[SIXBIT /CTY/]
	CAMN	A,OPR
	TLO	F,FL.GOD
	MOVE	D,[XWD -NTAB,TABPTR]
INIT0:	LDB	B,PSPY		;SPYABLE?
	JUMPN	B,INIT1		;THEN FORGET LOOKUP
	LDB	B,PSIZE		;GET THE TABLE SIZE
	MOVN	B,TSIZE(B)	;VIA INDEX
	MOVSS	B		;SWAP HALVES
	HRRZ	C,(D)		;GET POINTER TO TABLE POINTER
	HRR	B,(C)		;GET TABLE ADDRESS
INIT2:	LDB	J,PTABLE	;GET THE TABLE VALUE
INIT3:	MOVE	A,J		;GET GETTAB PARAMETER
	PUSHJ	P,GETZ		;GET THE VALUE
	MOVEM	A,(B)		;STORE THE RESULT
	ADD	J,[1,,0]	;NEXT JOB
	AOBJN	B,INIT3		;FOR ALL TABLE MEMBERS
INIT1:	AOBJN	D,INIT0
	MOVE	A,SGCNT
	HRLS	A
	SETZM	(A)
	ADDI	A,1
	BLT	A,@.SEGLS
	POPJ	P,0		;END OF GET JOB DATA ROUTINE
;JBTSGN ENTRIES CONVERTED HERE

GETSGN:	MOVE	A,@JBSGN	;GET THE ENTRY
CNVSGN:	SKIPE	A		;ANYTHING THERE?
	TRNN	F,FR.NSF	;SOMETHING, DO WE NEED TO CONVERT IT?
	POPJ	P,		;RETURN
	MOVEI	A,1(A)		;ADDRESS OF OLD JBTSGN DATA IN HIGH SEG BLOCK
	PJRST	MPEEK4		;FETCH OLD JBTSGN DATA AND RETURN
;PSEUDO OPCODES AREA INTERPRETED HERE

PSEUDO:	LDB	T1,[POINT 9,(A),8]	;GET THE OPCODE
	CAILE	T1,.OPMAX	;VALID??
	AOJA	A,PSEUDO	;SEE IF THIS HELPS
	PUSH	P,A		;SAVE PSEUDO PC
	CALL	@PSOPC(T1)	;DO THE OPERATION
	POP	P,A		;RESTORE THE PC
	AOJA	A,PSEUDO	;THERE IS ARETURN CODE

PSOPC:	.PRTXT			;PRINT TEXT
	.PRGTD			;PRINT GETTAB VALUE DECIMAL
	CRLF			;PRINT CRLF
	.STOP			;LAST INSTRUCTION
	PLD			;PRINT LEFT HALF IN DECIMAL
	PRD			;PRINT RIGHT HALF IN DECIMAL
	GTB			;DO GETTAB INTO CEL
	PFLS			;PRINT A FLOAT WITH SCALE FACTOR
	TAB			;PRINT A TAB
	PLPA			;PRINT LEFT PAREN
	PRPA			;PRINT RIGHT PAREN
	OPPER			;PRINT PERIOD
	OPPLS			;PRINT A PLUS
	PRDP			;PRINT RIGHT HALF DECIMAL PADDED


.PRTXT:	HRRZ	M,(A)		;GET THE ADDRESS
	PJRST	MSG		;RETURN VIA MSG

.PRGTD:	MOVE	A,(A)		;GET GETTAB CODE
	TLZ	A,777000	;ZAP THE OPCODE
	CALL	GETZ		;ZERO OR VALUE
	MOVE	N,A		;GET THE VALUE
	PJRST	DECPRT		;RETURN VIA DECIMAL PRINTER

.STOP:	POP	P,A		;POP OFF RETURN
	POP	P,A		;AND SAVED A
	JRST	1(A)		;BACK TO NORMAL CODE

PLD:	HLRZ	N,@(A)		;GET THE VALUE
	PJRST	DECPRT		;AND PRINT IT
PRDP:	AOS	-1(P)		;POINT TO FACTOR
	MOVE	N,@-1(P)	;LOAD THE FACTOR
PRDP0:	IDIVI	N,^D10		;GET REDUCED SCALE
	HRRZ	N1,@(A)		;AND GET THE DATA
	CAMG	N,N1		;PADDING NEEDED
	JRST	PRDP1		;NO TYPE IT
	MOVEI	CH,"0"		;GET A ZERO
	CALL	TYO		;PRINT THE PADDING CHAR
	JRST	PRDP0		;TRY IT AGAIN
PRDP1:	HRRZ	N,@(A)		;GET DATA
	JUMPN	N,DECPRT	;PRINT NON ZERO VALUES ONLY
	POPJ	P,

PRD:	HRRZ	N,@(A)		;GET THE VALUE
	PJRST	DECPRT		;AND PRINT IT

GTB:	MOVE	A,(A)		;GET CODE
	TLZ	A,777000	;AFTER MASKING OPCODE
	CALL	GETZ		;GET ZERO OR VALUE IN A!
	AOS	T1,-1(P)	;POINT TO TARGET ADDRESS
	MOVEM	A,@(T1)		;AND STORE THE VALUE
	RETURN

PFLS:	MOVE	N,@(A)		;GET THE FLOATING NUMBER
	AOS	-1(P)		;POINT TO SCALE FACTOR
	FLTR	N1,@-1(P)	;GET THE SCALE FLOATING
	FMPR	N,N1		;AND GET THE PART WE WANT TO SEE
	FIXR	N,N		;FIX THE RESULT
	IDIV	N,@-1(P)	;NOW USE IT AS AN INTEGER
	PUSH	P,N1		;SAVE FRACTION
	CALL	DECPRT		;PRINT IT DECIMAL
	MOVEI	CH,"."		;TAKE DIVIDING CHARACTER
	CALL	TYO		;AND PRINT THAT
	POP	P,N		;GET FRACTION
	PJRST	DECPRT		;AND PRINT THAT

PLPA:	MOVEI	CH,"("		;GET LEFT PAREN
	PJRST	TYO		;AND PRINT IT

OPPER:	MOVEI	CH,"."		;GET A PERIOD
	PJRST	TYO		;AND PRINT IT

OPPLS:	MOVEI	CH,"+"		;GET A PLUS
	PJRST	TYO		;AND PRINT IT

PRPA:	MOVEI	CH,")"		;GET RIGHT PAREN
	PJRST	TYO		;AND TYPE IT
SUBTTL SUBROUTINES FOR CHAR AND PAGE HANDLING

THISIS:	SET	1,XSIZE,1,YSIZE,0,TAB4
THISIZ:	PUSHJ	P,CONFIG	;TYPE SYSTEM NAME
	JRST	THISI1		;CONTINUE

;ENTER AT "THISIM" WITH HEADER TEXT IN "M" (TO REPLACE "THIS IS" STRING)

THISIM:	SET	1,XSIZE,1,YSIZE,0,TAB4
	PUSHJ	P,CONFIM	;SKIP THE "THIS IS" BLURB
THISI1:	PUSHJ	P,SPACE		;SPACE OVER
	PUSHJ	P,PDATIM	;TYPE CURRENT DATE AND TIME
	PUSHJ	P,SPACE		;SPACE OVER
	PUSHJ	P,GUPTIM	;GET SYSTEM UPTIME
	SUB	A,UPTIME	;A:= INCREMENTAL UPTIME
	ADDM	A,UPTIME	;KEEP TOTAL UP TO DATE
	TLNN	F,FL.INC	;INCREMENTAL OR TOTAL?
	MOVE	A,UPTIME	;TOTAL
	MOVEM	A,UPTINC	;SAVE FOR LATER USE
	MOVEI	M,[ASCIZ/(+) /]	;IN CASE INCREMENTAL
	TLNE	F,FL.INC	;INCREMENTAL DISPLAY?
	PUSHJ	P,MSG		;YES, TELL USER
	PUSHJ	P,PUPTIM	;TYPE SYSTEM UPTIME
	PJRST	CRLF
IFE <V.DISP-V.ANSI>*<V.DISP-V.DVT6>*<V.DISP-V.DV5A>*<V.DISP-V.DV5B>*<V.DISP-V.DV61>*<V.DISP-V.DV50>*<V.DISP-V.DV52>, <;
;
;	DISPLAY SUBROUTINES FOR THE VT06 DISPLAY TERMINAL
;
FINR:	DPB	CH,T1		;STORE WITHOUT NEW BIT
;	TLNE	F,FL.2PT+FL.REF	;IN SECOND PART AND
	CAIE	CH," "		;SPACE?
	TLZA	F,FL.EOL	;NO.
	TLON	F,FL.EOL	;YES. SEE IF FIRST OR LATER
	JRST	FINR1		;OUTPUT NON-SPACE OR FIRST SPACE
	POPJ	P,0		;MULT SPACE. DONT OUTPUT

FINR1:	MOVE	A,COL		;DESTINATION IS IN COL, LINE
	MOVE	B,LINE		; ..
	MOVEM	C,COL		;STORE CURSOR, FOR GETCH
	MOVEM	D,LINE
IFE V.DISP-V.DVT6,<
	CAIE	B,0(D)		;NEED TO MOVE VERTICALLY?
	PUSHJ	P,FILLIT	;YES--ADD FILLERS
>;	END OF IFE V.DISP-V.DVT6
FINR4:	MOVX	CH,CDOWN	;
	CAIN	B,0(D)		;ON RIGHT LINE NOW?
	JRST	FINR2		;YES. GO LOOK AT X DIRECTION
	CAIG	B,0(D)		;NO. NEED TO GO UP OR DOWN?
	SOSA	D,LINE		;UP
	AOSA	D,LINE		;DOWN
	MOVX	CH,CUP		;UP
	PUSHJ	P,DPYOUT
IFE V.DISP-V.DV5B,<
	PUSHJ	P,FILLIT	;ADD FILLER AFTER CURSOR
>;	END OF IFE V.DISP-V.DV5B
	JRST	FINR4

FINR2:	CAIN	A,0(C)		;ALREADY AT RIGHT PLACE?
	JRST	FINR5		;YES
	CAIG	A,0(C)		;NO. LEFT OR RIGHT?
	JRST	FINR8		;LEFT
	PUSHJ	P,GETCH		;GET OLD CHAR AT THIS POS TO RE-SEND
	MOVE	CH,T2
	AOS	C,COL		;MOVE CURSOR PAST THIS CHAR
FINR6:	PUSHJ	P,DPYOUT	;OUTPUT
	JRST	FINR2		;SEE IF TO DEST YET
FINR5:	PUSHJ	P,GETCH		;GET NEW CHAR AT DEST
	MOVE	CH,T2		;TO RIGHT AC
	PUSHJ	P,DPYOUT	;SEND IT
	CAIGE	C,XSIZE-1		;AND UNLESS UP AGAINST STOP,
	MOVEI	C,1(C)		;COUNT THIS POSITION OF CURSOR
	POPJ	P,0		;RETURN

FINR8:	MOVEI	T1,0(C)		;DEST COLUMN
	SUBI	T1,0(A)		;DIST=DEST-CURRENT
	CAILE	T1,0(A)		;DIST .LE. DEST FROM LEFT?
	JRST	FINR7		;NO. BETTER TO CR
	SOS	C,COL		;MOVE CURSOR LEFT 1 PLACE
	MOVX	CH,CLEFT	;PHYSICALLY, TOO
	JRST	FINR6		; ..

FINR7:	SETZB	C,COL		;DO A CR
	MOVEI	CH,15
	JRST	FINR6
>;END IFE <V.DISP-V.ANSI>*<V.DISP-V.DVT6>*<V.DISP-V.DV5A>*<V.DISP-V.DV5B>*<V.DISP-V.DV61>*<V.DISP-V.DV50>*<V.DISP-V.DV52>

IFE V.DISP-V.DVT6,<
;SUBROUTINE TO POSITION CURSOR TO BOTTOM LEFT
;HOMEDN CODE CAN NOT BE USED BECAUSE OF HIGH-SPEED OPERATION
;THEREFORE, SIMULATE IT WITH 25 CURSOR DOWNS AND <CR>

HOMDWN:	OUTSTR	[BYTE (7)CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,15,ERASE,CFILL,CFILL,CFILL,0]
	POPJ	P,

>;	END OF IFE V.DISP-V.DVT6
IFE <V.DISP-V.DV5A>*<V.DISP-V.DV5B>, <
;
;	DISPLAY SUBROUTINES FOR THE DIGITAL VT05
;
DPYX:	CAILE	C,4(XCUR)
	JRST	DPYPOS
	MOVE	A,D
	IMULI	A,XSIZE
	ADDI	A,-1(XCUR)
	IDIVI	A,4
	ADD	A,BPTAB(B)
DPYX1:	ILDB	CH,A
	PUSHJ	P,DPYOUT
	ADDI	XCUR,1
	CAIE	C,(XCUR)
	JRST	DPYX1
	POPJ	P,

DPYPOS:	MOVEI	XCUR,(C)
	MOVEI	YCUR,(D)
	MOVEI	CH,16
	PUSHJ	P,DPYOUT
	MOVEI	CH," "(D)
	PUSHJ	P,DPYOUT
IFE V.DISP-V.DV5B,<
	PUSHJ	P,FILLIT	;FILLERS FOR 2400 BAUD
>;	END OF IFE V.DISP-V.DV5B
	MOVEI	CH," "(C)
	PJRST	DPYOUT		;OUTPUT ADDRESS AND RETURN

HOMDWN:	IONEOU	[16]		;START OF CURSOR POSITIONING
	IONEOU	[<" "+YSIZE-2>]	;JUMP DOWN THE SCREEN
	IONEOU	[CFILL]		;NEED
	IONEOU	[CFILL]		; LOTS
	IONEOU	[CFILL]		;  OF
	IONEOU	[CFILL]		;   FILLERS
	IONEOU	[" "]		;STAY AT LEFT MARGIN
	IONEOU	[ERASE]		;CLEAR TO END OF SCREEN
	IONEOU	[CFILL]		;SOME
	IONEOU	[CFILL]		; MORE
	IONEOU	[CFILL]		;  FILL
	IONEOU	[CFILL]		;   CHARACTERS
	POPJ	P,

>;	END OF	IFE <V.DISP-V.DV5A>*<V.DISP-V.DV5B>
IFE <V.DISP-V.DVT6>*<V.DISP-V.DV5A>*<V.DISP-V.DV5B>,<
;SUBROUTINE TO CLEAR THE SCREEN
CLEAR:	PUSHJ	P,HOME		;GET TO START OF SCREEN
	MOVX	CH,ERASE	;COMMAND TO CLEAR THE SCREEN
	PJRST	DPYOUT		;SEND TO TERMINAL

;SUBROUTINE TO HOME UP AND FILL
HOME:	MOVEI	CH,HOMEUP	;ISSUE HOME
	PUSHJ	P,DPYOUT	;TO DISPLAY
				;THEN FALL INTO FILLERS
>;	END IFE <V.DISP-V.DVT6>*<V.DISP-V.DV5A>*<V.DISP-V.DV5B>
IFE V.DISP-V.DV5A,<
	POPJ	P,		;NO FILLERS ON VT05A
>;	END IFE V.DISP-V.DV5A
IFE <V.DISP-V.DVT6>*<V.DISP-V.DV5B>,<

;SUBROUTINE TO EMIT ENOUGH FILLER CHARACTERS TO KEEP VT06 HAPPY
;EVEN AT 2400 BAUD IN 50 CYCLE COUNTRIES.
;CLOBBERS CH
FILLIT:	MOVEI	CH,CFILL	;GET FILLER CHARACTER
	REPEAT	3,<PUSHJ P,DPYOUT>
	JRST	DPYOUT
>;	END OF IFE <V.DISP-V.DVT6>*<V.DISP-V.DV5B>
IFE <V.DISP-V.ANSI>*<V.DISP-V.DV61>*<V.DISP-V.DV50>*<V.DISP-V.DV52>,<
;
;	DISPLAY SUBROUTINES FOR THE DIGITAL VT61
;
	ESC61==33
IFN	<V.DISP-V.DV50>,<	;NOT FOR VT50'S
DPYX:	CAILE	C,4(XCUR)
	JRST	DPYPOS
	MOVE	A,D
	IMULI	A,XSIZE
	ADDI	A,-1(XCUR)
	IDIVI	A,4
	ADD	A,BPTAB(B)
DPYX1:	ILDB	CH,A
	PUSHJ	P,DPYOUT
	ADDI	XCUR,1
	CAIE	C,(XCUR)
	JRST	DPYX1
	POPJ	P,

DPYPOS:	MOVEI	XCUR,(C)
	MOVEI	YCUR,(D)
	MOVEI	CH,ESC61	;ESC
	PUSHJ	P,DPYOUT
IFE V.DISP-V.ANSI,<		;VT100 POSITIONING
	MOVEI	CH,"["		;
	PUSHJ	P,DPYOUT	;
	MOVEI	N,1(D)		;
	PUSHJ	P,DPYPRN	;
	MOVEI	CH,";"		;
	PUSHJ	P,DPYOUT	;
	MOVEI	N,1(C)		;
	PUSHJ	P,DPYPRN	;
	MOVEI	CH,"H"		;
>;END OF IFE V.DISP-V.ANSI
IFN V.DISP-V.ANSI,<		;
	MOVEI	CH,"Y"
	PUSHJ	P,DPYOUT
	MOVEI	CH," "(D)
	PUSHJ	P,DPYOUT
	MOVEI	CH," "(C)
>;END OF IFN V.DISP-V.ANSI
	PJRST	DPYOUT		;OUTPUT ADDRESS AND RETURN
HOMDWN:
IFE V.DISP-V.ANSI,<		;
	OUTSTR	[BYTE(7)ESC61,"[","2","3","H",ESC61,"[","J",0]	;
>				;
IFN V.DISP-V.ANSI,<		;
	OUTSTR	[BYTE	(7)ESC61,"Y",<" "+YSIZE-2>," ",<ERASE&177>,<<ERASE_-^D9>&177>,0]
>				;
	POPJ	P,
> ;END OF NOT-VT50 CONDITIONAL

IFE	<V.DISP-V.DV50>,<	;VT50'S ARE STUPID
HOMDWN:	OUTSTR	[BYTE (7)CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,CDOWN,<ERASE&177>,<<ERASE_-^D9>&177>,0]
	POPJ	P,
> ;END OF VT50 CONDITIONAL
HOME:	MOVX	CH,HOMEUP	;POSITION-TO-HOME COMMAND
	JRST	DPYOUT

;SUBROUTINE TO CLEAR THE SCREEN
CLEAR:	PUSHJ	P,HOME		;POSITION TO START OF SCREEN
	MOVX	CH,ERASE	;CLEAR-TO-EOS COMMAND
	PJRST	DPYOUT

IFE V.DISP-V.ANSI,<		;
RVIDEO:	MOVE	CH,[BYTE (9) "m","7","[",.CHESC]	;
	TRCE	F,FR.RVD	;IF CLEARING, THEN
	TLZ	CH,7		;CHANGE THAT "7" TO A "0"
	PUSHJ	P,DPYOUT	;
	JRST	FRCOUT		;
>;END OF IFE V.DISP-V.ANSI

IFE	V.DISP-V.DV61,<
RVIDEO:	MOVEI	CH,ESC61
	PUSHJ	P,DPYOUT
	MOVEI	CH,"O"
	PUSHJ	P,DPYOUT
	MOVEI	CH,"J"
	TRCE	F,FR.RVD
	MOVEI	CH,"j"
	PUSHJ	P,DPYOUT
	JRST	FRCOUT

ALARM:	MOVEI	CH,ESC61
	PUSHJ	P,DPYOUT
	MOVEI	CH,"O"
	PUSHJ	P,DPYOUT
	MOVEI	CH,"G"
	TRCE	F,FR.ALR
	MOVEI	CH,"g"
	PUSHJ	P,DPYOUT
	JRST	FRCOUT
> ;	END OF IFE V.DISP-V.DV61
>;	END OF IFE <V.DISP-V.ANSI>*<V.DISP-V.DV61>*<V.DISP-V.DV50>*<V.DISP-V.DV52>
IFE V.DISP-V.DHZL, <
;
;	DISPLAY SUBROUTINES FOR THE HAZELTINE 2000
;
DPYX:	CAILE	C,4(XCUR)
	JRST	DPYPOS
	MOVE	A,D
	IMULI	A,XSIZE
	ADDI	A,-1(XCUR)
	IDIVI	A,4
	ADD	A,BPTAB(B)
DPYX1:	ILDB	CH,A
	PUSHJ	P,DPYOUT
	ADDI	XCUR,1
	CAIE	C,(XCUR)
	JRST	DPYX1
	POPJ	P,

DPYPOS:	PUSHJ	P,CURSOR
	MOVEI	CH,(C)
	PUSHJ	P,DPYOUT
	MOVEI	CH,(D)
	JRST	DPYOUT

CLEAR:	MOVEI	M,[BYTE (7) 176,34,177,177,177,0,0,0,0,0]
	MOVE	A,[XWD 040040,040040]
	MOVEM	A,DBUF
	MOVE	A,[XWD DBUF,DBUF+1]
	BLT	A,DBFEND
	JRST	DPYCHR

CURSOR:	MOVEI	XCUR,(C)
	MOVEI	YCUR,(D)
	MOVEI	M,[BYTE (7) 176,21,0,0,0]
	JRST	DPYCHR

HOME:	MOVEI	M,[BYTE (7) 176,22,0,0,0]

DPYCHR:	HRLI	M,(<POINT 7>)
DPYCH1:	ILDB	CH,M
	JUMPE	CH,CPOPJ
	PUSHJ	P,DPYOUT
	JRST	DPYCH1

HOMDWN:	OUTSTR	[BYTE (7)176,34,177,177,177,176,22,0]
	POPJ	P,
>;	END OF	IFE V.DISP-V.DHZL
IFE V.DISP-V.DDLT, <
;
;	DISPLAY SUBROUTINES FOR THE DELTA DATA TELTERM
;
DPYSPC:	MOVE	B,BP		;COPY BUFFER BYTE POINTER
	MOVEI	A,XSIZE		;GET # OF CHARS IN A LINE
	SUBI	A,1(C)		;GET # OF CHARS REMAINING IN THIS ONE
	JUMPLE	A,CPOPJ		;  NONE, RETURN
	SETZB	M,T1		;CLEAR CHARACTER COUNTERS
DPYSP1:	ILDB	CH,B		;GET NEXT CHARACTER FROM BUFFER
	CAIN	CH,400!" "	;TEST FOR BLANK CHANGED TO BLANK
	JRST	DPYSP3		;  YES, JUMP TO NEXT CHAR
	TRNE	CH,400		;TEST FOR SOMETHING CHANGED TO BLANK
	MOVEI	CH,200!" "	;  YES, CONVERT TO THAT FORMAT
	CAIN	CH,200!" "	;TEST FOR MODIFIED BLANK
	AOS	M		;  YES, COUNT IT
	ANDI	CH,177		;MASK OFF FOR 7 BITS ONLY
	CAIE	CH," "		;TEST FOR A SPACE
	AOS	T1		;  NO, COUNT NON-BLANKS
DPYSP3:	SOJG	A,DPYSP1	;DECR COUNT & REPEAT
	TLNE	F,FL.REF	;TEST FOR REFRESHING NOW
	JUMPN	T1,CPOPJ	;  YES, THEN DON'T CLEAR IF CHARS REMAIN
	SUBI	M,(T1)		;GET # OF MODIFIED BLANKS - # OF OTHER
	CAIG	M,(T1)		;TEST FOR MORE BLANKS THAN OTHER (YET)
	POPJ	P,		;  NO, RETURN
	MOVEI	A,0		;CLEAR REGISTER AS A FLAG
	CAIN	D,YSIZE-1	;TEST FOR LAST ROW ON CRT
	TLNN	F,FL.REF	;TEST FOR FULL REFRESH
	AOBJN	J,DPYSP2	;  NO TO EITHER, UPDATE & SKIP
	POPJ	P,		;  YES TO BOTH, RETURN
DPYSP2:	SKIPN	A		;TEST FOR POINTER ALREADY SAVED
	MOVE	T1,BP		;  ELSE SAVE BYTE POINTER
	ILDB	CH,BP		;GET CHARACTER FROM BUFFER
	TRNE	CH,400		;TEST FOR CHANGED TO A BLANK
	MOVEI	CH," "		;  YES, GET A BLANK
	ANDI	CH,177		;  & CLEAR MODIFY BIT
	CAIE	CH," "		;TEST FOR BLANK
	TRO	CH,200		;  NO, MUST OUTPUT THIS TIME
	DPB	CH,BP		;STORE PROPER CHARACTER BACK
	TRNE	CH,200		;TEST FOR NON-BLANK
	SKIPE	A		;TEST FOR FIRST NON-BLANK
	JRST	DPYSP4		;  NO, JUMP
	MOVE	A,J		;SAVE POSITION POINTER
	SUB	A,[1,,1]	;SUBTRACT ONE FROM EACH HALF!
	MOVE	M,T1		;  & SAVE BYTE POINTER
DPYSP4:	CAME	BP,B		;TEST FOR CAUGHT UP
	AOBJN	J,DPYSP2	;  NO, UPDATE POSITION & LOOP
	MOVEI	T2,23		;GET A CLEAR LINE CHARACTER
	JUMPE	A,CPOPJ		;TEST FOR BLANK LINE
	MOVE	J,A		;  NO, POINT AT NEXT CHARACTER TO OUTPUT
	MOVE	BP,M		;        DITTO
	POPJ	P,		;RETURN NOW
DPYX:				;ENTRY FOR X-POSITION CHANGING ONLY
DPYPOS:	MOVEI	B,(D)		;GET DESIRED Y POSITION
	SUBI	B,(YCUR)	;  MINUS CURRENT Y POSITION
	MOVMS	B		;GET DELTA-Y = ABS(DESIRED-CURRENT)
	MOVEI	A,(C)		;GET DESIRED COLUMN
	ADDI	A,(B)		;  PLUS DELTA-Y
	CAIGE	A,4		;TEST FOR .LT. LIMIT
	JRST	DPYCAR		;  YES, GO DO <CR>+INCREMENTAL
	MOVEI	A,(C)		;GET DESIRED COLUMN
	ADDI	A,(D)		;  PLUS DESIRED ROW
	CAIGE	A,4		;TEST FOR .LT. LIMIT
	JRST	DPYHOM		;  YES, GO DO <HOME>+INCREMENTAL
	MOVEI	A,(C)		;GET DESIRED X POSITION
	SUBI	A,(XCUR)	;  MINUS CURRENT X POSITION
	MOVMS	A		;GET DELTA-X = ABS(DESIRED-CURRENT)
	ADDI	A,(B)		;ADD DELTA-X & DELTA-Y
	CAIGE	A,5		;TEST FOR .LT. LIMIT
	JRST	DPYINC		;  YES, GO DO INCRMENTAL SHIFT
	CAMLE	C,LASTCR(D)	;TEST FOR FORMATTING POSITION RQST
	JRST	DPYFOR		;  YES, JUMP
	MOVEI	XCUR,(C)
	MOVEI	YCUR,(D)
	MOVEI	M,[BYTE (7) 20, 16, 0,0,0]
	PUSHJ	P,DPYCHR
	MOVEI	CH,(C)
	PUSHJ	P,DPYOUT
	MOVEI	CH,(D)
	PUSHJ	P,DPYOUT	;OUTPUT Y POSITION
	POPJ	P,		;RETURN TO CALLER

DPYCAR:	SETZ	XCUR,		;CLEAR CURRENT X POSITION
	MOVEI	CH,15		;GET A <CR> CHARACTER
	JRST	DPYCOM		;GO TO COMMON ROUTINE

DPYHOM:	SETZB	XCUR,YCUR	;CLEAR CURRENT X & Y POSITIONS
	MOVEI	CH,24		;GET A <HOME> CHARACTER
DPYCOM:	PUSHJ	P,DPYOUT	;OUTPUT CONTROL CHARACTER
	PUSHJ	P,DPYFIL	;PUT OUT A FILL CHARACTER
	ADDI	A,2		;  & REQUEST TWO MORE LATER

DPYINC:	MOVEI	CH,13		;ASSUME DOWN
	CAIN	D,(YCUR)	;TEST FOR CORRECT LINE
	JRST	DPYHOR		;  YES, JUMP
	CAIG	D,(YCUR)	;TEST FOR DIRECTION
	SOSA	YCUR		;  UP, DECR CURRENT Y & SKIP
	AOSA	YCUR		;  DOWN, INCR CURRENT Y & SKIP
	MOVEI	CH,32		;CHANGE TO UPWARD CHARACTER
	PUSHJ	P,DPYOUT	;OUTPUT VERTICAL CONTROL CHARACTER
	JRST	DPYINC		;REPEAT AS NECESSARY
DPYHOR:	MOVEI	CH,10		;ASSUME LEFT
	CAIN	C,(XCUR)	;TEST FOR CORRECT COLUMN
	POPJ	P,		;  YES, RETURN
	CAIG	C,(XCUR)	;TEST FOR DIRECTION
	SOJA	XCUR,DPYPUT	;  LEFT, DECR CURRENT X & JUMP
	AOS	XCUR		;  RIGHT, INCR CURRENT X
	MOVEI	CH,31		;CHANGE FOR RIGHTWARD DIRECTION
	CAMLE	XCUR,LASTCR(YCUR) ;TEST FOR UNFORMATTED AREA
	MOVEI	CH," "		;  YES, PUT OUT A GOOD OLD BLANK
DPYPUT:	PUSHJ	P,DPYOUT	;OUTPUT THE CHARACTER
	JRST	DPYHOR		;REPEAT AS NECESSARY

DPYFOR:	PUSH	P,C		;SAVE DESIRED X POSITION
	MOVE	C,LASTCR(D)	;GET LAST CHARACTER WRITTEN ON SAME LINE
	PUSHJ	P,DPYPOS	;  & GO POSITION THERE NOW
	MOVEI	A,(XCUR)	;SAVE CURRENT POSITION OF THE LINE
	POP	P,XCUR		;RESTORE DESIRED AS CURRENT POSITION NOW
	MOVEI	C,(XCUR)	;  DITTO
	CAMLE	XCUR,LASTCR(YCUR) ;TEST FOR EXCEEDING CURRENT POSITION
	MOVEM	XCUR,LASTCR(YCUR) ;  YES, SHOW AS LAST CHARACTER WRITTEN
	SUBM	XCUR,A		;GET NUMBER OF CHARACTERS TO SEND
DPYBLK:	JUMPLE	A,CPOPJ		;  NONE, RETURN
	MOVEI	CH," "		;GET A BLANK
	PUSHJ	P,DPYOUT	;  & OUTPUT IT
	SOJA	A,DPYBLK	;DECR COUNT & REPEAT

HOME:	MOVEI	CH,24		;GET A <HOME> CONTROL CHARACTER
	PJRST	DPYOUT		;  & OUTPUT IT

CLEAR:	MOVEI	M,[BYTE (7) 20, 22, 20, 05, 0]
	SETZM	LASTCR		;CLEAR LAST-CHARACTER POSITION ARRAY
	MOVE	A,[XWD LASTCR,LASTCR+1] ;  DITTO
	BLT	A,LASTCR+YSIZE-1 ;  DITTO

DPYCHR:	HRLI	M,(<POINT 7>)
DPYCH1:	ILDB	CH,M
	JUMPE	CH,CPOPJ
	PUSHJ	P,DPYOUT
	JRST	DPYCH1

DPYFIL:	MOVEI	CH,177		;GET A NICE FILL CHARACTER
	PJRST	DPYOUT		;GO OUTPUT IT & RETURN

HOMDWN:	OUTSTR	[BYTE	(7)20,22,20,05,24,0]
	POPJ	P,
>;	END OF	IFE V.DISP-V.DHZL
;MPEEK  --  READ WORD FROM MONITOR EXEC VIRTUAL ADDRESS SPACE
;CALL IS:
;
;	MOVX	A,<ADR>
;	MOVX	J,<JOB>
;	PUSHJ	P,MPEEK
;	RETURN
;
;WHERE <ADR> IS THE EXEC VIRTUAL ADDRESS TO BE READ. IF <ADR> IS IN THE
;"PER-PROCESS" RANGE THEN A JOBPEK WILL BE USED TO READ THE SPECIFIED
;JOB'S PER-PROCESS AREA. IF THE JOB IS SWAPPED, OR CURRENTLY RUNNING ON
;ANOTHER CPU (STUCK IN THE OTHER CPU'S CACHE) THEN 0 IS RETURNED.
;
;THE MONITOR WORD IS RETURNED IN AC A.
;
;USES N, N1

MPEEK:	CAML	A,VMPPB0	;IS DESIRED ADDRESS IN SECTION-0
	CAML	A,VMPPE0	; PER-PROCESS ADDRESS SPACE?
	CAML	A,VMPPB1	;IS DESIRED ADDRESS IS SECTION-1
	CAML	A,VMPPE1	; PER-PROCESS ADDRESS SPACE?
	JRST	MPEEK4		;NO, TRY PEEK/SPY
	HRLZ	N,J		;YES, GET JOB NUMBER
	TXO	N,JK.EVA!JK.AIO+1  ;READ ONE WORD FROM PER PROCESS AREA
	HRLZ	N1,A		;ADDRESS TO BE READ
	HRRI	N1,A		;WHERE TO READ CONTENTS INTO
	MOVEI	A,N		;A := ADDRESS OF ARG BLOCK TO
	JOBPEK	A,		;ASK MONITOR FOR FUNNY ADDRESS
	SETZ	A,		;CAN'T (SWAPPED OR NOT PRIVILEGED)
	POPJ	P,		;RETURN WITH WORD IN A

MPEEK4:	TLNN	F,FL.SPY	;CAN WE SPY?
	JRST	MPEEK7		;CAN'T SPY, TRY PEEK
	TLNN	A,7776		;IS ADDRESS PAST SECTION 1 (NOT SPYABLE)?
	ANDI	A,777777	;ADDR IN SECTION 0/1, MAP TO SECTION 0
	CAMG	A,SPYSIZ	;CAN WE SPY THE DATA?
MPEEK6:	SKIPA	A,400000(A)	;SPY THE INFORMATION (FASTER)
MPEEK7:	PEEK	A,		;PEEK THE INFORMATION (SLOWER)
	POPJ	P,0
;SUB TO GET MONITOR WORD - RETURN 0 IN A IF CANNOT GET
; AND PRINT "?" BECAUSE UNEXPECTED ERROR

GETA:	PUSHJ	P,GET
	  TDZA	A,A		;RETURN 0
	POPJ	P,		;OK
	MOVEI	CH,"?"		;PRINT QUESTION MARK
	PJRST	TYO		;PRINT



;SUBROUTINE TO GET MONITOR WORD - RETURN 0 IN A IF CANNOT
; NOT AN ERROR IF NOT THERE - USE 0 AS VALUE

GETZ:	PUSHJ	P,GET0		;DECIPHER WORD ADDRESS
	  JRST	GETZ0		;NO SUCH ENTITY, RETURN 0
	 JRST	GETZ1		;CAN'T SPY/ETC, JUST TRY GETTAB
	MOVE	A,0(N1)		;SPY THE WORD DIRECTLY
	POPJ	P,		;ALWAYS RETURN

GETZ1:	PUSHJ	P,GETPEK	;TRY FOR THE WORD THE HARD WAY
GETZ0:	 SETZ	A,		;UNABLE TO GET WORD, RETURN 0
	POPJ	P,		;RETURN ALWAYS



;SUBROUTINE TO GET MONITOR WORD - SKIP IF CAN, NO SKIP IF CANNOT

GET:	PUSHJ	P,GET0		;SEE WHERE THE WORD IS
	  POPJ	P,		;WORD DOES NOT EXIST
	 PJRST	GETPEK		;PEEK FOR IT
	MOVE	A,0(N1)		;GET THE WORD BY SPYING
	JRST	CPOPJ1		;WIN RETURN



;GET 4 CONSECUTIVE MONITOR WORDS

GET4:	PUSHJ	P,GET0		;SEE WHERE WORD IS
	POPJ	P,		;WORD DOES NOT EXIST
	PJRST	GETPK4		;GO GETTAB THEM
	DMOVE	A,0(N1)		;GOT THE WORD(S)
	DMOVE	C,2(N1)		;GOT THE OTHER WORDS TOO
	JRST	CPOPJ1		;SUCCESSFUL RETURN
;DO THE WORK FOR THE GET ROUTINES

GET0:	TLNN	F,FL.SPY	;SPYING??
	PJRST	CPOPJ1		;NO, JUST GETTAB THE VALUE
	LDB	BP,[POINT 9,GTTSLF,8]
	CAIGE	BP,0(A)		;TABLE OK?
	POPJ	P,		;NO THEN IT DOES NOT EXIST
	HRRZ	BP,GTTSLF	;YES. GET THE DESIRED TABLE BASE WORD
	ADDI	BP,(A)		;OFFSET TO DESIRED TABLE ENTRY
	MOVE	BP,400000(BP)	;FETCH GETTAB TABLE POINTER FROM MONITOR
	HRRZ	CH,BP		;EXTRACT THE GETTAB TABLE BASE ADDRESS
	JUMPE	CH,CPOPJ	;[612] RETURN IF NO TABLE
	CAMLE	CH,SPYSIZ	;IS IT WITHIN SPY'ABLE MEMORY?
	JRST	CPOPJ1		;NO, JUST GETTAB IT THEN
	HLRZ	N1,A		;GET DESIRED ITEM IN TABLE
	SKIPGE	A		;WANT SELF?
	MOVE	N1,MYJOB	;YES.
	LDB	CH,[POINT 3,BP,11]  ;GET ENTRY TYPE
	SKIPL	CH,LENTAB(CH)	;GET TABLE LENGTH
	JRST	GETSPR		;REGULAR (E.G., JOB/SEGMENT) TABLE
	AOJE	CH,GETPDB	;PDB DATA
	LDB	CH,[POINT 9,BP,8]  ;GET TABLE LENGTH
GETSPR:	CAIGE	CH,0(N1)	;IS ITEM WITHIN TABLE LIMITS?
	POPJ	P,		;DOES NOT EXIST
	TLNN	BP,(17B17)	;SEE IF INDEXED
GETSPP:	MOVEI	N1,0		;NO--KILL INDEX
	ADDI	N1,400000(BP)	;COMPUTE ADDRESS TO GET WORD
CPOPJ2:	AOS	0(P)		;WIN RETURN
	JRST	CPOPJ1		;DOUBLE SKIP

GETPDB:	TRO	F,FR.PDB	;SET A FLAG FOR GETBLK CODE
	SKIPE	PDBPTR		;FAIL IF NO PDB POINTER
	CAML	N1,JOBN		;SKIP IF LEGAL JOB NUMBER
	JRST	CPOPJ1		;TRY PEEK BETTER POPJ ??
	SKIPGE	PDBPTR		;SEE IF SWAPPING PDBS
	JRST	[MOVNS N1	;YES--GET -N
		 ADD   N1,PDBPTR;INCLUDE OFFSET
		 MOVE  N1,(N1)	;GET JBTADR(-JOB)
		 TRNN  N1,-1	;SEE IF IN CORE
		 JRST  CPOPJ1	;NO--GO LET MONITOR TRY
		 JRST  GETSPP]	;YES--SPY ON IT
	ADD	BP,@PDBPTR	;ADD ADDR OF PDB FOR THIS JOB
	JRST	GETSPP		;GET ENTRY FROM PDB
;HERE IF SPY FAILED - TRY GETTAB UUO

GETPEK:	GETTAB	A,
	  POPJ	P,		;ERROR GETTAB NOT THERE
	JRST	CPOPJ1		;OK, RETURN

GETPK4:	MOVE	B,A		;ADDRESS OF WORD PLUS ONE
	ADD	B,[1,,0]	;PLUS ONE
	DMOVE	C,A		;PLUS TWO MORE WORDS
	DADD	C,[EXP <2,,0>,<2,,0>]  ;LAST TWO WORD "ADDRESS"ES
	GETTAB	A,		;TRY FOR WORD 1
	 POPJ	P,		;NOPE
	GETTAB	B,		;TRY FOR WORD 2
	 POPJ	P,		;NOPE
	GETTAB	C,		;TRY FOR WORD 3
	 POPJ	P,		;NOPE
	GETTAB	D,		;TRY FOR WORD 4
	 POPJ	P,		;NOPE
	JRST	CPOPJ1		;GOT ALL FOUR!
STRWHO:	MOVE	A,[SIXBIT /**,**/]
SIXBP:	MOVE	BP,[POINT 6,A]
SIXBP1:	ILDB	CH,BP
	JUMPE	CH,CPOPJ
	ADDI	CH,40
	PUSHJ	P,TYO
	TLNE	BP,770000
	JRST	SIXBP1
CPOPJ:	POPJ	P,0

SIXB6:	MOVE	BP,[POINT 6,A]
SIXB61:	ILDB	CH,BP
	ADDI	CH,40
	PUSHJ	P,TYO
	TLNE	BP,770000
	JRST	SIXB61
	POPJ	P,

CRLF:	MOVEI	M,[ASCIZ /
/]
MSG:	TLNN	M,777700	;UNLESS ALREADY HAVE BYTE POINTER
	HRLI	M,(<POINT 7>)	;MAKE ADDRESS INTO BYTE POINTER
MSG1:	ILDB	CH,M
	JUMPE	CH,CPOPJ
	PUSHJ	P,TYO
	JRST	MSG1

COLON:	MOVEI	CH,":"
	JRST	TYO
COMMA:	MOVEI	CH,","
	JRST	TYO
DOT:	MOVEI	CH,"."		;A DOT OR PERIOD CHARACTER
	PJRST	TYO		;TO BE TYPED OUT.
PERCNT:	MOVEI	CH,"%"		;A PERCENT SIGN
	PJRST	TYO		;TO BE TYPED OUT.

;PRINT PERCENT
PRPCNT:	MOVEM	N,TEMP1
	PUSHJ	P,MSGDEC
	MOVSI	A,(SIXBIT ./.)
	MOVE	N,TEMP
	PUSHJ	P,SIXDEC
	MOVEI	M,[ASCIZ / = /]
	MOVE	N,TEMP1
	PUSHJ	P,CMPCNT
	MOVEI	CH,"%"	;PRINT PERCENT
	PJRST	TYO
EMSG:	TLNN	M,777700	;ADDRESS OR BYTE POINTER
	HRLI	M,(POINT 7,)	;ADDRESS, MAKE INTO BYTE POINTER
EMSG1:	ILDB	CH,M		;NEXT CHARACTER
	JUMPE	CH,CPOPJ	;NUL ENDS STRING
	CAIE	CH,.CHLFD	;NEW LINE YET?
	JRST	EMSG2		;NO, REGULAR CHARACTER
	AOS	CLINE		;[611] BUMP CURRENT LINE COUNTER
	SKIPE	.FRAJR		;[611] SKIP OVERHEAD IF NO AUTO ROLL
	PUSHJ	P,SETVIS	;[611] DETERMINE VISIBILITY
	SOSL	EATCNT		;DECREMENT LINES TO BE EATEN
	JRST	EMSG1		;NEED TO EAT STILL MORE
EMSG2:	SKIPG	EATCNT		;ON SCREEN YET?
	PUSHJ	P,TYO		;YES, LIST CHARACTER
	JRST	EMSG1		;LOOP BACK FOR MORE


CHKDON:	SKIPGE	N,LINE		;GET LINES FILLED WITH DATA
	JRST	CPOPJ1		;LINE .LT. 0 MEANS FULL SCREEN
	CAIGE	N,<YSIZE/2>	;IF LESS THAN 4 LINES
	SKIPG	FIRJOB		;AND WE ARE "+"'ED
	CAIA			;NO
	SOS	(P)		;THEN FLAG TO REDO THE SCREEN IMMED.
	SUBI	N,YSIZE		;SEE HOW MANY LINES LEFT ON SCREEN
	JUMPGE	N,CPOPJ1	;IF SCREEN FULL JUST EXIT OK
	ADDB	N,FIRJOB	;SCREEN HAS EMPTY LINES, "-" IT
	JUMPGE	N,CPOPJ1	;AND LET NEXT CYCLE SKIPGE IT DOWN
	SETZM	FIRJOB		;BUT NEVER LET IT GO NEGATIVE
	JRST	CPOPJ1		;RETURN APPROPRIATELY
;PRINTERS OF PAGE ORIENTED DATA

KAYPAG:	MOVEI	CH,"P"		;ASSUME PAGING
	TRNN	F,FR.KIP	;SO LOOK TO PROCESSOR
	MOVEI	CH,"K"		;AND CHANGE TO KAYS IF KA10
	PJRST	TYO		;EXIT VIA PRINTER


;PRINT PAGING DATA FOR THE CURRENT JOB CONTAINED IN J
;BEFORE SWITCHING TO INLINE CODE THE FOLLOWING DATA IS COLLECTED
;1 GETAB1 MAX VIRTUAL AND PHYSICAL LIMITS
;2 GETAB2 INTEGER PAGING RATE FRACTION,,FRACTIONAL PGR DATA

PGDATA:	TRNE	F,FR.VMM	;HAS THE SYSTEM ANY VIRTUES
	JRST	PGDATV		;(YES) DO THINGS DIFFERENT
	MOVS	N,JOBPHY	;GET LOSEG PHYSICAL SIZE
	ADD	N,JOBPHY	;ADD HISEG PHYSICAL SIZE
	ADD	N,JOBPPG	;ADD MONITOR OVERHEAD (PER-PROCESS) SIZE
	ANDI	N,777777	;STRIP OFF GARBAGE
	CALL	DECPRT		;PRINT IN DECIMAL P
	PJRST	TAB		;RETURN AFTER THE TAB

PGDATV:	HRL	A,J		;GET JOB NUMBER
	HRRI	A,.GTMVL	;GET MAXIMUM VALUES FOR JOB
	CALL	GETZ		;NOW OR ZER
	AND	A,[377777,,377777]  ;ZAP NON CORE BITS
	MOVEM	A,GETAB1	;REMEMBER MAX VALUE
	HRL	A,J		;GET THE JOBNUMBER
	HRRI	A,.GTCVL	;GET GUIDELINE
	CALL	GETZ		;AND TAKE THAT AS PHYS
	AND	A,[377777,,377777]  ;ZAP NON CORE BITS
	HRRM	A,GETAB1	;AND STORE IT FOR PRINTING
	SETZM	GETAB2		;ZAP PAGING RATE COMPLETELY
	HLRZ	N1,@JBVRT	;GET PAGING RATE
	JUMPE	N1,PGDAT0	;CERTAINLY NOT PAGING
	CALL	CMPPGR		;COMPUTE PAGING RATE
PGDAT0:	.INL			;START INLINE PSEUDO CODE
	.PLD	JOBVIR		;PRINT LOWSEG VIRTUAL SIZE
	.PLS			;SEPARATE WITH A PLUS
	.PRD	JOBVIR		;PRINT HISEG VIRTUAL SIZE
	.LPA			;PRINT A LEFT PAREN
	.PLD	GETAB1		;PRINT MAXIMUM VIRTUAL
	.RPA			;AND A RIGHT PAREN
	.TAB			;SPACE 2 PRINTS
	.PLD	JOBPHY		;PRINT LOWSEG PHYSICAL SIZE
	.PLS			;SEPARATE WITH A PLUS SIGN
	.PRD	JOBPHY		;PRINT HIGHSEG PHYSICAL SIZE
	.PLS			;SEPARATE WITH A PLUS
	.PRD	JOBPPG		;PRINT MONITOR PER-PROCESS PAGES
	.LPA			;(
	.PRD	GETAB1		;MAX PHYS
	.RPA			;)
	.TAB
	.PLD	GETAB2		;PRINT FRACTION
	.PER			;PERIOD
	.PRDP	GETAB2,^D100	;FACTOR 100
	.END			;END OF PSEUDO CODE
	PJRST	TAB		;EXIT AFTER PRINTING A TAB

;CMPPGR COMPUTES THE PAGING RATE PER SECOND THE INVERSE IS PASSED
;IN N1 THE RESULT IS RETURNED IN GETAB2,
;THE LEFTHALF IS THE INTEGER PART
;THE RIGHT HALF THE FRACTION

CMPPGR:	PUSH	P,N1		;SAVE THE INTERVAL
	MOVEI	N,^D100000	;TO MAKE A FRACTION
	IDIVI	N,(N1)		;GET REMAINDER IN N1
	HRLM	N,GETAB2	;STORE INTEGER PART
	MOVE	N,N1		;GET THE FARCTION
	IMULI	N,^D100		;FACTOR 100
	POP	P,N1		;GET THE INTERVAL BACK
	IDIVI	N,(N1)		;GET FRACTION
	HRRM	N,GETAB2	;AND STORE IT FOR PRINTING
	RETURN
PAGSYS:	PUSHJ	P,THISIZ	;GIVE HEADER
	MOVE	A,[11,,113]	;GET USER  LIMIT
	CALL	GETZ		;GET THE VALUE
	MOVEM	A,N1		;GET VALUE FOR CONVERSION
	CALL	CMPPGR		;PRINT PAGING RATE
;GETAB1 CONTAINS SYSTEM PAGING RATE LIMIT AS AN INTEGER
;GETAB2 CONTAINS USER PGR LIMIT AS XWD FORMAT
	.INL			;START OF INLINE CODE
	.TXT	<VM(MAX=>
	.GTB	5,113,GETAB
	.PRD	GETAB		;PRINT MAX VALUE
	.TXT	<,USED=>
	.PGTBD	4,113
	.TXT	<) PGR.USER=>
	.PLD	GETAB2		;PRINT INTEGER PART
	.PER			;PERIOD
	.PRD	GETAB2		;AND FRACTION
	.TXT	< PFC:NIW=>
	.GTB	13,113,GETAB	;PAGE FAULT COUNT
	.PLD	GETAB
	.TXT	< IW=>
	.PRD	GETAB
	.NWLIN
	.END
	RETURN			;RETURN TO CALLER
;CPCPT  --  ROUTINE TO PRINT N IN HUNDREDTHS OF PERCENT
;CALL IS:
;
;	MOVX	N,<PERCENT*100>
;	PUSHJ	P,CPCPT
;	RETURN
;
;THE PERCENT IS ALWAYS PRINTED AS THREE CHARACTERS:
;	1)	100
;	2)	NN.
;	3)	N.M
;	4)	.NN

CPCPT:	CAIG	N,^D999		;NN% FORM?
	JRST	CPCPT2		;NO
	IDIVI	N,^D100		;YES, REDUCE TO JUST PERCENT
	CAILE	N,^D99		;100%?
	PJRST	DECPRT		;YES, THAT'S OUR THREE DIGITS
	PUSHJ	P,DECPRT	;NO, PRINT TWO DIGITS
	MOVEI	CH,"."		;FOLLOW BY PERCENT INDICATOR
	PJRST	TYO		;AND CAP IT OFF

CPCPT2:	CAIG	N,^D99		;N.N FORM?
	JRST	CPCPT4		;NO
	IDIVI	N,^D100		;GET PERCENTAGE DIGIT
	MOVEI	CH,"0"(N)	;IN ASCII
	PUSHJ	P,TYO		;AND PRINT IT OUT
	MOVEI	CH,"."		;SEPARATING DOT
	PUSHJ	P,TYO		;PRINT IT ALSO
	MOVE	N,N1		;GET BACK THE HUNDREDTHS
	IDIVI	N,^D10		;TENTHS OF PERCENT
	MOVEI	CH,"0"(N)	;IN ASCII
	PJRST	TYO		;AND PRINT IT OUT

CPCPT4:	MOVEI	CH,"."		;LEADING DECIMAL
	PUSHJ	P,TYO		;INDICATE HUNDREDTHS
	MOVEI	CH,"0"		;IN CASE NEED LEADING "0"
	CAIG	N,^D9		;LESS THAN .10 PERCENT?
	PUSHJ	P,TYO		;YES, NEED LEADING "0"
	PJRST	DECPRT		;TYPE HUNDREDTHS OF PERCENT
;SUBROUTINE TO DIVIDE A NUMBER IN AC N BY TEMP
;ROUND UP RESULT IF NECESSARY AND PRINT MESSAGE FOLLOWED BY N (%)
;CALL	MOVEM	AC,TEMP
;	MOVE	N,NUMBER TO BE DIVIDED
;	MOVEI	M,[ASCIZ /TEXT/]
;	PUSHJ	P,DIVRPT
;	ALWAYS	RETURN
;ACS N1,N,M,CH & R ARE DESTROYED

CMPCNA:	MOVE	N,A
CMPCNT:	IMULI	N,^D100
	IDIV	N,TEMP
	LSH	N1,1
	CAML	N1,TEMP
	ADDI	N,1
	PJRST	MSGDEC		;GO PRINT MESSAGE AND DECIMAL

CALCNA:	MOVE	N,A
CALCNT:	IMULI	N,^D100
	IDIV	N,TEMP
	LSH	N1,1
	CAML	N1,TEMP
	ADDI	N,1
	POPJ	P,




;CMPDNA  --  PRINT PERCENTAGE.HUNDREDTHS (N/TEMP)
;CALL IS:
;
;		TEMP/	BASE FOR PERCENTAGE
;	MOVX	A,VALUE
;	PUSHJ	P,CMPDNA
;	RETURN
;
;USES A-D, N, N1

CMPDNA:	IMULI	A,^D100*^D100	;TO GET HUNDREDTHS
	IDIV	A,TEMP		;A := PERCENT * ^D100
	IDIVI	A,^D100		;A := PERCENT
	MOVE	N,A		;POSITION FOR DECZ2
	PUSHJ	P,DECZ2		;PRINT TWO DIGIT PERCENTAGE
	PUSHJ	P,DOT		;FINISH WITH A "."
	MOVE	N,B		;POSITION FOR DECZ2
	PJRST	DECZ2		;TYPE TWO DIGIT HUNDREDTHS
MSPDEC:	AOJE	J,MSGDEC	;IF FIRST SKIP SPACE
	PUSHJ	P,SPACE		;OTHERWISE NEED SPACE SEPARATOR
MSGDEC:	PUSHJ	P,MSG
	JRST	DECPRT



SIXDEC:	PUSHJ	P,SIXBP
	JRST	DECPRT



MSPOCT:	AOJE	J,MSGOCT	;IF FIRST NO SEPARATOR
	PUSHJ	P,SPACE		;OTHERWISE NEED SEPARATOR
MSGOCT:	PUSHJ	P,MSG		;PRINT LEADING TEXT
	PJRST	OCTPRT		;AND TRAILING OCTAL NUMBER



MSPDHM:	AOJE	J,MSGDHM	;IF FIRST SKIP SPACE
	PUSHJ	P,SPACE		;OTHERWISE NEED A SPACE
MSGDHM:	PUSHJ	P,MSG		;PRINT THE MESSAGE TEXT
	JRST	DHMPRT		;PRINT [[DAYS:]HOURS:]MINUTES



;SUBROUTINE TO PRINT JIFFY TIME TO NEAREST TENTH OF SECONDS
;CALL:	MOVE	N,TIME IN JIFFIES
;	PUSHJ	P,PNTSEC

PNTSEC:	MOVE	T1,TCKSEC	;NO. OF JIFFIES IN 1 SECOND
	MOVEM	T1,TEMP		;STORE FOR CMPDFN
	PJRST	CMPDFN		;GO PRINT RATIO
;CMPDFA  --  SUBROUTINE TO PRINT INTEGER+1 DIGIT FRACTION
;CALL:	MOVEM	TEMP		NUMBER TO DIVIDE BY
;	MOVE	A,NUMBER TO BE DIVIDED
;	PUSHJ	P,CMPDFA
;	ALWAYS RETURN

CMPDFA:	MOVE	N,A
CMPDFN:	IMULI	N,^D10		;  * 10
	IDIV	N,TEMP		;DIVIDE BY #K AVAILABLE
	LSH	N1,1		;REMAINDER * 2
	CAML	N1,TEMP		;TEST FOR ROUNDING NEEDED
	AOJ	N,		;  YES, INCR QUOTIENT BY 1
	IDIVI	N,^D10		;DIVIDE TO GET INTEGER/FRACTION
	PUSH	P,N1		;SAVE FRACTION FOR LATER
	PUSHJ	P,MSGDEC	;PRINT MSG & INTEGRAL PART
	POP	P,N		;RESTORE FRACTIONAL DIGIT
	MOVEI	CH,"."		;DECIMAL POINT
	PUSHJ	P,TYO		;SEPARATE FRACTION
	PJRST	DECPRT		;AND TYPE FRACTION



;CMPCPT  --  PRINT "A" PER SECOND CPU UPTIME (FROM TEMP)
;CMPCTT  --  PRINT "A" PER SECOND SYS UPTIME (FROM UPTINC)

CMPCPT:	SKIPA	N,TEMP		;GET UPTIME FROM TEMP
CMPCTT:	MOVE	N,UPTINC	;GET UPTIME OF SYSTEM
	IDIV	N,TCKSEC	;CONVERT TO SECONDS
	EXCH	N,A		;(PRINT FROM N)
	IDIV	N,A		;WHATEVER'S PER SECOND
	PJRST	DECPRT		;TYPE NUMBER



;CALCPT  --  CALCULATE "A" PER SECOND CPU UPTIME (FROM TEMP)
;CALCTT  --  CALCULATE "A" PER SECOND SYS UPTIME (FROM UPTINC)

CALCPT:	SKIPA	N,TEMP		;GET UPTIME FROM TEMP
CALCTT:	MOVE	N,UPTINC	;GET UPTIME OF SYSTEM
	IDIV	N,TCKSEC	;CONVERT TO SECONDS
	EXCH	N,A		;(PRINT FROM N)
	IDIV	N,A		;WHATEVER'S PER SECOND
	POPJ	P,		;RETURN PER-SECOND COUNT IN N
;CMPDDN  --  SUBROUTINE TO PRINT 4-DIGIT INTEGER PLUS 2-DIGIT FRACTION
;CALL:	MOVEM	TEMP		NUMBER TO DIVIDE BY
;	MOVE	N,NUMBER TO BE DIVIDED
;	PUSHJ	P,CMPDDN
;	ALWAYS RETURN

CMPDDN:	IMULI	N,^D100		;WANT IN HUNDREDTHS
	IDIV	N,TEMP		;GET REMAINDER
	LSH	N1,1		;SEE IF MORE THAN HALF
	CAML	N1,TEMP		;...
	AOJ	N,		;YES, ROUND UP
	IDIVI	N,^D100		;GET UNITS AND HUNDREDTHS
	PUSH	P,N+1		;SAVE REMAINDER
	PUSHJ	P,DECB4		;PRINT FIRST PART
	MOVEI	CH,"."		;GET A POINT
	PUSHJ	P,TYO		;PRINT IT
	POP	P,N		;GET REMAINDER BACK
	PJRST	DECZ2		;AND TYPE FRACTION
;SUBROUTINE TO GET REL ENTRY FROM MONITOR GETTAB SUB-TABLE
;CALL:	MOVEI	A,DESIRED REL ENTRY IN RESPONSE TABLE
;	MOVEM	CPU #,CPU	;STORE CPU NUMBER = 0,1
;	PUSHJ	P,GETRSP
;	  ERROR RETURN NOT PRESENT FOR THIS CPU
;	OK RETURN CONTENTS IN AC A

GETRSP:	PUSH	P,N1		;SAVE N1
	PUSH	P,A		;SAVE RELATIVE ADR IN SUB-TABLE
	MOVE	A,[%CCRSP]	;GETTAB IN CPU CONSTANTS TABLE
				; FOR REL ENTRY IN CPU VARIABLE TABLE
				; FOR RESPONSE DATA
	ADD	A,CPU		;FORM FOR THIS CPU
	ADD	A,CPU		;CONSTANTS GETTABS ARE EVERY OTHER
	PUSHJ	P,GET		;GET ENTRY FROM MONITORJ
	  JRST	GTRSPX		;NOT PRESENT, ERROR RETURN
	ADD	A,(P)		;FORM ADR IN CPU VARIABLE TABLE
	HRL	A,A		;TO LH
	HRRI	A,.GTC0V	;VARIABLE GETTAB FOR CPU0
	ADD	A,CPU		;FOR FOR CPU N
	ADD	A,CPU		;VARIABLE TABLE IS EVERY OTHER
	PUSHJ	P,GET		;GET FROM MONITOR
	  SOS	-2(P)		;NOT PRESENT, SET FOR ERROR RETURN
	AOS	-2(P)		;SKIP RETURN(UNLESS ERROR)
GTRSPX:	POP	P,N1		;RESTORE PD LIST
	POP	P,N1		;RESTORE N1
	POPJ	P,		;ERROR OR OK RETURN
;STROLL STARTS THE OUTPUT OF A PAGE ON THE DISPLAY SCREEN

STROLL:	PUSH	P,A		;SAVE A SCRATCH ONE
	MOVEI	A,STREND	;SO ALWAYS GET EXIT FROM DISPLAY
	EXCH	A,-1(P)		;GET OLD RETURN
	EXCH	A,(P)		;GET A BACK
	SETZM	.FRAJS		;NO ONE SKIPPED YET
	SETZM	CLINE		;NO ONE PRINTED YET
	SETZM	NLTYPD		;NO ONE TYPED YET
	SETZM	HDRVAL		;NO RESIDUES
	RETURN

;SETEND FREEZE VALUE OF LINE IN SLNE SO STREND CAN ADAPT TO
;EMPTY SCREENS

SETEND:	PUSH	P,LINE		;GET CURRENT LINE VALUE
	POP	P,SLINE		;REMEMBER IT
	PUSH	P,BOTTOM	;GET BOTTOM
	POP	P,SBOTTM	;TO RECOMPUTE FIRJOB
	RETURN

;STREND IS ENTERED WHEN THE DISPLAY PROGRAM ENDS

STREND:	SKIPE	.FRAJR		;AUTOMATIC ROLL ON?
	JRST	STREN0		;(YES) DO DIFFERENT THINGS
	MOVE	A,SLINE		;ANY SPACE LEFT?
	JUMPL	A,CPOPJ		;NOPE ALL USED
	SUB	A,SBOTTM	;MINUS NUMBER LEFT
	ADDB	A,FIRJOB	;REINITIALIZE BORDER
	JUMPGE	A,CPOPJ		;ALL SET
	SETZM	FIRJOB		;NO NEGATIVE LINE NUMBERS
	RETURN
STREN0:	SETZM	FIRJOB		;ASSUME BACK TO THE BEGINNING
	MOVE	A,LSTLNE		;LAST LINE NUMBER
	SKIPE	.FRAJS		;ANY JOBS SKIPPED?
	MOVEM	A,FIRJOB	;(YES) UPDATE NEXT LINE START
	RETURN

;PRINTERS FOR THE PAGED F DISPLAY
;IFPRNT CHECKS WHETHER THE CURRENT LINE CAN BE PRINTED OR NOT
;CPOPJ LINE IS INVISIBLE
;CPOPJ1 LINE IS VISIBLE

IFPRNT:	SKIPL	VISIBL		;CAN WE SEE IT?
	RETURN			;NO ALL DONE
	PUSH	P,A		;SAVE A
	MOVE	A,HDRVAL	;IS A HEADER TO BE PRINTED?
	JUMPE	A,IFPRN0	;NOPE EXIT
	SETZM	HDRVAL		;NO RECURSIVE ENTRIES
	CALL	(A)		;GET IT OUT
IFPRN0:	POP	P,A		;GET A BACK
	JRST	CPOPJ1		;GO BACK
;SETVIS SORT OUT WHETHER LINE CAN BE SEEN

SETVIS:	PUSH	P,CH		;SAVE A SCRATCH
	SETZM	VISIBL		;ASSUME NO VISIBILITY
	SKIPGE	LINE		;BUT VERIFY FIRST
	JRST	SETVI0		;CHECK SCREEN LOGIC
	AOS	VISIBL		;IF BELOW HORIZONT
	MOVE	CH,CLINE	;GET CURRENT LINE NUMBER
	CAML	CH,FIRJOB	;IS BELOW THE HORIZONT
	SETOM	VISIBL		;NO ITS ON THE SCREEN
	JRST	SETVI1		;GO BACK
SETVI0:	SKIPE	.FRAJR		;IF NO AUTO ROLL OR
	SKIPE	.FRAJS		;SKIP LOGIC DONE
	JRST	SETVI1		;ALL SET
	SETOM	.FRAJS		;JOBS ARE SKIPPED
	MOVE	CH,CLINE	;GET LAST LINE
	MOVEM	CH,LSTLNE	;HERE TO BEGIN NEXT
SETVI1:	POP	P,CH		;GET JUNK BACK
	RETURN			;AND ALL HAS BEEN DONE

;ICRLF START A NEW LINE THIS MEANS UPDATE LINE LOGIC

ICRLF:	CALL	IFPRNT		;VISIBLE
	JRST	ICRLF0		;NOT TO US
	CALL	CRLF		;SHOW IT
	CALL	SETEND		;UPDATE LAST LINE VALUE
	AOS	NLTYPD		;ONE MORE TYPED
ICRLF0:	AOS	CLINE		;UPDATE THE LINE NUMBER
	PJRST	SETVIS		;AND SEE HOW OUR VISION IS NOW

;SETHDR GENERATE THE CALL TO A HEADER PRINTER

SETHDR:	POP	P,HDRVAL	;ROUTINE ADDRESS -1
	PUSH	P,HDRVAL	;RESTORE RETURN ADDRESS
	AOS	HDRVAL		;CODE IS JUST PAST RETURN
	RETURN
;CONDITIONAL PRINTERS

IMSG:	CALL	IFPRNT		;VISIBLE
	RETURN			;NO GO BACK
	PJRST	MSG		;YES PRINT IT

ISIXBP:	CALL	IFPRNT		;VISIBLE
	RETURN
	PJRST	SIXBP

IDECPR:	CALL	IFPRNT
	RETURN
	PJRST	DECPRT

ITAB:	CALL	IFPRNT
	RETURN
	PJRST	TAB

IFRCL:	PUSHJ	P,ICRLF		;GIVE A "FREE" <CR><LF>
	PUSHJ	P,ISPACE	;AND A SPACE TO INDENT
	PUSHJ	P,ISPACE	;AND ANOTHER
	PUSHJ	P,ISPACE	;AND YET ANOTHER
				;FALL INTO FINAL ISPACE

ISPACE:	CALL	IFPRNT
	RETURN
	PJRST	SPACE

IDECTA:	CALL	IFPRNT
	RETURN
	PJRST	DECTAB

IPRPCN:	CALL	IFPRNT
	RETURN
	PJRST	PRPCNT
SIXTAB:	PUSHJ	P,SIXBP
TAB:	SKIPA	CH,[11]
SPACE:	MOVEI	CH,40

TYO:	TLNN	F,FL.SUP	;SUPPRESSED?
	SKIPGE	LINE		;DO NOTHING IF OUT OF ROOM
	POPJ	P,
	ANDI	CH,177
	CAIN	CH,15
	JRST	TYCR		;SIMULATE CAR. RET.
	CAIN	CH,12
	JRST	TYLF		;SIMULATE LINE FEED
	SKIPGE	COL		;IGNORE LINE TOO WIDE
	JRST	TYO3		;GO CHECK FOR FREE CRLF
	CAIN	CH,11
	JRST	TYTAB		;SIMULATE TAB
	PUSHJ	P,GETCH
	ANDI	T2,377		;CLEAR 400 BIT
	CAIN	CH," "		;TEST FOR CHANGING TO BLANK
	MOVEI	CH,400(T2)	;  YES, CONVERT TO 400!<ORIGINAL VALUE>
	TRNE	CH,400		;TEST FOR 400 BIT NOW ON
	MOVEI	T2,(CH)		;  YES, COPY REGISTER TO AVOID 200 BIT
	CAME	CH,T2
	TRO	CH,200		;NOT THE SAME AS LAST TIME
	DPB	CH,T1
	AOS	T1,COL		;INCREMENT COLUMN COUNT
	CAMLE	T1,RTEND
	SETOM	COL		;LINE TOO WIDE
	POPJ	P,

;LINE EXHAUSTED, CHECK FOR FREE CRLF ACTION

TYO3:	TLNN	F,FL.CRF	;HIGH LEVEL WANT FREE CRLF?
	POPJ	P,		;NO, JUST TOSS OUT THE CHARACTER
	PUSH	P,CH		;YES, SAVE THE REAL CHARACTER
	PUSHJ	P,TYCR3		;GIVE THE FREE CR
	PUSHJ	P,TYLF		;AND THE FREE LF FOLLOWING
	PUSHJ	P,SPACE		;SPACE
	PUSHJ	P,SPACE		; OVER
	PUSHJ	P,SPACE		;  CONTINUATION
	PUSHJ	P,SPACE		;   LINES
	POP	P,CH		;RESTORE THE REAL CHARACTER
	PJRST	TYO		;AND FINALLY OUTPUT IT
TYCR:	MOVEI	CH," "
	PUSHJ	P,TYO		;CLEAR REMAINDER OF LINE
	SKIPL	COL
	JRST	TYCR
TYCR3:	MOVE	T1,LTEND	;MOVE TO LEFT EDGE OF WINDOW
	MOVEM	T1,COL
	MOVE	T1,LTTEND
	MOVEM	T1,TABCTR
	POPJ	P,

GETCH:	MOVE	T1,LINE
	IMULI	T1,XSIZE
	ADD	T1,COL		;CALC. CHAR POSITION IN BUF
	IDIVI	T1,4
	ADD	T1,BPTAB(T2)	;MAKE BYTE POINTER TO CHAR
	LDB	T2,T1		;GET THE CHAR
	POPJ	P,0		;RETURN
TYLF:	AOS	T1,LINE		;INCREMENT LINE COUNT
	CAMG	T1,BOTTOM
	POPJ	P,		;SPACE LEFT
	LDB	T2,PCONT
	JUMPN	T2,TYLF2	;CONTINUATION COLUMN?
TYLF1:	SETOM	LINE		;NO ROOM LEFT
	POPJ	P,
TYLF2:	ADD	T2,LTEND	;ADD SPACE BETWEEN COLUMNS
	LDB	T1,PWIDTH	;MOVE OVER A FULL COLUMN WIDTH
	ADD	T2,T1
	MOVEM	T2,COL
	EXCH	T2,LTEND
	ADD	T1,LTEND
	CAILE	T1,XSIZE
	JRST	TYLF1		;COLUMN WON'T FIT
	MOVEM	T1,RTEND
	SKIPA	T1,TABCTR	;GET CURRENT VALUE OF TABCTR & SKIP NEXT
	AOS	T1,TABCTR
	MOVEM	T1,LTTEND
	MOVE	T1,TAB0(T1)
	CAMG	T1,LTEND
	JRST	.-4
	LDB	T1,PTOP		;GO TO TOP OF NEW COLUMN
	MOVEM	T1,LINE
	TLZE	F,FL.NHED	;TEST FOR  HEADING SUPPRESSED
	POPJ	P,		;  YES, THEN EXIT W/O ACTION
	IMULI	T1,XSIZE	;COPY HEADING
	ADD	T1,T2
	SOS	T1
	IDIVI	T1,4		;SPLIT WORD/BYTE
	ADD	T1,BPTAB(T2)
	PUSH	P,T1
TYLF3:	ILDB	CH,(P)
	ANDI	CH,177
	PUSHJ	P,TYO
	SKIPL	COL
	JRST	TYLF3
	POP	P,T1		;MOVE TO FRESH LINE AND RETURN
	JRST	CRLF
TYTAB:	MOVE	T2,COL
	AOS	T2
	MOVE	T1,TABCTR	;GET NEXT TAB POSITION
	AOS	TABCTR		;UPDATE TAB COUNTER
	SUB	T2,TAB0(T1)	;CALCULATE # OF SPACES NEEDED
	PUSH	P,T2
TYTAB1:	MOVEI	CH," "
	PUSHJ	P,TYO		;OUTPUT SPACES
	AOSGE	(P)
	JRST	TYTAB1
	POP	P,T1
	POPJ	P,
PLTEND:	POINT	7,WINDOW,6
PWIDTH:	POINT	7,WINDOW,13
PTOP:	POINT	5,WINDOW,18
PBOTTO:	POINT	5,WINDOW,23
PCONT:	POINT	2,WINDOW,25
PTABST:	POINT	10,WINDOW,35


SETUP:	MOVE	T1,@(P)		;PICK UP INFO WORD
	MOVEM	T1,WINDOW
	LDB	T1,PLTEND	;UNPACK NECESSARY DATA
	MOVEM	T1,LTEND
	MOVEM	T1,COL
	LDB	T2,PWIDTH
	ADD	T1,T2
	MOVEM	T1,RTEND
	LDB	T1,PTOP
	MOVEM	T1,LINE
	LDB	T1,PBOTTO
	MOVEM	T1,BOTTOM
	LDB	T1,PTABST
SETUP7:	MOVEM	T1,LTTEND	;SET TAB STOPS
	MOVEM	T1,TABCTR
	JRST	CPOPJ1		;SKIP OVER INFO WORD

TSETUP:	MOVE	T1,@(P)		;GET INFO WORD
	DPB	T1,PTABST	;UPDATE "WINDOW"
	PJRST	SETUP7		;AND FIX TAB STOPS
	SUBTTL	DISPLAY WINDOW SETTERS

;DISPLAY INDEPENDENT WINDOW OPERATIONS
;WNDJOB SETS THE WINDOW FOR THE JOB AREA ON THE SCREEN
;WNDSYS SETS THE WINDOW FOR SYSTEM INFORMATION

WNDJOB:	TRNN	F,FR.VMM	;IS THERE VM DATA
	JRST	WNDJO0		;(NO) CLASSIC STUFF
	SET	1,XSIZE,1,YSIZE,0,TABV0
	RETURN			;THAT WAS ALL

WNDJO0:	TRNN	F,FR.JOB	;JOBS ONLY DISPLAY?
	JRST	WNDJO1		;NO
	SET	1,39,1,YSIZE,2,TABJ0	;SET FOR JOBS ONLY (MULTI COLUMN)
	RETURN			;THAT'S ALL

WNDJO1:	TRNN	F,FR.SJB	;EXPANDED JOB (NO SYSTEM STUFF)?
	JRST	WNDJO9		;NO
	SET	1,72,1,YSIZE,2,TABS0  ;SET FOR EXPANDED JOBS
	POPJ	P,		;RETURN WITH WINDOW SET UP

WNDJO9:	SET	1,39,1,YSIZE,0,TAB0
	RETURN



WNDSYS:	TRNN	F,FR.VMM	;A VM DISPLAY??
	JRST	WNDSY0		;(NO) CLASSIC
	CHANGE	1,XSIZE,1,2,0,TAB5
	RETURN

WNDSY0:	CHANGE	41,XSIZE,NSYSYS,YSIZE,0,TAB1
	RETURN
IFN V.DISP-V.DVBX,<

IFE V.DISP-V.ANSI,<		;
DPYPRN:	SETZ	CH,		;
DPYPR1:	LSH	CH,^D9		;
	IDIVI	N,^D10		;
	IORI	CH,"0"(N1)	;
	JUMPN	N,DPYPR1	;
; ; ;	;PJRST	DPYOUT		;
>;;END OF IFE V.DISP-V.ANSI

DPYOUT:	SKIPE	CCIOPC
	POPJ	P,
DPYOU2:	PUSH	P,CH		;SAVE CH IN CASE MULT CHARS
	ANDI	CH,177		;ONLY 7-BIT ASCII CHARACTERS GET OUTPUT
	PUSHJ	P,DPYCHO	;OUTPUT THIS CHARACTER
	POP	P,CH		;GET BACK CH
	LSH	CH,-^D9		;SHIFT OVER BY ONE "CHARACTER"
	JUMPN	CH,DPYOU2	;LOOP BACK IF MORE CHARACTERS
	POPJ	P,		;ALL DONE

DPYCHO:	SOSG	THED+2
	PUSHJ	P,FRCOUT	;FORCE OUTPUT
	IDPB	CH,THED+1
	POPJ	P,
NRMDEV=='TTY'		;NORMALLY TO TTY:
>;	END OF IFN V.DISP-V.DVBX
IFE V.DISP-V.DVBX,<
NRMDEV=='DIS'		;NORMALLY TO DIS:
>;	END IFE V.DISP-V.DVBX

OPNTTY:	MOVE	T1,[SIXBIT /SYSDPY/]
	DEVCHR	T1,
	JUMPN	T1,OPNTT1
	MOVSI	T1,NRMDEV
	DEVCHR	T1,
	MOVSI	B,NRMDEV
OPNTT2:
IFN V.DISP-V.DVBX,<
	TRNN	T1,1_10
	TDZA	A,A
	MOVEI	A,10
	TRO	A,700		;NO ECHO
	TXNN	T1,DV.TTY	;SEE IF A TTY
	TRZ	A,-1		;NO--KILL SPECIAL MODES
	MOVSI	C,THED
	OPEN	TTY,A
	  EXIT
	OUTBUF	TTY,3
	MOVE	A,[SIXBIT /SYSDPY/]
	MOVSI	B,(SIXBIT /TXT/)
	SETZB	C,D
	ENTER	TTY,A
	  JFCL
>;	END IFN V.DISP-V.DVBX
IFE V.DISP-V.DVBX,<
	MOVEI	A,15		;SET DISPLAY DUMP MODE
	MOVEI	C,0		;NO BUFFERS
	OPEN	DIS,A		;GET EQUIPMENT
	  JRST	[OUTSTR [ASCIZ /? DIS NOT AVAILABLE
/]
		 EXIT]
				;(EDIT 1 PART 2) CODE MOVED TO FRONT OF MODULE
	TRZ	F,FR.DIS	;INDICATE TO INITIALIZE DIS
>;	END OF IFE V.DISP-V.DVBX
	POPJ	P,0

OPNTT1:	MOVE	B,[SIXBIT /SYSDPY/]
	JRST	OPNTT2

;ROUTINE TO FORCE OUT TTY DISPLAY
FRCOUT:	SKIPE	CCIOPC		;UNLESS ^C INTERCEPT, SKIP
	JRST	FRCOU1		;IF SO--OMIT THE OUTPUT
FRCUUO:	OUTPUT	TTY,		;ELSE, DO THE OUTPUT
	POPJ	P,		;AND RETURN

FRCOU1:	PUSH	P,A		;FREE UP AN AC
	MOVEI	A,5*20		;NUM CHARS/BUF
	ADDM	A,THED+2	;MAKE ROOM
	MOVNI	A,20		;NUM WORDS/BUF
	ADDM	A,THED+1	;BACK UP POINTER
	POP	P,A		;RESTORE AC
	POPJ	P,		;RETURN
;DHMPRT  --  PRINT "A" IN [[DAYS:]HOURS:]MINUTES

DHMPRT:	CAIGE	N,^D60		;NEED HOURS?
	PJRST	DECPRT		;NO, JUST STRAIGHT MINUTES
	IDIVI	A,^D60*^D24	;A:=DAYS TO GO
	SKIPN	N,A		;SKIP IF NO DAYS
	JRST	DHMPR2		;JUST PRINT HOURS:MINUTES
	PUSHJ	P,DECPRT	;PRINT DAYS
	MOVEI	CH,"D"		;SEPARATOR
	PUSHJ	P,TYO		;PRINT IT
DHMPR2:	IDIVI	B,^D60		;B:=HOURS
	MOVE	N,B		;N:=HOURS
	CAIE	A,0		;DID WE TYPE DAYS?
	PUSHJ	P,DECZ2		;YES, PRINT TWO-DIGIT HOURS
	CAIN	A,0		;DID WE TYPE DAYS?
	PUSHJ	P,DECPRT	;NO, PRINT ONE-OR-TWO-DIGIT HOURS
	PUSHJ	P,COLON		;SEPARATE FROM MINUTES
	MOVE	N,C		;N:=MINUTES
	PJRST	DECZ2		;PRINT TWO-DIGIT MINUTES
;TCKTIM  --  PRINT "A" IN HH:MM:SS OR MM:SS.CC FORMAT

TCKTIM:	IMULI	A,^D100		;"INCREASED" PRECISION
	IDIV	A,TCKSEC	;JUNK JIFFIES
	CAXGE	A,^D60*^D60*^D100  ;TIME EXTEND INTO HOURS?
	JRST	TCKTM4		;NO, PRINT MM:SS.CC INSTEAD
	IDIVX	A,^D60*^D60*^D100  ;YES, A := HOURS
	MOVE	N,A
	PUSHJ	P,DECZ2
	PUSHJ	P,COLON
TCKTM1:	IDIVI	B,^D60*^D100	;B := MINUTES
	MOVE	N,B
	PUSHJ	P,DECZ2
	PUSHJ	P,COLON
	IDIVI	C,^D100		;C := SECONDS
	MOVE	N,C
	PJRST	DECZ2		;CAP OFF WITH MINUTES

TCKTM4:	IDIVI	A,^D60*^D100	;A:= MINUTES
	MOVE	N,A		;POSTION FOR DECZ2
	PUSHJ	P,DECZ2		;TYPE TWO DIGIT DECIMAL
	PUSHJ	P,COLON		;TERMINATE MINUTES
	IDIVI	B,^D100		;B := SECONDS; C := HUNDREDTHS
	MOVE	N,B		;POSITION SECONDS FOR DECZ2
	PUSHJ	P,DECZ2		;TYPE TWO DIGIT DECIMAL
	PUSHJ	P,DOT		;TERMINATE WITH A "."
	MOVE	N,C		;POSITION HUNDREDTHS FOR DECZ2
	PJRST	DECZ2		;TYPE TWO DIGIT DECIMAL



;HEXPRB  --  PRINT A HEX BYTE

HEXPRB:	ANDI	N,377		;MASK BYTE
	PUSH	P,N		;SAVE VALUE
	LSH	N,-4		;GET HIGH DIGIT
	PUSHJ	P,HEXPRT	;PRINT IT
	POP	P,N		;GET BACK VALUE
	ANDI	N,17		;GET LOW DIGIT
	PJRST	HEXPRT		;PRINT OUT AND RETURN


;DECPRT  --  PRINT A GENERAL DECIMAL NUMBER

HEXPRT:	SKIPA	R,[^D16]
DECPRT:	MOVEI	R,12
RDXPRT:	MOVEI	CH,"-"
	JUMPGE	N,RADIX1
	PUSHJ	P,TYO
	MOVMS	N
RADIX1:	IDIVI	N,(R)
	HRLM	N1,0(P)
	SKIPE	N
	PUSHJ	P,RADIX1
	HLRZ	CH,0(P)
	ADDI	CH,"0"
	CAILE	CH,"9"
	ADDI	CH,"A"-"9"-1
	JRST	TYO
;DECPN?  --  PRINT A ?-DIGIT DECIMAL NUMBER
;CALL IS:
;
;	MOVX	N,<NUMBER>
;	MOVX	A,<-DIGITS,,"FILLER">
;	PUSHJ	P,DECPN
;
;WHERE DIGITS IS THE COUNT OF DIGITS TO BE OUTPUT; FILLER IS THE
;FILL CHARACTER TO USE FOR LEADING CHARACTERS. NEGATIVE NUMBERS
;DON'T WORK.

DECB8:	MOVE	A,[-^D8,," "]	;EIGHT-DIGIT NUMBER FIELD
	PJRST	DECPN		;GO DO GENERALIZED STUFF

DECB7:	SKIPA	A,[-^D7,," "]	;SEVEN-DIGIT NUMBER FIELD
DECB6:	MOVE	A,[-^D6,," "]	;SIX-DIGIT NUMBER FIELD
	PJRST	DECPN		;GO DO GENERALIZED STUFF

DECB5:	SKIPA	A,[-^D5,," "]	;FIVE-DIGIT NUMBER FIELD
DECB4:	MOVE	A,[-^D4,," "]	;FOUR-DIGIT NUMBER FIELD
	PJRST	DECPN		;GO DO GENERALIZED STUFF

DECB3:	SKIPA	A,[-^D3,," "]	;THREE-DIGIT NUMBER FIELD
DECB2:	MOVE	A,[-^D2,," "]	;TWO-DIGIT NUMBER FIELD
	PJRST	DECPN		;GO DO GENERALIZED STUFF

DECZ2:	MOVE	A,[-^D2,,"0"]	;TWO-DIGIT NUMBER FIELD
	PJRST	DECPN		;GO DO GENERALIZED STUFF



DECPN:	MOVEI	R,^D10		;DECIMAL RADIX
RDXPN:	HRRZM	A,L0FILL	;LEADING ZERO FILL CHARACTER
RDXPN0:	IDIVI	N,(R)		;GET NEXT ---ADE
	ADDI	N1,"0"		;ASCII-IZE IT
	HRLM	N1,(P)		;AND SAVE IT AWAY FOR TYPEOUT
	AOBJN	A,.+1		;COUNT UP DIGITS
	JUMPE	N,RDXPN4	;EXIT LOOP IF DONE WITH NON-ZERO DIGITS
	PUSHJ	P,RDXPN0	;RECURSE FOR WHOLE NUMBER

RDXPN2:	HLRZ	CH,(P)		;RETRIEVE ASCII DIGIT
	PJRST	TYO		;AND OUTPUT IT

RDXPN4:	JUMPGE	A,RDXPN2	;IF ALREADY FULL, NO FILLERS
RDXPN5:	HRRZ	CH,L0FILL	;GET LEADING FILLER
	PUSHJ	P,TYO		;OUTPUT LEADING FILLER
	AOBJN	A,RDXPN5	;LOOP FOR NOT-YET-FILLED FIELD
	JRST	RDXPN2		;NOW OUTPUT THE REAL DIGITS
PNTPPN:	MOVE	N,A

;PRINT OCTAL AS UNSIGNED HALVES

OCTPRT:	PUSH	P,N
	HLRZ	N,(P)
	JUMPE	N,OCTRH
	MOVEI	R,10
	PUSHJ	P,RDXPRT
	PUSHJ	P,COMMA
OCTRH:	HRRZ	N,(P)
	MOVEI	R,10
	PUSHJ	P,RDXPRT
	POP	P,N
	POPJ	P,
	JRST	RDXPRT

DECTAB:	PUSHJ	P,DECPRT
	JRST	TAB

CONFIG:	MOVEI	M,[ASCIZ /This is/]
CONFIM:	PUSHJ	P,MSG
	PUSHJ	P,SPACE
CONFI0:	MOVEI	B,0
	MOVEI	C,11
CONFL:	MOVEI	M,A
	MOVE	A,C
	PUSHJ	P,GETA
	PUSHJ	P,MSG
	AOBJN	C,.+1
	TRNE	A,376
	SOJA	C,CONFL
	POPJ	P,0
PDATIM:	MOVE	A,XDATE		;DATE
	CALL	GETA		;GET THE DATE
	IDIVI	A,^D31
	MOVEI	N,1(B)
	MOVE	B,A		;SAVE A
	PUSHJ	P,DECZ2		;PRINT TWO-DIGIT DAY OF THE MONTH
	MOVE	A,B		;RESTORE A
	IDIVI	A,^D12
	MOVE	B,MONTAB(B)
	MOVEI	C,0
	MOVEI	M,B
	MOVEI	N,^D64(A)
	PUSHJ	P,MSGDEC	;PRINT MESSAGE FOLLOWED BY DECIMAL NO.
	PUSHJ	P,SPACE
	MOVE	A,XTIME
	PUSHJ	P,GETA
	JRST	TCKTIM


PUPTIM:	MOVEI	M,[ASCIZ/UP:/]	;IDENTIFY WHAT FOLLOWS
	PUSHJ	P,MSG		;TYPE IT
	MOVE	A,UPTINC	;GET APPROPRIATE UPTIME FIGURE
	PJRST	TCKTIM		;AND TYPE IT OUT

GUPTIM:	MOVE	A,XSMPTM	;SYSTEM UPTIME GETTAB
	PUSHJ	P,GET		;SEE HOW LONG SYSTEM UP
	 SKIPA	A,XUPTIM	;MUST BE PRE-SMP MONITOR
	POPJ	P,		;SMP TOTAL SYSTEM UPTIME
	PJRST	GETZ		;SEE HOW LONG MASTER UP
;ROUTINE TO COMPUTE INTEGER SQRT:  N=ISQRT(A,B)
;CALLED WITH POS ARG IN "A,B", RESULT RETURNED IN "N", USES N1

ISQRT:	MOVEI	N,0		;PRESET NULL ANSWER
	JUMPL	A,CPOPJ		;RETURN 0 IF NEG
	MOVE	N,A		;COPY ARG
	JFFO	N,.+2		;SET N1 TO NUM 0S
	MOVEI	N1,^D36		; IN CASE ALL ZERO
	SOS	N1		;BACK DOWN FOR SIGN BIT
	TRZ	N1,1		;MAKE SMALLER EVEN
	LSH	B,1		;COMPRESS OUT SIGN BIT OF B
	LSHC	A,-^D35(N1)	;POSITION MOST SIG. BITS IN B
	ASH	N1,-1		;DIVIDE SHIFT BY 2
	MOVNS	N1		;SET TO OTHER WAY FOR ANSWER

	TRO	B,1		;FORCE SOME BITS ON TO TERMINATE
	MOVEI	N,0		;CLEAR ANSWER
ISQ1:	ASH	N,1		;MOVE TO NEXT BIT
	CAMG	A,N		;SEE IF REMAINDER IS BIG
	JRST	ISQ2		;NO--LOOP ON
	SUB	A,N		;DECREASE REMAINDER
	SUBI	A,1		; ..
	TRO	N,2		;INCREASE RESULT
ISQ2:	LSHC	A,2		;SHIFT REMAINDER TWO BITS
	JUMPN	B,ISQ1		;LOOP UNTIL DONE
	ASH	A,-1		;BACK OFF REMAINDER
	CAMLE	A,N		;SEE IF ROUNDING NEEDED
	ADDI	N,1		;YES--INCREASE RESULT

	ASH	N,^D17(N1)	;POSITION RESULT
	POPJ	P,		;RETURN
SUBTTL CONSTANTS AND DATA

;CONSTANTS FOR GETTAB UUO

XTIME:	XWD	10,11
XDATE:	XWD	11,11
XSEGPT:	XWD	15,11
XUPTIM:	XWD	15,12
XSMPTM:	%CNSUP		;TOTAL SMP SYSTEM UPTIME
XDVLST:	XWD	14,11
XSTATS:	XWD	17,11
XLSTIM:	XWD	22,12
XK4SWP:	XWD	1,15
XSYSSZ:	XWD	12,11
XMEMSZ:	XWD	23,12
XSPPN:	XWD	1,16
XOPR:	XWD	13,11
XGETTS:	XWD	23,23		;GET TAB SELF POINTER
XSYSUNI:	XWD 7,16
XSWPER:	XWD	5,13
XSWPUN:	XWD	10,16
XPTYCN:	XWD	22,11		;PTY CONFIGURATION
XOPPN:	XWD	2,16		;OPERATOR PPN
XLPPN:	XWD	3,16		;LOGIN PPN
XHGHJB:	XWD	20,12		;HIGHEST JOB CURRENTLY ACTIVE
XPDBPT:	XWD	45,11		;PTR TO LIST OF PDB'S
XDDBLD:	XWD	75,11		;POINTER TO VALUE OF LDB LINK IN TTY DDB

QTAB:	SIXBIT	/RNWSTS/
	SIXBIT	/STAUMQ/
	SIXBIT	/DADTDC/
	SIXBIT	/MTIOTI/
	SIXBIT	/SLNL^C/
	SIXBIT	/AABBCC/
	SIXBIT	/DDEEFF/
	SIXBIT	/GGHHII/
	SIXBIT	/JJKKLL/
	SIXBIT	/MMNNOO/
	SIXBIT	/PPQQRR/
LQTAB==QTAB-.
MONTAB:	ASCII	/-Jan-/
	ASCII	/-Feb-/
	ASCII	/-Mar-/
	ASCII	/-Apr-/
	ASCII	/-May-/
	ASCII	/-Jun-/
	ASCII	/-Jul-/
	ASCII	/-Aug-/
	ASCII	/-Sep-/
	ASCII	/-Oct-/
	ASCII	/-Nov-/
	ASCII	/-Dec-/

SYSPPN:	XWD	1,1
OLDPPN:	Z
NEWPPN:	Z
OPRPPN:	XWD	1,2		;DEFAULT OPERATOR PPN
LOGPPN:	XWD	2,5		;DEFAULT LOGIN PPN
COMMENT &
TABPTR IS A TABLE USED TO INITIALIZE ALL TABLES NEEDED BY SYSDPY

BASICALLY THERE ARE TWO TYPES OF TABLES:
1 TABLES IN THE SPY SEGMENT
2 TABLES IN SYSDPY CORE

THE TABLES ARE DESCRIBED BY FOUR FIELDS IN THE LEFTHALF POINTER
OF THE TABPTR ENTRIES. THESE FIELDS ARE ADDRESSED BY 4 BYTE POINTERS:
1 PSIZE A TWO BIT LEFT ADJUSTED FIELD USED TO INDEX TABLE TSIZE
  THIS OPERATION GIVES THE THE TABLE LENGTH
2 PSPY A BIT IF SET FLAGGING THAT TABLE IS IN SPY SPACE NOW
3 PSPYTB A BIT THAT INDICATES TABLE IS SPYABLE FROM MONITOR
4 PTABLE AN INDEX OF THE TABLE FOR GETTAB UUOS (IFF SPYTAB SET)

NOTE: THE SIZE OF BOTH IS ONPURPOSE 2,THIS SATISFIES OLD SIGN TESTS
&

LJOBN==0B1		;TABLE INDEX BY JOB NUMBER
LSEGN==1B1		;TABLE INDEX BY SEGMENT NUMBER
LBOTH==2B1		;TABLE INDEX BY JOB OR SEGMENT NUMBER
			;3B1 IS ILLEGAL

			;1B2 IS USED BY PSPY
SPYTAB==1B3		;TABLE IS SPYABLE FROM MONITOR


PSIZE:	POINT	2,(D),1	;TSIZE INDEX
PSPY:	POINT	1,(D),2	;TABLE IS CURRENTLY BEING SPYED
PSPYTB:	POINT	1,(D),3	;TABLE IS SPYABLE FROM MONITOR
PTABLE:	POINT	9,(D),17;GETTAB TABLE INDEX (IFF SPYTAB SET)
;THE TABLE USED TO INITIALIZE SYSDPY'S JOB DATA TABLES
;
;THE TABLES AT TABLE ARE INTERNAL SYSDPY BOOKKEEPING TABLES.
;
;THE TABLES AT TABPTR ARE MONITOR TABLES WHICH, IF THEY CANNOT BE
;SPIED, ARE CONVERTED TO INTERNAL SYSDPY TABLES AND FILLED BY
;GETTAB'ING THE INFORMATION FROM THE MONITOR (SLOW, BUT SURE)

TABLE:	EXP	LJOBN+TTIOS
	EXP	LJOBN+TTLDB
	EXP	LJOBN+JTTIM
	EXP	LJOBN+JTRCT
	EXP	LJOBN+JTWCT
TABPTR:	EXP	LBOTH!SPYTAB+<.GTSTS,,JBSTS>
	EXP	LBOTH!SPYTAB+<.GTADR,,JBADR>
	EXP	LBOTH!SPYTAB+<.GTPPN,,JBPPN>
	EXP	LBOTH!SPYTAB+<.GTPRG,,JBPRG>
	EXP	LJOBN!SPYTAB+<.GTTIM,,JBTIM>
	EXP	LBOTH!SPYTAB+<.GTSWP,,JBSWP>
	EXP	LJOBN!SPYTAB+<.GTSGN,,JBSGN>
	EXP	LJOBN!SPYTAB+<.GTRCT,,JBRCT>
	EXP	LJOBN!SPYTAB+<.GTWCT,,JBWCT>
	EXP	LJOBN!SPYTAB+<.GTNM1,,JBNM1>
	EXP	LJOBN!SPYTAB+<.GTNM2,,JBNM2>
	EXP	LJOBN!SPYTAB+<.GTRTD,,JBRTD>
	EXP	LJOBN!SPYTAB+<.GTVRT,,JBVRT>
	EXP	LJOBN!SPYTAB+<.GTST2,,JBST2>
;	EXP	LJOBN!SPYTAB+<.GTPC,,JBPC>
	EXP	LJOBN!SPYTAB+<.GTPDB,,JBPDB>
	EXP	LBOTH!SPYTAB+<.GTIMI,,JBIMI>
	EXP	LBOTH!SPYTAB+<.GTIMO,,JBIMO>
	EXP	LJOBN!SPYTAB+<.GTDDB,,JBDDB>
	EXP	LJOBN!SPYTAB+<.GTVIR,,JBVIR>
NTAB==.-TABPTR
	EXP	LSEGN+SGCNT

NTABLE=.-TABLE
;THE ACTUAL TABLE POINTERS (INITIALIZED BY GJBDAT TO EITHER BE
;INTERNAL TO SYSDPY TABLES (MEMORY ALLOCATED AT RUN TIME BASED
;ON MONITOR'S JOB CAPACITY) OR THE ACTUAL MONITOR TABLE ADDRESS
;RELOCATED INTO THE SPY SPACE.

;THE TT--- TABLES ARE UNAVAILABLE WITHOUT PEEKING OR SPYING ABILITIES.

TTIOS:	Z	0(J)		;CONTROLLING TTY DEVIOS WORD
TTLDB:	Z	0(J)		;TTY LDB ADDRESS

;THE JI--- VARIABLES ARE THE INCREMENTAL STATISTICS FOR PRESENT JOB.

JITIM:	Z			;[610] INCREMENTAL RUNTIME
JIRCT:	Z			;[610] INCREMENTAL DISK READS
JIWCT:	Z			;[610] INCREMENTAL DISK WRITES

;THE JT--- TABLES ARE USED FOR PER-JOB INCREMENTAL STATISTICS DISPLAY

JTTIM:	Z	0(J)		;RUNTIME (TOTAL) LAST UPDATE CYCLE
JTRCT:	Z	0(J)		;DISK READS (TOTAL) LAST UPDATE CYCLE
JTWCT:	Z	0(J)		;DISK WRITES (TOTAL) LAST UPDATE CYCLE

;THE JB--- TABLES ARE THE REAL JOB TABLES

JBSTS:	Z	0(J)		;JOB STATUS (RUN, SWAPPED, ETC.)
JBADR:	Z	0(J)		;PROGRAM SIZE (NON-VM)
JBPPN:	Z	0(J)		;JOB'S ACCOUNT (PPN)
JBPRG:	Z	0(J)		;PROGRAM NAME
JBTIM:	Z	0(J)		;TOTAL RUNTIME
JBSWP:	Z	0(J)		;SWAPPING POINTER AND SIZE
JBSGN:	Z	0(J)		;HIGH SEG NUMBER AND FLAGS
JBRCT:	Z	0(J)		;INCREMENTAL AND TOTAL DISK READS
JBWCT:	Z	0(J)		;INCREMENTAL AND TOTAL DISK WRITES
JBNM1:	Z	0(J)		;FIRST HALF OF USER NAME
JBNM2:	Z	0(J)		;SECOND HALF OF USER NAME
JBRTD:	Z	0(J)		;REAL-TIME (HPQ) WORD
JBVRT:	Z	0(J)		;PROGRAM (SEGMENT) VIRTUAL SIZES
JBST2:	Z	0(J)		;SECOND JOB STATUS (EW CODE, ETC.)
JBPC:	Z	0(J)		;PROGRAM PC
JBPDB:	Z	0(J)		;ADDRESS OF PDB, MONITOR PAGES, ETC.
JBIMI:	Z	0(J)		;PROGRAM/SEGMENT "IMGIN" SIZE
JBIMO:	Z	0(J)		;PROGRAM/SEGMENT "IMGOUT" SIZE
JBddb:	Z	0(J)		;I/O WAIT DDB
JBVIR:	Z	0(J)		;PROGRAM VIRTUAL SIZE


;THE SG--- TABLES ARE INTERNAL INFO FOR THE SEGMENTS

SGCNT:	Z	0(A)		;HIGH SEGMENT COUNTS
	SGC$AC==1B1		; LH = FLAGS:  SGC$AC  SEGMENT COUNTED IN ACTUSE
				; RH = COUNT OF JOBS USING THIS SEGMENT
TAB0:	DEC	4,12,16,23,26,32		;FOR JOB DISPLAY
TABJ0:	DEC	4,12,16,23,26,32,44,52,56,63,66,72  ;JOBS ONLY
TABS0:	DEC	4,12,16,23,26,32,40,50,60	;FOR EXPANDED JOB DISPLAY
TABV0:	DEC	4,12,16,23,40,58,64,70
TAB1:	DEC	46,49,52,55,65,69,73,77		;CPU STUFF
TAB1CP:	DEC	46,50,54,58,62,66,70,74		;KL PERF PERCENTAGES
TAB1IO:	DEC	46,51,56,61			;DISK I/O
TAB1NT:						;NETWORK I/O
TAB1TT:	DEC	53,62				;TTY STATISTICS
TAB1ST:	DEC	48,52,61,68,72			;STRUCTURES DISPLAY
TAB1DV:	DEC	48,51,54,61,64,67,74,77		;DEVICES DISPLAY COLUMNS
TAB2:	DEC	48,51,54,65,68,71		;FOR HISEG DISPLAY
TABV2:	DEC	59,62,65,76,79,82
TAB4:	DEC	16,23,30,37,44,51,58,65,72	;RANDOM
TAB4FS:	DEC	16,25,34,43,52,61,70		;FOR FILE SYSTEM DISPLAY
TAB5:	DEC	10
TAB6:	DEC	13,XSIZE-39,XSIZE-34,XSIZE-29,XSIZE-24,XSIZE-19,XSIZE-14,XSIZE-9,XSIZE-4
TAB6X:	DEC	13,XSIZE-31,XSIZE-27,XSIZE-23,XSIZE-19,XSIZE-15,XSIZE-11,XSIZE-7,XSIZE-3
TAB7:	DEC	8,16,24,32,40,48,56,64,72
	IFN FTNET,<			;NETWORK VARIABLES
TAB8:	DEC	X2SIZE+7,X2SIZE+15,X2SIZE+23,X2SIZE+31,X2SIZE+39
TAB9A:	DEC	1+16,1+16+9		;UNNUMBERED CTL
TAB9B:	DEC	X2SIZE+16,X2SIZE+16+9	;NUMBERED CTL
	>				;
TAB10:	DEC	48,52,68,72		;STRUCTURE DISPLAY
TABCI:	DEC	8,18,28,38,48,58,68	;CI STUFF
TABDNL:	DEC	12,21,26,33,41,49,55,61,66,72  ;DECNET LINKS
TABDNN:	DEC	9,17,23,29,36,45	;DECNET NODES
IFN FTNET,<
TABETH:	DEC	20,29,36,52,63		;ETHERNET DISPLAY
TABLAT:	DEC	12,24,36,48,60,72	;LAT DISPLAY
>; END IFN FTNET
BPTAB:	POINT	9,DBUF,8
	POINT	9,DBUF,17
	POINT	9,DBUF,26
	POINT	9,DBUF,35



	XLIST				;THE LITERALS
	LIT
	LIST
;MORE MONITOR INTERFACE

PJOBNO:	Z	(D)	;RH SET WITH DEVJOB OFFSET INTO DDB
PJOBNP:	Z	C	;LH SET WITH BYTE POINTER INTO C

;LENTAB CORRESPONDENCE BETWEEN TABLE LENGTH AND ENTRY TYPE IN NUMTAB
;>0 YOU GOT THE LENTH
;=0 TABLE DOES NOT EXIST (NO ENTRIES)
;-1 PDB DATA
;-2 NUMTAB CONTAINS THE LENGTH

LENTAB:	EXP	0	;GT.UND UNDEFINED
	EXP	-2	;GT.ITM NUMTAB ENTRY HAS LENGTH
GT.JOB:	EXP	0	;GT.JOB CHANGED BY IJBDAT CODE
GT.SEG:	EXP	0	;GT.SEG SET BY IJBDAT CODE
	EXP	-1	;GTJBPDB PDB DATA

TPCJOB:	POINT	8,B,10
IMGOUT:	POINT	9,@JBSWP,26
IMGIN:	POINT	9,@JBSWP,35
DSKLEV:	POINT	3,STATES,9	;DISK MONITOR LEVEL NO.
TTYTAB:	EXP	;ADDRESS OF TTYTAB FOR EFFICIENT SPY
VDDLDB:	EXP		;VALUEDDBLDB
.SEGLS:	EXP		;LAST WORD IN SGCNT TABLE

CCINT:	4,,CCTYPD	;^C INTERCEPT BLOCK
	ER.ICC
CCIOPC:	Z
	Z

TTYFLG:	EXP	0	;0 WHEN NO LINE NUMBERS CAN BE GOTTEN
			;-1 WHEN SPYING ON OLD TOPS10
			;+1 WHEN ISUING TRMNO. AND DEVNAM UUO'S TO GET DATA
CTYNDX:	EXP	0	;CONTAINS INDEX OF CTY WHEN TTYFLG=+1

L0FILL:	BLOCK	1	;HOLDS FILLER FOR DECP??

IFE V.DISP-V.DVBX,<
DISPLA:	020137		;MODE 0/1: FULL INTENSITY,SCALE=1, 60HZ. SYNC.
	221750,,160000	;MODE 1:X=1000.; MODE 1:Y=0.
	060000,,DISBUF	;MODE 7:JUMP AND GO TO MODE 3(SIXBIT)
>;	END IFE V.DISP-V.DVBX

PDLST:	BLOCK	PDLEN	;ALLOCATE STACK SPACE
IFN	FTNET,<

;LIST OF BYTE POINTERS INTO NDB (MATCHES NDBGTB)

NDBPTB:
NDBLEN:	24			;LENGTH OF NDB
NDBNXT:	POINT	18,XDBBLK+00,35	;ADDRESS OF NEXT NDB
NDBNNM:	POINT	18,XDBBLK+00,17	;NODE NUMBER
NDBSNM:	POINT	18,XDBBLK+02,17	;ADDRESS OF STATION NAME
NDBNGH:	POINT	18,XDBBLK+07,17	;FIRST NEIGHBOR ENTRY
NDBNGL:	POINT	18,XDBBLK+16,35	;LAST NEIGHBOR ENTRY
NDBNGN:	POINT	10,N,27		;NODE NUMBER FROM NDBNGH
NDBOPR:	POINT	18,XDBBLK+17,35	;ADDRESS OF OPR LDB IF ANY
NDBCTJ:	POINT	18,XDBBLK+23,17	;STATION CONTROL JOB NUMBER
NDBLAR:	POINT	8,XDBBLK+03,11	;LAST ACK RECEIVED
NDBLAP:	POINT	8,XDBBLK+03,19	;LAST OUTPUT MESSAGE# ACK'ED
NDBLMS:	POINT	8,XDBBLK+03,27	;LAST MESSAGE SENT
NDBLMA:	POINT	8,XDBBLK+03,35	;LAST MESSAGE NUMBER ASSIGNED
NDBLMR:	POINT	8,XDBBLK+02,35	;LAST INPUT MESSAGE RECEIVED
NDBLMP:	POINT	8,XDBBLK+02,27	;LAST MESSAGE PROCESSED

> ;END IFN FTNET



;PROTOTYPE QUEUES-LISTING REQUEST MESSAGE FROM QUASAR

QSRMSG:	XWD	QSRLEN,.QOLIS	;TYPE OF FUNCTION AND LENGTH
	XWD	0,'SYS'		;FLAGS AND 3 LETTER MNENOMIC
	EXP	0		;ACKNOWLEDGE WORD

	EXP	0		;NO SPECIAL FLAGS
	EXP	1		;ONE ARGUMENT BLOCK FOLLOWING

	XWD	2,.LSQUE	;QUEUE BLOCK
QSRFLG:	EXP	0		;WHICH QUEUES TO LIST, FILLED IN AT RUNTIME

	QSRLEN==.-QSRMSG	;SIZE OF PACKET
ZER:!	BLOCK	21	;START OF AREA TO ZERO

;9 BYTE/CH	CH IF SAME; 200+CH IF DIFF; 400+OLD IF SPACE
DBUF:	BLOCK	<YSIZE*XSIZE/4>+1
DBFEND=.-1

IFE V.DISP-V.DVBX,<
DISBUF:	BLOCK	<YSIZE*XSIZE/5>+10
DISBEN:	353537,,160000	;NULLS,ESCAPE; MODE 0:NULL
	0,,DISPLA	;MODE 7:JUMP TO START
DISBES:	DISBEN-1	;OLD END OF BUFFER
>;	END IFE V.DISP-V.DVBX

IFE V.DISP-V.DDLT, <
LASTCR:	BLOCK	YSIZE		;LAST CHARACTER POSITION ARRAY
				;  FOR DELTA-DATA TELTERM
>;	END OF	IFE V.DISP-V.DDLT

HIBTIM:	BLOCK	1	;WAIT TIME BETWEEN UPDATES
HIBTIW:	BLOCK	1	;AS ENTERED BY OPERATOR
HLPADR:	EXP	0	;ADDRESS OF HELP TEXT IF READ IN

P2WLSH:	BLOCK	1	;LSH @P2WLSH FOR "PAGES" TO WORDS
W2PLSH:	BLOCK	1	;LSH @W2PLSH FOR WORDS TO "PAGES"

GETAB:	Z		;TEMP USED BY PSEUDO CODE
GETAB1:	Z		;TEMP USED BY PSEUDO CODE
GETAB2:	Z		;USED BY PSEUDO CODE
GETAB3:	0		;ANOTHER TEMP
TEMP:	0
TEMP1:	0
REPS:	0

JOBPHY:	BLOCK	1	;JOB LOW,,HIGH PHYSICAL SIZE
JOBPPG:	BLOCK	1	;COUNT OF PER-PROCESS PAGES
JOBVIR:	BLOCK	1	;JOB LOW,,HIGH VIRTUAL SIZE
CPU:	BLOCK	1	;CPU NUMBER FOR RESPONSES(0,1)
CPMAX:	BLOCK	1	;MAX CPU NUMBER SYS IS BUILT FOR
CPMNY:	BLOCK	1	;.GT. 0 IF MULTI-CPU
CPBTS:	BLOCK	1	;SYSTEM BOOT CPU
CPHDR:	BLOCK	1	;ADDR OF HEADER STRING IF NEEDED
CPRLX:	BLOCK	1	;OFFSET FOR CPLQR
CPCSH:	BLOCK	1	;.NE. 0 IF CACHE MEMORY SYSTEM
CPKS10:	BLOCK	1	;[633] .NE. 0 IF KS-10

;TABLES FOR CPU INCREMENTAL STATISTICS. THESE TABLES ARE TWO-WAY
;INTERLEAVED SINCE CPU INDEX IN CPULP IS A TWO-WORD INDEX FOR THE
;.CCXXX/.CVXXX MONITOR TABLES

CPNAM:	BLOCK	1	;CPU NAME
CPOKF:	BLOCK	1+5+5	;.NE. 0 THEN CPU NOT RUNNING
CPUPT:	BLOCK	1	;CPU UPTIME (IN TICKS)
CPNUL:	BLOCK	1+5+5	;CPU IDLE (NULL) TIME (IN TICKS)
CPOHT:	BLOCK	1	;CPU OVERHEAD TIME (IN TICKS)
CPLST:	BLOCK	1+5+5	;CPU LOST TIME (IN TICKS)
CPTJC:	BLOCK	1	;TOTAL JOB CONTEXT SWITCHS
CPNDB:	BLOCK	1+5+5	;NUMBER OF TIMES DOORBELL RUNG (MULTI-CPU)
CPCSN:	BLOCK	1	;NUMBER OF TIMES CACHE SWEPT (KL-10 ONLY)
CPTUC:	BLOCK	1+5+5	;TOTAL UUOS
CPFBI:	BLOCK	1	;DISK (FILE) BLOCKS INPUT
CPFBO:	BLOCK	1+5+5	;DISK (FILE) BLOCKS OUTPUT
CPSBI:	BLOCK	1	;DISK (SWAP) BLOCKS INPUT
CPSBO:	BLOCK	1+5+5	;DISK (SWAP) BLOCKS OUTPUT
CPTFI:	BLOCK	1	;MAGTAPE "BLOCKS" INPUT
CPTFO:	BLOCK	1+5+5	;MAGTAPE "BLOCKS" OUTPUT
CPMHD:	BLOCK	1	;DOUBLE WORD CLOCK RATE (MHZ)
CPMHZ:	BLOCK	1+5+5	;SINGLE WORD CLOCK RATE (MHZ)
			;CPMHD ALWAYS 0 SO CAN DDIV IN CPLQR

;THE KL-10 PERFORMANCE ANALYSIS COUNTS
;NOTE THEY ARE INDEXED "STRAIGHT" - THEY ARE NOT INTERLEAVED

CP0PAV:	BLOCK	^D16*4	;CPU0 BACKGROUND PERFORMANCE ANALYSYS
CP1PAV:	BLOCK	^D16*4	;CPU1 BACKGROUND PERFORMANCE ANALYSYS
CP2PAV:	BLOCK	^D16*4	;CPU2 BACKGROUND PERFORMANCE ANALYSYS
CP3PAV:	BLOCK	^D16*4	;CPU3 BACKGROUND PERFORMANCE ANALYSYS
CP4PAV:	BLOCK	^D16*4	;CPU4 BACKGROUND PERFORMANCE ANALYSYS
CP5PAV:	BLOCK	^D16*4	;CPU5 BACKGROUND PERFORMANCE ANALYSYS
NABYI:	BLOCK	1	;ANF NETWORK BYTES RECEIVED
NABYO:	BLOCK	1	;ANF NETWORK BYTES TRANSMITTED

NDBYI:	BLOCK	1	;DECNET NETWORK BYTES RECEIVED
NDBYO:	BLOCK	1	;DECNET NETWORK BYTES TRANSMITTED

NEBYI:	BLOCK	1	;ETHERNET BYTES RECEIVED
NEBYO:	BLOCK	1	;ETHERNET BYTES TRANSMITTED
NEDGI:	BLOCK	1	;ETHERNET DATAGRAMS RECEIVED
NEDGO:	BLOCK	1	;ETHERNET DATAGRAMS TRANSMITTED

SCNRI:	BLOCK	1	;NUMBER OF RECEIVED CHARACTERS
SCNXI:	BLOCK	1	;NUMBER OF TRANSMITTED CHARACTERS

IPCTS:	BLOCK	1	;NUMBER OF IPCF PACKETS TRANSFERED
IPTWT:	BLOCK	1	;NUMBER OF WORDS IN WORD-MODE PACKETS
IPTPT:	BLOCK	1	;NUMBER OF PAGES IN PAGE-MODE PACKETS



IFN	FTNET,<

;NETWORKS STATISTICS INCREMENTAL DISPLAY DATA

NTXTP:	BLOCK	^D10	;UNNUMBERED CONTROL SENT
NTRTP:	BLOCK	^D10	;UNNUMBERED CONTROL RECEIVED
NTXMT:	BLOCK	^D10	;NUMBERED CONTROL SENT
NTRMT:	BLOCK	^D10	;NUMBERED CONTROL RECEIVED
NTXDL:	BLOCK	^D12	;MESSAGES SENT BY LENGTH
NTRDL:	BLOCK	^D12	;MESSAGES RECEIVED BY LENGTH

NTRTL:	BLOCK	1	;TOTAL MESSAGES RECEIVED
NTXTL:	BLOCK	1	;TOTAL MESSAGES TRANSMITTED

NTRTH:	BLOCK	1	;TOTAL DATA MESSAGES RECEIVED
NTXTH:	BLOCK	1	;TOTAL DATA MESSAGES SENT

> ;END IFN FTNET
UPTIME:	0			;UPTIME OF SYSTEM IN JIFFIES
UPTINC:	BLOCK	1		;UPTIME (MAYBE INCREMENTAL)

THED:	BLOCK	3

LOGOHD:	BLOCK	3		;LOG FILE RING HEADER

;THE SEQUENCE OF JOBN SEGN AND BOTH MUST NOT BE CHANGED NOR MUST
;OTHER ENTRIES BE INSERTED
TSIZE:
JOBN:	0
SEGN:	0
BOTH:	0

JBNMAX:	BLOCK	1	;LARGEST JOB NUMBER IN USE
CORMAX:	BLOCK	1	;LARGEST SIZE FOR SINGLE JOB
MAXMAX:	BLOCK	1	;TOTAL PHYSICAL USER MEMORY AVAILABLE
PHYMAX:	BLOCK	1	;MAX POSSIBLE MAXMAX

JBUBZR:			;START OF JOB USAGE FIGURES CLEARED EACH PASS
JBNUSE:	BLOCK	1	;NUMBER OF JOBS IN USE
JBNLOG:	BLOCK	1	;NUMBER OF JOBS LOGGED-IN
JBNDET:	BLOCK	1	;NUMBER OF JOBS DETACHED
ACTUSE:	BLOCK	1	;TOTAL MEMORY USED BY "ACTIVE" JOBS
DSKUSE:	BLOCK	1	;TOTAL DSK (SWAP) MEMORY USED
PHYUSE:	BLOCK	1	;TOTAL PHYSICAL (WORKING SET) MEMORY USED
VIRUSE:	BLOCK	1	;TOTAL VIRTUAL MEMORY USED
SHRSAV:	BLOCK	1	;MEMORY SAVED BY SHARING
JRNRN:	BLOCK	1	;JOBS RUNNING ACTIVELY
JRNIO:	BLOCK	1	;JOBS RUNNING OR IO BLOCKED
JRNSL:	BLOCK	1	;JOBS NOT ^C'ED
JBUEZR==.-1		;END OF JOB USAGE FIGURES CLEARED EACH PASS
SLQ:	BLOCK	1	;"SL" STATE Q CODE
TIQ:	BLOCK	1	;"TI" STATE Q CODE
EWQ:	BLOCK	1	;"EW" STATE Q CODE
LOKCHK:	BLOCK	1	;CHECKED FOR LOCKED SEGMENT FLAG
SEGPTR:	0
ZERLOW:	0
ZERHGH:	0

TCKSEC:	0
STATES:	0
GTTSLF:	0

MONVER:	0		;VERSION OF RUNNING MONITOR
FREAK:	0		;FREQUENCY OF LINE CLOCK JIFFIES
VMPPB0:	0		;SECTION-0 PER-PROCESS BEGIN ADDRESS
VMPPE0:	0		;SECTION-0 PER-PROCESS END ADDRESS
VMPPB1:	0		;SECTION-1 PER-PROCESS BEGIN ADDRESS
VMPPE1:	0		;SECTION-1 PER-PROCESS END ADDRESS
ME:	0
MYJOB:	0
OPR:	0
LINE:	0
COL:	0
BOTTOM:	0
WINDOW:	0
LTEND:	0
LTTEND:	0
RTEND:	0
RELCKC:	0		;COUNT UP TO RELEASE /V
TABCTR:	0		;COUNTER OF TABS IN THIS LINE SO FAR
PROGRM:	0		;WHICH DISPLAY PROGRAM
CURFS:	0		;CURRENT FILE STRUCTURE
CURUN:	0		;CURRENT UNIT NAME
CURUN2:	BLOCK	1	;CURRENT UNIT "PRIME" PORT NAME
DSKBLK:	BLOCK	DSKBKL	;DSKCHR UUO BLOCK
SWPTAB:	BLOCK	SWPTLN	;SWAPPING UNIT TABLE
PTYOFS:	0
DUAL:	0		;-1 IF DUAL PROCESSOR SYSTEM ELSE 0
QSRPID:	BLOCK	1	;PID FOR [SYSTEM]QUASAR
IPCBLK:	BLOCK	.IPCFP+1;IPCF PACKET HEADER BLOCK
;PRINT CONTROL VARIABLES
;ONLY USED BY F DISPLAY CURRENTLY(FIRJOB BY N DISPLAY)

VISIBL:	Z		;MIN 1 WHEN CURRENT LINE IS VISIBLE
			;EQL 0 WHEN SCREEN IS FULL
			;PLS 1 WHEN LINE IS BELOW OUR HORIZONT
			;MANIPULATED BY ICRLF &STROLL

HDRVAL:	Z		;ZERO IF NO HEADER HAS BEEN DELAYED ELSE ADDRESS
			;OF HEADER STRING GENERATOR

NLTYPD:	Z		;NUMBER OF LINES TYPED ON SCREEN

CLINE:	Z		;LOGICAL LINE NUMBER E.G. JOB NUMBER +HEADER LENGTH

LSTLNE:	Z		;LAST LINE NOT TYPED
FIRJOB:	Z		;FIRST LINE VISIBLE IN CURRENT WINDOW
EATCNT:	BLOCK	1	;LINES TO EAT (EMSG)
SLINE:	Z		;SAVE REMAINDER ON SCREEN HERE
SBOTTM:	Z		;SAVE OLD BOTTOM VALUE
.FRAJR:	Z		;AUTO JOB ROLL FACILITY
.FRAJS:	Z		;JOBS SKIPPED DURING AUTO ROLL


PTYMAX:	BLOCK	1
PDBPTR:	BLOCK	1	;ADDR OF LIST OF PDB'S +400000 BIT FOR SPYING
			;LH=N1 TO OFFSET FOR THE DESIRED JOB
SPYSIZ:	BLOCK	1	;MAX EXEC VIRTUAL ADDRESS (LOSEG) WE CAN SPY
REALTT:	BLOCK	1	;-1 IF REAL TTY NAME DESIRED
TRSHLD:	0		;[610] RUNTIME THRESHOLD VALUE (= 1/100 SECONDS)
NUMBER:	BLOCK	1	;NUMBER FOR COMMAND (E.G., "W")
NUMFLG:	BLOCK	1	;NUMBER FOR COMMAND WAS TYPED
HPQCMD:	BLOCK	1	;HPQ LEVEL FROM SET HPQ COMMAND
NETMNY:	BLOCK	1	;.GT. 0 IF NEED TO COMPRESS SCREEN
DCHOFF: BLOCK	1	;LDB OFFSET FOR LDBDCH
LTBOFF:	BLOCK	1	;SECTION OFFSET FOR LDBS
XDBBLK:	BLOCK	XDBLEN	;SCRATCH DATA BLOCK
FLPBLK:	BLOCK	FLPLEN	;FILOP. BLOCK
LKEBLK:	BLOCK	LKELEN	;LOOKUP/ENTER BLOCK
	SUBTTL Low segment -- DCN Stuff

KNONOD:	BLOCK	^D1028		; Block for DNET. Function .DNLNN
NODSTA:	BLOCK	.DNNLN		; Block for DNET. function .DNNDI
DNTBLK:	BLOCK	.DNSLN		; Block for DNET. function .DNSLS
TRMBLK:	BLOCK	4		; TRMOP. Block
SAVCRL:	BLOCK	1		; Storage for TTY CRLF


;ETHERNET DATA STORAGE

IFN FTNET,<
ENTBLK:	BLOCK	.ETAR2+1	;ETHNT. UUO ARGUMENT BLOCK

	RCLBFL==^D5		;SIZE OF READ CHANNEL LIST BUFFER
RCLBUF:	BLOCK	RCLBFL		;READ CHANNEL LIST BUFFER
	RCIBFL==^D5		;SIZE OF READ CHANNEL INFO BUFFER
RCIBUF:	BLOCK	RCIBFL		;READ CHANNEL INFO BUFFER
	RCCBFL==^D50		;SIZE OF READ CHANNEL COUNTERS BUFFER
RCCBUF:	BLOCK	RCCBFL		;READ CHANNEL COUNTERS BUFFER

	RKLBFL==^D5		;SIZE OF READ KONTROLLER LIST BUFFER
RKLBUF:	BLOCK	RKLBFL		;READ KONTROLLER LIST BUFFER
	RKIBFL==^D10		;SIZE OF READ KONTROLLER INFO BUFFER
RKIBUF:	BLOCK	RKIBFL		;READ KONTROLLER INFO BUFFER
	RKCBFL==^D50		;SIZE OF READ KONTROLLER COUNTERS BUFFER
RKCBUF:	BLOCK	RKCBFL		;READ KONTROLLER COUNTERS BUFFER

	RPLBFL==^D20		;SIZE OF READ PORTAL LIST BUFFER
RPLBUF:	BLOCK	RPLBFL		;READ PORTAL LIST BUFFER
	RPIBFL==^D20		;SIZE OF READ PORTAL INFO BUFFER
RPIBUF:	BLOCK	RPIBFL		;READ PORTAL INFO BUFFER
	RPCBFL==^D50		;SIZE OF READ PORTAL COUNTERS BUFFER
RPCBUF:	BLOCK	RPCBFL		;READ PORTAL COUNTERS BUFFER

DGMXMT:	BLOCK	RCLBFL+RKLBFL+RPLBFL	;DATAGRAM TRANSMITTED COUNTS
DGMRCV:	BLOCK	RCLBFL+RKLBFL+RPLBFL	;DATAGRAM RECEIVED COUNTS
DGMFQE:	BLOCK	RCLBFL+RKLBFL+RPLBFL	;DATAGRAM FREE QUEUE ERROR COUNTS
>; END IFN FTNET


;LAT DATA STORAGE

IFN FTNET,<
LASARG:	BLOCK	.LAQUA+1
LASCBF:	BLOCK	^D26
LASBUF:	BLOCK	^D20*7
>; END IFN FTNET
	SUBTTL Low segment -- CI Stuff

CIVARB:!			;BEGINNING OF CI VARIABLES
CPUPTR:	BLOCK	1		;AOBJN POINTER FOR LEGAL CPUS
CPULNN:	BLOCK	6		;LOCAL CI NODE NUMBER FOR EACH CPU
SCSBLK:	BLOCK	20		;GENERAL SCS. UUO BLOCK
CTRBLK:	BLOCK	6*NOSTCT	;STATISTICS COUNTERS (PER CPU)
CIVARE==.-1			;END OF CI VARIABLES
CTRSAV:	BLOCK	6*NOSTCT	;SAVED COPY OF STATISTICS COUNTERS
CTRSVE==.-1			;END OF SAVE COUNTERS AREA
LZER==.-1
	XLIST			;THE LITERALS
	LIT
	LIST


REPEAT 0,<
IF1,<
  IFE	V.DISP-V.DVT6,<PRINTX [End of pass 1 SYSDPY]>
  IFE	V.DISP-V.DV5A,<PRINTX [End of pass 1 SYSDPA]>
  IFE	V.DISP-V.DV5B,<PRINTX [End of pass 1 SYSDPB]>
  IFE	V.DISP-V.DVBX,<PRINTX [End of pass 1 SYSVBX]>
  IFE	V.DISP-V.DV50,<PRINTX [End of pass 1 SYSV50]>
  IFE	V.DISP-V.DV52,<PRINTX [End of pass 1 SYSV52]>
  IFE	V.DISP-V.DV61,<PRINTX [End of pass 1 SYSV61]>
  IFE	V.DISP-V.ANSI,<PRINTX [End of pass 1 SYSANS]>
  IFE	V.DISP-V.DHZL,<PRINTX [End of pass 1 SYSHZL]>
  IFE	V.DISP-V.DDLT,<PRINTX [End of pass 1 SYSDLT]>
> ;END OF IF1
> ;END OF REPEAT 0


	END	SYSDPY
