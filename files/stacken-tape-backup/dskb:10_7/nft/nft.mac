	UNIVER	NFTDEF	NFT definitions
	SUBTTL	Robert D. Houk/RDH

	SEARCH	MACTEN		;MACRO DEFINITIONS (TX--, ETC.)
	SEARCH	UUOSYM		;TOPS-10 MONITOR SYMBOLS
	SEARCH	SWIL		;SWIL DEFINITIONS

	SALL			;PRETTY LISTINGS
	.DIRECT	FLBLST		;PRETTIER LISTINGS

	COMMENT	\

NFTDEF  --  Definitions for NFT and related modules


COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984,1987,1988. ALL RIGHTS RESERVED.


THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED ONLY
IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH THE INCLUSION OF THE
ABOVE NOTICE. THIS SOFTWARE OR ANY OTHER COPIES THEROF MAY NOT BE PROVIDED
OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON. NO TITLE TO AND OWNERSHIP
OF THIS SOFTWARE IS HEREBY TRANSFERRED.

THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE AND
SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.

DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

\
	SUBTTL	Revision history
	SUBTTL	Feature tests

ND	FT$NIP,-1		;LOAD NIP BY DEFAULT
ND	FT$FAL,00		;PUNT FAL BY DEFAULT
ND	FT$TSC,00		;SHUN TSC BY DEFAULT

ND	FT$CCM,00		;SUPPORT "N" COMMANDS ("CCL COMMANDS")
	SUBTTL	Register definitions

	M0=0		;ULTRA-SCRATCH AC, PASS RETURN CODES

	T1=1		;GENERAL SCRATCH/TEMP AC
	T2=2		; ANOTHER
	T3=3		;  AND ANOTHER
	T4=4		;   AND ANOTHER

	P1=5		;PRESERVED REGISTER
	P2=6		; ANOTHER
	P3=7		;  AND ANOTHER
	P4=10		;   AND ANOTHER

	IO=11		;I/O CDB ADDRESS
;	ID=12		;DAP BLOCK ADDRESS FROM CDB

	CI=13		;INPUT CDB INDEX
	CO=14		;OUTPUT CDB INDEX

;15 - 16 RESERVED FOR AP/PF/CF/AD NAUSEUM USAGE (BLISS/FORTRAN/PASCAL/ETC.)

	P=17		;PROGRAM STACK POINTER


;SPECIAL AC USAGE

	NM==P3			;UGLY, BUT THAT IS SCAN'S CONVENTION
	CH==P4			; DITTO

	CX=16			;COMMAND BASE INDEX


;NOW SAVE SOME TREES

	.XCREF	M0, T1, T2, T3, T4, P1, P2, P3, P4, IO, P
	.XCREF	CH, NM
	.XCREF	CI, CO, CX
	SUBTTL	Instruction definitions (OPDEFs, et al)

;THE "EXTENDED" ADDRESSING INSTRUCTIONS THAT HAVEN'T MADE MACRO YET

OPDEF	XMOVEI	[SETMI]
OPDEF	XHLLI	[HLLI]

;GENERATE INSTRUCTION-FORMAT-INDIRECT-WORD

OPDEF	IFIW	[1B0]
 .NODDT	IFIW		;PRESERVE SETZ
	SUBTTL	General definitions - TOTALS flags

;THE TOTALS CONTROL BITS (*MUST* MATCH ORDER OF TOT KEYS MACRO IN NFT!!!)

TT$BIT==1B35	;PRINT BIT(S) SUMMARY
TT$BYT==1B34	;PRINT BYTE(S) SUMMARY
TT$WRD==1B33	;PRINT WORD(S) SUMMARY
;TT$REC==1B32	;PRINT RECORD(S) SUMMARY
TT$BLK==1B31	;PRINT BLOCK(S) SUMMARY
;TT$PAG==1B30	;PRINT PAGE(S) SUMMARY
TT$FIL==1B29	;PRINT FILE(S) SUMMARY
TT$BAU==1B28	;PRINT BAUD RATE
TT$ERR==1B27	;PRINT ERROR(S) SUMMARY
	SUBTTL	General definitions - Miscellaneous

ND	FXVRSN,<12,,%%FXVE>	;SCAN PROTOCOL VERSION WORD
	SUBTTL	Macro definitions - Commands and friends

;COMMAND BASE OFFSETS

$CMPFX==0			;PREFIX (SIXBIT)
$CMPRM==1			;PROMPT STRING (ADDRESS OF ASCIZ)
$CMHLP==2			;MINIMAL HELP TEXT
$CMLEN==3			;LENGTH (POSITIVE INTEGER) OF TABLES
$CMNAM==4			;NAMES TABLE ADDRESS
$CMDSP==5			;DISPATCH TABLE (WITH INDIRECTION AND T1 INDEX)
$CMBLB==6			;BLAB TABLE

;COMMAND BASE TABLE GENERATION MACRO

DEFINE	DOCMND(NME),<

;;GENERATE COMMAND NAMES TABLE

	DEFINE	CM(NAM,ADR,BLB),<SIXBIT\NAM\>

NME'NAM:	CMNDS

	NME'LEN==.-NME'NAM

;;GENERATE COMMAND DISPATCH TABLE

	DEFINE	CM(NAM,ADR,BLB),<Z ADR>

NME'DSP:	CMNDS

;;GENERATE COMMAND TEXT BLURB TABLE

	DEFINE	CM(NAM,ADR,BLB),<[ASCIZ\BLB\]>

NME'BLB:	CMNDS


;;FINALLY, GENERATE THE BASE TABLE

	IFNDEF	NME'HLP,<NME'HLP==0>

NME'BAS:SIXBIT	\NME\		;;THE PREFIX (SIXBIT)
	Z	[ASCIZ\NME\]	;;PROMPT STRING (ASCIZ)
	Z	NME'HLP		;;MINIMAL HELP STRING
	EXP	NME'LEN		;;LENGTH OF COMMAND TABLES
	Z	NME'NAM		;;NAME TABLE
	Z	@NME'DSP(T1)	;;DISPATCH TABLE
	Z	NME'BLB		;;BLAB TABLE

> ;END OF DOCMND MACRO DEFINITION
	SUBTTL	Macro definitions - ABORT, ERROR, WARN, INFORM

;ERROR - PRINT ERROR MESSAGE AND ABORT
;CALL IS:
;
;	ERROR	PFX,TXT,RTN,ADR,DIE
;
;WHERE PFX IS THE 3-LETTER ERROR MNEMONIC; TXT IS ERROR TEXT TO
;BE TYPED OUT; ADR IS OPTIONAL AND IF SPECIFIED IS ADDRESS
;FROM WHICH TO LOAD T1 FOR RTN (USING T1-T4 OR P IS ILLEGAL);
;RTN IS OPTIONAL AND IF SPECIFIED IS SPECIAL ROUTINE TO CALL
;AFTER TXT PRINTED (ONLY CALLED IF /MESS:FIRST) AND WITH T1 LOADED
;FROM ADR; AND DIE IS OPTIONAL RESUME ADDRESS (DEFAULT IS PC+1
;FOR ALL BUT ERROR, WHOSE DEFAULT IS A POPJ P,).

DEFINE	ABORT(PFX,TXT,RTN<0>,ADR<0>,DIE<ERRDIE>),<
A..'PFX:!PUSHJ	P,[PUSHJ P,ERRMSG	;;CALL ERROR MESSAGE PROCESSOR
	SIXBIT	\   PFX\		;;PREFIX
	 "?",,	[ASCIZ\TXT\]		;;CHAR AND TEXT BODY
	 Z	RTN			;;ADDITIONAL ROUTINE
	 Z	ADR			;;ADDITIONAL ADDRESS
	 Z	DIE]			;;RESUME ADDRESS
> ;END ERROR MACRO


DEFINE	ERROR(PFX,TXT,RTN<0>,ADR<0>,DIE<.POPJ##>),<
E..'PFX:!PUSHJ	P,[PUSHJ P,ERRMSG	;;CALL ERROR MESSAGE PROCESSOR
	 SIXBIT	\   PFX\		;;PREFIX
	 "?",,	[ASCIZ\TXT\]		;;CHAR AND TEXT BODY
	 Z	RTN			;;ADDITIONAL ROUTINE
	 Z	ADR			;;ADDITIONAL ADDRESS
	 Z	DIE]			;;RESUME ADDRESS
> ;END ERROR MACRO


DEFINE	WARN(PFX,TXT,RTN<0>,ADR<0>,DIE<.+1>),<
W..'PFX:!PUSHJ	P,[PUSHJ P,ERRMSG	;;CALL ERROR MESSAGE PROCESSOR
	 SIXBIT	\   PFX\		;;PREFIX
	 "%",,	[ASCIZ\TXT\]		;;CHAR AND TEXT BODY
	 Z	RTN			;;ADDITIONAL ROUTINE
	 Z	ADR			;;ADDITIONAL ADDRESS
	 Z	DIE]			;;RESUME ADDRESS
> ;END WARN MACRO


DEFINE	INFRM(PFX,TXT,RTN<0>,ADR<0>,DIE<.+1>),<
I..'PFX:!PUSHJ	P,[PUSHJ P,ERRMSG	;;CALL ERROR MESSAGE PROCESSOR
	 SIXBIT	\   PFX\		;;PREFIX
	 "[",,	[ASCIZ\TXT\]		;;CHAR AND TEXT BODY
	 Z	RTN			;;ADDITIONAL ROUTINE
	 Z	ADR			;;ADDITIONAL ADDRESS
	 Z	DIE]			;;RESUME ADDRESS
> ;END INFRM MACRO
	SUBTTL	Macro definitions - STOPCD and WARNCD

;TEMP MACRO(S)

DEFINE	STOPCD(TXT,RTN,ADR,DIE),<
	IF2,	<IFNDEF .SPOPJ,<EXTERN .SPOPJ>>
	IFB	<TXT>,<
		IFB	<DIE>,<	HALT	.SPOPJ>
		IFNB	<DIE>,<	POP	P,.JBBLT
				HALT	DIE>
		>
	IFNB	<TXT>,<
		PUSHJ	P,[OUTSTR [ASCIZ\? TXT
\]
		IFB	<DIE>,<	JRST	.SPOPJ>
		IFNB	<DIE>,<	POP	P,.JBBLT
				JRST	DIE>]
		>
> ;END STOPCD MACRO DEFINITION

DEFINE	WARNCD(TXT,RTN,ADR,DIE),<
	PUSHJ	P,[SKIPLE S.MOAN##	;;WANT WARNINGS?
		OUTSTR [ASCIZ\% TXT
\]
	IFB	<DIE>,<POPJ	P,]>	;;RETURN TO INLINE CODE
	IFNB	<DIE>,<
		POP	P,.JBBLT	;;ADJUST STACK (REMEMBER DISPATCH)
		JRST	DIE]>		;;CONTINUE ELSEWHERE
> ;END WARNCD MACRO DEFINITION
	PRGEND
	TITLE	NFT %2(16) NIP/FAL/TSC TOP-LEVEL EXECUTIVE
	SUBTTL	Robert Houk/RDH

	SEARCH	JOBDAT,	MACTEN,	UUOSYM	;STANDARD DEFINITIONS
	SEARCH	NFTDEF			;NFT-RELATED DEFINITIONS
	SEARCH	SWIL			;SWIL DEFINITIONS

IFN FT$NIP,<.REQUI NIP>			;NIP COMMAND PROCESSOR
IFN FT$FAL,<.REQUI FAL>			;FAL COMMAND PROCESSOR
IFN FT$TSC,<.REQUI TSC>			;TSC COMMAND PROCESSOR

	.REQUE	REL:SWIL		;SWIL PACKAGE

	SALL				;PRETTY LISTINGS
	.DIREC	FLBLST			;PRETTIER LISTINGS

	TWOSEG	456000			;NICE PURE CODE


COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984,1987,1988. ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO


	COMMENT	\

NFT  --  "NIP/FAL/TSC Top-level Executive" for TOPS-10


COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984,1987,1988. ALL RIGHTS RESERVED.


THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED ONLY
IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH THE INCLUSION OF THE
ABOVE NOTICE. THIS SOFTWARE OR ANY OTHER COPIES THEROF MAY NOT BE PROVIDED
OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON. NO TITLE TO AND OWNERSHIP
OF THIS SOFTWARE IS HEREBY TRANSFERRED.

THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE AND
SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.

DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

\
	SUBTTL	Version and Revision history

;Version

MAJVER==2		;MAJOR VERSION LEVEL
MINVER==1		;MAINTENANCE LEVEL
CSTVER==0		;CUSTOMER VERSION
EDTVER==21		;EDIT LEVEL

	LOC	.JBVER
	<%%NFT==:<BYTE (3)CSTVER(9)MAJVER(6)MINVER(18)EDTVER>>
	RELOC


;The edit history

;1	RDH	19-Jan-83
;	First field test tape (with 7.02 monitor).

;2	RDH	26-May-83
;	Second field test tape (with 7.02 monitor).

;3	RDH	28-Sep-83
;	Third field test tape (with 7.02 monitor).

;4	RDH	1-Oct-83
;	Fourth field test tape (with 7.02 monitor)

;5	RDH	12-Jan-84
;	First release.

;NFT %1(5) released with 7.02, Spring '84.

;6	RDH	8-Mar-84
;	Fix FAL to talk with RSTS systems; fix FAL for RSTS/RSX/VAX
;	non-wildcarded directory.
;	Modules: FAL

;7	RDH	31-Mar-84
;	Fix NFT to talk with RT11 systems.
;	Modules: NIP; requires SWIL edit 1001

;10	RDH	31-Mar-84
;	Fix NFT to report correct file size on (e.g.,) DELETE commands.
;	Modules: none; requires SWIL edit 1002

;11	RDH	16-Jul-84
;	Problems with VAX version 4 (first VMS/DAP protocol version 7):
;	NIP - Don't ask for 3-part name messages unless supported;
;	FAL - Send ACK after each file in DIRECTORY LIST processing;
;	Modules: FAL; requires SWIL edit 1004

;12	RDH	29-Nov-84
;	A zero-length USERS.TXT file causes FAL to die with PC out of bounds.
;	Modules: FAL

;NFT %1A(12)

;13	RDH	30-Apr-85
;	Version 2. Split FAL to separate stand-alone componet (under GALAXY
;	control). Add "SET DEFAULT" and "SET NAME" commands.

;14	RDH	12-May-85
;	NIP gets I/O error on ASCII file which ends with <CR><EOF> (The
;	error code in M0 gets trashed by COACS9).
;	Modules: NIP
;
;15	LEO	16-Aug-85
;	Do copyrights
;
;16	RDH	30-Oct-85
;	Fix [15]
;
;17	RDH	4-Jan-85	SPR 10-35424
;	Can't transfer Line Sequence Numbers over a network link.
;	Modules: NIP, FAL, requires SWIL %13(1041) or later
;
;20	RDH	23-Jan-86
;	Extra null byte appended to records read and then written in
;	non-record mode (e.g., from -11/VMS to straight 8-bit-bytes).
;	Modules: NIP
;
;21	TL	4-Dec-86
;	Fix embedded carriage control in implied carriage control records, 
;	when the embedded control occurs before some data characters.
;	Modules: SWIL %13(1047)
	SUBTTL	Definitions

;FIRST AND FOREMOST, THE STACK

ND	PDLEN,400		;ONE KLUNKIN' STACK


;"HARDWIRED" I/O CHANNELS

	TTY==1			;COMMAND TERMINAL I/O CHANNEL


;OTHER I/O-RELATED PARAMETERS

ND	TTIBFN,1		;NUMBER OF COMMAND TERMINAL INPUT BUFFERS
ND	TTIBSZ,30		;SIZE (DATA) OF COMMAND TERMINAL INPUT BUFFER
ND	TTOBFN,1		;NUMBER OF COMMAND TERMINAL OUTPUT BUFFERS
ND	TTOBSZ,30		;SIZE (DATA) OF COMMAND TERMINAL OUTPUT BUFFER
	SUBTTL	Initialization

NFT::	TDZA	P,P		;REGULAR ENTRY POINT
	MOVEI	P,1		;CCL ENTRY (OFFSET OF 1)
	MOVEM	P,CCLFLG	;SET IT FOR .ISCAN
	MOVE	P,[IOWD PDLEN,PDLST] ;SETUP STACK
	RESET			;"STOP THE WORLD" - FAILSA
	SETZM	BZMEM		;CLEAR START OF TO-BE-CLEARED AREA
	MOVE	T1,[BZMEM,,BZMEM+1]  ;BLT POINTER TO
	BLT	T1,EZMEM-1	;CLEAR ALL OF TO-BE-CLEARED AREA
	SETOM	SCNXXX		;INITIALIZE SCAN INTERLOCK

;SAVE SOME INTERESTING JOB DATA LOCATIONS

	MOVE	T1,.JBFF	;COPY OF ORIGINAL .JBFF
	MOVEM	T1,SAVFF	;SAVE IT
	MOVEM	T1,ORGFF	;SAVE THE PERMANENT COPY
	MOVE	T1,.JBCOR	;COPY OF ORIGINAL .JBCOR
	MOVEM	T1,SAVCOR	;SAVE IT
	MOVE	T1,.JBREL	;COPY OF ORIGINAL .JBREL
	MOVEM	T1,SAVREL	;SAVE IT

;SETUP COMMAND TERMINAL I/O

	PUSHJ	P,TTINI		;INITIALIZE COMMAND TERMINAL I/O
	 HALT	.-1		;THIS IS NOT ACCEPTABLE

;INITIALIZE VIS-A-VIS SCAN

IFE FT$NIP,<PRINTX ? FT$NIP must be turned on (non-zero)!!!>

	MOVE	T1,[ISLEN,,ISBLK] ;.ISCAN BLOCK
	PUSHJ	P,.ISCAN##	;INITIALIZE SCAN
	PUSHJ	P,NIP00##	;START UP NIP COMMAND MODE
	 HALT	.		;DUH?
	JRST	MAIN		;GO START THINGS ROLLING



;ISCAN PARAMETER BLOCK

ISBLK:	EXP	FXVRSN		;PROTOCOL VERSION WORD
	IOWD	NIPLEN##,NIPNAM##  ;IOWD OF LEGAL (NIP) MONITOR COMMANDS
	CCLFLG,,'NIP'		;ADR OF STARTING OFFSET,,CCL NAME
	XWD	TTINC,	TTOUC	;CHAR INPUT RTN,,CHAR OUTPUT RTN
	Z			;INDIRECT FILE BLOCK POINTER (XWD)
	XWD	NFTPR,	NFTEX	;PROMPT RTN,,MONRET RTN
	FS.ICK			;FLAGS,,<FUTURE>
	Z	NFTER		;ERROR ROUTINE

	ISLEN==.-ISBLK
	SUBTTL	Main command control loop

MAINER:	MOVE	T1,CMDFF	;COMMAND-LEVEL .JBFF
	SKIPN	IGNRFF		;HAS SOMEONE PREEMPTED IT?
	MOVEM	T1,.JBFF	;NO, FORCIBLY SYNCHRONIZE .JBFF
	SKIPA	P,SAVPDP	;RESTORE STACK
MAIN:	MOVEM	P,SAVPDP	;SAVE "P" FOR ERROR RESTART
	MOVE	CX,CMDBAS	;[RE]SET COMMAND BASE TABLE
	PUSHJ	P,.TNEWL##	;MAKE SURE AT LEFT MARGIN

;READ IN AND PROCESS ONE USER COMMAND

MAIN10:	PUSHJ	P,DOIT		;GO DO SOMETHING
	 JFCL			;ERROR SOMEWHERE
	SKIPE	IGNRFF		;WANT TO IGNORE .JBFF?
	JRST	MAIN30		;YES, ASSUME SOMEONE KNOWS WHAT HE IS DOING
	MOVE	P1,.JBFF	;GET TOP-LEVEL .JBFF
	SUB	P1,SAVFF	;COMPARE AGAINST START-UP VALUE
	JUMPE	P1,MAIN30	;IF 0 THEN HAVEN'T SCREWED UP YET
	ERROR	TFF,<Top-level .JBFF off by >,.TDECW##,P1,.+1
	MOVE	P1,SAVFF	;ORIGINAL .JBFF
	MOVEM	P1,.JBFF	;RESET TO WHAT WE THINK IT SHOULD BE

;END OF COMMAND CLEANUP

MAIN30:	JRST	MAIN		;TRY FOR ANOTHER COMMAND
;HERE TO REALLY DO ANYTHING

DOIT:	MOVE	T1,[XWD SCNPL,SCNPS]  ;ARG BLOCK
	PUSHJ	P,.TSKRK##	;LET THE TINY SHEEP RUN RAMPANT
	 POPJ	P,		;OH WELL, TRY AGAIN
	MOVEM	CH,CMDCH	;SAVE TERMINATING CHARACTER
	MOVEM	NM,CMDNM	;AND NAME TOO
	JUMPN	NM,DOIT03	;GO PROCESS COMMAND IF ANYTHING THERE
	CAIN	CH,"?"		;NOTHING EVEN RESEMBLING A COMMAND, MAYBE A "?"
	JRST	NQCM		;YEAH, GO SLOBBER ALL OVER HIM
	JUMPLE	CH,.POPJ1##	;NOTHING ELSE ON LINE, IGNORE IT
	JRST	DOITE2		;NULL COMMAND WITH JUNK AFTER, ILLEGAL

;WE HAVE A COMMAND INPUT, SEE WHAT FOLLOWS IMMEDIATELY AFTER
; THIS IS DELIBERATLY HIGHLY RESTRICTIVE IN ORDER TO CATCH CASES
; SUCH AS "NUL:=XXX", AN ERROR EASILY CAUSED WITH THE COMMAND SYNTAX
; DIFFERENCES BETWEEN NFT AND PIP . . .

DOIT03:	CAIE	CH," "		;IF A BLANK
	CAIN	CH,.CHTAB	; (OR A BLANK IN DRAG)
	JRST	DOIT10		;THEN LEGAL SYNTAX
	CAIE	CH,"/"		;OR IF START OF A SWITCH
	CAIN	CH,""""		; OR START OF A QUOTED NAME
	JRST	DOIT10		;THEN LEGAL SYNTAX
	CAIN	CH,"@"		;IF COMMAND FILE
	JRST	DOIT10		;THEN LEGAL SYNTAX
	JUMPLE	CH,DOIT10	;END OF LINE IS LEGAL SYNTAX
	JRST	DOITE3		;ILLEGAL SYNTAX
;VALID COMMAND SYNTAX, INTERPRET COMMAND

DOIT10:	PUSHJ	P,.TINBC##	;INSURE ON NON-BLANK CHARACTER
	SETCM	T1,$CMLEN(CX)	;CONCOCT
	MOVS	T1,T1		; IOWD
	ADD	T1,$CMNAM(CX)	;  POINTER TO COMMAND NAMES TABLE
	MOVE	T2,NM		;AND COMMAND NAME SUPPLIED BY USER
	PUSHJ	P,.LKNAM##	;TRY TO RECOGNIZE THE COMMAND
	 JRST	DOITE4		;UNKNOWN OR AMBIGUOUS COMMAND
	SUB	T1,$CMNAM(CX)	;MAKE T1 INTO AN INDEX
DOIT20:	ANDI	T1,-1		;WANT JUST THE INDEX PART
	MOVEM	T1,CMDNX	;AND SAVE THE INDEX
	SETOM	CMDCH		;VALID COMMAND, TELL TOP LEVEL
	MOVE	P2,.JBFF	;CURRENT VALUE OF .JBFF
	SKIPN	IGNRFF		;UNLESS TOLD TO IGNORE .JBFF,
	MOVEM	P2,CMDFF	;SAVE PRIOR TO SPECIFIC COMMAND DISPATCH
	MOVE	P2,.JBREL	;CURRENT VALUE OF .JBREL
	SKIPN	IGNRFF		;UNLESS TOLD TO IGNORE .JBFF,
	MOVEM	P2,CMDREL	;SAVE PRIOR TO SPECIFIC COMMAND DISPATCH
	PUSHJ	P,.TINBC##	;ENSURE ON NON-BLANK TERMINATOR
	PUSHJ	P,@$CMDSP(CX)	;DISPATCH TO COMMAND PROCESSOR
	 TDZA	P1,P1		;FLAG FAILURE
	SETO	P1,		;FLAG SUCCESS
	SKIPE	IGNRFF		;NEED TO CHECK .JBFF?
	JRST	DOIT30		;LEAVE IT ALONE!
	MOVE	P2,.JBFF	;GET CURRENT .JBFF
	SUB	P2,CMDFF	;CONTRAST WITH OLD COPY
	JUMPE	P2,DOIT30	;OK IF BACK TO WHERE WE STARTED
	SKIPE	.JBDDT		;LET DEBUGGING USER KNOW
	INFRM	CFF,<Command left .JBFF off by >,.TDECW##,P2,.+1
	MOVE	P2,CMDFF	;FETCH OLD .JBFF
	MOVEM	P2,.JBFF	;AND SET .JBFF TO WHERE IT SHOULD BE
	SKIPE	P1,.JBDDT	;SUCCESS IF NOT DEBUGGING
	SETO	P1,		;FLAG FAILURE
DOIT30:	CAIL	P1,0		;SUCCESS OR FAILURE
	AOS	(P)		;SUCCESS
	POPJ	P,		;RETURN FROM COMMAND
;COMMAND ERRORS

;ERROR - NO COMMAND BUT SOMETHING ON THE LINE

DOITE2:	ERROR	CSI,<Command syntax illegal ">,DOITF2



;ERROR - ILLEGAL COMMAND TERMINATOR

DOITE3:	ERROR	ICT,<Illegal command terminator [syntax] ">,DOITF1



;ERROR - UNKNOWN OR AMBIGUOUS COMMAND

DOITE4:	CAIL	T1,0		;UNKNOWN OR AMBIGUOUS?
	ERROR	AMC,<Ambiguous command ">,DOITF4
	MOVE	T1,[IOWD DOITEL,DOITET]  ;OUR "ALWAYS" COMMANDS
	MOVE	T2,NM		;THE COMMAND NAME
	PUSHJ	P,.LKNAM##	;SEE IF THE COMMAND LOOKS RECOGNIZABLE
	 ERROR	UKC,<Unknown command ">,DOITF4
	SUBI	T1,DOITET	;GET INDEX OF NEW-FOUND COMMAND
	PUSHJ	P,@DOITEX(T1)	;DISPATCH TO COMMAND
	 JFCL			;SHOULDN'T HAPPEN
	JRST	.POPJ1##	;SUCCESSFUL COMPLETION OF COMMAND


DOITET:	'DDT   '
	'EXIT  '
	'HELP  '

	DOITEL==.-DOITET


DOITEX:	IFIW	NDDT
	IFIW	NEXI
	IFIW	NHEL
;COMMAND ERROR AUXILIARY ROUTINES

DOITF1:	MOVE	T1,CMDNM	;THE COMMAND NAME AS TYPED BY USER
	PUSHJ	P,.TSIXN##	;TYPE IT BACK AT HIM/HER

DOITF2:	SKIPLE	T1,CMDCH	;COMMAND TERMINATOR CHARACTER
	JRST	DOITF3		;TYPE IT OUT
	MOVEI	T1,[ASCIZ\<EOL>\]  ;END OF LINE, INDICATE
	PUSHJ	P,.TSTRG##	;TYPE OUT "CHARACTER"
	JRST	DOITF5		;CAP OFF QUOTED COMMAND
DOITF3:	PUSHJ	P,.TFCHR##	;TYPE OUT TERMINATING CHARACTER
	JRST	DOITF5		;AND CAP OFF QUOTED COMMAND

DOITF4:	MOVE	T1,CMDNM	;THE COMMAND NAME AS TYPED BY USER
	PUSHJ	P,.TSIXN##	;TYPE IT BACK AT HIM OR HER

DOITF5:	PUSHJ	P,.TDQTE##	;CAP OFF THE QUOTED COMMAND

DOITF6:	MOVEI	T1,[ASCIZ\ - type "?" or "HELP" for help\]
	PJRST	.TSTRG##	;END ERROR MESSAGE
	SUBTTL	DDT command

NDDT:	SKIPN	.JBBPT		;IS DDT LOADED
	WARN	DNL,<DDT is not loaded>,,,.POPJ1##
	SKIPG	DDTCNT		;BEEN HERE BEFORE?
	INFRM	DDT,<Entering DDT - type $P to return . . . >
	AOS	DDTCNT		;DON'T TYPE MESSAGE ON SUBSEQUENT DDT COMMANDS
	JSR	@.JBBPT		;CALL DDT
NFTDDT::JRST	.POPJ1##	;SUCCESSFUL RETURN FROM COMMAND
	SUBTTL	EXIT command

NEXI:	PUSHJ	P,.CLEOL##	;EAT REST OF COMMAND
	PUSHJ	P,.RUNXT##	;FAKE OUT A "/EXIT" SWITCH
	JRST	.POPJ1##	;AND LET SCAN TAKE CARE OF IT
	SUBTTL	HELP command(s)

;"HELP" command

NHEL:	PUSHJ	P,.CLEOL##	;EAT REST OF LINE (IF ANY)
	MOVE	T1,$CMPFX(CX)	;"PREFIX" IN SIXBIT
	CAMN	T1,['NIP   ']	;HO
	MOVSI	T1,'NFT'	; HUM
	PUSHJ	P,.HELPR##	;TYPE OUT THE .HLP FILE
	JRST	.POPJ1##	;THAT IS THE END OF THE "HELP" COMMAND



;"?" command - list the available commands

NQCM:	PUSHJ	P,.CLEOL##	;EAT REST OF LINE (IF ANY)

;LIST THE COMMANDS

NQCM2::	MOVEI	T1,NQCMT1	;"COMMANDS ARE" MESSAGE
	PUSHJ	P,.TSTRG##	;PREFIX THE COMMANDS LISTING

;LOOP TYPING THE COMMANDS AND COMMAND TEXTS

	SETCM	P1,$CMLEN(CX)	;CONCOCT
	MOVS	P1,P1		; AOBJN
	ADD	P1,$CMNAM(CX)	;  POINTER TO COMMANDS NAMES
	MOVE	P2,$CMBLB(CX)	;AND PARALLEL BLAB TABLE
NQCM22:	MOVE	T1,1(P1)	;GET COMMAND NAME
	PUSHJ	P,.TSIXN##	;TYPE OUT THE COMMAND NAME
	PUSHJ	P,.TTABC##	;SEPARATE WITH A TAB
	MOVE	T1,(P2)		;GET COMMAND TEXTUAL BLURB
	PUSHJ	P,.TSTRG##	;AND TYPE IT OUT TOO
	PUSHJ	P,.TCRLF##	;CAP OFF THE LINE
	ADDI	P2,1		;ADVANCE BLAB TABLE, AND
	AOBJN	P1,NQCM22	;LOOP FOR ALL KNOWN COMMANDS

;ALSO OUR "HIDDEN" COMMANDS

	MOVEI	T1,NQCMT2	;OTHER TEXT
	PUSHJ	P,.TSTRG##	;TO TYPE OUT

;ALL DONE WITH COMMANDS SUMMARY

	PUSHJ	P,.TCRLF##	;CAP OFF THE COMMANDS SUMMARY
	JRST	.POPJ1##	;RETURN FOR NEXT COMMAND
NQCMT1:	ASCIZ\
Commands are:

\

NQCMT2:	ASCIZ\
DDT	Call DDT if it is loaded
EXIT	Terminate program execution, return to monitor level
HELP	Provide helpful information
^Z	Same as "EXIT" command
\
	SUBTTL	File wildcard selection

;.NXTFI  --  OPEN NEXT [WILDCARDED] INPUT FILE
;.NXTFC  --  OPEN NEXT [WILDCARDED] INPUT FILE, HANDLING CONCATENATION
;CALL IS:
;
;	PUSHJ	P,.NXTFI/.NXTFC
;	 error return
;	normal return
;
;.NXTFI is used to generate the next input file to be read from the
;input file expression list; .NXTFC is used as an adjunct to .NXTFI
;to handle concatenated input files (going into only one output file).

.NXTFI::AOSN	NXTFCX		;PREVIOUS CALL TO .NXTFC WIN A $EFIXN?
	JRST	[MOVEI	M0,$EFIXN	;YES, PROPAGATE THE EXCEPTION
		POPJ	P,]		;BUT ONLY ONCE!
	TDZA	T2,T2		;FLAG PRIMARY INPUT OPEN OPERATION
.NXTFC::SETO	T2,		;FLAG "CONCATENATED" INPUT OPEN OPERATION
	PUSHJ	P,TSAV14##	;SAVE THE FLAG
	JUMPE	T2,NXTFI3	;GO IF PRIMARY OPEN
	MOVEI	T1,CDBLI	;*** ADDRESS OF INPUT CDB
	PUSHJ	P,.IOCLO##	;CLOSE THE CURRENT INPUT FILE
	 JFCL			;WHAT??? OH WELL, SO IT GOES
	PUSH	P,CDBLI+.IOIOM	;SAVE I/O MODE CONTROL WORD
	MOVX	T3,IM.DQI	;.IOPIN'S DISABLE .IOQAT FLAG
	ANDCAM	T3,CDBLI+.IOIOM	;TEMPORARILY CLEAR FOR CONCATENATED OPERATION
	MOVX	T3,IM.IQC	;THE "CONCATENATION" OPERATION FLAG
	IORM	T3,CDBLI+.IOIOM	;TEMPORARILY SET FOR .NXTFC CALL
	PUSHJ	P,NXTFI3	;GET ANOTHER INPUT FILE
	 JRST	[POP	P,CDBLI+.IOIOM	;RESTORE CALLER'S I/O MODE CONTROL
		CAIN	M0,$EFIXN	;INPUT FILE STREAM EXHAUSTED?
		SETOM	NXTFCX		;YES, SET FLAG FOR NEXT .NXTFI CALL
		POPJ	P,]		;PROPAGATE ERROR/EXCEPTION RETURN
	POP	P,CDBLI+.IOIOM	;RESTORE CALLER'S I/O MODE CONTROL FLAGS
	JRST	.POPJ1##	;RETURN AS APPOPRIATE

NXTFI3:	MOVEI	T1,CDBLI	;*** ADDRESS OF INPUT CDB (POINTING TO FILE SPECS)
	MOVE	T2,-T2(P)	;SET PRIMARY/SECONDARY OPEN
	PUSHJ	P,.IOPIN##	;SELECT INPUT FILE
	 JRST	NXTFIE		;ERROR
	JRST	.POPJ1##	;SKIP RETURN
NXTFIE:	CAIN	M0,$EFIXN	;INPUT STREAM EXHAUSTED?
	POPJ	P,		;YES.
	CAIN	M0,$EFIXE	;INPUT STREAM EXHAUSTED (REDUNDANTLY)?
	ERROR	IXE,<Internal error "IXE" at NXTFIE>
	POPJ	P,		;PROPAGATE FILE ACCESS ERROR TO CALLER


;FERPIN  --  TYPE OUT .IOPIN ERROR MESSAGE
;
;NON-SKIP TO ABORT, SKIP TO CONTINUE WITH NEXT FILE

FERPIN::MOVEI	T1,CDBLI	;*** ADDRESS OF INPUT CDB
	PUSHJ	P,.ERPIN##	;ISSUE ERROR MESSAGE
	PJRST	ONERCK		;WANT TO ABORT ON ERROR?
.NXTFO::MOVEI	T1,CDBLO	;*** ADDRESS OF OUTPUT CDB
	MOVEI	T2,CDBLI	;*** ADDRESS OF INPUT SPEC
	PUSHJ	P,.IOPOU##	;SELECT OUTPUT FILE
	 JRST	NXTFOE		;ERROR
	JRST	.POPJ1##	;ALL SET

NXTFOE:	POPJ	P,		;PROPAGATE ERROR BACK TO CALLER TO CLEAN UP


;FERPOU  --  TYPE OUT .IOPOU ERROR
;
;NON-SKIP TO ABORT, SKIP TO CONTINUE ONWARDS

FERPOU::MOVEI	T1,CDBLO	;*** ADDRESS OF OUTPUT CDB
	PUSHJ	P,.ERPOU##	;ISSUE ERROR MESSAGE
	PJRST	ONERCK		;WANT TO ABORT ON ERROR?



CLRTOT::SETZM	BZTOT		;CLEAR START OF TOTALS AREA
	MOVE	T1,[BZTOT,,BZTOT+1]  ;BLT POINTER TO
	BLT	T1,EZTOT-1	;CLEAR OUT THE TOTALS
	POPJ	P,		;THE TOTALS HAVE BEEN RESET



ONERCK::SKIPLE	S.OKER		;/OKERROR?
	 AOS	(P)		;YES, TRY TO DO MORE
	POPJ	P,		;NO, ABORT
	SUBTTL	User interface - "ASK" routines

.ASKNY::PUSHJ	P,.SAVE4##	;SAVE THE P'S AGAINST SCAN'S TI???
	MOVEI	P1,0		;THIS IS A NO/YES
	JRST	ASKXX		;ASK USER

.ASKYN::PUSHJ	P,.SAVE4##	;SAVE THE P'S AGAINST SCAN'S TI???
	MOVEI	P1,1		;THIS IS A YES/NO

ASKXX:	MOVE	T1,[[ASCIZ\[N/Y]: \]  ;DEFAULT IS NO
		    [ASCIZ\[Y/N]: \]](P1)  ;DEFAULT IS YES
ASKXX0:	PUSHJ	P,.TSTRG##	;SEND OUT PROMPT
	PUSHJ	P,.CLRTI##	;INITIALIZE FOR INPUT LINE
	PUSHJ	P,.SIXSW##	;READ IN USER'S RESPONSE
	SKIPE	T2,NM		;PLACE ANSWER FOR .LKNAM
	JRST	ASKXX6		;AND SEE IF ANSWER IS INTELLIGIBLE
	JUMPLE	CH,ASKXX8	;IF EOL, THEN TAKE DEFAULT EXIT

;USER TYPED JUNK, EAT IT ALL AND TRY AGAIN

ASKXX2:	PUSHJ	P,.CLEOL##	;CLEAR TO END OF LINE
	PUSHJ	P,.TNEWL##	;MAKE SURE AT START OF LINE
	MOVE	T1,[[ASCIZ\% Please type either "NO" or "YES": \]
		    [ASCIZ\% Please type either "YES" or "NO": \]](P1)
	JRST	ASKXX0		;AND TRY AGAIN

;USER TYPED SOMETHING, SEE WHAT IT IS

ASKXX6:	MOVE	T1,[IOWD 2,NYTAB]  ;THE YES/NO TABLE
	PUSHJ	P,.LKNAM##	;SEE IF USER'S RESPONSE MAKES ANY SENSE
	 JRST	ASKXX2		;NOTHING I UNDERSTAND
	SUBI	T1,NYTAB	;GET OFFSET
	MOVE	P1,T1		;SAVE SKIPNESS
ASKXX8:	PUSHJ	P,.CLEOL##	;EAT TO END OF LINE IF NEED BE
	PUSHJ	P,.TNEWL##	;MAKE SURE AT A NICE PLACE
	ADDM	P1,(P)		;ADJUST RETURN AS NEEDED
	POPJ	P,		;RETURN TO CALLER

NYTAB:	'NO    '
	'YES   '
	SUBTTL	User interface - USERID prompting

;.DFLND - HANDLE NODE-SPECIFIC DEFAULTING FOR USERID/ETC
;CALL IS:
;
;	MOVX	T1,<CDB>
;	PUSHJ	P,.DFLND
;	 ERROR RETURN
;	NORMAL RETURN
;
;Where <CDB> is the address of the I/O CDB preparatory to a network
;connect initialization.

.DFLND::PUSHJ	P,.SACIO##	;SETUP I/O CONTEXT
	PUSHJ	P,.SAVE4##	;PROTECT THE P'S
	SKIPE	P1,.IOFSC(IO)	;GET ADDRESS OF FILE SPEC BLOCK
	SKIPN	T1,.FXUID(P1)	;AND /USERID USERID STRING/ARGUMENT
	JRST	.POPJ1##	;NONE, JUST IGNORE
	HLRZ	T2,.IONUS(IO)	;LENGTH OF USERID STRING
	JUMPE	T2,DFLND2	;IF BLANK, NEED TO PROMPT
;RDH	HLRZ	T2,.IONAC(IO)	;LENGTH OF USERID ACCOUNT STRING
;RDH	JUMPE	T2,DFLND2	;IF BLANK, NEED TO PROMPT
	HLRZ	T2,.IONPW(IO)	;LENGTH OF USERID PASSWORD STRING
	JUMPN	T2,.POPJ1##	;IF NON-BLANK, NOTHING FURTHER TO DO

;NEED TO PROMPT FOR SOMETHING

DFLND2:	PUSHJ	P,NFTYIO	;FORCE COMMAND TERMINAL I/O
	MOVEI	T1,[ASCIZ\For remote \]  ;A PROMPT STRING
	PUSHJ	P,.TSTRG##	;TO IDENTIFY WHICH SPEC/NODE
	MOVE	T1,.IOFSC(IO)	;ADDRESS OF FILE SPEC BLOCK
	PUSHJ	P,.TFBLK##	;TYPE OUT FILE SPEC
	PUSHJ	P,.TCRLF##	;CAP OFF WITH A <CR><LF>

;HANDLE USERID STRING

DFLND3:	MOVEI	T1,[ASCIZ\ User-id: \]  ;A PROMPT STRING
	XMOVEI	T4,.IONUS(IO)	;ADDRESS OF USERID STRING
	PUSHJ	P,DFLNE		;LIST OR ACCEPT AS NEEDED
	 POPJ	P,		;???

;HANDLE USERID ACCOUNT STRING

DFLND4:	MOVEI	T1,[ASCIZ\ Account: \]  ;A PROMPT STRING
	XMOVEI	T4,.IONAC(IO)	;ADDRESS OF ACCOUNT STRING
	PUSHJ	P,DFLNE		;LIST OR ACCEPT AS NEEDED
	 POPJ	P,		;???

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;HANDLE USERID PASSWORD STRING

DFLND5:	PUSHJ	P,TTNEC		;NO-ECHO!!
	MOVEI	T1,[ASCIZ\ Password:\]  ;A PROMPT STRING
	XMOVEI	T4,.IONPW(IO)	;ADDRESS OF PASSWORD
	PUSHJ	P,DFLNE		;ACCEPT AS NEEDED
	 PJRST	TTECH		;ERROR, RESTORE ECHO
	PUSHJ	P,TTECH		;SUCCESS, RESTORE ECHO
	JRST	.POPJ1##	;PROPAGATE SUCCESS RETURN
;DFLNE - HELPER TO DFLND

DFLNE:	PUSHJ	P,.TSTRG##	;LIST PROMPT STRING
	HLRZ	T3,0(T4)	;LENGTH OF CURRENT STRING (IF ANY)
	JUMPE	T3,DFLNE3	;NEED TO ASK FOR NEW STRING
	SKIPE	TTYNEC		;IS THIS A NOT-TO-BE-LISTED STRING?
	JRST	DFLNE9		;YES, PUNT IT THEN.

;LIST EXTANT STRING

	HRLI	T4,(POINT 8,,31);MAKE INTO BYTE POINTER TO EXTANT STRING
DFLNE1:	ILDB	T1,T4		;NEXT STRING BYTE
	PUSHJ	P,.TFCHR##	;LIST IT OUT (HANDLING "FUNNY" CHARACTERS)
	SOJG	T3,DFLNE1	;LOOP FOR REST OF STRING
	JRST	DFLNE9		;CAP OFF WITH <CR><LF>

;ACCEPT NEW STRING FROM USER

DFLNE3:	PUSH	P,T4		;SAVE STRING BLOCK ADDRESS
	HRLI	T4,(POINT 8,,31);MAKE INTO BYTE POINTER TO NEW STRING
	MOVSI	T3,-^D39	;AND BYTE COUNTER
	PUSHJ	P,.CLRTI##	;PRESET FOR LINE OF INPUT
	JRST	DFLNE6		;ENTER STRING INPUT LOOP

DFLNE4:	AOBJP	T3,DFLNE6	;PITCH CHARACTER IF TOO MANY
	IDPB	CH,T4		;STASH ONE MORE CHARACTER
DFLNE6:	PUSHJ	P,.TIGET##	;NEXT 7-BIT COMMAND CHARACTER
	CAIN	CH,.CHCRT	;IF <CR>,
	JRST	DFLNE6		;JUST EAT IT UP
	CAIL	CH,.CHLFD	;ELSE, IF EOL
	CAILE	CH,.CHFFD	; (I.E., <LF>, <VT>, OR <FF>)
	JRST	DFLNE4		;NOT EOL, STASH IT AWAY
	POP	P,T4		;RESTORE STRING BLOCK ADDRESS
	CAILE	T3,^D39		;MAX CHARACTERS ALLOWED
	MOVEI	T3,^D39		;MAX CHARACTERS ALLOWED
	HRLM	T3,0(T4)	;SET ACTUAL BYTE COUNT OF FRESH STRING
	SKIPE	TTYNEC		;WAS THE <EOL> ECHOED?
DFLNE9:	PUSHJ	P,.TCRLF##	;NO, ISSUE <CR><LF> FOR NEATNESS
	JRST	.POPJ1##	;SUCCESS RETURN



REPEAT	0,<			;***

.SWUAC::
.SWUPA::SKIPN	UIDCNT#		;BEEN HERE BEFORE?
	JFCL			;***
	OUTSTR	[ASCIZ\The /UACCOUNT and /UPASSWORD switches are obsolete and
should not be used. Please use /USERID:userid:account:password.
For more details, please read the help file NFT.HLP.
\]
	AOS	UIDCNT		;BEEN HERE NOW
	PJRST	.SWASQ##	;HO HUM

> ;*** END REPEAT 0
	SUBTTL	Totals summary

;TOTALS  --  PRINT A SUMMARY OF FILES/ETC.
;CALL IS:
;
;	MOVX	T3,<<LGL>,,<NML>>
;	PUSHJ	P,TOTALS
;	 ERROR
;	NORMAL
;
;WHERE <LGL> IS THE MASK OF LEGAL TOTALS VALUES; AND <NML> IS THE NORMAL
;MASK OF VALUES TO OUTPUT.
;
;THE ERROR RETURN IS NOT USED.
;
;ON NORMAL RETURN A TOTALS SUMMARY HAS BEEN OUTPUT.

.TOTAL::PUSHJ	P,.SAVE1##	;WANT A PRESERVED AC
	HLRZ	P1,T1		;POSITION MASK OF LEGAL VALUES
	HLRZ	T3,S.TOTA	;USER-SUPPLIED VALUES MASK (IF ANY)
	HRRZ	T2,S.TOTA	;USER-REQUESTED TOTALS (IF ANY)
	AND	T2,P1		;IGNORE NON-APPLICABLE USER-REQUESTED TOTALS
	ANDCM	T1,T3		;MAKE ROOM FOR USER-REQUESTED TOTALS
	IOR	T1,T2		;OVERRIDE DEFAULTS WITH USER-REQUESTED ACTION
	AND	P1,T1		;P1:=TOTALS TO BE ISSUED
	JUMPE	P1,.POPJ1##	;DO NOTHING IF NO TOTALS REQUESTED
	SKIPN	FILES		;/TOTALS:SOMETHING, ANY FILES
	SKIPE	ERRORS		;OR ANY ERRORS?
	CAIA			;YES, SOMETHING HAPPENED
	JRST	.POPJ1		;NO, DUD COMMAND LINE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;SOME SORT OF TOTALS ARE DEEMED APPROPRIATE

TOTAL0:	MOVEI	T1,[ASCIZ\Total of\]  ;START UP THE MESSAGE
	PUSHJ	P,.TSTRG##	;OUTPUT IT
	SKIPN	FILES		;DID ANY FILES GET THROUGH?
	JRST	TOTALE		;NO, JUST CHECK FOR ERRORS

;CHECK FOR BITS SUMMARY

TOTAL1:	TXNN	P1,TT$BIT	;WANT BITS?
	JRST	TOTAL2		;NO
	MOVE	T1,BITS		;GET COUNT OF DATA BITS
	MOVEI	T2,[ASCIZ\bit\]	;IDENTIFY COUNT
	PUSHJ	P,TOTALR	;ISSUE TOTAL BIT(S)

;CHECK FOR BYTES SUMMARY

TOTAL2:	TXNN	P1,TT$BYT	;WANT BYTES?
	JRST	TOTAL3		;NO
	MOVE	T1,BYTES	;GET COUNT OF DATA BYTES
	MOVEI	T2,[ASCIZ\byte\];IDENTIFY COUNT
	PUSHJ	P,TOTALR	;ISSUE TOTAL BYTE(S)

;CHECK FOR WORDS SUMMARY

TOTAL3:	TXNN	P1,TT$WRD	;WANT WORDS
	JRST	TOTAL4		;NO
	MOVE	T1,WORDS	;GET COUNT OF WORDS
	MOVEI	T2,[ASCIZ\word\];IDENTIFY COUNT
	PUSHJ	P,TOTALR	;ISSUE TOTAL WORD(S)

;CHECK FOR RECORDS SUMMARY

TOTAL4:;TXNN	P1,TT$REC	;WANT RECORDS?
;	JRST	TOTAL5		;NO
;	MOVE	T1,RECORD	;GET COUNT OF RECORDS
;	MOVEI	T2,[ASCIZ\record\]  ;IDENTIFY QUANTITY
;	PUSHJ	P,TOTALR	;ISSUE TOTAL RECORD(S)

;CHECK FOR BLOCKS SUMMARY

TOTAL5:	TXNN	P1,TT$BLK	;WANT BLOCKS?
	JRST	TOTAL6		;NO
	MOVE	T1,BLOCKS	;GET BLOCK COUNT
	MOVEI	T2,[ASCIZ\block\]  ;IDENTIFY NUMBER
	PUSHJ	P,TOTALR	;ISSUE TOTAL BLOCK(S)

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;CHECK FOR PAGES SUMMARY

TOTAL6:;TXNN	P1,TT$PAG	;WANT PAGES?
;	JRST	TOTAL7		;NO
;	MOVE	T1,PAGES	;GET COUNT OF PAGES
;	MOVEI	T2,[ASCIZ\page\];IDENTIFY PAGE COUNT
;	PUSHJ	P,TOTALR	;ISSUE TOTAL PAGE(S)

;CHECK FOR FILES SUMMARY

TOTAL7:	TXNN	P1,TT$BIT!TT$BYT!TT$WRD!TT$BLK  ;IF ANYTHING PREFIXED
	TXNE	P1,TT$FIL	;(NO BITS, BYTES, ETC.) WANT FILES?
	CAIA			;ISSUE FILES
	JRST	TOTAL8		;NO FILES SUMMARY
	MOVE	T1,FILES	;COUNT OF FILES
	MOVEI	T2,[ASCIZ\file\];IDENTIFY NUMBER AS FILES
	PUSHJ	P,TOTALV	;ISSUE TOTAL FILE(S)

;CHECK FOR BAUD RATE SUMMARY

TOTAL8:	TXNN	P1,TT$BAU	;WANT BAUD RATE?
	JRST	TOTAL9		;NO
	MOVEI	T1,[ASCIZ\ at \];TEXT
	PUSHJ	P,.TSTRG##	;TELL USER
	MOVE	T1,BITS		;GET BITS TRANSFERRED
	MULI	T1,^D1000	;READY FOR BAUD RATE
	DIV	T1,MSECS	;T1 := BITS PER SECOND
	PUSHJ	P,.TDECW##	;TYPE OUT BITS PER SECOND
	MOVEI	T1,[ASCIZ\ baud\]  ;AND IDENTIFY AS SUCH
	PUSHJ	P,.TSTRG##	;TO THE USER

;CHECK FOR ERRORS SUMMARY

TOTAL9:	TXNE	P1,TT$ERR	;WANT ERRORS?
	SKIPN	ERRORS		;YES, WERE THERE ANY ERRORS?
	JRST	TOTALZ		;NO
	MOVEI	T1,[ASCIZ\ and\]  ;YES
	PUSHJ	P,.TSTRG##	;SO TELL USER THAT TOO
TOTALE:	TXNE	P1,TT$ERR	;WANT ERRORS?
	SKIPN	ERRORS		;YES, WERE THERE ANY ERRORS
	JRST	TOTALZ		;NO
	MOVE	T1,ERRORS	;COUNT OF ERRORS
	MOVEI	T2,[ASCIZ\error\]  ;IDENTIFY ERRORS
	PUSHJ	P,TOTALV	;ISSUE TOTAL ERROR(S)
TOTALZ:	PUSHJ	P,.TCRLF##	;CAP OFF TOTALS WITH A <CR><LF>
	JRST	.POPJ1		;GO FOR MORE COMMANDS
;HELPER TO .TOTAL

TOTALR:	PUSHJ	P,TOTALV	;ISSUE COUNT AND IDENTIFY IT
	MOVEI	T1,[ASCIZ\ in\]	;PREPARE FOR ANOTHER LEVEL
	PJRST	.TSTRG##	;PREFIX AND RETURN FOR NEXT TOTAL

TOTALV:	PUSH	P,T1		;SAVE COUNT VALUE
	PUSH	P,T2		;AND IDENTIFICATION STRING
	PUSHJ	P,.TSPAC##	;ISSUE LEADING SPACE
	MOVE	T1,-1(P)	;RETRIEVE DECIMAL COUNT
	PUSHJ	P,.TDECW##	;ISSUE COUNT
	PUSHJ	P,.TSPAC##	;SEPARATE WITH A PRETTY SPACE
	POP	P,T1		;ADDRESS OF NAME STRING
	PUSHJ	P,.TSTRG##	;ISSUE NAME STRING TOO
	MOVEI	T1,"s"		;IN CASE OTHER THAN SINGULAR
	SOSE	0(P)		;EXACTLY ONE WHATEVER
	PUSHJ	P,.TCHAR##	;NO, NEEDS A [NON-SINGULAR] "S" APPENDED
	POP	P,T1		;ADJUST STACK
	POPJ	P,		;RETURN READY FOR MORE
	SUBTTL	Common error messages

ERRCDI::ERROR	CDI,<Can't initialize input CDB>

ERRCDO::ERROR	CDO,<Can't initialize output CDB>

ERRNIF::ERROR	NIF,<No input file specified>

ERRNOF::ERROR	NOF,<No output file specified>

ERROFI::ERROR	OFI,<Output file illegal>
	SUBTTL	Error processor

;ALL ABORT/ERROR/WARN/INFRM CALLS COME HERE TO BE HANDLED

ERRMSG::PUSHJ	P,.PSH4T##	;SAVE T1-T4 FOR MOMENT
	MOVE	T4,-4(P)	;CALLER PC
	MOVE	T1,CMDBAS	;GET CURRENT COMMAND BASE TABLE
	HLLZ	T1,$CMPFX(T1)	;GET SIXBIT "PROGRAM" PREFIX/PROMPT
	HRR	T1,0(T4)	;ADD IN SPECIFIC ERROR CODE
	MOVE	T2,1(T4)	;CHAR AND TEXT
	MOVE	T3,-5(P)	;AND THE ERROR PC
	PUSHJ	P,.ERMSA##	;TYPE ERROR STUFF
	MOVE	T4,-4(P)	;ARG BLOCK PC AGAIN
	SKIPE	T2,2(T4)	;DID USER REQUEST A ROUTINE?
	TXNN	T1,JWW.FL	;AND IS FIRST SET?
	JRST	ERRMS4		;NO, DON'T EVEN BOTHER
	SKIPE	T1,3(T4)	;DID USER GIVE AN ADDRESS?
	MOVE	T1,@T1		;YES, LOAD UP T1
	PUSHJ	P,@T2		;CALL USER SPECIAL ROUTINE
ERRMS4:	MOVE	T4,-4(P)	;GET ARG BLOCK PC YET AGAIN
	HLRZ	T1,1(T4)	;GET ERROR CHARACTER
	CAIN	T1,"["		;INFORMATIONAL?
	PUSHJ	P,.TRBRK##	;YES, CAP IT OFF
	PUSHJ	P,.TCRLF##	;END THE LINE OF TEXT
	MOVEI	T1,@4(T4)	;GET RESUME ADDRESS
	MOVEM	T1,-5(P)	;FAKE OUT THE POPJ P,
	PUSHJ	P,.POP4T##	;RESTORE THE T REGS
	POP	P,(P)		;DISCARD JUNK PC
	POPJ	P,		;AND "RESUME" PROCESSING


ERRDIE::EXIT			;AND THAT IS THAT!
	SUBTTL	Command terminal I/O routines

REPEAT	0,<

;The command terminal cannot be used as an I/O device because it may
;also be used as real I/O (e.g., the TYPE command) device, which totally
;rapes the command channel. It is not worth trying to interlock/intercept
;command and file I/O to make it all work. Therefore, fall back on
;the ole tried and true TTCALLs . . .

;TTINI - OPEN AND INITIALIZE THE TERMINAL I/O CHANNEL

TTINI:	MOVX	T1,.IOASL	;DULL AND BORING ASCII LINE MODE
	MOVSI	T2,'TTY'	;DULL AND BORING TERMINAL DEVICE
	MOVE	T3,[TTOBFH,,TTIBFH]  ;EXCITING AND GLAMOROUS BUFFER RINGS
	OPEN	TTY,T1		;OPEN DEVICE TTY:
	  JRST	TTINE1		;OPEN FAILURE? OFF TO A BAD START!
	MOVEM	T1,TTYSTS	;SAVE INITIAL I/O STATUS
	MOVEI	T1,TTY		;TTY I/O CHANNEL
	DEVTYP	T1,		;GET DEVICE TYPE INFORMATION
	  JRST	TTINE2		;CAN'T FAIL
	LDB	T2,[POINTR T1,TY.DEV]  ;GET DEVICE CODE
	CAIE	T2,.TYTTY	;IS TTY: A TRUE TERMINAL?
	  JRST	TTINE3		;NO, BARF ON USER
	MOVEI	T1,TTY		;TTY I/O CHANNEL AGAIN
	IONDX.	T1,		;GET OFFICIAL TTY UDX
	  JRST	TTINE4		;CAN'T FAIL
	MOVEM	T1,TTYUDX	;SAVE FOR ASSORTED AND SUNDRY TRMOP.S

;NOW SET UP INPUT BUFFER RING STRUCTURE

	MOVE	T2,[TTIBFN,,TTIBSZ]  ;TERMINAL INPUT BUFARG
	MOVEI	T3,TTIBF1	;FIRST INPUT BUFFER
	MOVEI	T4,TTIBFH	;TERMINAL INPUT BUFFER RING HEADER
	PUSHJ	P,.IOBFI##	;INITIALIZE INPUT BUFFER RING
	 JRST	TTINE7		;CAN'T HAPPEN

;NOW SET UP OUTPUT BUFFER RING STRUCTURE

	MOVE	T2,[TTOBFN,,TTOBSZ]  ;TERMINAL OUTPUT BUFARG
	MOVEI	T3,TTOBF1	;FIRST OUTPUT BUFFER
	MOVEI	T4,TTOBFH	;TERMINAL OUTPUT BUFFER RING HEADER
	PUSHJ	P,.IOBFI##	;INITIALIZE OUTPUT BUFFER RING
	 JRST	TTINE7		;CAN'T HAPPEN

	JRST	.POPJ1##	;COMMAND TERMINAL I/O READY AND RARING
;TTINI ERRORS

TTINE1:	OUTSTR	[ASCIZ\? Can't OPEN device TTY:\]
	JRST	TTINEX		;COMMON ERROR EXIT

TTINE2:	OUTSTR	[ASCIZ\? DEVTYP failure for TTY channel\]
	JRST	TTINEX		;COMMON ERROR EXIT

TTINE3:	OUTSTR	[ASCIZ\? Device TTY: is not a real terminal\]
	JRST	TTINEX		;COMMON ERROR EXIT

TTINE4:	OUTSTR	[ASCIZ\? IONDX. failure for TTY channel\]
	JRST	TTINEX		;COMMON ERROR EXIT

TTINE7:	OUTSTR	[ASCIZ\? .IOBFI failure initializing TTY buffer ring\]
	JRST	TTINEX		;COMMON ERROR EXIT

TTINEX:	OUTSTR	[ASCIZ\
\]				;BLANK LINE BEFORE THE "."
	EXIT	1,		;RETURN TO MONITOR LEVEL
	JRST	TTINI		;USER .CONTINUED, SO TRY AGAIN
;HERE TO HANDLE COMMAND TERMINAL INPUT
;CALLED BY SCAN, RETURNS CHARACTER IN "CH" (AKA P4)

TTINC::	SKIPE	TTYOFL		;TERMINAL OUTPUT FLAG SET?
	PUSHJ	P,TTOUU		;YES, FLUSH OUTPUT FIRST
TTINC1:	SOSGE	TTIBFH+.BFCTR	;GOT ANY CHARACTERS IN INPUT BUFFER?
	JRST	TTINC3		;NO, GO ASK FOR MORE
	ILDB	CH,TTIBFH+.BFPTR;GET NEXT BUFFERED INPUT CHARACTER
	JUMPN	CH,.POPJ##	;RETURN WITH NON-NULL CHARACTER IN CH
	JRST	TTINC1		;BUT EAT STUPID NULLS

TTINC3:	PUSHJ	P,TTINU		;ASK FOR ANOTHER BUFFER
	JRST	TTINC1		;PROCESS NEW INPUT BUFFER


TTINU:	MOVX	CH,.IOASL	;ASCII LINE MODE
	SKIPE	TTYNEC		;NO-ECHO REQUESTED?
	TXO	CH,IO.SUP	;YES
	CAME	CH,TTYSTS	;TTY I/O STATUS SET PROPERLY?
	SETSTS	TTY,(CH)	;NO, SWITCH TO NEW NEEDS
	MOVEM	CH,TTYSTS	;SAVE CURRENT TTY STATUS
TTINU2:	IN	TTY,		;ASK MONITOR FOR ANOTHER BUFFER
	POPJ	P,		;STUPID BASS-ACKWARDS UUO
TTINU3:	GETSTS	TTY,CH		;ERROR??? GET TTY I/O STATUS
	TXNN	TTY,IO.EOF	;END-OF-FILE SET?
	JRST	TTINU5		;NO, REAL ERROR?
	CLOSE	TTY,		;CLEAR EOF THE HARD WAY
	JRST	TTINU2		;AND TRY AGAIN

TTINU5:	OUTSTR	[ASCIZ\? Command terminal INput error
\]
	EXIT	1,		;BAD NEWS
	JRST	TTINU2		;TRY AGAIN (??)
;COMMAND TERMINAL OUTPUT
;CALLED BY SCAN WITH CHARACTER IN T1

TTOUC::	SOSGE	TTOBFH+.BFCTR	;ROOM IN OUTPUT BUFFER FOR ANOTHER CHAR?
	JRST	TTOUC3		;NO
	IDPB	T1,TTOBFH+.BFPTR;STASH OUTPUT CHARACTER
	AOS	TTYOFL		;FLAG OUTPUT PENDING
	CAIL	T1,.CHLFD	;IF NOT A VFE
	CAILE	T1,.CHFFD	;(I.E., <LF>, <VT>, OR <FF>)
	POPJ	P,		;THEN JUST RETURN
	PJRST	TTOUU		;ELSE FORCE OUT ONE FULL LINE OF TEXT

TTOUC3:	PUSHJ	P,TTOUU		;OUTPUT CURRENT BUFFER
	JRST	TTOUC		;LOOP BACK


;HERE TO FORCE OUT TTY OUTPUT

TTOUU:	PUSHJ	P,TSAV14##	;SAVE THE T'S
TTOUU2:	OUT	TTY,		;GIVE CURRENT OUTPUT TO MONITOR
	CAIA			;STUPID BASS-ACKWARDS UUO
	 JRST	TTOUU3		;ERROR
	SETZM	TTYOFL		;CLEAR OUTPUT PENDING FLAG
	POPJ	P,		;RETURN WITH FRESH OUTPUT BUFFER

TTOUU3:	GETSTS	TTY,T1		;GET TTY I/O STATUS
	TXNN	T1,IO.EOF	;END-OF-FILE SET?
	JRST	TTOUU5		;NO, REAL ERROR?
	CLOSE	TTY,		;CLEAR EOF THE HARD WAY
	JRST	TTOUU2		;TRY AGAIN

TTOUU5:	OUTSTR	[ASCIZ\? Command terminal OUTput error
\]
	EXIT	1,		;BAD NEWS
	JRST	TTOUU2		;TRY AGAIN (??)

> ;END REPEAT 0
;INITIALIZE FOR COMMAND TERMINAL I/O

TTINI:	SETO	T1,		;-1 = US
	GETLCH	T1		;READ CURRENT COMMAND TERMINAL "STATUS"
	MOVEM	T1,TTYSTS	;SET CURRENT STATUS
	HRRZM	T1,TTYUDX	;SET UDX FOR TRMOP.'S
	PUSHJ	P,TTOUUI	;INITIALIZE OUTPUT STUFF
	JRST	.POPJ1##	;TTCALLS SURE ARE SIMPLE . . .



;TTINC - INPUT COMMAND TERMINAL CHARACTER

TTINC::	SKIPE	TTYOFL		;GOT OUTPUT PENDING?
	PUSHJ	P,TTOUU		;YES, FLUSH IT OUT
REPEAT	0,<
	MOVE	CH,TTYSTS	;CURRENT TTY STATUS
	SKIPE	TTYNEC		;WANT NO-ECHO?
	TXOA	CH,GL.NEC	;YES
	TXZ	CH,GL.NEC	;NO
	CAME	CH,TTYSTS	;ANYTHING CHANGING?
	SETLCH	CH		;YES, FORCE TERMINAL TO NEW MODE
	MOVEM	CH,TTYSTS	;SET NEW STATUS
> ;END REPEAT 0
	INCHWL	CH		;INPUT ONE COMMAND CHARACTER
	JUMPN	CH,.POPJ##	;RETURN NON-NULL
	JRST	.-2		;THIS REALLY SHOULDN'T HAPPEN



;TTNEC - SET COMMAND TERMINAL TO NO-ECHO COMMAND INPUT

TTNEC::	SETOB	T1,TTYNEC	;FLAG US (T1) AND NO-ECHO IN EFFECT (TTYNEC)
	GETLCH	T1		;GET CURRENT TTY STATE
	TXO	T1,GL.NEC	;ASSERT NOECHO REQUEST
	SETLCH	T1		;TELL THE MONITOR TO NOT ECHO INPUT
	POPJ	P,		;RETURN SETUP FOR NO-ECHO



;TTECH - SET COMMAND TERMINAL TO ECHO COMMAND INPUT

TTECH::	SETO	T1,		;FLAG US
	GETLCH	T1		;GET CURRENT TTY STATE
	TXZ	T1,GL.NEC	;ASSERT ECHO REQUEST
	SETLCH	T1		;TELL THE MONITOR TO ECHO INPUT
	SETZM	TTYNEC		;FLAG ECHO IN EFFECT
	OUTCHR	TTECHX		;NUDGE SCNSER SO IT WILL NOTICE
				; (AND NO, A SKPIN? DOESN'T SUFFICE)
TTECHX:	POPJ	P,000		;RETURN SETUP FOR ECHO
;TTOUC - COMMAND TERMINAL OUTPUT

TTOUC::	SOSGE	TTOBFH+.BFCTR	;ROOM?
	JRST	TTOUC3		;NO
	IDPB	T1,TTOBFH+.BFPTR;STASH OUTPUT CHARACTER
	AOS	TTYOFL		;FLAG OUTPUT PENDING
	CAIL	T1,.CHLFD	;IF NOT A VFE
	CAILE	T1,.CHFFD	;(I.E., <LF>, <VT>, <FF>)
	POPJ	P,		;THEN JUST RETURN
	PJRST	TTOUU		;OTHERWISE FORCE OUT ONE FULL LINE OF TEXT

TTOUC3:	PUSHJ	P,TTOUU		;OUTPUT CURRENT BUFFER
	JRST	TTOUC		;NOW STASH THE CHARACTER

TTOUU:	PUSHJ	P,TSAV14##	;PROTECT THE ACS
	SETZ	T1,		;A NULL
	IDPB	T1,TTOBFH+.BFPTR;ASCIZIZE THE STRING
	OUTSTR	TTOBF1		;OUTPUT THE STRING
	SETZM	TTYOFL		;CLEAR OUTPUT PENDING FLAG
TTOUUI:	MOVEI	T1,TTOBSZ*5	;PROTOTYPE BYTE COUNTER
	MOVEM	T1,TTOBFH+.BFCTR;INITIALIZE STRING COUNTER
	MOVE	T1,[POINT 7,TTOBF1]  ;PROTOTYPE BYTE POINTER
	MOVEM	T1,TTOBFH+.BFPTR;INITIALIZE STRING STUFFER
	POPJ	P,		;RETURN
;NFTYIO - FORCE COMMAND TERMINAL "PREEMPTIVE" I/O
;
;CALLED AS A CO-ROUTINE (LIKE .SAVE4), WILL CALL CALLER IN NEW COMMAND
;CONTEXT, WILL RESTORE COMMAND CONTEXT ON CALLER'S RETURN.

NFTYIO:	XMOVEI	T1,TTINC	;COMMAND TERMINAL INPUT ROUTINE
	PUSHJ	P,.TYPRE##	;FORCE PREEMPTIVE INPUT
	PUSH	P,T1		;SAVE PREVIOUS CONTEXT
	XMOVEI	T1,TTOUC	;COMMAND TERMINAL OUTPUT ROUTINE
	PUSHJ	P,.TYOCH##	;FORCE COMMAND TERMINAL OUTPUT
	PUSH	P,T1		;SAVE PREVIOUS CONTEXT
	PUSHJ	P,@-2(P)	;CO-ROUTINE BACK TO CALLER
	 SOS	-3(P)		;NON-SKIP RETURN
	POP	P,T1		;PREVIOUS OUTPUT CONTEXT
	PUSHJ	P,.TYOCH##	;RESTORE IT
	POP	P,T1		;PREVIOUS INPUT CONTEXT
	PUSHJ	P,.TYPRE##	;RESTORE IT (SHOULD BE 0!)
	POP	P,T1		;JUNK ADDRESS
	JRST	.POPJ1##	;PROPAGATE RETURN
;NFTPR  --  COMMAND PROMPTING

NFTPR:	PUSH	P,T1		;SAVE FIRST/CONTINUATION
	MOVE	T1,$CMPRM(CX)	;GET ADDRESS OF PROMPT STRING
	MOVE	M0,[ASCII/NIP/]	;!$*#$! AN INTERESTING RANDOM STRING
	CAMN	M0,0(T1)	;!$*#$! GONNA PROMPT WITH "NIP"?
	JRST	[POP	P,T1		;!$*#$! YEAH, SO DON'T
		PJUMPGE	T1,.TASTR##	;!$*#$! MAIN COMMAND PROMPT
		PJRST	.THASH##]	;!$*#$! CONTINUATION PROMPT
	PUSHJ	P,.TSTRG##	;ISSUE PROMPT STRING
	POP	P,T1		;RESTORE FIRST/CONTINUATION FLAG
	PJUMPGE	T1,.TRANG##	;CAP OFF MAIN COMMAND PROMT
	PJRST	.THASH##	;CAP OFF CONTINUATION PROMPT



;NFTEX  --  PROGRAM EXIT

NFTEX:	SKIPE	NFTXRT		;SOMEONE WANT CONTROL OF "EXIT"
	PJRST	@NFTXRT		;YES, DISPATCH TO "EXIT" PROCESSOR
	PJRST	.MNRET##	;NO, GO BYE BYE



;NFTER  --  SCAN SYNTAX ERROR

NFTER:	SKIPE	NFTERT		;SOMEONE WANT CONTROL OF "ERROR"
	PJRST	@NFTERT		;YES, OFF TO CALLER INTERCEPT
	PJRST	MAINER		;NO, THEN ERROR RECOVER AT "MAIN"
	SUBTTL	SCAN-called subroutines

;ALLOCATE FILE-SPEC AREAS (SCAN BLOCKS)

OUX::	MOVEI	T1,.FXMAX	;LENGTH OF SCAN BLOCK
	PUSHJ	P,.MMGWD##	;ALLOCATE SOME MEMORY
	 JRST	E..COR		;NO CORE AVAILABLE
	MOVE	T1,T2		;SCAN WANTS ADDRESS IN T1
	MOVEI	T2,.FXMAX	;AND LENGTH IN T2
	SKIPE	SOFIR		;IS THIS THE FIRST OUTPUT SPEC?
	ERROR	MOE,<Multiple output specs illegal>
	MOVEM	T1,SOFIR	;SET FIRST OUTPUT FILE SPEC
	MOVEM	T1,SOLAS	;AND THE LAST TOO (ON G.P.'S)
	PJRST	IOX		;COPY OVER PRIVATE SWITCHES



INX::	MOVEI	T1,.FXMAX	;LENGTH OF A SCAN BLOCK
	PUSHJ	P,.MMGWD##	;ALLOCATE SOME MANAGED MEMORY
	 ERROR	COR,<No "free core" available>
	MOVE	T1,T2		;SCAN WANTS START ADDRESS IN T1
	SKIPN	SIFIR		;IS THIS THE VERY FIRST SCAN BLOCK?
	MOVEM	T1,SIFIR	;YES - REMEMBER IT
	MOVEM	T1,SILAS	;ALSO REMEMBER LAST SCAN BLOCK
;	PJRST	IOX		;COPY OVER PRIVATE SWITCHES

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;CHECK OUT TEXT STRINGS (ENTER WITH SCAN BLOCK ADDRESS IN T1)

IOX::	PUSHJ	P,.SAVE1##	;NEED A PROTECTED-ACROSS-ERROR AC
	SETZM	.FXBZM(T1)	;START OF TO-BE-ZERO'ED AREA
	HRLZI	P1,.FXBZM(T1)	;CONCOCT A
	HRRI	P1,.FXBZM+1(T1)	; BLT POINTER TO
	BLT	P1,.FXEZM-1(T1)	;  INITIALIZE TO-BE-ZERO'ED AREA
	SETOM	.FXBOM(T1)	;START OF TO-BE-ONE'ED AREA
	HRLZI	P1,.FXBOM(T1)	;CONCOCT A
	HRRI	P1,.FXBOM+1(T1)	; BLT POINTER TO
	BLT	P1,.FXEOM-1(T1)	;  INITIALIZE TO-BE-ONE'ED AREA
	SETZ	P1,		;INITIALIZE TABLE INDEX
IOX3:	SKIPN	T2,IOXSTB(P1)	;NEXT STORAGE BLOCK
	JRST	IOX5		;ALL DONE
	LDB	T2,[POINT 8,$ASCMX-1(T2),35]  ;LAST ASCII BYTE, LSN BIT
	CAIE	T2,0		;TERMINATED?
	XCT	IOXTTB(P1)	;NO, ISSUE WARNING AND TRUNCATE IT
IOX4:	AOJA	P1,IOX3		;LOOP FOR ALL STRINGS

;COPY OVER PRIVATE SCAN BLOCK STUFF AND RETURN

IOX5:	MOVEI	T2,.FX$B(T1)	;START OF CUSTOM ANSWERS WITHIN SCAN BLOCK
	HRLI	T2,BBFIL	;AND OUR BUILDING AREA
	BLT	T2,.FX$E-1(T1)	;COPY LOCAL SWITCHES INTO SCAN BLOCK
				; NOTE THAT SCAN CAREFULLY LEAVES ANYTHING
				; IN EXCESS OF .FXLEN ALONE
	MOVEI	T2,.FXMAX	;SET TOTAL LENGTH IN T2
	POPJ	P,		;GIVE STUFF TO SCAN


IOXSTB:	Z	S.PASS		;/PASSWORD
	Z	S.USER		;/USERID
;***	Z	S.UACC		;/UACCOUNT
;***	Z	S.UPAS		;/UPASSWORD
	Z			;END OF TABLE

IOXTTB:	WARN	PWT,</PASSWORD>,IOXES,,IOX4
	WARN	UIT,</USERID>,IOXES,,IOX4
;***	WARN	UAT,</UACCOUNT>,IOXES,,IOX4
;***	WARN	UPT,</UPASSWORD>,IOXES,,IOX4

IOXES:	MOVE	T2,IOXSTB(P1)	;ADDRESS OF OFFENDING STRING
	SETZ	T1,		;A NULL BYTE
	DPB	T1,[POINT 8,$ASCMX-1(T2),35]  ;FORCIBLY TERMINATE THE STRING
	MOVEI	T1,[ASCIZ\ string "\]
	PUSHJ	P,.TSTRG##	;TYPE OUT STRING PREFIX
	MOVE	T1,IOXSTB(P1)	;ADDRESS OF OFFENDING STRING
	PUSHJ	P,.TSTRG##	;TYPE OUT THE OFFENDING (TRUNCATED) STRING
	MOVEI	T1,[ASCIZ\" too long; truncated\]
	PJRST	.TSTRG##	;CAP OFF WARNING MESSAGE
;FRESB - FREE UP THE SCAN BLOCKS

FRESB::	PUSHJ	P,.SAVE1##	;WANT A PROTECTED AC
	SKIPN	P1,SILAS	;GET LAST INPUT FILE SPEC BLOCK ALLOCATED
	JRST	FRESB5		;NONE, CHECK FOR OUTPUT
	SKIPE	SOLAS		;ANY OUTPUT SPECS TOO?
	CAML	P1,SOLAS	;IN WHICH ORDER WERE THEY ALLOCATED?
	JRST	FRESB2		;INPUT LAST
	JRST	FRESB5		;OUTPUT LAST

;DEALLOCATE "INPUT" FILE SPEC BLOCKS

FRESB2:	MOVEI	T1,.FXMAX	;LENGTH OF FILE SPEC BLOCK
	MOVE	T2,P1		;ADDRESS OF FILE SPEC BLOCK
	PUSHJ	P,.MMFWD##	;FREE UP THIS SCAN BLOCK
	 ERROR	SDE,<SCAN block deallocation failed>,,,.+1
	SUBI	P1,.FXMAX	;BACK UP ONE SCAN BLOCK
	CAML	P1,SIFIR	;FREED UP ALL INPUT SPECS YET?
	JRST	FRESB2		;NO, FREE UP THE REST
	SETZM	SIFIR		;NO MORE INPUT SPECS
	SETZM	SILAS		; . . .

;DEALLOCATE "OUTPUT" FILE SPEC BLOCKS

FRESB5:	SKIPN	P1,SOLAS	;GET LAST OUTPUT FILE SPEC BLOCK ALLOCATED
	JRST	FRESB9		;ALL DONE
FRESB7:	MOVEI	T1,.FXMAX	;LENGTH OF THE SCAN BLOCK
	MOVE	T2,P1		;ADDRESS OF THE FILE SPEC BLOCK
	PUSHJ	P,.MMFWD##	;FREE UP THIS SCAN BLOCK
	 ERROR	OSD,<Output SCAN block deallocation failed>,,,.+1
	SUBI	P1,.FXMAX	;BACK UP ONE SCAN BLOCK
	CAML	P1,SOFIR	;FREED UP ALL OUTPUT SPECS YET?
	JRST	FRESB7		;NO, FREE UP THE REST
	SETZM	SOFIR		;NO MORE OUTPUT SPECS
	SETZM	SOLAS		; . . .

FRESB9:	SKIPE	SIFIR		;INPUT BLOCKS PENDING (ALLOCATED BACKWARDS)?
	JRST	FRESB		;YES, LOOP AND TRY DEALLOCATING AGAIN
	JRST	.POPJ1##	;SUCCESSFUL (BY DEFINITION)
;CLRALL  --  CLEAR ALL  --  CALLED AT COMMAND START-UP

CLRALL::SETZM	BZALL		;CLEAR START OF TO-BE-CLEARED AREA
	MOVE	T1,[BZALL,,BZALL+1]  ;BLT POINTER TO
	BLT	T1,EZALL-1	;CLEAR ALL OF TO-BE-CLEARED AREA
	SETOM	BOALL		;CLEAR START OF TO-BE-CLEARED AREA
	MOVE	T1,[BOALL,,BOALL+1]  ;BLT POINTER TO
	BLT	T1,EOALL-1	;CLEAR ALL OF TO-BE-CLEARED AREA
	POPJ	P,		;READY FOR A COMMAND LINE



;CLRFIL  --  CLEAR FILE  --  CALLED BEFORE EACH FILE SPECIFICATION

CLRFIL::SETZM	BZFIL		;CLEAR START OF TO-BE-CLEARED AREA
	MOVE	T1,[BZFIL,,BZFIL+1]  ;BLT POINTER TO
	BLT	T1,EZFIL-1	;CLEAR ALL OF TO-BE-CLEARED AREA
	SETOM	BOFIL		;CLEAR START OF TO-BE-CLEARED AREA
	MOVE	T1,[BOFIL,,BOFIL+1]  ;BLT POINTER TO
	BLT	T1,EOFIL-1	;CLEAR ALL OF TO-BE-CLEARED AREA
	POPJ	P,		;READY FOR ANOTHER FILE



;CLRSTK  --  CLEAR STICKY DEFAULTS  --  CALLED BEFORE MEMORIZING STICKY STUFF

CLRSTK::SETZM	BZSTK		;CLEAR START OF TO-BE-CLEARED AREA
	MOVE	T1,[BZSTK,,BZSTK+1]  ;BLT POINTER TO
	BLT	T1,EZSTK-1	;CLEAR ALL OF TO-BE-CLEARED AREA
	SETOM	BOSTK		;CLEAR START OF TO-BE-CLEARED AREA
	MOVE	T1,[BOSTK,,BOSTK+1]  ;BLT POINTER TO
	BLT	T1,EOSTK-1	;CLEAR ALL OF TO-BE-CLEARED AREA
	POPJ	P,		;READY FOR NEW STICKY DEFAULTS
;MEMSTK  --  MEMORIZE STICKY DEFAULTS  --  CALLED TO REMEMBER DEFAULTS

MEMSTK::SETZB	T1,T2		;INITIALIZE INDICES
MEMST1:	MOVN	T3,BZSTB(T1)	;LENGTH OF NEXT "ZEROED ANSWER"
	JUMPE	T3,MEMST5	;0 IS END OF ZEROED ANSWERS
	HRL	T2,T3		;MAKE AOBJN POINTER
	SKIPE	BZFIL(T2)	;ANYTHING THERE TO MEMORIZE?
	JRST	MEMST3		;YES
	AOBJN	T2,.		;NO, JUST SKIP THIS ANSWER
	AOJA	T1,MEMST1	;AND CHECK THE NEXT ONE

MEMST3:	MOVE	T3,BZFIL(T2)	;NEXT WORD OF ZEROED ANSWER
	MOVEM	T3,BZSTK(T2)	;MEMORIZE IT
	AOBJN	T2,MEMST3	;LOOP FOR WHOLE ANSWER
	AOJA	T1,MEMST1	;LOOP FOR ALL ANSWERS

MEMST5:	MOVSI	T1,-LOFIL	;MAKE AOBJN POINTER
MEMST6:	MOVE	T3,BOFIL(T1)	;GET "FILE ANSWER"
	CAME	T3,[-1]		;VALUE SPECIFIED HERE YET?
	MOVEM	T3,BOSTK(T1)	;YES, MEMORIZE IT
	AOBJN	T1,MEMST6	;LOOP FOR ALL "FILE ANSWERS"
	POPJ	P,		;READY TO APPLY STICKY DEFAULTS



;APLSTK  --  APPLY STICKY DEFAULTS  --  CALLED AFTER EACH FILE SPEC SEEN

APLSTK::SETZB	T1,T2		;INITIALIZE INDICES
APLST1:	MOVN	T3,BZSTB(T1)	;LENGTH OF NEXT ANSWER
	JUMPE	T3,APLST5	;0 IS ALL DONE
	HRL	T2,T3		;MAKE AOBJN POINTER
	SKIPN	BZFIL(T2)	;HAVE A VALUE YET?
	JRST	APLST3		;NO, USE STICKY ONE THEN
	AOBJN	T2,.		;YES, JUST SKIP THIS ONE
	AOJA	T1,APLST1	;AND CHECK OUT THE NEXT CANDIDATE

APLST3:	MOVE	T3,BZSTK(T2)	;NEXT WORD OF FILE ANSWER
	MOVEM	T3,BZFIL(T2)	;STUFF INTO FILE-SPECIFIC AREA
	AOBJN	T2,APLST3	;LOOP FOR ENTIRE ANSWER
	AOJA	T1,APLST1	;LOOP FOR ALL ANSWERS

APLST5:	MOVSI	T1,-LOFIL	;MAKE AOBJN POINTER
	SETO	T2,		;"VALUE ABSENT" VALUE
APLST6:	MOVE	T3,BOSTK(T1)	;STICKY DEFAULT VALUE
	CAMN	T2,BOFIL(T1)	;HAVE WE SEEN AN EXPLICIT VALUE YET?
	MOVEM	T3,BOFIL(T1)	;NO, USE STICKY VALUE
	AOBJN	T1,APLST6	;LOOP FOR ALL "FILE ANSWERS"
	POPJ	P,		;BACK TO SCAN
;DOOSDF  --  DO SWITCH.INI DEFAULTING

DOOSDF::PUSHJ	P,.SAVE1##	;SAVE AN AC
	MOVE	P1,T1		;PRESERVE FILE SPEC ADDRESS

;HANDLE STANDARD SWITCHES (E.G., /BEFORE)

	PUSHJ	P,.OSDFS##	;HANDLE STANDARD SWITCHES

;HANDLE NIP CUSTOM SWITCHES (E.G., /USERID)

	SETZB	T1,T2		;INITIALIZE INDICES
	MOVEI	T4,.FX$BZ(P1)	;AND WHERE TO STORE THESE ANSWERS
	HRLI	T4,T2		; (INDEXED OFF OF T2)
DOOSD1:	MOVN	T3,BZSTB(T1)	;LENGTH OF NEXT ONE
	JUMPE	T3,DOOSD5	;0 IS ALL DONE
	HRL	T2,T3		;MAKE AOBJN POINTER
	SKIPN	@T4		;THIS FILE SPEC HAVE THIS SWITCH VALUE?
	JRST	DOOSD3		;NO, APPLY THIS SWITCH
	AOBJN	T2,.		;YES, SKIP THIS SWITCH
	AOJA	T1,DOOSD1	;AND CHECK OUT THE REST

DOOSD3:	MOVE	T3,BZFIL(T2)	;NEXT WORD OF FILE SWITCH
	MOVEM	T3,@T4		;AND GIVE IT TO THE FILE SPEC
	AOBJN	T2,DOOSD3	;LOOP FOR WHOLE SWITCH
	AOJA	T1,DOOSD1	;LOOP FOR ALL SWITCHES

DOOSD5:	MOVSI	T1,-LOFIL	;AOBJN POINTER
	SETO	T2,		;"VALUE ABSENT" VALUE
	MOVEI	T4,.FX$BO(P1)	;START INDEX FOR FILE SPEC STUFF
	HRLI	T4,T1		; INDEXED OFF OF T1 THIS TIME
DOOSD6:	MOVE	T3,BOFIL(T1)	;SWITCH.INI VALUE
	CAMN	T2,@T4		;DOES FILE SPEC ALREADY HAVE SOMETHING?
	MOVEM	T3,@T4		;NO, GIVE IT SWITCH.INI VALUE
	AOBJN	T1,DOOSD6	;LOOP FOR ALL SWITCHES
	POPJ	P,		;SWITCH.INI SWITCHES APPLIED!



;TABLE OF ZERO'ED FILE ANSWER LENGTHS TO MEMSTK/APLSTK/DOOSDF.
;MUST PARALLEL BZFIL:EZFIL!!!!!

BZSTB:	EXP	2		;/DIAL
	EXP	$ASCMX		;/PASSWORD
	EXP	3*$ASCMX	;/USERID
	EXP	0		;END OF TABLE
;SCAN INTERLOCK SERVICE FOR I/O LIBRARY PACKAGE

;SCNSET  --  GET AND SET SCAN INTERLOCK

SCNSET::AOSE	SCNXXX		;GET AND SET INTERLOCK
	ERROR	SIA,<SCAN interlock already active in SCNSET>
	MOVE	T1,[SCNPL,SCNPS];PSCAN POINTER TO
	PUSHJ	P,.PSCAN##	;SETUP SCAN TO READ ARGUMENTS/FILES

;ALL FOR NOW

	JRST	.POPJ1##	;SUCCESSFUL RETURN



;SCNCLR  --  RELEASE SCAN INTERLOCK

SCNCLR::SKIPGE	SCNXXX		;SCAN INTERLOCK SET?
	ERROR	SIQ,<SCAN interlock already quiesent in SCNCLR>
	SETOM	SCNXXX		;RELEASE INTERLOCK
	JRST	.POPJ1##	;SUCCESSFUL RETURN



;SCNXXX BLOCKS FOR PSCAN

SCNPS:	EXP	FXVRSN		;PROTOCOL VERSION
	IOWD	SCNSWL,	SCNSWN	;POINTER TO SWITCH NAMES
	XWD	SCNSWD,	SCNSWM	;DEFAULT,,MAXIMA
	XWD	0,	SCNSWP	;<FUTURE>,,STORAGE POINTER
	EXP	0		;NO HELP

	SCNPL==.-SCNPS


;SCNXXX SWITCHS (ONLY "FILE-SPECIFIC" SWITCHES ARE ALLOWED)

KEYS	(TOT,<BITS,BYTES,WORDS,RECORDS,BLOCKS,PAGES,FILES,BAUD,ERRORS>)

DEFINE	SWTCHS,<

SP	DIAL,<POINT <^D65-2>,S.DIAL>,.SWPNM##,,
SP	PASSWORD,<POINT <^D65-$ASCMX>,S.PASS>,.SWASQ##,,
SP	USERID,<POINT <^D65-<3*$ASCMX>>,S.USER>,.SWUID##,,
;*** SP	UACCOUNT,<POINT <^D65-$ASCMX>,S.UACC>,.SWUAC,,
;*** SP	UPASSWORD,<POINT <^D65-$ASCMX>,S.UPAS>,.SWUPA,,

>

DOSCAN(SCNSW)
	SUBTTL	Impure data

	XLIST			;THE LITERALS GO IN THE HIGH SEG
	LIT
	LIST

	RELOC	0

	BLOCK	1		;TO AVOID THAT DAMNED "DDTEND" SYMBOL...
PDLST:	BLOCK	PDLEN		;THE STACK

CCLFLG:	BLOCK	1		;STARTING OFFSET
				;   0 = NORMAL (".RUN PROG")
				;   1 = CCL (LOOK IN TMPCOR)

DDTCNT:	BLOCK	1		;COUNT OF TIMES "DDT" COMMAND EXECUTED
				; (USED TO AVOID EXCESSIVE TYPEOUT OF DDT MSG)

SCNXXX::BLOCK	1		;SCAN INTERLOCK

DDCMDF::BLOCK	1		;KROCK FLAG FOR NIP'S DAPPISH COMMANDS


;COMMAND TERMINAL I/O STUFF

TTYSTS:	BLOCK	1		;I/O STATUS LAST SET FOR COMMAND TERMINAL
TTYNEC:	BLOCK	1		;.NE. 0 IF NOECHO REQUESTED
TTYUDX:	BLOCK	1		;I/O UDX FOR COMMAND TERMINAL
TTYOFL:	BLOCK	1		;.NE. 0 IF OUTPUT PENDING

TTIBFH:	BLOCK	3		;INPUT BUFFER RING HEADER
TTIBF1:	BLOCK	TTIBFN*<TTIBSZ+3>  ;INPUT BUFFERS

TTOBFH:	BLOCK	3		;OUTPUT BUFFER RING HEADER
TTOBF1:	BLOCK	TTOBFN*<TTOBSZ+3>  ;OUTPUT BUFFERS


;VARIOUS FILE CONTROL BLOCKS

CDBLI::	BLOCK	.IOMAX		;INPUT CHANNEL CONTROL BLOCK
CDBLO::	BLOCK	.IOMAX		;OUTPUT CHANNEL CONTROL BLOCK

	SYN	CDBLI,	I	;*** DEBUGGING
	SYN	CDBLO,	O	;*** DEBUGGING
;START OF CLEARED-ON-PROGRAM-STARTUP AREA

BZMEM::

ORGFF::	BLOCK	1		;TO HOLD MASTER (ORIGINAL) .JBFF

SAVFF::	BLOCK	1		;TO HOLD 'TOP-LEVEL' .JBFF
SAVCOR:	BLOCK	1		;TO HOLD 'TOP-LEVEL' .JBCOR
SAVREL:	BLOCK	1		;TO HOLD 'TOP-LEVEL' .JBREL
SAVPDP:	BLOCK	1		;TO HOLD MAIN STACK POINTER

IGNRFF::BLOCK	1		;.NE. 0 THEN DON'T CHECK .JBFF IN MAIN10

NFTXRT::BLOCK	1		;.NE. 0 THEN ADDRESS OF "EXIT" PROCESSOR
NFTERT::BLOCK	1		;.NE. 0 THEN ADDRESS OF SCAN ERROR INTERCEPT
NFTERP::BLOCK	1		;	STACK POINTER FOR C(NFTERT)'S USE

CMDFF::	BLOCK	1		;COPY OF .JBFF AFTER SCAN, BUT BEFORE I/O
CMDREL::BLOCK	1		;DITTO FOR .JBREL

CMDBAS::BLOCK	1		;COMMAND INDEX BASE ADDRESS

CMDCH:	BLOCK	1		;PRESERVE CH FROM DOIT DISPATCH
CMDNM:	BLOCK	1		;PRESERVE NM
CMDNX:	BLOCK	1		;INDEX INTO CMD??? TABLES FOR COMMAND IN CMDNM
;START OF CLEARED-ON-EACH-COMMAND AREA

BZALL::
BZTOT:				;START OF "TOTALS" AREA

BITS::	BLOCK	1		;COUNT OF BITS
BYTES::	BLOCK	1		;COUNT OF BYTES
WORDS::	BLOCK	1		;COUNT OF WORDS
RECORD::BLOCK	1		;COUNT OF RECORDS
BLOCKS::BLOCK	1		;COUNT OF BLOCKS
PAGES::	BLOCK	1		;COUNT OF PAGES
FILES::	BLOCK	1		;COUNT OF FILES
MSECS::	BLOCK	1		;COUNT OF MILLISECONDS
ERRORS::BLOCK	1		;COUNT OF FILES ABORTED
HWORDS::BLOCK	1		;"HELD" WORDS FOR COPL??
TIME::	BLOCK	1		;SCRATCH TIMER FOR CURRENT FILE
TELCNT::BLOCK	1		;COUNT OF TELFIL'S FOR CURRENT FILE

EZTOT:				;END OF "TOTALS" AREA

;OTHER (RANDOM)

NXTFCX:	BLOCK	1		;.NXTFI/.NXTFC INTERLOCK FLAG

;OTHER (FOR SCAN) BLOCKS

SIFIR::	BLOCK	1		;FIRST INPUT SCAN BLOCK ADDRESS
SILAS::	BLOCK	1		;LAST INPUT SCAN BLOCK ADDRESS

SOFIR::	BLOCK	1		;FIRST OUTPUT SCAN BLOCK ADDRESS
SOLAS::	BLOCK	1		;LAST OUTPUT SCAN BLOCK ADDRESS

S.TOTA::BLOCK	1		;/TOTALS:(BITS, BYTES, ETC.)

EZALL::				;END OF CLEARED-ON-COMMAND AREA

BOALL::

;SCAN SWITCHES

S.BAUD::BLOCK	1		;.NE. 0 THEN ALSO GIVE BAUD RATE IF /TOTALS
S.MOAN::BLOCK	1		;.GT. 0 THEN BITCH ABOUT MONITOR QUIRKS
S.NBIO::BLOCK	1		;.NE. 0 THEN USE TSK::NON-BLOCKING I/O
S.OKER::BLOCK	1		;.EQ. 0 THEN ABORT ON TRANSFER FAILURE
S.PERC::BLOCK	1		;.GT. 0 THEN SETNAM TO PERCENTAGES
S.WAIT::BLOCK	1		;.GT. 0 THEN WAIT FOR RECEIVER FOREVER

EOALL::				;END OF CLEARED-ON-COMMAND
;START OF CLEARED-ON-FILE AREA

BBFIL::

;THE ZERO'ED AREA (NOTE THAT BZFIL:EZFIL MUST PARALLEL BZSTB!!!)

BZFIL::

S.DIAL::BLOCK	2		;/DIAL
S.PASS::BLOCK	$ASCMX		;/PASSWORD
S.USER::BLOCK	$ASCMX		;/USERID
	BLOCK	$ASCMX		;/UACCOUNT
	BLOCK	$ASCMX		;/UPASSWORD

EZFIL::

;THE ONE'D AREA

BOFIL::

S.XUO0::BLOCK	1		;ONE'ED #0
S.XUO1::BLOCK	1		;ONE'ED #1
S.XUO2::BLOCK	1		;ONE'ED #2
S.XUO3::BLOCK	1		;ONE'ED #3
S.XUO4::BLOCK	1		;ONE'ED #4
S.XUO5::BLOCK	1		;ONE'ED #5
S.XUO6::BLOCK	1		;ONE'ED #6
S.XUO7::BLOCK	1		;ONE'ED #7
S.XUO8::BLOCK	1		;ONE'ED #8
S.XUO9::BLOCK	1		;ONE'ED #9

EOFIL::
EEFIL::

	LZFIL==EZFIL-BZFIL	;LENGTH OF ZERO'ED FILE-SPECIFIC AREA
	LOFIL==EOFIL-BOFIL	;LENGTH OF ONE'D FILE-SPECIFIC AREA
	LNFIL==EEFIL-BBFIL	;TOTAL LENGTH OF FILE-SPECIFIC AREA



;START OF STICKY DEFAULTS COPY OF FILE "ANSWERS"

BBSTK::

BZSTK::	BLOCK	LZFIL		;ZERO'ED STICKY PARALLEL FROM BBFIL
EZSTK::

BOSTK::	BLOCK	LOFIL		;ONE'D STICKY PARALLEL FROM BBFIL
EOSTK::

EESTK::

EZMEM::				;END OF CLEARED-ON-PROGRAM STARTUP
	END	NFT
