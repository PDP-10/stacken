	TITLE	FILDAE - TELL FILSER HIGHEST ACCESS ALLOWED TO A FILE
	SUBTTL	J.M.FLEMMING/JMF/GMU	12-AUG-85
	SEARCH	MACTEN,UUOSYM,SCNMAC
	.REQUEST	REL:SCAN



;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976,1978,1979,1980,1981,1982,1984,1986.
;ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

VFILDAE==4			;VERSION NUMBER
VWHO==0				;WHO EDITED LAST
VMINOR==0			;MINOR VERSION NUMBER
VEDIT==44			;EDIT NUMBER


COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976,1986. ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO




;
;EDIT 21	6-17-78	ISM	FORCE IN BEHALF OF FILOP TO FAIL,
;EVEN IF JOB IS [1,2] OR JACCT'ED.
;
;EDIT 35	15-JAN-81 RKB  SPR #10-30384
;	DON'T DO THE CORE UUO TO CONTRACT CORE AT FILD10 +2.  IT
;	WASTES MORE RUNTIME THAN IT'S WORTH.
;EDIT 40	9-6-83 SMW
;	A MALICIOUS USER CAN ^C OUT OF FILDAE BY CREATING A LARGE
;	ACCESS.USR. IT TAKES FILDAE A LONG TIME TO READ IT.
;	MAKE THE WINDOW SMALLER BY NOT ALLOWING LARGE ACCESS.USR FILES,
;	THE USER IS OBVIOUSLY TRYING TO BE MALICIOUS.
;EDIT 41	8-NOV-83 ERS
;	MAKE THE OWNER OF AN UFD BE ANY OWNER, NOT JUST THE PPN ITSELF.
;EDIT 42	25-MAR-84 ERS
;	LET ONLY THE /CREATE SWITCH GIVE PERMISSION TO CREATE A FILE.
;EDIT 43	12-AUG-85 LEO
;	MAKE COPYRIGHT CHANGES.
;EDIT 44	24-DEC--85 RCB
;	FIX UP FOR CTXSER--ADD HANDLING FOR PUSH AND POP MESSAGES.
;	BECOME VERSION 4.
;
.JBVER==137

	LOC	.JBVER		;PUT VERSION NUMBER IN .JBVER
	BYTE	(3)VWHO(9)VFILDAE(6)VMINOR(18)VEDIT
	RELOC
	SALL

	SUBTTL	DEFINITIONS

;ACCUMULATOR ASSIGNMENTS
T1=1				;TEMPORARY ACCUMULATORS
T2=2				; ..
T3=3				; ..
T4=4				; ..
P1=5				;PRESERVED ACCUMULATORS
P2=6				; ..
P3=7				; ..
P4=10				; ..
J=11				;JOB NUMBER OF FILE ACCESSOR
D=12				;PPN OF FILE ACCESSOR
C=13				;CODE FROM FILSER INDICATING MESSAGE TYPE
M=16				;ADDRESS OF THE IPCF MESSAGE
P=17				;PUSH DOWN LIST POINTER

;ERROR
DEFINE ERROR	<HALT	.>
;I/O CHANNEL ASSIGNMENTS
DSK==1

;LENGTH OF THE PUSH-DOWN LIST
PDLL==400

;LOCATIONS IN THE IPCF MESSAGE
M.CODE==0			;HIGHEST ACCESS ATTEMPTED,,REASON FILE DAEMON WAS CALLED
M.STR==1			;FILE STR WHERE FILE BEING ACCESSED WAS FOUND
M.FILE==2			;NAME OF THE FILE BEING ACCESSED
M.EXT==3			;EXTENSION OF THE FILE BEING ACCESSED
M.PPN==4			;DIRECTORY OF THE FILE BEING ACCESSED
M.PATH==5			;PATH TO THE FIE WITHIN THE DIRECTORY

;HIGHEST FUNCTION ALLOWED
FNCCPR==15			;CHANGE PROTECTION
FNCCNM==14			;CHANGE NAME
FNCDEL==13			;DELETE
FNCCAT==12			;CHANGE ATTRIBUTES
FNCTRN==11			;TRUNCATE
FNCSUP==10			;SUPERSEDE
FNCCRE==7			;CREATE
FNCUPD==6			;UPDATE
FNCAPP==5			;APPEND
FNCDLL==4			;DEALLOCATE
FNCALL==3			;ALLOCATE
FNCRED==2			;READ
FNCEXE==1			;EXECUTE
FNCNAA==0			;NO ACCESS ALLOWED

;LENGTH OF AN ACCOUNT STRING
ACTLEN==^D8

;DEFINE A DUMMY HELPER SO THAT WE DON'T HAVE TO LOAD WITH IT
.HELPR==:.POPJ##

;INTERNAL CODE (NEGATIVE INDEX INTO ACTION TABLE)
.FLDSC==0		;PROGRAM BEING SAVED(CREATE) AS OPPOSED TO EXECUTED
.FLDSS==-1		;PROGRAM BEING SAVED(SUPERCEDES)

	IFNDEF	BIGSIZ,<BIGSIZ==^D10>	;SIZE OF LARGEST ACCESS.USR ALLOWED
	SUBTTL	SCAN INTERFACE MACROS

DEFINE SWTCHS,<
XLIST
SS RUN,RUNSWT,0			;DON'T ALLOW SCAN'S BUILT IN RUN SWITCH
SS TMPFIL,TMPSWT,0		;  OR SCAN'S TMPFIL SWITCH
SP ACCOUNT,FACCT,ACCTSW,,FS.VRQ	;ALLOW ACCESS ONLY BY SPECIFIED ACCOUNT STRING
SS CREATE,FCREAT,0,FS.NOS	;ALLOW CREATE IN A DIRECTORY PROTECTED AGAINST CREATE
SL LOG,FLOG,LOGS,LOGSAL		;LOG ACCESS TO THE FILE
SS NOLOG,FLOG,0,0		;DON'T LOG ACCESS TO THE FILE (FOR COMPATABILITY)
SS EXIT,FEXIT,0,FS.NOS		;IF LOGGING, LOG EXIT IF A PROGRAM IS BEING RUN
SS CLOSE,FCLOSE,0,FS.NOS	;IF LOGGING, LOG CLOSE OF A FILE
SS ALL,FSWICH,FNCCPR		;ALL ACCESS ALLOWED
SS RENAME,FSWICH,FNCDEL		;RENAME ALLOWED
SS WRITE,FSWICH,FNCSUP		;WRITE (SUPERSEDE) ALLOWED
SS UPDATE,FSWICH,FNCUPD		;UPDATE ALLOWED
SS APPEND,FSWICH,FNCAPP		;APPEND ALLOWED
SS READ,FSWICH,FNCRED		;READ ALLOWED
SS EXECUTE,FSWICH,FNCEXE	;EXECUTION ALLOWED
SP NAME,FNAME,NAMESW,,FS.VRQ	;ALLOW ACCESS ONLY BY SPECIFIED USER NAME
SS NONE,FSWICH,FNCNAA		;NO ACCESS ALLOWED
SS XONLY,FXONLY,0,FS.NOS	;ONLY GRANT PROGRAM ACCESS IF IT IS EXUCUTE ONLY
SP PROGRAM,FPRGM,.SWFIL##,PRO,FS.VRQ
LIST
>

KEYS	(LOGS,<ALL,NONE,SUCCESSES,FAILURES>)

MX.PRO==.FXLEN
PD.PRO==0
DEFINE FNC(TEXT)<
	[ASCIZ	/TEXT/]>

;TABLE OF HIGHEST ACCESS ATTEMPTED BY ACCESSOR
; USED TO LOG HIGHEST ACCESS ATTEMPTED IN ACCESS.LOG
ACCESS:	FNC	<Execute>
	FNC	<Read>
	FNC	<Allocate>
	FNC	<Deallocate>
	FNC	<Append>
	FNC	<Update>
	FNC	<Create>
	FNC	<Supersede>
	FNC	<Truncate>
	FNC	<Change Attributes>
	FNC	<Delete>
	FNC	<Change Name>
	FNC	<Change Protection>
	FNC	<Save(supersede)>
	FNC	<Save(create)>
	0
ACTION:	FNC	<Input Close>
	FNC	<Output Close>
	FNC	<Program Execution Terminated>
	FNC	<Execution>
	0			;DIRECTORY ACCESS ENTRY NOT REFERENCED
	FNC	<Program Suspended>
	FNC	<Program Resumed>


DOSCAN	(S)			;DEFINE SCAN TABLES
	SUBTTL	MAIN LOOP

FILDAE:	RESET			;RESET THE WORLD
	MOVE	P,[-PDLL,,PDL]	;SETUP A PUSH DOWN LIST POINTER
	PUSHJ	P,FDINIT	;INITIALIZE THE FILE DAEMON
	MOVE	T1,.JBFF	;FIRST FREE LOCATION
	MOVEM	T1,SAVFF	;SAVE THAT TO REINITIALIZE SIZE
	MOVX	T1,%LDFFA	;FULL FILE ACCESS PPN
	GETTAB	T1,		;GET THAT
	  ERROR			;MUST BE IMPLEMENTED
	MOVEM	T1,FFAPPN	;SAVE FULL FILE ACCESS PPN
	OUTSTR	[ASCIZ /DETACHING
./]				;TELL THE WORLD
	SETO	T1,		;OUR TTY
	GETLCH	T1		;GET ITS LINE NUMBER
	HRLZS	T1		;LINE NUMBER,,DETACH
	ATTACH	T1,		;DETATCH FROM THE TERMINAL
	  JFCL			;OH WELL
FILDA1:	MOVE	P,[-PDLL,,PDL]	;SCAN DOESN'T ALWAYS RETURN WITH THE STACK RIGHT
	MOVEI	T1,.POPJ##	;SET TO THROW OUTPUT FROM SCAN AWAY
	MOVEM	T1,TYO		;WHERE SCAN GOES TO TYPE OUT CHARACTERS
	PUSHJ	P,FDRECV	;GET AN IPCF MESSAGE FROM FILSER
	MOVEI	T1,.RBAUT	;GET DATA FROM THE RIB THROUGH THE AUTHOR
	MOVEM	T1,LEB.BL	;STORE THAT
	MOVE	T1,[FO.PRV+.FORED(DSK)]
	MOVEM	T1,FOP.BL	;READ INVOKING PRIVILEDGES
	MOVE	T1,M.STR(M)	;FILE STRUCTURE
	MOVEM	T1,FOP.DV	;STORE THAT FOR OPEN PART OF FILOP.
	MOVEM	T1,ACS.WB+.DCNAM	; AND FOR DSKCHR LATER IF NEEDED
	MOVE	T1,[SIXBIT /ACCESS/]
	MOVEM	T1,LEB.FL	;FILE NAME OF THE ACCESS LIST
	MOVSI	T1,(SIXBIT /USR/)
	MOVEM	T1,LEB.XT	;EXTENSION OF THE ACCESS LIST
	SETZM	FOP.BH		;NO BUFFERS ARE NEEDED
	SETZM	FOP.NB		; ..
	SETZM	LEB.AW		;ZERO THE ATTRIBUTES WORD
	MOVEI	T1,LEB.PB	;ADDRESS OF THE PATH BLOCK
	MOVEM	T1,LEB.PT	;STORE THAT
	HLRZ	T2,M.EXT(M)	;FILE OR DIRECTORY EXTENSION
	CAIE	C,.FLDDA	;A DIRECTORY ACCESS?
	MOVEI	T2,0		;NO, TREAT IT AS A FILE EVEN IF THE
				; EXTENSION IS SFD OR UFD
	MOVE	T1,M.PPN(M)	;FILE'S DIRECTORY
	CAIN	T2,'UFD'	;IS THE FILE A DIRECTORY?
	MOVE	T1,M.FILE(M)	;YES, FILE NAME IS PPN
	MOVEM	T1,LEB.PP	;STORE PPN
	MOVEI	T1,M.PATH(M)	;ADDRESS OF THE PATH IN THE MESSAGE
	MOVE	T4,[LEB.SF,,LEB.SF+1]
	SETZB	T3,LEB.SF	;ZERO THE PATH BLOCK
	BLT	T4,LEB.SF+4	; ..
FILDA2:	SKIPN	T4,(T1)		;GET NEXT SFD FROM MESSAGE
	JRST	FILDA3		;THE LAST ONE
	MOVEM	T4,LEB.SF(T3)	;STORE SFD IN LOOKUP BLOCK
	ADDI	T1,1		;POINT AT NEXT SFD
	AOJA	T3,FILDA2	;NEXT PATH ELEMENT
FILDA3:	MOVE	T1,M.FILE(M)	;FILE NAME
	CAIN	T2,'SFD'	;READING AN SFD AS A FILE?
	MOVEM	T1,LEB.SF(T3)	;YES, STORE FILE NAME AS LAST ELEMENT OF THE PATH
	MOVE	T1,[7,,FOP.BL]	;LOOKUP ACCESS.USR AND GET THE ACTUAL PATH
	FILOP.	T1,		; WHERE IT WAS FOUND
	  JRST	[JUMPE T1,FILD30;JUMP IF FILE NOT FOUND
		JRST FILD31]	;ALLOW NO ACCESS TO THE FILE
	MOVE	T1,LEB.SZ	;SIZE OF ACCESS.USR
	CAILE	T1,BIGSIZ*200	;DON'T ALLOW LARGE ACCESS.USR
	JRST	FILD30		;PRETEND THERE WAS NO ACCESS.USR AT ALL
 	MOVE	T2,LEB.PP	;PPN OF THE FILE
	CAMN	T2,LEB.AT	;SAME AS THE AUTHOR?
	  JRST	FILDA4		;YES, SCAN ACCESS.USR
	MOVE	T1,[.ACCPR,,<777>B26+<077>B35] ;NO, THEN SETUP FOR CHKACC
	MOVE	T3,LEB.AT	;AUTHOR OF ACCESS.USR
	MOVEI	T4,T1     	;CHECK TO SEE IF THE AUTHOR OF THE ACCESS.USR
	CHKACC	T4,		;IS THE OWNER OF THE FILE
	  CAIA			;SHOULD NEVER HAPPEN
	CAIE	T4,0		;IS HE?
	  CAMN	T3,FFAPPN	;NO, FULL FILE ACCESS PPN?
	JRST	FILDA4		;YES, SCAN ACCESS.USR
	MOVE	T1,[.DCOWN+1,,ACS.WB]
	DSKCHR	T1,		;GET THE OWNER OF THE FILE STRUCTURE
	  ERROR			;SHOULDN'T HAPPEN
	SKIPN	T1,ACS.WB+.DCOWN;PPN OF THE OWNER OF THE PACK
	JRST	FILD30		;NONE THERE, IGNORE ACCESS.USR
	TLC	T1,-1		;WILD CARD PROJECT NUMBER?
	TLCN	T1,-1
	HLL	T1,LEB.AT	;YES, THIS PROJECT MATCHES
	TRC	T1,-1		;WILD CARD PROGRAMMER NUMBER?
	TRCN	T1,-1
	HRR	T1,LEB.AT	;YES, THIS PROGRAMMER NUMBER MATCHS THAT
	CAME	T1,LEB.AT	;IS AUTHOR THE OWNER OF THE STR?
	JRST	FILD30		;NO, TREAT IT THE SAME AS IF THERE WAS NO ACCESS.USR
FILDA4:	CAIN	C,.FLDDA	;DIRECTORY ACCESS?
	JRST	FILDA5		;YES
	SETOM	IPS.DT+.IPCS1	;MAKE SURE ACCOUNTING LINE IS OUTPUT TO
				; THE LOG FILE IF EXIT OR CLOSE
	CAILE	C,.FLDCA	;FILE ACCESS?
	CAIN	C,.FLDPG	;OR RUNNING A PROGRAM?
FILDA5:	TDZA	T1,T1		;YES, SEE IF ACCESS IS ALLOWED
	JRST	FILD36		;NO, MUST BE CLOSE OR PROGRAM EXECUTION TERMINATED
				; JUST GO MAKE A LOG ENTRY
	SETZB	T2,PATHMM	;ASSUME ACCESS.USR WAS FOUND ON THE SAME
				; PATH AS THE FILE BEING ACCESSED
FILDA6:	MOVE	T3,PTH.PP(T1)	;DIRECTORY COMPONENT ON PATH TO ACCESS.USR
	CAME	T3,LEB.PP(T2)	;SAME AS COMPONENT ON THE PATH TO THE FILE?
	SETOM	PATHMM		;NO, PATH IN ACCESS.USR MUST MATCH PATH TO FILE
	JUMPE	T3,FILDA7	;JUMP IF THE ENTIRE PATH HAS BEEN EXAMINED
	ADDI	T1,1		;POINT AT NEXT DIRECTORY COMPONENT
	AOJA	T2,FILDA6	;AND SEE IF NEXT COMPONENTS MATCH
;HERE TO SCAN ACCESS.USR LOOKING FOR A FILESPEC MATCH
FILDA7:	SETOM	SCNBLK		;INITIALIZE SCAN BLOCK
	MOVE	T1,[SCNBLK,,SCNBLK+1]
	BLT	T1,SCNBLK+SCNBKL-1
	MOVE	T1,PTH.BL	;FILE STRUCTURE NAME
	MOVEM	T1,SCNDEV	;STORE THAT FOR SCAN
	MOVE	T1,[SIXBIT /ACCESS/]
	MOVEM	T1,SCNNAM	;FILE NAME
	MOVSI	T1,(SIXBIT /USR/)
	HLLM	T1,SCNEXT	;FILE EXTENSION
	MOVE	T1,[FX.DIR+FX.PHY]
	MOVEM	T1,SCNMOD	;FORCE A PHYSICAL ONLY OPEN
	MOVEI	T1,PTH.PP	;PATH TO ACCESS.USR
	MOVEI	T2,SCNDIR	;WHERE SCAN WANTS THE PATH FOR AN INDIRECT FILE
	MOVEI	T3,.FXLND	;MAXIMUM LENGTH OF A FULL PATH
FILDA8:	SKIPN	T4,(T1)		;SKIP IF NEXT DIRECTORY COMPONENT WAS SPECIFIED
	JRST	FILDA9		;FULL PATH HAS BEEN COPIED
	MOVEM	T4,(T2)		;STORE DIRECTORY COMPONENT IN SCAN BLOCK
	ADDI	T1,1		;NEXT COMPONENT IN THE PATH
	ADDI	T2,2		;NEXT WORD IN THE SCAN BLOCK
	SOJG	T3,FILDA8	;COPY THE ENTIRE PATH
FILDA9:	SETZM	(T2)		;INDICATE END
	MOVE	T1,[6,,[0
			0
			XWD	0,TYPE
			XWD	SCNBKL,SCNBLK
			XWD	.POPJ##,FILD31
			EXP	FS.IFI]]
	PUSHJ	P,.ISCAN##	;INITIALIZE SCAN
FILD10:	MOVE	T1,SAVFF	;OUR ORIGINAL SIZE
	MOVEM	T1,.JBFF	;RESET WHERE BUFFERS, ETC. GO
	MOVE	T1,[7,,[IOWD	SL,SN
			XWD	SD,SM
			XWD	0,SP
			0
			XWD	CLRALL,CLRFIL
			XWD	ALIN,ALOUT
			XWD	0,APLSTY]]
	PUSHJ	P,.TSCAN##	;SCAN ACCESS.USR
;HERE TO SEE IF THE PPN OF THE ACCESSOR MATCHES PPN'S SPECIFIED IN ACCESS.USR
	MOVE	T1,NINFIL	;NUMBER OF INPUT FILES
	MOVE	P2,T1		;ALSO TO P2
	JUMPE	T1,FILD10	;JUMP IF NO INPUT FILES SPECIFIED
	MOVE	P1,.JBFF	;CURRENT FIRST FREE LOCATION
	IMULI	T1,INLEN	;NUMBER OF INPUT FILES * LENGTH OF INPUT SCAN BLOCK
	SUB	P1,T1		;ADDRESS OF FIRST INPUT SCAN BLOCK
FILD11:	SKIPGE	.FXMOD(P1)	;ILLEGAL IF A DEVICE NAME WAS SPECIFIED
	SKIPE	.FXNAM(P1)	;ILLEGAL IF A FILE NAME WAS SPECIFIED
	JRST	FILD12		;SKIP THIS ILLEGAL SCAN BLOCK
	SKIPN	.FXEXT(P1)	;ILLEGAL IF AN EXTENSION WAS SPECIFIED
	SKIPE	.FXDIR+2(P1)	;ILLEGAL IF SFD'S WERE SPECIFIED
	JRST	FILD12		;SKIP THIS ILLEGAL SCAN BLOCK
	MOVX	T1,FX.DIR	;DIRECTORY WAS SPECIFIED BIT
	TDNN	T1,.FXMOD(P1)	;WAS A DIRECTORY SPECIFIED?
	JRST	FILD12		;NO, SKIP THIS ILLEGAL SCAN BLOCK
	SKIPN	T1,.FXDIR(P1)	;A REAL PPN TYPED?
	SKIPA	T1,M.PPN(M)	;NO, MUST BE [-], USE DEFAULT
	SKIPA	T3,.FXDIM(P1)	;PPN MASK FORM ACCESS.USR
	SETO	T3,		;PPN MASK OF [*,*]
	MOVE	T2,D		;PPN OF ACCESSOR
	PUSHJ	P,MATCHS	;DOES THE PPN FROM ACCESS.USR MATCH THE PPN
				; OF THE ACCESSOR?
	  CAIA			;NO, LOOK AT THE NEXT ENTRY IN ACCESS.USR
	JRST	FILD13		;YES, ALLOW ACCESS AS SPECIFIED BY ACCESS.USR
FILD12:	ADDI	P1,INLEN	;NEXT SCAN BLOCK
	SOJG	P2,FILD11	;LOOK AT ALL PPNS ON THE LINE FROM ACCESS.USR
	JRST	FILD10		;READ THE NEXT LINE FROM ACCESS.USR
;HERE WHEN ACCESSOR'S PPN WAS FOUND IN ACCESS.USR.
; NOW SEE IF THE FILE SPEC MATCHES THE LEFT HAND SIDE AND IF SO,
; USE SWITCH VALUE FOR HIGHEST ACCESS ALLOWED TO THE FILE
;
;HERE TO SEE IF THE /NAME SWITCH WAS SPECIFIED

FILD13:	SETCM	T1,I.NAME(P1)	;GET VALUE OF FIRST AND
	SETCM	T2,I.NAME+1(P1)	;  SECOND WORDS OF /NAME
	SKIPN	T1		;IF VALUE NOT
	JUMPE	T2,FILD14	;  SPECIFIED, CONTINUE
	HRLZ	T1,J		;GET JOB NUMBER OF ACCESSOR
	HRRI	T1,.GTNM1	;FIRST HALF OF USER NAME
	GETTAB	T1,		;GET IT
	  ERROR			;CAN'T HAPPEN
	HRLZ	T2,J		;GET JOB NUMBER AGAIN
	HRRI	T2,.GTNM2	;SECOND HALF OF USER NAME
	GETTAB	T2,		;GET IT
	  ERROR			;CAN'T HAPPEN
	CAMN	T1,I.NAME(P1)	;DOES FIRST HALF MATCH?
	CAME	T2,I.NAME+1(P1)	;YES, DOES SECOND HALF MATCH?
	JRST	FILD12		;NO, TRY NEXT ENTRY ON LINE

;HERE TO SEE IF THE /ACCOUNT SWITCH WAS SPECIFIED

FILD14:	SKIPN	I.ACTFL(P1)	;/ACCOUNT SPECIFIED?
	JRST	FILD18		;NO, CONTINUE
	MOVE	T1,[.ACTRD,,T2]	;POINT TO ACCT. BLOCK
	MOVEI	T2,2		;2 WORDS LONG
	MOVEI	T3,(J)		;JOB NUMBER
	MOVEI	T4,ACTBLK	;WHERE TO STORE ACCOUNT STRING
	ACCT.	T1,		;GET USERS ACCOUNT STRING
	  JRST	FILD12		;DISALLOW ACCESS IF FAILED
	MOVEI	T1,ACTLEN*5	;NUMBER CHARACTERS IN ACCOUNT STRING
	MOVE	T2,[POINT 7,ACTBLK] ;BYTE POINTER TO STRING
FILD15:	ILDB	T3,T2		;GET NEXT CHARACTER
	SOS	T1		;DECREMENT COUNT
	JUMPN	T3,FILD15	;FIND END OF STRING
	MOVEI	T3,0		;SETUP TO INSURE THAT STRING IS ZERO FILLED
FILD16:	SKIPLE	T1		;DONE IF COUNT DECREMENTED TO ZERO
	IDPB	T3,T2		;STORE NEXT CHARACTER
	SOJG	T1,FILD16	;LOOP FOR ALL
	MOVSI	T1,-ACTLEN	;BUILD AOBJN POINTER TO BLOCK
FILD17:	MOVEI	T2,(P1)		;GET POINTER TO SCAN BLOCK
	ADDI	T2,(T1)		;OFFSET FOR THIS WORD
	MOVE	T2,I.ACCT(T2)	;GET WORD FROM SCAN BLOCK
	CAMN	T2,ACTBLK(T1)	;MATCH?
	AOBJN	T1,FILD17	;YES, LOOP
	JUMPL	T1,FILD12	;IF NOT FULL MATCH, DISALLOW ACCESS
;HERE TO SEE IF THE /PROGRAM SWITCH WAS SPECIFIED

FILD18:	SKIPN	I.PRGM(P1)	;WAS /PROGRAM SEEN?
	JRST	FILD25		;NO, SEE IF FILE SPEC MATCHES
;HERE WHEN /PROGRAM WAS SPECIFIED IN ACCESS.USR
	SKIPE	I.PRGM+.FXEXT(P1)
	JRST	FILD12		;SKIP THIS ILLEGAL SCAN BLOCK
	MOVE	T1,I.PRGM+.FXNAM(P1)
	HRLZ	T2,J		;JOB NUMBER OF THE ACCESSOR
	HRRI	T2,.GTRFN	;NAME OF THE PROGRAM THAT THE ACCESSOR IS RUNNING
	GETTAB	T2,		;GET THAT
	  ERROR			;SHOULDN'T HAPPEN
	MOVE	T3,I.PRGM+.FXNMM(P1)
	PUSHJ	P,MATCHS	;SEE IF PROGRAM SPECIFIED IN ACCESS.USR
				; MATCHS THE PROGRAM THE ACCESSOR IS RUNNING
	  JRST	FILD12		;IT DOESN'T, LOOK AT THE NEXT ENTRY ON THIS LINE
;HERE WHEN PROGRAM NAMES MATCH
	SKIPGE	I.PRGM+.FXMOD(P1)
	JRST	FILD22		;NO DEVICE WAS SPECIFIED
	HRLZ	P3,J		;JOB NUMBER OF THE ACCESSOR
	HRRI	P3,.GTRDV	;STR WHERE THE ACCESSING PROGRAM CAME FROM
	GETTAB	P3,		;GET THAT
	  ERROR			;SHOULDN'T HAPPEN
	MOVE	T1,I.PRGM+.FXDEV(P1)
	MOVEM	T1,ACS.WB	;STORE DEVICE NAME FROM ACCESS.USR
	MOVE	T1,[3,,ACS.WB]	;ARGUMENT TO PATH.
	PATH.	T1,		;GET INFO ABOUT THE DEVICE
	  JRST	FILD12		;NO SUCH DEVICE, LOOK AT NEXT ENTRY
	MOVX	T1,PT.LIB	;IN CASE WE HAVE A LIB SET AND LIB WAS SPECIFIED
	TDNE	T1,ACS.WB+.PTSWT; IN ACCESS.USR, DON'T ALLOW LIB
	JRST	FILD12		; SINCE IT MAKES NO SENSE
	LDB	T1,[POINTR (ACS.WB+.PTSWT,PT.SLT)]
	MOVX	T2,PT.IPP	;AN IMPLIED PPN?
	TDNN	T2,ACS.WB+.PTSWT;TEST THAT
	JRST	FILD19		;NO, SEE IF ALL OR SYS SEARCH LIST
;HERE IF THE DEVICE FROM ACCESS.USR HAS AN IMPLIED PPN
	SKIPE	I.PRGM+.FXDIR(P1)
	JRST	FILD12		;PPN WAS SPECIFIED, THAT'S ILLEGAL
	MOVE	T2,ACS.WB+.PTPPN;GET THE IMPLIED PPN
	MOVEM	T2,I.PRGM+.FXDIR(P1)
	SETOM	I.PRGM+.FXDIM(P1)
	MOVX	T2,FX.DIR	;DIRECTORY WAS SPECIFIED BIT
	IORM	T2,I.PRGM+.FXMOD(P1);INDICATE THAT
FILD19:	CAXN	T1,.PTSLA	;ALL SEARCH LIST?
	JRST	FILD22		;YES, DEVICES MATCH
	CAXE	T1,.PTSLS	;SYS SEARCH LIST?
	JRST	FILD21		;NO, NEED MORE INFORMATION
;HERE IF THE SEARCH LIST FOR THE DEVICE SPECIFIED IN ACCESS.USR IS
; THE SYS SEARCH LIST
	SETZM	ACS.WB+.DFGJN	;ZERO JOB NUMBER (SYS SEARCH LIST)
	SETZM	ACS.WB+.DFGPP	;AND PPN
	SETOM	ACS.WB+.DFGNM	;GET FIRST FILE STRUCTURE IN SYS SEARCH LIST
FILD20:	MOVE	T1,[3,,ACS.WB]	;ARGUMENT TO GOBSTR
	GOBSTR	T1,		;GET THE NEXT STR FROM THE SYS SEARCH LIST
	  ERROR			;WHAT?
	MOVE	T1,ACS.WB+.DFGNM;FILE STRUCTURE NAME
	JUMPE	T1,FILD12	;JUMP IF ALL STRS IN SYS SEARCH LIST HAVE BEEN CHECKED
	CAMN	T1,P3		;SAME AS THE STR WHERE THE ACCESSING PROGRAM CAME FROM?
	JRST	FILD22		;YES, DEVICE NAMES MATCH
	JRST	FILD20		;NO, LOOK AT NEXT STR IN S.S.L.
;HERE IF THE SEARCH LIST FOR THE DEVICE SPECIFIED IN ACCESS.USR IS
; NOT THE SYS SEARCH LIST
FILD21:	MOVE	T1,[5,,ACS.WB]	;ARGUMENT TO DSKCHR
	DSKCHR	T1,		;GET DSK CHARACTERISTICS
	  JRST	FILD12		;NOT A DSK?
	LDB	T1,[POINTR (T1,DC.TYP)]
XX==.DCTDS			;CREF THE SYMBOL USED IN THE JUMPE
	JUMPE	T1,FILD22	;IF GENERIC, THEN ITS DSK AND DEVICE NAMES MATCH
	CAXE	T1,.DCTFS	;FILE STR NAME?
	JRST	FILD12		;NO, ANYTHING ELSE IS ILLEGAL
	CAME	P3,ACS.WB+.DCSNM;SAME AS THE NAME FROM ACCESS.USR?
	JRST	FILD12		;NO, LOOK ONWARD
;HERE WHEN THE FILE STRUCTURE WHERE THE PROGRAM CAME FROM MATCHES
; THE FILE STRUCTURE SPECIFIED IN ACCESS.USR
FILD22:	HRLZ	T2,J		;JOB NUMBER OF THE ACCESSOR
	HRRI	T2,.GTRDI	;DIRECTORY WHERE THE ACCESSING PROGRAM CAME FROM
	GETTAB	T2,		;GET THAT
	  ERROR			;HUH?
	JUMPE	T2,FILD12	;CAN'T MATCH IF NOT FROM DSK
	MOVX	T1,FX.DIR	;DIRECTORY WAS SPECIFIED BIT
	TDNE	T1,I.PRGM+.FXMOD(P1)
	SKIPN	T1,I.PRGM+.FXDIR(P1)
	SKIPA	T1,M.PPN(M)	;NOT SPECIFIED OR [-], USE DEFAULT OF OWNER'S PPN
	SKIPA	T3,I.PRGM+.FXDIM(P1)
	SETO	T3,		;-1 FOR PPN MASK
	MOVE	T4,IPR.BL+.IPCFC;CAPABILITIES
	SKIPLE	I.XO(P1)	;EXECUTE ONLY PROGRAM REQUIRED?
	TXNE	T4,IP.SXO	;YES, AND IS THE ACCESSING PROGRAM EXECUTE ONLY?
	PUSHJ	P,MATCHS	;DOES DIRECTORY FROM ACCESS.USR MATCH THE
				; DIRECTORY THAT THE ACCESSING PROGRAM CAME FROM?
	  JRST	FILD12		;NO, PRESS ON
;HERE TO SEE IF PATH TO PROGRAM MATCHES PATH FROM ACCESS.USR
	HRLZ	T1,J		;JOB NUMBER OF ACCESSOR
	HRRI	T1,.GTRS0-1	;GETTAB TABLE FOR FIRST SFD IN PATH TO PROGRAM
	PUSH	P,T1		;SAVE GETTAB NUMBER
	MOVEI	P3,I.PRGM+.FXDIR+2(P1)
	MOVEI	P4,.FXLND-1	;MAXIMUM NUMBER OF SFD'S
FILD23:	AOS	T4,(P)		;NEXT SFD
	GETTAB	T4,		;GET IT
	  SETZ	T4,		;NOT IMPLEMENTED, MUST NOT BE IN ACCESS.USR
	MOVE	T1,(P3)		;USER SUPPLIED SFD NAME
	MOVE	T2,T4		;SFD PROGRAM CAME FROM
	MOVE	T3,1(P3)	;MASK
	PUSHJ	P,MATCHS	;SEE IF SFD'S MATCH
	  JRST	[POP P,(P)	;NO MATCH
		JRST FILD12]	;NEXT SPEC
	JUMPE	T4,FILD24	;JUMPE IF END OF PATH
	ADDI	P3,2		;NEXT SFD
	SOJG	P4,FILD23	;GET NEXT IF ALL HAVEN'T BEEN LOOKED AT
;HERE TO SEE IF STR WHERE FILE IS BEING ACCESSED MATCHES STR FROM ACCESS.USR
FILD24:	POP	P,(P)		;RESTORE STACK
FILD25:	SKIPE	PPRGM		;/PROGRAM SPECIFIED IN OUTPUT FILE SPEC?
	JRST	FILD10		;YES, ERROR, LOOK AT NEXT LINE IN ACCESS.USR
	SKIPGE	OUTBLK+.FXMOD	;WAS A DEVICE SPECIFIED?
	JRST	FILD26		;NO
	MOVE	T1,OUTBLK+.FXDEV;DEVICE NAME SPECIFIED IN ACCESS.USR
	CAME	T1,M.STR(M)	;DOES IT MATCH STR NAME WHERE THE FILE IS BEING ACCESSED?
	JRST	FILD10		;NO, READ THE NEXT LINE FROM ACCESS.USR
;HERE TO SEE IF FILE NAMES MATCH
FILD26:	SKIPN	T1,OUTBLK+.FXNAM;FILE NAME FROM ACCESS.USR
	JRST	FILD27		;NONE SPECIFIED, FILE NAMES MATCH
	MOVE	T2,M.FILE(M)	;FILE NAME OF FILE BEING ACCESSED
	MOVE	T3,OUTBLK+.FXNMM;FILE NAME MASK FROM ACCESS.USR
	PUSHJ	P,MATCHS	;DO THE FILE NAMES MATCH?
	  JRST	FILD10		;NO, LOOK AT THE NEXT LINE IN ACCESS.USR
;HERE TO SEE IF FILE EXTENSIONS MATCH
FILD27:	HLLZ	T1,OUTBLK+.FXEXT;EXTENSION FROM ACCESS.USR
	HLLZ	T2,M.EXT(M)	;EXTENSION OF THE FILE BEING ACCESSED
	HRLZ	T3,OUTBLK+.FXEXT;EXTENSION MASK FROM ACCESS.USR
	PUSHJ	P,MATCHS	;DO THE EXTENSIONS MATCH?
	  JRST	FILD10		;NO, LOOK AT THE NEXT LINE IN ACCESS.USR
;HERE TO SEE IF PATHS MATCH. THEY MUST IF PATHMM.NE.0 OR A PATH WAS
; SPECIFIED IN ACCESS.USR
	MOVX	T1,FX.DIR	;DIRECTORY WAS SPECIFIED BIT
	TDNE	T1,OUTBLK+.FXMOD;WAS A DIRECTORY SPECIFIED IN ACCESS.USR?
	SKIPE	T1,OUTBLK+.FXDIR;YES, WAS IT [,]?
	JRST	FILD28		;NO
	MOVE	T1,M.PPN(M)	;YES, FILL IN DEFAULT DIRECTORY
	MOVEM	T1,OUTBLK+.FXDIR; IN THE SCAN BLOCK
	SETOM	OUTBLK+.FXDIM	;AND THE DEFAULT MASK
FILD28:	SKIPN	PATHMM		;MUST PATH IN ACCESS.USR MATCH PATH TO THE FILE?
	SKIPE	OUTBLK+.FXDIR	;NO, WAS A DIRECTORY SPECIFIED IN ACCESS.USR
	SKIPA	T2,LEB.PP	;YES, DIRECTORIES MUST MATCH
	JRST	FILD32		;NO, FILE SPECS MATCH
	MOVE	T3,OUTBLK+.FXDIM;DIRECTORY WILD CARD MASK
	PUSHJ	P,MATCHS	;SEE IF DIRECTORIES MATCH
	  JRST	FILD10		;NO MATCH, READ NEXT LINE IN ACCESS.USR
	MOVEI	P2,OUTBLK+.FXDIR+2;ADDRESS OF THE PATH IN THE SCAN BLOCK
	MOVEI	P3,M.PATH(M)	;ADDRESS OF THE PATH TO THE FILE BEING ACCESSED
	MOVEI	P4,.FXLND	;MAXIMUM LENGTH OF A PATH
FILD29:	MOVE	T1,(P2)		;DIRECTORY COMPONENT FROM THE SCAN BLOCK
	SKIPN	T2,(P3)		;COMPONENT FROM THE MONITOR
	JUMPE	T1,FILD32	;JUMP IF DIRECTORIES MATCH
	MOVE	T3,1(P2)	;DIRECTORY MASK FROM THE SCAN BLOCK
	PUSHJ	P,MATCHS	;SEE IF DIRECTORY COMPONENTS MATCH
	  JRST	FILD10		;THEY DON'T, LOOK AT THE NEXT LINE IN ACCESS.USR
	ADDI	P2,2		;NEXT ENTRY IN THE SCAN BLOCK
	ADDI	P3,1		;NEXT ELEMENT OF THE PATH
	SOJG	P4,FILD29	;LOOP OVER ALL ELEMENTS OF THE DIRECTORY SPEC
	JRST	FILD32		;TELL FILSER THE ANSWER
;HERE WHEN ACCESS.USR WASN'T FOUND. RETURN DEFAULT VALUE (FNCNAA) AS HIGHEST ACCESS
; ALLOWED TO THE FILE OR (FNCCPR) IF FULL FILE ACCESS PROGRAM
FILD30:	MOVEI	T1,.GTPPN	;PICK UP PPN OF
	HRL	T1,J		;...REQUESTING JOB
	GETTAB	T1,		;...
	  JRST	FILD31		;NO ACCESS IF NO PPN
	JUMPE	T1,FILD31	;...
	MOVE	T2,IPR.BL+.IPCFC;ACCESSOR'S CAPABILITIES
	CAMN	T1,D		;IN YOU BEHALF FILOP?
	TXNN	T2,IP.JAC	;NO, JACCT?
	CAMN	D,FFAPPN	;OR [1,2]
	SKIPA	T1,[FNCCPR]	;YES, ALLOW ALL ACCESS
;HERE IF NO ACCESS IS TO BE ALLOWED TO THE FILE
FILD31:	MOVEI	T1,FNCNAA	;NO ACCESS ALLOWED
	SETZM	PLOG		;DON'T LOG ACCESS
	MOVEI	P1,PLOG-I.LOG	;USE STICKY LOG SWITCH
	JRST	FILD33		;TELL FILSER THE ANSWER
;HERE WHEN FILE BEING ACCESSED MATCHES FILE SPEC FOUND IN ACCESS.USR
FILD32:	SKIPGE	T1,I.SWCH(P1)	;HIGHEST ACCESS ALLOWED TO THE FILE
	MOVEI	T1,FNCNAA	;IF NONE SPECIFIED, ALLOW NO ACCESS
;HERE TO SEE IF THE ACCESSOR IS ATTEMPTING TO CREATE THE FILE
	HLRZ	T2,M.CODE(M)	;ACCESS BEING ATTEMPTED
	CAIE	T2,FNCCRE	;CREATE?
	JRST	FILD33		;NO, ALLOW ONLY ACCESS SPECIFIED IN ACCESS.USR
	SKIPG	I.CRE(P1)	;CREATE ALLOWED?
	JRST	FILD31		;NO, ALLOW NO ACCESS TO THE FILE
	MOVEI	T1,FNCCRE	;YES, ALLOW THE CREATE
;HERE TO SEE IF A PROTECTION CODE WAS SPECIFIED IN ACCESS.USR
; IF SO, TELL FILSER TO CREATE THE FILE WITH THIS PROTECTION CODE
	MOVX	T2,FX.PRO	;PROTECTION MASK
	TDNN	T2,OUTBLK+.FXMOM;A PROTECTION CODE SPECIFIED?
	JRST	FILD33		;NO
	LDB	T2,[POINTR (OUTBLK+.FXMOD,FX.PRO)] ;YES
	DPB	T2,[POINTR (T1,FL.DPT)]
	TXO	T1,FL.DSP	;TELL FILSER THAT USER SPECIFIED CREATE PROTECTION
;HERE TO SEND HIGHEST ACCESS ALLOWED TO THE FILE BY THIS ACCESSOR
; TO FILSER
FILD33:	TXO	T1,FL.DAA	;ASK US ON EVERY REFERENCE TO THE FILE
	MOVEM	T1,IPS.DT+.IPCS1;STORE HIGHEST ACCESS ALLOWED
	HLRZ	T2,M.CODE(M)	;ACCESS BEING ATTEMPTED
	MOVEI	P2,[ASCIZ / failed
/]				;ASSUME ACCESS WILL NOT BE ALLOWED
	CAIE	C,.FLDPG	;A PROGRAM BEING RUN?
	JRST	FILD34		;NO
	HRRZS	T1		;TYPE OF ACCESS BEING ATTEMPTED
	CAIN	T1,FNCEXE	;EXECUTE ONLY FILE?
	CAILE	T1,FNCRED	;AND TRYING TO READ IT?
FILD34:	CAIG	T2,(T1)		;ACCESS REQUESTED LESS THAN ACCESS ALLOWED?
	MOVEI	P2,[ASCIZ / succeeded
/]				;YES, THE ACCESS WILL BE ALLOWED
	MOVE	T1,[1,,[.FOCLS(DSK)]]
	FILOP.	T1,		;CLOSE ACCESS.USR
	  JFCL			;SHOULDN'T HAPPEN
	SKIPLE	T1,I.LOG(P1)	;ACCESS LOGGING REQUESTED?
	CAIN	T1,LOGSNO	;OR LOG:NONE SPECIFIED?
	JRST	FILD46		;NO, SEND THE MESSAGE TO FILSER AND START OVER
	CAIN	T1,LOGSAL	;/LOG:ALL?
	JRST	FILD35		;YES, GO LOG IT
	CAIN	T1,LOGSFA	;LOG FAILURES?
	MOVEI	T2,[ASCIZ / failed
/]				;YES
	CAIN	T1,LOGSSU	;LOG SUCCESSES?
	MOVEI	T2,[ASCIZ / succeeded
/]				;YES

	CAIE	T2,(P2)		;SUCCESS OR FAILURE?
	JRST	FILD46		;NO, NO LOGGING
FILD35:	MOVE	T1,IPS.DT+.IPCS1;WORD RETURNED TO MONITOR
	SKIPLE	I.CLOS(P1)	;YES, A CLOSE SWITCH SEEN?
	TXO	T1,FL.DCL	;YES, CALL THE FILE DAEMON ON CLOSE
	CAIN	C,.FLDPG	;PROGRAM BEING RUN?
	SKIPG	I.EXIT(P1)	;AND WAS AN EXIT SWITCH SEEN?
	CAIA			;NO
	TXO	T1,FL.DXT	;YES, CALL THE FILE DAEMON ON PROGRAM EXIT
	MOVEM	T1,IPS.DT+.IPCS1;STORE CLOSE AND EXIT BITS
;HERE TO LOG ACCESS TO THE FILE
FILD36:	MOVEI	T1,.RBPRV	;4 WORD LOOKUP SO IT WILL BE FASTER IF
	MOVEM	T1,LEB.BL	; IF FILSER KNOWS ABOUT THE FILE
	MOVE	T1,[FO.PRV+.FOAPP(DSK)]
	MOVEM	T1,FOP.BL	;APPEND TO THE FILE ENVOKING PRIVS
	MOVSI	T1,(SIXBIT /LOG/)
	MOVEM	T1,LEB.XT	;EXTENSION
	MOVSI	T1,OBUF		;OUTPUT BUFFER HEADER
	MOVEM	T1,FOP.BH	;STORE THAT
	MOVSI	T1,1		;ONE INPUT BUFFER
	MOVEM	T1,FOP.NB	;STORE THAT
	HRLOI	T1,777		;ZERO ALL OF THE ATTRIBUTES WORD
	ANDCAM	T1,LEB.AW	;EXCEPT THE PROTECTION FIELD
	MOVEI	T1,PTH.BL	;ADDRESS OF THE PATH BLOCK
	MOVEM	T1,LEB.PT	;STORE THAT
	MOVEI	T1,.PTSCN	;DON'T SCAN
	MOVEM	T1,PTH.AW	;STORE THAT
	MOVE	T1,[6,,FOP.BL]	;FILOP ARGUMENT LIST
	FILOP.	T1,		;APPEND OR CREATE ON SAME PATH AS ACCESS.USR
	  JRST	FILD45		;THE ONLY REASON THIS SHOULD HAPPEN IS A RIB ERROR
	MOVEI	T1,PUTCHR	;HAVE SCAN CALL PUTCHR
	MOVEM	T1,TYO		; TO OUTPUT TO THE LOG FILE
	PUSHJ	P,.GTNOW##	;GET CURRENT DATE/TIME
	PUSHJ	P,.TDTTM##	;PRINT DATE AND TIME
	MOVEI	T1,[ASCIZ /
	Job /]
	PUSHJ	P,.TSTRG##	;OUTPUT THE STRING
	MOVE	T1,J		;JOB NUMBER OF ACCESSOR
	PUSHJ	P,.TDECW##	;PRINT THAT
	PUSHJ	P,.TSPAC##	;PRINT A SPACE
	HRLZ	P3,J		;JOB NUMBER OF THE ACCESSOR
	HRRI	P3,.GTNM1	;FIRST PART OF THE USER'S NAME
	GETTAB	P3,		;GET THAT
	  ERROR			;SHOULDN'T HAPPEN
	HRLZ	P4,J		;JOB NUMBER
	HRRI	P4,.GTNM2	;SECOND HALF OF USER'S NAME
	GETTAB	P4,		;GET THAT
	  ERROR			;SHOULDN'T HAPPEN
	MOVE	P1,[POINT 6,P3]	;BYTE POINTER TO NAME STRING
FILD37:	SKIPN	P3		;FIRST HALF OF NAME ZERO OR BEEN ZEROED?
	JUMPE	P4,FILD38	;JUMP IF SECOND HALF HAS BEEN PRINTED
	ILDB	T1,P1		;NEXT CHARACTER OF NAME STRING
	MOVEI	T2,0		;ZERO CHARACTER POSITION
	DPB	T2,P1		; FOR END TEST
	ADDI	T1," "		;MAKE IT ASCII
	PUSHJ	P,.TCHAR##	;PUT IT IN THE OUTPUT
	JRST	FILD37		;NEXT CHARACTER IF THERE IS ONE
FILD38:	PUSHJ	P,.TSPAC##	;PRINT A SPACE
	MOVE	T1,D		;PPN OF THE ACCESSOR
	PUSHJ	P,.TPPNW##	;PRINT THAT
	MOVE	T1,J		;GET JOB NUMBER
	TRMNO.	T1,		;GET TTY NUMBER
	  JRST	[MOVEI T1,[ASCIZ/ Detached/] ;MUST BE
		 PUSHJ P,.TSTRG##	;  DETACHED
		 JRST  FILD40]	; AND CONTINUE
	PUSH	P,T1		;SAVE LINE NUMBER
	MOVEI	T1,[ASCIZ/ from TTY/]
	PUSHJ	P,.TSTRG##	;START WITH TTY PREFIX
	MOVE	T1,0(P)		;GET UDX BACK
	TRZ	T1,.UXTRM	;CLEAR UNIVERSAL BIT
	PUSHJ	P,.TOCTW##	;PRINT IT
	POP	P,T1		;RESTORE UDX
	GTNTN.	T1,		;MAP TO NODE,,LINE ON NODE
	  JRST	FILD40		;SHOULDN'T HAPPEN
	PUSH	P,T1		;SAVE THAT
	HLRZ	T2,T1		;MOVE NODE NUMBER TO T2
	MOVEI	T1,2		;NUMBER OF ARGS IS 2
	MOVE	T3,[.NDRNN,,T1]	;SETUP FOR NODE. UUO
	NODE.	T3,		;GET THE CORRESPONDING NAME
	  JRST	FILD39		;SHOULDN'T HAPPEN
	MOVEI	T1,[ASCIZ/, node /]
	PUSHJ	P,.TSTRG##	;TYPE SEPARATOR
	MOVE	T1,T3		;MOVE NODE NAME
	PUSHJ	P,.TSIXN##	;  IS A NODE SPEC
	MOVEI	T1,[ASCIZ/ line /]
	PUSHJ	P,.TSTRG##	;TYPE SEPARATOR
	HRRZ	T1,0(P)		;GET LINE ON NODE BACK
	PUSHJ	P,.TOCTW##	;TYPE IT
FILD39:	POP	P,0(P)		;BRING STACK INTO PHASE
FILD40:	CAIN	C,.FLDPG	;A PROGRAM BEING RUN?
	JRST	FILD43		;YES
	HRLZ	T1,J		;JOB NUMBER OF ACCESSOR
	HRRI	T1,.GTRDV	;GET THE DEVICE WHERE
	GETTAB	T1,		; ACCESSING PROGRAM CAME FROM
	  ERROR			;SHOULDN'T HAPPEN
	JUMPE	T1,FILD43	;IF NONE, PROBABLY A SAVE IN PROGRESS
	PUSH	P,T1		;SAVE PROGRAM NAME
	MOVEI	T1,[ASCIZ/,
	Running /]
	PUSHJ	P,.TSTRG##	;Type start of program spec
	POP	P,T1		;RESTORE PROGRAM NAME
	PUSHJ	P,.TSIXN##	;PRINT THE PROGRAM NAME
	PUSHJ	P,.TCOLN##	;PRINT A COLON
	HRLZ	T1,J		;JOB NUMBER
	HRRI	T1,.GTRFN	;GET THE NAME OF THE ACCESSING PROGRAM
	GETTAB	T1,		; ..
	  ERROR			;SHOULDN'T FAIL
	PUSHJ	P,.TSIXN##	;PRINT THAT
	HRLZ	T1,J		;JOB NUMBER
	HRRI	T1,.GTRDI	;GET THE DIRECTORY THAT
	GETTAB	T1,		; THE ACCESSING PROGRAM CAME FROM
	  ERROR			;SHOULDN'T HAPPEN
	JUMPE	T1,FILD43	;JUMP IF DIRECTORY UNKNOWN
	PUSH	P,T1		;SAVE PPN
	MOVEI	T1,"["		;PRINT A LEFT BRACKET
	PUSHJ	P,.TCHAR##	; ..
	POP	P,T1		;PRINT P,PN
	PUSHJ	P,.TXWDW##	; ..
	HRLZ	P1,J		;JOB NUMBER OF THE ACCESSOR
	HRRI	P1,.GTRS0	;FIRST SFD IN PATH TO ACCESSING PROGRAM
	MOVEI	P3,.FXLND-1	;MAXIMUM NUMBER OF SFD'S
FILD41:	MOVE	T1,P1		;NEXT SFD
	GETTAB	T1,		;GET IT
	  SETZ	T1,		;GETTAB NOT IMPLEMENTED, IGNORE SFD'S
	JUMPE	T1,FILD42	;JUMP IF LAST SFD IN PATH
	PUSH	P,T1		;SAVE SFD NAME
	MOVEI	T1,","		;PRINT A COMMA
	PUSHJ	P,.TCHAR##	; ..
	POP	P,T1		;RESTORE SFD NAME
	PUSHJ	P,.TSIXN##	;AND PRINT IT
	ADDI	P1,1		;NEXT SFD
	SOJG	P3,FILD41	;LOOP OVER ALL POSSIBLE SFD'S
FILD42:	PUSHJ	P,.TRBRK##	;PRINT RIGHT BRACKET
FILD43:	PUSHJ	P,.TCRLF##	;CARRIAGE RETURN, LINE FEED
	PUSHJ	P,.TTABC##	;PRINT A TAB
	HLRZ	T1,M.CODE(M)	;TYPE OF ACCESS BEING ATTEMPTED
	CAIE	C,.FLDDA	;DIRECTORY ACCESS?
	CAIN	C,.FLDCA	;REGULAR FILE ACCESS?
	SKIPA	T1,ACCESS-1(T1)	;ADDRESS OF ACCESS TEXT
	MOVE	T1,ACTION-.FLDCA-1(C)
	PUSHJ	P,.TSTRG##	;PRINT TYPE OF ACCESS
	CAIN	C,.FLDXT	;PROGRAM EXECUTION TERMINATED?
	JRST	FILD44		;YES, NOTHING MORE TO PRINT
	CAIE	C,.FLDPS	;PROGRAM SUSPENSION?
	CAIN	C,.FLDPR	;OR PROGRAM RESUMED?
	JRST	FILD44		;YES, TREAT LIKE EXIT MESSAGE
	MOVEI	T1,[ASCIZ / of /]
	PUSHJ	P,.TSTRG##	;PRINT THE STRING
	MOVE	T1,M.STR(M)	;STRUCTURE NAME WHERE FILE BEING ACCESSED CAME FROM
	PUSHJ	P,.TSIXN##	;PRINT THAT
	PUSHJ	P,.TCOLN##	;PRINT A COLON
	MOVE	T1,M.FILE(M)	;ACCESSED FILE'S FILE NAME
	HLRZ	P1,M.EXT(M)	;EXTENSION
	CAIN	P1,'UFD'	;A UFD?
	PUSHJ	P,.TPPNW##	;YES, PRINT IN PPN FORMAT
	CAIE	P1,'UFD'	;A UFD
	PUSHJ	P,.TSIXN##	;NO, PRINT FILE NAME
	MOVEI	T1,"."		;PRINT A DOT
	PUSHJ	P,.TCHAR##	; ..
	HLLZ	T1,M.EXT(M)	;ACCESSED FILE'S EXTENSION
	PUSHJ	P,.TSIXN##	;PRINT THAT
	MOVEI	T1,M.PPN(M)	;ADDRESS OF FULL PATH
	TLO	T1,TS.DRP	;SO SCAN PRINTS IN PROPER FORMAT
	PUSHJ	P,.TDIRB##	;PRINT THE FULL PATH TO THE FILE
	CAIE	C,.FLDIC	;INPUT CLOSE?
	CAIN	C,.FLDOC	;OR OUTPUT CLOSE?
FILD44:	SKIPA	T1,[[ASCIZ /
/]]				;CRLF
	MOVE	T1,P2		;SUCCEEDED OR FAILED
	PUSHJ	P,.TSTRG##	;PRINT THAT
	MOVE	T1,IPS.DT+.IPCS1;FLAG BITS RETURNED TO THE MONITOR
	TXNN	T1,FL.DCL!FL.DXT;EXIT, CLOSE, OR WILL LOG EXIT OR CLOSE?
	JRST	FILD45		;NO, ALL DONE
	MOVEI	T1,[ASCIZ /	Current Runtime:/]
	PUSHJ	P,.TSTRG##	;PRINT THE STRING
	MOVE	T1,J		;JOB NUMBER OF ACCESSOR
	RUNTIM	T1,		;GET JOB'S CURRENT RUN TIME
	PUSHJ	P,.TTIME##	;PRINT THAT
	MOVEI	T1,[ASCIZ /, KCT:/]
	PUSHJ	P,.TSTRG##	;PRINT THE STRING
	HRLZ	T1,J		;JOB NUMBER
	HRRI	T1,.GTKCT	;GET CURRENT KCT
	GETTAB	T1,		; ..
	  ERROR			;SHOULDN'T HAPPEN
	PUSHJ	P,.TDECW##	;PRINT THAT
	MOVEI	T1,[ASCIZ /, Disk Reads:/]
	PUSHJ	P,.TSTRG##	;PRINT THE STRING
	HRLZ	T1,J		;JOB NUMBER
	HRRI	T1,.GTRCT	;GET JOB'S CURRENT DISK READS
	GETTAB	T1,		; ..
	  ERROR			;SHOULDN'T HAPPEN
	TXZ	T1,RC.INC	;CLEAR INCREMENTAL READS
	PUSHJ	P,.TDECW##	;PRINT CURRENT DISK READS
	MOVEI	T1,[ASCIZ /, Writes:/]
	PUSHJ	P,.TSTRG##	;PRINT THE STRING
	HRLZ	T1,J		;JOB NUMBER OF ACCESSOR
	HRRI	T1,.GTWCT	;GET THE JOB'S CURRENT DISK WRITES
	GETTAB	T1,		; ..
	  ERROR			;SHOULDN'T HAPPEN
	TXZ	T1,WC.INC	;CLEAR INCREMENTAL WRITES
	PUSHJ	P,.TDECW##	;PRINT CURRENT DISK WRITES
	PUSHJ	P,.TCRLF##	;CARRIAGE RETURN, LINE FEED
	MOVE	T1,[.ACTRD,,T2]	;POINT TO ACCT. BLOCK
	MOVEI	T2,2		;2 WORDS LONG
	MOVEI	T3,(J)		;GET JOB NUMBER OF ACCESSOR
	MOVEI	T4,ACTBLK	;POINT TO WHERE TO STORE STRING
	ACCT.	T1,		;GET ACCOUNT STRING
	  JRST	FILD45		;FAILED, GIVE UP
	LDB	T1,[POINT 7,ACTBLK,6] ;GET FIRST CHARACTER OF STRING
	JUMPE	T1,FILD45	;GO IF NULL
	MOVEI	T1,[ASCIZ/	Account string:"/]
	PUSHJ	P,.TSTRG##	;TELL WHAT THIS IS
	MOVEI	T1,ACTBLK	;POINT AT IT
	PUSHJ	P,.TSTRG##	;TYPE IT
	MOVEI	T1,[ASCIZ/"
/]
	PUSHJ	P,.TSTRG##	;END THE LINE
FILD45:	MOVE	T1,[1,,[.FOCLS(DSK)]]
	FILOP.	T1,		;CLOSE ACCESS.LOG
	  JFCL			;IGNORE ERROR
FILD46:	MOVE	T1,IPR.BL+.IPCFS;PID OF [SYSTEM]GOPHER
	MOVEM	T1,IPS.BL+.IPCFR;STORE THAT AS THE RECEIVER'S PID
	SETZM	IPS.BL+.IPCFL	;ZERO THE FLAGS
	HRL	J,M.EXT(M)	;GET SEQUENCE NUMBER FOR RESPONSE
	MOVEM	J,IPS.DT+.IPCS0	;JOB NUMBER OF THE ACCESSOR
	PUSHJ	P,FDSEND	;SEND THE RESPONSE TO [SYSTEM]GOPHER
	JRST	FILDA1		;RETURN TO THE TOP OF THE LOOP
	SUBTTL	SCAN INTERFACE

;HERE TO INITIALIZE THE WORLD
CLRALL:	SETZM	NINFIL		;ZERO NUMBER OF INPUT FILES
	SETOM	PEXIT		;STICKY EXIT SWITCH
	SETOM	PCLOSE		;STICKY CLOSE SWITCH
	SETOM	PSWICH		;INITIALIZE STICKY SWITCH
	SETOM	PLOG		; AND STICKY LOG SWITCH
	SETZM	FPRGM		;INITIALIZE PROGRAM SWITCH
	SETOM	PCREAT		;INITIALIZE STICKY CREATE SWITCH
	SETOM	PXONLY		;INITIALIZE STICKY XONLY SWITCH
	SETOM	PNAME		;INITIALIZE STICKY NAME SWITCH
	SETOM	PNAME+1		;  (BOTH WORDS)
	STORE	T1,PACCT,PACTFL,0 ;INITIALIZE STICKY ACCOUNT SWITCH
	POPJ	P,		;RETURN TO SCAN

;HERE TO INITIALIZE THE PER-FILE SWITCH AREA
CLRFIL:	SETZM	FPRGM		;INITIALIZE PROGRAM SWITCH
	SETOM	FEXIT		;LOCAL EXIT SWITCH
	SETOM	FCLOSE		;LOCAL CLOSE SWITCH
	SETOM	FSWICH		;INITIALIZE THE SWITCH
	SETOM	FLOG		;LOCAL LOG SWITCH
	SETOM	FCREAT		;LOCAL CREATE SWITCH
	SETOM	FXONLY		;LOCAL XONLY SWITCH
	SETOM	FNAME		;LOCAL NAME SWITCH
	SETOM	FNAME+1		;  (BOTH WORDS)
	STORE	T1,FACCT,FACTFL,0 ;LOCAL ACCOUNT SWITCH
	POPJ	P,		;AND RETURN
;HERE TO ALLOCATE AN INPUT FILESPEC AREA
ALIN:	MOVE	T1,.JBFF	;GET ADDRESS OF NEXT AREA
	MOVEI	T2,INLEN(T1)	;GET ADDRESS OF NEXT AREA
	MOVEM	T2,.JBFF	;SAVE IT
	CAMG	T2,.JBREL	;NEED MORE CORE?
	JRST	ALIN1		;NO
	CORE	T2,		;AND GET THE CORE
	  ERROR			;WHOOPS
ALIN1:	MOVEI	T2,INLEN	;LOAD THE LENGTH
	MOVEI	T3,1(T1)	;GET THE ADR+1
	HRLI	T3,-1(T3)	;ADR,,ADR+1
	SETZM	0(T1)		;CLEAR THE FIRST WORD
	BLT	T3,INLEN-1(T1)	;AND BLT THE BLOCK
	MOVSI	T3,FPRGM	;ADDRESS OF THE PROGRAM BLOCK
	HRRI	T3,I.PRGM(T1)	;WHERE IT IS IN THE SCAN BLOCK
	BLT	T3,INLEN-1(T1)	;BLT THE BLOCK
	MOVE	T3,FSWICH	;GET SWITCH
	MOVEM	T3,I.SWCH(T1)	;STORE IT
	MOVE	T3,FLOG		;VALUE OF THE LOG SWITCH
	MOVEM	T3,I.LOG(T1)	;STORE THAT IN THE SCAN BLOCK
	MOVE	T3,FEXIT	;VALUE OF THE EXIT SWITCH
	MOVEM	T3,I.EXIT(T1)	;STORE THAT IN THE SCAN BLOCK
	MOVE	T3,FCLOSE	;VALUE OF THE CLOSE SWITCH
	MOVEM	T3,I.CLOS(T1)	;STORE THAT
	MOVE	T3,FCREAT	;VALUE OF THE CREATE SWITCH
	MOVEM	T3,I.CRE(T1)	;STORE THAT IN THE SCAN BLOCK
	MOVE	T3,FXONLY	;VALUE OF THE XONLY SWITCH
	MOVEM	T3,I.XO(T1)	;STORE THAT
	MOVE	T3,FNAME	;VALUE OF FIRST WORD OF NAME SWITCH
	MOVEM	T3,I.NAME(T1)	;STORE THAT
	MOVE	T3,FNAME+1	;VALUE OF SECOND WORD OF NAME SWITCH
	MOVEM	T3,I.NAME+1(T1)	;STORE THAT
	MOVEI	T3,I.ACCT(T1)	;POINT TO WHERE TO STORE ACCOUNT STRING
	HRLI	T3,FACCT	;  AND WHERE TO GET IT FROM
	BLT	T3,I.ACTFL(T1)	;MOVE IT ALL
	AOS	NINFIL		;INCREMENT FILE COUNTER
	POPJ	P,		;AND RETURN
;HERE TO ALLOCATE AN OUTPUT FILESPEC BLOCK
ALOUT:	MOVE	T1,[OUTBLK,,OUTBLK+1]
	SETZM	OUTBLK		;ZERO THE OUTPUT SCAN BLOCK
	BLT	T1,OUTBLK+OUTLEN-1
	MOVE	T1,FSWICH	;VALUE OF STICKY SWITCH
	MOVEM	T1,PSWICH	;STORE THAT
	MOVE	T1,FLOG		;VALUE OF STICKY LOG SWITCH
	MOVEM	T1,PLOG		;STORE THAT
	MOVE	T1,FPRGM	;VALUE OF STICKY PROGRAM SWITCH
	MOVEM	T1,PPRGM	;STORE THAT
	MOVE	T1,FEXIT	;VALUE OF STICKY EXIT SWITCH
	MOVEM	T1,PEXIT	;STORE THAT
	MOVE	T1,FCLOSE	;VALUE OF STICKY CLOSE SWITCH
	MOVEM	T1,PCLOSE	;STORE THAT
	MOVE	T1,FCREAT	;VALUE OF STICKY CREATE SWITCH
	MOVEM	T1,PCREAT	;STORE THAT
	MOVE	T1,FXONLY	;VALUE OF STICKY XONLY SWITCH
	MOVEM	T1,PXONLY	;STORE THAT
	MOVE	T1,FNAME	;VALUE OF STICKY NAME SWITCH (1ST WORD)
	MOVEM	T1,PNAME	;STORE THAT
	MOVE	T1,FNAME+1	;VALUE OF STICKY NAME SWITCH (2ND WORD)
	MOVEM	T1,PNAME+1	;STORE THAT
	MOVE	T1,[FACCT,,PACCT] ;BLT POINTER TO MOVE ACCT STRING
	BLT	T1,PACTFL	;MOVE IT ALL
	MOVEI	T1,OUTBLK	;ADDRESS OF OUTPUT FILE SPEC SCAN BLOCK
	MOVEI	T2,OUTLEN	;LENGTH, RETURNED TO SCAN
	POPJ	P,		;AND RETURN TO SCAN
;HERE TO APPLY STICKY SWITCHES
APLSTY:	MOVE	T1,PSWICH	;LOAD THE GLOBAL SWITCH
	SKIPGE	FSWICH		;WAS A LOCAL SWITCH SPECIFIED?
	MOVEM	T1,FSWICH	;NO, USE THE  GLOBAL SWITCH
	MOVE	T1,PLOG		;GLOBAL LOG SWITCH
	SKIPGE	FLOG		;LOCAL SPECIFIED?
	MOVEM	T1,FLOG		;NO, USE GLOBAL VALUE
	MOVE	T1,PEXIT	;GLOBAL EXIT SWITCH
	SKIPGE	FEXIT		;LOCAL SPECIFIED?
	MOVEM	T1,FEXIT	;NO, USE GLOBAL VALUE
	MOVE	T1,PCLOSE	;GLOBAL CLOSE SWITCH
	SKIPGE	FCLOSE		;LOCAL SPECIFIED?
	MOVEM	T1,FCLOSE	;NO, USE GLOBAL VALUE
	MOVE	T1,PCREAT	;GLOBAL CREATE SWITCH
	SKIPGE	FCREAT		;LOCAL SPECIFIED?
	MOVEM	T1,FCREAT	;NO, USE GLOBAL VALUE
	MOVE	T1,PXONLY	;GLOBAL XONLY SWITCH
	SKIPGE	FXONLY		;LOCAL SPECIFIED?
	MOVEM	T1,FXONLY	;NO, USE GLOBAL VALUE
	SETCM	T1,FNAME	;GET LOCAL VALUE OF NAME SWITCH
	SETCM	T2,FNAME+1	;DITTO FOR 2ND WORD
	SKIPN	T1		;LOCAL
	SKIPE	T2		;  SPECIFIED?
	JRST	APLST1		;YES, DON'T DEFAULT
	MOVE	T1,PNAME	;GET STICKY VALUE
	MOVEM	T1,FNAME	;STORE THAT
	MOVE	T1,PNAME+1	;GET 2ND WORD
	MOVEM	T1,FNAME+1	;STORE THAT
APLST1:	SKIPE	FACTFL		;LOCAL ACCOUNT SWITCH SPECIFIED?
	POPJ	P,		;YES, RETURN
	MOVE	T1,[PACCT,,FACCT] ;SETUP BLT POINTER
	BLT	T1,FACTFL	;MOVE IT
	POPJ	P,		;RETURN
;HERE TO OUTPUT CHARACTERS FROM SCAN (NORMALLY THROW AWAY OUTPUT UNLESS LOGGING)
TYPE:	JRST	@TYO		;CPOPJ OR PUTCHR

;SUBROUTINE TO SEE IF COMPONENTS OF A FILE SPEC MATCH
;CALLING SEQUENCE:
;	MOVE	T1,USER SUPPLIED COMPONENT
;	MOVE	T2,COMPONENT TO MATCH AGAINST
;	MOVE	T3,MASK
;	PUSHJ	P,MATCHS
;RETURNS CPOPJ IF COMPONENTS DON'T MATCH, CPOPJ1 IF THEY DO

MATCHS:	XOR	T2,T1		;XOR (ACCESS.USR) WITH FILE SPEC
	AND	T2,T3		;APPLY WILD CARD MASK
	JUMPE	T2,.POPJ1##	;JUMP IF MATCH
	POPJ	P,		;NO MATCH

;HERE TO OUTPUT DATA TO ACCESS.LOG IGNORING I/O ERRORS

PUTCHR:	SOSGE	OBUF+2		;BUFFER FULL?
	JRST	[OUTPUT DSK,	;YES, OUTPUT IT
		JRST PUTCHR]	;AND STORE CHARACTER IN THE NEW BUFFER
	IDPB	T1,OBUF+1	;STORE THE CHARACTER
	POPJ	P,		;AND RETURN TO SCAN

;SUBROUTINE TO PROCESS THE /NAME SWITCH
;CALLING SEQUENCE:
;	PUSHJ	P,NAMESW
;ALWAYS RETURNS CPOPJ1 TO AVOID SCAN STORING A VALUE

NAMESW:	PUSHJ	P,.SIXQW##	;READ THE NAME
	MOVE	T1,.NMUL##	;GET FIRST 2 WORDS OF NAME
	MOVE	T2,.NMUL##+1	;  FROM WHERE SCAN STORES THEM
	MOVEM	T1,FNAME	;AND STORE THEM
	MOVEM	T2,FNAME+1	;  WHERE WE WANT THEM
	JRST	.POPJ1##	;SKIP RETURN TO BYPASS STORE


;SUBROUTINE TO PROCESS THE /ACCOUNT SWITCH
;CALLING SEQUENCE:
;	PUSHJ	P,ACCTSW
;ALWAYS RETURNS CPOPJ1 TO AVOID SCAN STORING A VALUE

ACCTSW:	PUSHJ	P,.ASCQW##	;READ THE STRING
	MOVE	T1,[.NMUL##,,FACCT] ;SETUP TO BLT IT TO OUR AREA
	BLT	T1,FACCT+ACTLEN-1 ;MOVE IT ALL
	SETOM	FACTFL		;INDICATE WE HAVE ONE
	JRST	.POPJ1##	;GIVE SKIP RETURN
	SUBTTL	INITIALIZATION

FDINIT:	MOVX	T1,%IPCML	;MAXIMUM LENGTH OF AN IPCF MESSAGE
	GETTAB	T1,		;GET THAT
	  ERROR			;IPCF MUST BE IMPLEMENTED
	MOVE	T2,.JBFF	;FIRST FREE LOCATION IN CORE IMAGE
	HRLM	T1,IPCSDT	;MAX LENGTH IF MESSAGE
	HRRM	T2,IPCSDT	;START OF MESSAGE (WHERE IT WILL BE RECEIVED)
	ADDI	T1,1(T2)	;LAST WORD IN RECEIVE BLOCK
	MOVEM	T1,.JBFF	;STORE THAT AS NEW FIRST FREE LOCATION
	CAMG	T1,.JBREL	;ALREADY HAVE ENOUGH CORE FOR MESSAGE?
	JRST	FDINI1		;YES
	CORE	T1,		;NO, GET ENOUGH CORE
	  ERROR			;WHOOPS
FDINI1:	MOVX	T1,%SIIPC	;PID OF [SYSTEM]IPCC
	GETTAB	T1,		;GET THAT
	  ERROR			;SHOULDN'T HAPPEN
	MOVEM	T1,IPCPID	;SAVE IT
	MOVX	T1,%SIFDA	;OUR PID
	GETTAB	T1,		;GET THAT
	  ERROR			;MUST BE IMPLEMENTED
	MOVEM	T1,OURPID	;SAVE THAT
	JUMPN	T1,.POPJ##	;INITIALIZATION IS COMPLETE IF PID EXISTS
	MOVX	T1,IP.CFP	;PRIVILEGED
	MOVEM	T1,IPS.BL+.IPCFL; SEND
	MOVE	T1,IPCPID	; TO [SYSTEM]IPCC
	MOVEM	T1,IPS.BL+.IPCFR; ..
	MOVX	T1,.IPCSC	;CREATE A PID
	MOVEM	T1,IPS.DT+.IPCS0; ..
	PJOB	T1,		;GET OUR JOB NUMBER
	MOVEM	T1,IPS.DT+.IPCS1;WHO TO CREATE A PID FOR
	PUSHJ	P,FDSEND	;SEND THE REQUEST TO [SYSTEM]IPCC
	PUSHJ	P,FDRECV	;WAIT FOR A RESPONSE
	MOVE	T1,.IPCS2(M)	;PID WHICH WAS CREATED FOR US
	MOVEM	T1,OURPID	;REMEMBER THAT
	MOVX	T1,.IPCSQ	;SET QUOTA
	MOVEM	T1,IPS.DT+.IPCS0; ..
	MOVE	T1,OURPID	;FROM US
	MOVEM	T1,IPS.DT+.IPCS1; ..
	MOVEI	T1,-1		;SET SEND AND RECEIVE QUOTAS TO 777
	MOVEM	T1,IPS.DT+.IPCS2; ..
	PUSHJ	P,FDSEND	;SEND REQUEST TO [SYSTEM]IPCC
	PUSHJ	P,FDRECV	;WAIT FOR A RESPONSE
	MOVX	T1,.IPCWP	;ADD AN ENTRY TO THE SYSTEM PID TABLE
	MOVEM	T1,IPS.DT+.IPCS0; ..
	MOVX	T1,.IPCPF	;WHERE TO ADD IT
	MOVEM	T1,IPS.DT+.IPCS1; ..
	MOVE	T1,OURPID	;PUT OUR PID IN .GTSID
	MOVEM	T1,IPS.DT+.IPCS2; ..
	PUSHJ	P,FDSEND	;ESTABLISH OURSELVES AS [SYSTEM]FILE DAEMON
;	PJRST	FDRECV		;WAIT FOR A RESPONSE
	SUBTTL	IPCF INTERFACE

FDRECV:	MOVX	T1,IP.CFT	;BLOCKING RECEIVE, TRUNCATE IF TOO LONG
	MOVEM	T1,IPR.BL+.IPCFL;STORE FLAGS
	MOVE	T1,IPCSDT	;LENGTH,,ADDRESS OF DATA
	MOVEM	T1,IPR.BL+.IPCFP;STORE THAT IN DESCRIPTOR BLOCK
	MOVE	T1,[6,,IPR.BL]	;IPCF RECEIVE ARGUMENT LIST
	IPCFR.	T1,		;RECEIVE A PACKET
	  CAIA			;ERROR
	JRST	FDREC1		;RECEIVE OK
	CAIE	T1,IPCPR%	;IS IT A PAGE?
	ERROR			;NO, WHOOPS
	MOVX	T1,IP.CFT+IP.CFV;TRUNCATE MESSAGE TO ZERO LENGTH
	MOVEM	T1,IPR.BL+.IPCFL;STORE THAT
	HRRZS	IPR.BL+.IPCFP	;RECIEVE ZERO WORDS
	MOVE	T1,[6,,IPR.BL]	;IPCF RECEIVE ARGUMENT LIST
	IPCFR.	T1,		;PITCH THE PAGE
	  ERROR			;SHOULDN'T HAPPEN
	JRST	FDRECV		;RECEIVE ANOTHER PACKET
FDREC1:	MOVE	T1,IPR.BL+.IPCFL;FLAGS
	TXNE	T1,IP.CFC	;WEED OUT JUNK MAIL (FROM THE SYSTEM)?
	TXNE	T1,IP.CFP+IP.CFT;NO, PRIVILEGED OR TRUNCATED?
	JRST	FDRECV		;YES, PITCH IT
	ANDX	T1,IP.CFM	;ISOLATE TURNED AROUND MESSAGE FIELD
	CAIN	T1,.IPCFN	;A TURNED AROUND MESSAGE?
	JRST	FDRECV		;YES, PITCH IT
	MOVE	T1,IPR.BL+.IPCFL;GET FLAGS AGAIN
	ANDX	T1,IP.CFE	;ISOLATE ERROR FIELD
	JUMPN	T1,FDRECV	;PITCH IT IF NON-ZERO ERROR FIELD
	MOVE	J,IPR.BL+.IPCFC	;FIELD CONTAINING SENDING JOB'S JOB NUMBER
	ANDX	J,IP.SJN	;ISOLATE JOB NUMBER OF SENDER
	HRRZ	M,IPCSDT	;ADDRESS OF THE DATA PORTION OF THE PACKET
	HLL	M,IPR.BL+.IPCFP	;LENGTH OF DATA
	MOVE	D,IPR.BL+.IPCFU	;PPN OF SENDER
	HRRZ	C,M.CODE(M)	;REASON WE WERE CALLED
	CAIE	C,.FLDPG	;SOME FLAVOR OF PROGRAM?
	POPJ	P,		;RETURN TO CALLER
	HLRZ	T1,M.CODE(M)	;YES, TYPE OF ACCESS
	CAIN	T1,FNCCRE	;CREATE?
	MOVX	C,.FLDSC	;YES, SAVE CREATING THE FILE
	CAIN	T1,FNCSUP	;SUPERSEDE?
	MOVX	C,.FLDSS	;YES, SAVE SUPERCEDING AN EXISTING FILE
	HRRM	C,M.CODE(M)	;STORE INTERNALLY GENERATED CODE
	POPJ	P,		;AND RETURN
FDSEND:	MOVE	T1,OURPID	;OUR PID
	MOVEM	T1,IPS.BL+.IPCFS;STORE AS SENDER'S PID
FDSEN1:	MOVE	T1,[4,,IPS.BL]	;IPCF SEND ARGUMENT LIST
	IPCFS.	T1,		;SEND THE MESSAGE
	  CAIA			;ERROR RETURN (ONLY IF NO MONITOR FREE CORE)
	POPJ	P,		;ALL IS WELL, RETURN
	CAXE	T1,IPCRY%	;NO ROOM ERROR?
	ERROR			;NO, WHAT NOW?
	MOVEI	T1,1		;SLEEP ONE SECOND
	SLEEP	T1,		; ..
	JRST	FDSEN1		;AND TRY AGAIN
	SUBTTL	STORAGE

PDL:	BLOCK	PDLL		;PUSH DOWN LIST
NINFIL:	BLOCK	1		;NUMBER OF INPUT FILES
IPCSEQ:	BLOCK	1		;IPCF SEQUENCE NUMBER
SAVFF:	BLOCK	1		;SAVE INITIAL VALUE OF .JBFF
FFAPPN:	BLOCK	1		;FULL FILE ACCESS PPN
IPCSDT:	BLOCK	1		;LENGTH,,ADDRESS OF IPCF RECEIVE DATA
IPCPID:	BLOCK	1		;PID OF [SYSTEM]IPCC
OURPID:	BLOCK	1		;PID OF THE FILE DAEMON
PATHMM:	BLOCK	1		;FLAG SAYING PATHS MUST MATCH
TYO:	BLOCK	1		;OUTPUT ROUTINE'S ADDRESS (CPOPJ OR PUTCHR)
IBUF:	BLOCK	3		;INPUT BUFFER HEADER
OBUF:	BLOCK	3		;OUTPUT BUFFER HEADER
ACTBLK:	BLOCK	ACTLEN		;ACCOUNT STRING READ HERE
OUTBLK:	BLOCK	.FXBFR		;SCAN BLOCK FOR OUTPUT FILE SPEC
	OUTLEN==.FXBFR		;LENGTH OF SCAN BLOCK

	PHASE	0
INBLK:	BLOCK	.FXLEN		;PROTOTYPE INPUT FILE SPEC SCAN BLOCK
I.SWCH:	BLOCK	1		;VALUE OF ACCESS SWITCH
I.LOG:	BLOCK	1		;VALUE OF LOG SWITCH
I.EXIT:	BLOCK	1		;VALUE OF EXIT SWITCH
I.CLOS:	BLOCK	1		;VALUE OF CLOSE SWITCH
I.CRE:	BLOCK	1		;VALUE OF CREATE SWITCH
I.XO:	BLOCK	1		;VALUE OF XONLY SWITCH
I.PRGM:	BLOCK	.FXLEN		;VALUE OF PROGRAM SWITCH
I.NAME:	BLOCK	2		;VALUE OF NAME SWITCH
I.ACCT:	BLOCK	ACTLEN		;VALUE OF ACCOUNT SWITCH
I.ACTFL:BLOCK	1		;ACCOUNT SWITCH SEEN
	INLEN==.-INBLK		;LENGTH OF SCAN BLOCK
	DEPHASE
FPRGM:	BLOCK	.FXLEN		;SCAN BLOCK FOR FILE SPEC FROM PROGRAM SWITCH

SCNBLK:				;SCAN BLOCK USED FOR READING ACCESS.USR
				; AS AN INDIRECT FILE
SCNDEV:	BLOCK	1		;DEVICE
SCNNAM:	BLOCK	2		;SIXBIT /ACCESS/
SCNEXT:	BLOCK	1		;SIXBIT /USR/
SCNMOD:	BLOCK	2		;MODIFIERS
SCNDIR:	BLOCK	2*.FXLND	;PATH TO ACCESS.USR
SCNBKL==.-SCNBLK		;LENGTH OF SCAN BLOCK
	0			;ALWAYS TERMINATE WITH A ZERO
RUNSWT:	BLOCK	1		;SWITCH TO DEFEAT SCAN'S /RUN SWITCH
TMPSWT:	BLOCK	1		;SWITCH TO DEFEAT SCAN'S /TMPFIL SWITCH
FCREAT:	BLOCK	1		;CREATE SWITCH
PCREAT:	BLOCK	1		;STICKY CREATE SWITCH
FSWICH:	BLOCK	1		;FILE SWITCH
PSWICH:	BLOCK	1		;STICKY SWITCH
FLOG:	BLOCK	1		;LOG SWITCH
PLOG:	BLOCK	1		;STICKY LOG SWITCH
PPRGM:	BLOCK	1		;STICKY PROGRAM SWITCH
FEXIT:	BLOCK	1		;EXIT SWITCH
PEXIT:	BLOCK	1		;STICKY EXIT SWITCH
FCLOSE:	BLOCK	1		;CLOSE SWITCH
PCLOSE:	BLOCK	1		;STICKY CLOSE SWITCH
FXONLY:	BLOCK	1		;XONLY SWITCH
PXONLY:	BLOCK	1		;STICKY XONLY SWITCH
FNAME:	BLOCK	2		;NAME SWITCH
PNAME:	BLOCK	2		;STICKY NAME SWITCH
FACCT:	BLOCK	ACTLEN		;LOCAL ACCOUNT SWITCH
FACTFL:	BLOCK	1		;LOCAL ACCOUNT SWITCH SEEN
PACCT:	BLOCK	ACTLEN		;STICKY ACCOUNT SWITCH
PACTFL:	BLOCK	1		;STICKY ACCOUNT SWITCH SEEN
IPS.BL:	BLOCK	3		;IPCF SEND BLOCK
	3,,IPS.DT		;LENGTH,,ADDRESS OF DATA
IPS.DT:	BLOCK	3		;IPCF SEND DATA
IPR.BL:	BLOCK	6		;IPCF RECEIVE BLOCK

FOP.BL:	BLOCK	1		;FILOP BLOCK
FOP.MD:	UU.PHS+.IOASC		;PHYSICAL ONLY, ASCII MODE
FOP.DV:	0			;DEVICE
FOP.BH:	0			;BUFFER HEADERS
FOP.NB:	0			;NUMBER OF BUFFERS
FOP.LB:	LEB.BL			;LOOKUP/ENTER BLOCK ADDRESS
FOP.PB:	10,,PTH.BL		;WHERE TO RETURN PATH TO THE FILE
LEB.BL:	.RBAUT			;EXTENDED LOOKUP/ENTER BLOCK
LEB.PT:	LEB.PB			;ADDRESS OF PATH
LEB.FL:	0			;FILE NAME
LEB.XT:	0			;EXTENSION
LEB.AW:	0			;ATTRIBUTES WORD
LEB.SZ:	0			;SIZE
	BLOCK	.RBAUT-.RBSIZ-1	;UNINTERESTING ARGUMENTS RETURNED FROM EXTENDED LOOKUP
LEB.AT:	0			;AUTHOR OF ACCESS.USR
LEB.PB:	0			;PATH
LEB.SS:	.PTSCY			;SCAN SWITCH
LEB.PP:	0			;PPN
LEB.SF:	BLOCK	5		;SFD'S
	0			;ALWAYS TERMINATE WITH A ZERO
PTH.BL:	0			;PATH BLOCK
PTH.AW:	0			;ATTRIBUTES WORD
PTH.PP:	0			;PPN
PTH.SF:	BLOCK	5		;SFD'S
	0			;ALWAYS TERMINATE WITHA ZERO

ACS.WB:	BLOCK	.DCOWN+1	;WORKING STORAGE FOR PATH AND DSKCHR UUOS


	END	FILDAE
