	TITLE HELP %7(100) CUSP TO TYPE OUT HELPFUL DOCUMENTATION.
	SUBTTL MLB(ADR)/PFC/DIB/RDH/PLB	9-AUG-85

	SEARCH	JOBDAT,MACTEN,UUOSYM	;STANDARD DEFINTIONS
	SALL				;PRETTY LISTINGS
	.DIREC	FLBLST			;PRETTIER LISTINGS

;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1972,1974,1978,1979,1980,1984,1985,1986.
;ALL RIGHTS RESERVED.
;

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
;COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.

;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.

;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
; FOR OPERATING INSTRUCTIONS READ HELP.HLP.  THERE ARE NO SPECIAL
;  COMPILE, LOAD OR SAVE INSTRUCTIONS.
; A NULL FILENAME IS CONSIDERED TO BE HELP.HLP BY DEFAULT.
; HELP *, LISTS ALL *.HLP FILES WHICH COULD BE LISTED BY HELP FOO.


;  COLS IS NUMBER OF COLUMNS / LINE WHEN LISTING HELP *
;  DEFAULT COLS==^D8

ND	COLS,^D8

VWHO==0		;WHO LAST EDITTED
VERSIN==7	;VERSION NUMBER
VPATCH==0	;VERSION LETTER
VEDIT==100	;EDIT NUMBER
;NONE OF THE FOLLOWING ACS ARELOCATION DEPENDENT,
; THEY CAN BE MOVED TO ANY POSITION IF NECESSARY.
F=0
T=1
T1=T+1
T2=T1+1
T3=T2+1
CH=5		; CONTAINS CURRENT CHARACTER
EOL=6		; -1 IF END OF LINE SEEN. 0 OTHERWISE
STS=7		; LAST GETSTS INFO.
D=10		; COUNTS # OF NAMES PER LINE (COLUMN ROUTINE)
;11-16 ARE FREE; NOTE THAT 11-14 ARE USED IN NEW SORT ROUTINE
C1=11		;SCRATCH 1
C2=12		;SCRATCH 2
C3=13		;SCRATCH 3
LN=16		;LOGICAL NAME POINTER
P=17

;I/O CHANNELS
DSK==1
TTY==2
FIL==3

PDLSIZ==10	;LENGTH OF PUSH DOWN LIST


	TWOSEG

	LOC	137
	BYTE	(3)VWHO (9)VERSIN (6)VPATCH (18)VEDIT
	RELOC	400000



COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1972,1986. ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO




;REVISION HISTORY

;%3(34) RELEASED FEB, 1972

;35	REMOVE SPECIAL TEST FOR 175 (ALTMODE)
;36	CORRECT ERROR IN PRINTING "ILLEGAL CHAR" MESSAGE
;37	USE JOBSTS TO DETERMINE IF LOGGED IN
;40	SKIP REST OF COMMAND ON COMMAND ERRORS
;41	USE DEFAULT NUMBER OF DISK BUFFERS
;42	ADD EXPLICIT DEVICE ALLOWED
;43	HANDLE HLP:,NEW:,OLD:
;44	ADD MONITOR COMMANDS TO HELP *
;45	FIX BUG WHICH OCCASIONALLY INCLUDED ONE JUNK LINE IN HELP *
;46	ONLY LIST IN HELP * THOSE FILES WHOSE PROT. CODE ALLOWS THEM
;	TO BE PRINTED.
;47	HANDLE PHYSICAL UUOS IN HELP * SO THE LIST INCLUDES ALL THOSE
;	FILES WHICH CAN BE LISTED.
;50	TRANSLATE COMMON WORDS, EG "HELP ME" TO "HELP HELP".
;51	CHANGE TO 8 COLS PER LINE INSTEAD OF 6
;52	REMOVE LOOKUPS INTRODUCED BY 46 UNTIL CHANCE TO CODE
;	HISTORY TO MAKE SPEED ACCEPTABLE.
;53	MAKE REENTRANT
;54	EXTEND 43 TO HANDLE SYS: CORRECTLY IF /NEW ON HELP *.

;%4(54) RELEASED DEC, 1972

;55	(10-11623) HANDLE LISTS OF ONE ELEMENT
;56	REMOVE SPACE C.RET. IN SOURCE FILE ON PAGE 1
;57	(10-9710) DISCARD SEQUENCE NUMBERS IN HELP FILES
;60	ADD TTY COMMANDS TO MONITOR COMMAND LISTS
;61	ADD WATCH COMMANDS TO MONITOR COMMAND LISTS
;62	SUPPORT RUN HELP (...) STYLE COMMAND AND COMMENTS
;63	SUPPORT ERROR MESSAGE STANDARD
;64	DON'T PRINT JUNK CHARS FOR NEW 5 LETTER COMMAND AND SET TABLES
;65	CHANGE TO USE UUOSYM SYMBOLS
;66	(QARS 10-02478, 10-02495) ACCEPT ONLY DISK AS USER DEVICE.
;67	(QAR 10-02502) DONT TYPE PROTECTED FILES IF NOT LOGGED IN

;%5(67)	RELEASED ???

;70	FASTER SORTING, USE TTY WIDTH, TYPE TERMINAL TYPES TABLE
;71	USE .GTIDX TABLE TO LIST CUSTOMER GETTAB VALUES ALSO
;72	TYPE 6-CHARACTER COMMAND NAMES AGAIN
;73	TYPE OUT SET DEFAULT COMMANDS
;74	QAR 10-03930 USE CONTROLLING JOB'S PPN FOR .HLP FILE LOOKUP
;75	SPR #10-30242	RKB	12-JAN-80
;	FIX THE MONTAB ROUTINE @ NEXT2+2 TO AVOID ?ILL MEM REF AND ALSO
;	AVOID DUPLICATE ENTRIES.  FIXED A SMALL BUG @ SORT6+1.
;76	NO SPR		PLB	20-Jul-83
;	ADD THE "DOC" COMMAND.  PATH. REQUIRES 3 WORDS TO READ /NEW.
;	CHECK CORRECT BIT FOR /NEW.  SUPPORT PATH-O-LOGICAL DEVICES!!
;	REMOVED USELESS OPEN/RELEASE OF CHAN FIL. (UNUSED SINCE EDIT 52)
;77	NO SPR		NT/RDH	16-MAR-85
;	LIST BOTH SITE-SPECIFIC ("MONGEN") COMMANDS AND JOB-SPECIFIC
;	("DECLARE") COMMANDS.
;100	NO SPR		LEO	9-AUG-85
;	DO COPYRIGHTS.
;

HELP:	JFCL			;DEFEND AGAINST CCL CALL
	RESET
	RESCAN
	SETZB	EOL,FWAZER
	MOVE	T,[FWAZER,,FWAZER+1]
	BLT	T,LWAZER
	MOVE	P,[IOWD PDLSIZ,PDL]
	MOVSI	T,'HLP'		;DEFAULT DEVICE AND EXT
	MOVEM	T,DEVEXT	;STORE
	PJOB	T,		;GET MY JOB NUMBER
	MOVNS	T		;NEGATE FOR JOBSTS
	JOBSTS	T,		;GET STATUS
	  SETO	T,		;ASSUME YES
	SETO	T1,		;-1 = US
	TXNE	T,JB.ULI	;ARE WE LOGGED-IN?
	JRST	HELP0		;YES - NO FANCY TRICKERY THEN
	CTLJOB	T1,		;NO - ARE WE BEING CONTROLLED BY ANYONE?
	 SETO	T1,		;ASSUME NOT
	JUMPGE	T1,HELP02	;IF BEING CONTROLLED USE HIS (HER?) PPN
	SETO	T1,		;NOT LOGGED IN, NOT BEING CONTROLLED
	JRST	HELP04		;PRETEND WE DON'T OWN ANY FILES

HELP02:	MOVSS	T1		;JOB INDEX IN LEFT HALF
	HRRI	T1,.GTPPN	;GETTAB ARG POINTER TO
	GETTAB	T1,		;READ CONTROLLING JOB'S PPN
	 SETZ	T1,		;NO JBTPPN TABLE?
HELP04:	MOVEM	T1,USEPPN	;SET PPN TO USE FOR .HLP FILE ACCESS

HELP0:	PUSHJ	P,CHAR		;SKIP UP TO FIRST ATOM
	  JRST	DEFAULT		; SHOULDN'T SEE EOL UNTIL AFTER FIRST ATOM
	  JRST	HELP0		; OVER ANY SPACES,TABS, OR COMMAS
	MOVE	T,CH		;SAVE FOR LATER TEST
HELP1:	PUSHJ	P,CHAR		;SKIP PAST FIRST ATOM
	  JRST	DEFAULT		; NO FILNAME.
	  JRST	HELP1X		;SPACE--GO SEE IF HELP
	CAIN	CH,"("		;SEE IF START OF ARGUMENT
	JRST	HELP2		;YES--GO GET IT
	CAIN	CH,":"		;SEE IF DEVICE BEFORE NAME
	JRST	HELP0		;YES--START OVER
	JRST	HELP1
HELP1X:	TRZ	T,40		;FORCE SAVE TO UC
	CAIN	T,"H"		;SEE IF "HELP"
	JRST	HELP2		;YES--PROCEED
	CAIE	T,"D"		;CHECK FOR "DOC"
	JRST	HELP1Y		;NO SUCH LUCK
	MOVSI	T,'DOC'		;GET DEVICE AND EXT
	MOVEM	T,DEVEXT	;STORE
	JRST	HELP2		;JOIN HELP CODE
HELP1Y:	PUSHJ	P,CHAR		;NO--SKIP TO PAREN
	  JRST	DEFAULT		;IF EOL, DEFAULT
	  JRST	HELP1Y		;IF SPACE, LOOP ON
	CAIE	CH,"("		;SEE IF PAREN
	JRST	HELP1Y		;NO--LOOP ON
HELP2:	PUSHJ	P,CHAR		;AND UP TO THE SECOND ATOM.
	  JRST	DEFAULT
	  JRST	HELP2
	CAIN	CH,"("		;SEE IF PAREN
	JRST	HELP2		;YES--IGNORE
	CAIN	CH,")"		;SEE IF END OF ARG
	JRST	DEFAULT		;YES--DEFAULT
	SETZM	FILNAM		;CLEAR FILNAME
	MOVE	T,[POINT 6,FILNAM]
	MOVEI	T1,6		;ONLY LOOK AT NEXT 6 CHARS.
	JRST	HELP4

HELP3:	PUSHJ	P,CHAR		;GET A CHAR.
	  JRST	DONE		;EOL RETURN.
	  JRST	DONE		;SPACE,TAB,OR COMMA RET
HELP4:	CAIN	CH,"*"		;IS CHAR A *
	JRST	SEARCH		;USER TYPED *--WANTS LIST OF ALL INFO
	CAIN	CH,":"		;SEE IF DEVICE
	JRST	GETDEV		;YES--STORE IT AWAY
	CAIN	CH,")"		;SEE IF CLOS PAREN
	JRST	DONE		;YES--ALL DONE
	CAIL	CH,"A"+40	;LOWER CASE
	CAILE	CH,"Z"+40	;ALPHABETIC
	SKIPA			;NO.
	TRZ	CH,40		;YES MAKE IT UPPER CASE.
	CAIL	CH,"A"		;IS IT A-Z?
	CAILE	CH,"Z"
	SKIPA
	JRST	OK
	CAIL	CH,"0"
	CAILE	CH,"9"		;IS IT 0-9?
	JRST	E$$ILC		;NOPE--HE LOOSES
OK:	SUBI	CH,40		;MAKE TO SIXBIT
	SOJL	T1,HELP3
	IDPB	CH,T
	JRST	HELP3

GETDEV:	SKIPN	DEVICE		;SEE IF ALREADY A DEVICE
	SKIPN	T,FILNAM	;OR NO NAME
	JRST	E$$IDS		;YES--ERROR
	MOVEM	T,DEVICE	;OK--STORE AS DEVICE
	JRST	HELP2		;LOOP FOR MORE
;USER JUST TYPED HELP, PRETEND HE TYPED HELP HELP

DEFAULT:MOVE	T,[SIXBIT/HELP/]
	MOVEM	T,FILNAM

;READ TO END OF LINE, IF NOT ALREADY THERE
;INIT DSK FOR ASCII INPUT
;LOOKUP INFO
;INIT TTY FOR OUTPUT
;OUTPUT INFO TO TTY
DONE:	PUSHJ	P,CHAR		;NOPE.
	  JRST	DONE03		;EOL SEEN.
	  JRST	DONE		; GO LOOK FOR IT.
	JRST	DONE		;KEEP LOOKING.
DONE03:	MOVE	T1,DEVICE	;GET DEVICE TYPE
	DEVTYP	T1,		;
	  JRST	DONE3A		;ERROR--ASSUME IT'S ALL RIGHT
	ANDI	T1,77		;ISOLATE DEVICE TYPE
	CAIE	T1,.TYDSK	;IS IT A DISK?
	  JRST	E$$IDS		;NO, BOMB THE USER OFF
DONE3A:	PUSHJ	P,SETDEV	;OK--INITIALIZE FOR DEVICE
DONE05:	MOVEI	T,0		;SET ASCII MODE
	SKIPN	T1,DEVICE	;SEE IF USER DEVICE
	MOVE	T1,(D)		;SET DEVICE
	JUMPE	T1,NOINF	;NO-INFO IF NOT FOUND
	MOVEI	T2,IBUF		;POINT TO BUFFER HEADERS
DONE07:	MOVEM	T,FILBLK+.FOIOS	;SET FILOP. DEVIOS WORD
	MOVEM	T1,FILBLK+.FODEV;SET FILOP. DEVICE WORD
	MOVEM	T2,FILBLK+.FOBRH;SET FILOP. BUFFER HEADER WORD
	MOVEI	T3,LEBBLK	;ADDRESS OF LOOKUP BLOCK
	MOVEM	T3,FILBLK+.FOLEB;SET FILOP. LOOKUP WORD
; UNFORTUNATELY, THE "ON-BEHALF-OF" PPN WORKS ONLY IF [1,2], BEING THE
; OWNER OF THE FILE IS NOT SUFFICIENT. THEREFORE WE DO A CHKACC LATER
; AND IGNORE ANY POSSIBLE FILDAE PRIVILEGES
;	MOVE	T3,USEPPN	;GET FLAG/CTL-JOB'S PPN
;	MOVEM	T3,FILBLK+.FOPPN;SET FILOP. "ON-BEHALF-OF" WORD
	MOVEI	T3,.RBPRV	;LENGTH OF LOOKUP BLOCK (INCLUDE PROT)
	MOVEM	T3,LEBBLK+.RBCNT;SET IN LOOKUP BLOCK
	SETZM	LEBBLK+.RBPPN	;USE IMPLIED DIRECTORY (E.G., HLP:)
	MOVE	T3,FILNAM	;NAME OF HELP TEXT DESIRED
	MOVEM	T3,LEBBLK+.RBNAM;SET IN LOOKUP BLOCK
	MOVE	T3,DEVEXT	;GET PROPER EXTENSION
	MOVEM	T3,LEBBLK+.RBEXT;SET IN LOOKUP BLOCK
	MOVE	T3,[1B0+<DSK,,0>+.FORED]  ;FILOP. READ FUNCTION
	MOVEM	T3,FILBLK+.FOFNC;SET FILOP. FUNCTION WORD
	MOVE	T3,[.FOPPN+1,,FILBLK]  ;FILOP. ARG POINTER TO
	FILOP.	T3,		;READ HELP FILE
	 JRST	DONE7		;CAN'T READ HELP FILE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	SKIPN	C3,USEPPN	;DOING FUNNY PRIVILEGE CHECKING?
	JRST	LOOKNC		;NO, STRAIGHTFORWARD OPERATION
	LDB	C1,[POINTR LEBBLK+.RBPRV,RB.PRV]  ;YES, FILE PROTECTION
	HRLI	C1,.ACRED	;READ FILE FUNCTIONALITY
	MOVE	C2,LEBBLK+.RBPPN;OWNER OF THE FILE
	AOSE	C3		;RUNNING NOT-LOGGEG-IN?
	SOSA	C3		;NO, BEING CONTROLLED, USE HIS PPN
	TDC	C3,C2		;YES, PRETEND NO INTRINSIC ACCESS RIGHTS
	MOVEI	T3,C1		;CHKACC ARG POINTER TO
	CHKACC	T3,		;VERIFY ACCESS RIGHTS
	 SETZ	T3,		;ASSUME ACCESS ALLOWED
	AOJE	T3,DONE7	;IF ACCESS DISALLOWED, FLICK IN THIS FILE
LOOKNC:	INBUF	DSK,0		;SETUP BUFFERS
	PUSHJ	P,TTYINI	;INIT TTY
	PUSHJ	P,CRLF		;SKIP A LINE

DONE1:	PUSHJ	P,INR		;GET A CHAR
	  JRST	EXITL		;NO MORE CHARS.
	PUSHJ	P,OUTR		;OUTPUT CHAR.
	JRST	DONE1		;GO DO IT AGAIN

DONE7:	TLON	T,(UU.PHS)	;SET PHYSICAL AND TRY AGAIN
	JRST	DONE07		;LOOP BACK ONCE
	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	NOINF		;ELSE, COMPLAIN

NODEV:	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	E$$COI		;ERROR IF SO
	AOJA	D,DONE05	;ELSE, TRY NEXT IN LIST
;HERE WHEN CAN NOT FIND ANYPLACE--TRY TRANSLATION

NOINF:	SKIPE	T,OLDNAM	;SEE IF ALREADY HERE ONCE
	JRST	[MOVEM T,FILNAM	;YES--RESTORE ARGUMENT
		 JRST  E$$NIO]	;AND GIVE ERROR
	MOVE	T,[-TNAML,,TNAM-1]
	MOVE	T1,FILNAM	;GET MATCH
	MOVEM	T1,OLDNAM	;SAVE FOR LATER
NOINFL:	AOS	T		;SKIP VALUE
	CAME	T1,(T)		;SEE IF MATCH
	AOBJN	T,NOINFL	;NO--LOOP
	JUMPGE	T,E$$NIO	;DONE--SEE IF MATCHED
	MOVE	T,1(T)		;YES--GET VALUE
	MOVEM	T,FILNAM	;CHANGE ARGUMENT
	JRST	DONE03		;AND GO DO IT AGAIN

;TABLE OF PAIRS TO TRANSLATE FROM X TO Y

	DEFINE	TRANS(X,Y),<XLIST
	EXP	<SIXBIT \X\>
	EXP	<SIXBIT \Y\>
	LIST>

TNAM:
	TRANS	US,HELP
	TRANS	ME,HELP

TNAML==.-TNAM
;CHAR--GETS NEXT CHAR FROM TTY INPUT BUFFER
;	IF END OF LINE SEEN SETS EOL TO -1
;CALL:	PUSHJ	P,CHAR
;	EOL RETURN
;	SPACE,COMMA,OR TAB RETURN
;	OTHER CHARACTER RETURN

CHAR:	JUMPL	EOL,CHAR2	;RETURN IF DONE
	INCHSL	CH		;GET A CHAR FROM TTY
	  JRST	CHAR2		; IF NO CHARS LEFT CONSIDER IT EOL.
	JUMPE	CH,CHAR		;IGNORE NULL
	CAIE	CH,177		;IGNORE DELETE
	CAIN	CH,15		;IGNORE C.RET.
	JRST	CHAR		; ..
	ANDI	CH,177		;MAKE SURE IT LOOKS LIKE CHAR
	AOS	0(P)		;INCR RETURN ADDR
	AOS	0(P)		;TWICE
	CAIN	CH," "		;IS CHAR A SPACE?
	SOS	0(P)		;YES. DECR RETURN ADDR.
	CAIE	CH,"	"	;IS CHAR A TAB?
	CAIN	CH,","		;MAYBE ITS A COMMA?
	SOS	0(P)		;DECR RET ADDR IF SO.
	CAIE	CH,";"		;SEE IF COMMENT
	CAIN	CH,"!"		; OR NEW STYLE
	JRST	CHAR3		;YES--GO SKIP COMMENT
	CAIN	CH,33
	JRST	CHAR1		;YES.
	CAIG	CH,14		;IS IT VT,FF,OR LF?
	CAIGE	CH,12
	POPJ	P,		;NO.
CHAR1:	SOS	0(P)		;YES. DECR RETURN ADDR
	SOS	0(P)		;TWICE
CHAR2:	SETOI	EOL,		;SET EOL TO -1
	POPJ	P,		;AND GO AWAY.
;HERE IF COMMENT SEEN
CHAR3:	INCHSL	CH		;GET NEXT CHAR
	  JRST	CHAR1		;ALL DONE
	CAIN	CH,33		;SEE IF ESCAPE
	JRST	CHAR1		;YES--END
	CAIG	CH,14		;SEE IF VT,
	CAIGE	CH,12		; FF, OR LF?
	JRST	CHAR3		;NO--LOOP
	JRST	CHAR1		;YES--DONE
;SETDEV--INITIALIZES TO CORRECT DEFAULT LIST OF HELP DEVICES
;RETURNS WITH D POINTING TO LIST ENDED BY 0

SETDEV:	MOVEI	D,DEVLST-1	;WHERE TO PUT THIS STUFF
	PUSH	D,DEVEXT	;PUT DEFAULT DEV/EXT FIRST IN LIST
	MOVE	T,[3,,T1]	;SETUP INVESTIGATION (NEEDS 3!!)
	MOVNI	T1,-.PTFRL	;READ DEFAULT PATH
	MOVEI	T2,0		;FLAGS
	PATH.	T,		;READ CURRENT PATH
	 SETZ	T2,		;IF NOT IMPLEMENTED, RETURN DEFAULT
	TRNE	T2,PT.SNW	;SEE IF /NEW
	JRST	SETNEW		;YES, SET ALTERNATE LIST
	PUSH	D,['SYS   ']	;SET SYS NEXT
	PUSH	D,['NEW   ']	;THEN NEW
	JRST	SETDEY		;DONE

SETNEW:	PUSH	D,['NEW   ']	;SET NEW NEXT
	PUSH	D,['SYS   ']	;THEN SYS
SETDEY:	PUSH	D,['OLD   ']	;FINALLY OLD
	PUSH	D,[0]		;TERMINATE
	MOVEI	D,DEVLST	;ADDRESS OF ABOVE JUNK
	POPJ	P,		;AND RETURN


;IN--READS BYTE OF INPUT FROM DSK, BYTE SIZE DEPENDS ON
; MODE DISK INITED IN, FOR *.HLP FILE 7 BIT ASCII, FOR
; TXTDIR.UFD FILE 36 BIT BINARY.
;
;CALL	PUSHJ	P,INR
;	EOF RETURN
;	NORMAL RETURN
; BYTE IS RETURNED IN CH.
; THERE IS NO RETURN ON AN ERROR.

INR:	SOSGE	IBUF+2		;ANY CHARS LEFT IN BUFFER
	JRST	IN1		;NOPE.
	MOVE	CH,IBUF+1	;GET BYTE POINTER
	TLNN	CH,(70B11)	;SEE IF BINARY
	JRST	IN2		;NO--GO LOOK FOR SEQ NUMBS
	ILDB	CH,IBUF+1	;YES--GO GET IT
IN0:	AOS	(P)		;AND INCR RET ADDR
	POPJ	P,		;RETURN.
IN1:	IN	DSK,		;GET NEW BUFFER.
	  JRST	INR		;GO BACK, GET CHAR
	GETSTS	DSK,STS		;SOMETHING GOOFED--FIND OUT WHAT
	TRNE	STS,IO.ERR	;CHECK FOR ERROR BITS.
	JRST	E$$IDE		;YES ERROR--GIVE UP.
	TRNN	STS,IO.EOF	;EOF?
	JRST	E$$HBS		;NOT ERROR BITS OR EOF--CAN NEVER GET HERE
	POPJ	P,		;EOF RETURN
IN2:	IBP	IBUF+1		;ASCII MODE--ADVANCE POINTER
	MOVE	CH,@IBUF+1	;GET THIS WORD
	TRNN	CH,1		;SEE IF SEQUENCED
	JRST	IN3		;NO--JUST RETURN NEXT CHAR
	AOS	IBUF+1		;YES--ADVANCE 6 CHARS
	MOVNI	CH,5		;ALSO COUNTER
	ADDM	CH,IBUF+2	; ..
	JRST	INR		;AND TRY AGAIN
IN3:	LDB	CH,IBUF+1	;GET BYTE OF DATA
	JRST	IN0		;AND RETURN IT
;TTYINI-INIT TTY FOR OUTPUT.
;CALL	PUSHJ	P,TTYINI
;	NORMAL RETURN
; NEVER RETURNS IF ANY ERROR.

TTYINI:	INIT	TTY,.IOASL
	  SIXBIT /TTY/
	  XWD	OBUF,0
	  JRST	E$$COO		;NEVER GET HERE--I HOPE
	OUTBUF	TTY,0
	MOVE	T1,[2,,T2]	;POINTER FOR TRMOP.
	MOVEI	T2,.TOWID	;TO READ TTY WIDTH
	MOVEI	T3,TTY		;OUTPUT CHANNEL
	IONDX.	T3,		;GET TTY'S UDX
	 CAIA			;???
	TRMOP.	T1,		;READ TTY WIDTH
	 MOVEI	T1,COLS*^D8	;USE DEFAULT IF NOT TTY
	IDIVI	T1,^D8		;CONVERT TO NUMBER OF TAB COLUMS
	MOVEM	T1,NUMCOL	;SAVE FOR TYPEOUT ROUTINES
	POPJ	P,

;OUT--OUTPUTS BYTE TO TTY.  CALLED WITH BYTE IN CH.
;TAB--OUTPUTS TAB TO TTY.
;CRLF-OOUTPUTS CR-LF SEQUENCE TO TTY.
;
;CALL	PUSHJ	P,<ROUTINE>
;	NORMAL RETURN
; THERE IS NO RETURN ON ANY ERROR.

CRLF:	MOVEI	CH,.CHCRT
	PUSHJ	P,OUTR
	MOVEI	CH,.CHLFD
	PUSHJ	P,OUTR
	POPJ	P,

TAB:	MOVEI	CH,.CHTAB		;PUT OUT TAB.

OUTR:	SOSG	OBUF+2		;ROM FOR ONE MORE?
	JRST	OUT1		;NO--GO MAKE ROOM
	IDPB	CH,OBUF+1	;YES--PUT IT THERE
	POPJ	P,		;AND RETURN?
OUT1:	OUT	TTY,		;OUTPUT A BUFFER
	  JRST	OUTR		;GO TRY NOW
	GETSTS	TTY,STS		;SOMETHING WENT WRONG--GET STATUS
	TRNN	STS,IO.ERR	;ERROR?
	JRST	E$$HBS		;SHOULDN'T GET HERE
	JRST	E$$ODE		;LEGIT. ERROR  TELL USER.
; SEARCH--TYPE OUT LIST OF ALL AVAILABLE *.HLP FILES
;  IN HELP'S DIRECTORY.
;	FIRST  READ PAST END OF COMMAND
;	LOOKUP DIRECTORY--COMPUTE SIZE OF PDL
;	  NEEDED.
;	READ DIRECTORY FOR ALL *.HLP FILES, PUT NAMES FOUND
;	  AT .JBFF
;	SORT LIST
;	TYPE OUT LIST.

SEARCH:	PUSHJ	P,CHAR		;READ TO END OF COMMAND
	  JRST	S0
	  JRST	SEARCH
	JRST	SEARCH		;KEEP LOOKING.
S0:	PUSHJ	P,TTYINI	;SETUP TTY
	PUSHJ	P,SETDEV	;SETUP DEFAULT DEVICE LIST
	MOVE	T,.JBFF		;SAVE INITIAL
	MOVEM	T,SAVFF		; .JBFF
	MOVEI	F,0		;CLEAR COUNT
S0A:	TLZ	F,(UU.PHS)	;CLEAR PHYS BIT
	MOVEI	T,.IOBIN	;SET FOR BINARY MODE
S0B:	MOVEM	T,IOMODE	;STORE I/O MODE
	SKIPN	T1,DEVICE	;GET USER DEVICE IF ANY
	MOVE	T1,(D)		;ELSE GET NEXT DEFAULT
	JUMPE	T1,S2A		;EXIT WHEN ALL DONE
	PUSHJ	P,SRHLNM	;GO TRY THIS DEVICE

; TRANSPLANTED (USED TO BE LABEL S2)
	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	S2A		;YES--ALL DONE
	TLOE	F,(UU.PHS)	;SET/TEST FLAG FOR PHYSICAL
	AOJA	D,S0A		;LOOP OVER ALL DEVICES
	MOVE	T,(D)		;REFETCH DEVICE NAME
	DEVNAM	T,		;GET PHYSICAL NAME
	 TRNA
	  CAMN	T,(D)		;SEE IF SAME
	   AOJA	D,S0A		;YES
	MOVE	T,[UU.PHS+.IOBIN]   ;NO--TRY AGAIN, PHYSICAL
	JRST	S0B		;AS WELL
SRHLNM:	MOVEM	T1,LNMBLK+.PTLNM ;STORE DEVICE
	DMOVE	T2,[EXP .PTFRN, PT.RCN]	;PATH. FUNCTION
	DMOVEM	T2,LNMBLK	;STORE
	MOVE	T1,[.PTLLB,,LNMBLK] ;POINT TO FUNCTION BLOCK
	SETZ	T,		;ASSUME NOT PHYSICAL
	TLNE	F,(UU.PHS)	;UNTIL PROVEN
	 MOVEI	T,UU.PHY	;OTHERWISE
	PATH.	T1,(T)		;READ LOGICAL NAME
	 JRST	SL.PTH		;COULDN'T, TRY NORMAL PATH.
SL.LNM:	MOVEI	LN,LNMBLK+.PTLSB ;POINTER TO FIRST GROUP
SL.LN2:	MOVEI	T1,<.PTSTR-.PTPPN+.PTLPP>(LN) ;POINTER TO "PATH" BLOCK
	SKIPN	T2,.PTLSL(LN)	;GET STRUCTURE NAME
	 POPJ	P,		;NONE, END OF THIS NAME
	PUSHJ	P,SRHOPN	;OPEN AND READ IT
	MOVEI	LN,.PTLSF(LN)	;ADVANCE POINTER TO 1ST SFD
SL.LN3:	SKIPE	(LN)		;ZERO?
	 AOJA	LN,SL.LN3	;NO, ADVANCE
	AOJA	LN,SL.LN2	;POINT TO "NODE"

SL.PTH:	MOVE	T1,LNMBLK+.PTLNM ;GET NAME BACK
	MOVEM	T1,LNMBLK+.PTFCN ;STORE AS FUNCTION
	MOVE	T1,[.PTMAX+1,,LNMBLK] ;POINT TO STD PATH
	PATH.	T1,(T)		;READ NORMAL PATH.
	  JRST	S.PPN		;NORMAL PATH. LOSSES!
	MOVEI	T1,LNMBLK	;GET POINTER TO PATH
	MOVE	T2,LNMBLK+.PTSTR ;GET PATH STRUCTURE
	PJRST	SRHOPN		;GO DO THE OPEN

S.PPN:	MOVE	T1,LNMBLK+.PTFCN ;GET DEVICE BACK
	MOVE	T2,T1		;COPY DEVICE
	DEVPPN	T1,(T)		;PERHAPS ERSATZ?
	 TRNA			;NO, GET SYS:
	  PJRST	SRHOPN		;YES, READ DIR
	MOVE	T1,[%LDSYS]	;NOT ERSATZ!!
	GETTAB	T1,		;ASK MONITOR FOR SYS:
	  MOVE	T1,[1,,1]	;MUST BE ANCIENT
;;	PJRST	SRHOPN		;GO OPEN DIR

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

SRHOPN:	MOVEI	T3,IBUF		;INPUT BUFFER HEADER
	DMOVEM	T2, IOMODE+.OPDEV ;STORE OPEN DEVICE
	OPEN	DSK,IOMODE	;OPEN DEVICE
	  JRST	NODSKS		;GIVE UP.
	MOVE	T2,SAVFF	;GET ORIGINAL .JBFF
	EXCH	T2,.JBFF	;RESTORE FOR BUFFERS
	INBUF	DSK,0
	CAMLE	T2,.JBFF	;IF FIRST TIME,
	MOVEM	T2,.JBFF	; RESTORE UPDATED VALUE
	TLNE	T1,-1		;FULL PATH OR JUST PPN?
	 PJRST	SO.UFD		;JUST PPN
	MOVEM	T1,FILNAM+3	;STORE PATH PTR
	MOVEI	T2,.PTSFD(T1)	;POINTER TO SFDS
	SKIPN	T1,.PTPPN(T1)	;GET PPN
	 POPJ	P,		;NOT SO FAST
	SKIPN	(T2)		;ANY SFDS?
	 PJRST	SO.UFD		;NO, OPEN UFD
SO.LOP:	SKIPE	1(T2)		;MORE SFDS?
	 AOJA	T2,SO.LOP	;LOOP TILL END
	MOVE	T1,(T2)		;GET LAST SFD NAME
	SETZM	(T2)		;ZERO IT
	PUSH	P,T1		;SAVE SFD NAME
	PUSH	P,T2		;AND ADDR
	MOVSI	T2,'SFD'	;GET EXT
	PUSHJ	P,SO.LKP	;GO DO LOOKUP
	POP	P,T2		;RESTORE SFD ADDR
	POP	P,(T2)		;RESTORE SFD NAME
	POPJ	P,

SO.UFD:	MOVE	T2,[%LDMFD]	;
	GETTAB	T2,		;
	  MOVE	T2,[XWD 1,1]	;
	MOVEM	T2,FILNAM+3	;STORE PATH
	MOVSI	T2,'UFD'	;.UFD
SO.LKP:	DMOVEM	T1,FILNAM	;STORE NAME & EXT
	SETZM	FILNAM+2	;
	LOOKUP	DSK,FILNAM	;LOOKUP DIRECTORY FILE
	  JRST	NOUFD		;WE TRIED.

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;READ DIRECTORY
S1:	PUSHJ	P,INR
	  POPJ	P,		;DONE!
	MOVE	T,CH
	PUSHJ	P,INR
	JRST	E$$HBS		;PRETEND EOF WILL NEVER OCCUR HERE.
	HLLZ	CH,CH		;JUST GET EXT
	CAME	CH,DEVEXT	;CHECK IT
	JRST	S1		; NOT A *.HLP FILE KEEP LOOKING.
	MOVE	T1,DEVEXT	;SET IN EXTENSION
	SETZB	T2,T3		;CLEAR DIRECTORY
	PUSHJ	P,STOR		;SAVE NAME
	JRST	S1		;AND LOOP

NOUFD:	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	E$$CLD		;YES--HE IS IN TROUBLE
NODSKS:	SKIPE	DEVICE		;SEE IF USER DEVICE
	JRST	E$$COI		;YES--ERROR
	POPJ	P,

S2A:	RELEAS	DSK,		;FREE CHANNEL

	JUMPE	F,MONCMD	;SKIP ON IF NOTHING!
	PUSHJ	P,SORT		;ELSE GO SORT LIST

	MOVEI	D,[ASCIZ/
HELP is available for the following:/]
	HLRZ	T1,DEVEXT	;GET DEVICE
	CAIE	T1,'HLP'	;NOT DOC?
	MOVEI	D,[ASCIZ/
DOCumentation is available for the following:/] ;GET DOC HEADER
	PUSHJ	P,HEAD		;OUTPUT HEADING AND LIST

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

MONCMD:	MOVEI	T,.GTCOM	;POINT TO COMMAND TABLE
	MOVEI	D,[ASCIZ /
The monitor has the following commands:/]
	PUSHJ	P,MONTAB	;GET AND OUTPUT A TABLE

	MOVEI	T,.GTCCM	;POINT TO CUSTOMER SPECIFIC COMMANDS
	MOVEI	D,[ASCIZ /
The monitor has the following site-specific commands:/]
	PUSHJ	P,MONTAB	;LIST "MONGEN" COMMANDS

	MOVEI	D,[ASCIZ /
The monitor has the following job-specific commands:/]
	PUSHJ	P,DCLTAB	;LIST "DECLARE" COMMANDS

	MOVEI	T,.GTCM2	;POINT TO SET COMMAND TABLE
	MOVEI	D,[ASCIZ /
The monitor has the following SET commands:/]
	PUSHJ	P,MONTAB	;GET AND OUTPUT THE TABLE

	MOVEI	T,.GTDCN	;POINT TO SET DEFAULT COMMANDS TABLE
	MOVEI	D,[ASCIZ/
The monitor has the following SET DEFAULT commands:/]
	PUSHJ	P,MONTAB	;GET AND OUTPUT THE TABLE

	MOVEI	T,.GTCMT	;POINT TO TTY COMMAND TABLE
	MOVEI	D,[ASCIZ /
The monitor has the following SET TTY commands:/]
	PUSHJ	P,MONTAB	;GET AND OUTPUT TABLE

	MOVEI	T,.GTTNM	;TERMINAL TYPES TABLE
	MOVEI	D,[ASCIZ/
The monitor supports the following terminal types:/]
	PUSHJ	P,MONTAB	;LIST TERMINAL TYPES

	MOVEI	T,.GTCMW	;POINT TO WATCH TABLE
	MOVEI	D,[ASCIZ /
The monitor has the following SET WATCH commands:/]
	PUSHJ	P,MONTAB	;GET AND OUTPUT TABLE

	JRST	EXITL		;GO FINISH UP
;MONTAB -- ROUTINE TO GET A MONITOR TABLE, SORT IT, AND LIST IT
;CALL:	MOVSI	T,TABLE NUMBER (MUST BE IN SIXBIT)
;	MOVE	D,[POINT 7,ASCIZ STRING FOR HEADING]
;	PUSHJ	P,MONTAB

MONTAB:	MOVE	T1,SAVFF	;RESTORE .JBFF
	MOVEM	T1,.JBFF	; ..
	PUSH	P,T		;SAVE GETTAB TABLE NUMBER
	MOVS	T2,T		;TABLE NUMBER AS INDEX
	HRRI	T2,.GTIDX	;TO SEE WHERE TABLE STARTS
	GETTAB	T2,		;(IN CASE CUSTOMER-DEFINED ENTRIES)
	 SETZ	T2,		;DO IT THE OLD WAY - START AT 0
	HLRE	T2,T2		;T2:=STARTING INDEX FOR TABLE SEARCH
	MOVEI	F,0		;CLEAR COUNT

MONTB1:	MOVS	T1,T2		;GET NEXT INDEX
	HRR	T1,0(P)		;INSERT TABLE NUMBER
	GETTAB	T1,		;READ THIS TABLE ENTRY
	  JRST	PRMTAB		;DONE - PRINT THE TABLE
	MOVEI	T,0		;CLEAR AC
	LSHC	T,6		;GET FIRST CHAR
	CAIN	T,'.'		;SEE IF STARTS WITH PERIOD
	SETZB	T,T1		;YES--CLEAR COMMAND
	LSHC	T,^D30		;REPOSITION COMMAND
	PUSHJ	P,STOR		;SAVE AWAY
	AOJA	T2,MONTB1	;INCREMENT ENTRY AND TRY AGAIN



;STOR--ROUTINE TO ADD ENTRY TO LIST
;CALL:	MOVE	T,ENTRY
;	PUSHJ	P,STOR

STOR:	JUMPE	T,CPOPJ		;RETURN IF BLANK ENTRY
	MOVE	T1,.JBFF	;SEE IF ENOUGH CORE
	CAMLE	T1,.JBREL	; ..
	JRST	[CORE	T1,	; NO--GET MORE
		   JRST	E$$CLE	;GIVE UP IF NO MORE TO BE HAD
		 JRST	.+1]
	MOVEM	T,@.JBFF	;STORE NAME
	AOS	.JBFF		;AND ADVANCE POINTER
	AOS	F		;COUNT RESULT
CPOPJ:	POPJ	P,		;RETURN
;DCLTAB -- ROUTINE TO GET AND PRINT "DECLARE" COMMANDS (ANALGUOS TO MONTAB)
;CALL:	MOVEI	D,<ADR>	;ASCIZ STRING TO PREFIX TABLE (IF EXTANT)
;	PUSHJ	P,DCLTAB

DCLTAB:	MOVE	T1,SAVFF	;PERMANENT COPY OF .JBFF
	MOVEM	T1,.JBFF	;RESTORE .JBFF
	MOVEI	T2,40		;STARTING SIZE FOR READING COMMANDS
DCLTA2:	MOVE	T1,T2		;SIZE OF BUFFER
	ADD	T1,.JBFF	;PROPOSED END OF BUFFER
	CAMLE	T1,.JBREL	;ENOUGH SPACE ALREADY?
	JRST	[CORE	T1,		;ASK FOR MORE ROOM
		  JRST	E$$CLE		;FAILED, GO COMPLAIN
		JRST	.+1]		;CONTINUE
	MOVEM	T2,@.JBFF	;SET "LENGTH" OF BUFFER
	MOVSI	T1,.CMLST	;"LIST" COMMANDS FUNCTION
	HRR	T1,.JBFF	;ADDRESS OF ARG BLOCK
	MOVE	T3,T1		;SAVE A COPY FOR ERROR RETURN
	CMAND.	T1,		;GET THE LIST OF USER-DEFINED COMMANDS
	 JRST	[LSH	T2,1		;INCREMENT THE BUFFER SIZE
		CAIN	T1,CMDNF%	;WAS BUFFER TOO SHORT?
		JRST	DCLTA2		;YES, TRY WITH A BUGGER BIFFER
		CAMN	T1,T3		;UUO NOT IMPLEMENTED?
		POPJ	P,		;NO SUCH UUO, ERGO NO SUCH PRINTOUT
		JRST	E$$DCL]		;REAL UUO ERROR, GO COMPLAIN
	MOVE	F,@.JBFF	;.CMSIZ = COUNT OF RETURNED COMMANDS
	ADDM	F,.JBFF		;ADVANCE .JBFF TO END OF BUFFER FOR SORT
	AOS	.JBFF		;(THE REAL END OF THE BUFFER)
	PJRST	PRITAB		;GO LIST THE BUFFER
;PR?TAB -- ROUTINE TO SORT AND PRINT TABLE RESULTS FROM MONTAB/ETC.

PRMTAB:	POP	P,T2		;ADJUST STACK
PRITAB:	JUMPE	F,CPOPJ		;RETURN IF NOTHING
	PUSHJ	P,SORT		;GO SORT TABLE
				;FALL INTO "OUTPUT THE WHOLE THING"


;HEAD -- ROUTINE TO OUTPUT HEADING AND THEN LIST
;CALL:	MOVE	D,[POINT 7,ASCIZ STRING]
;	PUSHJ	P,HEAD

HEAD:	TLOA	D,(POINT 7,)	;MAKE INTO BYTE POINTER
HEAD1:	PUSHJ	P,OUTR
	ILDB	CH,D
	JUMPN	CH,HEAD1
NEWLIN:	PUSHJ	P,CRLF
	MOVE	D,NUMCOL	;GET NUMBER OF TAB SUBCOLUMNS
	SKIPA
NEXT:	PUSHJ	P,TAB
	MOVE	T3,(T)
NEXT1:	MOVEI	T2,0
	LSHC	T2,6
	MOVEI	CH,40(T2)
	PUSHJ	P,OUTR
	JUMPN	T3,NEXT1
NEXT2:	AOBJP	T,CRLF		;LOOP FOR WHOLE TABLE
	MOVE	T3,(T)		;GET NEXT ITEM
	CAMN	T3,-1(T)	;COMPARE WITH PREVIOUS ONE
; PLACED A "-" SIGN IN THE ABOVE LINE OF CODE:  IT WAS NEGLECTED BEFORE.
	JRST	NEXT2		;SAME--SKIP PRINTING
	SOJG	D,NEXT
	JRST	NEWLIN
	SUBTTL	SORT AN ARRAY INTO INCREASING ORDER

;NEW SORT ROUTINE, GRATEFULLY STOLEN FROM LLN
;
;SORT - SORT AN ARRAY INTO INCREASING ORDER
;CALL IS:
;
;	.JBFF/	END OF ARRAY + 1
;	F/	LENGTH OF ARRAY
;
;	PUSHJ	P,SORT
;	RETURN
;
;THE ALGORITHM USED HERE IS A HEAPSORT ALGORITHM, TAKEN DIRECTLY FROM
;DONALD KNUTH, THE ART OF COMPUTER PROGRAMMING, VOL. 3, SORTING AND
;SEARCHING, PP. 145-149.  THE USER IS REFERRED TO THAT VOLUME FOR
;MORE THOROUGH DOCUMENTATION ON THE METHOD.
;
;RETURNS WITH T:=AOBJN POINTER TO SORTED TABLE
;
;NOTE THAT ACS 11-14 ARE USED, AS WELL AS F AND T1-T3

;AC'S ARE NAMED DIFFERENTLY HERE TO CORRESPOND TO THE VARIABLES USED
;IN KNUTH'S ALGORITHM, PP. 147-147 OF VOLUME MENTIONED ABOVE.

TEMP==	F
ADDR==	T1
R==	T2
L==	T3
RCAP==	11
K==	12
I==	13
J==	14
AC==	15

;THE CODE THAT FOLLOWS IS GRATEFULLY STOLEN FROM LLN.
;CAN'T DO MUCH BETTER WITHOUT RECURSION

SORT:	MOVE	R,F		;LENGTH OF ARRAY
	MOVE	ADDR,.JBFF	;ADDRESS + 1 OF END
	SUBI	ADDR,1(R)	;ADDR:=ADDRESS OF ARRAY (MINUS ONE)
	MOVN	T,R		;NEGATIVE LENGTH FOR AOBJN
	MOVS	T,T		;COUNT IN L.H.
	HRRI	T,1(ADDR)	;ADDRESS IN R.H.
	MOVEI	L,(R)		;INITIALIZE
	CAIG	R,1		;CHECK INDEX
	POPJ	P,		;RETURN IF INVALID, OR =1
	LSH	L,-1		;L=N/2
	AOJ	L,
SORT2:	CAIG	L,1		;DECREASE L OR R
	JRST	SORT9
	SOJ	L,		;L POINTS TO FIRST UNCHECKED NODE
	HRLI	ADDR,L
	MOVE	RCAP,@ADDR	;GET THAT ENTRY
SORT3:	MOVEI	J,(L)		;PREPARE FOR SIFT-UP
SORT4:	MOVEI	I,(J)		;ADVANCE DOWNWARD
	LSH	J,1		;J POINTS TO FIRST SON
	CAMN	J,R
	JRST	SORT6		;JUMP IF LAST ENTRY
	CAML	J,R
	JRST	SORT8		;J TOO HIGH--JUMP
	HRLI	ADDR,J		;FIND "LARGER" SON
	MOVE	TEMP,@ADDR
	AOJ	J,
	MOVE	AC,TEMP		;GET A COPY OF TEMP
	PUSHJ	P,CAML36	;DO A 36-BIT UNSIGNED "CAML AC,@ADDR"
	SOJ	J,
SORT6:	HRLI	ADDR,J		;LARGER THAN RCAP?
	MOVE	AC,RCAP		;GET A COPY OF RCAP
	PUSHJ	P,CAML36	;DO THE "CAML AC,@ADDR"
	JRST	SORT8
	HRLI	ADDR,J		;MOVE IT UP
	MOVE	TEMP,@ADDR
	HRLI	ADDR,I
	MOVEM	TEMP,@ADDR
	JRST	SORT4
SORT8:	HRLI	ADDR,I		;STORE R
	MOVEM	RCAP,@ADDR
	JRST	SORT2
SORT9:	HRLI	ADDR,R		;HAVE A HEAP NOW
	MOVE	RCAP,@ADDR
	MOVE	TEMP,1(ADDR)
	MOVEM	TEMP,@ADDR
	SOJ	R,
	CAILE	R,1
	JRST	SORT3
	MOVEM	RCAP,1(ADDR)
	POPJ	P,
;  HERE TO DO A "CAML AC,@ADDR"

CAML36:	MOVE	K,@ADDR		;GET A COPY OF @ADDR
	TXC	K,1B0		;TOGGLE SIGN-BIT ON EACH NUMBER
	TXC	AC,1B0		;
	CAMGE	AC,K		;DO THE COMPARISON
	AOS	(P)		;GIVE SKIP-RETURN
	POPJ	P,		;



EXITL:	PUSHJ	P,CRLF
EXITR:	RELEAS	TTY,
EXITRL:	PUSHJ	P,CHAR
	  JRST	EXITRX
	  JRST	EXITRL
	JRST	EXITRL
EXITRX:	RESET
	AOSN	USEPPN		;LOGGED IN?
	JRST	KJOB		;NO, GO COMMIT SUICIDE
	EXIT	1,		;YES, EXIT QUIETLY
	JRST	.-1		;AND STAY EXITED

KJOB:	OUTSTR	[ASCIZ/
.KJOB
./]				;NO. MAKE SURE HE KNOWS IT
	LOGOUT
;ERROR AND WARNING MESSAGES

E$$ILC:	PUSHJ	P,ERRMSG
	  'ILC',,"%"
	  EXITX,,[ASCIZ/Illegal char: "/]
	CAIGE	CH,40
	JRST	[OUTSTR	[ASCIZ /^/]
		 ADDI	CH,100
		 JRST	.+1]
	OUTCHR	CH
	OUTSTR	[ASCIZ/", for HELP type HELP/]
	JRST	EXITX

;POSSIBLE WAYS TO GOOF,
;  IN OR OUT FAILED WITHOUT ANY 74B23 BITS SET.
;  READ FILNAME BUT NOT EXTENSION OUT OF A DIR BLOCK.
; NOTE THAT NONE OF THESE SHOULD EVER HAPPEN.
E$$HBS:	PUSHJ	P,ERRMSG
	  'HBS',,"?"
	  EXITX,,[ASCIZ/Horrible bug somewhere..../]
	JRST	EXITR

E$$NIO:	PUSHJ P,ERRMSG
	  'NIO',,"%"
	  EXITX,,[ASCIZ/No information is currently available on "/]
	MOVE	T1,FILNAM
NOINF1:	MOVEI	T,0
	LSHC	T,6
	ADDI	T,40
	OUTCHR	T		;PRINT IT.
	JUMPN	T1,NOINF1
	OUTSTR	[ASCIZ /"
/]
	JRST	EXITR		;ALL DONE.

E$$IDE:	PUSHJ	P,ERRMSG
	  'IDE',,"?"
	  EXITX,,[ASCIZ/Input error /]
	JRST	TYPSTS

E$$ODE:	PUSHJ	P,ERRMSG
	  'ODE',,"?"
	  EXITX,,[ASCIZ/Output error /]
TYPSTS:	HRLZ	T1,STS
	MOVEI	F,6
TYPST1:	MOVEI	T,0
	LSHC	T,3
	ADDI	T,"0"
	OUTCHR	T
	SOJG	F,TYPST1
	JRST	EXITX
E$$IDS:	PUSHJ	P,ERRMSG
	  'IDS',,"?"
	  EXITX,,[ASCIZ /Illegal device specification in command/]
	JRST	EXITX

E$$COO:	PUSHJ	P,ERRMSG
	  'COO',,"?"
	  EXITX,,[ASCIZ/Can't OPEN output device/]
	JRST	EXITX

E$$COI:	PUSHJ	P,ERRMSG
	  'COI',,"?"
	  EXITX,,[ASCIZ/Can't OPEN input device/]
	JRST	EXITX

E$$CLD:	PUSHJ	P,ERRMSG
	  'CLD',,"?"
	  EXITX,,[ASCIZ/Can't LOOKUP directory/]
	JRST	EXITX

E$$CLE:	PUSHJ	P,ERRMSG
	  'CLE',,"?"
	  EXITX,,[ASCIZ/Core limit exceeded/]
EXITX:	OUTSTR	[ASCIZ /
/]
	JRST	EXITR

E$$DCL:	PUSHJ	P,ERRMSG
	  'DCL',,"?"
	  EXITX,,[ASCIZ/Can't read DECLARE commands/]
	JRST	EXITX
;ERROR MESSAGE PREFIX PRINTER

ERRMSG:	MOVE	T2,(P)		;POINT TO ANSWERS
	AOS	(P)		;ADVANCE RETURN
	AOS	(P)		;ADVANCE RETURN
	OUTCHR	(T2)		;OUTPUT PREFIX CHARACTER
	HRRZ	T1,(T2)		;GET CHARACTER
	CAIN	T1,"?"		;SEE IF ?
	CLRBFI			;YES--CLEAR INPUT BUFFER
	HRROI	T3,.GTWCH	;WATCH TABLE
	GETTAB	T3,		;GET IT
	  MOVEI	T3,0		;ZERO IF MISSING
	TLNN	T3,(JW.WMS)	;SEE IF SET
	TLO	T3,(JW.WFL+JW.WPR)	;NO--SET TO PREFIX,LINE
	MOVE	T1,DEVEXT	;SET OUR PREFIX
	HLR	T1,(T2)		;GET MESSAGE CODE
	TLNE	T3,(JW.WPR)	;SEE IF PREFIX SUPPRESSED
	PUSHJ	P,TYPSIX	;TYPE IN SIXBIT
	OUTSTR	[ASCIZ / /]
	HRRZ	T1,1(T2)	;GET ADDRESS OF TEXT
	TLNE	T3,(JW.WCN+JW.WFL)	;SEE IF COMMENTARY
	OUTSTR	@T1		;YES--DO IT
	HLRZ	T1,1(T2)		;GET NOMESSAGE ADDRESS
	TLNN	T3,(JW.WCN+JW.WFL)	;SEE IF REST
	HRRM	T1,(P)		;YES--RETURN THERE INSTEAD
	POPJ	P,		;RETURN

TYPSIX:	MOVEI	T,0		;CLEAR NEXT CHAR
	LSHC	T,6		;POSITION IT
	ADDI	T,40		;MAKE ASCII
	OUTCHR	T		;OUTPUT IT
	JUMPN	T1,TYPSIX	;LOOP UNTIL DONE
	POPJ	P,		;RETURN
	XLIST	;LITERALS
	LIT
	LIST

	RELOC	;SWITCH TO LOW SEG


;STORAGE AREA

FWAZER:!			;START OF AREA TO ZERO
OLDNAM:	BLOCK	1
SAVFF:	BLOCK	1
NUMCOL:	BLOCK	1		;NUMBER OF TAB SUB-COLUMNS
DEVICE:	BLOCK	1
FILNAM:	BLOCK	4
IBUF:	BLOCK	3
OBUF:	BLOCK	3
PDL:	BLOCK	PDLSIZ
USEPPN:	BLOCK	1		;.LT. 0 THEN NOT LOGGED IN
				;.EQ. 0 THEN LOGGED IN AS USER JOB
				;.GT. 0 NOT LOGGED IN, CTL JOB'S PPN
FILBLK:	BLOCK	<.FOPPN+1>	;FILOP. BLOCK
LEBBLK:	BLOCK	<.RBPRV+1>	;EXTENDED FILOP. LOOKUP BLOCK
NEXTPC:	BLOCK	1		;SAVED PC IN PATH. COROUTINE
DEVEXT:	BLOCK	1		;DEVICE AND EXT TO USE
LNMBLK:	BLOCK	.PTLLB		;PATH BLOCK FOR LOGICAL NAMES
IOMODE:	BLOCK	3		;OPEN BLOCK FOR UFD/SFD
SFDPTH:	BLOCK	.PTMAX		;PATH FOR .SFD OPEN

DEVLST:	BLOCK	1		;DEFAULT DEVEXT
	BLOCK	1		;SYS OR NEW
	BLOCK	1		;NEW OR SYS
	BLOCK	1		;OLD
	BLOCK	1		;0

LWAZER==.-1	;END


	END	HELP
